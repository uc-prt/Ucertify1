
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, C as validate_each_argument, v as validate_slots, o as onMount, A as AH, L as beforeUpdate, y as language, w as writable, X as XMLToJSON, M as JSONToXML, _ as onUserAnsChange, a9 as afterUpdate, z as empty, n as insert_dev, x as detach_dev, c as create_component, f as space, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, j as attr_dev, k as add_location, K as destroy_each, l as set_style, r as group_outros, u as check_outros, q as listen_dev, G as prop_dev, H as run_all, B as noop, h as text } from './main-f041e104.js';
import { I as ItemHelper } from './ItemHelper-7e8c9584.js';
import { G as GriddedHelper } from './GriddedHelper-bde7a853.js';

/* clsSMGridded\GriddedPreview.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMGridded\\GriddedPreview.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-vscbpc-style";
	style.textContent = ".layoutHeading{font-weight:bold;font-size:16px;color:#1877b1}.items_element:hover{border:1.2px solid #777}.moreOptions{-webkit-box-shadow:3px 4px 6px #c4c5c5;-moz-box-shadow:3px 4px 6px #c4c5c5;box-shadow:3px 4px 6px #c4c5c5;background-color:#f0f0f0;border-top:1px solid #1877b1;border-bottom:1px solid #1877b1}.moreOptionDetails{background-color:#f7f7f7}.input_col{position:relative;left:5px}.layoutheading{padding:5px;font-size:20px;font-weight:bold}.numbr_range{position:relative;left:130px}.numbr_range_txt{position:relative;left:200px}.plus_minus_fraction{position:relative;top:20px}.floating_fraction{position:relative;top:27px}.plus_minus_span{position:relative;left:5px}.floating_decimal{float:right;margin-right:45px}.fontStyle{width:100px;float:right;margin-right:60px}.fraction_slash{position:relative;left:177px}.minus_tab,\r\n    .plus_tab,\r\n    .slash_tab{text-align:center}.gridded_tab{background-color:#f0f0f0!important;user-select:none!important;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.font_size_label{position:relative;left:198px}.font_size{position:relative;left:225px}.decimal_col{position:relative;left:208px;width:90px}.correct_color{background-color:#E9FFE9}.fixed_decimal_check{position:relative;top:26px;left:13px}.correct_incorrect_icon_fill{position:relative;width:19px;height:19px;right:121px;top:-55px;background:white;border-radius:50%}.row_column_decimal{position:relative;top:30px;left:5px}.fixed_point_class{position:relative;left:7px}.row_column{position:relative;left:5px}.answer_icon{position:absolute;top:7px;right:34px}.myP tbody{cursor:pointer}.col_range{width:205px}.posSize{position:relative;left:7px}.fontSmall{font-size:12px;text-align:center}.fontNormal{font-size:14px;text-align:center}.fontLarge{font-size:24px;text-align:center}.fontExtraLarge{font-size:26px;text-align:center}.grid{position:relative;top:10px;box-shadow:10px 5px 10px #000}.items_element{border:1px solid #8080807a;padding:6px 10px;border-radius:50%;background-color:white}.griddedModule .active{color:white;transition:1s;background:#696969;border:2px solid #fff}.minus_point,\r\n    .decl_point{padding:6px 12px}.sla_point{padding:6px 11px}.griddedModule table tr td:last-child{border-right:1px solid #ccc !important}.griddedModule .lastGrid tr:last-child td{border-bottom:1px solid #ccc !important}.griddedModule td{border:1px solid #f0f0f0 !important;border-left:1px solid #ccc !important}.token:hover{border:1px solid #000 !important}.bla .token:hover{border:1px solid #fff !important}.token_selected{background-color:#64bb63;color:#fff}.bla .token_highlight_heading{color:#000 !important}.griddedModule .expandIcon{font-size:27px;font-weight:bold;color:#1877b1}table td, table th{padding:.5rem .5rem!important;vertical-align:top!important;border-top:1px solid #dee2e6!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZGRlZFByZXZpZXcuc3ZlbHRlIiwic291cmNlcyI6WyJHcmlkZGVkUHJldmlldy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBcclxuICogIEZpbGUgTmFtZSAgIDogR3JpZGRlZFByZXZpZXcuanNcclxuICogIERlc2NyaXB0aW9uIDogU2hvd2luZyB0aGUgZ3JpZGRlZCBzaGVldCBmb3Igc3R1ZGVudFxyXG4gKiAgQXV0aG9yICAgICAgOiBTdW5kYXJhbSBUcmlwYXRoaVxyXG4gKiAgVmVyc2lvbiAgICAgOiAxLjBcclxuICogIFBhY2thZ2UgICAgIDogcGUtZ29sZFxyXG4gKiAgTGFzdCB1cGRhdGUgOiAyNi1qdW5lLTIwMjEgIC0tPlxyXG4gPHNjcmlwdD5cclxuICAgIGltcG9ydCBsIGZyb20gJy4uL3NyYy9saWJzL2VkaXRvckxpYi9sYW5ndWFnZS5qcyc7XHJcbiAgICBpbXBvcnQgSXRlbUhlbHBlciBmcm9tICcuLi9oZWxwZXIvSXRlbUhlbHBlci5zdmVsdGUnO1xyXG4gICAgaW1wb3J0IHt3cml0YWJsZX0gZnJvbSAnc3ZlbHRlL3N0b3JlJztcclxuICAgIGltcG9ydCB7QUgsWE1MVG9KU09OLEpTT05Ub1hNTCxvblVzZXJBbnNDaGFuZ2V9IGZyb20gXCIuLi9oZWxwZXIvSGVscGVyQUkuc3ZlbHRlXCI7XHJcbiAgICBpbXBvcnQgeyBhZnRlclVwZGF0ZSwgYmVmb3JlVXBkYXRlLCBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcclxuICAgIGltcG9ydCBHcmlkZGVkSGVscGVyIGZyb20gJy4vR3JpZGRlZEhlbHBlci5zdmVsdGUnO1xyXG4gICAgXHJcblxyXG5cclxuXHJcbiAgICBleHBvcnQgbGV0IGlzUmV2aWV3O1xyXG4gICAgZXhwb3J0IGxldCB4bWw7XHJcbiAgICBleHBvcnQgbGV0IHNob3dBbnM7XHJcbiAgICBleHBvcnQgbGV0IHV4bWw7XHJcbiAgICBleHBvcnQgbGV0IGVkaXRvclN0YXRlO1xyXG5cclxuICAgIC8vIERlY2xhcmUgZ2xvYmFsIHZhcmlhYmxlcyAvLy8vXHJcblxyXG4gICAgbGV0IGJvb2wgPSAnICc7IFxyXG4gICAgbGV0IHVzZXJBbnMgPSBbXTtcclxuICAgIGxldCBhbnMgPSBbXTtcclxuICAgIGxldCBteUFucyA9IFtdO1xyXG4gICAgbGV0IGMgPSAwO1xyXG4gICAgbGV0IGNvcnJlY3RJbmM7XHJcbiAgICBsZXQgaXNBbnN3ZXJDb3JyZWN0ID0gJyc7XHJcbiAgICBsZXQgYW5zd2VyU3RhdHVzID0gJyc7XHJcbiAgICBsZXQgYXV0aEFuc1NwbGl0O1xyXG4gICAgbGV0IGluY29ycmVjdENscyA9IFwiXCI7XHJcbiAgICBsZXQgdXNlclhNTDtcclxuXHJcblxyXG5cclxuICAgIGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7ICBcclxuICAgICAgICByb3dOdW0gICAgICAgICAgICAgICAgICA6IDQsXHJcbiAgICAgICAgY29sTnVtICAgICAgICAgICAgICAgICAgOiA0LFxyXG4gICAgICAgIGl0ZW0gICAgICAgICAgICAgICAgICAgIDogMSxcclxuICAgICAgICBwbHVzX21pbnVzICAgICAgICAgICAgICA6IDAsXHJcbiAgICAgICAgc2xhc2hfdmFsICAgICAgICAgICAgICAgOiAwLFxyXG4gICAgICAgIGRlY2ltYWxfdmFsICAgICAgICAgICAgIDogMCxcclxuICAgICAgICB4bWwgICAgICAgICAgICAgICAgICAgICA6ICcnLFxyXG4gICAgICAgIHRleHRTaXplUCAgICAgICAgICAgICAgIDogMCxcclxuICAgICAgICBjb3JyZWN0QW5zICAgICAgICAgICAgICA6IFtdLFxyXG4gICAgICAgIHVzZXJMaXN0ICAgICAgICAgICAgICAgIDogW10sXHJcbiAgICAgICAgaXNNYXRocXVpbGwgICAgICAgICAgICAgOmZhbHNlLFxyXG4gICAgICAgIHNtQ29udHJvbGxlciAgICAgICAgICAgIDogXCJoXCIsXHJcbiAgICAgICAgcG9pbnRlckV2ZW50cyAgICAgICAgICAgOiBcImF1dG9cIixcclxuICAgICAgICBkZWNpbWFsX3BvaW50ICAgICAgICAgICA6IDAsXHJcbiAgICAgICAgaWNvblZpc2libGUgICAgICAgICAgICAgOiBcImhcIixcclxuICAgICAgICBcclxuICAgIH0pXHJcblxyXG4gICAgbGV0IHN0YXRlID0ge307XHJcbiAgICBcclxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RhdGVEYXRhLnN1YnNjcmliZSgoaXRlbXMpPT57XHJcbiAgICAgICAgc3RhdGUgPSBpdGVtcztcclxuICAgIH0pXHJcblxyXG4gICAgJDp7XHJcbiAgICAgICAgaWYgKGlzUmV2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRSZXZpZXcoKTsgXHJcbiAgICAgICAgICAgICAgIC8vIHRoaXMuY2hlY2tBbnMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB1bnNldFJldmlldygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbk1vdW50KCgpPT57XHJcbiAgICAgICAgLy8gJCgnYm9keScpLm9uKCdrZXlkb3duJywgJy50ZF9kYXRhJywgZnVuY3Rpb24oZSkgeyBcclxuICAgICAgICAvLyAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAkKHRoaXMpLmNsaWNrKCk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICBBSC5saXN0ZW4oZG9jdW1lbnQsJ2tleWRvd24nLCcudGRfZGF0YScsKChkYXRhLGUpPT57XHJcbiAgICAgICAgICAgIGlmKGUud2hpY2ggPT09IDEzKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSlcclxuXHJcbiAgICAgICAgLy8galF1ZXJ5KCcjc21fY29udHJvbGxlciBidXR0b24nKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyAgICAgalF1ZXJ5KCcjc21fY29udHJvbGxlciBidXR0b24nKS5yZW1vdmVDbGFzcyhcImFjdGl2ZSBidG4tc2Vjb25kYXJ5IHRleHQtd2hpdGUgYmctc2Vjb25kYXJ5XCIpO1xyXG4gICAgICAgIC8vICAgICBqUXVlcnkodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZSBidG4tc2Vjb25kYXJ5IHRleHQtd2hpdGUgYmctc2Vjb25kYXJ5Jyk7XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgQUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJyNzbV9jb250cm9sbGVyIGJ1dHRvbicsKChlKT0+e1xyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJyNzbV9jb250cm9sbGVyIGJ1dHRvbicsJ3JlbW92ZUNsYXNzJyxbJ2FjdGl2ZSxidG4tc2Vjb25kYXJ5LHRleHQtd2hpdGUsYmctc2Vjb25kYXJ5J10pO1xyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoZSwnYWRkQ2xhc3MnLFsnYWN0aXZlLGJ0bi1zZWNvbmRhcnksdGV4dC13aGl0ZSxiZy1zZWNvbmRhcnknXSk7XHJcbiAgICAgICAgfSkpXHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBBSC5saXN0ZW4oZG9jdW1lbnQsJ2NsaWNrJywnI3NldC1yZXZpZXcnLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHNldFJldmlldygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBBSC5saXN0ZW4oZG9jdW1lbnQsJ2NsaWNrJywnI3Vuc2V0LXJldmlldycsZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdW5zZXRSZXZpZXcoKTtcclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGxvYWRNb2R1bGUobG9hZFhtbCkge1xyXG4gICAgICAgIGxvYWRYbWwgPSBYTUxUb0pTT04obG9hZFhtbCk7XHJcbiAgICAgICAgcGFyc2VYTUxQcmV2aWV3KGxvYWRYbWwpOyBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVhNTFByZXZpZXcoTVlYTUwpIHtcclxuXHQgICAgdHJ5IHtcclxuXHRcdFx0XHJcblx0XHRcdHN0YXRlLnJvd051bSA9IE1ZWE1MLnNteG1sLl9yb3c7XHJcbiAgICAgICAgICAgIHN0YXRlLmNvbE51bSA9IE1ZWE1MLnNteG1sLl9jb2w7ICBcclxuICAgICAgICAgICAgc3RhdGUuc2xhc2hfdmFsID0gTVlYTUwuc214bWwuX3NsYXNoO1xyXG4gICAgICAgICAgICBzdGF0ZS5wbHVzX21pbnVzID0gTVlYTUwuc214bWwuX3BsdXNtaW51cztcclxuICAgICAgICAgICAgc3RhdGUuZGVjaW1hbF92YWwgPSAgTVlYTUwuc214bWwuX2RlY2ltYWw7XHJcbiAgICAgICAgICAgIHN0YXRlLnRleHRTaXplUCA9IE1ZWE1MLnNteG1sLl9mb250O1xyXG4gICAgICAgICAgICBzdGF0ZS5jb3JyZWN0QW5zID0gTVlYTUwuc214bWwuX2NvcnJlY3RBbnMuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgc3RhdGUuZGVjaW1hbF9wb2ludCA9IE1ZWE1MLnNteG1sLl9maXhlZF9wb2ludDtcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2lmICh3aW5kb3cudWFYTUwpIHtcclxuICAgICAgICAgICAgaWYodXhtbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3BhcnNlVXNlckFucyh3aW5kb3cudWFYTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlVXNlckFucyh1eG1sKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgICAgICAgICAvLyB9LDUwKTtcclxuICAgICAgICAgICAgfVxyXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsnZXJyb3InOmVycm9yLm1lc3NhZ2UsJ2Z1bmN0aW9uIG5hbWUnOidwYXJzZVhNTFByZXZpZXcnLCdGaWxlIG5hbWUnOidHcmlkZGVkUHJldmlldy5qcyd9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VVc2VyQW5zKHVhbnMpIHtcclxuICAgICAgICAgICAgbGV0IHVzZXJBbnN3ZXIgPSBYTUxUb0pTT04odWFucyk7XHJcbiAgICAgICAgICAgIGlmICh1c2VyQW5zd2VyLnNtYW5zICYmIHVzZXJBbnN3ZXIuc21hbnMuZGl2ICYmIHVzZXJBbnN3ZXIuc21hbnMuZGl2Ll91c2VyQW5zKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VyQW5zID0gdXNlckFuc3dlci5zbWFucy5kaXYuX3VzZXJBbnMuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgYm9vbCA9IHVzZXJBbnN3ZXIuc21hbnMuZGl2Ll9jb3JyZWN0O1xyXG4gICAgICAgICAgICAgICAvLyAkKFwiI2Fuc3dlclwiKS5wcm9wKFwiY2hlY2tlZFwiLCBib29sKVxyXG4gICAgICAgICAgICAgICAgYW5zID0gdXNlckFucztcclxuICAgICAgICAgICAgICAgIC8vZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJlZm9yZVVwZGF0ZSgoKT0+e1xyXG4gICAgICAgIGlmICh4bWwgIT0gc3RhdGUueG1sKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnhtbCA9IHhtbDtcclxuICAgICAgICAgICAgbG9hZE1vZHVsZSh4bWwpO1xyXG4gICAgICAgIH0gIFxyXG4gICAgICAgIC8vaWYgKHRoaXMucHJvcHMucmVtZWRTdGF0dXMgIT0gbmV4dFByb3BzLnJlbWVkU3RhdHVzKSB7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgLy99IFxyXG4gICAgICAgIC8vaWYgKHdpbmRvdy5RWE1MKSB7XHJcbiAgICAgICAgaWYoeG1sKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdxeG1sJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpcnN0Um93SXRlbVByZSgpO1xyXG4gICAgICAgIGRlY2ltYWxGbG9hdGluZ1ByZSgpO1xyXG4gICAgICAgIHNsYXNoRnVuY1ByZSgpO1xyXG4gICAgICAgIHBsdXNNaW51c1NpZ25QcmUoKTtcclxuICAgICAgICBjcmVhdGVkU2hlZXRSb3dQcmUoKTtcclxuICAgICAgICBcclxuICAgIH0pXHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLy8vLy8vLy8vLy8vL2NoYW5naW5nIGNvbG9yIGFjY29yZGluZyB0byB1c2VyLy8vLy8vLy8vXHJcbiAgICAgICAgbGV0IGNlbGxfY2xhc3MgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XHJcbiAgICAgICAgICAgIGxldCBjb2x1bW5faW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShjZWxsX2NsYXNzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5faW5kZXgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XHJcblxyXG4gICAgICAgICAgLy8vLy8vLy9UaHJvdyB0aGUgc2VsZWN0IGRhdGEgaW4gdG9wIHJvdy8vLy8vLy9cclxuICAgICAgICAgICAgbGV0IHRhcmdldF9pZCA9IGV2ZW50LnRhcmdldC5pZDtcclxuICAgICAgICAgICAgbGV0IHRhcmdldF90b19kaXNwbGF5ID0gdGFyZ2V0X2lkLnNwbGl0KFwiLVwiKTsgXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldF90b19kaXNwbGF5WzBdKS52YWx1ZSA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgIHNldFVzZXJBbnMoZXZlbnQpOyAvLy8vLy8vLyBDYWxsIGZ1bmN0aW9uIGZvciBhbnN3ZXIgY2hlY2tpbmdcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRVc2VyQW5zIChldmVudCkgIHtcclxuICAgICAgICBsZXQgY291bnRSZXM7XHJcbiAgICAgICAgbGV0IHJlc05ldztcclxuICAgICAgICBsZXQgYW5zQm9vbDtcclxuXHJcbiAgICAgICAvLy8vLy8vLyBUaGlzIGNvZGUgc2V0IHRoZSBhbnN3ZXIvLy8vLy8vLy8vL1xyXG4gICAgICAgIGxldCBhdHRyID0gZXZlbnQudGFyZ2V0LmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLXRhZycpLnZhbHVlO1xyXG4gICAgICAgIGlmIChldmVudC50YXJnZXQuaW5uZXJIVE1MID09PSAnJykge1xyXG4gICAgICAgICAgICB1c2VyQW5zW2F0dHJdID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdXNlckFuc1thdHRyXSA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPHVzZXJBbnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YodXNlckFuc1tpXSkgPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFuc1tpXSA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VyQW5zW2ldID0gXCIlYmxhbmslXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh1c2VyQW5zWyh1c2VyQW5zLmxlbmd0aCktMV0gPT0gXCIlYmxhbmslXCIpIHtcclxuICAgICAgICAgICAgdXNlckFucy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHN0YXRlLnVzZXJMaXN0ID0gdXNlckFucztcclxuICAgICAgICBcclxuICAgICAgICAgICAgYXV0aEFuc1NwbGl0ID0gc3RhdGUuY29ycmVjdEFucztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCB1c2VyID0gc3RhdGUudXNlckxpc3Q7XHJcbiAgICAgICAgICAgIGlmICh1c2VyLmxlbmd0aCA9PSBhdXRoQW5zU3BsaXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1dGhBbnNTcGxpdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyW2ldID09IGF1dGhBbnNTcGxpdFtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjKys7ICBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gdXNlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5jb3JyZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbnN3ZXJDb3JyZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gMDtcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRSZXMgPSBsLmluY29ycmVjdDtcclxuICAgICAgICAgICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5pbmNvcnJlY3Q7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgKCF3aW5kb3cuUVhNTCkge1xyXG4gICAgICAgICAgICBpZihlZGl0b3JTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc2hvd0Fucyhjb3VudFJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5zQm9vbCA9IChjb3VudFJlcyA9PSBcImNvcnJlY3RcIikgPyB0cnVlIDogZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB1c2VyWE1MID0gXCI8c21hbnM+PGRpdiB0eXBlPSc1NicgY29ycmVjdD0nXCIraXNBbnN3ZXJDb3JyZWN0K1wiJyB1c2VyQW5zPSdcIitzdGF0ZS51c2VyTGlzdCtcIic+PC9kaXY+PC9zbWFucz5cIlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9BSC5zZWxlY3QoXCIjc3BlY2lhbF9tb2R1bGVfdXNlcl94bWxcIikudmFsdWUgPSB1c2VyWE1MXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXNOZXcgPSBcIjxzbWFucz48ZGl2IHR5cGU9JzU2JyBjb3JyZWN0PSdcIitpc0Fuc3dlckNvcnJlY3QrXCInIHVzZXJBbnM9J1wiK3N0YXRlLnVzZXJMaXN0K1wiJz48L2Rpdj48L3NtYW5zPlwiO1xyXG4gICAgICAgICAgICBpZiAoYm9vbCAhPSAnICcgJiYgYyA9PSB1c2VyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy9qUVVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KFwiI2Fuc3dlclwiLCdhdHRyJyx7XCJjaGVja2VkXCI6Ym9vbH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9qUXVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGlzQW5zd2VyQ29ycmVjdCk7XHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoXCIjYW5zd2VyXCIsJ2F0dHInLHtcImNoZWNrZWRcIjppc0Fuc3dlckNvcnJlY3R9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1eG1sID0gdXNlclhNTFxyXG4gICAgICAgICAgICBvblVzZXJBbnNDaGFuZ2Uoe3VYbWw6cmVzTmV3LGFuczphbnNCb29sfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrQ29tYm8oZXZlbnQpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLy8vLy8vLy8vLy8vL2NoYW5naW5nIGNvbG9yIGFjY29yZGluZyB0byB1c2VyLy8vLy8vLy8vXHJcbiAgICAgICAgbGV0IGNlbGxfY2xhc3MgPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkuZ2V0QXR0cmlidXRlKCduYW1lJyk7XHJcbiAgICAgICAgICAgIGxldCBjb2x1bW5faW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShjZWxsX2NsYXNzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5faW5kZXgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKGV2ZW50LmRldGFpbC50YXJnZXQpLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XHJcblxyXG4gICAgICAgICAgLy8vLy8vLy9UaHJvdyB0aGUgc2VsZWN0IGRhdGEgaW4gdG9wIHJvdy8vLy8vLy9cclxuICAgICAgICAgICAgbGV0IHRhcmdldF9pZCA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pZDtcclxuICAgICAgICAgICAgbGV0IHRhcmdldF90b19kaXNwbGF5ID0gdGFyZ2V0X2lkLnNwbGl0KFwiLVwiKTsgXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldF90b19kaXNwbGF5WzBdKS52YWx1ZSA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgIHNldFVzZXJBbnNDb21ibyhldmVudCk7IC8vLy8vLy8vIENhbGwgZnVuY3Rpb24gZm9yIGFuc3dlciBjaGVja2luZ1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFVzZXJBbnNDb21ibyAoZXZlbnQpICB7XHJcbiAgICAgICAgbGV0IGNvdW50UmVzO1xyXG5cclxuICAgICAgIC8vLy8vLy8vIFRoaXMgY29kZSBzZXQgdGhlIGFuc3dlci8vLy8vLy8vLy8vXHJcbiAgICAgICAgbGV0IGF0dHIgPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtdGFnJykudmFsdWU7XHJcbiAgICAgICAgaWYgKChldmVudC5kZXRhaWwudGFyZ2V0KS5pbm5lckhUTUwgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHVzZXJBbnNbYXR0cl0gPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkudmFsdWU7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB1c2VyQW5zW2F0dHJdID0gKGV2ZW50LmRldGFpbC50YXJnZXQpLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8dXNlckFucy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZih1c2VyQW5zW2ldKSA9PSAndW5kZWZpbmVkJyB8fCB1c2VyQW5zW2ldID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIHVzZXJBbnNbaV0gPSBcIiVibGFuayVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHVzZXJBbnNbKHVzZXJBbnMubGVuZ3RoKS0xXSA9PSBcIiVibGFuayVcIikge1xyXG4gICAgICAgICAgICB1c2VyQW5zLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICAgICAgc3RhdGUudXNlckxpc3QgPSB1c2VyQW5zO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBhdXRoQW5zU3BsaXQgPSBzdGF0ZS5jb3JyZWN0QW5zO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHVzZXIgPSBzdGF0ZS51c2VyTGlzdDtcclxuICAgICAgICAgICAgaWYgKHVzZXIubGVuZ3RoID09IGF1dGhBbnNTcGxpdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXV0aEFuc1NwbGl0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJbaV0gPT0gYXV0aEFuc1NwbGl0W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMrKzsgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYyA9PSB1c2VyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRSZXMgPSBsLmNvcnJlY3RcclxuICAgICAgICAgICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRSZXMgPSBsLmluY29ycmVjdDtcclxuICAgICAgICAgICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5pbmNvcnJlY3Q7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiAoIXdpbmRvdy5RWE1MKSB7XHJcbiAgICAgICAgICAgIGlmKGVkaXRvclN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzaG93QW5zKGNvdW50UmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8valF1ZXJ5KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIpLnZhbChcIjxzbWFucz48ZGl2IHR5cGU9JzU2JyBjb3JyZWN0PSdcIitpc0Fuc3dlckNvcnJlY3QrXCInIHVzZXJBbnM9J1wiK3N0YXRlLnVzZXJMaXN0K1wiJz48L2Rpdj48L3NtYW5zPlwiKTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIpLnZhbHVlID0gXCI8c21hbnM+PGRpdiB0eXBlPSc1NicgY29ycmVjdD0nXCIraXNBbnN3ZXJDb3JyZWN0K1wiJyB1c2VyQW5zPSdcIitzdGF0ZS51c2VyTGlzdCtcIic+PC9kaXY+PC9zbWFucz5cIlxyXG4gICAgICAgICAgICBpZiAoYm9vbCAhPSAnICcgJiYgYyA9PSB1c2VyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy9qUVVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoXCIjYW5zd2VyXCIsJ2F0dHInLHtcImNoZWNrZWRcIjpib29sfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2pRdWVyeShcIiNhbnN3ZXJcIikucHJvcChcImNoZWNrZWRcIiwgaXNBbnN3ZXJDb3JyZWN0KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KFwiI2Fuc3dlclwiLCdhdHRyJyx7XCJjaGVja2VkXCI6aXNBbnN3ZXJDb3JyZWN0fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByb3dWYWxpZGF0aW9uKGV2ZW50KSB7ICBcclxuICAgICAgICBsZXQgYSA9IHN0YXRlLnJvd051bSAtIDE7XHJcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC52YWx1ZS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIEFILmFsZXJ0KCdEb3VibGUgZGlnaXQgbm90IGFjY2VwdGVkJyk7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfWVsc2UgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgQUguYWxlcnQoXCJMZXNzIHRoZW4gMSBub3QgYWNjZXB0ZWRcIik7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9ZWxzZSBpZiAoIGEgPCBldmVudC50YXJnZXQudmFsdWUpIHtcclxuICAgICAgICAgICAgQUguYWxlcnQoJ051bWJlciBpbnNlcnQgb25seSAwIHRvICcrc3RhdGUucm93TnVtKTtcclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VXNlckFucyhldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGlnaExpZ2h0KGV2ZW50KSB7ICAgIFxyXG4gICAgICAgIGxldCBjZWxsX2NsYXNzID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xyXG4gICAgICAgIGxldCBjb2x1bW5faW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShjZWxsX2NsYXNzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgIH0gICAgXHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5faW5kZXhbaV0uaW5uZXJIVE1MID09IGV2ZW50LnRhcmdldC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcblxyXG5cclxuICAgICAvLy8vLy8vLy8vLy8vLy8vLy8gQ3JlYXRlIHZlcnkgZmlyc3Qgcm93IGFuZCBzdG9yZSBkYXRhIGFjY29yZGluZyB0byBjbGljay8vLy8vLy8vLy9cclxuXHJcbiAgICBsZXQgQ29sc1ByZSA9IFtdO1xyXG4gICAgZnVuY3Rpb24gZmlyc3RSb3dJdGVtUHJlKCkge1xyXG4gICAgICAgICAgICBsZXQgUm93cyA9IFtdO1xyXG4gICAgICAgICAgICBDb2xzUHJlID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLmNvbE51bTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5zW2pdID09PSBcIiVibGFuayVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgbXlBbnNbal0gPSBcIiBcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXlBbnNbal0gPSBhbnNbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29sc1ByZSA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc1ByZSx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbHNQcmUubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbHNQcmUgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzUHJlLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3QnK2osXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncCcraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbXlBbnNbal0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhbmlkOiBcInRfXCIraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGxldCB0b3RhbFJvd3MgPSBbXTtcclxuICAgIGxldCB0b3RhbENvbHMgPSBbXTtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZWRTaGVldFJvd1ByZSgpIHtcclxuICAgICAgICB0b3RhbFJvd3MgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUucm93TnVtOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsQ29scyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGRlY19wb2ludCAtIDEgJiYgZGVjX3BvaW50ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQ29scyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImNvbFwiK2kraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsQ29scy5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxDb2xzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiY29sXCIraStqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncCcraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidFwiICsgaiArIFwiLVwiICsgaSArIGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3RvdGFsUm93cy5wdXNoKDx0ciBrZXk9e1wicm93XCIraX0+e3RvdGFsQ29sc308L3RyPik7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFJvd3MgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4udG90YWxSb3dzLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInJvd1wiK2lcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgQ29sc19zbGFzaCA9IFtdO1xyXG4gICAgZnVuY3Rpb24gc2xhc2hGdW5jUHJlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBSb3dzX3NsYXNoID0gW107XHJcbiAgICAgICAgICAgIENvbHNfc2xhc2ggPSBbXTtcclxuICAgICAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbHNfc2xhc2ggPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX3NsYXNoLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiY29sXCIraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDb2xzX3NsYXNoLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29sc19zbGFzaCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX3NsYXNoLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidFwiICsgaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3AnK2osXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgQ29sc19kZWNpbWFsID0gW107XHJcbiAgICBmdW5jdGlvbiBkZWNpbWFsRmxvYXRpbmdQcmUoZXZlbnQpIHtcclxuICAgICAgICBsZXQgUm93c19kZWNpbWFsID0gW107XHJcbiAgICAgICAgQ29sc19kZWNpbWFsID0gW107XHJcbiAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQtMSAmJiBkZWNfcG9pbnQgIT0gMCkgeyBcclxuICAgICAgICAgICAgICAgIENvbHNfZGVjaW1hbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX2RlY2ltYWwse1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiY29sXCIraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQ29sc19kZWNpbWFsLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbHNfZGVjaW1hbCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19kZWNpbWFsLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRcIiArIGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncCcraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgXHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8gU2V0IHJldmlldyBhbmQgdW5zZXQgcmV2aWV3IGZ1bmN0aW9uLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRSZXZpZXcoKSB7XHJcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICAgIHN0YXRlLnNtQ29udHJvbGxlciA9IFwiXCIsXHJcbiAgICAgICAgc3RhdGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiXHJcbiAgICAgICAgaXNSZXZpZXcgPSB0cnVlO1xyXG4gICAgICAgIHNob3dBbnN3ZXIoXCJ5YW5zXCIsIFwic2hvd0ljb25cIik7XHJcbiAgICAgICAgLy9qUXVlcnkoJyNzbV9jb250cm9sbGVyIC55b3VyLWFucycpLmFkZENsYXNzKFwiYnRuLWxpZ2h0IGFjdGl2ZVwiKTtcclxuXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcjc21fY29udHJvbGxlciAueW91ci1hbnMnLCdhZGRDbGFzcycsWydidG4tbGlnaHQnLCdhY3RpdmUnXSk7XHJcblxyXG5cclxuICAgICAgICAvL2pRdWVyeShcIi50b2tlbkhlYWRlclwiKS5hdHRyKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xyXG4gICAgICAgIEFILnNlbGVjdEFsbChcIi50b2tlbkhlYWRlclwiLFwiYXR0clwiLHtcInRhYmluZGV4XCI6MH0pXHJcblxyXG4gICAgICAgIC8vZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50b2tlbkhlYWRlclwiKS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiMFwiKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGdldENvcnJlY3QoKSwyMDApOyBcclxuICAgICAgICAvLyBpZiAoIXdpbmRvdy5RWE1MKSB7XHJcbiAgICAgICAgaWYoZWRpdG9yU3RhdGUpIHtcclxuICAgICAgICAgICAgc2hvd0FucygoaXNBbnN3ZXJDb3JyZWN0KT8obC5jb3JyZWN0KToobC5pbmNvcnJlY3QpKTtcclxuICAgICAgICB9IFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvcnJlY3QoKSB7XHJcblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuY29ycmVjdEFucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuY29ycmVjdEFuc1tpXSA9PSBzdGF0ZS51c2VyTGlzdFtpXSkge1xyXG4gICAgICAgICAgICAgICAgLy9qUXVlcnkoJyN0XycraSkucmVtb3ZlQ2xhc3MoXCJpY29tb29uLW5ldy0yNHB4LWNhbmNlbC1jaXJjbGUtMVwiKS5hZGRDbGFzcyhcImljb21vb24tbmV3LTI0cHgtY2hlY2ttYXJrLWNpcmNsZS0xXCIpO1xyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjdF8nK2ksJ3JlbW92ZUNsYXNzJywnaWNvbW9vbi1uZXctMjRweC1jYW5jZWwtY2lyY2xlLTEnKTtcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3RfJytpLCdhZGRDbGFzcycsJ2ljb21vb24tbmV3LTI0cHgtY2hlY2ttYXJrLWNpcmNsZS0xJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2pRdWVyeSgnI3RfJytpKS5yZW1vdmVDbGFzcyhcImljb21vb24tbmV3LTI0cHgtY2hlY2ttYXJrLWNpcmNsZS0xXCIpLmFkZENsYXNzKFwiaWNvbW9vbi1uZXctMjRweC1jYW5jZWwtY2lyY2xlLTFcIik7XHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyN0XycraSwncmVtb3ZlQ2xhc3MnLCdpY29tb29uLW5ldy0yNHB4LWNoZWNrbWFyay1jaXJjbGUtMScpO1xyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjdF8nK2ksJ2FkZENsYXNzJywnaWNvbW9vbi1uZXctMjRweC1jYW5jZWwtY2lyY2xlLTEnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG5cdH1cclxuIFxyXG4gICAgZnVuY3Rpb24gdW5zZXRSZXZpZXcoKSB7ICBcclxuICAgICAgICBzdGF0ZS5zbUNvbnRyb2xsZXIgPSBcImhcIixcclxuICAgICAgICBzdGF0ZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCJcclxuICAgICAgICBpc1JldmlldyA9IGZhbHNlO1xyXG4gICAgICAgIHNob3dBbnN3ZXIoXCJ5YW5zXCIsIFwiaGlkZUljb25cIik7XHJcbiAgICAgICAgLy9qUXVlcnkoXCIudG9rZW5IZWFkZXJcIikucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpO1xyXG4gICAgICAgIEFILnNlbGVjdEFsbChcIi50b2tlbkhlYWRlclwiLCAncmVtb3ZlQXR0cicsICd0YWJpbmRleCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNob3dBbnN3ZXIodmFsLGljb25TdGF0ZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAvL3Nob3cgY29ycmVjdCBpbmNvcnJlY3QgaWNvbiB3aXRoIHJlc3BlY3QgdG8gaWNvblN0YXRlXHJcbiAgICAgICAgaWYgKGljb25TdGF0ZSA9PSBcInNob3dJY29uXCIpIHtcclxuICAgICAgICAgICAgc3RhdGUuaWNvblZpc2libGUgPSBcIlwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmljb25WaXNpYmxlID0gXCJoXCI7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYgKHZhbCA9PSBcImNhbnNcIikge1xyXG4gICAgICAgICAgICBsZXQgZWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZ3JpZGRlZF90YWInKTtcclxuICAgICAgICAgICAgZWxlLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgYW5zID0gc3RhdGUuY29ycmVjdEFucztcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PSBcInlhbnNcIikge1xyXG4gICAgICAgICAgICBhbnMgPSB1c2VyQW5zO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIGNyZWF0ZSBwbHVzIGFuZCBtaW51cyByb3cvLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIGxldCBDb2xzID0gW107XHJcbiAgICBsZXQgQ29sc19NaW51cyA9IFtdO1xyXG4gICAgZnVuY3Rpb24gcGx1c01pbnVzU2lnblByZShldmVudCkgIHtcclxuICAgICAgICBDb2xzID0gW107XHJcbiAgICAgICAgQ29sc19NaW51cyA9IFtdO1xyXG4gICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xyXG4gICAgICAgIC8vbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgQ29scyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWQ6IFwidGRcIiArIGogKyAnLScgKyBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChDb2xzLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLkNvbHMse1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidFwiICsgaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwJytqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChqID09IGRlY19wb2ludCAtIDEgJiYgZGVjX3BvaW50ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBDb2xzX01pbnVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX01pbnVzLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkOiBcInRkXCIgKyBqICsgJy0nICsgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChDb2xzX01pbnVzLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbHNfTWludXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLkNvbHNfTWludXMse1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidFwiICsgaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwJytqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXZpZXcobW9kZSkge1xyXG4gICAgICAgIGlmIChtb2RlID09ICdjJykge1xyXG5cdFx0XHRzaG93QW5zd2VyKFwiY2Fuc1wiLCBcImhpZGVJY29uXCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hvd0Fuc3dlcihcInlhbnNcIiwgXCJzaG93SWNvblwiKTtcclxuXHRcdH1cclxuICAgIH1cclxuICAgIC8vbGV0IGRpc3BsYXlDbGFzcyA9ICgoc3RhdGUuaWNvblZpc2libGUgPT0gXCJcIiAmJiAoc3RhdGUudXNlckFucykuaW5jbHVkZXModmFsLmlkKSkpO1xyXG5cclxuPC9zY3JpcHQ+XHJcblxyXG48bWFpbj5cclxuICAgIDxjZW50ZXI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImdyaWRkZWRNb2R1bGVcIj5cclxuICAgICAgICAgICAgPGNlbnRlcj4gXHJcbiAgICAgICAgICAgICAgICA8SXRlbUhlbHBlciBcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZXZpZXdDbGljaz17aGFuZGxlUmV2aWV3fVxyXG4gICAgICAgICAgICAgICAgICAgIHJldmlld01vZGU9e2lzUmV2aWV3fVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9jZW50ZXI+XHJcbiAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XCIxXCIgaWQ9XCJ0YWIyXCIgc3R5bGU9eydib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7dGV4dC1hbGlnbjpjZW50ZXInfSA+XHJcbiAgICAgICAgICAgICAgICA8dHIgc3R5bGU9XCJkaXNwbGF5OmZsZXg7XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgeyNlYWNoIENvbHNQcmUgYXMgdmFsLGl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgdmFsLmRlY3BvaW50ID09IHRydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT17J3dpZHRoOjUwcHg7dGV4dC1hbGlnbjpjZW50ZXI7J30gIHZhbHVlPVwiLlwiIGRpc2FibGVkPVwidHJ1ZVwiIGNsYXNzPVwidGRGb250XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9e3ZhbC5pZH0gZGF0YS10YWc9e3ZhbC5kYXRhVGFnfSBuYW1lPXt2YWwubmFtZX0gc3R5bGU9eyd3aWR0aDo1MHB4O3RleHQtYWxpZ246Y2VudGVyOyd9IG9uOmNoYW5nZT17cm93VmFsaWRhdGlvbn0gb246aW5wdXQ9e2hpZ2hMaWdodH0gdmFsdWU9eyhteUFuc1tpXSA9PT0gdW5kZWZpbmVkKT9cIiBcIjpteUFuc1tpXX0gY2xhc3M9XCJ0ZEZvbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICBjbGFzcz17c3RhdGUuaWNvblZpc2libGUrJyByZWxhdGl2ZSd9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD17dmFsLnNwYW5pZH0gY2xhc3M9XCJhbnN3ZXJfaWNvblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuXHJcbiAgICAgICAgICAgICAgICB7I2lmIHN0YXRlLnBsdXNfbWludXMgPT0gMX1cclxuICAgICAgICAgICAgICAgICAgICA8R3JpZGRlZEhlbHBlciBcclxuICAgICAgICAgICAgICAgICAgICAgICAgb246aGFuZGxlQ2xpY2tDb21ibyA9IHtoYW5kbGVDbGlja0NvbWJvfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wID0ge0NvbHN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzMSA9IFwidGRGb250IHBsdXNfdGFiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250UCBwbHVzX3RhYiBpdGVtc19lbGVtZW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVJZCA9XCJwbHVzX21pbnVzX3RhYlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3MgPVwicGx1c19taW51c190YWIgZ3JpZGRlZF90YWIgbXQtMCBteVBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiK1wiXHJcbiAgICAgICAgICAgICAgICAgICAgPjwvR3JpZGRlZEhlbHBlcj5cclxuICAgICAgICAgICAgICAgICAgICA8R3JpZGRlZEhlbHBlciBcclxuICAgICAgICAgICAgICAgICAgICAgICAgb246aGFuZGxlQ2xpY2tDb21ibyA9IHtoYW5kbGVDbGlja0NvbWJvfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wID0ge0NvbHNfTWludXN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzMSA9IFwidGRGb250IHBsdXNfdGFiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250UCBwbHVzX3RhYiBpdGVtc19lbGVtZW50IG1pbnVzX3BvaW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVJZCA9XCJwbHVzX21pbnVzX3RhYlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3MgPVwicGx1c19taW51c190YWIgZ3JpZGRlZF90YWIgbXQtMCBteVBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiLVwiXHJcbiAgICAgICAgICAgICAgICAgICAgPjwvR3JpZGRlZEhlbHBlcj5cclxuICAgICAgICAgICAgICAgIHsvaWZ9XHJcblxyXG4gICAgICAgICAgICB7I2lmIHN0YXRlLmRlY2ltYWxfdmFsID09IDF9XHJcbiAgICAgICAgICAgICAgICA8R3JpZGRlZEhlbHBlciBcclxuICAgICAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvID0ge2hhbmRsZUNsaWNrQ29tYm99XHJcbiAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX2RlY2ltYWx9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3MxID0gXCJ0ZEZvbnQgcG9pbnRzXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZEZvbnRQIHRleHQtY2VudGVyIGl0ZW1zX2VsZW1lbnQgZGVjbF9wb2ludFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVJZCA9XCJzbGFzaF90YWJcIlxyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3MgPVwic2xhc2hfdGFiIGdyaWRkZWRfdGFiIG10LTAgbWItMCBteVBcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCIuXCJcclxuICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XHJcbiAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgIHsjaWYgc3RhdGUuc2xhc2hfdmFsID09IDF9XHJcbiAgICAgICAgICAgICAgICA8R3JpZGRlZEhlbHBlciAgXHJcbiAgICAgICAgICAgICAgICAgICAgb246aGFuZGxlQ2xpY2tDb21ibyA9IHtoYW5kbGVDbGlja0NvbWJvfVxyXG4gICAgICAgICAgICAgICAgICAgIGxvb3AgPSB7Q29sc19zbGFzaH1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzczEgPSBcInRkRm9udCBwb2ludHNcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRkRm9udFAgdGV4dC1jZW50ZXIgaXRlbXNfZWxlbWVudCBzbGFfcG9pbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwidGRGb250UCBzbGFzaF90YWJcIlxyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3MgPVwic2xhc2hfdGFiIGdyaWRkZWRfdGFiIG10LTBcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCIvXCJcclxuICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XHJcbiAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIDx0YWJsZSBpZD1cImdyaWRkZWRfc2hlZXRcIiBjbGFzcz1cImdyaWRkZWRfdGFiIG10LTAgbGFzdEdyaWQgY3JlYXRlX3RhYiBteVBcIj5cclxuICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICB7I2VhY2ggdG90YWxSb3dzIGFzIGRhdGEsbm99XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBrZXk9e2RhdGEua2V5fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCB0b3RhbENvbHMgYXMgdmFsLGl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiB2YWwuZGVjcG9pbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBrZXk9e3ZhbC5rZXl9IGNsYXNzID0ndGRGb250IHRleHQtY2VudGVyJyB3aWR0aD1cIjUwXCIgZGlzYWJsZWQ9XCJ0cnVlXCI+ICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHdpZHRoPVwiNTBcIiBjbGFzcz1cInRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB0YWJpbmRleD17dmFsLnRhYkluZGV4fSBrZXk9e3ZhbC5rZXl9IG5hbWU9e3ZhbC5uYW1lfSBkYXRhLXRhZz17dmFsLmRhdGFUYWd9IGNsYXNzPVwidGRGb250UCB0ZXh0LWNlbnRlciB0ZF9kYXRhIGFsZ24gaXRlbXNfZWxlbWVudFwiIGlkPXt2YWwuaWR9IG9uOmNsaWNrPXtoYW5kbGVDbGlja30+eytub308L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvY2VudGVyPlxyXG48L21haW4+XHJcblxyXG48c3R5bGU+XHJcbiAgICBcclxuICAgIDpnbG9iYWwoLmxheW91dEhlYWRpbmcpIHtcclxuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgICBmb250LXNpemU6IDE2cHg7XHJcbiAgICAgICAgY29sb3I6ICMxODc3YjE7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguaXRlbXNfZWxlbWVudDpob3Zlcikge1xyXG4gICAgICAgIGJvcmRlcjogMS4ycHggc29saWQgIzc3NztcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5tb3JlT3B0aW9ucykge1xyXG4gICAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogM3B4IDRweCA2cHggI2M0YzVjNTtcclxuICAgICAgICAtbW96LWJveC1zaGFkb3c6IDNweCA0cHggNnB4ICNjNGM1YzU7XHJcbiAgICAgICAgYm94LXNoYWRvdzogM3B4IDRweCA2cHggI2M0YzVjNTtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmMGYwO1xyXG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjMTg3N2IxO1xyXG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjMTg3N2IxO1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLm1vcmVPcHRpb25EZXRhaWxzKSB7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5pbnB1dF9jb2wpIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgbGVmdDogNXB4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmxheW91dGhlYWRpbmcpIHtcclxuICAgICAgICBwYWRkaW5nOiA1cHg7XHJcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xyXG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICA6Z2xvYmFsKC5udW1icl9yYW5nZSkge1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICBsZWZ0OiAxMzBweDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5udW1icl9yYW5nZV90eHQpIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgbGVmdDogMjAwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCgucGx1c19taW51c19mcmFjdGlvbikge1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICB0b3A6IDIwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZmxvYXRpbmdfZnJhY3Rpb24pIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgdG9wOiAyN3B4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLnBsdXNfbWludXNfc3Bhbikge1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICBsZWZ0OiA1cHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZmxvYXRpbmdfZGVjaW1hbCkge1xyXG4gICAgICAgIGZsb2F0OiByaWdodDtcclxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDQ1cHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZm9udFN0eWxlKSB7XHJcbiAgICAgICAgd2lkdGg6IDEwMHB4O1xyXG4gICAgICAgIGZsb2F0OiByaWdodDtcclxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDYwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZnJhY3Rpb25fc2xhc2gpIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgbGVmdDogMTc3cHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCgubWludXNfdGFiLFxyXG4gICAgLnBsdXNfdGFiLFxyXG4gICAgLnNsYXNoX3RhYikge1xyXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5ncmlkZGVkX3RhYikge1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjAhaW1wb3J0YW50O1xyXG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lIWltcG9ydGFudDtcclxuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmZvbnRfc2l6ZV9sYWJlbCkge1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICBsZWZ0OiAxOThweDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5mb250X3NpemUpIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgbGVmdDogMjI1cHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIDpnbG9iYWwoLmRlY2ltYWxfY29sKSB7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIGxlZnQ6IDIwOHB4O1xyXG4gICAgICAgIHdpZHRoOiA5MHB4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmNvcnJlY3RfY29sb3IpIHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRTlGRkU5O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmZpeGVkX2RlY2ltYWxfY2hlY2spIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgdG9wOiAyNnB4O1xyXG4gICAgICAgIGxlZnQ6IDEzcHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguY29ycmVjdF9pbmNvcnJlY3RfaWNvbl9maWxsKSB7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIHdpZHRoOiAxOXB4O1xyXG4gICAgICAgIGhlaWdodDogMTlweDtcclxuICAgICAgICByaWdodDogMTIxcHg7XHJcbiAgICAgICAgdG9wOiAtNTVweDtcclxuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCgucm93X2NvbHVtbl9kZWNpbWFsKSB7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIHRvcDogMzBweDtcclxuICAgICAgICBsZWZ0OiA1cHg7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmZpeGVkX3BvaW50X2NsYXNzKSB7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIGxlZnQ6IDdweDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5yb3dfY29sdW1uKSB7XHJcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgICAgIGxlZnQ6IDVweDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5hbnN3ZXJfaWNvbikge1xyXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICB0b3A6IDdweDtcclxuICAgICAgICByaWdodDogMzRweDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5teVAgdGJvZHkpIHtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguY29sX3JhbmdlKSB7XHJcbiAgICAgICAgd2lkdGg6IDIwNXB4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLnBvc1NpemUpIHtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgbGVmdDogN3B4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmZvbnRTbWFsbCkge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZm9udE5vcm1hbCkge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZm9udExhcmdlKSB7XHJcbiAgICAgICAgZm9udC1zaXplOiAyNHB4O1xyXG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5mb250RXh0cmFMYXJnZSkge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMjZweDtcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZ3JpZCkge1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICB0b3A6IDEwcHg7XHJcbiAgICAgICAgYm94LXNoYWRvdzogMTBweCA1cHggMTBweCAjMDAwO1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLml0ZW1zX2VsZW1lbnQpIHtcclxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDgwN2E7XHJcbiAgICAgICAgcGFkZGluZzogNnB4IDEwcHg7XHJcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgLmFjdGl2ZSkge1xyXG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgICAgICB0cmFuc2l0aW9uOiAxcztcclxuICAgICAgICBiYWNrZ3JvdW5kOiAjNjk2OTY5O1xyXG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCgubWludXNfcG9pbnQsXHJcbiAgICAuZGVjbF9wb2ludCkge1xyXG4gICAgICAgIHBhZGRpbmc6IDZweCAxMnB4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLnNsYV9wb2ludCkge1xyXG4gICAgICAgIHBhZGRpbmc6IDZweCAxMXB4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgdGFibGUgdHIgdGQ6bGFzdC1jaGlsZCkge1xyXG4gICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNjY2MgIWltcG9ydGFudDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5ncmlkZGVkTW9kdWxlIC5sYXN0R3JpZCB0cjpsYXN0LWNoaWxkIHRkKSB7XHJcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNjY2MgIWltcG9ydGFudDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5ncmlkZGVkTW9kdWxlIHRkKSB7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2YwZjBmMCAhaW1wb3J0YW50O1xyXG4gICAgICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2NjYyAhaW1wb3J0YW50O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLnRva2VuOmhvdmVyKSB7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgIzAwMCAhaW1wb3J0YW50O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmJsYSAudG9rZW46aG92ZXIpIHtcclxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZmZmICFpbXBvcnRhbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCgudG9rZW5fc2VsZWN0ZWQpIHtcclxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNjRiYjYzO1xyXG4gICAgICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmJsYSAudG9rZW5faGlnaGxpZ2h0X2hlYWRpbmcpIHtcclxuICAgICAgICBjb2xvcjogIzAwMCAhaW1wb3J0YW50O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgLmV4cGFuZEljb24pIHtcclxuICAgICAgICBmb250LXNpemU6IDI3cHg7XHJcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICAgICAgY29sb3I6ICMxODc3YjE7XHJcbiAgICB9XHJcbiAgICA6Z2xvYmFsKHRhYmxlIHRkLCB0YWJsZSB0aCkge1xyXG4gICAgICAgIHBhZGRpbmc6IC41cmVtIC41cmVtIWltcG9ydGFudDtcclxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wIWltcG9ydGFudDtcclxuICAgICAgICBib3JkZXItdG9wOiAxcHggc29saWQgI2RlZTJlNiFpbXBvcnRhbnQ7XHJcbiAgICB9XHJcbjwvc3R5bGU+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTJ2QlksY0FBYyxBQUFFLENBQUMsQUFDckIsV0FBVyxDQUFFLElBQUksQ0FDakIsU0FBUyxDQUFFLElBQUksQ0FDZixLQUFLLENBQUUsT0FBTyxBQUNsQixDQUFDLEFBRU8sb0JBQW9CLEFBQUUsQ0FBQyxBQUMzQixNQUFNLENBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEFBQzVCLENBQUMsQUFFTyxZQUFZLEFBQUUsQ0FBQyxBQUNuQixrQkFBa0IsQ0FBRSxHQUFH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 */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[47] = list[i];
	child_ctx[49] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	child_ctx[46] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[47] = list[i];
	child_ctx[49] = i;
	return child_ctx;
}

// (681:24) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_id_value;
	let input_data_tag_value;
	let input_name_value;
	let input_style_value;
	let input_value_value;
	let t0;
	let span1;
	let span0;
	let span0_id_value;
	let t1;
	let span1_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			span1 = element("span");
			span0 = element("span");
			t1 = space();
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = /*val*/ ctx[47].id);
			attr_dev(input, "data-tag", input_data_tag_value = /*val*/ ctx[47].dataTag);
			attr_dev(input, "name", input_name_value = /*val*/ ctx[47].name);
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");

			input.value = input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[49]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[49]];

			attr_dev(input, "class", "tdFont");
			add_location(input, file, 682, 32, 23464);
			attr_dev(span0, "id", span0_id_value = /*val*/ ctx[47].spanid);
			attr_dev(span0, "class", "answer_icon");
			add_location(span0, file, 685, 36, 23829);
			attr_dev(span1, "class", span1_class_value = /*state*/ ctx[2].iconVisible + " relative");
			add_location(span1, file, 684, 32, 23746);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t1);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*rowValidation*/ ctx[12], false, false, false),
					listen_dev(input, "input", highLight, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsPre*/ 8 && input_id_value !== (input_id_value = /*val*/ ctx[47].id)) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_data_tag_value !== (input_data_tag_value = /*val*/ ctx[47].dataTag)) {
				attr_dev(input, "data-tag", input_data_tag_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_name_value !== (input_name_value = /*val*/ ctx[47].name)) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty[0] & /*myAns*/ 2 && input_value_value !== (input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[49]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[49]]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && span0_id_value !== (span0_id_value = /*val*/ ctx[47].spanid)) {
				attr_dev(span0, "id", span0_id_value);
			}

			if (dirty[0] & /*state*/ 4 && span1_class_value !== (span1_class_value = /*state*/ ctx[2].iconVisible + " relative")) {
				attr_dev(span1, "class", span1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(681:24) {:else}",
		ctx
	});

	return block;
}

// (679:24) {#if val.decpoint == true}
function create_if_block_4(ctx) {
	let input;
	let input_style_value;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");
			input.value = ".";
			input.disabled = "true";
			attr_dev(input, "class", "tdFont");
			add_location(input, file, 679, 28, 23264);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(679:24) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (678:20) {#each ColsPre as val,i}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*val*/ ctx[47].decpoint == true) return create_if_block_4;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(678:20) {#each ColsPre as val,i}",
		ctx
	});

	return block;
}

// (695:16) {#if state.plus_minus == 1}
function create_if_block_3(ctx) {
	let griddedhelper0;
	let t;
	let griddedhelper1;
	let current;

	griddedhelper0 = new GriddedHelper({
			props: {
				loop: /*Cols*/ ctx[8],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "+"
			},
			$$inline: true
		});

	griddedhelper0.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	griddedhelper1 = new GriddedHelper({
			props: {
				loop: /*Cols_Minus*/ ctx[9],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element minus_point",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "-"
			},
			$$inline: true
		});

	griddedhelper1.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper0.$$.fragment);
			t = space();
			create_component(griddedhelper1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(griddedhelper1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper0_changes = {};
			if (dirty[0] & /*Cols*/ 256) griddedhelper0_changes.loop = /*Cols*/ ctx[8];
			griddedhelper0.$set(griddedhelper0_changes);
			const griddedhelper1_changes = {};
			if (dirty[0] & /*Cols_Minus*/ 512) griddedhelper1_changes.loop = /*Cols_Minus*/ ctx[9];
			griddedhelper1.$set(griddedhelper1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper0.$$.fragment, local);
			transition_in(griddedhelper1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper0.$$.fragment, local);
			transition_out(griddedhelper1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(griddedhelper1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(695:16) {#if state.plus_minus == 1}",
		ctx
	});

	return block;
}

// (716:12) {#if state.decimal_val == 1}
function create_if_block_2(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_decimal*/ ctx[7],
				class1: "tdFont points",
				className: "tdFontP text-center items_element decl_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 mb-0 myP",
				value: "."
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_decimal*/ 128) griddedhelper_changes.loop = /*Cols_decimal*/ ctx[7];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(716:12) {#if state.decimal_val == 1}",
		ctx
	});

	return block;
}

// (727:12) {#if state.slash_val == 1}
function create_if_block_1(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[6],
				class1: "tdFont points",
				className: "tdFontP text-center items_element sla_point",
				tableId: "tdFontP slash_tab",
				tableClass: "slash_tab gridded_tab mt-0",
				value: "/"
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 64) griddedhelper_changes.loop = /*Cols_slash*/ ctx[6];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(727:12) {#if state.slash_val == 1}",
		ctx
	});

	return block;
}

// (747:32) {:else}
function create_else_block(ctx) {
	let td;
	let span;
	let t_value = +/*no*/ ctx[46] + "";
	let t;
	let span_tabindex_value;
	let span_key_value;
	let span_name_value;
	let span_data_tag_value;
	let span_id_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "tabindex", span_tabindex_value = /*val*/ ctx[47].tabIndex);
			attr_dev(span, "key", span_key_value = /*val*/ ctx[47].key);
			attr_dev(span, "name", span_name_value = /*val*/ ctx[47].name);
			attr_dev(span, "data-tag", span_data_tag_value = /*val*/ ctx[47].dataTag);
			attr_dev(span, "class", "tdFontP text-center td_data algn items_element");
			attr_dev(span, "id", span_id_value = /*val*/ ctx[47].id);
			add_location(span, file, 748, 40, 26754);
			attr_dev(td, "width", "50");
			attr_dev(td, "class", "text-center");
			add_location(td, file, 747, 36, 26677);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*handleClick*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && span_tabindex_value !== (span_tabindex_value = /*val*/ ctx[47].tabIndex)) {
				attr_dev(span, "tabindex", span_tabindex_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_key_value !== (span_key_value = /*val*/ ctx[47].key)) {
				attr_dev(span, "key", span_key_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_name_value !== (span_name_value = /*val*/ ctx[47].name)) {
				attr_dev(span, "name", span_name_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_data_tag_value !== (span_data_tag_value = /*val*/ ctx[47].dataTag)) {
				attr_dev(span, "data-tag", span_data_tag_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_id_value !== (span_id_value = /*val*/ ctx[47].id)) {
				attr_dev(span, "id", span_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(747:32) {:else}",
		ctx
	});

	return block;
}

// (744:32) {#if val.decpoint}
function create_if_block(ctx) {
	let td;
	let td_key_value;

	const block = {
		c: function create() {
			td = element("td");
			attr_dev(td, "key", td_key_value = /*val*/ ctx[47].key);
			attr_dev(td, "class", "tdFont text-center");
			attr_dev(td, "width", "50");
			attr_dev(td, "disabled", "true");
			add_location(td, file, 744, 36, 26478);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && td_key_value !== (td_key_value = /*val*/ ctx[47].key)) {
				attr_dev(td, "key", td_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(744:32) {#if val.decpoint}",
		ctx
	});

	return block;
}

// (743:28) {#each totalCols as val,i}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*val*/ ctx[47].decpoint) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(743:28) {#each totalCols as val,i}",
		ctx
	});

	return block;
}

// (741:20) {#each totalRows as data,no}
function create_each_block(ctx) {
	let tr;
	let t;
	let tr_key_value;
	let each_value_1 = /*totalCols*/ ctx[5];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "key", tr_key_value = /*data*/ ctx[44].key);
			add_location(tr, file, 741, 24, 26313);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols, handleClick*/ 1056) {
				each_value_1 = /*totalCols*/ ctx[5];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*totalRows*/ 16 && tr_key_value !== (tr_key_value = /*data*/ ctx[44].key)) {
				attr_dev(tr, "key", tr_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(741:20) {#each totalRows as data,no}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let center1;
	let div;
	let center0;
	let itemhelper;
	let t0;
	let table0;
	let tr;
	let table0_style_value;
	let t1;
	let t2;
	let t3;
	let t4;
	let table1;
	let tbody;
	let current;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[13],
				reviewMode: /*isReview*/ ctx[0]
			},
			$$inline: true
		});

	let each_value_2 = /*ColsPre*/ ctx[3];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block0 = /*state*/ ctx[2].plus_minus == 1 && create_if_block_3(ctx);
	let if_block1 = /*state*/ ctx[2].decimal_val == 1 && create_if_block_2(ctx);
	let if_block2 = /*state*/ ctx[2].slash_val == 1 && create_if_block_1(ctx);
	let each_value = /*totalRows*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			main = element("main");
			center1 = element("center");
			div = element("div");
			center0 = element("center");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			table0 = element("table");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			table1 = element("table");
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(center0, file, 669, 12, 22817);
			set_style(tr, "display", "flex");
			add_location(tr, file, 676, 16, 23110);
			attr_dev(table0, "border", "1");
			attr_dev(table0, "id", "tab2");
			attr_dev(table0, "style", table0_style_value = "border-collapse:collapse;text-align:center");
			add_location(table0, file, 675, 12, 23010);
			add_location(tbody, file, 739, 16, 26230);
			attr_dev(table1, "id", "gridded_sheet");
			attr_dev(table1, "class", "gridded_tab mt-0 lastGrid create_tab myP");
			add_location(table1, file, 738, 12, 26137);
			attr_dev(div, "class", "griddedModule");
			add_location(div, file, 668, 8, 22776);
			add_location(center1, file, 667, 4, 22758);
			add_location(main, file, 666, 0, 22746);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, center1);
			append_dev(center1, div);
			append_dev(div, center0);
			mount_component(itemhelper, center0, null);
			append_dev(div, t0);
			append_dev(div, table0);
			append_dev(table0, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t4);
			append_dev(div, table1);
			append_dev(table1, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);

			if (dirty[0] & /*ColsPre, state, myAns, rowValidation*/ 4110) {
				each_value_2 = /*ColsPre*/ ctx[3];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (/*state*/ ctx[2].plus_minus == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].decimal_val == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].slash_val == 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*totalRows, totalCols, handleClick*/ 1072) {
				each_value = /*totalRows*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(itemhelper);
			destroy_each(each_blocks_1, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function highLight(event) {
	let cell_class = event.target.getAttribute("name");
	let column_index = document.getElementsByName(cell_class);

	for (let i = 1; i < column_index.length; i++) {
		if (column_index[i].classList.contains("active")) {
			column_index[i].classList.remove("active");
		}

		if (column_index[i].innerHTML == event.target.value) {
			column_index[i].classList.add("active");
		}
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GriddedPreview", slots, []);
	let { isReview } = $$props;
	let { xml } = $$props;
	let { showAns } = $$props;
	let { uxml } = $$props;
	let { editorState } = $$props;

	// Declare global variables ////
	let bool = " ";

	let userAns = [];
	let ans = [];
	let myAns = [];
	let c = 0;
	let correctInc;
	let isAnswerCorrect = "";
	let answerStatus = "";
	let authAnsSplit;
	let incorrectCls = "";
	let userXML;

	let stateData = writable({
		rowNum: 4,
		colNum: 4,
		item: 1,
		plus_minus: 0,
		slash_val: 0,
		decimal_val: 0,
		xml: "",
		textSizeP: 0,
		correctAns: [],
		userList: [],
		isMathquill: false,
		smController: "h",
		pointerEvents: "auto",
		decimal_point: 0,
		iconVisible: "h"
	});

	let state = {};

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(2, state = items);
	});

	onMount(() => {
		// $('body').on('keydown', '.td_data', function(e) { 
		//     if (e.which === 13) {
		//         $(this).click();
		//     }
		// });
		AH.listen(document, "keydown", ".td_data", (data, e) => {
			if (e.which === 13) {
				data.click();
			}
		});

		// jQuery('#sm_controller button').click(function() {
		//     jQuery('#sm_controller button').removeClass("active btn-secondary text-white bg-secondary");
		//     jQuery(this).addClass('active btn-secondary text-white bg-secondary');
		// });
		AH.listen(document, "click", "#sm_controller button", e => {
			AH.selectAll("#sm_controller button", "removeClass", ["active,btn-secondary,text-white,bg-secondary"]);
			AH.selectAll(e, "addClass", ["active,btn-secondary,text-white,bg-secondary"]);
		});

		AH.listen(document, "click", "#set-review", function () {
			setReview();
		});

		AH.listen(document, "click", "#unset-review", function () {
			unsetReview();
		});
	});

	function loadModule(loadXml) {
		loadXml = XMLToJSON(loadXml);
		parseXMLPreview(loadXml);
	}

	function parseXMLPreview(MYXML) {
		try {
			$$invalidate(2, state.rowNum = MYXML.smxml._row, state);
			$$invalidate(2, state.colNum = MYXML.smxml._col, state);
			$$invalidate(2, state.slash_val = MYXML.smxml._slash, state);
			$$invalidate(2, state.plus_minus = MYXML.smxml._plusminus, state);
			$$invalidate(2, state.decimal_val = MYXML.smxml._decimal, state);
			$$invalidate(2, state.textSizeP = MYXML.smxml._font, state);
			$$invalidate(2, state.correctAns = MYXML.smxml._correctAns.split(","), state);
			$$invalidate(2, state.decimal_point = MYXML.smxml._fixed_point, state);

			//if (window.uaXML) {
			if (uxml) {
				// let timer = setTimeout(function() {
				//parseUserAns(window.uaXML);
				parseUserAns(uxml);
			} //     clearTimeout(timer);
			// },50);
		} catch(error) {
			onError = error;

			console.log({
				"error": error.message,
				"function name": "parseXMLPreview",
				"File name": "GriddedPreview.js"
			});
		}
	}

	function parseUserAns(uans) {
		let userAnswer = XMLToJSON(uans);

		if (userAnswer.smans && userAnswer.smans.div && userAnswer.smans.div._userAns) {
			userAns = userAnswer.smans.div._userAns.split(",");
			bool = userAnswer.smans.div._correct;

			// $("#answer").prop("checked", bool)
			ans = userAns;
		} //forceUpdate();
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(2, state.xml = xml, state);
			loadModule(xml);
		}

		//if (this.props.remedStatus != nextProps.remedStatus) {
		//} 
		//if (window.QXML) {
		if (xml) {
			console.log("qxml");
		}

		firstRowItemPre();
		decimalFloatingPre();
		slashFuncPre();
		plusMinusSignPre();
		createdSheetRowPre();
	});

	function handleClick(event) {
		//////////////changing color according to user/////////
		let cell_class = event.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.target.innerHTML;
		setUserAns(event); //////// Call function for answer checking
	}

	function setUserAns(event) {
		let countRes;
		let resNew;
		let ansBool;

		//////// This code set the answer///////////
		let attr = event.target.attributes.getNamedItem("data-tag").value;

		if (event.target.innerHTML === "") {
			userAns[attr] = event.target.value;
		} else {
			userAns[attr] = event.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == "undefined" || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = language.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = language.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = language.incorrect;
		} // return false;

		// if (!window.QXML) {
		if (editorState) {
			showAns(countRes);
		}

		ansBool = countRes == "correct" ? true : false;
		userXML = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		//AH.select("#special_module_user_xml").value = userXML
		resNew = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != " " && c == user.length) {
			//jQUery("#answer").prop("checked", bool);
			AH.select("#answer", "attr", { "checked": bool });
		} else {
			//jQuery("#answer").prop("checked", isAnswerCorrect);
			AH.select("#answer", "attr", { "checked": isAnswerCorrect });
		}

		$$invalidate(14, uxml = userXML);
		onUserAnsChange({ uXml: resNew, ans: ansBool });
	}

	function handleClickCombo(event) {
		//////////////changing color according to user/////////
		let cell_class = event.detail.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.detail.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.detail.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.detail.target.innerHTML;
		setUserAnsCombo(event); //////// Call function for answer checking
	}

	function setUserAnsCombo(event) {
		let countRes;

		//////// This code set the answer///////////
		let attr = event.detail.target.attributes.getNamedItem("data-tag").value;

		if (event.detail.target.innerHTML === "") {
			userAns[attr] = event.detail.target.value;
		} else {
			userAns[attr] = event.detail.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == "undefined" || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = language.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = language.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = language.incorrect;
		} // return false;

		//if (!window.QXML) {
		if (editorState) {
			showAns(countRes);
		}

		//jQuery("#special_module_user_xml").val("<smans><div type='56' correct='"+isAnswerCorrect+"' userAns='"+state.userList+"'></div></smans>");
		AH.select("#special_module_user_xml").value = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != " " && c == user.length) {
			//jQUery("#answer").prop("checked", bool);
			AH.select("#answer", "attr", { "checked": bool });
		} else {
			//jQuery("#answer").prop("checked", isAnswerCorrect);
			AH.select("#answer", "attr", { "checked": isAnswerCorrect });
		}
	}

	function rowValidation(event) {
		let a = state.rowNum - 1;

		if (event.target.value.length > 1) {
			AH.alert("Double digit not accepted");
			event.target.value = "";
			return false;
		} else if (event.target.value < 0) {
			AH.alert("Less then 1 not accepted");
			event.target.value = "";
			return false;
		} else if (a < event.target.value) {
			AH.alert("Number insert only 0 to " + state.rowNum);
			event.target.value = "";
			return false;
		}

		setUserAns(event);
	}

	////////////////// Create very first row and store data according to click//////////
	let ColsPre = [];

	function firstRowItemPre() {
		$$invalidate(3, ColsPre = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (ans[j] === "%blank%") {
				$$invalidate(1, myAns[j] = " ", myAns);
			} else {
				$$invalidate(1, myAns[j] = ans[j], myAns);
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(3, ColsPre = [...ColsPre, { decpoint: true }]);
			} else {
				if (ColsPre.length < state.colNum) {
					$$invalidate(3, ColsPre = [
						...ColsPre,
						{
							id: "t" + j,
							dataTag: j,
							name: "p" + j,
							value: myAns[j],
							spanid: "t_" + j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	let totalRows = [];
	let totalCols = [];

	function createdSheetRowPre() {
		$$invalidate(4, totalRows = []);
		let dec_point = state.decimal_point;

		for (let i = 0; i < state.rowNum; i++) {
			$$invalidate(5, totalCols = []);

			for (let j = 0; j < state.colNum; j++) {
				if (j == dec_point - 1 && dec_point != 0) {
					$$invalidate(5, totalCols = [...totalCols, { key: "col" + i + j, decpoint: true }]);
				} else {
					if (totalCols.length < state.colNum) {
						$$invalidate(5, totalCols = [
							...totalCols,
							{
								tabIndex: 0,
								key: "col" + i + j,
								name: "p" + j,
								dataTag: j,
								id: "t" + j + "-" + i + j,
								decpoint: false
							}
						]);
					}
				}
			}

			//totalRows.push(<tr key={"row"+i}>{totalCols}</tr>);
			$$invalidate(4, totalRows = [...totalRows, { key: "row" + i }]);
		}
	}

	let Cols_slash = [];

	function slashFuncPre(event) {
		$$invalidate(6, Cols_slash = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(6, Cols_slash = [...Cols_slash, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_slash.length < state.colNum) {
					$$invalidate(6, Cols_slash = [
						...Cols_slash,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	
	let Cols_decimal = [];

	function decimalFloatingPre(event) {
		$$invalidate(7, Cols_decimal = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(7, Cols_decimal = [...Cols_decimal, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_decimal.length < state.colNum) {
					$$invalidate(7, Cols_decimal = [
						...Cols_decimal,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	///////////////// Set review and unset review function//////////////
	function setReview() {
		console.trace();
		($$invalidate(2, state.smController = "", state), $$invalidate(2, state.pointerEvents = "none", state));
		$$invalidate(0, isReview = true);
		showAnswer("yans", "showIcon");

		//jQuery('#sm_controller .your-ans').addClass("btn-light active");
		AH.selectAll("#sm_controller .your-ans", "addClass", ["btn-light", "active"]);

		//jQuery(".tokenHeader").attr("tabindex", "0");
		AH.selectAll(".tokenHeader", "attr", { "tabindex": 0 });

		//document.querySelector(".tokenHeader").setAttribute("tabindex","0");
		setTimeout(getCorrect(), 200);

		// if (!window.QXML) {
		if (editorState) {
			showAns(isAnswerCorrect ? language.correct : language.incorrect);
		}
	}

	function getCorrect() {
		for (let i = 0; i < state.correctAns.length; i++) {
			if (state.correctAns[i] == state.userList[i]) {
				//jQuery('#t_'+i).removeClass("icomoon-new-24px-cancel-circle-1").addClass("icomoon-new-24px-checkmark-circle-1");
				AH.select("#t_" + i, "removeClass", "icomoon-new-24px-cancel-circle-1");

				AH.select("#t_" + i, "addClass", "icomoon-new-24px-checkmark-circle-1");
			} else {
				//jQuery('#t_'+i).removeClass("icomoon-new-24px-checkmark-circle-1").addClass("icomoon-new-24px-cancel-circle-1");
				AH.select("#t_" + i, "removeClass", "icomoon-new-24px-checkmark-circle-1");

				AH.select("#t_" + i, "addClass", "icomoon-new-24px-cancel-circle-1");
			}
		}
	}

	function unsetReview() {
		($$invalidate(2, state.smController = "h", state), $$invalidate(2, state.pointerEvents = "auto", state));
		$$invalidate(0, isReview = false);
		showAnswer("yans", "hideIcon");

		//jQuery(".tokenHeader").removeAttr("tabindex");
		AH.selectAll(".tokenHeader", "removeAttr", "tabindex");
	}

	function showAnswer(val, iconState) {
		//show correct incorrect icon with respect to iconState
		if (iconState == "showIcon") {
			$$invalidate(2, state.iconVisible = "", state);
		} else {
			$$invalidate(2, state.iconVisible = "h", state);
		}

		if (val == "cans") {
			let ele = document.getElementsByClassName("gridded_tab");
			ele.disabled = true;
			ans = state.correctAns;
		} else if (val == "yans") {
			ans = userAns;
		}
	}

	///////////////////////////// create plus and minus row//////////////////
	let Cols = [];

	let Cols_Minus = [];

	function plusMinusSignPre(event) {
		$$invalidate(8, Cols = []);
		$$invalidate(9, Cols_Minus = []);
		let dec_point = state.decimal_point;

		//let arr = [];
		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(8, Cols = [
					...Cols,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols.length < state.colNum) {
					$$invalidate(8, Cols = [
						...Cols,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(9, Cols_Minus = [
					...Cols_Minus,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols_Minus.length < state.colNum) {
					$$invalidate(9, Cols_Minus = [
						...Cols_Minus,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	function handleReview(mode) {
		if (mode == "c") {
			showAnswer("cans", "hideIcon");
		} else {
			showAnswer("yans", "showIcon");
		}
	}

	const writable_props = ["isReview", "xml", "showAns", "uxml", "editorState"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<GriddedPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("showAns" in $$props) $$invalidate(16, showAns = $$props.showAns);
		if ("uxml" in $$props) $$invalidate(14, uxml = $$props.uxml);
		if ("editorState" in $$props) $$invalidate(17, editorState = $$props.editorState);
	};

	$$self.$capture_state = () => ({
		l: language,
		ItemHelper,
		writable,
		AH,
		XMLToJSON,
		JSONToXML,
		onUserAnsChange,
		afterUpdate,
		beforeUpdate,
		onMount,
		GriddedHelper,
		isReview,
		xml,
		showAns,
		uxml,
		editorState,
		bool,
		userAns,
		ans,
		myAns,
		c,
		correctInc,
		isAnswerCorrect,
		answerStatus,
		authAnsSplit,
		incorrectCls,
		userXML,
		stateData,
		state,
		unsubscribe,
		loadModule,
		parseXMLPreview,
		parseUserAns,
		handleClick,
		setUserAns,
		handleClickCombo,
		setUserAnsCombo,
		rowValidation,
		highLight,
		ColsPre,
		firstRowItemPre,
		totalRows,
		totalCols,
		createdSheetRowPre,
		Cols_slash,
		slashFuncPre,
		Cols_decimal,
		decimalFloatingPre,
		setReview,
		getCorrect,
		unsetReview,
		showAnswer,
		Cols,
		Cols_Minus,
		plusMinusSignPre,
		handleReview
	});

	$$self.$inject_state = $$props => {
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("showAns" in $$props) $$invalidate(16, showAns = $$props.showAns);
		if ("uxml" in $$props) $$invalidate(14, uxml = $$props.uxml);
		if ("editorState" in $$props) $$invalidate(17, editorState = $$props.editorState);
		if ("bool" in $$props) bool = $$props.bool;
		if ("userAns" in $$props) userAns = $$props.userAns;
		if ("ans" in $$props) ans = $$props.ans;
		if ("myAns" in $$props) $$invalidate(1, myAns = $$props.myAns);
		if ("c" in $$props) c = $$props.c;
		if ("correctInc" in $$props) correctInc = $$props.correctInc;
		if ("isAnswerCorrect" in $$props) isAnswerCorrect = $$props.isAnswerCorrect;
		if ("answerStatus" in $$props) answerStatus = $$props.answerStatus;
		if ("authAnsSplit" in $$props) authAnsSplit = $$props.authAnsSplit;
		if ("incorrectCls" in $$props) incorrectCls = $$props.incorrectCls;
		if ("userXML" in $$props) userXML = $$props.userXML;
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
		if ("ColsPre" in $$props) $$invalidate(3, ColsPre = $$props.ColsPre);
		if ("totalRows" in $$props) $$invalidate(4, totalRows = $$props.totalRows);
		if ("totalCols" in $$props) $$invalidate(5, totalCols = $$props.totalCols);
		if ("Cols_slash" in $$props) $$invalidate(6, Cols_slash = $$props.Cols_slash);
		if ("Cols_decimal" in $$props) $$invalidate(7, Cols_decimal = $$props.Cols_decimal);
		if ("Cols" in $$props) $$invalidate(8, Cols = $$props.Cols);
		if ("Cols_Minus" in $$props) $$invalidate(9, Cols_Minus = $$props.Cols_Minus);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isReview*/ 1) {
			 {
				if (isReview) {
					setReview();
				} else {
					unsetReview(); // this.checkAns();
				}
			}
		}
	};

	return [
		isReview,
		myAns,
		state,
		ColsPre,
		totalRows,
		totalCols,
		Cols_slash,
		Cols_decimal,
		Cols,
		Cols_Minus,
		handleClick,
		handleClickCombo,
		rowValidation,
		handleReview,
		uxml,
		xml,
		showAns,
		editorState
	];
}

class GriddedPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-vscbpc-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				isReview: 0,
				xml: 15,
				showAns: 16,
				uxml: 14,
				editorState: 17
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GriddedPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isReview*/ ctx[0] === undefined && !("isReview" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'isReview'");
		}

		if (/*xml*/ ctx[15] === undefined && !("xml" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'xml'");
		}

		if (/*showAns*/ ctx[16] === undefined && !("showAns" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'showAns'");
		}

		if (/*uxml*/ ctx[14] === undefined && !("uxml" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'uxml'");
		}

		if (/*editorState*/ ctx[17] === undefined && !("editorState" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'editorState'");
		}
	}

	get isReview() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showAns() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default GriddedPreview;
//# sourceMappingURL=GriddedPreview-84d1c6df.js.map
