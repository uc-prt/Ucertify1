{"version":3,"file":"parseCSV-929be628.js","sources":["../../../clsSMChoiceMatrix/parseCSV.js"],"sourcesContent":["export default {\r\n    parseCSVFormat: function(data) {\r\n\t\tlet newJSON = {stem:\"\",term:[],option:[]};\r\n\t\tlet arr = data.split(\"\\n\");\r\n\t\tlet newArr = [];\r\n\t\tarr.map((val)=>{\r\n\t\t\tif(val.trim()) {\r\n\t\t\t\tnewArr.push(val);\r\n\t\t\t}\r\n\t\t});\r\n\t\tnewArr.map(function(value,i){\r\n\t\t\tlet innerValue =  value.replace(/,$/gm,\"\");\r\n\t\t\tinnerValue = innerValue.split(\",\");\r\n\t\t\tif (i == 0) {\r\n\t\t\t\tinnerValue.map((value2,j)=>{\r\n\t\t\t\t\tif(j == 0) {\r\n\t\t\t\t\t\tnewJSON.stem = value2;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnewJSON.option.push({\r\n\t\t\t\t\t\t\tid:'o'+j,\r\n\t\t\t\t\t\t\ttext:value2.replace(/^\\s+/g, \"\")\r\n\t\t\t\t\t\t});0\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tlet termText = \"\";\r\n\t\t\t\tlet termCorrect = \"\"\r\n\t\t\t\tinnerValue.map((termValue,k)=>{\r\n\t\t\t\t\tif(k == 0) {\r\n\t\t\t\t\t\ttermText = termValue.replace(/^\\s+/g, \"\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif(termValue.trim() == \"1\") {\r\n\t\t\t\t\t\t\ttermCorrect = \"o\"+k;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tnewJSON.term.push({\r\n\t\t\t\t\tid:'t'+i,\r\n\t\t\t\t\ttext:termText,\r\n\t\t\t\t\tcorrect:termCorrect\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn newJSON;\r\n    },\r\n\tCSVToArray: function (strData, strDelimiter) {\r\n\t\t// Check to see if the delimiter is defined. If not,\r\n\t\t// then default to comma.\r\n\t\tstrDelimiter = (strDelimiter || \",\");\r\n\t\t// Create a regular expression to parse the CSV values.\r\n\t\tvar objPattern = new RegExp((\r\n\t\t// Delimiters.\r\n\t\t\"(\\\\\" + strDelimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\r\n\t\t// Quoted fields.\r\n\t\t\"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\r\n\t\t// Standard fields.\r\n\t\t\"([^\\\"\\\\\" + strDelimiter + \"\\\\r\\\\n]*))\"), \"gi\");\r\n\t\t// Create an array to hold our data. Give the array\r\n\t\t// a default empty first row.\r\n\t\tvar arrData = [[]];\r\n\t\t// Create an array to hold our individual pattern\r\n\t\t// matching groups.\r\n\t\tvar arrMatches = null;\r\n\t\t// Keep looping over the regular expression matches\r\n\t\t// until we can no longer find a match.\r\n\t\twhile (arrMatches = objPattern.exec(strData)) {\r\n\t\t\t// Get the delimiter that was found.\r\n\t\t\tvar strMatchedDelimiter = arrMatches[1];\r\n\t\t\t// Check to see if the given delimiter has a length\r\n\t\t\t// (is not the start of string) and if it matches\r\n\t\t\t// field delimiter. If id does not, then we know\r\n\t\t\t// that this delimiter is a row delimiter.\r\n\t\t\tif (strMatchedDelimiter.length && (strMatchedDelimiter != strDelimiter)) {\r\n\t\t\t\t// Since we have reached a new row of data,\r\n\t\t\t\t// add an empty row to our data array.\r\n\t\t\t\tarrData.push([]);\r\n\t\t\t}\r\n\t\t\t// Now that we have our delimiter out of the way,\r\n\t\t\t// let's check to see which kind of value we\r\n\t\t\t// captured (quoted or unquoted).\r\n\t\t\tif (arrMatches[2]) {\r\n\t\t\t\t// We found a quoted value. When we capture\r\n\t\t\t\t// this value, unescape any double quotes.\r\n\t\t\t\tvar strMatchedValue = arrMatches[2].replace(\r\n\t\t\t\tnew RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\r\n\t\t\t} else {\r\n\t\t\t\t// We found a non-quoted value.\r\n\t\t\t\tvar strMatchedValue = arrMatches[3];\r\n\t\t\t}\r\n\t\t\t// Now that we have our value string, let's add\r\n\t\t\t// it to the data array.\r\n\t\t\tarrData[arrData.length - 1].push(strMatchedValue);\r\n\t\t}\r\n\t\t// Return the parsed data.\r\n\t\treturn (arrData);\r\n\t},\r\n\tCSV2JSON: function (csv) {\r\n\t\tvar array = this.CSVToArray(csv);\r\n\t\tvar objArray = [];\r\n\t\tfor (var i = 1; i < array.length; i++) {\r\n\t\t\tobjArray[i - 1] = {};\r\n\t\t\tfor (var k = 0; k < array[0].length && k < array[i].length; k++) {\r\n\t\t\t\tvar key = array[0][k];\r\n\t\t\t\tobjArray[i - 1][key] = array[i][k]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar json = JSON.stringify(objArray);\r\n\t\tvar str = json.replace(/},/g, \"},\\r\\n\");\r\n\r\n\t\treturn str;\r\n\t}\r\n}"],"names":["parseCSVFormat","data","newJSON","stem","term","option","arr","split","newArr","map","val","trim","push","value","i","innerValue","replace","value2","j","id","text","termText","termCorrect","termValue","k","correct","CSVToArray","strData","strDelimiter","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","length","strMatchedValue","CSV2JSON","csv","array","this","objArray","key","JSON","stringify"],"mappings":"AAAA,MAAe,CACXA,eAAgB,SAASC,GAC3B,IAAIC,EAAU,CAACC,KAAK,GAAGC,KAAK,GAAGC,OAAO,IAClCC,EAAML,EAAKM,MAAM,MACjBC,EAAS,GA0Cb,OAzCAF,EAAIG,KAAKC,IACLA,EAAIC,QACNH,EAAOI,KAAKF,MAGdF,EAAOC,KAAI,SAASI,EAAMC,GACzB,IAAIC,EAAcF,EAAMG,QAAQ,OAAO,IAEvC,GADAD,EAAaA,EAAWR,MAAM,KACrB,GAALO,EACHC,EAAWN,KAAI,CAACQ,EAAOC,KACd,GAALA,EACFhB,EAAQC,KAAOc,EAEff,EAAQG,OAAOO,KAAK,CACnBO,GAAG,IAAID,EACPE,KAAKH,EAAOD,QAAQ,QAAS,aAI1B,CACN,IAAIK,EAAW,GACXC,EAAc,GAClBP,EAAWN,KAAI,CAACc,EAAUC,KACzB,GAAQ,GAALA,EACFH,EAAWE,EAAUP,QAAQ,QAAS,SAEtC,GAAuB,KAApBO,EAAUZ,OAEZ,OADAW,EAAc,IAAIE,GACX,KAKVtB,EAAQE,KAAKQ,KAAK,CACjBO,GAAG,IAAIL,EACPM,KAAKC,EACLI,QAAQH,QAKJpB,GAERwB,WAAY,SAAUC,EAASC,GAG9BA,EAAgBA,GAAgB,IAiBhC,IAfA,IAAIC,EAAa,IAAIC,OAErB,MAAQF,EAAR,iDAIYA,EAAe,aAAe,MAGtCG,EAAU,CAAC,IAGXC,EAAa,KAGVA,EAAaH,EAAWI,KAAKN,IAAU,CAE7C,IAAIO,EAAsBF,EAAW,GAarC,GARIE,EAAoBC,QAAWD,GAAuBN,GAGzDG,EAAQnB,KAAK,IAKVoB,EAAW,GAGd,IAAII,EAAkBJ,EAAW,GAAGhB,QACpC,IAAIc,OAAO,KAAQ,KAAM,UAGrBM,EAAkBJ,EAAW,GAIlCD,EAAQA,EAAQI,OAAS,GAAGvB,KAAKwB,GAGlC,UAEDC,SAAU,SAAUC,GAGnB,IAFA,IAAIC,EAAQC,KAAKd,WAAWY,GACxBG,EAAW,GACN3B,EAAI,EAAGA,EAAIyB,EAAMJ,OAAQrB,IAAK,CACtC2B,EAAS3B,EAAI,GAAK,GAClB,IAAK,IAAIU,EAAI,EAAGA,EAAIe,EAAM,GAAGJ,QAAUX,EAAIe,EAAMzB,GAAGqB,OAAQX,IAAK,CAChE,IAAIkB,EAAMH,EAAM,GAAGf,GACnBiB,EAAS3B,EAAI,GAAG4B,GAAOH,EAAMzB,GAAGU,IAOlC,OAHWmB,KAAKC,UAAUH,GACXzB,QAAQ,MAAO"}