{"version":3,"file":"parseCSV-3f55367f.js","sources":["../../../clsSMChoiceMatrix/parseCSV.js"],"sourcesContent":["module.exports = {\n    parseCSVFormat: function(data) {\n\t\tlet newJSON = {stem:\"\",term:[],option:[]};\n\t\tlet arr = data.split(\"\\n\");\n\t\tlet newArr = [];\n\t\tarr.map((val)=>{\n\t\t\tif(val.trim()) {\n\t\t\t\tnewArr.push(val);\n\t\t\t}\n\t\t});\n\t\tnewArr.map(function(value,i){\n\t\t\tlet innerValue =  value.replace(/,$/gm,\"\");\n\t\t\tinnerValue = innerValue.split(\",\");\n\t\t\tif (i == 0) {\n\t\t\t\tinnerValue.map((value2,j)=>{\n\t\t\t\t\tif(j == 0) {\n\t\t\t\t\t\tnewJSON.stem = value2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewJSON.option.push({\n\t\t\t\t\t\t\tid:'o'+j,\n\t\t\t\t\t\t\ttext:value2.replace(/^\\s+/g, \"\")\n\t\t\t\t\t\t});0\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tlet termText = \"\";\n\t\t\t\tlet termCorrect = \"\"\n\t\t\t\tinnerValue.map((termValue,k)=>{\n\t\t\t\t\tif(k == 0) {\n\t\t\t\t\t\ttermText = termValue.replace(/^\\s+/g, \"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(termValue.trim() == \"1\") {\n\t\t\t\t\t\t\ttermCorrect = \"o\"+k;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnewJSON.term.push({\n\t\t\t\t\tid:'t'+i,\n\t\t\t\t\ttext:termText,\n\t\t\t\t\tcorrect:termCorrect\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\n\t\treturn newJSON;\n    },\n\tCSVToArray: function (strData, strDelimiter) {\n\t\t// Check to see if the delimiter is defined. If not,\n\t\t// then default to comma.\n\t\tstrDelimiter = (strDelimiter || \",\");\n\t\t// Create a regular expression to parse the CSV values.\n\t\tvar objPattern = new RegExp((\n\t\t// Delimiters.\n\t\t\"(\\\\\" + strDelimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\t\t// Quoted fields.\n\t\t\"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\t\t// Standard fields.\n\t\t\"([^\\\"\\\\\" + strDelimiter + \"\\\\r\\\\n]*))\"), \"gi\");\n\t\t// Create an array to hold our data. Give the array\n\t\t// a default empty first row.\n\t\tvar arrData = [[]];\n\t\t// Create an array to hold our individual pattern\n\t\t// matching groups.\n\t\tvar arrMatches = null;\n\t\t// Keep looping over the regular expression matches\n\t\t// until we can no longer find a match.\n\t\twhile (arrMatches = objPattern.exec(strData)) {\n\t\t\t// Get the delimiter that was found.\n\t\t\tvar strMatchedDelimiter = arrMatches[1];\n\t\t\t// Check to see if the given delimiter has a length\n\t\t\t// (is not the start of string) and if it matches\n\t\t\t// field delimiter. If id does not, then we know\n\t\t\t// that this delimiter is a row delimiter.\n\t\t\tif (strMatchedDelimiter.length && (strMatchedDelimiter != strDelimiter)) {\n\t\t\t\t// Since we have reached a new row of data,\n\t\t\t\t// add an empty row to our data array.\n\t\t\t\tarrData.push([]);\n\t\t\t}\n\t\t\t// Now that we have our delimiter out of the way,\n\t\t\t// let's check to see which kind of value we\n\t\t\t// captured (quoted or unquoted).\n\t\t\tif (arrMatches[2]) {\n\t\t\t\t// We found a quoted value. When we capture\n\t\t\t\t// this value, unescape any double quotes.\n\t\t\t\tvar strMatchedValue = arrMatches[2].replace(\n\t\t\t\tnew RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n\t\t\t} else {\n\t\t\t\t// We found a non-quoted value.\n\t\t\t\tvar strMatchedValue = arrMatches[3];\n\t\t\t}\n\t\t\t// Now that we have our value string, let's add\n\t\t\t// it to the data array.\n\t\t\tarrData[arrData.length - 1].push(strMatchedValue);\n\t\t}\n\t\t// Return the parsed data.\n\t\treturn (arrData);\n\t},\n\tCSV2JSON: function (csv) {\n\t\tvar array = this.CSVToArray(csv);\n\t\tvar objArray = [];\n\t\tfor (var i = 1; i < array.length; i++) {\n\t\t\tobjArray[i - 1] = {};\n\t\t\tfor (var k = 0; k < array[0].length && k < array[i].length; k++) {\n\t\t\t\tvar key = array[0][k];\n\t\t\t\tobjArray[i - 1][key] = array[i][k]\n\t\t\t}\n\t\t}\n\n\t\tvar json = JSON.stringify(objArray);\n\t\tvar str = json.replace(/},/g, \"},\\r\\n\");\n\n\t\treturn str;\n\t}\n}"],"names":["parseCSVFormat","data","newJSON","stem","term","option","arr","split","newArr","map","val","trim","push","value","i","innerValue","replace","value2","j","id","text","termText","termCorrect","termValue","k","correct","CSVToArray","strData","strDelimiter","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","length","strMatchedValue","CSV2JSON","csv","array","this","objArray","key","JSON","stringify"],"mappings":"MAAiB,CACbA,eAAgB,SAASC,GAC3B,IAAIC,EAAU,CAACC,KAAK,GAAGC,KAAK,GAAGC,OAAO,IAClCC,EAAML,EAAKM,MAAM,MACjBC,EAAS,GA0Cb,OAzCAF,EAAIG,KAAKC,IACLA,EAAIC,QACNH,EAAOI,KAAKF,MAGdF,EAAOC,KAAI,SAASI,EAAMC,GACzB,IAAIC,EAAcF,EAAMG,QAAQ,OAAO,IAEvC,GADAD,EAAaA,EAAWR,MAAM,KACrB,GAALO,EACHC,EAAWN,KAAI,CAACQ,EAAOC,KACd,GAALA,EACFhB,EAAQC,KAAOc,EAEff,EAAQG,OAAOO,KAAK,CACnBO,GAAG,IAAID,EACPE,KAAKH,EAAOD,QAAQ,QAAS,aAI1B,CACN,IAAIK,EAAW,GACXC,EAAc,GAClBP,EAAWN,KAAI,CAACc,EAAUC,KACzB,GAAQ,GAALA,EACFH,EAAWE,EAAUP,QAAQ,QAAS,SAEtC,GAAuB,KAApBO,EAAUZ,OAEZ,OADAW,EAAc,IAAIE,GACX,KAKVtB,EAAQE,KAAKQ,KAAK,CACjBO,GAAG,IAAIL,EACPM,KAAKC,EACLI,QAAQH,QAKJpB,GAERwB,WAAY,SAAUC,EAASC,GAG9BA,EAAgBA,GAAgB,IAiBhC,IAfA,IAAIC,EAAa,IAAIC,OAErB,MAAQF,EAAR,iDAIYA,EAAe,aAAe,MAGtCG,EAAU,CAAC,IAGXC,EAAa,KAGVA,EAAaH,EAAWI,KAAKN,IAAU,CAE7C,IAAIO,EAAsBF,EAAW,GAarC,GARIE,EAAoBC,QAAWD,GAAuBN,GAGzDG,EAAQnB,KAAK,IAKVoB,EAAW,GAGd,IAAII,EAAkBJ,EAAW,GAAGhB,QACpC,IAAIc,OAAO,KAAQ,KAAM,UAGrBM,EAAkBJ,EAAW,GAIlCD,EAAQA,EAAQI,OAAS,GAAGvB,KAAKwB,GAGlC,UAEDC,SAAU,SAAUC,GAGnB,IAFA,IAAIC,EAAQC,KAAKd,WAAWY,GACxBG,EAAW,GACN3B,EAAI,EAAGA,EAAIyB,EAAMJ,OAAQrB,IAAK,CACtC2B,EAAS3B,EAAI,GAAK,GAClB,IAAK,IAAIU,EAAI,EAAGA,EAAIe,EAAM,GAAGJ,QAAUX,EAAIe,EAAMzB,GAAGqB,OAAQX,IAAK,CAChE,IAAIkB,EAAMH,EAAM,GAAGf,GACnBiB,EAAS3B,EAAI,GAAG4B,GAAOH,EAAMzB,GAAGU,IAOlC,OAHWmB,KAAKC,UAAUH,GACXzB,QAAQ,MAAO"}