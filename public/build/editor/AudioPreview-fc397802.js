
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, v as validate_slots, o as onMount, A as AH, y as l, X as XMLToJSON, a8 as afterUpdate, a2 as onUserAnsChange, e as element, c as create_component, f as space, h as text, j as attr_dev, k as add_location, n as insert_dev, m as mount_component, p as append_dev, q as listen_dev, t as transition_in, a as transition_out, x as detach_dev, b as destroy_component, G as run_all, F as prop_dev, U as src_url_equal } from './main-f9ee8c90.js';
import { I as ItemHelper } from './ItemHelper-1880ee02.js';
import { s as styleInject } from './style-inject.es-1c867377.js';

var css_248z = ".pointerEventOff{pointer-events:none}.pointerEventOn{pointer-events:auto}.noteColor{color:#c30f0f}.recording_status{height:185px;width:300px;background-color:#000}.img_fit{object-fit:contain}.disabledState,select:disabled{cursor:not-allowed!important}.disabledState{opacity:.5}.custom_checkbox_new{display:block;position:relative;width:20px;height:20px;margin-bottom:0;cursor:pointer;font-size:18px}.custom_checkbox_new input{position:absolute;z-index:-1;opacity:0}.check_mark_custom{width:17px;height:17px;position:absolute;text-align:center;top:2px;left:0;border:1px solid #d4cfcf}.custom_checkbox_new .check_mark_custom:after{content:'';color:#fff;transform:rotate(10deg);margin-top:-3px;width:13px;font-size:13px}.custom_checkbox_new input:checked~.check_mark_custom:after{display:block}.check_mark_custom:after{content:'';position:absolute}.custom_checkbox_new input:checked~.check_mark_custom{background:#4285f4;border:2px solid #a4dbfc}input:focus~.check_mark_custom{box-shadow:0 0 0 .13rem rgb(66 133 244 / 25%)}.btn-light:not([disabled]):not(.disabled).active{color:#fff!important;-webkit-box-shadow:inset 0 2px 0 #1266f1!important;box-shadow:inset 0 2px 0 #1266f1!important;background-color:#2572f2!important;border-color:#2572f2!important;border-top-color:#0c57d3!important}.typeCorrect{background:#d1f5cb!important}.typeIncorrect{background:#f3d2d7!important}.bg-light{background-color:#e4e1e1!important}.top1{top:1px}";
styleInject(css_248z);

/* clsSMAudioRecorder\AudioPreview.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file = "clsSMAudioRecorder\\AudioPreview.svelte";

// (564:8) {:else}
function create_else_block_1(ctx) {
	let div1;
	let div0;
	let b0;
	let t1;
	let t2_value = l.recording_warning + "";
	let t2;
	let t3;
	let t4;
	let div8;
	let div7;
	let div2;
	let b1;
	let t6;
	let div5;
	let span0;
	let t8;
	let div3;
	let img0;
	let img0_src_value;
	let t9;
	let div4;
	let img1;
	let img1_src_value;
	let t10;
	let div6;
	let button0;
	let span1;
	let span1_title_value;
	let button0_aria_label_value;
	let t11;
	let button1;
	let span2;
	let button1_disabled_value;
	let button1_aria_label_value;
	let t12;
	let button2;
	let span3;
	let button2_disabled_value;
	let div6_class_value;
	let mounted;
	let dispose;
	let if_block = /*state*/ ctx[4].showTranscript == true && create_if_block_2(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			b0 = element("b");
			b0.textContent = `${l.note_label}`;
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			if (if_block) if_block.c();
			t4 = space();
			div8 = element("div");
			div7 = element("div");
			div2 = element("div");
			b1 = element("b");
			b1.textContent = `${l.audio_recorder}`;
			t6 = space();
			div5 = element("div");
			span0 = element("span");
			span0.textContent = `${l.starting_message}`;
			t8 = space();
			div3 = element("div");
			img0 = element("img");
			t9 = space();
			div4 = element("div");
			img1 = element("img");
			t10 = space();
			div6 = element("div");
			button0 = element("button");
			span1 = element("span");
			t11 = space();
			button1 = element("button");
			span2 = element("span");
			t12 = space();
			button2 = element("button");
			span3 = element("span");
			attr_dev(b0, "class", "noteColor bolder");
			add_location(b0, file, 566, 20, 27317);
			attr_dev(div0, "class", "");
			attr_dev(div0, "tabindex", "0");
			attr_dev(div0, "aria-label", "Recording will end after 15 sec");
			add_location(div0, file, 565, 16, 27223);
			attr_dev(div1, "class", "col-12 pb-3");
			add_location(div1, file, 564, 12, 27180);
			add_location(b1, file, 578, 103, 28190);
			attr_dev(div2, "class", "p-2 tokenfield bg-light mb-3");
			attr_dev(div2, "aria-label", "Audio Recorder");
			attr_dev(div2, "tabindex", "0");
			add_location(div2, file, 578, 20, 28107);
			attr_dev(span0, "class", "align-self-center mx-auto previewInitialState tokenfield");
			attr_dev(span0, "aria-label", "Click on record to start recording");
			attr_dev(span0, "tabindex", "0");
			add_location(span0, file, 580, 24, 28352);
			if (!src_url_equal(img0.src, img0_src_value = "//s3.amazonaws.com/jigyaasa_content_static/6ba174bf48e9b6dc8d8bd19d13c9caa9_000Awg.gif")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "recording is on");
			attr_dev(img0, "class", "w-100 h-100 img_fit");
			add_location(img0, file, 582, 28, 28654);
			attr_dev(div3, "class", "h previewRecordingOn tokenfield");
			attr_dev(div3, "aria-label", "recording is on");
			attr_dev(div3, "tabindex", "0");
			add_location(div3, file, 581, 24, 28537);
			if (!src_url_equal(img1.src, img1_src_value = "//s3.amazonaws.com/jigyaasa_content_static/giphy_000AYi.gif")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "audio is playing");
			attr_dev(img1, "class", "w-100 h-100 img_fit");
			add_location(img1, file, 585, 28, 28980);
			attr_dev(div4, "class", "h previewAudioPlaying tokenfield");
			attr_dev(div4, "aria-label", "Audio is playing");
			attr_dev(div4, "tabindex", "0");
			add_location(div4, file, 584, 24, 28861);
			attr_dev(div5, "class", "mx-auto text-danger recording_status initialState mb-3 d-flex mx-auto");
			add_location(div5, file, 579, 20, 28243);
			attr_dev(span1, "class", "icomoon-circle-2 s2 text-danger position-relative top1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "top");
			attr_dev(span1, "data-placement", "top");

			attr_dev(span1, "title", span1_title_value = /*state*/ ctx[4].status == "recording"
			? "Stop Recording"
			: "Start Recording");

			attr_dev(span1, "id", "recordButtonTooltip");
			attr_dev(span1, "name", "recordButtonTooltip");
			add_location(span1, file, 597, 28, 29773);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "name", "preview_recordButton");
			attr_dev(button0, "id", "preview_recordButton");
			attr_dev(button0, "class", "btn btn-light py-0");
			attr_dev(button0, "aria-label", button0_aria_label_value = "Click for " + /*areaLabelForPreviewRecordButton*/ ctx[3]);
			add_location(button0, file, 589, 24, 29351);
			attr_dev(span2, "class", "icomoon-24px-autoplay-4 position-relative top1");
			attr_dev(span2, "data-bs-toggle", "tooltip");
			attr_dev(span2, "data-bs-placement", "top");
			attr_dev(span2, "title", "Play Audio");
			attr_dev(span2, "id", "stopButtonTooltip");
			attr_dev(span2, "name", "stopButtonTooltip");
			add_location(span2, file, 608, 28, 30603);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "name", "preview_stopButton");
			attr_dev(button1, "id", "preview_stopButton");
			button1.disabled = button1_disabled_value = /*state*/ ctx[4].disabled;
			attr_dev(button1, "class", "btn btn-light py-0");
			attr_dev(button1, "aria-label", button1_aria_label_value = "Click for " + /*areaLabelForPreviewStopButton*/ ctx[1]);
			add_location(button1, file, 599, 24, 30132);
			attr_dev(span3, "class", "icomoon-new-24px-reset-1 position-relative top1");
			attr_dev(span3, "data-bs-toggle", "tooltip");
			attr_dev(span3, "data-placement", "top");
			attr_dev(span3, "title", "Reset Data");
			add_location(span3, file, 623, 28, 31551);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "name", "resetButton");
			attr_dev(button2, "id", "resetButton");
			attr_dev(button2, "class", "btn btn-light py-0");
			button2.disabled = button2_disabled_value = /*state*/ ctx[4].isReset;
			attr_dev(button2, "data-bs-toggle", "modal");
			attr_dev(button2, "data-toggle", "modal");
			attr_dev(button2, "data-bs-target", "#preview_confirm_modal");
			attr_dev(button2, "data-target", "#preview_confirm_modal");
			attr_dev(button2, "aria-label", "Click on this button for override the previous recording");
			add_location(button2, file, 610, 24, 30848);
			attr_dev(div6, "id", "controls_container");

			attr_dev(div6, "class", div6_class_value = "bg-light text-center w-100 p-2 " + (/*state*/ ctx[4].pointerEvents == 'none'
			? 'pointerEventOff'
			: 'pointerEventOn'));

			add_location(div6, file, 588, 20, 29185);
			attr_dev(div7, "class", "border rounded shadow-sm");
			add_location(div7, file, 577, 16, 28047);
			attr_dev(div8, "class", "col-12 col-md-8 offset-md-2");
			add_location(div8, file, 576, 12, 27988);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, b0);
			append_dev(div0, t1);
			append_dev(div0, t2);
			insert_dev(target, t3, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, div8, anchor);
			append_dev(div8, div7);
			append_dev(div7, div2);
			append_dev(div2, b1);
			append_dev(div7, t6);
			append_dev(div7, div5);
			append_dev(div5, span0);
			append_dev(div5, t8);
			append_dev(div5, div3);
			append_dev(div3, img0);
			append_dev(div5, t9);
			append_dev(div5, div4);
			append_dev(div4, img1);
			append_dev(div7, t10);
			append_dev(div7, div6);
			append_dev(div6, button0);
			append_dev(button0, span1);
			append_dev(div6, t11);
			append_dev(div6, button1);
			append_dev(button1, span2);
			append_dev(div6, t12);
			append_dev(div6, button2);
			append_dev(button2, span3);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*startRecording*/ ctx[8], false, false, false),
					listen_dev(button1, "click", /*playRecording*/ ctx[11], false, false, false),
					listen_dev(button2, "click", /*setData*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*state*/ ctx[4].showTranscript == true) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(t4.parentNode, t4);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*state*/ 16 && span1_title_value !== (span1_title_value = /*state*/ ctx[4].status == "recording"
			? "Stop Recording"
			: "Start Recording")) {
				attr_dev(span1, "title", span1_title_value);
			}

			if (dirty[0] & /*areaLabelForPreviewRecordButton*/ 8 && button0_aria_label_value !== (button0_aria_label_value = "Click for " + /*areaLabelForPreviewRecordButton*/ ctx[3])) {
				attr_dev(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty[0] & /*state*/ 16 && button1_disabled_value !== (button1_disabled_value = /*state*/ ctx[4].disabled)) {
				prop_dev(button1, "disabled", button1_disabled_value);
			}

			if (dirty[0] & /*areaLabelForPreviewStopButton*/ 2 && button1_aria_label_value !== (button1_aria_label_value = "Click for " + /*areaLabelForPreviewStopButton*/ ctx[1])) {
				attr_dev(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty[0] & /*state*/ 16 && button2_disabled_value !== (button2_disabled_value = /*state*/ ctx[4].isReset)) {
				prop_dev(button2, "disabled", button2_disabled_value);
			}

			if (dirty[0] & /*state*/ 16 && div6_class_value !== (div6_class_value = "bg-light text-center w-100 p-2 " + (/*state*/ ctx[4].pointerEvents == 'none'
			? 'pointerEventOff'
			: 'pointerEventOn'))) {
				attr_dev(div6, "class", div6_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t3);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div8);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(564:8) {:else}",
		ctx
	});

	return block;
}

// (534:8) {#if isReview}
function create_if_block(ctx) {
	let t0;
	let div;
	let b;
	let t2;
	let t3_value = l.insensitive_message + "";
	let t3;

	function select_block_type_1(ctx, dirty) {
		if (/*answer_status*/ ctx[5] != true) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			t0 = space();
			div = element("div");
			b = element("b");
			b.textContent = `${l.note_label}`;
			t2 = space();
			t3 = text(t3_value);
			attr_dev(b, "class", "noteColor bolder");
			add_location(b, file, 560, 16, 27042);
			attr_dev(div, "class", "col-12 pb-3");
			attr_dev(div, "tabindex", "0");
			attr_dev(div, "aria-label", "matching is case insensitive");
			add_location(div, file, 559, 12, 26944);
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, b);
			append_dev(div, t2);
			append_dev(div, t3);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(534:8) {#if isReview}",
		ctx
	});

	return block;
}

// (571:12) {#if state.showTranscript == true}
function create_if_block_2(ctx) {
	let div1;
	let div0;
	let label;
	let b;
	let t1;
	let textarea;
	let textarea_value_value;
	let textarea_aria_label_value;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			label = element("label");
			b = element("b");
			b.textContent = `${l.spoken_label}`;
			t1 = space();
			textarea = element("textarea");
			add_location(b, file, 572, 62, 27605);
			attr_dev(label, "for", "preview_show_transcript");
			add_location(label, file, 572, 25, 27568);
			add_location(div0, file, 572, 20, 27563);
			attr_dev(textarea, "id", "preview_show_transcript");
			attr_dev(textarea, "name", "preview_show_transcript");
			attr_dev(textarea, "class", "w-100 form-control");
			attr_dev(textarea, "rows", "2");
			textarea.value = textarea_value_value = /*state*/ ctx[4].cdata;
			textarea.readOnly = "readonly";
			attr_dev(textarea, "tabindex", "0");

			attr_dev(textarea, "aria-label", textarea_aria_label_value = l.spoken_label + " " + (/*state*/ ctx[4].cdata.trim() != ""
			? /*state*/ ctx[4].cdata.trim()
			: "Nothing"));

			add_location(textarea, file, 573, 20, 27664);
			attr_dev(div1, "class", "col-12 pb-3");
			add_location(div1, file, 571, 16, 27516);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, label);
			append_dev(label, b);
			append_dev(div1, t1);
			append_dev(div1, textarea);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[4].cdata)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 16 && textarea_aria_label_value !== (textarea_aria_label_value = l.spoken_label + " " + (/*state*/ ctx[4].cdata.trim() != ""
			? /*state*/ ctx[4].cdata.trim()
			: "Nothing"))) {
				attr_dev(textarea, "aria-label", textarea_aria_label_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(571:12) {#if state.showTranscript == true}",
		ctx
	});

	return block;
}

// (547:12) {:else}
function create_else_block(ctx) {
	let div;
	let textarea;
	let textarea_class_value;
	let textarea_value_value;
	let textarea_aria_label_value;

	const block = {
		c: function create() {
			div = element("div");
			textarea = element("textarea");
			attr_dev(textarea, "id", "preview_data_container");
			attr_dev(textarea, "name", "cdata");

			attr_dev(textarea, "class", textarea_class_value = "w-100 form-control " + (/*state*/ ctx[4].useransstatus == true
			? 'border-success typeCorrect'
			: 'border-danger typeIncorrect'));

			attr_dev(textarea, "rows", "2");

			textarea.value = textarea_value_value = /*state*/ ctx[4].cdata == ''
			? 'No record found'
			: /*state*/ ctx[4].cdata;

			textarea.readOnly = "readonly";
			attr_dev(textarea, "tabindex", "0");

			attr_dev(textarea, "aria-label", textarea_aria_label_value = "Your answer is " + /*state*/ ctx[4].cdata + " which is " + (/*state*/ ctx[4].cdata.toLowerCase().trim() == /*state*/ ctx[4].correctAns.toLowerCase().trim()
			? "Correct"
			: "Incorrect"));

			add_location(textarea, file, 548, 20, 26233);
			attr_dev(div, "class", "col-12 py-3");
			add_location(div, file, 547, 16, 26186);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, textarea);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && textarea_class_value !== (textarea_class_value = "w-100 form-control " + (/*state*/ ctx[4].useransstatus == true
			? 'border-success typeCorrect'
			: 'border-danger typeIncorrect'))) {
				attr_dev(textarea, "class", textarea_class_value);
			}

			if (dirty[0] & /*state*/ 16 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[4].cdata == ''
			? 'No record found'
			: /*state*/ ctx[4].cdata)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 16 && textarea_aria_label_value !== (textarea_aria_label_value = "Your answer is " + /*state*/ ctx[4].cdata + " which is " + (/*state*/ ctx[4].cdata.toLowerCase().trim() == /*state*/ ctx[4].correctAns.toLowerCase().trim()
			? "Correct"
			: "Incorrect"))) {
				attr_dev(textarea, "aria-label", textarea_aria_label_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(547:12) {:else}",
		ctx
	});

	return block;
}

// (535:12) {#if answer_status != true}
function create_if_block_1(ctx) {
	let div;
	let textarea;
	let textarea_value_value;
	let textarea_aria_label_value;

	const block = {
		c: function create() {
			div = element("div");
			textarea = element("textarea");
			attr_dev(textarea, "id", "preanswer_data_container");
			attr_dev(textarea, "name", "cdata");
			attr_dev(textarea, "class", "w-100 form-control border-success typeCorrect");
			attr_dev(textarea, "rows", "2");
			textarea.value = textarea_value_value = /*state*/ ctx[4].correctAns;
			textarea.readOnly = "readonly";
			attr_dev(textarea, "tabindex", "0");
			attr_dev(textarea, "aria-label", textarea_aria_label_value = "correct Answer is " + /*state*/ ctx[4].correctAns);
			add_location(textarea, file, 536, 20, 25680);
			attr_dev(div, "class", "col-12 py-3");
			add_location(div, file, 535, 16, 25633);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, textarea);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[4].correctAns)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 16 && textarea_aria_label_value !== (textarea_aria_label_value = "correct Answer is " + /*state*/ ctx[4].correctAns)) {
				attr_dev(textarea, "aria-label", textarea_aria_label_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(535:12) {#if answer_status != true}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let itemhelper;
	let t0;
	let div0;
	let t1;
	let div8;
	let div7;
	let div6;
	let div5;
	let div2;
	let h4;
	let t3;
	let button0;
	let t5;
	let div3;
	let t6_value = l.modal_data + "";
	let t6;
	let t7;
	let div4;
	let button1;
	let t9;
	let button2;
	let current;
	let mounted;
	let dispose;

	itemhelper = new ItemHelper({
			props: {
				reviewMode: /*isReview*/ ctx[0],
				handleReviewClick: /*handleReviewMode*/ ctx[14],
				customReviewMode: /*customIsReview*/ ctx[6]
			},
			$$inline: true
		});

	itemhelper.$on("setReview", /*setReview*/ ctx[12]);
	itemhelper.$on("unsetReview", /*unsetReview*/ ctx[13]);

	function select_block_type(ctx, dirty) {
		if (/*isReview*/ ctx[0]) return create_if_block;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			div0 = element("div");
			if_block.c();
			t1 = space();
			div8 = element("div");
			div7 = element("div");
			div6 = element("div");
			div5 = element("div");
			div2 = element("div");
			h4 = element("h4");
			h4.textContent = `${l.confirm_label}`;
			t3 = space();
			button0 = element("button");
			button0.textContent = "×";
			t5 = space();
			div3 = element("div");
			t6 = text(t6_value);
			t7 = space();
			div4 = element("div");
			button1 = element("button");
			button1.textContent = `${l.no_label}`;
			t9 = space();
			button2 = element("button");
			button2.textContent = `${l.yes_label}`;
			attr_dev(div0, "class", "row");
			add_location(div0, file, 532, 4, 25533);
			attr_dev(div1, "id", "preview_container");
			attr_dev(div1, "class", "container");
			add_location(div1, file, 524, 0, 25233);
			attr_dev(h4, "class", "modal-title tokenfield");
			attr_dev(h4, "aria-label", "Confirmation Dialog box");
			attr_dev(h4, "tabindex", "0");
			add_location(h4, file, 636, 20, 32107);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "close");
			attr_dev(button0, "data-bs-dismiss", "modal");
			attr_dev(button0, "data-dismiss", "modal");
			attr_dev(button0, "tabindex", "0");
			attr_dev(button0, "aria-label", "Click on this button for close the confirmation dialog box");
			add_location(button0, file, 637, 20, 32236);
			attr_dev(div2, "class", "modal-header");
			add_location(div2, file, 635, 16, 32059);
			attr_dev(div3, "class", "modal-body tokenfield");
			attr_dev(div3, "tabindex", "0");
			attr_dev(div3, "aria-label", /*areaLabelForPreviewModalContent*/ ctx[2]);
			attr_dev(div3, "id", "previewDialogBody");
			attr_dev(div3, "name", "previewDialogBody");
			add_location(div3, file, 639, 16, 32460);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "preview_dismiss_modal btn btn-light pr-2");
			attr_dev(button1, "data-bs-dismiss", "modal");
			attr_dev(button1, "data-dismiss", "modal");
			attr_dev(button1, "tabindex", "0");
			attr_dev(button1, "aria-label", "Click on this button for neglecte to override previous recording");
			add_location(button1, file, 643, 20, 32727);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "id", "StopRecord");
			attr_dev(button2, "class", "preview_dismiss_done btn btn-primary");
			attr_dev(button2, "data-bs-dismiss", "modal");
			attr_dev(button2, "data-dismiss", "modal");
			attr_dev(button2, "tabindex", "0");
			attr_dev(button2, "aria-label", "Click on this button for override the previous recording");
			add_location(button2, file, 644, 20, 33002);
			attr_dev(div4, "class", "modal-footer");
			add_location(div4, file, 642, 16, 32679);
			attr_dev(div5, "class", "modal-content");
			add_location(div5, file, 634, 12, 32014);
			attr_dev(div6, "class", "modal-dialog modal-md modal-dialog-centered");
			add_location(div6, file, 633, 8, 31943);
			attr_dev(div7, "class", "modal fade");
			attr_dev(div7, "id", "preview_confirm_modal");
			add_location(div7, file, 632, 4, 31882);
			attr_dev(div8, "class", "preview_modal_container container");
			add_location(div8, file, 631, 0, 31829);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(itemhelper, div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			if_block.m(div0, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, div8, anchor);
			append_dev(div8, div7);
			append_dev(div7, div6);
			append_dev(div6, div5);
			append_dev(div5, div2);
			append_dev(div2, h4);
			append_dev(div2, t3);
			append_dev(div2, button0);
			append_dev(div5, t5);
			append_dev(div5, div3);
			append_dev(div3, t6);
			append_dev(div5, t7);
			append_dev(div5, div4);
			append_dev(div4, button1);
			append_dev(div4, t9);
			append_dev(div4, button2);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button1, "click", /*modalResponse*/ ctx[10], false, false, false),
					listen_dev(button2, "click", /*manageData*/ ctx[7], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}

			if (!current || dirty[0] & /*areaLabelForPreviewModalContent*/ 4) {
				attr_dev(div3, "aria-label", /*areaLabelForPreviewModalContent*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(itemhelper);
			if_block.d();
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div8);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AudioPreview', slots, []);
	let { xml } = $$props;
	let { uxml } = $$props;
	let { showAns } = $$props;
	let { isReview } = $$props;
	let { editorState } = $$props;
	let customIsReview = isReview;
	let recognition;
	let synth;
	let previewResetClicked = 'no';
	let areaLabelForPreviewStopButton = "Play Audio";
	let areaLabelForPreviewModalContent;
	let areaLabelForPreviewRecordButton = "Start Recording";
	let previewTimeForRecording = 15;
	let previewManageTimer;

	let state = {
		disabled: true,
		cdata: '',
		language: '',
		correctAns: '',
		xml: '',
		status: '',
		pointerEvents: "auto",
		isReset: true,
		showTranscript: false,
		counter: 0
	};

	// Called once throughout the programm execution
	onMount(() => {
		///////////////  For ADA //////////////
		AH.listen('#controls_container', 'keydown', '#preview_recordButton', function (_this, e) {
			if (e.which === 13) {
				AH.select("#preview_recordButton").click();
			} // startRecording();
		});

		////// ADA for close dialogbox with close icon /////
		AH.listen(".preview_modal_container #preview_confirm_modal", "keydown", ".close", function (_this, e) {
			if (e.which === 13) {
				AI.find('.preview_modal_container #preview_confirm_modal', '.close').click();
			}
		});

		////// ADA for close dialogbox with close button /////
		AH.listen(".preview_modal_container #preview_confirm_modal", "keydown", ".preview_dismiss_modal", function (_this, e) {
			if (e.which === 13) {
				AI.find('.preview_modal_container #preview_confirm_modal', '.preview_dismiss_modal').click();
			}
		});

		////// ADA for override voice /////////
		AH.listen(".preview_modal_container #preview_confirm_modal", "keydown", "#StopRecord", function (_this, e) {
			if (e.which === 13) {
				AH.select("#StopRecord").click();
			}
		});

		// AH.listen("#controls_container","keydown","#preview_recordButton",function() {
		//     if(e.which === 13) {
		//         startRecording();
		//     }
		// })
		///// ADA for stop and play button ////
		AH.listen('#controls_container', 'keydown', '#preview_stopButton', function (_this, e) {
			if (e.which === 13) {
				playRecording();
				AH.find('#controls_container', '#preview_stopButton').style.disabled = state.disabled;
			}
		});

		//// ADA for reset/////
		AH.listen('#controls_container', 'keydown', '#resetButton', function (_this, e) {
			if (e.which === 13) {
				AI.select("#resetButton").click();
			} //setData();
		});

		if (!(window.webkitSpeechRecognition || window.SpeechRecognition)) {
			// shows the warning message that your browser does not support the speechRecognition
			AH.alert(l.browser_support_msg);
		}

		if (xml != state.xml) {
			// sets the state xml
			$$invalidate(4, state.xml = xml, state);

			/* reset the recorded data and disabled the reset and play button and updates the xml and re-render the component */
			resetValue();

			// load the module according to the value of xml
			loadModule(xml);
		}
	});

	// load the module according to the value of xml
	function loadModule(loadXml) {
		// contains json data of xml
		let newXml = XMLToJSON(loadXml);

		// parses the xml data and update the xml
		parseXMLPreview(newXml);
	}

	// parses the xml data and update the xml
	function parseXMLPreview(MYXML) {
		try {
			// used to set the value of the state language from the value of language key of xml json
			($$invalidate(4, state.language = MYXML.smxml._language, state), $$invalidate(
				4,
				// used to set the value of the state cdata from the value of cdata key of xml json
				state.correctAns = MYXML.smxml.__cdata,
				state
			), $$invalidate(
				4,
				// used to set the value of the state showTranscript from the value of showTranscript key of xml json
				state.showTranscript = MYXML.smxml._showTranscript == 'true' ? true : false,
				state
			));

			if (uxml) {
				// parses the user answer xml and update the xml
				parseUserAns(uxml);
			}
		} catch(event) {
			console.warn({
				'error': event.message,
				'function name': 'parseXMLPreview',
				'File name': 'AudioPreview.svelte'
			});
		}
	}

	// parses the user answer xml and update the xml
	function parseUserAns(userAns) {
		// contains json data of user answer xml
		let MYXML = XMLToJSON(userAns);

		// used to set the value of the state language from the value of language key of the user answer xml json
		$$invalidate(4, state.language = MYXML.smans._language, state);

		// used to set the value of the state cdata from the value of cdata key of the user answer xml json
		$$invalidate(4, state.cdata = MYXML.smans.__cdata, state);

		// used to set the value of the state status from the value of status key of the user answer xml json
		$$invalidate(4, state.status = MYXML.smans._status, state);

		// used to sets the value of the state disabled to false if the value of 'status' key of the user answer xml json is 'recordingStopped' otherwise 'true'
		$$invalidate(4, state.disabled = MYXML.smans._status == 'recordingStopped' ? false : true, state);

		// used to set the value of the state isReset from the value of isReset key of user answer xml json
		$$invalidate(4, state.isReset = MYXML.smans._isReset == 'true' ? true : false, state);

		// used to set the value of the state showTranscript from the value of showTranscript key of the user answer xml json
		$$invalidate(4, state.showTranscript = MYXML.smans._showTranscript == 'true' ? true : false, state);
	}

	/* reset the recorded data and disabled the reset and play button and updates the xml and re-render the component */
	function resetValue() {
		$$invalidate(4, state.disabled = true, state);
		$$invalidate(4, state.cdata = '', state);
		$$invalidate(4, state.xml = '', state);
		$$invalidate(4, state.status = '', state);
		$$invalidate(4, state.isReset = true, state);
	}

	// reset the previous recorded data
	function manageData() {
		// when reset modalbox open after click on reset button
		if (previewResetClicked == 'yes') {
			// reset the previously recorded data
			resetAudioData();

			previewResetClicked = 'no';
		} else {
			// when reset modalbox open after click on record button
			($$invalidate(4, state.cdata = '', state), $$invalidate(4, state.disabled = true, state), $$invalidate(4, state.status = '', state), $$invalidate(4, state.pauseRecording = '', state));

			/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
			previewCheckState();

			let manage_data_timer = setTimeout(
				function () {
					// called for start the recording
					startRecording();

					// clear the timeout
					clearTimeout(manage_data_timer);
				},
				120
			);
		}
	}

	// disabled the reset and play button and blanks the value of cdata and xml of state
	function resetAudioData() {
		// handles with gif of recording and play and icon of record button
		manageStopStatus();

		if (state.status == 'recording') {
			/* stops the speech recognition service from listening to incoming audio, and attempts to return a SpeechRecognitionResult using the audio captured so far. */
			recognition.stop();
		}

		$$invalidate(4, state.cdata = '', state);
		$$invalidate(4, state.disabled = true, state);
		$$invalidate(4, state.xml = '', state);
		$$invalidate(4, state.status = '', state);
		$$invalidate(4, state.isReset = true, state);

		// clears the timeout which is started when recording stared
		clearTimeout(previewManageTimer);

		/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
		previewCheckState();
	}

	/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
	function previewCheckState() {
		setTimeout(
			function () {
				let uXml = '<smans type="43" name="AudioRecorder" disabled="' + state.disabled + '" status="' + state.status + '" language="' + state.language + '" isReset="' + state.isReset + '" showTranscript="' + state.showTranscript + '"><![CDATA[' + state.cdata + ']]></smans>';
				AH.select("#special_module_user_xml").value = uXml;
				ISSPECIALMODULEUSERXMLCHANGE = 1;

				// stores user answer xml data in uaXML variable of window object to access it globally
				$$invalidate(15, uxml = AH.select("#special_module_user_xml").value);

				// used for screen reader to read the message when user reached on play button
				$$invalidate(1, areaLabelForPreviewStopButton = AH.select('#stopButtonTooltip').getAttribute('title'));

				// used for screen reader to read the message when user reached on record button
				$$invalidate(3, areaLabelForPreviewRecordButton = AH.select('#recordButtonTooltip').getAttribute('title'));

				// used for screen reader to read the message when user open the reset modalbox
				$$invalidate(2, areaLabelForPreviewModalContent = AH.select('#previewDialogBody').innerText);

				if (state.correctAns.trim() != '') {
					// check the answer
					checkAns();
				}
			},
			100
		);
	}

	// stops capturing incoming audio
	function stopRecording() {
		// handles with gif of recording and play and icon of record button
		manageStopStatus();

		clearTimeout(previewManageTimer);
		$$invalidate(4, state.status = 'recordingStopped', state);
		$$invalidate(4, state.disabled = false, state);

		/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
		previewCheckState();

		// hides recording gif
		AH.selectAll('.previewRecordingOn', 'addClass', 'h');

		// shows the initial state image
		AH.selectAll('.previewInitialState', 'removeClass', 'h');

		/* stops the speech recognition service from listening to incoming audio, and attempts to return a SpeechRecognitionResult using the audio captured so far. */
		recognition.stop();
	}

	// ends recording after 15 sec
	function previewManageTime() {
		previewTimeForRecording = previewTimeForRecording - 1;
		$$invalidate(4, state.counter = state.counter + 1, state);

		previewManageTimer = setTimeout(
			function () {
				if (previewTimeForRecording > 0) {
					// calls again the method previewManageTime for counting the second value
					previewManageTime();
				} else {
					// stops the recording
					stopRecording();
				}
			},
			1000
		);
	}

	// start the listening to incoming audio, enables reset button, stores the recognised data to cdata state and update the xml 
	function dictate() {
		// checks if SpeechRecognition supported then defines some properties value of SpeechRecogniton and adds  some event listener as well
		isSpeechRecognitionSupported();

		/* starts the speech recognition service listening to incoming audio with intent to recognize grammars associated with the current SpeechRecognition. */
		recognition.start();

		// enables reset button
		AH.select('#preview_container #resetButton').disabled = false;

		// hides the initial state image of the audio container and play gif
		AH.selectAll('.previewAudioPlaying, .previewInitialState', 'addClass', 'h');

		// shows recording gif
		AH.selectAll('.previewRecordingOn', 'removeClass', 'h');

		/* The onresult property of the SpeechRecognition interface represents an event handler that will run when the speech recognition service returns a result — a word or phrase has been positively recognized and this has been communicated back to the app */
		recognition.onresult = event => {
			let speechToText = '';

			for (let index_no = 0; index_no < event.results.length; index_no = index_no + 1) {
				speechToText += event.results[index_no][0].transcript;
			}

			// sets the value of textual data into cdata state that is recognised by SpeechRecognition
			$$invalidate(4, state.cdata = speechToText.trim(), state);

			/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
			previewCheckState();
		};
	}

	// handles with gif of recording and play and icon of record button
	function manageStopStatus() {
		// hides the gif of recording and playing
		AH.selectAll('.previewAudioPlaying, .previewRecordingOn', 'addClass', 'h');

		// shows the initial state image of the audio container
		AH.selectAll('.previewInitialState', 'removeClass', 'h');

		// removes the stop icon from recording button and adds start recording icon
		AH.selectAll('#preview_recordButton span', 'removeClass', 'icomoon-24px-stop');

		AH.selectAll('#preview_recordButton span', 'addClass', ['icomoon-circle-2', 'text-danger']);
	}

	// speak the text after defining some properties value and adding event
	function isSpeechSynthesisSupported() {
		// Returns a new SpeechSynthesisUtterance object instance
		let utterThis = new SpeechSynthesisUtterance(state.cdata);

		// array of available voices
		let voiceForSpeech = synth.getVoices();

		// sets the voice name according to the value of language state
		let voice_name = state.language == 'de-DE'
		? "Google Deutsch"
		: state.language == 'fr-FR'
			? "Google français"
			: state.language == 'es-ES'
				? "Google español"
				: state.language == 'hi-IN'
					? "Google हिन्दी"
					: state.language == 'ja-JP'
						? "Google 日本語"
						: state.language == 'ko-KR'
							? "Google 한국의"
							: state.language == 'it-IT'
								? "Google italiano"
								: "Google US English";

		// event listener fired when the utterance has finished being spoken.
		utterThis.addEventListener('end', function () {
			// hides the gif of recording and play
			AH.selectAll('.previewAudioPlaying, .previewRecordingOn', 'addClass', 'h');

			// shows the initial state image of the audio container
			AH.selectAll('.previewInitialState', 'removeClass', 'h');

			// enables the play button
			$$invalidate(4, state.disabled = false, state);

			/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
			previewCheckState();

			// removes all utterances from the utterance queue.
			synth.cancel();
		});

		for (let index_no = 0; index_no < voiceForSpeech.length; index_no = index_no + 1) {
			if (voiceForSpeech[index_no].name == voice_name) {
				//  sets the voice that will be used to speak the utterance.
				utterThis.voice = voiceForSpeech[index_no];

				// sets the pitch at which the utterance will be spoken at.
				utterThis.pitch = 1;

				// sets the speed at which the utterance will be spoken at.
				utterThis.rate = 1;

				// sets the language of the utterance
				utterThis.lang = state.language;

				// adds an utterance to the utterance queue; it will be spoken when any other utterances queued before it have been spoken.
				synth.speak(utterThis);

				break;
			}
		}
	}

	// starts the recording
	function startRecording() {
		switch (state.status) {
			case 'recording':
				// stops the recording when stop recording button clicked
				stopRecording();
				break;
			case 'recordingStopped':
				// for show the reset modalbox when start recording button clicked and recording is done previously
				AH.getBS('#preview_confirm_modal', 'Modal').show();
				// focus on reset modalbox for screen reader purpose
				AH.select('.modal-body').focus();
				break;
			default:
				dictate();
				($$invalidate(4, state.status = 'recording', state), $$invalidate(4, state.isReset = false, state), $$invalidate(
					4,
					// used for count the second after recording start
					state.counter = 0,
					state
				));
				// used for automatically end the recording after 15 sec
				previewTimeForRecording = 15;
				// ends recording after 15 sec
				previewManageTime();
				/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
				previewCheckState();
				// adds the stop recording icon to record button
				AH.selectAll('#preview_recordButton span', 'removeClass', ['icomoon-circle-2', 'text-danger']);
				AH.selectAll('#preview_recordButton span', 'addClass', 'icomoon-24px-stop');
		}
	}

	// checks if SpeechRecognition supported then defines some properties value of SpeechRecogniton and adds  some event listener as well
	function isSpeechRecognitionSupported() {
		if (window.webkitSpeechRecognition || window.SpeechRecognition) {
			window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;

			// creates new recognition object
			recognition = new SpeechRecognition();

			//Controls whether continuous results are returned for each recognition
			recognition.continuous = true;

			// returns interim results 
			recognition.interimResults = true;

			//  sets the language of the current SpeechRecognition
			recognition.lang = state.language;

			// used for globally access the recogniton 
			window.recognitionData = recognition;

			recognition.addEventListener('end', function () {
				if (!state.isReset) {
					// clears the timeout which is started when recording stared
					clearTimeout(previewManageTimer);

					// shows message that recording ended
					AH.showmsg(l.recording_ended, 3000);

					// handles with gif of recording and play and icon of record button
					manageStopStatus();

					// shows the initial state image of the audio container
					AH.selectAll('.previewInitialState', 'removeClass', 'h');

					$$invalidate(4, state.status = 'recordingStopped', state);
					$$invalidate(4, state.disabled = false, state);

					/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
					previewCheckState();
				}
			});
		} else {
			// shows the message that SpeechRecognition not supported
			AH.alert(l.browser_support_msg);

			return;
		}
	}

	//check that reset button is clicked or not
	function setData() {
		previewResetClicked = 'yes';
	}

	// reset the data of 'resetClicked' to 'no' when no button is clicked in modalbox
	function modalResponse() {
		previewResetClicked = 'no';
	}

	// called for speak the recorded text
	function playRecording() {
		if (window.speechSynthesis) {
			synth = window.speechSynthesis;

			if (state.cdata != '') {
				// hides the initial state image of the audio container and recording gif
				AH.selectAll('.previewRecordingOn, .previewInitialState', 'addClass', 'h');

				// shows the play gif
				AH.selectAll('.previewAudioPlaying', 'removeClass', 'h');

				$$invalidate(4, state.disabled = true, state);

				/* used for check the answer, store the user answer xml and defines the title for stop button, record button and reset modal box for use it when screen reader used */
				previewCheckState();

				// removes all utterances from the utterance queue.
				//synth.cancel();
				// speak the recorded text after defining some properties value and adding event
				isSpeechSynthesisSupported();
			} else {
				// hides the play and recording gif
				AH.selectAll('.previewRecordingOn, .previewAudioPlaying', 'addClass', 'h');

				// shows the initial state image of the audio container
				AH.selectAll('.previewInitialState', 'removeClass', 'h');

				// message for no data recorded
				AH.alert(l.no_data_msg);
			}
		} else {
			// message for not supported speechSynthesis
			AH.alert(l.browser_support_msg);

			return;
		}
	}

	// checks the answer
	function checkAns() {
		let ans = "";

		if (state.correctAns.trim() != '') {
			if (state.correctAns.toLowerCase() == state.cdata.toLowerCase()) {
				// label of message
				ans = l.correct;

				AH.select("#answer").checked = true;
				$$invalidate(4, state.useransstatus = true, state);
			} else {
				// label of message
				ans = l.incorrect;

				AH.select("#answer").checked = false;
				$$invalidate(4, state.useransstatus = false, state);
			}

			// shows the answer
			if (editorState) {
				showAns(ans);
			} else {
				ans = ans == 'Correct' ? true : false;
				onUserAnsChange({ uXml: uxml, ans });
			}
		} else {
			// message, no data found for match the answer
			AH.alert(l.matching_msg);

			return;
		}
	}

	let answer_status;

	function setReview() {
		$$invalidate(0, isReview = true);
		$$invalidate(4, state.pointerEvents = "none", state);
		$$invalidate(5, answer_status = true);

		// check the answer
		checkAns();

		if (state.useransstatus == true) {
			// change the user answer data container's text and border color to #50af50
			AH.setCss('#preview_data_container', { 'color': '#50af50' });
		} else {
			// change the user answer data container's text and border color to #c30f0f
			AH.setCss('#preview_data_container', { 'color': '#c30f0f' });
		}

		/* hides the answer container in which correct answer will be seen after click on correct answer button */
		AH.selectAll(AH.parent(AH.selectAll('#preanswer_data_container')), 'addClass', 'h');

		/* shows the answer container in which user answer will be seen after click on your answer button */
		AH.selectAll(AH.parent(AH.selectAll('#preview_data_container')), 'removeClass', 'h');
	}

	/* allows the user to perform the task, shows the recording end notification message, hides correct and your answer button */
	function unsetReview() {
		$$invalidate(0, isReview = false);
		$$invalidate(4, state.pointerEvents = "auto", state);
		$$invalidate(5, answer_status = false);

		// hides both container in which your answer and correct answer data will be seen
		AH.selectAll(AH.parent(AH.selectAll('#preview_data_container')), 'addClass', 'h');
	}

	function handleReviewMode(mode) {
		if (mode == 'c') {
			$$invalidate(5, answer_status = false);
		} else if (mode == 'u') {
			$$invalidate(5, answer_status = true);
		}
	}

	const writable_props = ['xml', 'uxml', 'showAns', 'isReview', 'editorState'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<AudioPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('xml' in $$props) $$invalidate(16, xml = $$props.xml);
		if ('uxml' in $$props) $$invalidate(15, uxml = $$props.uxml);
		if ('showAns' in $$props) $$invalidate(17, showAns = $$props.showAns);
		if ('isReview' in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ('editorState' in $$props) $$invalidate(18, editorState = $$props.editorState);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		XMLToJSON,
		AH,
		onUserAnsChange,
		ItemHelper,
		l,
		xml,
		uxml,
		showAns,
		isReview,
		editorState,
		customIsReview,
		recognition,
		synth,
		previewResetClicked,
		areaLabelForPreviewStopButton,
		areaLabelForPreviewModalContent,
		areaLabelForPreviewRecordButton,
		previewTimeForRecording,
		previewManageTimer,
		state,
		loadModule,
		parseXMLPreview,
		parseUserAns,
		resetValue,
		manageData,
		resetAudioData,
		previewCheckState,
		stopRecording,
		previewManageTime,
		dictate,
		manageStopStatus,
		isSpeechSynthesisSupported,
		startRecording,
		isSpeechRecognitionSupported,
		setData,
		modalResponse,
		playRecording,
		checkAns,
		answer_status,
		setReview,
		unsetReview,
		handleReviewMode
	});

	$$self.$inject_state = $$props => {
		if ('xml' in $$props) $$invalidate(16, xml = $$props.xml);
		if ('uxml' in $$props) $$invalidate(15, uxml = $$props.uxml);
		if ('showAns' in $$props) $$invalidate(17, showAns = $$props.showAns);
		if ('isReview' in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ('editorState' in $$props) $$invalidate(18, editorState = $$props.editorState);
		if ('customIsReview' in $$props) $$invalidate(6, customIsReview = $$props.customIsReview);
		if ('recognition' in $$props) recognition = $$props.recognition;
		if ('synth' in $$props) synth = $$props.synth;
		if ('previewResetClicked' in $$props) previewResetClicked = $$props.previewResetClicked;
		if ('areaLabelForPreviewStopButton' in $$props) $$invalidate(1, areaLabelForPreviewStopButton = $$props.areaLabelForPreviewStopButton);
		if ('areaLabelForPreviewModalContent' in $$props) $$invalidate(2, areaLabelForPreviewModalContent = $$props.areaLabelForPreviewModalContent);
		if ('areaLabelForPreviewRecordButton' in $$props) $$invalidate(3, areaLabelForPreviewRecordButton = $$props.areaLabelForPreviewRecordButton);
		if ('previewTimeForRecording' in $$props) previewTimeForRecording = $$props.previewTimeForRecording;
		if ('previewManageTimer' in $$props) previewManageTimer = $$props.previewManageTimer;
		if ('state' in $$props) $$invalidate(4, state = $$props.state);
		if ('answer_status' in $$props) $$invalidate(5, answer_status = $$props.answer_status);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*xml, isReview*/ 65537) {
			// Called every time when any state gets changed
			 {
				loadModule(xml);

				if (isReview) {
					setReview();
				} else {
					unsetReview();
				}
			}
		}
	};

	return [
		isReview,
		areaLabelForPreviewStopButton,
		areaLabelForPreviewModalContent,
		areaLabelForPreviewRecordButton,
		state,
		answer_status,
		customIsReview,
		manageData,
		startRecording,
		setData,
		modalResponse,
		playRecording,
		setReview,
		unsetReview,
		handleReviewMode,
		uxml,
		xml,
		showAns,
		editorState
	];
}

class AudioPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				xml: 16,
				uxml: 15,
				showAns: 17,
				isReview: 0,
				editorState: 18
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AudioPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[16] === undefined && !('xml' in props)) {
			console_1.warn("<AudioPreview> was created without expected prop 'xml'");
		}

		if (/*uxml*/ ctx[15] === undefined && !('uxml' in props)) {
			console_1.warn("<AudioPreview> was created without expected prop 'uxml'");
		}

		if (/*showAns*/ ctx[17] === undefined && !('showAns' in props)) {
			console_1.warn("<AudioPreview> was created without expected prop 'showAns'");
		}

		if (/*isReview*/ ctx[0] === undefined && !('isReview' in props)) {
			console_1.warn("<AudioPreview> was created without expected prop 'isReview'");
		}

		if (/*editorState*/ ctx[18] === undefined && !('editorState' in props)) {
			console_1.warn("<AudioPreview> was created without expected prop 'editorState'");
		}
	}

	get xml() {
		throw new Error("<AudioPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<AudioPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<AudioPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<AudioPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showAns() {
		throw new Error("<AudioPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<AudioPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isReview() {
		throw new Error("<AudioPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<AudioPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<AudioPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<AudioPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default AudioPreview;
//# sourceMappingURL=AudioPreview-fc397802.js.map
