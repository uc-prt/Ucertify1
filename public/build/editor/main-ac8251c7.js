
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    var _a;
    const append_styles_to = get_root_for_styles(target);
    if (!((_a = append_styles_to) === null || _a === void 0 ? void 0 : _a.getElementById(style_sheet_id))) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_node(node) {
    if (!node)
        return document;
    return (node.getRootNode ? node.getRootNode() : node.ownerDocument); // check for getRootNode because IE is still supported
}
function get_root_for_styles(node) {
    const root = get_root_for_node(node);
    return root.host ? root : root;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_styles(node), style_element);
    return style_element;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function to_number(value) {
    return value === '' ? null : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
}
class HtmlTag {
    constructor() {
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_node(node);
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config();
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_destroy_block(block, lookup) {
    block.f();
    destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
            throw new Error('Cannot have duplicate keys in a keyed each');
        }
        keys.add(key);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.40.2' }, detail), true));
}
function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', { node });
    detach(node);
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
    else
        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev('SvelteDOMSetData', { node: text, data });
    text.data = data;
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error("'target' is a required option");
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}
function quintOut(t) {
    return --t * t * t * t * t + 1;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}

/* helper\Drawer.svelte generated by Svelte v3.40.2 */

const { window: window_1 } = globals;
const file = "helper\\Drawer.svelte";

function add_css(target) {
	append_styles(target, "svelte-h4cjkb", ".drawer.svelte-h4cjkb{border:1px solid gray;position:fixed;top:-1px;left:-1px}#backdrop.svelte-h4cjkb{position:fixed;height:100%;width:100%;z-index:99;background:rgba(0,0,0,0.3)}.drawerBody.svelte-h4cjkb{position:absolute;overflow-y:auto;background:white;z-index:99999999999999999999}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRHJhd2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpQ0ksT0FBTyxjQUFDLENBQUMsQUFDTCxNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQ3RCLFFBQVEsQ0FBRSxLQUFLLENBQ2YsR0FBRyxDQUFFLElBQUksQ0FDVCxJQUFJLENBQUUsSUFBSSxBQUNkLENBQUMsQUFDRCxTQUFTLGNBQUMsQ0FBQyxBQUNQLFFBQVEsQ0FBRSxLQUFLLENBQ2YsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxFQUFFLENBQ1gsVUFBVSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEFBQy9CLENBQUMsQUFDRCxXQUFXLGNBQUMsQ0FBQyxBQUNULFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxLQUFLLENBQ2pCLE9BQU8sQ0FBRSxvQkFBb0IsQUFDakMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEcmF3ZXIuc3ZlbHRlIl19 */");
}

const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (20:4) {#if backdrop}
function create_if_block(ctx) {
	let div;
	let div_transition;
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "id", "backdrop");
			attr_dev(div, "class", "svelte-h4cjkb");
			add_location(div, file, 19, 18, 605);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(20:4) {#if backdrop}",
		ctx
	});

	return block;
}

// (28:33) <span>
function fallback_block(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Enter Content here...";
			add_location(span, file, 27, 33, 953);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(28:33) <span>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div3;
	let t0;
	let div2;
	let div0;
	let t1;
	let div1;
	let div2_transition;
	let current;
	let mounted;
	let dispose;
	let if_block = /*backdrop*/ ctx[1] && create_if_block(ctx);
	const header_slot_template = /*#slots*/ ctx[8].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[7], get_header_slot_context);
	const content_slot_template = /*#slots*/ ctx[8].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[7], get_content_slot_context);
	const content_slot_or_fallback = content_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			div3 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div2 = element("div");
			div0 = element("div");
			if (header_slot) header_slot.c();
			t1 = space();
			div1 = element("div");
			if (content_slot_or_fallback) content_slot_or_fallback.c();
			attr_dev(div0, "class", "drawerHeader");
			add_location(div0, file, 25, 8, 822);
			attr_dev(div1, "class", "drawerContent");
			add_location(div1, file, 26, 8, 891);
			attr_dev(div2, "class", "drawerBody svelte-h4cjkb");
			set_style(div2, "height", /*height*/ ctx[3] + "px");
			set_style(div2, "width", /*width*/ ctx[0] + "px");
			add_location(div2, file, 20, 4, 691);
			attr_dev(div3, "class", "drawer svelte-h4cjkb");
			attr_dev(div3, "role", "dialog");
			attr_dev(div3, "aria-modal", "true");
			add_location(div3, file, 18, 0, 514);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			if (if_block) if_block.m(div3, null);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, div0);

			if (header_slot) {
				header_slot.m(div0, null);
			}

			append_dev(div2, t1);
			append_dev(div2, div1);

			if (content_slot_or_fallback) {
				content_slot_or_fallback.m(div1, null);
			}

			/*div3_binding*/ ctx[10](div3);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window_1, "keydown", /*handle_keydown*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*backdrop*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*backdrop*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div3, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[7], !current ? -1 : dirty, get_header_slot_changes, get_header_slot_context);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[7], !current ? -1 : dirty, get_content_slot_changes, get_content_slot_context);
				}
			}

			if (!current || dirty & /*width*/ 1) {
				set_style(div2, "width", /*width*/ ctx[0] + "px");
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(header_slot, local);
			transition_in(content_slot_or_fallback, local);

			add_render_callback(() => {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, scale, {}, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(header_slot, local);
			transition_out(content_slot_or_fallback, local);
			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, scale, {}, false);
			div2_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (if_block) if_block.d();
			if (header_slot) header_slot.d(detaching);
			if (content_slot_or_fallback) content_slot_or_fallback.d(detaching);
			if (detaching && div2_transition) div2_transition.end();
			/*div3_binding*/ ctx[10](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Drawer', slots, ['header','content']);
	let { width = 300 } = $$props;
	let { backdrop = true } = $$props;
	let { closeByEsc = true } = $$props;
	let height = window.innerHeight;
	const dispatch = createEventDispatcher();
	let drawer;

	function handle_keydown(event) {
		if (event.keyCode == 27 && closeByEsc) {
			dispatch('close');
		}
	}

	const writable_props = ['width', 'backdrop', 'closeByEsc'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Drawer> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch('close');

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			drawer = $$value;
			$$invalidate(2, drawer);
		});
	}

	$$self.$$set = $$props => {
		if ('width' in $$props) $$invalidate(0, width = $$props.width);
		if ('backdrop' in $$props) $$invalidate(1, backdrop = $$props.backdrop);
		if ('closeByEsc' in $$props) $$invalidate(6, closeByEsc = $$props.closeByEsc);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		fade,
		scale,
		width,
		backdrop,
		closeByEsc,
		height,
		dispatch,
		drawer,
		handle_keydown
	});

	$$self.$inject_state = $$props => {
		if ('width' in $$props) $$invalidate(0, width = $$props.width);
		if ('backdrop' in $$props) $$invalidate(1, backdrop = $$props.backdrop);
		if ('closeByEsc' in $$props) $$invalidate(6, closeByEsc = $$props.closeByEsc);
		if ('height' in $$props) $$invalidate(3, height = $$props.height);
		if ('drawer' in $$props) $$invalidate(2, drawer = $$props.drawer);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		width,
		backdrop,
		drawer,
		height,
		dispatch,
		handle_keydown,
		closeByEsc,
		$$scope,
		slots,
		click_handler,
		div3_binding
	];
}

class Drawer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { width: 0, backdrop: 1, closeByEsc: 6 }, add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Drawer",
			options,
			id: create_fragment.name
		});
	}

	get width() {
		throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByEsc() {
		throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByEsc(value) {
		throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * File: tagsView.js
 * Description: Create tag view on input box.
 * Author: Pradeep Yadav
 * className: 'tagin'
 * @param {selected elements using class or id} el 
 * @param {separator|duplicate|transform|placeholder} option 
 */
function TagView(el, option = {}) {
    const classElement = 'tagin';
    const classWrapper = 'tagin-wrapper';
    const classTag = 'tagin-tag';
    const classRemove = 'tagin-tag-remove';
    const classInput = 'tagin-input';
    const classInputHidden = 'tagin-input-hidden';
    const defaultSeparator = ',';
    const defaultDuplicate = 'false';
    const defaultTransform = input => input;
    const defaultPlaceholder = '';
    const separator = el.dataset.separator || option.separator || defaultSeparator;
    const duplicate = el.dataset.duplicate || option.duplicate || defaultDuplicate;
    const transform = eval(el.dataset.transform) || option.transform || defaultTransform;
    const placeholder = el.dataset.placeholder || option.placeholder || defaultPlaceholder;
  
    const templateTag = value => `<span class="${classTag}">${value}<span class="${classRemove}"></span></span>`;
  
    const getValue = () => el.value;
    const getValues = () => getValue().split(separator)
  
    // Create
    ; (function () {
      const className = classWrapper + ' ' + el.className.replace(classElement, '').trim();
      const tags = getValue().trim() === '' ? '' : getValues().map(templateTag).join('');
      const template = `<div class="${className}">${tags}<input type="text" class="${classInput}" placeholder="${placeholder}"></div>`;
      el.insertAdjacentHTML('afterend', template); // insert template after element
    })();
  
    const wrapper = el.nextElementSibling;
    const input = wrapper.getElementsByClassName(classInput)[0];
    const getTags = () => [...wrapper.getElementsByClassName(classTag)].map(tag => tag.textContent);
    const getTag = () => getTags().join(separator);
  
    const updateValue = () => { el.value = getTag(); el.dispatchEvent(new Event('change')); };
  
    // Focus to input
    wrapper.addEventListener('click', () => input.focus());
  
    // Toggle focus class
    input.addEventListener('focus', () => wrapper.classList.add('focus'));
    input.addEventListener('blur', () => wrapper.classList.remove('focus'));
  
    // Remove by click
    document.addEventListener('click', e => {
      if (e.target.closest('.' + classRemove)) {
        e.target.closest('.' + classRemove).parentNode.remove();
        updateValue();
      }
    });
  
    // Remove with backspace
    input.addEventListener('keydown', e => {
      if (input.value === '' && e.keyCode === 8 && wrapper.getElementsByClassName(classTag).length) {
        wrapper.querySelector('.' + classTag + ':last-of-type').remove();
        updateValue();
      }
    });
  
    // Adding tag
    input.addEventListener('input', () => {
      addTag();
      autowidth();
    });
    input.addEventListener('blur', () => {
      addTag(true);
      autowidth();
    });
    autowidth();
  
    function autowidth() {
      const fakeEl = document.createElement('div');
      fakeEl.classList.add(classInput, classInputHidden);
      const string = input.value || input.getAttribute('placeholder') || '';
      fakeEl.innerHTML = string.replace(/ /g, '&nbsp;');
      document.body.appendChild(fakeEl);
      input.style.setProperty('width', Math.ceil(window.getComputedStyle(fakeEl).width.replace('px', '')) + 1 + 'px');
      fakeEl.remove();
    }
    function addTag(force = false) {
      const value = transform(input.value.replace(new RegExp(escapeRegex(separator), 'g'), '').trim());
      if (value === '') { input.value = ''; }
      if (input.value.includes(separator) || (force && input.value != '')) {
        if (getTags().includes(value) && duplicate === 'false') {
          alertExist(value);
        } else {
          input.insertAdjacentHTML('beforebegin', templateTag(value));
          updateValue();
        }
        input.value = '';
        input.removeAttribute('style');
      }
    }
    function alertExist(value) {
      for (const el of wrapper.getElementsByClassName(classTag)) {
        if (el.textContent === value) {
          el.style.transform = 'scale(1.09)';
          setTimeout(() => { el.removeAttribute('style'); }, 150);
        }
      }
    }
    function updateTag() {
      if (getValue() !== getTag()) {
        [...wrapper.getElementsByClassName(classTag)].map(tag => tag.remove());
        getValue().trim() !== '' && input.insertAdjacentHTML('beforebegin', getValues().map(templateTag).join(''));
      }
    }
    function escapeRegex(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
    }
    el.addEventListener('change', () => updateTag());
}

var tagViewCss = { style: `.tagin{display:none}.tagin-wrapper{border: 1px solid #ccc;display:flex;flex-wrap:wrap;height:auto;padding:calc(.375rem - 2px) calc(.75rem - 2px);position:relative;overflow:hidden;cursor:text}.tagin-wrapper.focus{color:#495057;background-color:#fff;border-color:#80bdff;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.tagin.is-valid+.tagin-wrapper,.was-validated .tagin:valid+.tagin-wrapper{border-color:#28a745}.tagin.is-invalid+.tagin-wrapper,.was-validated .tagin:invalid+.tagin-wrapper{border-color:#dc3545}.tagin-tag{border-radius:.25rem;color:#fff;border:0;padding:0 4px;display:inline-flex;align-items:center;height:24px;margin:2px;font-weight:300;background-color:#6c757d;transition:transform .1s}.tagin-tag-remove{margin-left:2px;width:18px;height:18px;cursor:pointer;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23a0aec0' width='18px' height='18px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z'/%3E%3C/svg%3E")}.tagin-tag-remove:hover{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='18px' height='18px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z'/%3E%3C/svg%3E")}.tagin-input{margin-left:2px;border-color:transparent;outline:0;border-width:1px 0;padding:0 2px 0 0;height:28px;color:#495057}.tagin-input:not(.tagin-input-hidden){width:4px;min-width:4px}.tagin-input-hidden{position:absolute;top:0;left:-9999px;overflow:hidden;visibility:hidden;white-space:nowrap` };

class API {
    constructor(options) {
        this._servers = [
            'http://localhost/pe-gold3/', 
            'https://www.ucertify.com/', 
            'https://www.jigyaasa.info/',
            'http://172.10.195.203/pe-gold3/',
        ];
        this._REMOTE_API_URL = this._servers[1] + 'pe-api/1/index.php';
        //@Prabhat: Why is this here. Need to remove this.
        this._client = {
            email: "pradeep.yadav@ucertify.com",
            password: "786pradeep",
            isSocial: "false",
            clientId: "040MA"
        };
    }

    validateApp (checkExpired) {
        return new Promise((resolve, reject) => {
            let isExpired = checkExpired ? `&action=refresh_token&refresh_token=1` : "";
            let isSocial = this._client.isSocial ? '&social_login=1' : "";
            let url = `${this._REMOTE_API_URL}?func=cat2.authenticate&device_id=${this._client.clientId}&email=${this._client.email}&password=${this._client.password + isSocial + isExpired}`;
            let request = new XMLHttpRequest();
            request.open('POST', url, true);
            request.onreadystatechange = (event) => {
                if (request.readyState == 4 && request.status === 200) {
                    try {
                        let responseBody = request.responseText;
                        let responseObject = responseBody.match(/<jsonstring>(.*?)<\/jsonstring>/);
                        resolve(JSON.parse(responseObject[1]));
                    } catch (err) {
                        reject(err);
                    }
                } 
            };
            request.onerror = (requestError) => {
                reject(requestError);
            };
            if (checkExpired) {
                request.setRequestHeader("old-access-token", globalThis.apiAccessToken);
            }
            request.send();
        });
    }
    
    getAPIDataJ (func, where, callback = function(){}) {
        let param = "";
        let _param2 = {};
        let str = '';
        let ajax_info = where.ajax_info ||{};
        where = this._assignPartial(where, {}, 'ajax_info', true);
        // if (typeof where.redis == 'undefined') {
        // 	_param2.redis = 0;
        // }
        //----------- code for acces_token based validation --------//
        _param2.device_id = this._client.clientId;
        //----------------------------------------------------------//
    
        if (typeof (where) == 'object') {
            for (let k in where) {
                if (typeof where[k] != 'object') {
                    param += "&" + k + "=" + where[k];
                }	
            }
        }
        if (typeof (func) !== "undefined" && func != "") {
            for (let k in _param2) {
                if (typeof _param2[k] != 'object') {
                    str += "&" + k + "=" + _param2[k];
                }	
            }
            str += "&func="+func;
        }
        
        this.getAPIDataJSON(this._REMOTE_API_URL + "?" + str + "&debug=0&"+param, param, ajax_info, (apidata)=> {
            if (apidata == 'Expired'){
                this.getAPIDataJ(func, where, callback);
            } else {
                callback(apidata);
            }
        }, func);
    }
    
    getAPIDataJSON (url, data, ajax_info, callback = function(){}, funcName) {
        let request = new XMLHttpRequest();
        request.open('POST', url, true);
        request.onreadystatechange = (event) => {
            if (request.readyState == 4 && request.status === 200) {
                let responseBody = request.responseText;
                let responseData = {};
                try {
                    let resStr = responseBody.match(/<jsonstring>(.*?)<\/jsonstring>/);
                    if (resStr[1] != '') {
                        let responseObject = JSON.parse(resStr[1]);
                        if (responseObject.error && ['Expired', '-9'].includes(responseObject.error.error_id)) {
                            console.log("Api Error = ", responseObject.error.error_id);
                            this.validateApp (responseObject.error.error_id != -9).then((validRes) => {
                                if (validRes.status == 'Success') {
                                    this.setAccessKey(validRes);
                                    callback("Expired");
                                }
                            }).catch((validateError)=> {
                                //UI.storeError('Validate Error####no1:1####' + JSON.stringify(validateError || {}), true)
                                console.log(validateError);
                            });
                            return;
                        } else {
                            if (responseObject['response']) {
                                responseData = responseObject['response'];
                                console.warn("Api data J reponse <-- Received -->", responseObject);
                            } else if(responseObject['response'] == undefined && responseObject.error == undefined) {
                                responseData = responseObject;
                                console.warn("Api data J reponse <-- Received II-->", responseData);
                            } else {
                                responseData = undefined;
                                console.warn({"Response_error":responseObject.error});
                            }
                        }
                    }
                } catch (error) {
                    console.warn("Please check your Internet connection.");
                    console.log("Api data error = ", responseBody);
                    if (data.includes('must_reply_override')) {
                        responseData = undefined;
                    } else {
                        return (0);
                    }
                }
                callback(responseData);
            }
        };
        if (!data.includes('no_access_token_required')) {
            request.setRequestHeader("access-token", globalThis.apiAccessToken);
        }
        request.setRequestHeader("Content-type", "application/json");
        request.setRequestHeader("Access-Control-Allow-Origin", "*");
        request.setRequestHeader("Access-Control-Allow-Headers", "*");
        request.send();
    }

    _assignPartial(iObj, oObj = {}, str, unsetOnly = false ) {
        str = str.split(',');
        if ( !unsetOnly ) {
          for ( let i in str ) {
            let index = str[i];
            if ( typeof iObj[index] != 'undefined') {
              oObj[index] = iObj[index];
            }
          }
        }
        else {
          for ( let i in iObj ) {
            let index = str.indexOf( i ); 
            if ( index === -1) {
              oObj[i] = iObj[i];
            }
          }
        }
        return oObj;
    }
    
    setAccessKey (api) {
        if (api.access_token && api.access_token.length > 50) {
            globalThis.apiAccessToken = api.access_token;
            if (typeof(Storage) !== "undefined") {
                localStorage.setItem('apiAccessToken', api.access_token);
            }
        }
    }
}
class JStore {
    constructor(options={}) {
        this._options = options;
        this._allowed = false;
        /**
         * session : true to enable sessionStorage
         * locastorage : by default true
         * onStore : to listen store changes
         */
        this._init();
    }

    _init() {
        if (typeof(Storage) !== "undefined") {
            this._allowed = true;
            // Code for localStorage/sessionStorage.
            window.onstorage = (e)=> {
                if (this._options.onStore) this._options.onStore(e); 
            };
        } else {
            this._allowed = false;
            console.warn("Sorry! No Web Storage support..");
        }
    }

    //When passed a number n, this method will return the name of the nth key in the storage.
    key(n) {
        if (this._allowed) {
            return this._options.session ? console.warn("Session has not key method.") : window.localStorage.key(n)
        }
    }

    //When passed a key name, will return that key's value.
    get(name) {
        if (this._allowed) {
            return this._options.session ? window.sessionStorage.getItem(name) : window.localStorage.getItem(name);
        }
    }

    //When passed a key name and value, will add that key to the storage, or update that key's value if it already exists.
    set(name, value) {
        if (this._allowed) {
            return this._options.session ? window.sessionStorage.setItem(name, value) : window.localStorage.setItem(name, value);
        }
    }

    //When passed a key name, will remove that key from the storage.
    remove(name) {
        if (this._allowed) {
            return this._options.session ? window.sessionStorage.removeItem(name) : window.localStorage.removeItem(name);
        }
    }

    //clear all stored
    clearAll() {
        if (this._allowed) {
            return this._options.session ? window.sessionStorage.clear() : window.localStorage.clear();
        }
    }
}
class JUI extends API{
    constructor(options) {
        super();
        this.trackInf = {};
        this.buffer = {};
        this.bsCat1 = ['Modal', 'Tooltip', 'Collapse', 'Popover', 'ScrollSpy', 'Tab', 'Alert', 'Dropdown'];
        this.extraSelectors = ['hidden', 'visible', 'selected', 'checked', 'enabled', 'children', 'childNodes'];
        this.parseHtml = this.templateHtml.bind(this);
        this.isSSDloaded = "";
        this.loadSSD();
    }

    loadSSD() {
        if (typeof globalThis == 'object') {
            globalThis.eventTracker = globalThis.eventTracker || {};
            globalThis.JUITemp = globalThis.JUITemp || {};
        } else {
            this.isSSDloaded = setInterval(()=> {
                if (typeof globalThis == 'object') {
                    globalThis.eventTracker = globalThis.eventTracker || {};
                    globalThis.JUITemp = globalThis.JUITemp || {};
                    clearInterval(this.isSSDloaded);
                }
            }, 500);
        }   
    }

    validate(isExpired) {
        return new Promise((resolve, reject) => {
            this.validateApp(isExpired).then((tokenApi) => {
                if (tokenApi.status != 'Success') {
                    reject(tokenApi);
                } else {
                    try {
                        this.setAccessKey(tokenApi);
                        resolve(tokenApi);
                    } catch (err) {
                        reject(err);
                    }
                }
            }).catch((err) => {
                reject(err);
            });
        });
    }

    param2Url(params) {
        let url = [];
        for (var i in params) {
            var uri = i + '=' + params[i];
            url.push(uri);
        }
        return url.join('&');
    }

    // Provide unique in array
    unique(myArray) {
        return myArray.filter((v, i, a) => a.indexOf(v) === i);
    }

    // handle json parse
    parseJSON(obj, showErr_data) {
        let showErr = showErr_data || false;
        try {
            return JSON.parse(obj);
        } catch (e) {
            if (showErr) {
                console.warn(e);
            }
            return {}; //Return blank object
        }
    }

    parseDom(str) {
        let parser = new DOMParser();
        let html = parser.parseFromString(str, 'text/html');
        return html;
    }

    // Add script data or url into page
    addScript(data, url, options={}) {
        let sc = document.createElement("script");
        if (url) {
            sc.src = url;
            sc.async = true;
            if (options.callback) {
                sc.onload = function() { 
                    options.callback();
                };
            }
        } else {
            sc.innerHTML = data;
        }
        let selector = options.target ? document.body : document.head;
        selector.append(sc);
        return sc;
    }

    // used to genrate css links
    createLink(path, options={}) {
        let link = document.createElement('link');
        let selector = options.target ? document.body : document.head;
        link.href = path;
        if  (options.preload) {
            link.rel = "preload";
            link.onload = function() {
                this.rel= options.type || "stylesheet";
            };
            link.as = options.as || "style";
            link.crossorigin = "anonymous";
        } else {
            link.rel = "stylesheet";
        }
        selector.append(link);
        return link;
    }

    // To enable Tag view on selected inputs
    // before use this call addTagViewCss once only
    enableTagView(options) {
        let selected = document.querySelectorAll('.tagin');
        for (const el of selected) {
            options ? TagView(el, options) : TagView(el);
        }
        return selected;
    }

    // Add css for tagsview inout
    addTagViewCss() {
        this.insert(document.head, `<style>${tagViewCss.style}</style>`, 'beforeend');
    }

    //check target selector is present in base selector/dom
    hasInall(selector, target) {
        let current = (typeof selector == "object") ? selector : document.querySelectorAll(selector);
        let result = [];
        if (current) {
            Array.prototype.forEach.call(current, (item)=> {
                if (item.contains(target)) {
                    result.push(item);
                }
            });
        }
        return result;
    }

    // removeAttr of jq like
    removeDomAttr(selector, attrArray) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (current) {
            Array.prototype.forEach.call(attrArray, (attr)=> {
                current.removeAttribute(attr);
            });
        }

        return current || {};
    }

    // trigger events
    trigger(selector, evName, options) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (current) {
            options ? current.dispatchEvent(new Event(evName, options)) : current.dispatchEvent(new Event(evName));
        } else {
            console.warn("Selector not found.", selector);
        }
    }

    // Find in childrent of selected node
    findChild(selector, search, action) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        let list = current.children || [];
        let found = [];
        if (search && list.length > 0) {
            let index = 0;
            while (list[index]) {
                if (list[index].matches(search)) {
                    if (action) {
                        found.push(list[index]);
                    } else {
                        found = list[index];
                        break;
                    }
                }
                index++;
            }
            return found;
        } else {
            return list;
        }
    }

    closest(selector, search) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        let elm = current ? current.parentElement : null;
        let result = [];
        if (search) {
            while (elm) {
                if (this.find(elm, search)) {
                    result = this.find(elm, search);
                    break;
                }
                elm = elm.parentElement;
            }
        }
        return result;
    }

    parent(selector, search) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        let elm = current ? current.parentElement : null;
        if (search) {
            while(elm) {
                if (elm.matches(search)) {
                    break;
                }
                elm = elm.parentElement;
            }
        }

        return elm;
    }

    // find in sibiling or return imediate
    siblings(selector, search) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        let result = [];
        if (current) {
            var node = current.parentNode.firstChild;

            while ( node ) {
                if ( node !== current && node.nodeType === Node.ELEMENT_NODE ) {
                    if (search) {
                            node.matches(search) ? result.push( node ) : "";
                    } else {
                        result.push( node );
                    }
                }
                node = node.nextElementSibling || node.nextSibling;
            }
        } 
        return result;
    }

    // find in next element or return all
    nextAll(selector) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        let nextSibling = current.nextElementSibling;
        let result = [];
        if (nextSibling) {
            while(nextSibling) {
                nextSibling = nextSibling.nextElementSibling;
                result.push(nextSibling);
            }
        }

        return result;
    }

    // find in next 
    nextElm(selector, search) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        let nextSibling = current.nextElementSibling;
        if (search) {
            while(nextSibling) {
                if (nextSibling.matches(search)) {
                    break;
                }
                nextSibling = nextSibling.nextElementSibling;
            }
        }

        return nextSibling;
    }

    // find in previous element
    prevElm(selector, search) {
        let current = (typeof selector == "object") ? selector : document.querySelector(selector);
        let previousSibling = current.previousElementSibling;
        if (search) {
            while(previousSibling) {
                if (previousSibling.matches(search)) {
                    break;
                }
                previousSibling = previousSibling.previousElementSibling;
            }
        }

        return previousSibling;
    }

    // add dom loaded event
    onReady(func) {
        document.addEventListener('DOMContentLoaded', function(event) {
            func.call(event);
        });
    }

    // Create element from html string
    create(tagName, html) {
        let elem = document.createElement(tagName);
        if (html) {
            elem.innerHTML = html;
        }
        return elem;
        
    }

    clone(selector) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            return selected.cloneNode(true);
        }
        return null;
    }

    // Setrialize form nodes
    serialize(selector) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            return new URLSearchParams(new FormData(selected)).toString();
        }
        return null;
    }

    // Empty dom I.e $.empty()
    empty(selector) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            while(selected.firstChild) selected.removeChild(selected.firstChild);
        }
        return selected;
    }

    // Get bootstrap5 instance accoridng to compoenent
    getBS(target, comp, options) {
        let selected = (typeof target == "object") ? target : document.querySelector(target);
        if (selected && this.bsCat1.includes(comp)) {
            let isIns = bootstrap[comp].getInstance(selected);
            if (isIns) {
                return bootstrap[comp].getInstance(selected);
            } else {
                let ref = new bootstrap[comp](selected, options);
                return ref;
            }
        } else {
            return {};
        }
    }

    // Enable all mathced node's bootstrap5 compoenent
    enableBsAll(selector, comp, options) {
        if (this.bsCat1.includes(comp)) {
            let triggerList = [].slice.call(document.querySelectorAll(selector));
            let fireList = triggerList.map(function (triggerElm) {
                if (options) {
                    return new bootstrap[comp](triggerElm, options);
                } else {
                    return new bootstrap[comp](triggerElm);
                }
            });
            return fireList;
        } else {
            console.error("Bootstrap can't enable for this component name");
            return [];
        }
    }

    // Hide enabled bootstrap5 compoenents
    hideBsAll(selector, comp) {
        let fireList = [].slice.call(document.querySelectorAll(selector));
        if (this.bsCat1.includes(comp)) {
            fireList.forEach(function (elm) {
                let ref = bootstrap[comp].getInstance(elm);
                ref?.hide?.();
            });
        } else {
            console.error("Bootstrap can't disable for this component name");
        }
    }
    initDropdown() { // Hide the dropdown click outside, when dropdown is appended in dom using ajax call.
        let _this= this;
        _this.enableBsAll('[data-toggle="dropdown"]', 'Dropdown');
        _this.bind('body', 'click', function(event) {
            if (!event.target.closest('[data-toggle="dropdown"]')) {
                _this.selectAll('[data-toggle="dropdown"]').forEach(function(currElem) {
                    currElem.classList.remove('show');
                });
                _this.selectAll('.dropdown-menu').forEach(function(currElem) {
                    currElem.classList.remove('show');
                });
            }
        });
    }
    // Js based ajax i.e $.ajax
    ajax(sendData) {
        let longData = "";
        if (typeof (sendData.data) == 'object') {
            if (sendData.formData) {
                longData = sendData.data;
            } else if (sendData.withUrl) {
                let param = "?";
                for (let k in sendData.data) {
                    if (typeof sendData.data[k] != 'object') {
                        param += "&" + k + "=" + sendData.data[k];
                    }	
                }
                sendData.url += param;
            } else {
                longData = new FormData();
                for (let prop in sendData.data) {
                    if (typeof sendData.data[prop] == 'object' && this.isValid(sendData.data[prop])) {
                        longData = this.jsonFormEncode(longData, prop, sendData.data[prop]);
                    } else {
                        longData.append(prop, sendData.data[prop]);
                    }	
                }
            }
        }
        return new Promise((resolve, reject)=> {
            const request = new XMLHttpRequest();
            request.open(sendData.type || 'POST', sendData.url, true);
            if (sendData.responseType) {
                request.responseType = sendData.responseType;
            }
            request.onreadystatechange = (event) => {
                if (request.readyState == 4 && request.status === 200) {
                    try {
                        resolve(request.responseText, event);
                    } catch (err) {
                        reject(err);
                    }
                } 
            };
            request.onerror = (requestError) => {
                reject(requestError);
            };
            if (sendData.onStart) request.onloadstart = sendData.onStart;
            if (sendData.onEnd) request.onloadend = sendData.onEnd;
            request.send(longData);
        });
    }

    jsonFormEncode(formData, prop, jsonArray) {
        try {
            if (Array.isArray(jsonArray)) {
                for (let i = 0; i < jsonArray.length; i++) {
                    for (let key in jsonArray[i]) {
                        formData.append(`${prop}[${i}][${key}]`, jsonArray[i][key]);
                    }
                }
            } else {
                for (var key in jsonArray) {
                    formData.append(`${prop}[${key}]`, jsonArray[key]);
                }
            }
        } catch(error) {
            console.warn("Please provide valid JSON Object in ajax data."+ error);
        }
        return formData;
    }

    // get script from url
    getJSON(url) {
        var scr = document.createElement('script');
        scr.src = url;
        document.body.appendChild(scr);
    }

    // $.offset alternative
    offset(container) {
        let rect = (typeof container == "object") ? container : document.querySelector(container);
        let offset = {rect};
        if (rect) {
            let clientRect = rect.getBoundingClientRect();
            offset = { 
                target: rect,
                clientRect,
                top: clientRect.top + window.scrollY, 
                left: clientRect.left + window.scrollX, 
            };
        }
        
        return offset;
    }

    // find in array
    findInArray(value, baseArray) {
        if (value && baseArray) {
            return baseArray.find((item)=> item == value );
        }

        return false;
    }

    // comapre two array
    inArray(baseArray, compareArray) {
        let matched = [];
        if (baseArray && compareArray) {
            baseArray.forEach((item)=> {
                compareArray.forEach((comp)=> {
                    if (item == comp) {
                        matched.includes(comp) ? "" : matched.push(comp);
                    }
                });
            });
        }

        return matched.length > 0 ? matched.length : -1;
    }

    // serialize nodes into array
    serializeArray(nodeArr, filter) {
        let result = [];
        nodeArr.forEach((item)=> {
            if (!filter || item.matches(filter)) {
                console.log(item.attributes.length);
                if (item.attributes.length > 0) {
                    let tempData = {};
                    for (let _attr of item.attributes) {
                        tempData[_attr.name] = _attr.value;
                    }
                    result.push(tempData);
                }
            }
        });
        return result;
    }

    // Find target node into base node and some extra selectors
    find(baseSelector, target, data ) {
        let base = (typeof baseSelector == "object") ? baseSelector : document.querySelector(baseSelector);
        let typeAction = (typeof data == "object") ? "action" : data;
        if (base) {
            switch (typeAction) {
                case 'all' : return base?.querySelectorAll(target);
                case 'child' : return base?.querySelector(target).childNodes;
                case 'hidden': return Array.prototype.filter.call(base.querySelectorAll(target), (elm)=> elm.offsetWidth == 0 && elm.offsetHeight == 0);
                case 'visible': return Array.prototype.filter.call(base.querySelectorAll(target), (elm)=> elm.offsetWidth > 0 && elm.offsetHeight > 0);
                case 'checked': return Array.prototype.filter.call(document.querySelectorAll(selector), (elm)=> elm.checked);
                case 'selected': return Array.prototype.filter.call(base.querySelectorAll(target), (elm)=> elm.selected);
                case 'action': {
                    let found = base.querySelectorAll(target);
                    if (found && found.length > 0 && data.action) {
                        found.forEach((_elm)=> this.jsAction(_elm, {action: data.action, actionData: data.actionData}));
                    }
                    return found;
                }
                default: return base.querySelector(target);  
            }
        }
        return [];
    }

    // Select all using query selectors and perform action both
    selectAll(selector, action, actionData) {
        let selected = this.isExtraSelectors(action, actionData) ? this.selectAction(selector, action) : (typeof selector == 'object' ? selector : document.querySelectorAll(selector));
        if (selected && selected.length > 0 && action) {
            Array.prototype.forEach.call(selected, (elm)=> this.jsAction(elm, {action, actionData}));
        }
        return selected;
    }

    isExtraSelectors(action, actionData) {
        if (this.extraSelectors.includes(action)) {
            return (action == "checked" && typeof actionData != 'undefined') ? false : true;
        }
        return false;
    }

    // Select and enhance selector like jquery
    select(selector, action, actionData) {
        if (this.isExtraSelectors(action, actionData)) {
            return this.selectAction(selector, action);
        } else {
            selector = (typeof selector == 'object') ? selector : document.querySelector(selector);
            if (selector) {
                this.jsAction(selector, {action, actionData});
            }
            return  selector || {};
        }
    }

    getElm(selector, type) {
        return document.getElementById(selector) || {};
    }

    // Listen all node with events
    listenAll(target, eventName, func) {
        let selected = (typeof target == "object") ? target : document.querySelectorAll(target);
        if (selected && selected.length > 0) {
            for (let i = 0; i < selected.length; i++) {
                selected[i].addEventListener(eventName, func, false);
            }
        }
    }

    // bind event directly on nodes
    bind(selector, eventName, handler) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            selected.addEventListener(eventName, handler);
        }
    }

    // Listen target with in base node listner
    listen(baseSelector, eventName, selector, handler) {
        let base = (typeof baseSelector == "object") ? baseSelector : (typeof document !== 'undefined' ? document.querySelector(baseSelector) : false);
        if (!base) return false;
        if (globalThis.eventTracker[selector]) {
            base.removeEventListener(eventName, globalThis.eventTracker[selector]);
        }
        globalThis.eventTracker[selector] = this.onListen.bind(this, selector, handler, base);
        base.addEventListener(eventName, globalThis.eventTracker[selector]);
    }

    // remove node classes
    removeClass(selector, name) {
        let selected = (typeof selector == "object") ? selector : document.querySelectorAll(selector);
        if (selected && selected?.length > 0) {
            Array.prototype.forEach.call(selected, (elm)=> this.jsAction(elm, {action: 'removeClass', actionData: name}));
        } else if (typeof selected == 'object') {
            this.jsAction(selected, {action: 'removeClass', actionData: name});
        }
        return selected || {};
    }
    // add class for node
    addClass(selector, name) {
        let selected = (typeof selector == "object") ? selector : document.querySelectorAll(selector);
        if (selected && selected?.length > 0) {
            Array.prototype.forEach.call(selected, (elm)=> this.jsAction(elm, {action: 'addClass', actionData: name}));
        } else if (typeof selected == 'object') {
            this.jsAction(selected, {action: 'addClass', actionData: name});
        }
        return selected || {};
    }

    // dom visibility handle
    toggleDom(dom, action="toggleDisplay") {
        let selected =  typeof dom == "object" ? dom : document.querySelectorAll(dom);
        if (selected && selected.length > 0) {
            Array.prototype.forEach.call(selected, (elm)=> this.jsAction(elm, {action}) );
        }
        return selected || {};
    }

    // alterntive of $.select2
    select2(selecor) {
        let found = document.querySelector(`${selecor} + span > .selection > span`);
        if (found) {
            found.click();
        }
    }

    // Set dataset on element
    setData(selector, attrs) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            for (let property in attrs) {
                selected.dataset[property] = attrs[property];
            }
        }
        return selected || {};
    }

    // Set dataset on element
    getData(selector, attr) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        return selected?.dataset[attr] || {};
    }

    // manage attr using object
    setAttr(selector, attrs) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            for (let property in attrs) {
                selected.setAttribute(property, attrs[property]);
            }
        }
        return selected || {};
    }

    // add css using object
    setCss(selector, cssList) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            for (let property in cssList) {
                selected.style && (selected.style[property] = cssList[property]);
            }
        }
        return selected || {};
    }

    //alternative of $.remove
    remove(dom) {
        let selected =  document.querySelectorAll(dom);
        if (selected.length > 0) {
            Array.prototype.forEach.call(selected, (elm)=> elm.remove() );
        }
    }

    // alternive of $.replaceWith
    replaceWith(selector, domStr) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            let createdNode = this.templateHtml(domStr);
            selected.replaceWith(createdNode);
            return createdNode;
        }
        return selected;

    }

    wrap(selector, domStr) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            let createdNode = this.templateHtml(domStr);
            let innerNode = this.innerChild(createdNode);
            innerNode.innerHTML = selected.outerHTML;
            selected.parentNode.replaceChild(createdNode, selected);
            return innerNode.firstChild;
        }
        return selected;
    }

    unwrap(selector) {
        let nodeToRemove = (typeof selector == "object") ? selector : document.querySelectorAll(selector);
        if (nodeToRemove && nodeToRemove.length > 0) {
            nodeToRemove.forEach((item)=> {
                item.outerHTML = item.innerHTML;
            });
        }
    }

    insertAfter(newNode, existingNode) {
        newNode = (typeof newNode == "object") ? newNode : document.querySelector(newNode);
        existingNode = (typeof existingNode == "object") ? existingNode : document.querySelector(existingNode);
        if (newNode && existingNode) {
            existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);
        }
        return newNode;
    }

    // Insert using html string, need to provide position also
    insert(selector, domStr, position) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            switch (position) {
                case 'beforebegin': selected.insertAdjacentHTML('beforebegin', domStr);
                break;
                case 'afterbegin': selected.insertAdjacentHTML('afterbegin', domStr);
                break;
                case 'beforeend': selected.insertAdjacentHTML('beforeend', domStr);
                break;
                case 'afterend': selected.insertAdjacentHTML('afterend', domStr);
                break;
            }
        }
        return selected || {};
    }

    // provide dom index like $.index
    domIndex(selector) {
        let selected = (typeof selector == "object") ? selector : document.querySelector(selector);
        if (selected) {
            return Array.from( selected.parentNode.children ).indexOf( selected );
        } else {
            return -1;
        }
    }

    // compare selector in base node
    match(baseSelector, mathStr) {
        let base = (typeof baseSelector == "object") ? baseSelector : document.querySelector(baseSelector);
        let matched = [];
        if (base && base.length > 0 ) {
            Array.prototype.forEach.call(base, (elm)=> {
                if (elm.matches(mathStr)) matched.push(elm);
            });
        } else {
            return base && base.matches(mathStr);
        }
        return matched;
    }

    // check selector in base node
    contains(selector, text) {
        let elements = (typeof selector == "object") ? selector : document.querySelectorAll(selector);
        if (elements && elements.length > 0) {
            return [].filter.call(elements, function(element) {
                return RegExp(text).test(element.textContent);
                });
        } else {
            return [];
        }
    }

    // merge two object like $.extend
    extend() {
        //This function are alternative of $.extend which merge content of objects into first one
        // To create deep copy pass true as first argument
        let extended = {};
        let deep = false;
        let i = 0;
        let length = arguments.length;
        // Check if a deep merge
        if ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {
            deep = arguments[0];
            i++;
        }
        // Merge the object into the extended object
        const merge = function (obj) {
            for ( let prop in obj ) {
                if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {
                    // If deep merge and property is an object, merge properties
                    if ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {
                        extended[prop] = extend( true, extended[prop], obj[prop] );
                    } else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };
        // Loop through each object and conduct a merge
        for ( ; i < length; i++ ) {
            let obj = arguments[i];
            merge(obj);
        }
        return extended;
    }

    // return querystring as object
    url (url) {
        url = url || (typeof window == 'object' ? window.location.href : "");
        return new URLSearchParams(url);
    }

    updateEditorUrl(data) {
        let newUrl = `?action=new&content_subtype=${data.subtype}&content_type=${data.type}&content_icon=${data.content_icon}&react_content=1`;
        window.history.replaceState(null, '', newUrl);
    }

    getUrlVars() {
        let vars = [], hash;
        let hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        for (let i = 0; i < hashes.length; i++) {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
        }
        return vars;
    }

    setApiKey(token) {
        globalThis.apiAccessToken = token;
    }

    validateAjaxData(ajaxData, subtype) {
        if (subtype == 0 || subtype == 8) {
            if (ajaxData && !this.get('is_proposed')) {
                if (ajaxData.content_text) {
                    try {
                        ajaxData.content_text.answers.forEach((item,index)=> {
                            ajaxData.content_text.answers[index].answer =  item.answer.replace(/\n/g, "");
                        });
                    } catch(e) {
                        let tempAjaxData = {
                            answers: [
                                {
                                    is_correct: "0",
                                    answer: "Option A.",
                                    id: "01"
                                },
                                {
                                    is_correct: "0",
                                    answer: "Option B.",
                                    id: "02"
                                },
                                {
                                    is_correct: "0",
                                    answer: "Option C.",
                                    id: "03"
                                },
                                {
                                    is_correct: "0",
                                    answer: "Option D.",
                                    id: "04"
                                },
                            ],
                            correct_ans_str: "D",
                            total_answers: 4,
                            correct_answers: 1
                        };
                        return tempAjaxData;
                    }
                    //console.log(ajaxData.content_text.answers);
                    return ajaxData.content_text;
                }
                return ajaxData;
            } else {
                let tempAjaxData = {
                    answers: [
                        {
                            is_correct: "0",
                            answer: "Option A.",
                            id: "01"
                        },
                        {
                            is_correct: "0",
                            answer: "Option B.",
                            id: "02"
                        },
                        {
                            is_correct: "0",
                            answer: "Option C.",
                            id: "03"
                        },
                        {
                            is_correct: "0",
                            answer: "Option D.",
                            id: "04"
                        },
                    ],
                    correct_ans_str: "D",
                    total_answers: 4,
                    correct_answers: 1
                };
                return tempAjaxData;
            }
        }
        return ajaxData;
        
    }
    
    // watch if dom changes
    watchDom(target, func, options={childList: true}) {
        let observer = new MutationObserver(function (mutationRecords) {
                //if (mutationRecords[0].addedNodes[0].nodeName === "SPAN")
                func && func(mutationRecords);
            });
        observer.observe(target, options);
        return observer;
    }

    // revert if enity blocked by html
    ignoreEnity(html) {
        return html.replace(/&amp;/g,'&');
    }

    // cahce funciton to avoid repated outputs
    cache(func) {
        var chacheData = new Map();
        return function(input) {
            if(chacheData.has(input)) {
                return chacheData.get(input);
            }

            var newResult = func(input);
            chacheData.set(input,newResult);

            return newResult;
        }
    }

    // store data
    set(key, value) {
        if (typeof globalThis == 'object') globalThis.JUITemp[key] = value;
    }

    // get data from store
    get(key) {
        return globalThis.JUITemp[key];
    }

    // find caller
    caller() {
        console.log("called from " + arguments.callee.caller.toString());
    }

    // show warnign messages
    showmsg(msg, time = 10000) {
        let errorAlert = document.querySelector("#showMsgAlert");
        if (this.buffer['showmsg']) clearTimeout(this.buffer['showmsg']);
        if (errorAlert) {
            errorAlert.classList.add('show');
            this.select("#showMsgBody").innerHTML = msg;
        } else {
            this.insert(document.body, this.getModalHtml(msg, 'Alert'), 'beforeend');
        }
        setTimeout(()=> {
            let alterRef= this.getBS(document.querySelector("#showMsgAlert"), 'Alert');
            alterRef.close && alterRef.close();
        }, time);
    }

    alert(msgData) {
        if (document.getElementById('showBSModal')) {
            this.getBS("#showBSModal", 'Modal').show();
            this.select("#showBSBody").innerHTML = msgData|| "No msg provided...";
        } else {
            this.insert(document.body, this.getModalHtml(msgData, 'showBSModal'), 'beforeend');
            this.getBS("#showBSModal", 'Modal').show();
        }
    }

    formatXml(xml, cdata_format) {
        let cdata = cdata_format || false;
        let reg = /(>)(<)(\/*)/g;
        let wsexp = / *(.*) +\n/g;
        let contexp = /(<.+>)(.+\n)/g;
        let old_cdata = cdata ? xml.match(/<!--\[CDATA\[[\s\S]*?\]\]-->/gim) : "";
        xml = xml.replace(/\t/g, '').replace(reg, '$1\n$2$3').replace(wsexp, '$1\n').replace(contexp, '$1\n$2');
        if (cdata) {
            let new_cdata = xml.match(/<!--\[CDATA\[[\s\S]*?\]\]-->/gim);
            xml = xml.replace(new_cdata, old_cdata);
        }
        let formatted = '';
        let lines = xml.split('\n');
        let indent = 0;
        let lastType = 'other';
        // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions
        let transitions = {
            'single->single': 0,
            'single->closing': -1,
            'single->opening': 0,
            'single->other': 0,
            'closing->single': 0,
            'closing->closing': -1,
            'closing->opening': 0,
            'closing->other': 0,
            'opening->single': 1,
            'opening->closing': 0,
            'opening->opening': 1,
            'opening->other': 1,
            'other->single': 0,
            'other->closing': -1,
            'other->opening': 0,
            'other->other': 0
        };
    
        for (let i = 0; i < lines.length; i++) {
            let ln = lines[i];
            if (ln != '') {
                let single = Boolean(ln.match(/<.+\/>/)); // is this line a single tag? ex. <br />
                let closing = Boolean(ln.match(/<\/.+>/)); // is this a closing tag? ex. </a>
                let opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)
                let type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';
                let fromTo = lastType + '->' + type;
                lastType = type;
                let padding = '';
    
                indent += transitions[fromTo];
                for (let j = 0; j < indent; j++) {
                    padding += '\t';
                }
                if (fromTo == 'opening->closing')
                    formatted = formatted.substr(0, formatted.length - 1) + ln + '\n'; // substr removes line break (\n) from prev loop
                else
                    formatted += padding + ln + '\n';
            }
        }
        return formatted;
    }

    getModalHtml(data, type) {
        switch(type) {
            case 'Alert' : 
                return (`
                    <div id="showMsgAlert" class="alert alert-warning alert-dismissible text-center fade show" role="alert" style="z-index:99999;min-height:50px;position:fixed;width:100%;">
                        <span id="showMsgBody">${data}</span>
                        <button type="button" class="btn-close" style="margin-top: -3px;" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                `)
            case 'showBSModal':
              return(`
                    <div class="modal fade" id="showBSModal" tabindex="-1" aria-labelledby="Alert" aria-hidden="true">
                        <div class="modal-dialog modal-dialog-centered" id="showBSDialog">
                            <div class="modal-content">
                                <div class="modal-body text-center fs-5 pt-4" id="showBSBody">
                                    ${data}
                                </div>
                                <div class="modal-footer">
                                    <button type="button" class="btn bg-light m-auto text-dark" data-bs-dismiss="modal">OK</button>
                                </div>
                            </div>
                        </div>
                    </div>`
                );
            default : return "<div>Nothing</div>";
        }

    }

    // check data validity
    isValid(data, filter = false) {
        if (data && data != undefined && data != "" && data != "undefined" && data != null) {
            return true;
        } else {
            if (filter && data != filter) return true;
            return false;
        }
    }

    // store algo
    store(target,data) {
    }

    // convert query from objects
    query(data) {
        var inf = 'item_error_log=1';
            if (typeof (data) == 'object') {
                for (let key in data) {
                if (typeof data[key] != 'object') {
                    inf += "&" + key + "=" + data[key];
                }	
            }
        }
        return inf;
    }
    
    // show activator
    activate(loader) {
        document.querySelector('#activateLoaderContainer') && document.querySelector('#activateLoaderContainer').remove(); 
        if (loader > 0) {
            this.insert(document.body, `<div id="activateLoaderContainer" class="activateOverlay" style="z-index:9999999;"><center><div class="activator" style="height:100px; width: 100px;"></div></center></div>`, 'afterend');
        }
    }
    
    // listner callback
    onListen(selector, handler, base, event) {
        let target = event.target; //|| event.relatedTarget || event.toElement;
        let closest = target.closest && target.closest(selector);
        if (closest && base.contains(closest)) {
            // passes the event to the handler and sets `this`
            // in the handler as the closest parent matching the
            // selector from the target element of the event
            handler.call(this, closest, event);
        }
    }

    isFocus(target) {
        let selected = typeof target == 'object' ? target : document.querySelector(target);
        if (selected == document.activeElement) {
            return true;
        }
        return false;
    }
    
    // find inner child in dom
    innerChild(node) {
        let currentNode = (typeof node == "object") ? node : document.querySelector(node);
        let result = currentNode;
        if (currentNode && currentNode.lastChild) {
            currentNode = currentNode.lastChild;
            while ( currentNode ) {
                result = currentNode;
                currentNode = currentNode.lastChild;
            }
        }
        
        return result;
    }
    
    // parse html into template and reurn nodes
    templateHtml(html) {
        let t = document.createElement('template');
        t.innerHTML = html;
        return t.content.firstElementChild.cloneNode(true);
    }
    
    // action of selector
    selectAction(selector, type) {
        switch (type) {
            case 'hidden': return Array.prototype.filter.call(document.querySelectorAll(selector), (elm)=> elm.offsetWidth == 0 && elm.offsetHeight == 0);
            case 'visible': return Array.prototype.filter.call(document.querySelectorAll(selector), (elm)=> elm.offsetWidth > 0 && elm.offsetHeight > 0);
            case 'selected': return Array.prototype.filter.call(document.querySelectorAll(selector), (elm)=> elm.selected);
            case 'checked': return Array.prototype.filter.call(document.querySelectorAll(selector), (elm)=> elm.checked);
            case 'enabled': return document.querySelectorAll(selector + ':not([disabled]');
            case 'children': return document.querySelector(selector).children;
            case 'childNodes': return document.querySelector(selector).childNodes;
            default: return document.querySelector(selector);  
        }
    }
    
    // handle inline actions of js
    jsAction(selected, data) {
        if (selected instanceof HTMLElement) {
            switch(data.action) {
                case 'show': selected.style.display = data.actionData || "";
                break;
                case 'hide': selected.style.display = "none";
                break;
                case 'toggleDisplay': selected.style.display = (selected.style.display == "none") ? "block" : "none";
                break;
                case 'addClass': typeof data.actionData == "object" ? selected.classList.add(...data.actionData) : selected.classList.add(data.actionData);
                break;
                case 'removeClass': typeof data.actionData == "object" ? selected.classList.remove(...data.actionData) : selected.classList.remove(data.actionData);
                break;
                case 'toggleClass': selected.classList.toggle(data.actionData);
                break;
                case 'html' : selected.innerHTML = data.actionData;
                break;
                case 'value': selected.value = data.actionData;
                break;
                case 'text': selected.textContent = data.actionData;
                break;
                case 'checked':  selected.checked = data.actionData;
                break;
                case 'remove': selected.remove();
                break;
                case 'removeAttr': selected.removeAttribute(data.actionData);
                break;
                case 'css' : this.setCss(selected, data.actionData);
                break;
                case 'attr': this.setAttr(selected, data.actionData);
                break;
                case 'data': this.setData(selected, data.actionData);
                break;
                case 'getData': this.getData(selected, data.actionData);
                break;
            }
        }
    }
    
    slideUp (target, duration = 500) {
        target.style.transitionProperty = 'height, margin, padding';
        target.style.transitionDuration = duration + 'ms';
        target.style.boxSizing = 'border-box';
        target.style.height = target.offsetHeight + 'px';
        target.offsetHeight;
        target.style.overflow = 'hidden';
        target.style.height = 0;
        target.style.paddingTop = 0;
        target.style.paddingBottom = 0;
        target.style.marginTop = 0;
        target.style.marginBottom = 0;
        window.setTimeout( () => {
            target.style.display = 'none';
            target.style.removeProperty('height');
            target.style.removeProperty('padding-top');
            target.style.removeProperty('padding-bottom');
            target.style.removeProperty('margin-top');
            target.style.removeProperty('margin-bottom');
            target.style.removeProperty('overflow');
            target.style.removeProperty('transition-duration');
            target.style.removeProperty('transition-property');
        }, duration);
    }

    slideDown (target, duration = 500) {
        target.style.removeProperty('display');
        let display = window.getComputedStyle(target).display;
        if (display === 'none') display = 'block';
        target.style.display = display;
        let height = target.offsetHeight;
        target.style.overflow = 'hidden';
        target.style.height = 0;
        target.style.paddingTop = 0;
        target.style.paddingBottom = 0;
        target.style.marginTop = 0;
        target.style.marginBottom = 0;
        target.offsetHeight;
        target.style.boxSizing = 'border-box';
        target.style.transitionProperty = "height, margin, padding";
        target.style.transitionDuration = duration + 'ms';
        target.style.height = height + 'px';
        target.style.removeProperty('padding-top');
        target.style.removeProperty('padding-bottom');
        target.style.removeProperty('margin-top');
        target.style.removeProperty('margin-bottom');
        window.setTimeout( () => {
            target.style.removeProperty('height');
            target.style.removeProperty('overflow');
            target.style.removeProperty('transition-duration');
            target.style.removeProperty('transition-property');
        }, duration);
    }

    slideToggle (target, duration = 500) {
        if (window.getComputedStyle(target).display === 'none') {
            return this.slideDown(target, duration);
        } else {
            return this.slideUp(target, duration);
        }
    }
} 
class Draggable extends JUI {
    constructor(options) {
        super();
        this.options = options || {};
        this.events = {
            "drag" : this.onDrag.bind(this), 
            "dragend": this.onDragEnd.bind(this), 
            "dragenter": this.onDragEnter.bind(this), 
            "dragexit": this.onDragExit.bind(this), 
            "dragleave": this.onDragLeave.bind(this), 
            "dragover": this.onDragOver.bind(this), 
            "dragstart": this.onDragStart.bind(this), 
            "drop": this.onDrop.bind(this),
        };
        this.init();
        this.currentDrag = "";
        this.dragState = true;
    }

    init() {
       for (let name in this.events) {
           if (this.events[name]) {
                document.removeEventListener(name, this.events[name], true);
                document.addEventListener(name, this.events[name], true);
           }
       }
    }

    setDrag(target) {
        let selected = (typeof target == 'object') ? target : document.querySelector(target);
        //selected.setAttribute('dragable', 1);
        selected.setAttribute('draggable', true);
    }

    setDrop(target) {
        let selected = (typeof target == 'object') ? target : document.querySelector(target);
        selected.setAttribute('dropzone', 1);
    }

    disableDrag(target) {
        let selected = (typeof target == 'object') ? target : document.querySelector(target);
        if (selected) {
            selected.removeAttribute(['dragable','draggable']);
            selected.classList.remove('dragable');
        }
    }

    enableDrag(target) {
        let selected = (typeof target == 'object') ? target : document.querySelector(target);
        if (selected) {
            selected.setAttribute('dragable', 1);
            selected.setAttribute('draggable', true);
            selected.classList.add('dragable');
        }
    }

    //This event is fired when an element or text selection is being dragged.
    onDrag(event) {
        // calling user defined function
        if (this.options.onDrag) this.options.onDrag(event);
    }
        
    //This event is fired when an element is no longer the drag operation's immediate selection target
    onDragExit(event) {
        if (this.dragState) {
            // calling user defined function
            if (this.options.onDragExit) this.options.onDragExit(event);
        }
    }

    //This event is fired when a dragged element or text selection enters a valid drop target.
    onDragEnter(event) {
        // highlight potential drop target when the draggable element enters it
        if ( this.dragState && this.isValidDrop(event) ) {
            // calling user defined function
            if (this.options.onDragEnter) this.options.onDragEnter(event);
        }

    }

    //This event is fired when the user starts dragging an element or text selection.
    onDragStart(event) {
        if (this.isValidDrag(event)) {
            this.dragState = true;
            // store a ref. on the dragged elem
            this.currentDrag = event.target;
            
            // make it half transparent
            event.target.style.opacity = .2;

            // calling user defined function
            if (this.options.onDragStart) this.options.onDragStart(event);
        } else {
            this.dragState = false;
            //event.dataTrasfer.dropEffect = 'none'
        }
    }

    //This event is fired when a dragged element or text selection leaves a valid drop target.
    onDragLeave(event) {
        // reset background of potential drop target when the draggable element leaves it
        if ( this.dragState && this.isValidDrop(event) ) {
            // calling user defined function
            if (this.options.onDragLeave) this.options.onDragLeave(event, this.currentDrag);
        }
    }

    //This event is fired continuously when an element or text selection is being dragged and 
    //the mouse pointer is over a valid drop target (every 50 ms WHEN mouse is not moving 
    //ELSE much faster between 5 ms (slow movement) and 1ms (fast movement) approximately
    onDragOver(event) {
        // prevent default to allow drop
        event.preventDefault();

        // calling user defined function
        if (this.options.onDragOver) this.options.onDragOver(event, this.currentDrag);
    }

    //This event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)
    onDragEnd(event) {
        // reset the transparency
        event.target.style.opacity = "";

        // calling user defined function
        if (this.options.onDragEnd) this.options.onDragEnd(event, this.currentDrag);
    }

    //This event is fired when an element or text selection is dropped on a valid drop target.
    onDrop(event) {
        // prevent default action (open as link for some elements)
        event.preventDefault();
        // move dragged elem to the selected drop target
        if (this.dragState && this.isValidDrop(event) ) {
            //event.target.style.background = "";
            if (this.options.remove) this.currentDrag.parentNode.removeChild( this.currentDrag );
            if (this.options.copy) event.target.appendChild( this.currentDrag.cloneNode(true) );
            // calling user defined function
            if (this.options.onDrop) this.options.onDrop(event, this.currentDrag);
            //.draggable('destroy');
        }
    }

    isValidDrop(event) {
        if (event.target.getAttribute('dropzone') || event.target.classList.contains('dropable') || this.parent(event.target, "[dropzone]") || this.parent(event.target, ".dropable") ) {
            return true;
        } else {
            return false;
        }
    }

    isValidDrag(event) {
        if (event.target.getAttribute('dragable') || event.target.getAttribute('draggable') || this.parent(event.target, "[dragable]")) {
            return true;
        } else {
            return false;
        }
    }
}

const JS = new JUI();

class X2JS {
	config = {};
	VERSION = "1.2.0";

	DOMNodeTypes = {
		ELEMENT_NODE 	   : 1,
		TEXT_NODE    	   : 3,
		CDATA_SECTION_NODE : 4,
		COMMENT_NODE	   : 8,
		DOCUMENT_NODE 	   : 9
	}
	constructor() {
		this.initConfigDefaults();
		this.initRequiredPolyfills();
	}
	initConfigDefaults() {
		if(this.config.escapeMode === undefined) {
			this.config.escapeMode = true;
		}
		
		this.config.attributePrefix = this.config.attributePrefix || "_";
		this.config.arrayAccessForm = this.config.arrayAccessForm || "none";
		this.config.emptyNodeForm = this.config.emptyNodeForm || "text";		
		
		if(this.config.enableToStringFunc === undefined) {
			this.config.enableToStringFunc = true; 
		}
		this.config.arrayAccessFormPaths = this.config.arrayAccessFormPaths || []; 
		if(this.config.skipEmptyTextNodesForObj === undefined) {
			this.config.skipEmptyTextNodesForObj = true;
		}
		if(this.config.stripWhitespaces === undefined) {
			this.config.stripWhitespaces = true;
		}
		this.config.datetimeAccessFormPaths = this.config.datetimeAccessFormPaths || [];

		if(this.config.useDoubleQuotes === undefined) {
			this.config.useDoubleQuotes = false;
		}
		
		this.config.xmlElementsFilter = this.config.xmlElementsFilter || [];
		this.config.jsonPropertiesFilter = this.config.jsonPropertiesFilter || [];
		
		if(this.config.keepCData === undefined) {
			this.config.keepCData = false;
		}
	}

    initRequiredPolyfills() {		
	}

	getNodeLocalName( node ) {
		var nodeLocalName = node.localName;			
		if(nodeLocalName == null) // Yeah, this is IE!! 
			nodeLocalName = node.baseName;
		if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
			nodeLocalName = node.nodeName;
		return nodeLocalName;
	}
	
	getNodePrefix(node) {
		return node.prefix;
	}
		
	escapeXmlChars(str) {
		if(typeof(str) == "string")
			return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
		else
			return str;
	}

	unescapeXmlChars(str) {
		return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, '&');
	}
	
	checkInStdFiltersArrayForm(stdFiltersArrayForm, obj, name, path) {
		var idx = 0;
		for(; idx < stdFiltersArrayForm.length; idx++) {
			var filterPath = stdFiltersArrayForm[idx];
			if( typeof filterPath === "string" ) {
				if(filterPath == path)
					break;
			}
			else
			if( filterPath instanceof RegExp) {
				if(filterPath.test(path))
					break;
			}				
			else
			if( typeof filterPath === "function") {
				if(filterPath(obj, name, path))
					break;
			}
		}
		return idx!=stdFiltersArrayForm.length;
	}
	
	toArrayAccessForm(obj, childName, path) {
		switch(this.config.arrayAccessForm) {
			case "property":
				if(!(obj[childName] instanceof Array))
					obj[childName+"_asArray"] = [obj[childName]];
				else
					obj[childName+"_asArray"] = obj[childName];
				break;
			/*case "none":
				break;*/
		}
		
		if(!(obj[childName] instanceof Array) && this.config.arrayAccessFormPaths.length > 0) {
			if(this.checkInStdFiltersArrayForm(this.config.arrayAccessFormPaths, obj, childName, path)) {
				obj[childName] = [obj[childName]];
			}			
		}
	}
	
	fromXmlDateTime(prop) {
		// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
		// Improved to support full spec and optional parts
		var bits = prop.split(/[-T:+Z]/g);
		
		var d = new Date(bits[0], bits[1]-1, bits[2]);			
		var secondBits = bits[5].split("\.");
		d.setHours(bits[3], bits[4], secondBits[0]);
		if(secondBits.length>1)
			d.setMilliseconds(secondBits[1]);

		// Get supplied time zone offset in minutes
		if(bits[6] && bits[7]) {
			var offsetMinutes = bits[6] * 60 + Number(bits[7]);
			var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';

			// Apply the sign
			offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);

			// Apply offset and local timezone
			d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset());
		}
		else
			if(prop.indexOf("Z", prop.length - 1) !== -1) {
				d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));					
			}

		// d is now a local time equivalent to the supplied time
		return d;
	}
	
	checkFromXmlDateTimePaths(value, childName, fullPath) {
		if(this.config.datetimeAccessFormPaths.length > 0) {
			var path = fullPath.split("\.#")[0];
			if(this.checkInStdFiltersArrayForm(this.config.datetimeAccessFormPaths, value, childName, path)) {
				return this.fromXmlDateTime(value);
			}
			else
				return value;			
		}
		else
			return value;
	}
	
	checkXmlElementsFilter(obj, childType, childName, childPath) {
		if( childType == this.DOMNodeTypes.ELEMENT_NODE && this.config.xmlElementsFilter.length > 0) {
			return this.checkInStdFiltersArrayForm(this.config.xmlElementsFilter, obj, childName, childPath);	
		}
		else
			return true;
	}	

	parseDOMChildren( node, path ) {
		if(node.nodeType == this.DOMNodeTypes.DOCUMENT_NODE) {
			var result = new Object;
			var nodeChildren = node.childNodes;
			// Alternative for firstElementChild which is not supported in some environments
			for(var cidx=0; cidx <nodeChildren.length; cidx++) {
				var child = nodeChildren.item(cidx);
				if(child.nodeType == this.DOMNodeTypes.ELEMENT_NODE) {
					var childName = this.getNodeLocalName(child);
					result[childName] = this.parseDOMChildren(child, childName);
				}
			}
			return result;
		}
		else
		if(node.nodeType == this.DOMNodeTypes.ELEMENT_NODE) {
			var result = new Object;
			result.__cnt=0;
			
			var nodeChildren = node.childNodes;
			
			// Children nodes
			for(var cidx=0; cidx <nodeChildren.length; cidx++) {
				var child = nodeChildren.item(cidx); // nodeChildren[cidx];
				var childName = this.getNodeLocalName(child);
				
				if(child.nodeType!= this.DOMNodeTypes.COMMENT_NODE) {
					var childPath = path+"."+childName;
					if (this.checkXmlElementsFilter(result,child.nodeType,childName,childPath)) {
						result.__cnt++;
						if(result[childName] == null) {
							result[childName] = this.parseDOMChildren(child, childPath);
							this.toArrayAccessForm(result, childName, childPath);					
						}
						else {
							if(result[childName] != null) {
								if( !(result[childName] instanceof Array)) {
									result[childName] = [result[childName]];
									this.toArrayAccessForm(result, childName, childPath);
								}
							}
							(result[childName])[result[childName].length] = this.parseDOMChildren(child, childPath);
						}
					}
				}								
			}
			
			// Attributes
			for(var aidx=0; aidx <node.attributes.length; aidx++) {
				var attr = node.attributes.item(aidx); // [aidx];
				result.__cnt++;
				result[this.config.attributePrefix+attr.name]=attr.value;
			}
			
			// Node namespace prefix
			var nodePrefix = this.getNodePrefix(node);
			if(nodePrefix!=null && nodePrefix!="") {
				result.__cnt++;
				result.__prefix=nodePrefix;
			}
			
			if(result["#text"]!=null) {				
				result.__text = result["#text"];
				if(result.__text instanceof Array) {
					result.__text = result.__text.join("\n");
				}
				//if(this.config.escapeMode)
				//	result.__text = this.unescapeXmlChars(result.__text);
				if(this.config.stripWhitespaces)
					result.__text = result.__text.trim();
				delete result["#text"];
				if(this.config.arrayAccessForm=="property")
					delete result["#text_asArray"];
				result.__text = this.checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
			}
			if(result["#cdata-section"]!=null) {
				result.__cdata = result["#cdata-section"];
				delete result["#cdata-section"];
				if(this.config.arrayAccessForm=="property")
					delete result["#cdata-section_asArray"];
			}
			
			if( result.__cnt == 0 && this.config.emptyNodeForm=="text" ) {
				result = '';
			}
			else
			if( result.__cnt == 1 && result.__text!=null  ) {
				result = result.__text;
			}
			else
			if( result.__cnt == 1 && result.__cdata!=null && !this.config.keepCData  ) {
				result = result.__cdata;
			}			
			else			
			if ( result.__cnt > 1 && result.__text!=null && this.config.skipEmptyTextNodesForObj) {
				if( (this.config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
					delete result.__text;
				}
			}
			delete result.__cnt;			
			
			if( this.config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
				result.toString = function() {
					return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
				};
			}
			
			return result;
		}
		else
		if(node.nodeType == this.DOMNodeTypes.TEXT_NODE || node.nodeType == this.DOMNodeTypes.CDATA_SECTION_NODE) {
			return node.nodeValue;
		}	
	}
	
	startTag(jsonObj, element, attrList, closed) {
		var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
		if(attrList!=null) {
			for(var aidx = 0; aidx < attrList.length; aidx++) {
				var attrName = attrList[aidx];
				var attrVal = jsonObj[attrName];
				if(this.config.escapeMode)
					attrVal=this.escapeXmlChars(attrVal);
				resultStr+=" "+attrName.substr(this.config.attributePrefix.length)+"=";
				if(this.config.useDoubleQuotes)
					resultStr+='"'+attrVal+'"';
				else
					resultStr+="'"+attrVal+"'";
			}
		}
		if(!closed)
			resultStr+=">";
		else
			resultStr+="/>";
		return resultStr;
	}
	
	endTag(jsonObj,elementName) {
		return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
	}
	
	endsWith(str, suffix) {
		return str.indexOf(suffix, str.length - suffix.length) !== -1;
	}
	
	jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
		if((this.config.arrayAccessForm=="property" && this.endsWith(jsonObjField.toString(),("_asArray"))) 
				|| jsonObjField.toString().indexOf(this.config.attributePrefix)==0 
				|| jsonObjField.toString().indexOf("__")==0
				|| (jsonObj[jsonObjField] instanceof Function) )
			return true;
		else
			return false;
	}
	
	jsonXmlElemCount ( jsonObj ) {
		var elementsCnt = 0;
		if(jsonObj instanceof Object ) {
			for( var it in jsonObj  ) {
				if(this.jsonXmlSpecialElem ( jsonObj, it) )
					continue;			
				elementsCnt++;
			}
		}
		return elementsCnt;
	}
	
	checkJsonObjPropertiesFilter(jsonObj, propertyName, jsonObjPath) {
		return this.config.jsonPropertiesFilter.length == 0
			|| jsonObjPath==""
			|| this.checkInStdFiltersArrayForm(this.config.jsonPropertiesFilter, jsonObj, propertyName, jsonObjPath);	
	}
	
	parseJSONAttributes ( jsonObj ) {
		var attrList = [];
		if(jsonObj instanceof Object ) {
			for( var ait in jsonObj  ) {
				if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(this.config.attributePrefix)==0) {
					attrList.push(ait);
				}
			}
		}
		return attrList;
	}
	
	parseJSONTextAttrs ( jsonTxtObj ) {
		var result ="";
		
		if(jsonTxtObj.__cdata!=null) {										
			result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
		}
		
		if(jsonTxtObj.__text!=null) {			
			if(this.config.escapeMode)
				result+=this.escapeXmlChars(jsonTxtObj.__text);
			else
				result+=jsonTxtObj.__text;
		}
		return result;
	}
	
	parseJSONTextObject ( jsonTxtObj ) {
		var result ="";

		if( jsonTxtObj instanceof Object ) {
			result+=this.parseJSONTextAttrs ( jsonTxtObj );
		}
		else
			if(jsonTxtObj!=null) {
				if(this.config.escapeMode)
					result+=this.escapeXmlChars(jsonTxtObj);
				else
					result+=jsonTxtObj;
			}
		
		return result;
	}
	
	getJsonPropertyPath(jsonObjPath, jsonPropName) {
		if (jsonObjPath==="") {
			return jsonPropName;
		}
		else
			return jsonObjPath+"."+jsonPropName;
	}
	
	parseJSONArray ( jsonArrRoot, jsonArrObj, attrList, jsonObjPath ) {
		var result = ""; 
		if(jsonArrRoot.length == 0) {
			result+=this.startTag(jsonArrRoot, jsonArrObj, attrList, true);
		}
		else {
			for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
				result+=this.startTag(jsonArrRoot[arIdx], jsonArrObj, this.parseJSONAttributes(jsonArrRoot[arIdx]), false);
				result+=this.parseJSONObject(jsonArrRoot[arIdx], this.getJsonPropertyPath(jsonObjPath,jsonArrObj));
				result+=this.endTag(jsonArrRoot[arIdx],jsonArrObj);
			}
		}
		return result;
	}
	
	parseJSONObject ( jsonObj, jsonObjPath ) {
		var result = "";	

		var elementsCnt = this.jsonXmlElemCount ( jsonObj );
		
		if(elementsCnt > 0) {
			for( var it in jsonObj ) {
				
				if(this.jsonXmlSpecialElem ( jsonObj, it) || (jsonObjPath!="" && !this.checkJsonObjPropertiesFilter(jsonObj, it, this.getJsonPropertyPath(jsonObjPath,it))) )
					continue;			
				
				var subObj = jsonObj[it];						
				
				var attrList = this.parseJSONAttributes( subObj );
				
				if(subObj == null || subObj == undefined) {
					result+=this.startTag(subObj, it, attrList, true);
				}
				else
				if(subObj instanceof Object) {
					
					if(subObj instanceof Array) {					
						result+=this.parseJSONArray( subObj, it, attrList, jsonObjPath );					
					}
					else if(subObj instanceof Date) {
						result+=this.startTag(subObj, it, attrList, false);
						result+=subObj.toISOString();
						result+=this.endTag(subObj,it);
					}
					else {
						var subObjElementsCnt = this.jsonXmlElemCount ( subObj );
						if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
							result+=this.startTag(subObj, it, attrList, false);
							result+=this.parseJSONObject(subObj, this.getJsonPropertyPath(jsonObjPath,it));
							result+=this.endTag(subObj,it);
						}
						else {
							result+=this.startTag(subObj, it, attrList, true);
						}
					}
				}
				else {
					result+=this.startTag(subObj, it, attrList, false);
					result+=this.parseJSONTextObject(subObj);
					result+=this.endTag(subObj,it);
				}
			}
		}
		result+=this.parseJSONTextObject(jsonObj);
		
		return result;
	}
	
	parseXmlString (xmlDocStr) {
		var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
		if (xmlDocStr === undefined) {
			return null;
		}
		var xmlDoc;
		if (window.DOMParser) {
			var parser=new window.DOMParser();			
			var parsererrorNS = null;
			// IE9+ now is here
			if(!isIEParser) {
				try {
					parsererrorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI;
				}
				catch(err) {					
					parsererrorNS = null;
				}
			}
			try {
				xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
				if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
					//throw new Error('Error parsing XML: '+xmlDocStr);
					xmlDoc = null;
				}
			}
			catch(err) {
				xmlDoc = null;
			}
		}
		else {
			// IE :(
			if(xmlDocStr.indexOf("<?")==0) {
				xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
			}
			xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
			xmlDoc.async="false";
			xmlDoc.loadXML(xmlDocStr);
		}
		return xmlDoc;
	};
	
	asArray (prop) {
		if (prop === undefined || prop == null)
			return [];
		else
		if(prop instanceof Array)
			return prop;
		else
			return [prop];
	};
	
	toXmlDateTime (dt) {
		if(dt instanceof Date)
			return dt.toISOString();
		else
		if(typeof(dt) === 'number' )
			return new Date(dt).toISOString();
		else	
			return null;
	};
	
	asDateTime (prop) {
		if(typeof(prop) == "string") {
			return this.fromXmlDateTime(prop);
		}
		else
			return prop;
	};

	xml2json (xmlDoc) {
		return this.parseDOMChildren ( xmlDoc );
	};
	
	xml_str2json (xmlDocStr) {
		var xmlDoc = this.parseXmlString(xmlDocStr);
		if(xmlDoc!=null)
			return this.xml2json(xmlDoc);
		else
			return null;
	};

	json2xml_str (jsonObj) {
		return this.parseJSONObject ( jsonObj, "" );
	};

	json2xml (jsonObj) {
		var xmlDocStr = this.json2xml_str (jsonObj);
		return this.parseXmlString(xmlDocStr);
	};
	
	getVersion () {
		return this.VERSION;
	}
}

/* helper\HelperAI.svelte generated by Svelte v3.40.2 */

function XMLToJSON(myXml) {
	//var myXml = xml;
	myXml = myXml.replace(/<\!--\[CDATA\[/g, "<![CDATA[").replace(/\]\]-->/g, "]]>");

	let x2js = new X2JS({ useDoubleQuotes: true });
	let newXml = JSON.stringify(x2js.xml_str2json(myXml));
	newXml = newXml.replace("SMXML", "smxml");
	newXml = JSON.parse(newXml);
	return newXml;
}

function JSONToXML(a) {
	let b = new X2JS({ useDoubleQuotes: !0 });
	let c = b.json2xml_str(a);
	return c = c.replace("<![CDATA[", "\x3c!--[CDATA[").replace("]]>", "]]--\x3e");
}

function onUserAnsChange(result) {
	if (result) {
		AH.select("#answer", 'checked', result.ans ? true : false);
		AH.select("#special_module_user_xml", 'value', result.uXml);

		if (typeof window == 'object') {
			window.ISSPECIALMODULEUSERXMLCHANGE = 1;

			if (typeof calculatePoint != "undefined") {
				calculatePoint(result.correctPoints || 1, result.ansPoint || result.ans);
			}
		}

		globalThis.saveUserAnswerInSapper?.(result);
	}
}

const AH = new JUI();
const SSD = new JStore();

/* helper\Loader.svelte generated by Svelte v3.40.2 */

const file$1 = "helper\\Loader.svelte";

function add_css$1(target) {
	append_styles(target, "svelte-to8rmr", ".loader.svelte-to8rmr{border:2px solid #f3f3f3;border-radius:50%;border-top:2px solid #3498db;-webkit-animation:svelte-to8rmr-spin 2s linear infinite;animation:svelte-to8rmr-spin 2s linear infinite;margin:0 auto}.loader_msg.svelte-to8rmr{text-align:center;padding:15px}@-webkit-keyframes svelte-to8rmr-spin{0%{-webkit-transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg)}}@keyframes svelte-to8rmr-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFVQSxPQUFPLGNBQUMsQ0FBQyxBQUNQLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDekIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUM3QixpQkFBaUIsQ0FBRSxrQkFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUMxQyxTQUFTLENBQUUsa0JBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FDbEMsTUFBTSxDQUFFLENBQUMsQ0FBQyxJQUFJLEFBQ2hCLENBQUMsQUFFRCxXQUFXLGNBQUMsQ0FBQyxBQUNYLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUdELG1CQUFtQixrQkFBSyxDQUFDLEFBQ3ZCLEVBQUUsQUFBQyxDQUFDLEFBQUMsaUJBQWlCLENBQUUsT0FBTyxJQUFJLENBQUMsQUFBRSxDQUFDLEFBQ3ZDLElBQUksQUFBQyxDQUFDLEFBQUMsaUJBQWlCLENBQUUsT0FBTyxNQUFNLENBQUMsQUFBRSxDQUFDLEFBQzdDLENBQUMsQUFFRCxXQUFXLGtCQUFLLENBQUMsQUFDZixFQUFFLEFBQUMsQ0FBQyxBQUFDLFNBQVMsQ0FBRSxPQUFPLElBQUksQ0FBQyxBQUFFLENBQUMsQUFDL0IsSUFBSSxBQUFDLENBQUMsQUFBQyxTQUFTLENBQUUsT0FBTyxNQUFNLENBQUMsQUFBRSxDQUFDLEFBQ3JDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTG9hZGVyLnN2ZWx0ZSJdfQ== */");
}

// (7:0) {#if msg}
function create_if_block$1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*msg*/ ctx[1]);
			attr_dev(div, "class", "loader_msg svelte-to8rmr");
			add_location(div, file$1, 7, 2, 162);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*msg*/ 2) set_data_dev(t, /*msg*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(7:0) {#if msg}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let t;
	let if_block_anchor;
	let if_block = /*msg*/ ctx[1] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(div, "class", "loader svelte-to8rmr");
			set_style(div, "height", /*size*/ ctx[0] + "px");
			set_style(div, "width", /*size*/ ctx[0] + "px");
			add_location(div, file$1, 5, 0, 80);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size*/ 1) {
				set_style(div, "height", /*size*/ ctx[0] + "px");
			}

			if (dirty & /*size*/ 1) {
				set_style(div, "width", /*size*/ ctx[0] + "px");
			}

			if (/*msg*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Loader', slots, []);
	let { size = 100 } = $$props;
	let { msg = false } = $$props;
	const writable_props = ['size', 'msg'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loader> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('msg' in $$props) $$invalidate(1, msg = $$props.msg);
	};

	$$self.$capture_state = () => ({ size, msg });

	$$self.$inject_state = $$props => {
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('msg' in $$props) $$invalidate(1, msg = $$props.msg);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [size, msg];
}

class Loader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { size: 0, msg: 1 }, add_css$1);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Loader",
			options,
			id: create_fragment$1.name
		});
	}

	get size() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get msg() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set msg(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

// Thanks to @AlexxNB

function getEventsAction(component) {
	return (node) => {
		const events = Object.keys(component.$$.callbacks);
		const listeners = [];

		events.forEach((event) => listeners.push(listen(node, event, (e) => bubble(component, e))));

		return {
			destroy: () => {
				listeners.forEach((listener) => listener());
			},
		};
	};
}

function islegacy() {
	if (typeof window === 'undefined') return false;
	return !(window.CSS && window.CSS.supports && window.CSS.supports('(--foo: red)'));
}

function normalize(color) {
	if (color.charAt(0) === 'r') {
		color = rgb2hex(color);
	} else if (color.toLowerCase() === 'transparent') {
		color = '#00000000';
	}

	return color;
}

// http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
function luminance(color = '#ffffff') {
	let RsRGB, GsRGB, BsRGB, R, G, B;

	if (color.length === 0) {
		color = '#ffffff';
	}

	color = normalize(color);

	// Validate hex color
	color = String(color).replace(/[^0-9a-f]/gi, '');
	const valid = new RegExp(/^(?:[0-9a-f]{3}){1,2}$/i).test(color);

	if (valid) {
		if (color.length < 6) {
			color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
		}
	} else {
		throw new Error('Invalid HEX color!');
	}

	// Convert color to RGB
	const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
	const rgb = {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16),
	};

	RsRGB = rgb.r / 255;
	GsRGB = rgb.g / 255;
	BsRGB = rgb.b / 255;

	R = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4);
	G = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4);
	B = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);

	return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}

function rgb2hex(rgb) {
	rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
	return rgb && rgb.length === 4
		? '#' +
				('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) +
				('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) +
				('0' + parseInt(rgb[3], 10).toString(16)).slice(-2)
		: '';
}

/* node_modules\svelte-mui\src\Ripple.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file$2 = "node_modules\\svelte-mui\\src\\Ripple.svelte";

function add_css$2(target) {
	append_styles(target, "svelte-po4fcb", ".ripple.svelte-po4fcb{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-po4fcb .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-po4fcb .animation--enter{transition:none}.ripple.svelte-po4fcb .animation--in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-po4fcb .animation--out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmlwcGxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5TEMsT0FBTyxjQUFDLENBQUEsQUFDUCxPQUFPLENBQUUsS0FBSyxDQUNkLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLENBQ1QsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsYUFBYSxDQUFFLE9BQU8sQ0FDdEIsS0FBSyxDQUFFLE9BQU8sQ0FDZCxjQUFjLENBQUUsSUFBSSxDQUNwQixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxNQUFNLEFBQ2hCLENBQUEsQUFDQSxxQkFBTyxDQUFDLEFBQVEsVUFBVSxBQUFFLENBQUEsQUFDM0IsS0FBSyxDQUFFLE9BQU8sQ0FDZCxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLENBQUMsQ0FDVixjQUFjLENBQUUsSUFBSSxDQUNwQixRQUFRLENBQUUsTUFBTSxDQUNoQixXQUFXLENBQUUsU0FBUyxDQUFDLENBQUMsT0FBTyxBQUNoQyxDQUFBLEFBQ0EscUJBQU8sQ0FBQyxBQUFRLGlCQUFpQixBQUFFLENBQUEsQUFDbEMsVUFBVSxDQUFFLElBQUksQUFDakIsQ0FBQSxBQUNBLHFCQUFPLENBQUMsQUFBUSxjQUFjLEFBQUUsQ0FBQSxBQUMvQixVQUFVLENBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNyRCxVQUFVLENBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0dBQ3ZELE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDM0MsQ0FBQSxBQUNBLHFCQUFPLENBQUMsQUFBUSxlQUFlLEFBQUUsQ0FBQSxBQUNoQyxVQUFVLENBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUN0RCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlJpcHBsZS5zdmVsdGUiXX0= */");
}

function create_fragment$2(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "ripple svelte-po4fcb");
			add_location(div, file$2, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[4](div);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[4](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function isTouchEvent(e) {
	return e.constructor.name === 'TouchEvent';
}

function transform(el, value) {
	el.style['transform'] = value;
	el.style['webkitTransform'] = value;
}

function opacity(el, value) {
	el.style['opacity'] = value.toString();
}

const calculate = (e, el) => {
	const offset = el.getBoundingClientRect();
	const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
	const localX = target.clientX - offset.left;
	const localY = target.clientY - offset.top;
	let radius = 0;
	let scale = 0.3;

	// Get ripple position
	const center = el.dataset.center;

	const circle = el.dataset.circle;

	if (circle) {
		scale = 0.15;
		radius = el.clientWidth / 2;

		radius = center
		? radius
		: radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
	} else {
		radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
	}

	const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
	const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
	const x = center ? centerX : `${localX - radius}px`;
	const y = center ? centerY : `${localY - radius}px`;
	return { radius, scale, x, y, centerX, centerY };
};

const startRipple = function (eventType, event) {
	const hideEvents = ['touchcancel', 'mouseleave', 'dragstart'];
	let container = event.currentTarget || event.target;

	if (container && !container.classList.contains('ripple')) {
		container = container.querySelector('.ripple');
	}

	if (!container) {
		return;
	}

	const prev = container.dataset.event;

	if (prev && prev !== eventType) {
		return;
	}

	container.dataset.event = eventType;

	// Create the ripple
	const wave = document.createElement('span');

	const { radius, scale, x, y, centerX, centerY } = calculate(event, container);
	const color = container.dataset.color;
	const size = `${radius * 2}px`;
	wave.className = 'animation';
	wave.style.width = size;
	wave.style.height = size;
	wave.style.background = color;
	wave.classList.add('animation--enter');
	wave.classList.add('animation--visible');
	transform(wave, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
	opacity(wave, 0);
	wave.dataset.activated = String(performance.now());
	container.appendChild(wave);

	setTimeout(
		() => {
			wave.classList.remove('animation--enter');
			wave.classList.add('animation--in');
			transform(wave, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
			opacity(wave, 0.25);
		},
		0
	);

	const releaseEvent = eventType === 'mousedown' ? 'mouseup' : 'touchend';

	const onRelease = function () {
		document.removeEventListener(releaseEvent, onRelease);

		hideEvents.forEach(name => {
			document.removeEventListener(name, onRelease);
		});

		const diff = performance.now() - Number(wave.dataset.activated);
		const delay = Math.max(250 - diff, 0);

		setTimeout(
			() => {
				wave.classList.remove('animation--in');
				wave.classList.add('animation--out');
				opacity(wave, 0);

				setTimeout(
					() => {
						wave && container.removeChild(wave);

						if (container.children.length === 0) {
							delete container.dataset.event;
						}
					},
					300
				);
			},
			delay
		);
	};

	document.addEventListener(releaseEvent, onRelease);

	hideEvents.forEach(name => {
		document.addEventListener(name, onRelease, { passive: true });
	});
};

const onMouseDown = function (e) {
	// Trigger on left click only
	if (e.button === 0) {
		startRipple(e.type, e);
	}
};

const onTouchStart = function (e) {
	if (e.changedTouches) {
		for (let i = 0; i < e.changedTouches.length; ++i) {
			startRipple(e.type, e.changedTouches[i]);
		}
	}
};

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Ripple', slots, []);
	let { center = false } = $$props;
	let { circle = false } = $$props;
	let { color = 'currentColor' } = $$props;
	let el;
	let trigEl;

	onMount(async () => {
		await tick();

		try {
			if (center) {
				$$invalidate(0, el.dataset.center = 'true', el);
			}

			if (circle) {
				$$invalidate(0, el.dataset.circle = 'true', el);
			}

			$$invalidate(0, el.dataset.color = color, el);
			trigEl = el.parentElement;
		} catch(err) {
			
		} // eslint-disable-line

		if (!trigEl) {
			console.error('Ripple: Trigger element not found.');
			return;
		}

		let style = window.getComputedStyle(trigEl);

		if (style.position.length === 0 || style.position === 'static') {
			trigEl.style.position = 'relative';
		}

		trigEl.addEventListener('touchstart', onTouchStart, { passive: true });
		trigEl.addEventListener('mousedown', onMouseDown, { passive: true });
	});

	onDestroy(() => {
		if (!trigEl) {
			return;
		}

		trigEl.removeEventListener('mousedown', onMouseDown);
		trigEl.removeEventListener('touchstart', onTouchStart);
	});

	const writable_props = ['center', 'circle', 'color'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Ripple> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$props => {
		if ('center' in $$props) $$invalidate(1, center = $$props.center);
		if ('circle' in $$props) $$invalidate(2, circle = $$props.circle);
		if ('color' in $$props) $$invalidate(3, color = $$props.color);
	};

	$$self.$capture_state = () => ({
		isTouchEvent,
		transform,
		opacity,
		calculate,
		startRipple,
		onMouseDown,
		onTouchStart,
		center,
		circle,
		color,
		tick,
		onMount,
		onDestroy,
		el,
		trigEl
	});

	$$self.$inject_state = $$props => {
		if ('center' in $$props) $$invalidate(1, center = $$props.center);
		if ('circle' in $$props) $$invalidate(2, circle = $$props.circle);
		if ('color' in $$props) $$invalidate(3, color = $$props.color);
		if ('el' in $$props) $$invalidate(0, el = $$props.el);
		if ('trigEl' in $$props) trigEl = $$props.trigEl;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [el, center, circle, color, div_binding];
}

class Ripple extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { center: 1, circle: 2, color: 3 }, add_css$2);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Ripple",
			options,
			id: create_fragment$2.name
		});
	}

	get center() {
		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set center(value) {
		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get circle() {
		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set circle(value) {
		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Button.svelte generated by Svelte v3.40.2 */
const file$3 = "node_modules\\svelte-mui\\src\\Button.svelte";

function add_css$3(target) {
	append_styles(target, "svelte-6bcb3a", "button.svelte-6bcb3a:disabled{cursor:default}button.svelte-6bcb3a{cursor:pointer;font-family:Roboto, Helvetica, sans-serif;font-family:var(--button-font-family, Roboto, Helvetica, sans-serif);font-size:0.875rem;font-weight:500;letter-spacing:0.75px;text-decoration:none;text-transform:uppercase;will-change:transform, opacity;margin:0;padding:0 16px;display:-ms-inline-flexbox;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;height:36px;border:none;outline:none;line-height:inherit;user-select:none;overflow:hidden;vertical-align:middle;border-radius:4px}button.svelte-6bcb3a::-moz-focus-inner{border:0}button.svelte-6bcb3a:-moz-focusring{outline:none}button.svelte-6bcb3a:before{box-sizing:inherit;border-radius:inherit;color:inherit;bottom:0;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.2s cubic-bezier(0.25, 0.8, 0.5, 1);will-change:background-color, opacity}.toggle.svelte-6bcb3a:before{box-sizing:content-box}.active.svelte-6bcb3a:before{background-color:currentColor;opacity:0.3}.raised.svelte-6bcb3a{box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 5px 0 rgba(0, 0, 0, 0.12)}.outlined.svelte-6bcb3a{padding:0 14px;border-style:solid;border-width:2px}.shaped.svelte-6bcb3a{border-radius:18px}.dense.svelte-6bcb3a{height:32px}.icon-button.svelte-6bcb3a{line-height:0.5;border-radius:50%;padding:8px;width:40px;height:40px;vertical-align:middle}.icon-button.outlined.svelte-6bcb3a{padding:6px}.icon-button.fab.svelte-6bcb3a{border:none;width:56px;height:56px;box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 18px 0 rgba(0, 0, 0, 0.12)}.icon-button.dense.svelte-6bcb3a{width:36px;height:36px}.icon-button.fab.dense.svelte-6bcb3a{width:40px;height:40px}.outlined.svelte-6bcb3a:not(.shaped) .ripple{border-radius:0 !important}.full-width.svelte-6bcb3a{width:100%}@media(hover: hover){button.svelte-6bcb3a:hover:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}button.focus-visible.svelte-6bcb3a:focus:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.3}button.focus-visible.toggle.svelte-6bcb3a:focus:not(.active):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF1SUMsb0JBQU0sU0FBUyxBQUFDLENBQUEsQUFDZixNQUFNLENBQUUsT0FBTyxBQUNoQixDQUFBLEFBQ0EsTUFBTSxjQUFDLENBQUEsQUFDTixNQUFNLENBQUUsT0FBTyxDQUNmLFdBQVcsQ0FBRSxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxVQUFVLENBRTFDLFdBQVcsQ0FBRSxJQUFJLG9CQUFvQixDQUFDLDhCQUE4QixDQUFDLENBQ3JFLFNBQVMsQ0FBRSxRQUFRLENBQ25CLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLGVBQWUsQ0FBRSxJQUFJLENBQ3JCLGNBQWMsQ0FBRSxTQUFTLENBQ3pCLFdBQVcsQ0FBRSxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQy9CLE1BQU0sQ0FBRSxDQUFDLENBQ1QsT0FBTyxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQ2YsT0FBTyxDQUFFLGtCQUFrQixDQUMzQixPQUFPLENBQUUsV0FBVyxDQUNwQixRQUFRLENBQUUsUUFBUSxDQUNsQixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixVQUFVLENBQUUsVUFBVSxDQUN0QixNQUFNLENBQUUsSUFBSSxDQUNaLE1BQU0sQ0FBRSxJQUFJLENBQ1osT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsT0FBTyxDQUNwQixXQUFXLENBQUUsSUFBSSxDQUNqQixRQUFRLENBQUUsTUFBTSxDQUNoQixjQUFjLENBQUUsTUFBTSxDQUN0QixhQUFhLENBQUUsR0FBRyxBQUNuQixDQUFBLEFBQ0Esb0JBQU0sa0JBQWtCLEFBQUMsQ0FBQSxBQUN4QixNQUFNLENBQUUsQ0FBQyxBQUNWLENBQUEsQUFDQSxvQkFBTSxlQUFlLEFBQUMsQ0FBQSxBQUNyQixPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDQSxvQkFBTSxPQUFPLEFBQUMsQ0FBQSxBQUNiLFVBQVUsQ0FBRSxPQUFPLENBQ25CLGFBQWEsQ0FBRSxPQUFPLENBQ3RCLEtBQUssQ0FBRSxPQUFPLENBQ2QsTUFBTSxDQUFFLENBQUMsQ0FDVCxPQUFPLENBQUUsRUFBRSxDQUNYLElBQUksQ0FBRSxDQUFDLENBQ1AsT0FBTyxDQUFFLENBQUMsQ0FDVixjQUFjLENBQUUsSUFBSSxDQUNwQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsQ0FBQyxDQUNSLEdBQUcsQ0FBRSxDQUFDLENBQ04sVUFBVSxDQUFFLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNoRCxXQUFXLENBQUUsZ0JBQWdCLENBQUMsQ0FBQyxPQUFPLEFBQ3ZDLENBQUEsQUFDQSxxQkFBTyxPQUFPLEFBQUMsQ0FBQSxBQUNkLFVBQVUsQ0FBRSxXQUFXLEFBQ3hCLENBQUEsQUFDQSxxQkFBTyxPQUFPLEFBQUMsQ0FBQSxBQUNkLGdCQUFnQixDQUFFLFlBQVksQ0FDOUIsT0FBTyxDQUFFLEdBQUcsQUFDYixDQUFBLEFBRUEsT0FBTyxjQUFDLENBQUEsQUFDUCxVQUFVLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtHQUM3RSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQUFDakMsQ0FBQSxBQUNBLFNBQVMsY0FBQyxDQUFBLEFBQ1QsT0FBTyxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQ2YsWUFBWSxDQUFFLEtBQUssQ0FDbkIsWUFBWSxDQUFFLEdBQUcsQUFDbEIsQ0FBQSxBQUNBLE9BQU8sY0FBQyxDQUFBLEFBQ1AsYUFBYSxDQUFFLElBQUksQUFDcEIsQ0FBQSxBQUNBLE1BQU0sY0FBQyxDQUFBLEFBQ04sTUFBTSxDQUFFLElBQUksQUFDYixDQUFBLEFBRUEsWUFBWSxjQUFDLENBQUEsQUFDWixXQUFXLENBQUUsR0FBRyxDQUNoQixhQUFhLENBQUUsR0FBRyxDQUNsQixPQUFPLENBQUUsR0FBRyxDQUNaLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixjQUFjLENBQUUsTUFBTSxBQUN2QixDQUFBLEFBQ0EsWUFBWSxTQUFTLGNBQUMsQ0FBQSxBQUNyQixPQUFPLENBQUUsR0FBRyxBQUNiLENBQUEsQUFDQSxZQUFZLElBQUksY0FBQyxDQUFBLEFBQ2hCLE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFBO0dBQzlFLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxBQUNsQyxDQUFBLEFBQ0EsWUFBWSxNQUFNLGNBQUMsQ0FBQSxBQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2IsQ0FBQSxBQUVBLFlBQVksSUFBSSxNQUFNLGNBQUMsQ0FBQSxBQUN0QixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2IsQ0FBQSxBQUVBLHVCQUFTLEtBQUssT0FBTyxDQUFDLENBQUMsQUFBUSxPQUFPLEFBQUUsQ0FBQSxBQUN2QyxhQUFhLENBQUUsQ0FBQyxDQUFDLFVBQVUsQUFDNUIsQ0FBQSxBQUVBLFdBQVcsY0FBQyxDQUFBLEFBQ1gsS0FBSyxDQUFFLElBQUksQUFDWixDQUFBLEFBRUEsTUFBTSxBQUFDLFFBQVEsS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUNyQixvQkFBTSxNQUFNLEtBQUssT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxPQUFPLEFBQUMsQ0FBQSxBQUMvRCxnQkFBZ0IsQ0FBRSxZQUFZLENBQzlCLE9BQU8sQ0FBRSxJQUFJLEFBQ2QsQ0FBQSxBQUNBLE1BQU0sNEJBQWMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsT0FBTyxBQUFDLENBQUEsQUFDN0UsZ0JBQWdCLENBQUUsWUFBWSxDQUM5QixPQUFPLENBQUUsR0FBRyxBQUNiLENBQUEsQUFDQSxNQUFNLGNBQWMscUJBQU8sTUFBTSxLQUFLLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsT0FBTyxBQUFDLENBQUEsQUFDcEYsZ0JBQWdCLENBQUUsWUFBWSxDQUM5QixPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJ1dHRvbi5zdmVsdGUiXX0= */");
}

// (20:1) {#if ripple}
function create_if_block$2(ctx) {
	let ripple_1;
	let current;

	ripple_1 = new Ripple({
			props: {
				center: /*icon*/ ctx[3],
				circle: /*icon*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(ripple_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(ripple_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const ripple_1_changes = {};
			if (dirty & /*icon*/ 8) ripple_1_changes.center = /*icon*/ ctx[3];
			if (dirty & /*icon*/ 8) ripple_1_changes.circle = /*icon*/ ctx[3];
			ripple_1.$set(ripple_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(ripple_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(ripple_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(ripple_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(20:1) {#if ripple}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let button;
	let t;
	let events_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);
	let if_block = /*ripple*/ ctx[10] && create_if_block$2(ctx);

	let button_levels = [
		{ class: /*className*/ ctx[1] },
		{ style: /*style*/ ctx[2] },
		/*attrs*/ ctx[14]
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(button, button_data);
			toggle_class(button, "raised", /*raised*/ ctx[6]);
			toggle_class(button, "outlined", /*outlined*/ ctx[8] && !(/*raised*/ ctx[6] || /*unelevated*/ ctx[7]));
			toggle_class(button, "shaped", /*shaped*/ ctx[9] && !/*icon*/ ctx[3]);
			toggle_class(button, "dense", /*dense*/ ctx[5]);
			toggle_class(button, "fab", /*fab*/ ctx[4] && /*icon*/ ctx[3]);
			toggle_class(button, "icon-button", /*icon*/ ctx[3]);
			toggle_class(button, "toggle", /*toggle*/ ctx[11]);
			toggle_class(button, "active", /*toggle*/ ctx[11] && /*active*/ ctx[0]);
			toggle_class(button, "full-width", /*fullWidth*/ ctx[12] && !/*icon*/ ctx[3]);
			toggle_class(button, "svelte-6bcb3a", true);
			add_location(button, file$3, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append_dev(button, t);
			if (if_block) if_block.m(button, null);
			if (button.autofocus) button.focus();
			/*button_binding*/ ctx[20](button);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button, "click", /*onclick*/ ctx[16], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[15].call(null, button))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], !current ? -1 : dirty, null, null);
				}
			}

			if (/*ripple*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*ripple*/ 1024) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(button, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				(!current || dirty & /*className*/ 2) && { class: /*className*/ ctx[1] },
				(!current || dirty & /*style*/ 4) && { style: /*style*/ ctx[2] },
				dirty & /*attrs*/ 16384 && /*attrs*/ ctx[14]
			]));

			toggle_class(button, "raised", /*raised*/ ctx[6]);
			toggle_class(button, "outlined", /*outlined*/ ctx[8] && !(/*raised*/ ctx[6] || /*unelevated*/ ctx[7]));
			toggle_class(button, "shaped", /*shaped*/ ctx[9] && !/*icon*/ ctx[3]);
			toggle_class(button, "dense", /*dense*/ ctx[5]);
			toggle_class(button, "fab", /*fab*/ ctx[4] && /*icon*/ ctx[3]);
			toggle_class(button, "icon-button", /*icon*/ ctx[3]);
			toggle_class(button, "toggle", /*toggle*/ ctx[11]);
			toggle_class(button, "active", /*toggle*/ ctx[11] && /*active*/ ctx[0]);
			toggle_class(button, "full-width", /*fullWidth*/ ctx[12] && !/*icon*/ ctx[3]);
			toggle_class(button, "svelte-6bcb3a", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*button_binding*/ ctx[20](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let iconSize;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Button', slots, ['default']);
	const dispatch = createEventDispatcher();
	const events = getEventsAction(current_component);
	let { class: className = '' } = $$props;
	let { style = null } = $$props;
	let { icon = false } = $$props;
	let { fab = false } = $$props;
	let { dense = false } = $$props;
	let { raised = false } = $$props;
	let { unelevated = false } = $$props;
	let { outlined = false } = $$props;
	let { shaped = false } = $$props;
	let { color = null } = $$props;
	let { ripple = true } = $$props;
	let { toggle = false } = $$props;
	let { active = false } = $$props;
	let { fullWidth = false } = $$props;
	let elm;
	let attrs = {};

	beforeUpdate(() => {
		if (!elm) return;
		let svgs = elm.getElementsByTagName('svg');
		let len = svgs.length;

		for (let i = 0; i < len; i++) {
			svgs[i].setAttribute('width', iconSize + (toggle && !icon ? 2 : 0));
			svgs[i].setAttribute('height', iconSize + (toggle && !icon ? 2 : 0));
		}

		$$invalidate(13, elm.style.backgroundColor = raised || unelevated ? color : 'transparent', elm);
		let bg = getComputedStyle(elm).getPropertyValue('background-color');

		$$invalidate(
			13,
			elm.style.color = raised || unelevated
			? luminance(bg) > 0.5 ? '#000' : '#fff'
			: color,
			elm
		);
	});

	function onclick(e) {
		if (toggle) {
			$$invalidate(0, active = !active);
			dispatch('change', active);
		}
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elm = $$value;
			$$invalidate(13, elm);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ('style' in $$new_props) $$invalidate(2, style = $$new_props.style);
		if ('icon' in $$new_props) $$invalidate(3, icon = $$new_props.icon);
		if ('fab' in $$new_props) $$invalidate(4, fab = $$new_props.fab);
		if ('dense' in $$new_props) $$invalidate(5, dense = $$new_props.dense);
		if ('raised' in $$new_props) $$invalidate(6, raised = $$new_props.raised);
		if ('unelevated' in $$new_props) $$invalidate(7, unelevated = $$new_props.unelevated);
		if ('outlined' in $$new_props) $$invalidate(8, outlined = $$new_props.outlined);
		if ('shaped' in $$new_props) $$invalidate(9, shaped = $$new_props.shaped);
		if ('color' in $$new_props) $$invalidate(17, color = $$new_props.color);
		if ('ripple' in $$new_props) $$invalidate(10, ripple = $$new_props.ripple);
		if ('toggle' in $$new_props) $$invalidate(11, toggle = $$new_props.toggle);
		if ('active' in $$new_props) $$invalidate(0, active = $$new_props.active);
		if ('fullWidth' in $$new_props) $$invalidate(12, fullWidth = $$new_props.fullWidth);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		beforeUpdate,
		createEventDispatcher,
		current_component,
		getEventsAction,
		islegacy,
		luminance,
		Ripple,
		dispatch,
		events,
		className,
		style,
		icon,
		fab,
		dense,
		raised,
		unelevated,
		outlined,
		shaped,
		color,
		ripple,
		toggle,
		active,
		fullWidth,
		elm,
		attrs,
		onclick,
		iconSize
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
		if ('style' in $$props) $$invalidate(2, style = $$new_props.style);
		if ('icon' in $$props) $$invalidate(3, icon = $$new_props.icon);
		if ('fab' in $$props) $$invalidate(4, fab = $$new_props.fab);
		if ('dense' in $$props) $$invalidate(5, dense = $$new_props.dense);
		if ('raised' in $$props) $$invalidate(6, raised = $$new_props.raised);
		if ('unelevated' in $$props) $$invalidate(7, unelevated = $$new_props.unelevated);
		if ('outlined' in $$props) $$invalidate(8, outlined = $$new_props.outlined);
		if ('shaped' in $$props) $$invalidate(9, shaped = $$new_props.shaped);
		if ('color' in $$props) $$invalidate(17, color = $$new_props.color);
		if ('ripple' in $$props) $$invalidate(10, ripple = $$new_props.ripple);
		if ('toggle' in $$props) $$invalidate(11, toggle = $$new_props.toggle);
		if ('active' in $$props) $$invalidate(0, active = $$new_props.active);
		if ('fullWidth' in $$props) $$invalidate(12, fullWidth = $$new_props.fullWidth);
		if ('elm' in $$props) $$invalidate(13, elm = $$new_props.elm);
		if ('attrs' in $$props) $$invalidate(14, attrs = $$new_props.attrs);
		if ('iconSize' in $$props) iconSize = $$new_props.iconSize;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 {
			/* eslint-disable no-unused-vars */
			const { style, icon, fab, dense, raised, unelevated, outlined, shaped, color, ripple, toggle, active, fullWidth, ...other } = $$props;

			!other.disabled && delete other.disabled;
			delete other.class;
			$$invalidate(14, attrs = other);
		}

		if ($$self.$$.dirty & /*icon, fab, dense*/ 56) {
			 iconSize = icon ? fab ? 24 : dense ? 20 : 24 : dense ? 16 : 18;
		}

		if ($$self.$$.dirty & /*color, elm*/ 139264) {
			 if (color === 'primary') {
				$$invalidate(17, color = islegacy() ? '#1976d2' : 'var(--primary, #1976d2)');
			} else if (color == 'accent') {
				$$invalidate(17, color = islegacy() ? '#f50057' : 'var(--accent, #f50057)');
			} else if (!color && elm) {
				$$invalidate(17, color = elm.style.color || elm.parentElement.style.color || (islegacy() ? '#333' : 'var(--color, #333)'));
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		active,
		className,
		style,
		icon,
		fab,
		dense,
		raised,
		unelevated,
		outlined,
		shaped,
		ripple,
		toggle,
		fullWidth,
		elm,
		attrs,
		events,
		onclick,
		color,
		$$scope,
		slots,
		button_binding
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				class: 1,
				style: 2,
				icon: 3,
				fab: 4,
				dense: 5,
				raised: 6,
				unelevated: 7,
				outlined: 8,
				shaped: 9,
				color: 17,
				ripple: 10,
				toggle: 11,
				active: 0,
				fullWidth: 12
			},
			add_css$3
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$3.name
		});
	}

	get class() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fab() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fab(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dense() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dense(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raised() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raised(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get unelevated() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set unelevated(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlined() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlined(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shaped() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shaped(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fullWidth() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fullWidth(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Icon.svelte generated by Svelte v3.40.2 */
const file$4 = "node_modules\\svelte-mui\\src\\Icon.svelte";

function add_css$4(target) {
	append_styles(target, "svelte-h2unzw", ".icon.svelte-h2unzw.svelte-h2unzw{display:inline-block;position:relative;vertical-align:middle;line-height:0.5}.icon.svelte-h2unzw>svg.svelte-h2unzw{display:inline-block}.flip.svelte-h2unzw.svelte-h2unzw{transform:scale(-1, -1)}.flip-h.svelte-h2unzw.svelte-h2unzw{transform:scale(-1, 1)}.flip-v.svelte-h2unzw.svelte-h2unzw{transform:scale(1, -1)}.spin.svelte-h2unzw.svelte-h2unzw{animation:svelte-h2unzw-spin 1s 0s infinite linear}.pulse.svelte-h2unzw.svelte-h2unzw{animation:svelte-h2unzw-spin 1s infinite steps(8)}@keyframes svelte-h2unzw-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWNvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBd0RDLEtBQUssNEJBQUMsQ0FBQSxBQUNMLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLFdBQVcsQ0FBRSxHQUFHLEFBQ2pCLENBQUEsQUFDQSxtQkFBSyxDQUFHLEdBQUcsY0FBQyxDQUFBLEFBQ1gsT0FBTyxDQUFFLFlBQVksQUFDdEIsQ0FBQSxBQUNBLEtBQUssNEJBQUMsQ0FBQSxBQUNMLFNBQVMsQ0FBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxBQUN6QixDQUFBLEFBQ0EsT0FBTyw0QkFBQyxDQUFBLEFBQ1AsU0FBUyxDQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEFBQ3hCLENBQUEsQUFDQSxPQUFPLDRCQUFDLENBQUEsQUFDUCxTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQUFDeEIsQ0FBQSxBQUNBLEtBQUssNEJBQUMsQ0FBQSxBQUNMLFNBQVMsQ0FBRSxrQkFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQUFDdEMsQ0FBQSxBQUNBLE1BQU0sNEJBQUMsQ0FBQSxBQUNOLFNBQVMsQ0FBRSxrQkFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQUFDckMsQ0FBQSxBQUNBLFdBQVcsa0JBQUssQ0FBQSxBQUNmLEVBQUUsQUFBQyxDQUFBLEFBQ0YsU0FBUyxDQUFFLE9BQU8sSUFBSSxDQUFDLEFBQ3hCLENBQUEsQUFDQSxJQUFJLEFBQUMsQ0FBQSxBQUNKLFNBQVMsQ0FBRSxPQUFPLE1BQU0sQ0FBQyxBQUMxQixDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJJY29uLnN2ZWx0ZSJdfQ== */");
}

// (16:1) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? -1 : dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(16:1) {:else}",
		ctx
	});

	return block;
}

// (12:1) {#if typeof path === 'string'}
function create_if_block$3(ctx) {
	let svg;
	let path_1;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path_1 = svg_element("path");
			attr_dev(path_1, "d", /*path*/ ctx[1]);
			add_location(path_1, file$4, 13, 3, 311);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", /*viewBox*/ ctx[2]);
			attr_dev(svg, "class", "svelte-h2unzw");
			add_location(svg, file$4, 12, 2, 257);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path_1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*path*/ 2) {
				attr_dev(path_1, "d", /*path*/ ctx[1]);
			}

			if (dirty & /*viewBox*/ 4) {
				attr_dev(svg, "viewBox", /*viewBox*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(12:1) {#if typeof path === 'string'}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let i;
	let current_block_type_index;
	let if_block;
	let i_class_value;
	let events_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$3, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (typeof /*path*/ ctx[1] === 'string') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let i_levels = [
		{
			class: i_class_value = 'icon ' + /*className*/ ctx[0]
		},
		/*attrs*/ ctx[7]
	];

	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	const block = {
		c: function create() {
			i = element("i");
			if_block.c();
			set_attributes(i, i_data);
			toggle_class(i, "flip", /*flip*/ ctx[3] && typeof /*flip*/ ctx[3] === 'boolean');
			toggle_class(i, "flip-h", /*flip*/ ctx[3] === 'h');
			toggle_class(i, "flip-v", /*flip*/ ctx[3] === 'v');
			toggle_class(i, "spin", /*spin*/ ctx[4]);
			toggle_class(i, "pulse", /*pulse*/ ctx[5] && !/*spin*/ ctx[4]);
			toggle_class(i, "svelte-h2unzw", true);
			add_location(i, file$4, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
			if_blocks[current_block_type_index].m(i, null);
			/*i_binding*/ ctx[13](i);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[8].call(null, i));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(i, null);
			}

			set_attributes(i, i_data = get_spread_update(i_levels, [
				(!current || dirty & /*className*/ 1 && i_class_value !== (i_class_value = 'icon ' + /*className*/ ctx[0])) && { class: i_class_value },
				dirty & /*attrs*/ 128 && /*attrs*/ ctx[7]
			]));

			toggle_class(i, "flip", /*flip*/ ctx[3] && typeof /*flip*/ ctx[3] === 'boolean');
			toggle_class(i, "flip-h", /*flip*/ ctx[3] === 'h');
			toggle_class(i, "flip-v", /*flip*/ ctx[3] === 'v');
			toggle_class(i, "spin", /*spin*/ ctx[4]);
			toggle_class(i, "pulse", /*pulse*/ ctx[5] && !/*spin*/ ctx[4]);
			toggle_class(i, "svelte-h2unzw", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if_blocks[current_block_type_index].d();
			/*i_binding*/ ctx[13](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Icon', slots, ['default']);
	const events = getEventsAction(current_component);
	let { class: className = '' } = $$props;
	let { path = null } = $$props;
	let { size = 24 } = $$props;
	let { viewBox = '0 0 24 24' } = $$props;
	let { color = 'currentColor' } = $$props;
	let { flip = false } = $$props;
	let { spin = false } = $$props;
	let { pulse = false } = $$props;
	let elm;
	let attrs = {};

	function i_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elm = $$value;
			$$invalidate(6, elm);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ('path' in $$new_props) $$invalidate(1, path = $$new_props.path);
		if ('size' in $$new_props) $$invalidate(9, size = $$new_props.size);
		if ('viewBox' in $$new_props) $$invalidate(2, viewBox = $$new_props.viewBox);
		if ('color' in $$new_props) $$invalidate(10, color = $$new_props.color);
		if ('flip' in $$new_props) $$invalidate(3, flip = $$new_props.flip);
		if ('spin' in $$new_props) $$invalidate(4, spin = $$new_props.spin);
		if ('pulse' in $$new_props) $$invalidate(5, pulse = $$new_props.pulse);
		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		current_component,
		getEventsAction,
		events,
		className,
		path,
		size,
		viewBox,
		color,
		flip,
		spin,
		pulse,
		elm,
		attrs
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		if ('path' in $$props) $$invalidate(1, path = $$new_props.path);
		if ('size' in $$props) $$invalidate(9, size = $$new_props.size);
		if ('viewBox' in $$props) $$invalidate(2, viewBox = $$new_props.viewBox);
		if ('color' in $$props) $$invalidate(10, color = $$new_props.color);
		if ('flip' in $$props) $$invalidate(3, flip = $$new_props.flip);
		if ('spin' in $$props) $$invalidate(4, spin = $$new_props.spin);
		if ('pulse' in $$props) $$invalidate(5, pulse = $$new_props.pulse);
		if ('elm' in $$props) $$invalidate(6, elm = $$new_props.elm);
		if ('attrs' in $$props) $$invalidate(7, attrs = $$new_props.attrs);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 {
			/* eslint-disable no-unused-vars */
			const { path, size, viewBox, color, flip, spin, pulse, ...other } = $$props;

			delete other.class;
			$$invalidate(7, attrs = other);
		}

		if ($$self.$$.dirty & /*elm, size, color*/ 1600) {
			 if (elm) {
				elm.firstChild.setAttribute('width', size);
				elm.firstChild.setAttribute('height', size);
				color && elm.firstChild.setAttribute('fill', color);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		className,
		path,
		viewBox,
		flip,
		spin,
		pulse,
		elm,
		attrs,
		events,
		size,
		color,
		$$scope,
		slots,
		i_binding
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$4,
			create_fragment$4,
			safe_not_equal,
			{
				class: 0,
				path: 1,
				size: 9,
				viewBox: 2,
				color: 10,
				flip: 3,
				spin: 4,
				pulse: 5
			},
			add_css$4
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$4.name
		});
	}

	get class() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get path() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get viewBox() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set viewBox(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flip() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flip(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spin() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spin(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pulse() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pulse(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Checkbox.svelte generated by Svelte v3.40.2 */
const file$5 = "node_modules\\svelte-mui\\src\\Checkbox.svelte";

function add_css$5(target) {
	append_styles(target, "svelte-1idh7xl", "label.svelte-1idh7xl.svelte-1idh7xl{width:100%;align-items:center;display:flex;margin:0;position:relative;cursor:pointer;line-height:40px;user-select:none}input.svelte-1idh7xl.svelte-1idh7xl{cursor:inherit;width:100%;height:100%;position:absolute;top:0;left:0;margin:0;padding:0;opacity:0 !important}.mark.svelte-1idh7xl.svelte-1idh7xl{display:flex;position:relative;justify-content:center;align-items:center;border-radius:50%;width:40px;height:40px}.mark.svelte-1idh7xl.svelte-1idh7xl:before{background-color:currentColor;border-radius:inherit;bottom:0;color:inherit;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media not all and (min-resolution: 0.001dpcm){@supports (-webkit-appearance: none) and (stroke-color: transparent){.mark.svelte-1idh7xl.svelte-1idh7xl:before{transition:none}}}.label-text.svelte-1idh7xl.svelte-1idh7xl{margin-left:4px;white-space:nowrap;overflow:hidden}.right.svelte-1idh7xl .label-text.svelte-1idh7xl{margin-left:0;margin-right:auto;order:-1}@media(hover: hover){label.svelte-1idh7xl:hover:not([disabled]):not(.disabled) .mark.svelte-1idh7xl:before{opacity:0.15}.focus-visible:focus:not([disabled]):not(.disabled)~.mark.svelte-1idh7xl.svelte-1idh7xl:before{opacity:0.3}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hlY2tib3guc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNIQyxLQUFLLDhCQUFDLENBQUEsQUFDTCxLQUFLLENBQUUsSUFBSSxDQUNYLFdBQVcsQ0FBRSxNQUFNLENBQ25CLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLENBQUMsQ0FDVCxRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsT0FBTyxDQUNmLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFdBQVcsQ0FBRSxJQUFJLEFBQ2xCLENBQUEsQUFDQSxLQUFLLDhCQUFDLENBQUEsQUFDTCxNQUFNLENBQUUsT0FBTyxDQUNmLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsTUFBTSxDQUFFLENBQUMsQ0FDVCxPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxDQUFDLENBQUMsVUFBVSxBQUN0QixDQUFBLEFBQ0EsS0FBSyw4QkFBQyxDQUFBLEFBQ0wsT0FBTyxDQUFFLElBQUksQ0FDYixRQUFRLENBQUUsUUFBUSxDQUVsQixlQUFlLENBQUUsTUFBTSxDQUN2QixXQUFXLENBQUUsTUFBTSxDQUNuQixhQUFhLENBQUUsR0FBRyxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2IsQ0FBQSxBQUNBLG1DQUFLLE9BQU8sQUFBQyxDQUFBLEFBQ1osZ0JBQWdCLENBQUUsWUFBWSxDQUM5QixhQUFhLENBQUUsT0FBTyxDQUN0QixNQUFNLENBQUUsQ0FBQyxDQUNULEtBQUssQ0FBRSxPQUFPLENBQ2QsT0FBTyxDQUFFLEVBQUUsQ0FDWCxJQUFJLENBQUUsQ0FBQyxDQUNQLE9BQU8sQ0FBRSxDQUFDLENBQ1YsY0FBYyxDQUFFLElBQUksQ0FDcEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLENBQUMsQ0FDUixHQUFHLENBQUUsQ0FBQyxDQUNOLFVBQVUsQ0FBRSxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDakQsQ0FBQSxBQUdBLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLFNBQVMsQ0FBQyxBQUFDLENBQUEsQUFDOUMsVUFBVSxDQUFDLG9CQUFvQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxjQUFjLFdBQVcsQ0FBQyxBQUFDLENBQUEsQUFDcEUsbUNBQUssT0FBTyxBQUFDLENBQUEsQUFDWixVQUFVLENBQUUsSUFBSSxBQUNqQixDQUFBLEFBQ0QsQ0FBQSxBQUNELENBQUEsQUFDQSxXQUFXLDhCQUFDLENBQUEsQUFDWCxXQUFXLENBQUUsR0FBRyxDQUNoQixXQUFXLENBQUUsTUFBTSxDQUNuQixRQUFRLENBQUUsTUFBTSxBQUNqQixDQUFBLEFBQ0EscUJBQU0sQ0FBQyxXQUFXLGVBQUMsQ0FBQSxBQUNsQixXQUFXLENBQUUsQ0FBQyxDQUNkLFlBQVksQ0FBRSxJQUFJLENBQ2xCLEtBQUssQ0FBRSxFQUFFLEFBQ1YsQ0FBQSxBQUNBLE1BQU0sQUFBQyxRQUFRLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDckIsb0JBQUssTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxvQkFBSyxPQUFPLEFBQUMsQ0FBQSxBQUN2RCxPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDUSxjQUFjLEFBQUMsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBRyxtQ0FBSyxPQUFPLEFBQUMsQ0FBQSxBQUMzRSxPQUFPLENBQUUsR0FBRyxBQUNiLENBQUEsQUFDRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNoZWNrYm94LnN2ZWx0ZSJdfQ== */");
}

// (13:2) {#if ripple}
function create_if_block$4(ctx) {
	let ripple_1;
	let current;

	ripple_1 = new Ripple({
			props: { center: true, circle: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(ripple_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(ripple_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(ripple_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(ripple_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(ripple_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(13:2) {#if ripple}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let label;
	let input;
	let events_action;
	let t0;
	let div0;
	let icon;
	let t1;
	let div0_style_value;
	let t2;
	let div1;
	let label_class_value;
	let current;
	let mounted;
	let dispose;
	let input_levels = [{ type: "checkbox" }, { __value: /*value*/ ctx[9] }, /*attrs*/ ctx[10]];
	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	icon = new Icon({
			props: {
				path: /*indeterminate*/ ctx[2]
				? /*checkboxIndeterminate*/ ctx[14]
				: /*checked*/ ctx[0]
					? /*checkbox*/ ctx[12]
					: /*checkboxOutline*/ ctx[13]
			},
			$$inline: true
		});

	let if_block = /*ripple*/ ctx[7] && create_if_block$4(ctx);
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			div0 = element("div");
			create_component(icon.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			set_attributes(input, input_data);
			if (/*checked*/ ctx[0] === void 0 || /*indeterminate*/ ctx[2] === void 0) add_render_callback(() => /*input_change_handler*/ ctx[19].call(input));
			toggle_class(input, "svelte-1idh7xl", true);
			add_location(input, file$5, 1, 1, 70);
			attr_dev(div0, "class", "mark svelte-1idh7xl");

			attr_dev(div0, "style", div0_style_value = `color: ${/*indeterminate*/ ctx[2] || /*checked*/ ctx[0]
			? /*color*/ ctx[1]
			: '#9a9a9a'}`);

			add_location(div0, file$5, 10, 1, 198);
			attr_dev(div1, "class", "label-text svelte-1idh7xl");
			add_location(div1, file$5, 17, 1, 438);
			attr_dev(label, "class", label_class_value = "" + (null_to_empty(/*className*/ ctx[3]) + " svelte-1idh7xl"));
			attr_dev(label, "style", /*style*/ ctx[4]);
			attr_dev(label, "title", /*title*/ ctx[8]);
			toggle_class(label, "right", /*right*/ ctx[6]);
			toggle_class(label, "disabled", /*disabled*/ ctx[5]);
			add_location(label, file$5, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			if (input.autofocus) input.focus();
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[2];
			append_dev(label, t0);
			append_dev(label, div0);
			mount_component(icon, div0, null);
			append_dev(div0, t1);
			if (if_block) if_block.m(div0, null);
			append_dev(label, t2);
			append_dev(label, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[19]),
					listen_dev(input, "change", /*groupUpdate*/ ctx[15], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[11].call(null, input))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				{ type: "checkbox" },
				(!current || dirty & /*value*/ 512) && { __value: /*value*/ ctx[9] },
				dirty & /*attrs*/ 1024 && /*attrs*/ ctx[10]
			]));

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*indeterminate*/ 4) {
				input.indeterminate = /*indeterminate*/ ctx[2];
			}

			toggle_class(input, "svelte-1idh7xl", true);
			const icon_changes = {};

			if (dirty & /*indeterminate, checked*/ 5) icon_changes.path = /*indeterminate*/ ctx[2]
			? /*checkboxIndeterminate*/ ctx[14]
			: /*checked*/ ctx[0]
				? /*checkbox*/ ctx[12]
				: /*checkboxOutline*/ ctx[13];

			icon.$set(icon_changes);

			if (/*ripple*/ ctx[7]) {
				if (if_block) {
					if (dirty & /*ripple*/ 128) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*indeterminate, checked, color*/ 7 && div0_style_value !== (div0_style_value = `color: ${/*indeterminate*/ ctx[2] || /*checked*/ ctx[0]
			? /*color*/ ctx[1]
			: '#9a9a9a'}`)) {
				attr_dev(div0, "style", div0_style_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], !current ? -1 : dirty, null, null);
				}
			}

			if (!current || dirty & /*className*/ 8 && label_class_value !== (label_class_value = "" + (null_to_empty(/*className*/ ctx[3]) + " svelte-1idh7xl"))) {
				attr_dev(label, "class", label_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr_dev(label, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*title*/ 256) {
				attr_dev(label, "title", /*title*/ ctx[8]);
			}

			if (dirty & /*className, right*/ 72) {
				toggle_class(label, "right", /*right*/ ctx[6]);
			}

			if (dirty & /*className, disabled*/ 40) {
				toggle_class(label, "disabled", /*disabled*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			destroy_component(icon);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Checkbox', slots, ['default']);
	const events = getEventsAction(current_component);
	let { checked = false } = $$props;
	let { class: className = '' } = $$props;
	let { style = null } = $$props;
	let { color = 'primary' } = $$props; // primary, accent, currentColor, inherit
	let { disabled = false } = $$props;
	let { group = null } = $$props;
	let { indeterminate = false } = $$props;
	let { right = false } = $$props;
	let { ripple = true } = $$props;
	let { title = null } = $$props;
	let { value = 'on' } = $$props;
	let attrs = {};
	let checkbox = 'M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z';
	let checkboxOutline = 'M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z';
	let checkboxIndeterminate = 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z';

	function groupCheck() {
		setTimeout(
			() => {
				$$invalidate(0, checked = group.indexOf(value) >= 0);
			},
			0
		);
	}

	function groupUpdate() /*e*/ {
		if (group !== null) {
			let i = group.indexOf(value);

			if (checked) {
				if (i < 0) {
					group.push(value);
				}
			} else if (i >= 0) {
				group.splice(i, 1);
			}

			$$invalidate(16, group);
		}
	}

	function input_change_handler() {
		checked = this.checked;
		indeterminate = this.indeterminate;
		$$invalidate(0, checked);
		$$invalidate(2, indeterminate);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
		if ('disabled' in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ('group' in $$new_props) $$invalidate(16, group = $$new_props.group);
		if ('indeterminate' in $$new_props) $$invalidate(2, indeterminate = $$new_props.indeterminate);
		if ('right' in $$new_props) $$invalidate(6, right = $$new_props.right);
		if ('ripple' in $$new_props) $$invalidate(7, ripple = $$new_props.ripple);
		if ('title' in $$new_props) $$invalidate(8, title = $$new_props.title);
		if ('value' in $$new_props) $$invalidate(9, value = $$new_props.value);
		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		current_component,
		getEventsAction,
		islegacy,
		Icon,
		Ripple,
		events,
		checked,
		className,
		style,
		color,
		disabled,
		group,
		indeterminate,
		right,
		ripple,
		title,
		value,
		attrs,
		checkbox,
		checkboxOutline,
		checkboxIndeterminate,
		groupCheck,
		groupUpdate
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
		if ('checked' in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
		if ('color' in $$props) $$invalidate(1, color = $$new_props.color);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$new_props.disabled);
		if ('group' in $$props) $$invalidate(16, group = $$new_props.group);
		if ('indeterminate' in $$props) $$invalidate(2, indeterminate = $$new_props.indeterminate);
		if ('right' in $$props) $$invalidate(6, right = $$new_props.right);
		if ('ripple' in $$props) $$invalidate(7, ripple = $$new_props.ripple);
		if ('title' in $$props) $$invalidate(8, title = $$new_props.title);
		if ('value' in $$props) $$invalidate(9, value = $$new_props.value);
		if ('attrs' in $$props) $$invalidate(10, attrs = $$new_props.attrs);
		if ('checkbox' in $$props) $$invalidate(12, checkbox = $$new_props.checkbox);
		if ('checkboxOutline' in $$props) $$invalidate(13, checkboxOutline = $$new_props.checkboxOutline);
		if ('checkboxIndeterminate' in $$props) $$invalidate(14, checkboxIndeterminate = $$new_props.checkboxIndeterminate);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 {
			/* eslint-disable no-unused-vars */
			const { checked, style, color, group, indeterminate, right, ripple, title, value, ...other } = $$props;

			!other.disabled && delete other.disabled;
			delete other.class;
			$$invalidate(10, attrs = other);
		}

		if ($$self.$$.dirty & /*group*/ 65536) {
			 if (group !== null) {
				groupCheck();
			}
		}

		if ($$self.$$.dirty & /*color*/ 2) {
			 if (color === 'primary' || !color) {
				$$invalidate(1, color = islegacy() ? '#1976d2' : 'var(--primary, #1976d2)');
			} else if (color === 'accent') {
				$$invalidate(1, color = islegacy() ? '#f50057' : 'var(--accent, #f50057)');
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		color,
		indeterminate,
		className,
		style,
		disabled,
		right,
		ripple,
		title,
		value,
		attrs,
		events,
		checkbox,
		checkboxOutline,
		checkboxIndeterminate,
		groupUpdate,
		group,
		$$scope,
		slots,
		input_change_handler
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				checked: 0,
				class: 3,
				style: 4,
				color: 1,
				disabled: 5,
				group: 16,
				indeterminate: 2,
				right: 6,
				ripple: 7,
				title: 8,
				value: 9
			},
			add_css$5
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment$5.name
		});
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Textfield.svelte generated by Svelte v3.40.2 */
const file$6 = "node_modules\\svelte-mui\\src\\Textfield.svelte";

function add_css$6(target) {
	append_styles(target, "svelte-1dzu4e7", ".text-field.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{font-family:Roboto, 'Segoe UI', sans-serif;font-weight:400;font-size:inherit;text-decoration:inherit;text-transform:inherit;box-sizing:border-box;margin:0 0 20px;position:relative;width:100%;background-color:inherit;will-change:opacity, transform, color}.outlined.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{margin-top:12px}.required.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{position:relative;top:0.175em;left:0.125em;color:#ff5252}.input.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{box-sizing:border-box;font:inherit;width:100%;min-height:32px;background:none;text-align:left;color:#333;color:var(--color, #333);caret-color:#1976d2;caret-color:var(--primary, #1976d2);border:none;margin:0;padding:2px 0 0;outline:none}.input.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7::placeholder{color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));font-weight:100}.input.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7::-moz-focus-inner{padding:0;border:0}.input.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7:-moz-focusring{outline:none}.input.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7:required{box-shadow:none}.input.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7:invalid{box-shadow:none}.input.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7:active{outline:none}.input.svelte-1dzu4e7:hover~.input-line.svelte-1dzu4e7.svelte-1dzu4e7{background:#333;background:var(--color, #333)}.label.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{font:inherit;display:inline-flex;position:absolute;left:0;top:28px;padding-right:0.2em;color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));background-color:inherit;pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;max-width:90%;white-space:nowrap;transform-origin:left top;transition:0.18s cubic-bezier(0.25, 0.8, 0.5, 1)}.focus-ring.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{pointer-events:none;margin:0;padding:0;border:2px solid transparent;border-radius:4px;position:absolute;left:0;top:0;right:0;bottom:0}.input-line.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;left:0;right:0;bottom:0;margin:0;height:1px;background:rgba(0, 0, 0, 0.3755);background:var(--label, rgba(0, 0, 0, 0.3755))}.focus-line.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;bottom:0;left:0;right:0;height:2px;-webkit-transform:scaleX(0);transform:scaleX(0);transition:transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\t-webkit-transform 0.18s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.18s cubic-bezier(0.4, 0, 0.2, 1);opacity:0;z-index:2;background:#1976d2;background:var(--primary, #1976d2)}.help.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;left:0;right:0;bottom:-18px;display:flex;justify-content:space-between;font-size:12px;line-height:normal;letter-spacing:0.4px;color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));opacity:0;overflow:hidden;max-width:90%;white-space:nowrap}.persist.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7,.error.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7,.input.svelte-1dzu4e7:focus~.help.svelte-1dzu4e7.svelte-1dzu4e7{opacity:1}.error.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{color:#ff5252}.baseline.dirty.svelte-1dzu4e7 .label.svelte-1dzu4e7.svelte-1dzu4e7{letter-spacing:0.4px;top:6px;bottom:unset;font-size:13px}.baseline.svelte-1dzu4e7 .input.svelte-1dzu4e7:focus~.label.svelte-1dzu4e7{letter-spacing:0.4px;top:6px;bottom:unset;font-size:13px;color:#1976d2;color:var(--primary, #1976d2)}.baseline.svelte-1dzu4e7 .input.svelte-1dzu4e7:focus~.focus-line.svelte-1dzu4e7{transform:scaleX(1);opacity:1}.baseline.svelte-1dzu4e7 .input.svelte-1dzu4e7.svelte-1dzu4e7{height:52px;padding-top:22px}.baseline.filled.svelte-1dzu4e7.svelte-1dzu4e7.svelte-1dzu4e7{background:rgba(0, 0, 0, 0.0555);background:var(--bg-input-filled, rgba(0, 0, 0, 0.0555));border-radius:4px 4px 0 0}.baseline.filled.svelte-1dzu4e7 .label.svelte-1dzu4e7.svelte-1dzu4e7{background:none}.baseline.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7.svelte-1dzu4e7,.baseline.filled.svelte-1dzu4e7 .label.svelte-1dzu4e7.svelte-1dzu4e7{padding-left:8px;padding-right:8px}.baseline.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7:focus~.label.svelte-1dzu4e7{top:6px}.baseline.filled.svelte-1dzu4e7 .help.svelte-1dzu4e7.svelte-1dzu4e7{padding-left:8px}.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7.svelte-1dzu4e7:hover,.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7.svelte-1dzu4e7:focus{background:rgba(0, 0, 0, 0.0555);background:var(--bg-input-filled, rgba(0, 0, 0, 0.0555))}.outlined.svelte-1dzu4e7 .help.svelte-1dzu4e7.svelte-1dzu4e7{left:18px}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7.svelte-1dzu4e7{padding:11px 16px 9px;border-radius:4px;border:1px solid;border-color:rgba(0, 0, 0, 0.3755);border-color:var(--label, rgba(0, 0, 0, 0.3755))}.outlined.svelte-1dzu4e7 .label.svelte-1dzu4e7.svelte-1dzu4e7{top:12px;bottom:unset;left:17px}.outlined.dirty.svelte-1dzu4e7 .label.svelte-1dzu4e7.svelte-1dzu4e7{top:-6px;bottom:unset;font-size:12px;letter-spacing:0.4px;padding:0 4px;left:13px}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7.svelte-1dzu4e7:hover{border-color:#333;border-color:var(--color, #333)}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7:focus~.label.svelte-1dzu4e7{top:-6px;bottom:unset;font-size:12px;letter-spacing:0.4px;padding:0 4px;left:13px;color:#1976d2;color:var(--primary, #1976d2)}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7:focus~.focus-ring.svelte-1dzu4e7,.outlined.svelte-1dzu4e7 .input.focus-visible.svelte-1dzu4e7~.focus-ring.svelte-1dzu4e7{border-color:#1976d2;border-color:var(--primary, #1976d2)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dGZpZWxkLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtSEMsV0FBVyw2Q0FBQyxDQUFBLEFBQ1gsV0FBVyxDQUFFLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FDM0MsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsU0FBUyxDQUFFLE9BQU8sQ0FDbEIsZUFBZSxDQUFFLE9BQU8sQ0FDeEIsY0FBYyxDQUFFLE9BQU8sQ0FDdkIsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsTUFBTSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNoQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsV0FBVyxDQUFFLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssQUFDdkMsQ0FBQSxBQUNBLFNBQVMsNkNBQUMsQ0FBQSxBQUNULFVBQVUsQ0FBRSxJQUFJLEFBQ2pCLENBQUEsQUFDQSxTQUFTLDZDQUFDLENBQUEsQUFDVCxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsT0FBTyxDQUNaLElBQUksQ0FBRSxPQUFPLENBQ2IsS0FBSyxDQUFFLE9BQU8sQUFDZixDQUFBLEFBQ0EsTUFBTSw2Q0FBQyxDQUFBLEFBQ04sVUFBVSxDQUFFLFVBQVUsQ0FDdEIsSUFBSSxDQUFFLE9BQU8sQ0FDYixLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLEtBQUssQ0FBRSxJQUFJLENBRVgsS0FBSyxDQUFFLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUN6QixXQUFXLENBQUUsT0FBTyxDQUVwQixXQUFXLENBQUUsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLENBQ3BDLE1BQU0sQ0FBRSxJQUFJLENBQ1osTUFBTSxDQUFFLENBQUMsQ0FDVCxPQUFPLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBRWhCLE9BQU8sQ0FBRSxJQUFJLEFBQ2QsQ0FBQSxBQUNBLG1EQUFNLGFBQWEsQUFBQyxDQUFBLEFBQ25CLEtBQUssQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUU1QixLQUFLLENBQUUsSUFBSSxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FDMUMsV0FBVyxDQUFFLEdBQUcsQUFDakIsQ0FBQSxBQUNBLG1EQUFNLGtCQUFrQixBQUFDLENBQUEsQUFDeEIsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsQ0FBQyxBQUNWLENBQUEsQUFDQSxtREFBTSxlQUFlLEFBQUMsQ0FBQSxBQUNyQixPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDQSxtREFBTSxTQUFTLEFBQUMsQ0FBQSxBQUNmLFVBQVUsQ0FBRSxJQUFJLEFBQ2pCLENBQUEsQUFDQSxtREFBTSxRQUFRLEFBQUMsQ0FBQSxBQUNkLFVBQVUsQ0FBRSxJQUFJLEFBQ2pCLENBQUEsQUFDQSxtREFBTSxPQUFPLEFBQUMsQ0FBQSxBQUNiLE9BQU8sQ0FBRSxJQUFJLEFBQ2QsQ0FBQSxBQUNBLHFCQUFNLE1BQU0sQ0FBRyxXQUFXLDhCQUFDLENBQUEsQUFDMUIsVUFBVSxDQUFFLElBQUksQ0FFaEIsVUFBVSxDQUFFLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxBQUMvQixDQUFBLEFBQ0EsTUFBTSw2Q0FBQyxDQUFBLEFBQ04sSUFBSSxDQUFFLE9BQU8sQ0FDYixPQUFPLENBQUUsV0FBVyxDQUNwQixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsQ0FBQyxDQUNQLEdBQUcsQ0FBRSxJQUFJLENBQ1QsYUFBYSxDQUFFLEtBQUssQ0FDcEIsS0FBSyxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBRTVCLEtBQUssQ0FBRSxJQUFJLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUMxQyxnQkFBZ0IsQ0FBRSxPQUFPLENBRXpCLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLDJCQUEyQixDQUFFLE1BQU0sQ0FDbkMsbUJBQW1CLENBQUUsTUFBTSxDQUUzQixRQUFRLENBQUUsTUFBTSxDQUNoQixTQUFTLENBQUUsR0FBRyxDQUNkLFdBQVcsQ0FBRSxNQUFNLENBRW5CLGdCQUFnQixDQUFFLElBQUksQ0FBQyxHQUFHLENBQzFCLFVBQVUsQ0FBRSxLQUFLLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDbEQsQ0FBQSxBQUNBLFdBQVcsNkNBQUMsQ0FBQSxBQUNYLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLE1BQU0sQ0FBRSxDQUFDLENBQ1QsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQzdCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsR0FBRyxDQUFFLENBQUMsQ0FDTixLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLEFBQ1YsQ0FBQSxBQUNBLFdBQVcsNkNBQUMsQ0FBQSxBQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLENBQUMsQ0FDUixNQUFNLENBQUUsQ0FBQyxDQUNULE1BQU0sQ0FBRSxDQUFDLENBQ1QsTUFBTSxDQUFFLEdBQUcsQ0FDWCxVQUFVLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FFakMsVUFBVSxDQUFFLElBQUksT0FBTyxDQUFDLHNCQUFzQixDQUFDLEFBQ2hELENBQUEsQUFDQSxXQUFXLDZDQUFDLENBQUEsQUFDWCxRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsQ0FBQyxDQUNULElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLENBQUMsQ0FDUixNQUFNLENBQUUsR0FBRyxDQUNYLGlCQUFpQixDQUFFLE9BQU8sQ0FBQyxDQUFDLENBRTVCLFNBQVMsQ0FBRSxPQUFPLENBQUMsQ0FBQyxDQUVwQixVQUFVLENBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0dBQ3ZELE9BQU8sQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUMxQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FFckQsVUFBVSxDQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUN2RCxPQUFPLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzNDLE9BQU8sQ0FBRSxDQUFDLENBQ1YsT0FBTyxDQUFFLENBQUMsQ0FFVixVQUFVLENBQUUsT0FBTyxDQUVuQixVQUFVLENBQUUsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLEFBQ3BDLENBQUEsQUFDQSxLQUFLLDZDQUFDLENBQUEsQUFDTCxRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsQ0FBQyxDQUNQLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLEtBQUssQ0FDYixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxhQUFhLENBQzlCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsY0FBYyxDQUFFLEtBQUssQ0FDckIsS0FBSyxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBRTVCLEtBQUssQ0FBRSxJQUFJLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUMxQyxPQUFPLENBQUUsQ0FBQyxDQUVWLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFNBQVMsQ0FBRSxHQUFHLENBQ2QsV0FBVyxDQUFFLE1BQU0sQUFDcEIsQ0FBQSxBQUNBLHFEQUFRLENBQ1IsbURBQU0sQ0FDTixxQkFBTSxNQUFNLENBQUcsS0FBSyw4QkFBQyxDQUFBLEFBQ3BCLE9BQU8sQ0FBRSxDQUFDLEFBQ1gsQ0FBQSxBQUNBLE1BQU0sNkNBQUMsQ0FBQSxBQUNOLEtBQUssQ0FBRSxPQUFPLEFBQ2YsQ0FBQSxBQUVBLFNBQVMscUJBQU0sQ0FBQyxNQUFNLDhCQUFDLENBQUEsQUFDdEIsY0FBYyxDQUFFLEtBQUssQ0FDckIsR0FBRyxDQUFFLEdBQUcsQ0FDUixNQUFNLENBQUUsS0FBSyxDQUNiLFNBQVMsQ0FBRSxJQUFJLEFBQ2hCLENBQUEsQUFDQSx3QkFBUyxDQUFDLHFCQUFNLE1BQU0sQ0FBRyxNQUFNLGVBQUMsQ0FBQSxBQUMvQixjQUFjLENBQUUsS0FBSyxDQUNyQixHQUFHLENBQUUsR0FBRyxDQUNSLE1BQU0sQ0FBRSxLQUFLLENBQ2IsU0FBUyxDQUFFLElBQUksQ0FDZixLQUFLLENBQUUsT0FBTyxDQUVkLEtBQUssQ0FBRSxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsQUFDL0IsQ0FBQSxBQUNBLHdCQUFTLENBQUMscUJBQU0sTUFBTSxDQUFHLFdBQVcsZUFBQyxDQUFBLEFBQ3BDLFNBQVMsQ0FBRSxPQUFPLENBQUMsQ0FBQyxDQUNwQixPQUFPLENBQUUsQ0FBQyxBQUNYLENBQUEsQUFFQSx3QkFBUyxDQUFDLE1BQU0sOEJBQUMsQ0FBQSxBQUNoQixNQUFNLENBQUUsSUFBSSxDQUNaLFdBQVcsQ0FBRSxJQUFJLEFBQ2xCLENBQUEsQUFFQSxTQUFTLE9BQU8sNkNBQUMsQ0FBQSxBQUNoQixVQUFVLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FFakMsVUFBVSxDQUFFLElBQUksaUJBQWlCLENBQUMsc0JBQXNCLENBQUMsQ0FDekQsYUFBYSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDM0IsQ0FBQSxBQUNBLFNBQVMsc0JBQU8sQ0FBQyxNQUFNLDhCQUFDLENBQUEsQUFDdkIsVUFBVSxDQUFFLElBQUksQUFDakIsQ0FBQSxBQUNBLFNBQVMsc0JBQU8sQ0FBQyxvQ0FBTSxDQUN2QixTQUFTLHNCQUFPLENBQUMsTUFBTSw4QkFBQyxDQUFBLEFBQ3ZCLFlBQVksQ0FBRSxHQUFHLENBQ2pCLGFBQWEsQ0FBRSxHQUFHLEFBQ25CLENBQUEsQUFDQSxTQUFTLHNCQUFPLENBQUMscUJBQU0sTUFBTSxDQUFHLE1BQU0sZUFBQyxDQUFBLEFBQ3RDLEdBQUcsQ0FBRSxHQUFHLEFBQ1QsQ0FBQSxBQUNBLFNBQVMsc0JBQU8sQ0FBQyxLQUFLLDhCQUFDLENBQUEsQUFDdEIsWUFBWSxDQUFFLEdBQUcsQUFDbEIsQ0FBQSxBQUNBLHNCQUFPLENBQUMsb0NBQU0sTUFBTSxDQUNwQixzQkFBTyxDQUFDLG9DQUFNLE1BQU0sQUFBQyxDQUFBLEFBQ3BCLFVBQVUsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUVqQyxVQUFVLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxzQkFBc0IsQ0FBQyxBQUMxRCxDQUFBLEFBRUEsd0JBQVMsQ0FBQyxLQUFLLDhCQUFDLENBQUEsQUFDZixJQUFJLENBQUUsSUFBSSxBQUNYLENBQUEsQUFDQSx3QkFBUyxDQUFDLE1BQU0sOEJBQUMsQ0FBQSxBQUNoQixPQUFPLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQ3RCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUNqQixZQUFZLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FFbkMsWUFBWSxDQUFFLElBQUksT0FBTyxDQUFDLHNCQUFzQixDQUFDLEFBQ2xELENBQUEsQUFDQSx3QkFBUyxDQUFDLE1BQU0sOEJBQUMsQ0FBQSxBQUNoQixHQUFHLENBQUUsSUFBSSxDQUNULE1BQU0sQ0FBRSxLQUFLLENBQ2IsSUFBSSxDQUFFLElBQUksQUFDWCxDQUFBLEFBQ0EsU0FBUyxxQkFBTSxDQUFDLE1BQU0sOEJBQUMsQ0FBQSxBQUN0QixHQUFHLENBQUUsSUFBSSxDQUNULE1BQU0sQ0FBRSxLQUFLLENBQ2IsU0FBUyxDQUFFLElBQUksQ0FDZixjQUFjLENBQUUsS0FBSyxDQUNyQixPQUFPLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDZCxJQUFJLENBQUUsSUFBSSxBQUNYLENBQUEsQUFDQSx3QkFBUyxDQUFDLG9DQUFNLE1BQU0sQUFBQyxDQUFBLEFBQ3RCLFlBQVksQ0FBRSxJQUFJLENBRWxCLFlBQVksQ0FBRSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsQUFDakMsQ0FBQSxBQUNBLHdCQUFTLENBQUMscUJBQU0sTUFBTSxDQUFHLE1BQU0sZUFBQyxDQUFBLEFBQy9CLEdBQUcsQ0FBRSxJQUFJLENBQ1QsTUFBTSxDQUFFLEtBQUssQ0FDYixTQUFTLENBQUUsSUFBSSxDQUNmLGNBQWMsQ0FBRSxLQUFLLENBQ3JCLE9BQU8sQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUNkLElBQUksQ0FBRSxJQUFJLENBQ1YsS0FBSyxDQUFFLE9BQU8sQ0FFZCxLQUFLLENBQUUsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLEFBQy9CLENBQUEsQUFDQSx3QkFBUyxDQUFDLHFCQUFNLE1BQU0sQ0FBRywwQkFBVyxDQUNwQyx3QkFBUyxDQUFDLE1BQU0sNkJBQWMsQ0FBRyxXQUFXLGVBQUMsQ0FBQSxBQUM1QyxZQUFZLENBQUUsT0FBTyxDQUVyQixZQUFZLENBQUUsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLEFBQ3RDLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGV4dGZpZWxkLnN2ZWx0ZSJdfQ== */");
}

// (14:2) {#if required && !value.length}
function create_if_block_2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "*";
			attr_dev(span, "class", "required svelte-1dzu4e7");
			add_location(span, file$6, 14, 3, 313);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(14:2) {#if required && !value.length}",
		ctx
	});

	return block;
}

// (18:1) {#if !outlined || filled}
function create_if_block_1(ctx) {
	let div0;
	let t;
	let div1;

	const block = {
		c: function create() {
			div0 = element("div");
			t = space();
			div1 = element("div");
			attr_dev(div0, "class", "input-line svelte-1dzu4e7");
			add_location(div0, file$6, 18, 2, 390);
			attr_dev(div1, "class", "focus-line svelte-1dzu4e7");
			add_location(div1, file$6, 19, 2, 419);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(18:1) {#if !outlined || filled}",
		ctx
	});

	return block;
}

// (23:1) {#if !!message || !!error}
function create_if_block$5(ctx) {
	let div1;
	let div0;
	let t_value = (/*error*/ ctx[11] || /*message*/ ctx[10]) + "";
	let t;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t = text(t_value);
			attr_dev(div0, "class", "message");
			add_location(div0, file$6, 24, 3, 549);
			attr_dev(div1, "class", "help svelte-1dzu4e7");
			toggle_class(div1, "persist", /*messagePersist*/ ctx[9]);
			toggle_class(div1, "error", /*error*/ ctx[11]);
			add_location(div1, file$6, 23, 2, 484);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*error, message*/ 3072 && t_value !== (t_value = (/*error*/ ctx[11] || /*message*/ ctx[10]) + "")) set_data_dev(t, t_value);

			if (dirty & /*messagePersist*/ 512) {
				toggle_class(div1, "persist", /*messagePersist*/ ctx[9]);
			}

			if (dirty & /*error*/ 2048) {
				toggle_class(div1, "error", /*error*/ ctx[11]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(23:1) {#if !!message || !!error}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div2;
	let input;
	let events_action;
	let t0;
	let div0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let t5;
	let div2_class_value;
	let mounted;
	let dispose;
	let input_levels = [{ class: "input" }, /*attrs*/ ctx[12]];
	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	let if_block0 = /*required*/ ctx[2] && !/*value*/ ctx[0].length && create_if_block_2(ctx);
	let if_block1 = (!/*outlined*/ ctx[7] || /*filled*/ ctx[8]) && create_if_block_1(ctx);
	let if_block2 = (!!/*message*/ ctx[10] || !!/*error*/ ctx[11]) && create_if_block$5(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			input = element("input");
			t0 = space();
			div0 = element("div");
			t1 = space();
			div1 = element("div");
			t2 = text(/*label*/ ctx[6]);
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			if (if_block2) if_block2.c();
			set_attributes(input, input_data);
			toggle_class(input, "svelte-1dzu4e7", true);
			add_location(input, file$6, 8, 1, 158);
			attr_dev(div0, "class", "focus-ring svelte-1dzu4e7");
			add_location(div0, file$6, 10, 1, 218);
			attr_dev(div1, "class", "label svelte-1dzu4e7");
			add_location(div1, file$6, 11, 1, 246);

			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(`text-field mb-2 ${/*outlined*/ ctx[7] && !/*filled*/ ctx[8]
			? 'outlined'
			: 'baseline'} ${/*className*/ ctx[3]}`) + " svelte-1dzu4e7"));

			attr_dev(div2, "style", /*style*/ ctx[4]);
			attr_dev(div2, "title", /*title*/ ctx[5]);
			toggle_class(div2, "filled", /*filled*/ ctx[8]);
			toggle_class(div2, "dirty", /*dirty*/ ctx[13]);
			toggle_class(div2, "disabled", /*disabled*/ ctx[1]);
			add_location(div2, file$6, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, input);
			if (input.autofocus) input.focus();
			set_input_value(input, /*value*/ ctx[0]);
			append_dev(div2, t0);
			append_dev(div2, div0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, t2);
			append_dev(div1, t3);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div2, t4);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t5);
			if (if_block2) if_block2.m(div2, null);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[16]),
					action_destroyer(events_action = /*events*/ ctx[14].call(null, input))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(input, input_data = get_spread_update(input_levels, [{ class: "input" }, dirty & /*attrs*/ 4096 && /*attrs*/ ctx[12]]));

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			toggle_class(input, "svelte-1dzu4e7", true);
			if (dirty & /*label*/ 64) set_data_dev(t2, /*label*/ ctx[6]);

			if (/*required*/ ctx[2] && !/*value*/ ctx[0].length) {
				if (if_block0) ; else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div1, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*outlined*/ ctx[7] || /*filled*/ ctx[8]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div2, t5);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!!/*message*/ ctx[10] || !!/*error*/ ctx[11]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$5(ctx);
					if_block2.c();
					if_block2.m(div2, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*outlined, filled, className*/ 392 && div2_class_value !== (div2_class_value = "" + (null_to_empty(`text-field mb-2 ${/*outlined*/ ctx[7] && !/*filled*/ ctx[8]
			? 'outlined'
			: 'baseline'} ${/*className*/ ctx[3]}`) + " svelte-1dzu4e7"))) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*style*/ 16) {
				attr_dev(div2, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*title*/ 32) {
				attr_dev(div2, "title", /*title*/ ctx[5]);
			}

			if (dirty & /*outlined, filled, className, filled*/ 392) {
				toggle_class(div2, "filled", /*filled*/ ctx[8]);
			}

			if (dirty & /*outlined, filled, className, dirty*/ 8584) {
				toggle_class(div2, "dirty", /*dirty*/ ctx[13]);
			}

			if (dirty & /*outlined, filled, className, disabled*/ 394) {
				toggle_class(div2, "disabled", /*disabled*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let dirty;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Textfield', slots, []);
	const events = getEventsAction(current_component);
	let { value = '' } = $$props;
	let { disabled = false } = $$props;
	let { required = false } = $$props;
	let { class: className = '' } = $$props;
	let { style = null } = $$props;
	let { title = null } = $$props;
	let { label = '' } = $$props;
	let { outlined = false } = $$props;
	let { filled = false } = $$props;
	let { messagePersist = false } = $$props;
	let { message = '' } = $$props;
	let { error = '' } = $$props;
	let placeholder;
	let attrs = {};

	const allowedTypes = [
		'date',
		'datetime-local',
		'email',
		'month',
		'number',
		'password',
		'search',
		'tel',
		'text',
		'time',
		'url',
		'week'
	];

	const dirtyTypes = ['date', 'datetime-local', 'month', 'time', 'week'];

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('disabled' in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
		if ('required' in $$new_props) $$invalidate(2, required = $$new_props.required);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ('title' in $$new_props) $$invalidate(5, title = $$new_props.title);
		if ('label' in $$new_props) $$invalidate(6, label = $$new_props.label);
		if ('outlined' in $$new_props) $$invalidate(7, outlined = $$new_props.outlined);
		if ('filled' in $$new_props) $$invalidate(8, filled = $$new_props.filled);
		if ('messagePersist' in $$new_props) $$invalidate(9, messagePersist = $$new_props.messagePersist);
		if ('message' in $$new_props) $$invalidate(10, message = $$new_props.message);
		if ('error' in $$new_props) $$invalidate(11, error = $$new_props.error);
	};

	$$self.$capture_state = () => ({
		current_component,
		getEventsAction,
		events,
		value,
		disabled,
		required,
		className,
		style,
		title,
		label,
		outlined,
		filled,
		messagePersist,
		message,
		error,
		placeholder,
		attrs,
		allowedTypes,
		dirtyTypes,
		dirty
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$new_props.disabled);
		if ('required' in $$props) $$invalidate(2, required = $$new_props.required);
		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
		if ('title' in $$props) $$invalidate(5, title = $$new_props.title);
		if ('label' in $$props) $$invalidate(6, label = $$new_props.label);
		if ('outlined' in $$props) $$invalidate(7, outlined = $$new_props.outlined);
		if ('filled' in $$props) $$invalidate(8, filled = $$new_props.filled);
		if ('messagePersist' in $$props) $$invalidate(9, messagePersist = $$new_props.messagePersist);
		if ('message' in $$props) $$invalidate(10, message = $$new_props.message);
		if ('error' in $$props) $$invalidate(11, error = $$new_props.error);
		if ('placeholder' in $$props) $$invalidate(15, placeholder = $$new_props.placeholder);
		if ('attrs' in $$props) $$invalidate(12, attrs = $$new_props.attrs);
		if ('dirty' in $$props) $$invalidate(13, dirty = $$new_props.dirty);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 {
			/* eslint-disable no-unused-vars */
			const { value, style, title, label, outlined, filled, messagePersist, message, error, ...other } = $$props;

			!other.readonly && delete other.readonly;
			!other.disabled && delete other.disabled;
			delete other.class;

			other.type = allowedTypes.indexOf(other.type) < 0
			? 'text'
			: other.type;

			$$invalidate(15, placeholder = other.placeholder);
			$$invalidate(12, attrs = other);
		}

		if ($$self.$$.dirty & /*value, placeholder, attrs*/ 36865) {
			 $$invalidate(13, dirty = typeof value === 'string' && value.length > 0 || typeof value === 'number' || placeholder || dirtyTypes.indexOf(attrs.type) >= 0);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		disabled,
		required,
		className,
		style,
		title,
		label,
		outlined,
		filled,
		messagePersist,
		message,
		error,
		attrs,
		dirty,
		events,
		placeholder,
		input_input_handler
	];
}

class Textfield extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				value: 0,
				disabled: 1,
				required: 2,
				class: 3,
				style: 4,
				title: 5,
				label: 6,
				outlined: 7,
				filled: 8,
				messagePersist: 9,
				message: 10,
				error: 11
			},
			add_css$6
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Textfield",
			options,
			id: create_fragment$6.name
		});
	}

	get value() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlined() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlined(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filled() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filled(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messagePersist() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messagePersist(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get message() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function getFocusable(context = document) {
	const focusable = Array.prototype.slice
		.call(
			context.querySelectorAll(
				'button, [href], select, textarea, input:not([type="hidden"]), [tabindex]:not([tabindex="-1"])'
			)
		)
		.filter(function(item) {
			const style = window.getComputedStyle(item);

			return (
				!item.disabled &&
				!item.getAttribute('disabled') &&
				!item.classList.contains('disabled') &&
				style.display !== 'none' &&
				style.visibility !== 'hidden' &&
				style.opacity > 0
			);
		});

	return focusable;
}

function trapTabKey(e, context) {
	if (e.key !== 'Tab' && e.keyCode !== 9) {
		return;
	}

	let focusableItems = getFocusable(context);

	if (focusableItems.length === 0) {
		e.preventDefault();
		return;
	}

	let focusedItem = document.activeElement;

	let focusedItemIndex = focusableItems.indexOf(focusedItem);

	if (e.shiftKey) {
		if (focusedItemIndex <= 0) {
			focusableItems[focusableItems.length - 1].focus();
			e.preventDefault();
		}
	} else {
		if (focusedItemIndex >= focusableItems.length - 1) {
			focusableItems[0].focus();
			e.preventDefault();
		}
	}
}

/* node_modules\svelte-mui\src\Popover.svelte generated by Svelte v3.40.2 */

const { window: window_1$1 } = globals;
const file$7 = "node_modules\\svelte-mui\\src\\Popover.svelte";

function add_css$7(target) {
	append_styles(target, "svelte-5k22n0", ".popover.svelte-5k22n0{color:#333;color:var(--color, #333);background:#fff;background:var(--bg-popover, #fff);backface-visibility:hidden;position:fixed;border-radius:2px;max-height:100%;max-width:80%;overflow:auto;outline:none;box-shadow:0 3px 3px -2px rgba(0, 0, 0, 0.2), 0 3px 4px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 8px 0 rgba(0, 0, 0, 0.12);z-index:50}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUG9wb3Zlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBOEpDLFFBQVEsY0FBQyxDQUFBLEFBQ1IsS0FBSyxDQUFFLElBQUksQ0FFWCxLQUFLLENBQUUsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQ3pCLFVBQVUsQ0FBRSxJQUFJLENBRWhCLFVBQVUsQ0FBRSxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FDbkMsbUJBQW1CLENBQUUsTUFBTSxDQUMzQixRQUFRLENBQUUsS0FBSyxDQUNmLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFNBQVMsQ0FBRSxHQUFHLENBQ2QsUUFBUSxDQUFFLElBQUksQ0FDZCxPQUFPLENBQUUsSUFBSSxDQUNiLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFBO0dBQzdFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUNoQyxPQUFPLENBQUUsRUFBRSxBQUNaLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUG9wb3Zlci5zdmVsdGUiXX0= */");
}

// (8:0) {#if visible}
function create_if_block$6(ctx) {
	let div;
	let div_class_value;
	let events_action;
	let div_intro;
	let div_outro;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "" + (null_to_empty('popover ' + /*className*/ ctx[1]) + " svelte-5k22n0"));
			attr_dev(div, "style", /*style*/ ctx[2]);
			attr_dev(div, "tabindex", "-1");
			add_location(div, file$7, 8, 1, 161);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[20](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "introstart", /*introstart_handler*/ ctx[18], false, false, false),
					listen_dev(div, "introend", /*introend_handler*/ ctx[19], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[4].call(null, div))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], !current ? -1 : dirty, null, null);
				}
			}

			if (!current || dirty & /*className*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty('popover ' + /*className*/ ctx[1]) + " svelte-5k22n0"))) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 4) {
				attr_dev(div, "style", /*style*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, /*popoverIn*/ ctx[5], {});
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, /*popoverOut*/ ctx[6], {});
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[20](null);
			if (detaching && div_outro) div_outro.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(8:0) {#if visible}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block = /*visible*/ ctx[0] && create_if_block$6(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window_1$1, "scroll", /*onScroll*/ ctx[8], { passive: true }, false, false),
					listen_dev(window_1$1, "resize", /*onResize*/ ctx[9], { passive: true }, false, false),
					listen_dev(window_1$1, "keydown", /*onKeydown*/ ctx[10], true, false, false),
					listen_dev(window_1$1, "click", /*onclickOutside*/ ctx[11], true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*visible*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const MARGIN = 8;

function iend({ target }) {
	target.style.transformOrigin = null;
	target.style.transitionDuration = null;
	target.style.transitionProperty = null;
	target.style.transform = null;

	// grab focus
	target.focus();
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Popover', slots, ['default']);
	const events = getEventsAction(current_component);
	const dispatch = createEventDispatcher();
	let { class: className = '' } = $$props;
	let { style = null } = $$props;
	let { origin = 'top left' } = $$props;
	let { dx = 0 } = $$props;
	let { dy = 0 } = $$props;
	let { visible = false } = $$props;
	let { duration = 300 } = $$props;
	let popoverEl;
	let triggerEl;

	function popoverIn(target) {
		target.style.transformOrigin = origin;
		target.style.transform = 'scale(0.6)';
		target.style.opacity = '0';
		return { duration: +duration };
	}

	function popoverOut(target) {
		target.style.transformOrigin = origin;
		target.style.transitionDuration = duration + 'ms';
		target.style.transitionProperty = 'opacity, transform';
		target.style.transform = 'scale(0.6)';
		target.style.opacity = '0';
		return { duration: +duration };
	}

	async function istart({ target }) {
		setTimeout(
			() => {
				target.style.transitionDuration = duration + 'ms';
				target.style.transitionProperty = 'opacity, transform';
				target.style.transform = 'scale(1)';
				target.style.opacity = null;
			},
			0
		);
	}

	function getLeftPosition(width, rc) {
		let left = 0;
		$$invalidate(12, dx = +dx);
		const maxLeft = window.innerWidth - MARGIN - width;
		const minLeft = MARGIN;

		left = origin.indexOf('left') >= 0
		? left = rc.left + dx
		: left = rc.left + rc.width - width - dx;

		left = Math.min(maxLeft, left);
		left = Math.max(minLeft, left);
		return left;
	}

	function getTopPosition(height, rc) {
		let top = 0;
		$$invalidate(13, dy = +dy);
		const maxTop = window.innerHeight - MARGIN - height;
		const minTop = MARGIN;

		top = origin.indexOf('top') >= 0
		? top = rc.top + dy
		: top = rc.top + rc.height - height - dy;

		top = Math.min(maxTop, top);
		top = Math.max(minTop, top);
		return top;
	}

	function setStyle() {
		if (!visible || !popoverEl || !triggerEl) return;
		const rect = triggerEl.getBoundingClientRect();

		if (rect.top < -rect.height || rect.top > window.innerHeight) {
			close('overflow');
			return;
		}

		$$invalidate(3, popoverEl.style.top = getTopPosition(popoverEl.offsetHeight, rect) + 'px', popoverEl);
		$$invalidate(3, popoverEl.style.left = getLeftPosition(popoverEl.offsetWidth, rect) + 'px', popoverEl);
	}

	beforeUpdate(() => {
		triggerEl = popoverEl ? popoverEl.parentElement : null;
		triggerEl && setStyle();
	});

	function close(params) {
		dispatch('close', params);
		$$invalidate(0, visible = false);
	}

	// window event handlers
	function onScroll() {
		setStyle();
	}

	function onResize() {
		setStyle();
	}

	function onKeydown(e) {
		if (visible) {
			if (e.keyCode === 27) {
				e.stopPropagation();
				close('escape');
			}

			trapTabKey(e, popoverEl);
		}
	}

	function onclickOutside(e) {
		if (visible && triggerEl && !triggerEl.contains(e.target)) {
			e.stopPropagation();
			close('clickOutside');
		}
	}

	const writable_props = ['class', 'style', 'origin', 'dx', 'dy', 'visible', 'duration'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Popover> was created with unknown prop '${key}'`);
	});

	const introstart_handler = e => istart(e);
	const introend_handler = e => iend(e);

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			popoverEl = $$value;
			$$invalidate(3, popoverEl);
		});
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(1, className = $$props.class);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('origin' in $$props) $$invalidate(14, origin = $$props.origin);
		if ('dx' in $$props) $$invalidate(12, dx = $$props.dx);
		if ('dy' in $$props) $$invalidate(13, dy = $$props.dy);
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('duration' in $$props) $$invalidate(15, duration = $$props.duration);
		if ('$$scope' in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		current_component,
		beforeUpdate,
		createEventDispatcher,
		getEventsAction,
		trapTabKey,
		events,
		dispatch,
		className,
		style,
		origin,
		dx,
		dy,
		visible,
		duration,
		popoverEl,
		triggerEl,
		MARGIN,
		popoverIn,
		popoverOut,
		istart,
		iend,
		getLeftPosition,
		getTopPosition,
		setStyle,
		close,
		onScroll,
		onResize,
		onKeydown,
		onclickOutside
	});

	$$self.$inject_state = $$props => {
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('origin' in $$props) $$invalidate(14, origin = $$props.origin);
		if ('dx' in $$props) $$invalidate(12, dx = $$props.dx);
		if ('dy' in $$props) $$invalidate(13, dy = $$props.dy);
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('duration' in $$props) $$invalidate(15, duration = $$props.duration);
		if ('popoverEl' in $$props) $$invalidate(3, popoverEl = $$props.popoverEl);
		if ('triggerEl' in $$props) triggerEl = $$props.triggerEl;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		visible,
		className,
		style,
		popoverEl,
		events,
		popoverIn,
		popoverOut,
		istart,
		onScroll,
		onResize,
		onKeydown,
		onclickOutside,
		dx,
		dy,
		origin,
		duration,
		$$scope,
		slots,
		introstart_handler,
		introend_handler,
		div_binding
	];
}

class Popover extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				class: 1,
				style: 2,
				origin: 14,
				dx: 12,
				dy: 13,
				visible: 0,
				duration: 15
			},
			add_css$7
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Popover",
			options,
			id: create_fragment$7.name
		});
	}

	get class() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get origin() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set origin(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dx() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dx(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dy() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dy(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get visible() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visible(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get duration() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set duration(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function enableScroll(enable) {
	let isHidden = document.body.style.overflow === 'hidden';

	if (enable && isHidden) {
		let top = Math.abs(parseInt(document.body.style.top));

		document.body.style.cssText = null;
		document.body.removeAttribute('style');
		window.scrollTo(0, top);
	} else if (!enable && !isHidden) {
		document.body.style.top =
			'-' +
			Math.max(
				document.body.scrollTop,
				(document.documentElement && document.documentElement.scrollTop) || 0
			) +
			'px';
		document.body.style.position = 'fixed';
		document.body.style.width = '100%';
		document.body.style.overflow = 'hidden';
	}
}

/* node_modules\svelte-mui\src\Dialog.svelte generated by Svelte v3.40.2 */
const file$8 = "node_modules\\svelte-mui\\src\\Dialog.svelte";

function add_css$8(target) {
	append_styles(target, "svelte-1pkw9hl", ".overlay.svelte-1pkw9hl{background-color:rgba(0, 0, 0, 0.5);cursor:pointer;position:fixed;left:0;top:0;right:0;bottom:0;z-index:30;display:flex;justify-content:center;align-items:center}.dialog.svelte-1pkw9hl{position:relative;font-size:1rem;background:#eee;background:var(--bg-panel, #eee);border-radius:4px;cursor:auto;box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14),\n\t\t\t0 9px 46px 8px rgba(0, 0, 0, 0.12);z-index:40;max-height:80%;overflow-x:hidden;overflow-y:auto}.dialog.svelte-1pkw9hl:focus{outline:none}.dialog.svelte-1pkw9hl::-moz-focus-inner{border:0}.dialog.svelte-1pkw9hl:-moz-focusring{outline:none}div.svelte-1pkw9hl .actions{min-height:48px;padding:8px;display:flex;align-items:center}div.svelte-1pkw9hl .center{justify-content:center}div.svelte-1pkw9hl .left{justify-content:flex-start}div.svelte-1pkw9hl .right{justify-content:flex-end}.title.svelte-1pkw9hl{padding:16px 16px 12px;font-size:24px;line-height:36px;background:rgba(0, 0, 0, 0.1);background:var(--divider, rgba(0, 0, 0, 0.1))}.content.svelte-1pkw9hl{margin:16px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGlhbG9nLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFzSUMsUUFBUSxlQUFDLENBQUEsQUFDUixnQkFBZ0IsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUNwQyxNQUFNLENBQUUsT0FBTyxDQUNmLFFBQVEsQ0FBRSxLQUFLLENBQ2YsSUFBSSxDQUFFLENBQUMsQ0FDUCxHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxPQUFPLENBQUUsRUFBRSxDQUVYLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsV0FBVyxDQUFFLE1BQU0sQUFDcEIsQ0FBQSxBQUVBLE9BQU8sZUFBQyxDQUFBLEFBQ1AsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsU0FBUyxDQUFFLElBQUksQ0FDZixVQUFVLENBQUUsSUFBSSxDQUVoQixVQUFVLENBQUUsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQ2pDLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7R0FDbkYsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ25DLE9BQU8sQ0FBRSxFQUFFLENBQ1gsVUFBVSxDQUFFLEdBQUcsQ0FDZixVQUFVLENBQUUsTUFBTSxDQUNsQixVQUFVLENBQUUsSUFBSSxBQUNqQixDQUFBLEFBQ0Esc0JBQU8sTUFBTSxBQUFDLENBQUEsQUFDYixPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDQSxzQkFBTyxrQkFBa0IsQUFBQyxDQUFBLEFBQ3pCLE1BQU0sQ0FBRSxDQUFDLEFBQ1YsQ0FBQSxBQUNBLHNCQUFPLGVBQWUsQUFBQyxDQUFBLEFBQ3RCLE9BQU8sQ0FBRSxJQUFJLEFBQ2QsQ0FBQSxBQUNBLGtCQUFHLENBQUMsQUFBUSxRQUFRLEFBQUUsQ0FBQSxBQUNyQixVQUFVLENBQUUsSUFBSSxDQUNoQixPQUFPLENBQUUsR0FBRyxDQUNaLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQUFDcEIsQ0FBQSxBQUNBLGtCQUFHLENBQUMsQUFBUSxPQUFPLEFBQUUsQ0FBQSxBQUNwQixlQUFlLENBQUUsTUFBTSxBQUN4QixDQUFBLEFBQ0Esa0JBQUcsQ0FBQyxBQUFRLEtBQUssQUFBRSxDQUFBLEFBQ2xCLGVBQWUsQ0FBRSxVQUFVLEFBQzVCLENBQUEsQUFDQSxrQkFBRyxDQUFDLEFBQVEsTUFBTSxBQUFFLENBQUEsQUFDbkIsZUFBZSxDQUFFLFFBQVEsQUFDMUIsQ0FBQSxBQUVBLE1BQU0sZUFBQyxDQUFBLEFBQ04sT0FBTyxDQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUN2QixTQUFTLENBQUUsSUFBSSxDQUNmLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFVBQVUsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUU5QixVQUFVLENBQUUsSUFBSSxTQUFTLENBQUMsbUJBQW1CLENBQUMsQUFDL0MsQ0FBQSxBQUNBLFFBQVEsZUFBQyxDQUFBLEFBQ1IsTUFBTSxDQUFFLElBQUksQUFDYixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkRpYWxvZy5zdmVsdGUiXX0= */");
}

const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_actions_slot_changes = dirty => ({});
const get_actions_slot_context = ctx => ({});
const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});

// (3:0) {#if visible}
function create_if_block$7(ctx) {
	let div3;
	let div2;
	let div0;
	let t0;
	let div1;
	let t1;
	let t2;
	let div2_class_value;
	let div2_style_value;
	let events_action;
	let div2_intro;
	let div3_transition;
	let current;
	let mounted;
	let dispose;
	const title_slot_template = /*#slots*/ ctx[16].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[15], get_title_slot_context);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const actions_slot_template = /*#slots*/ ctx[16].actions;
	const actions_slot = create_slot(actions_slot_template, ctx, /*$$scope*/ ctx[15], get_actions_slot_context);
	const footer_slot_template = /*#slots*/ ctx[16].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[15], get_footer_slot_context);

	let div2_levels = [
		{
			class: div2_class_value = 'dialog ' + /*className*/ ctx[1]
		},
		{
			style: div2_style_value = `width: ${/*width*/ ctx[3]}px;${/*style*/ ctx[2]}`
		},
		{ tabindex: "-1" },
		/*attrs*/ ctx[6]
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			if (title_slot) title_slot.c();
			t0 = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (actions_slot) actions_slot.c();
			t2 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div0, "class", "title svelte-1pkw9hl");
			add_location(div0, file$8, 26, 3, 604);
			attr_dev(div1, "class", "content svelte-1pkw9hl");
			add_location(div1, file$8, 30, 3, 664);
			set_attributes(div2, div2_data);
			toggle_class(div2, "svelte-1pkw9hl", true);
			add_location(div2, file$8, 13, 2, 284);
			attr_dev(div3, "class", "overlay svelte-1pkw9hl");
			add_location(div3, file$8, 3, 1, 78);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div0);

			if (title_slot) {
				title_slot.m(div0, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div2, t1);

			if (actions_slot) {
				actions_slot.m(div2, null);
			}

			append_dev(div2, t2);

			if (footer_slot) {
				footer_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[18](div2);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(events_action = /*events*/ ctx[8].call(null, div2)),
					listen_dev(div2, "mousedown", stop_propagation(/*mousedown_handler*/ ctx[17]), false, false, true),
					listen_dev(div2, "mouseenter", /*mouseenter_handler*/ ctx[19], false, false, false),
					listen_dev(div3, "mousedown", /*mousedown_handler_1*/ ctx[20], false, false, false),
					listen_dev(div3, "mouseup", /*mouseup_handler*/ ctx[21], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (title_slot) {
				if (title_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[15], !current ? -1 : dirty, get_title_slot_changes, get_title_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], !current ? -1 : dirty, null, null);
				}
			}

			if (actions_slot) {
				if (actions_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot(actions_slot, actions_slot_template, ctx, /*$$scope*/ ctx[15], !current ? -1 : dirty, get_actions_slot_changes, get_actions_slot_context);
				}
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[15], !current ? -1 : dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*className*/ 2 && div2_class_value !== (div2_class_value = 'dialog ' + /*className*/ ctx[1])) && { class: div2_class_value },
				(!current || dirty & /*width, style*/ 12 && div2_style_value !== (div2_style_value = `width: ${/*width*/ ctx[3]}px;${/*style*/ ctx[2]}`)) && { style: div2_style_value },
				{ tabindex: "-1" },
				dirty & /*attrs*/ 64 && /*attrs*/ ctx[6]
			]));

			toggle_class(div2, "svelte-1pkw9hl", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			transition_in(default_slot, local);
			transition_in(actions_slot, local);
			transition_in(footer_slot, local);

			if (!div2_intro) {
				add_render_callback(() => {
					div2_intro = create_in_transition(div2, scale, {
						duration: 180,
						opacity: 0.5,
						start: 0.75,
						easing: quintOut
					});

					div2_intro.start();
				});
			}

			add_render_callback(() => {
				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, { duration: 180 }, true);
				div3_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			transition_out(default_slot, local);
			transition_out(actions_slot, local);
			transition_out(footer_slot, local);
			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, { duration: 180 }, false);
			div3_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (title_slot) title_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (actions_slot) actions_slot.d(detaching);
			if (footer_slot) footer_slot.d(detaching);
			/*div2_binding*/ ctx[18](null);
			if (detaching && div3_transition) div3_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(3:0) {#if visible}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block = /*visible*/ ctx[0] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "keydown", /*onKey*/ ctx[10], false, false, false),
					listen_dev(window, "popstate", /*onPopstate*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*visible*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Dialog', slots, ['title','default','actions','footer']);
	const dispatch = createEventDispatcher();
	const events = getEventsAction(current_component);
	let { class: className = '' } = $$props;
	let { style = '' } = $$props;
	let { visible = false } = $$props;
	let { width = 320 } = $$props;
	let { modal = false } = $$props;
	let { closeByEsc = true } = $$props;
	let { beforeClose = () => true } = $$props;
	let mouseDownOutside = false;
	let attrs = {};
	let mounted = false;
	let elm;

	onMount(async () => {
		await tick();
		$$invalidate(14, mounted = true);
	});

	onDestroy(() => {
		mounted && enableScroll(true);
	});

	function close(params) {
		if (beforeClose()) {
			dispatch('close', params);
			$$invalidate(0, visible = false);
		}
	}

	async function onVisible() {
		if (!elm) return;
		await tick();
		let inputs = elm.querySelectorAll('input:not([type="hidden"])');
		let length = inputs.length;
		let i = 0;

		for (; i < length; i++) {
			if (inputs[i].getAttribute('autofocus')) {
				break;
			}
		}

		i < length
		? inputs[i].focus()
		: length > 0 ? inputs[0].focus() : elm.focus();

		dispatch('open');
	}

	function onKey(e) {
		const esc = 'Escape';

		if (e.keyCode === 27 || e.key === esc || e.code === esc) {
			closeByEsc && close(esc);
		}

		if (visible) {
			trapTabKey(e, elm);
		}
	}

	function onPopstate() {
		$$invalidate(0, visible = false);
	}

	function mousedown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elm = $$value;
			$$invalidate(7, elm);
		});
	}

	const mouseenter_handler = () => {
		$$invalidate(5, mouseDownOutside = false);
	};

	const mousedown_handler_1 = () => {
		$$invalidate(5, mouseDownOutside = true);
	};

	const mouseup_handler = () => {
		mouseDownOutside && !modal && close('clickOutside');
	};

	$$self.$$set = $$new_props => {
		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ('style' in $$new_props) $$invalidate(2, style = $$new_props.style);
		if ('visible' in $$new_props) $$invalidate(0, visible = $$new_props.visible);
		if ('width' in $$new_props) $$invalidate(3, width = $$new_props.width);
		if ('modal' in $$new_props) $$invalidate(4, modal = $$new_props.modal);
		if ('closeByEsc' in $$new_props) $$invalidate(12, closeByEsc = $$new_props.closeByEsc);
		if ('beforeClose' in $$new_props) $$invalidate(13, beforeClose = $$new_props.beforeClose);
		if ('$$scope' in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		tick,
		onMount,
		onDestroy,
		createEventDispatcher,
		fade,
		scale,
		quintOut,
		current_component,
		getEventsAction,
		trapTabKey,
		enableScroll,
		dispatch,
		events,
		className,
		style,
		visible,
		width,
		modal,
		closeByEsc,
		beforeClose,
		mouseDownOutside,
		attrs,
		mounted,
		elm,
		close,
		onVisible,
		onKey,
		onPopstate
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
		if ('style' in $$props) $$invalidate(2, style = $$new_props.style);
		if ('visible' in $$props) $$invalidate(0, visible = $$new_props.visible);
		if ('width' in $$props) $$invalidate(3, width = $$new_props.width);
		if ('modal' in $$props) $$invalidate(4, modal = $$new_props.modal);
		if ('closeByEsc' in $$props) $$invalidate(12, closeByEsc = $$new_props.closeByEsc);
		if ('beforeClose' in $$props) $$invalidate(13, beforeClose = $$new_props.beforeClose);
		if ('mouseDownOutside' in $$props) $$invalidate(5, mouseDownOutside = $$new_props.mouseDownOutside);
		if ('attrs' in $$props) $$invalidate(6, attrs = $$new_props.attrs);
		if ('mounted' in $$props) $$invalidate(14, mounted = $$new_props.mounted);
		if ('elm' in $$props) $$invalidate(7, elm = $$new_props.elm);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 {
			/* eslint-disable no-unused-vars */
			const { style, visible, width, modal, closeByEsc, beforeClose, ...other } = $$props;

			$$invalidate(6, attrs = other);
		}

		if ($$self.$$.dirty & /*visible, mounted*/ 16385) {
			 if (visible) {
				mounted && enableScroll(false);
				onVisible();
			} else {
				$$invalidate(5, mouseDownOutside = false);
				mounted && enableScroll(true);
			}
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		visible,
		className,
		style,
		width,
		modal,
		mouseDownOutside,
		attrs,
		elm,
		events,
		close,
		onKey,
		onPopstate,
		closeByEsc,
		beforeClose,
		mounted,
		$$scope,
		slots,
		mousedown_handler,
		div2_binding,
		mouseenter_handler,
		mousedown_handler_1,
		mouseup_handler
	];
}

class Dialog extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				class: 1,
				style: 2,
				visible: 0,
				width: 3,
				modal: 4,
				closeByEsc: 12,
				beforeClose: 13
			},
			add_css$8
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dialog",
			options,
			id: create_fragment$8.name
		});
	}

	get class() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get visible() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visible(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get modal() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set modal(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByEsc() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByEsc(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get beforeClose() {
		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set beforeClose(value) {
		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Menu.svelte generated by Svelte v3.40.2 */

const { console: console_1$1 } = globals;
const file$9 = "node_modules\\svelte-mui\\src\\Menu.svelte";

function add_css$9(target) {
	append_styles(target, "svelte-1vc5q8h", "@supports (-webkit-overflow-scrolling: touch){html{cursor:pointer}}.menu.svelte-1vc5q8h{position:relative;display:inline-block;vertical-align:middle}ul.svelte-1vc5q8h{margin:0;padding:8px 0;width:100%;position:relative;overflow-x:hidden;overflow-y:visible}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcURDLFVBQVUsQ0FBQyw0QkFBNEIsS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUVyQyxJQUFJLEFBQUUsQ0FBQSxBQUNiLE1BQU0sQ0FBRSxPQUFPLEFBQ2hCLENBQUEsQUFDRCxDQUFBLEFBQ0EsS0FBSyxlQUFDLENBQUEsQUFDTCxRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsWUFBWSxDQUNyQixjQUFjLENBQUUsTUFBTSxBQUN2QixDQUFBLEFBQ0EsRUFBRSxlQUFDLENBQUEsQUFDRixNQUFNLENBQUUsQ0FBQyxDQUNULE9BQU8sQ0FBRSxHQUFHLENBQUMsQ0FBQyxDQUNkLEtBQUssQ0FBRSxJQUFJLENBQ1gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNZW51LnN2ZWx0ZSJdfQ== */");
}

const get_activator_slot_changes = dirty => ({});
const get_activator_slot_context = ctx => ({});

// (2:24)    
function fallback_block$1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			add_location(span, file$9, 2, 2, 104);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(2:24)    ",
		ctx
	});

	return block;
}

// (6:1) <Popover class={className} {style} {origin} {dx} {dy} bind:visible on:click={onPopoverClick}>
function create_default_slot(ctx) {
	let ul;
	let ul_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	const block = {
		c: function create() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr_dev(ul, "style", ul_style_value = `min-width: ${/*width*/ ctx[5]}px`);
			attr_dev(ul, "class", "svelte-1vc5q8h");
			add_location(ul, file$9, 6, 2, 220);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], !current ? -1 : dirty, null, null);
				}
			}

			if (!current || dirty & /*width*/ 32 && ul_style_value !== (ul_style_value = `min-width: ${/*width*/ ctx[5]}px`)) {
				attr_dev(ul, "style", ul_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(6:1) <Popover class={className} {style} {origin} {dx} {dy} bind:visible on:click={onPopoverClick}>",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let div;
	let t;
	let popover;
	let updating_visible;
	let events_action;
	let current;
	let mounted;
	let dispose;
	const activator_slot_template = /*#slots*/ ctx[11].activator;
	const activator_slot = create_slot(activator_slot_template, ctx, /*$$scope*/ ctx[14], get_activator_slot_context);
	const activator_slot_or_fallback = activator_slot || fallback_block$1(ctx);

	function popover_visible_binding(value) {
		/*popover_visible_binding*/ ctx[12](value);
	}

	let popover_props = {
		class: /*className*/ ctx[0],
		style: /*style*/ ctx[1],
		origin: /*origin*/ ctx[4],
		dx: /*dx*/ ctx[2],
		dy: /*dy*/ ctx[3],
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*visible*/ ctx[6] !== void 0) {
		popover_props.visible = /*visible*/ ctx[6];
	}

	popover = new Popover({ props: popover_props, $$inline: true });
	binding_callbacks.push(() => bind(popover, 'visible', popover_visible_binding));
	popover.$on("click", /*onPopoverClick*/ ctx[10]);

	const block = {
		c: function create() {
			div = element("div");
			if (activator_slot_or_fallback) activator_slot_or_fallback.c();
			t = space();
			create_component(popover.$$.fragment);
			attr_dev(div, "class", "menu svelte-1vc5q8h");
			add_location(div, file$9, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (activator_slot_or_fallback) {
				activator_slot_or_fallback.m(div, null);
			}

			append_dev(div, t);
			mount_component(popover, div, null);
			/*div_binding*/ ctx[13](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "click", /*onActivatorClick*/ ctx[9], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[8].call(null, div))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (activator_slot) {
				if (activator_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot(activator_slot, activator_slot_template, ctx, /*$$scope*/ ctx[14], !current ? -1 : dirty, get_activator_slot_changes, get_activator_slot_context);
				}
			}

			const popover_changes = {};
			if (dirty & /*className*/ 1) popover_changes.class = /*className*/ ctx[0];
			if (dirty & /*style*/ 2) popover_changes.style = /*style*/ ctx[1];
			if (dirty & /*origin*/ 16) popover_changes.origin = /*origin*/ ctx[4];
			if (dirty & /*dx*/ 4) popover_changes.dx = /*dx*/ ctx[2];
			if (dirty & /*dy*/ 8) popover_changes.dy = /*dy*/ ctx[3];

			if (dirty & /*$$scope, width*/ 16416) {
				popover_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty & /*visible*/ 64) {
				updating_visible = true;
				popover_changes.visible = /*visible*/ ctx[6];
				add_flush_callback(() => updating_visible = false);
			}

			popover.$set(popover_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(activator_slot_or_fallback, local);
			transition_in(popover.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(activator_slot_or_fallback, local);
			transition_out(popover.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (activator_slot_or_fallback) activator_slot_or_fallback.d(detaching);
			destroy_component(popover);
			/*div_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Menu', slots, ['activator','default']);
	const events = getEventsAction(current_component);
	let { class: className = '' } = $$props;
	let { style = null } = $$props;
	let { dx = 0 } = $$props;
	let { dy = 0 } = $$props;
	let { origin = 'top left' } = $$props; // 'bottom left', 'bottom right', 'top left', 'top right'
	let { width = 2 * 56 } = $$props;
	let visible = false;
	let menuEl;

	function onActivatorClick(e) {
		try {
			let triggerEl = menuEl.childNodes[0];

			if (triggerEl.contains(e.target)) {
				$$invalidate(6, visible = !visible);
			} else if (e.target === menuEl) {
				$$invalidate(6, visible = false);
			}
		} catch(err) {
			console.error(err);
		}
	}

	function onPopoverClick(e) {
		if (e.target.classList.contains('menu-item')) {
			$$invalidate(6, visible = false);
		}
	}

	const writable_props = ['class', 'style', 'dx', 'dy', 'origin', 'width'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Menu> was created with unknown prop '${key}'`);
	});

	function popover_visible_binding(value) {
		visible = value;
		$$invalidate(6, visible);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			menuEl = $$value;
			$$invalidate(7, menuEl);
		});
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, className = $$props.class);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('dx' in $$props) $$invalidate(2, dx = $$props.dx);
		if ('dy' in $$props) $$invalidate(3, dy = $$props.dy);
		if ('origin' in $$props) $$invalidate(4, origin = $$props.origin);
		if ('width' in $$props) $$invalidate(5, width = $$props.width);
		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		current_component,
		getEventsAction,
		Popover,
		events,
		className,
		style,
		dx,
		dy,
		origin,
		width,
		visible,
		menuEl,
		onActivatorClick,
		onPopoverClick
	});

	$$self.$inject_state = $$props => {
		if ('className' in $$props) $$invalidate(0, className = $$props.className);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('dx' in $$props) $$invalidate(2, dx = $$props.dx);
		if ('dy' in $$props) $$invalidate(3, dy = $$props.dy);
		if ('origin' in $$props) $$invalidate(4, origin = $$props.origin);
		if ('width' in $$props) $$invalidate(5, width = $$props.width);
		if ('visible' in $$props) $$invalidate(6, visible = $$props.visible);
		if ('menuEl' in $$props) $$invalidate(7, menuEl = $$props.menuEl);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		className,
		style,
		dx,
		dy,
		origin,
		width,
		visible,
		menuEl,
		events,
		onActivatorClick,
		onPopoverClick,
		slots,
		popover_visible_binding,
		div_binding,
		$$scope
	];
}

class Menu extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				class: 0,
				style: 1,
				dx: 2,
				dy: 3,
				origin: 4,
				width: 5
			},
			add_css$9
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu",
			options,
			id: create_fragment$9.name
		});
	}

	get class() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dx() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dx(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dy() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dy(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get origin() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set origin(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Menuitem.svelte generated by Svelte v3.40.2 */
const file$a = "node_modules\\svelte-mui\\src\\Menuitem.svelte";

function add_css$a(target) {
	append_styles(target, "svelte-mmrniu", "li.svelte-mmrniu{display:block}a.svelte-mmrniu,a.svelte-mmrniu:hover{text-decoration:none}.menu-item.svelte-mmrniu{position:relative;color:inherit;cursor:pointer;height:44px;user-select:none;display:flex;align-items:center;padding:0 16px;white-space:nowrap}.menu-item.svelte-mmrniu:focus{outline:none}.menu-item.svelte-mmrniu::-moz-focus-inner{border:0}.menu-item.svelte-mmrniu:-moz-focusring{outline:none}.menu-item.svelte-mmrniu:before{background-color:currentColor;color:inherit;bottom:0;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media(hover: hover){.menu-item.svelte-mmrniu:hover:not([disabled]):not(.disabled):before{opacity:0.15}.focus-visible.menu-item.svelte-mmrniu:focus:not([disabled]):not(.disabled):before{opacity:0.3}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudWl0ZW0uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1GQyxFQUFFLGNBQUMsQ0FBQSxBQUNGLE9BQU8sQ0FBRSxLQUFLLEFBQ2YsQ0FBQSxBQUNBLGVBQUMsQ0FDRCxlQUFDLE1BQU0sQUFBQyxDQUFBLEFBQ1AsZUFBZSxDQUFFLElBQUksQUFDdEIsQ0FBQSxBQUNBLFVBQVUsY0FBQyxDQUFBLEFBQ1YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLE9BQU8sQ0FDZCxNQUFNLENBQUUsT0FBTyxDQUNmLE1BQU0sQ0FBRSxJQUFJLENBQ1osV0FBVyxDQUFFLElBQUksQ0FFakIsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixPQUFPLENBQUUsQ0FBQyxDQUFDLElBQUksQ0FDZixXQUFXLENBQUUsTUFBTSxBQUNwQixDQUFBLEFBQ0Esd0JBQVUsTUFBTSxBQUFDLENBQUEsQUFDaEIsT0FBTyxDQUFFLElBQUksQUFDZCxDQUFBLEFBQ0Esd0JBQVUsa0JBQWtCLEFBQUMsQ0FBQSxBQUM1QixNQUFNLENBQUUsQ0FBQyxBQUNWLENBQUEsQUFDQSx3QkFBVSxlQUFlLEFBQUMsQ0FBQSxBQUN6QixPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDQSx3QkFBVSxPQUFPLEFBQUMsQ0FBQSxBQUNqQixnQkFBZ0IsQ0FBRSxZQUFZLENBQzlCLEtBQUssQ0FBRSxPQUFPLENBQ2QsTUFBTSxDQUFFLENBQUMsQ0FDVCxPQUFPLENBQUUsRUFBRSxDQUNYLElBQUksQ0FBRSxDQUFDLENBQ1AsT0FBTyxDQUFFLENBQUMsQ0FDVixjQUFjLENBQUUsSUFBSSxDQUNwQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsQ0FBQyxDQUNSLEdBQUcsQ0FBRSxDQUFDLENBQ04sVUFBVSxDQUFFLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUNqRCxDQUFBLEFBRUEsTUFBTSxBQUFDLFFBQVEsS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUNyQix3QkFBVSxNQUFNLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxPQUFPLEFBQUMsQ0FBQSxBQUN0RCxPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDUSxjQUFjLEFBQUMsd0JBQVUsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsT0FBTyxBQUFDLENBQUEsQUFDN0UsT0FBTyxDQUFFLEdBQUcsQUFDYixDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNZW51aXRlbS5zdmVsdGUiXX0= */");
}

// (18:0) {:else}
function create_else_block$1(ctx) {
	let li;
	let t;
	let li_class_value;
	let li_tabindex_value;
	let events_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let if_block = /*ripple*/ ctx[1] && create_if_block_2$1(ctx);

	let li_levels = [
		{
			class: li_class_value = 'menu-item ' + /*className*/ ctx[0]
		},
		{
			tabindex: li_tabindex_value = /*disabled*/ ctx[2] ? '-1' : '0'
		},
		/*attrs*/ ctx[4]
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(li, li_data);
			toggle_class(li, "svelte-mmrniu", true);
			add_location(li, file$a, 18, 1, 259);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			append_dev(li, t);
			if (if_block) if_block.m(li, null);
			/*li_binding*/ ctx[11](li);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(li, "keydown", /*onKeydown*/ ctx[7], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[6].call(null, li))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], !current ? -1 : dirty, null, null);
				}
			}

			if (/*ripple*/ ctx[1]) {
				if (if_block) {
					if (dirty & /*ripple*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(li, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty & /*className*/ 1 && li_class_value !== (li_class_value = 'menu-item ' + /*className*/ ctx[0])) && { class: li_class_value },
				(!current || dirty & /*disabled*/ 4 && li_tabindex_value !== (li_tabindex_value = /*disabled*/ ctx[2] ? '-1' : '0')) && { tabindex: li_tabindex_value },
				dirty & /*attrs*/ 16 && /*attrs*/ ctx[4]
			]));

			toggle_class(li, "svelte-mmrniu", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*li_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(18:0) {:else}",
		ctx
	});

	return block;
}

// (1:0) {#if url}
function create_if_block$8(ctx) {
	let li;
	let a;
	let t;
	let a_class_value;
	let a_tabindex_value;
	let events_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let if_block = /*ripple*/ ctx[1] && create_if_block_1$1(ctx);

	let a_levels = [
		{
			class: a_class_value = 'menu-item ' + /*className*/ ctx[0]
		},
		{ href: /*url*/ ctx[3] },
		{
			tabindex: a_tabindex_value = /*disabled*/ ctx[2] ? '-1' : '0'
		},
		/*attrs*/ ctx[4]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(a, a_data);
			toggle_class(a, "svelte-mmrniu", true);
			add_location(a, file$a, 2, 2, 18);
			attr_dev(li, "class", "svelte-mmrniu");
			add_location(li, file$a, 1, 1, 11);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_dev(a, t);
			if (if_block) if_block.m(a, null);
			/*a_binding*/ ctx[10](a);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(a, "keydown", /*onKeydown*/ ctx[7], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[6].call(null, a))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], !current ? -1 : dirty, null, null);
				}
			}

			if (/*ripple*/ ctx[1]) {
				if (if_block) {
					if (dirty & /*ripple*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*className*/ 1 && a_class_value !== (a_class_value = 'menu-item ' + /*className*/ ctx[0])) && { class: a_class_value },
				(!current || dirty & /*url*/ 8) && { href: /*url*/ ctx[3] },
				(!current || dirty & /*disabled*/ 4 && a_tabindex_value !== (a_tabindex_value = /*disabled*/ ctx[2] ? '-1' : '0')) && { tabindex: a_tabindex_value },
				dirty & /*attrs*/ 16 && /*attrs*/ ctx[4]
			]));

			toggle_class(a, "svelte-mmrniu", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*a_binding*/ ctx[10](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(1:0) {#if url}",
		ctx
	});

	return block;
}

// (28:2) {#if ripple}
function create_if_block_2$1(ctx) {
	let ripple_1;
	let current;
	ripple_1 = new Ripple({ $$inline: true });

	const block = {
		c: function create() {
			create_component(ripple_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(ripple_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(ripple_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(ripple_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(ripple_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(28:2) {#if ripple}",
		ctx
	});

	return block;
}

// (13:3) {#if ripple}
function create_if_block_1$1(ctx) {
	let ripple_1;
	let current;
	ripple_1 = new Ripple({ $$inline: true });

	const block = {
		c: function create() {
			create_component(ripple_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(ripple_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(ripple_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(ripple_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(ripple_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(13:3) {#if ripple}",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$8, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*url*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Menuitem', slots, ['default']);
	const events = getEventsAction(current_component);
	let { class: className = '' } = $$props;
	let { ripple = true } = $$props;
	let disabled = false;
	let url = null;
	let attrs = {};
	let elm;

	function onKeydown(e) {
		// click simulate
		if (e.keyCode === 13 || e.keyCode === 32) {
			e.stopPropagation();
			e.preventDefault();
			const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
			elm.dispatchEvent(clickEvent);
			elm.blur();
		}
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elm = $$value;
			$$invalidate(5, elm);
		});
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elm = $$value;
			$$invalidate(5, elm);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ('ripple' in $$new_props) $$invalidate(1, ripple = $$new_props.ripple);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		current_component,
		getEventsAction,
		Ripple,
		events,
		className,
		ripple,
		disabled,
		url,
		attrs,
		elm,
		onKeydown
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
		if ('ripple' in $$props) $$invalidate(1, ripple = $$new_props.ripple);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
		if ('url' in $$props) $$invalidate(3, url = $$new_props.url);
		if ('attrs' in $$props) $$invalidate(4, attrs = $$new_props.attrs);
		if ('elm' in $$props) $$invalidate(5, elm = $$new_props.elm);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 {
			/* eslint-disable no-unused-vars */
			const { href, ripple, ...other } = $$props;

			delete other.class;

			if (other.disabled === false) {
				delete other.disabled;
			}

			$$invalidate(2, disabled = !!other.disabled);
			$$invalidate(3, url = href && !disabled ? href : null);
			$$invalidate(4, attrs = other);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		className,
		ripple,
		disabled,
		url,
		attrs,
		elm,
		events,
		onKeydown,
		$$scope,
		slots,
		a_binding,
		li_binding
	];
}

class Menuitem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { class: 0, ripple: 1 }, add_css$a);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menuitem",
			options,
			id: create_fragment$a.name
		});
	}

	get class() {
		throw new Error("<Menuitem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Menuitem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Menuitem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Menuitem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Sidepanel.svelte generated by Svelte v3.40.2 */

const { window: window_1$2 } = globals;
const file$b = "node_modules\\svelte-mui\\src\\Sidepanel.svelte";

function add_css$b(target) {
	append_styles(target, "svelte-1o2jp7l", ".side-panel.svelte-1o2jp7l{background:#fbfbfb;background:var(--bg-color, #fbfbfb);position:fixed;visibility:hidden;width:256px;top:0;height:100%;box-shadow:0 0 10px rgba(0, 0, 0, 0.2);z-index:40;overflow-x:hidden;overflow-y:auto;transform-style:preserve-3d;will-change:transform, visibility;transition-duration:0.2s;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-property:transform, visibility}.side-panel.svelte-1o2jp7l:focus{outline:none}.side-panel.svelte-1o2jp7l::-moz-focus-inner{border:0}.side-panel.svelte-1o2jp7l:-moz-focusring{outline:none}.left.svelte-1o2jp7l{left:0;transform:translateX(-256px)}.right.svelte-1o2jp7l{left:auto;right:0;transform:translateX(256px)}.visible.svelte-1o2jp7l{visibility:visible;transform:translateX(0)}.overlay.svelte-1o2jp7l{background-color:rgba(0, 0, 0, 0.5);cursor:pointer;position:fixed;left:0;top:0;right:0;bottom:0;z-index:30}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lkZXBhbmVsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4SEMsV0FBVyxlQUFDLENBQUEsQUFDWCxVQUFVLENBQUUsT0FBTyxDQUVuQixVQUFVLENBQUUsSUFBSSxVQUFVLENBQUMsUUFBUSxDQUFDLENBQ3BDLFFBQVEsQ0FBRSxLQUFLLENBQ2YsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsS0FBSyxDQUFFLEtBQUssQ0FDWixHQUFHLENBQUUsQ0FBQyxDQUNOLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3ZDLE9BQU8sQ0FBRSxFQUFFLENBQ1gsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsZUFBZSxDQUFFLFdBQVcsQ0FDNUIsV0FBVyxDQUFFLFNBQVMsQ0FBQyxDQUFDLFVBQVUsQ0FDbEMsbUJBQW1CLENBQUUsSUFBSSxDQUN6QiwwQkFBMEIsQ0FBRSxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUN4RCxtQkFBbUIsQ0FBRSxTQUFTLENBQUMsQ0FBQyxVQUFVLEFBQzNDLENBQUEsQUFDQSwwQkFBVyxNQUFNLEFBQUMsQ0FBQSxBQUNqQixPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDQSwwQkFBVyxrQkFBa0IsQUFBQyxDQUFBLEFBQzdCLE1BQU0sQ0FBRSxDQUFDLEFBQ1YsQ0FBQSxBQUNBLDBCQUFXLGVBQWUsQUFBQyxDQUFBLEFBQzFCLE9BQU8sQ0FBRSxJQUFJLEFBQ2QsQ0FBQSxBQUNBLEtBQUssZUFBQyxDQUFBLEFBQ0wsSUFBSSxDQUFFLENBQUMsQ0FDUCxTQUFTLENBQUUsV0FBVyxNQUFNLENBQUMsQUFDOUIsQ0FBQSxBQUNBLE1BQU0sZUFBQyxDQUFBLEFBQ04sSUFBSSxDQUFFLElBQUksQ0FDVixLQUFLLENBQUUsQ0FBQyxDQUNSLFNBQVMsQ0FBRSxXQUFXLEtBQUssQ0FBQyxBQUM3QixDQUFBLEFBQ0EsUUFBUSxlQUFDLENBQUEsQUFDUixVQUFVLENBQUUsT0FBTyxDQUNuQixTQUFTLENBQUUsV0FBVyxDQUFDLENBQUMsQUFDekIsQ0FBQSxBQUVBLFFBQVEsZUFBQyxDQUFBLEFBQ1IsZ0JBQWdCLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDcEMsTUFBTSxDQUFFLE9BQU8sQ0FDZixRQUFRLENBQUUsS0FBSyxDQUNmLElBQUksQ0FBRSxDQUFDLENBQ1AsR0FBRyxDQUFFLENBQUMsQ0FDTixLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLENBQ1QsT0FBTyxDQUFFLEVBQUUsQUFDWixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNpZGVwYW5lbC5zdmVsdGUiXX0= */");
}

// (4:0) {#if visible}
function create_if_block$9(ctx) {
	let div;
	let div_transition;
	let current;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "overlay svelte-1o2jp7l");
			add_location(div, file$b, 4, 1, 127);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*hide*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 300 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 300 }, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(4:0) {#if visible}",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let t0;
	let t1;
	let aside;
	let events_action;
	let current;
	let mounted;
	let dispose;
	let if_block = /*visible*/ ctx[0] && create_if_block$9(ctx);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			aside = element("aside");
			if (default_slot) default_slot.c();
			attr_dev(aside, "class", "side-panel svelte-1o2jp7l");
			attr_dev(aside, "tabindex", "-1");
			toggle_class(aside, "left", !/*right*/ ctx[1]);
			toggle_class(aside, "right", /*right*/ ctx[1]);
			toggle_class(aside, "visible", /*visible*/ ctx[0]);
			add_location(aside, file$b, 6, 0, 209);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, aside, anchor);

			if (default_slot) {
				default_slot.m(aside, null);
			}

			/*aside_binding*/ ctx[13](aside);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window_1$2, "keydown", /*onKeydown*/ ctx[8], false, false, false),
					listen_dev(document.body, "touchstart", /*onTouchStart*/ ctx[6], false, false, false),
					listen_dev(document.body, "touchend", /*onTouchEnd*/ ctx[7], false, false, false),
					listen_dev(aside, "transitionend", /*transitionEnd*/ ctx[5], false, false, false),
					action_destroyer(events_action = /*events*/ ctx[3].call(null, aside))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*visible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*visible*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? -1 : dirty, null, null);
				}
			}

			if (dirty & /*right*/ 2) {
				toggle_class(aside, "left", !/*right*/ ctx[1]);
			}

			if (dirty & /*right*/ 2) {
				toggle_class(aside, "right", /*right*/ ctx[1]);
			}

			if (dirty & /*visible*/ 1) {
				toggle_class(aside, "visible", /*visible*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(aside);
			if (default_slot) default_slot.d(detaching);
			/*aside_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

let oneVisible = false;
const swipeArea = 20;
const swipeMin = 50;

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sidepanel', slots, ['default']);
	const events = getEventsAction(current_component);
	let { right = false } = $$props;
	let { visible = false } = $$props;
	let { disableScroll = false } = $$props;
	let touchStart = { x: null, y: null };
	let mounted = false;
	let elm;

	onMount(async () => {
		await tick();
		$$invalidate(10, mounted = true);
	});

	function hide() {
		$$invalidate(0, visible = false);

		setTimeout(
			() => {
				oneVisible = false;
			},
			20
		);
	}

	function show() {
		$$invalidate(0, visible = true);
	}

	function transitionEnd(e) {
		if (visible && e.propertyName === 'visibility') {
			elm.focus();
		}
	}

	function onTouchStart(e) {
		touchStart.x = e.changedTouches[0].clientX;
		touchStart.y = e.changedTouches[0].clientY;
	}

	function onTouchEnd(e) {
		const dx = e.changedTouches[0].clientX - touchStart.x;
		const dy = e.changedTouches[0].clientY - touchStart.y;
		const absDx = Math.abs(dx);

		if (absDx > swipeMin) {
			const absDy = Math.abs(dy);

			if (absDy < swipeMin << 1) {
				if (visible) {
					if (dx > 0 && right || dx < 0 && !right) {
						hide();
					}
				} else {
					if (oneVisible) {
						return;
					}

					if (dx > 0 && touchStart.x <= swipeArea) {
						if (!right) {
							show();
						}
					} else if (touchStart.x >= window.innerWidth - swipeArea) {
						if (right) {
							show();
						}
					}
				}
			}
		}
	}

	function onKeydown(e) {
		const esc = 'Escape';

		if (!visible) {
			return;
		}

		if (e.keyCode === 27 || e.key === esc || e.code === esc) {
			hide();
		}

		if (visible) {
			trapTabKey(e, elm);
		}
	}

	const writable_props = ['right', 'visible', 'disableScroll'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidepanel> was created with unknown prop '${key}'`);
	});

	function aside_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			elm = $$value;
			$$invalidate(2, elm);
		});
	}

	$$self.$$set = $$props => {
		if ('right' in $$props) $$invalidate(1, right = $$props.right);
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('disableScroll' in $$props) $$invalidate(9, disableScroll = $$props.disableScroll);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		oneVisible,
		tick,
		onMount,
		fade,
		current_component,
		getEventsAction,
		trapTabKey,
		enableScroll,
		events,
		right,
		visible,
		disableScroll,
		swipeArea,
		swipeMin,
		touchStart,
		mounted,
		elm,
		hide,
		show,
		transitionEnd,
		onTouchStart,
		onTouchEnd,
		onKeydown
	});

	$$self.$inject_state = $$props => {
		if ('right' in $$props) $$invalidate(1, right = $$props.right);
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('disableScroll' in $$props) $$invalidate(9, disableScroll = $$props.disableScroll);
		if ('touchStart' in $$props) touchStart = $$props.touchStart;
		if ('mounted' in $$props) $$invalidate(10, mounted = $$props.mounted);
		if ('elm' in $$props) $$invalidate(2, elm = $$props.elm);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*visible, mounted, disableScroll*/ 1537) {
			 if (visible) {
				oneVisible = true;
				mounted && disableScroll && enableScroll(false);
			} else {
				mounted && enableScroll(true);
				hide();
			}
		}
	};

	return [
		visible,
		right,
		elm,
		events,
		hide,
		transitionEnd,
		onTouchStart,
		onTouchEnd,
		onKeydown,
		disableScroll,
		mounted,
		$$scope,
		slots,
		aside_binding
	];
}

class Sidepanel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { right: 1, visible: 0, disableScroll: 9 }, add_css$b);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sidepanel",
			options,
			id: create_fragment$b.name
		});
	}

	get right() {
		throw new Error("<Sidepanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Sidepanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get visible() {
		throw new Error("<Sidepanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visible(value) {
		throw new Error("<Sidepanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disableScroll() {
		throw new Error("<Sidepanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disableScroll(value) {
		throw new Error("<Sidepanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-mui\src\Snackbar.svelte generated by Svelte v3.40.2 */
const file$c = "node_modules\\svelte-mui\\src\\Snackbar.svelte";

function add_css$c(target) {
	append_styles(target, "svelte-1ftyf0y", ".snackbar.svelte-1ftyf0y{display:flex;align-items:center;border-radius:0 0 2px 2px;padding:6px 16px;min-height:48px;min-width:288px;max-width:568px;position:fixed;flex-wrap:nowrap;z-index:50;box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 18px 0 rgba(0, 0, 0, 0.12)}.action.svelte-1ftyf0y{margin-right:-16px;padding:0 8px;margin-left:auto}.message.svelte-1ftyf0y{padding:8px 0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.top.svelte-1ftyf0y{top:0;left:50%;transform:translate3d(-50%, 0, 0)}.bottom.svelte-1ftyf0y{bottom:0;left:50%;border-radius:2px 2px 0 0;transform:translate3d(-50%, 0, 0)}@media only screen and (max-width: 600px){.snackbar.svelte-1ftyf0y{max-width:100%;left:0;right:0;transform:translate3d(0, 0, 0)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU25hY2tiYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJEQyxTQUFTLGVBQUMsQ0FBQSxBQUNULE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsYUFBYSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FDMUIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQ2pCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFFBQVEsQ0FBRSxLQUFLLENBQ2YsU0FBUyxDQUFFLE1BQU0sQ0FDakIsT0FBTyxDQUFFLEVBQUUsQ0FDWCxVQUFVLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtHQUM5RSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQUFDbEMsQ0FBQSxBQUVBLE9BQU8sZUFBQyxDQUFBLEFBQ1AsWUFBWSxDQUFFLEtBQUssQ0FDbkIsT0FBTyxDQUFFLENBQUMsQ0FBQyxHQUFHLENBQ2QsV0FBVyxDQUFFLElBQUksQUFDbEIsQ0FBQSxBQUVBLFFBQVEsZUFBQyxDQUFBLEFBQ1IsT0FBTyxDQUFFLEdBQUcsQ0FBQyxDQUFDLENBQ2QsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsYUFBYSxDQUFFLFFBQVEsQUFDeEIsQ0FBQSxBQUVBLElBQUksZUFBQyxDQUFBLEFBQ0osR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsR0FBRyxDQUNULFNBQVMsQ0FBRSxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUNuQyxDQUFBLEFBQ0EsT0FBTyxlQUFDLENBQUEsQUFDUCxNQUFNLENBQUUsQ0FBQyxDQUNULElBQUksQ0FBRSxHQUFHLENBQ1QsYUFBYSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDMUIsU0FBUyxDQUFFLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEFBQ25DLENBQUEsQUFFQSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUN6QyxTQUFTLGVBQUMsQ0FBQSxBQUNULFNBQVMsQ0FBRSxJQUFJLENBQ2YsSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsQ0FBQyxDQUNSLFNBQVMsQ0FBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUNoQyxDQUFBLEFBQ0QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTbmFja2Jhci5zdmVsdGUiXX0= */");
}

const get_action_slot_changes = dirty => ({});
const get_action_slot_context = ctx => ({});

// (1:0) {#if visible}
function create_if_block$a(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let div2_class_value;
	let div2_style_value;
	let events_action;
	let div2_intro;
	let div2_outro;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	const action_slot_template = /*#slots*/ ctx[9].action;
	const action_slot = create_slot(action_slot_template, ctx, /*$$scope*/ ctx[11], get_action_slot_context);
	const action_slot_or_fallback = action_slot || fallback_block$2(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t = space();
			div1 = element("div");
			if (action_slot_or_fallback) action_slot_or_fallback.c();
			attr_dev(div0, "class", "message svelte-1ftyf0y");
			add_location(div0, file$c, 10, 2, 267);
			attr_dev(div1, "class", "action svelte-1ftyf0y");
			add_location(div1, file$c, 13, 2, 312);
			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty('snackbar ' + /*className*/ ctx[1]) + " svelte-1ftyf0y"));
			attr_dev(div2, "style", div2_style_value = `color: ${/*color*/ ctx[5]};background: ${/*bg*/ ctx[4]};${/*style*/ ctx[2]}`);
			toggle_class(div2, "top", !/*bottom*/ ctx[3]);
			toggle_class(div2, "bottom", /*bottom*/ ctx[3]);
			add_location(div2, file$c, 1, 1, 15);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div2, t);
			append_dev(div2, div1);

			if (action_slot_or_fallback) {
				action_slot_or_fallback.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[6].call(null, div2));
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], !current ? -1 : dirty, null, null);
				}
			}

			if (action_slot) {
				if (action_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot(action_slot, action_slot_template, ctx, /*$$scope*/ ctx[11], !current ? -1 : dirty, get_action_slot_changes, get_action_slot_context);
				}
			} else {
				if (action_slot_or_fallback && action_slot_or_fallback.p && (!current || dirty & /*visible*/ 1)) {
					action_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*className*/ 2 && div2_class_value !== (div2_class_value = "" + (null_to_empty('snackbar ' + /*className*/ ctx[1]) + " svelte-1ftyf0y"))) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*color, bg, style*/ 52 && div2_style_value !== (div2_style_value = `color: ${/*color*/ ctx[5]};background: ${/*bg*/ ctx[4]};${/*style*/ ctx[2]}`)) {
				attr_dev(div2, "style", div2_style_value);
			}

			if (dirty & /*className, bottom*/ 10) {
				toggle_class(div2, "top", !/*bottom*/ ctx[3]);
			}

			if (dirty & /*className, bottom*/ 10) {
				toggle_class(div2, "bottom", /*bottom*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(action_slot_or_fallback, local);

			add_render_callback(() => {
				if (div2_outro) div2_outro.end(1);

				if (!div2_intro) div2_intro = create_in_transition(div2, fly, {
					y: /*bottom*/ ctx[3] ? 48 : -48,
					duration: 350
				});

				div2_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(action_slot_or_fallback, local);
			if (div2_intro) div2_intro.invalidate();

			div2_outro = create_out_transition(div2, fly, {
				y: /*bottom*/ ctx[3] ? 48 : -48,
				duration: 350
			});

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (default_slot) default_slot.d(detaching);
			if (action_slot_or_fallback) action_slot_or_fallback.d(detaching);
			if (detaching && div2_outro) div2_outro.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(1:0) {#if visible}",
		ctx
	});

	return block;
}

// (16:4) <Button color="#f50057" on:click={() => (visible = false)}>
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(16:4) <Button color=\\\"#f50057\\\" on:click={() => (visible = false)}>",
		ctx
	});

	return block;
}

// (15:23)      
function fallback_block$2(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				color: "#f50057",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[10]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$2.name,
		type: "fallback",
		source: "(15:23)      ",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*visible*/ ctx[0] && create_if_block$a(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*visible*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*visible*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Snackbar', slots, ['default','action']);
	const events = getEventsAction(current_component);
	let { visible = false } = $$props;
	let { class: className = '' } = $$props;
	let { style = '' } = $$props;
	let { bottom = false } = $$props;
	let { bg = 'rgba(0,0,0,.87)' } = $$props;
	let { color = '#fff' } = $$props;
	let { timeout = 5 } = $$props;
	let timerId;

	onDestroy(() => {
		clearTimeout(timerId);
		$$invalidate(8, timerId = undefined);
	});

	const writable_props = ['visible', 'class', 'style', 'bottom', 'bg', 'color', 'timeout'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Snackbar> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, visible = false);

	$$self.$$set = $$props => {
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('class' in $$props) $$invalidate(1, className = $$props.class);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('bottom' in $$props) $$invalidate(3, bottom = $$props.bottom);
		if ('bg' in $$props) $$invalidate(4, bg = $$props.bg);
		if ('color' in $$props) $$invalidate(5, color = $$props.color);
		if ('timeout' in $$props) $$invalidate(7, timeout = $$props.timeout);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onDestroy,
		fly,
		current_component,
		getEventsAction,
		Button,
		events,
		visible,
		className,
		style,
		bottom,
		bg,
		color,
		timeout,
		timerId
	});

	$$self.$inject_state = $$props => {
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('bottom' in $$props) $$invalidate(3, bottom = $$props.bottom);
		if ('bg' in $$props) $$invalidate(4, bg = $$props.bg);
		if ('color' in $$props) $$invalidate(5, color = $$props.color);
		if ('timeout' in $$props) $$invalidate(7, timeout = $$props.timeout);
		if ('timerId' in $$props) $$invalidate(8, timerId = $$props.timerId);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*visible, timerId, timeout*/ 385) {
			 if (visible === true) {
				clearTimeout(timerId);
				$$invalidate(8, timerId = undefined);

				if (timeout > 0) {
					$$invalidate(8, timerId = setTimeout(
						() => {
							$$invalidate(0, visible = false);
							$$invalidate(8, timerId = undefined);
						},
						timeout * 1000
					));
				}
			}
		}
	};

	return [
		visible,
		className,
		style,
		bottom,
		bg,
		color,
		events,
		timeout,
		timerId,
		slots,
		click_handler,
		$$scope
	];
}

class Snackbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$c,
			create_fragment$c,
			safe_not_equal,
			{
				visible: 0,
				class: 1,
				style: 2,
				bottom: 3,
				bg: 4,
				color: 5,
				timeout: 7
			},
			add_css$c
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Snackbar",
			options,
			id: create_fragment$c.name
		});
	}

	get visible() {
		throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visible(value) {
		throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottom() {
		throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottom(value) {
		throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bg() {
		throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bg(value) {
		throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get timeout() {
		throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set timeout(value) {
		throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const l$1 = {
    add_new_task : "Add new task",
    edit_task : "Edit task",
    you_cant_add_task_from_chapter : "You can't add task from chapter",
    status_update_success_txt : "Status has been updated successfully.",
    deleting_multiple_contents_will_also_delete_the_nested_contents: "If this item has nested sub-items, then deleting this will also delete sub-items.",
    viewer_error_msg_js: "You are participating as a viewer, You don't have permission to save.",
    add_new_part: "Add New Part",
    cut_js: "Cut",
    paste_js: "Paste",
    eng: "English",
    deleted: "Deleted",
    donot_select_multiseat: "Please do not select multi seat vouchers.",
    select_used_voucher: "Please select used voucher only.",
    edit_js: "Edit ",
    delete_js: "Delete ",
    add_existing_content: "Add Existing Content",
    duplicate_row: "Duplicate Row",
    author_lesson: "Author as Lesson",
    draft_js: "Draft",
    publish_js: "Publish",
    edit_mode: "Lesson Preview",
    import_from_epub: "Import a Lesson Below",
    select_new_content_type: "Select new content type",
    change_type_js: "Change type",
    objective_js: "Objective",
    fact_js: "Fact",
    embeded_content_js: "Embeded content",
    glossary_js: "Glossary",
    customize_saved: "Saved Successfully.",
    unable_save: "Error. Unable to save",
    add_txt : "Add",
    actions_txt : "Actions",
    bug_update : "Bug updated successfully.",
    org_url_exist : "Org Ucertify Url already exists!!",
    logo_validate : "logo must be less than 1MB.",
    logo_res : "logo size must be of maximum 300x100 pixel resolution.",
    image_validate : "Only jpeg, jpg, png, gif, bmp file types are supported.",
    country_update : "Country updated successfully.",
    country_not_updated : "Country not updated.",
    post_update : "Post updated successfully.",
    post_not_updated : "Post not updated.",
    user_deleted  : "The user has been deleted successfully! ",
    user_not_deleted  : "The user cannot be deleted.Please try after some time!",
    first_js_lang : "Js Testing",
    error_while_saving_please_try_again : "Error while saving, please try again",
    do_you_really_want_to_save : "Do you really want to Save?",
    off: "Off",
    lti_success: "Your score has been updated on your LMS.",
    lti_fail: "Score is not updated due to some technical issue.",
    select_an_option_txt : "Select an option",
    updated_please_reload : "Updated, please reload.",
    content_not_deleted_please_try_again : "Unable to delete the content. Please try again.",
    delete_content_with_child : "Item is deleted successfully with its child.",
    error_unable_to_delete : "Error. Unable to delete",
    no_changes_txt : "No changes.",
    content_has_been_added_successfully : "Content has been added successfully.",
    content_has_not_been_added_successfully : "Content has not been added successfully.",
    part_has_been_deleted_successfully : "Part has been deleted successfully.",
    content_has_been_moved_successfully : "Content has been moved successfully.",
    content_has_not_been_moved_successfully : "Content has not been moved successfully.",
    error_unable_to_move : "Error. Unable to move",
    content_level_has_been_changed_successfully : "Content level has been changed successfully.",
    content_level_has_not_been_changed_successfully : "Content level has not been changed successfully.",
    error_unable_to_changed_level : "Error. Unable to changed the level",
    taglist: "Tag List",
    formats: "Formats",
    inline: "Inline",
    bold: "Bold",
    bits: "bold",
    italic: "Italic",
    italics: "italic",
    underline: "Underline",
    underlines: "underline",
    strikethrough: "Strikethrough",
    strikethroughs: "strikethrough",
    superscript: "Superscript",
    superscripts: "superscript",
    subscript: "Subscript",
    subscripts: "subscript",
    small: "Small",
    smalls: "small",
    heading: "Heading",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    newspaper: "Newspaper Font",
    blocks: "Blocks",
    para: "Paragraph",
    div: "Div",
    block: "Blockquote",
    span: "Span",
    code: "Code",
    insnote: "Instructor Note",
    insans: "Instructor Answer",
    alignment: "Alignment",
    left: "Left",
    alignleft: "alignleft",
    center: "Center",
    aligncenter: "aligncenter",
    right: "Right",
    alignright: "alignright",
    justify: "Justify",
    alignjustify: "alignjustify",
    cases: "Cases",
    uppercase: "Uppercase",
    lowercase: "Lowercase",
    titlecase: "Titlecase",
    sentence_case: "Sentence Case",
    toggle_case: "Toggle Case",
    color: "Color",
    success: "Success",
    bsuccess: "b-success",
    warning: "Warning",
    bwarning: "b-warning",
    danger: "Danger",
    bdanger: "b-danger",
    white: "White",
    bwhite: "b-white",
    green: "Green",
    bgreen: "b-green",
    objref: "objref(italic)",
    borange: "b-orange",
    binfo: "b-info",
    bprimary: "b-primary",
    bgcolor: "Background color",
    lsuccess: "Label-Success",
    linfo: "Label-Info",
    lprimary: "Label-Primary",
    ldanger: "Label-Danger",
    lwarning: "Label-Warning",
    list: "List",
    withoutBullet: "Without Bullet",
    numlist: "Numbered list",
    alphlist: "Alphabetical list",
    romanlist: "Roman list",
    numalphlist: "Numeric alpha list",
    bullist: "Bullet list",
    blarlist: "Black arrow bullets",
    bluearlist: "Blue arrow bullets",
    blarbullet: "Blue arrow bullets with gray background",
    blcrcbbullet: "Blue circle bullets",
    bcbwbt: "Blue circle bullet with black text",
    redcrlist: "Red circle list",
    whcrclist: "White circle list",
    tickbull: "Tick Bullet",
    listtype1: "List type 1",
    listtype2: "List type 2",
    listtype3: "List type 3",
    listtype4: "List type 4",
    listtype5: "List type 5",
    listtype6: "List type 6",
    table: "Table",
    deftable: "Default Table",
    smplbortab: "Simple Bordered Table",
    unbortab: "Unbordered Table",
    borbacktab: "Bordered Background Table",
    hrowsbor: "Highlighted Rows Bordered",
    strptab: "Striped Table",
    tabhovdes: "Table Hover Design",
    mulstrp: "Multiple Stripes",
    separate: "Separate",
    grycolor: "Gray color column",
    blueshade: "Blue header with shading table",
    box: "Box",
    panelblue: "Panel Box Blue",
    panelgreen: "Panel Box Green",
    panelsky: "Panel Box Sky-blue",
    panelgrad: "Panel Box gradient",
    block_with_border: "Panel Box with Border",
    blockgrey: "Block in grey background",
    symbols: "Symbols",
    ucsyntax: "UC Syntax",
    indentation: "Indentation",
    clear_formatting: "Clear Formatting",
    wrap_text: "Wrap your text in block element to indent",
    outdent: "outdent",
    removeformat: "removeformat",
    align_content_message: "Wrap your text in block element to align content",
    blue_color:"Blue",
    orange_color:"Orange",
    red_color: "Red",
    golden_brown_color: "Golden Brown",
    black_color: "Black",
    green_color: "Green",
    cyan_color:  "Cyan",
    uc_syntax_format1: "White with number",
    uc_syntax_format2: "White without number",
    uc_syntax_format3: "Black with number",
    uc_syntax_format4: "Black without number",
    line_break1: "Single line Break",
    line_break2: "Double line Break",
    quotes: "Quotes(Sayings)",
    code_block1: "Syntax",
    code_block2: "Black with number",
    code_block3: "Black without number",
    code_block4: "White with number",
    code_block5: "White without number",
    timeline: "Timeline",
    slideshow :"Slideshow",
    panel_success: "Panel Success",
    panel_info: "Panel Info",
    panel_primary: "Panel Primary",
    panel_danger: "Panel Danger",
    panel_warning: "Panel Warning",
    acc_list1: "Accordion List 1",
    acc_list2: "Accordion List 2",
    acc_list3: "Accordion List 3",
    acc_list4: "Accordion List 4",
    inlineAlign: "icomoon-inline",
    headings: "icomoon-heading",
    block_ico: "icomoon-blocks",
    alginments: "icomoon-align",
    case: "icomoon-cases",
    colors: "icomoon-color",
    background: "icomoon-background-color",
    lists: "icomoon-list",
    tables: "icomoon-table",
    boxes: "icomoon-24-px-box",
    symbol: "icomoon-symbols",
    ucsyntaxes: "icomoon-uC-syntax",
    ucfeed: "icomoon-uC-feedback",
    dummyText: "Enter Your Text Here",
    authoring : "Authoring",
    change_view : "Change View",
    render_tag : "Render Tags",
    version_control : "Revision History",
    preview : "Preview",
    remediation : "Remediation",
    back : "Back",
    save_header : "Confirmation",
    save_process : "Please, be patient. We are saving your data...",
    save_confirmation : "Do you want to save this content?",
    cancel : "Cancel",
    done : "Done",
    save_new : "Save as new",
    save : "Save",
    save_success : "Data saved successfully",
    save_success_owner : "Content is successfully saved. Get it published by the Reviewer/Owner to make it visible in the course.",
    save_error : "It seems that the course is not loaded. Please load the course before you save.",
    setting : "Settings",
    add_response : "Add Response",
    add_editable : "Add Editable",
    case_sensetive : "Case Sensitive",
    ignore_spcl_char : "Ignore Special Character",
    multi : "Multiple Correct Answer",
    fill_header : "Fill in the blanks - type",
    fill_text_title : "Fill in the blanks (with text)",
    fill_dropdown_title : "Fill in the blanks (with drop downs)",
    fill_dragdrop_title : "Fill in the blanks (with drag & drop)",
    short_text : "Short Text",
    fill_multiline_title : "Fill in the blanks (with multiline)",
    fill_math_title : "Fill in the blanks (with mathematical equations)",
    math_eq         : 'Mathematical Equation',
    fill_text_placeholder : "Write correct answer here",
    fill_text_help1 : "1. To include multiple correct answers, type the answers and separate them with a comma (,).",
    fill_text_help2 : "2. Please do not include any space. Now, go back to the Settings and select Multiple Correct Answers from the drop-down.",
    fill_text_help3 : "3. Use #cm for comma (e.g., 5,000 as 5#cm000, function(a,b) as function(a#cmb)).",
    fill_math_help1 : "1. To make math equation initially, Click f(x) and then insert the equation.",
    fill_math_help2 : "2. To add user Response, place cursor before{*} and Click Add Response.",
    fill_math_help3 : "3. To edit the existing equation, Click Edit.",
    star_note : '* Note:',
    do_not_include_space : '2. Please do not include space.',
    //fill_text_help3 : "Now, go back to Settings and select Multi from the drop-down.",
    fill_dropdown_placeholder : "Write Option here",
    fill_dropdown_help1 : "1. To choose correct answer, select any one radio button from the given options.",
    fill_dropdown_help2 : "2. To choose the display answer, put ‘+’ sign before it. For eg: (+value).",
    fill_dropdown_help3 : "3. To give comma (,) between the text use #cm symbol.",
    drag_single : "Allow single dragging",
    fill_dragdrop_help1 : "1. By default, all answer option is correct.",
    fill_dragdrop_help2 : "2. To make an option incorrect, uncheck the corresponding checkbox.",
    fill_dragdrop_help3 : "3. To give comma (,) between the text use #cm symbol.",
    fill_dragdrop_help4 : "4. To give Vertical bar (|) use #pipe symbol.",
    default_answer : "Default Answer",
    rows : "Rows",
    cols : "Cols",
    fill_multiline_help1 : "By default, all the options provided are correct.",
    matchlist_heading1 : "List 1 heading",
    matchlist_heading2 : "List 2 heading",
    matchlist_normal : "Normal",
    matchlist_dnd : "Drag & Drop",
    shuffle : "Click here to Shuffle",
    add_item : "Add item",
    allow_sort : "Sequence", //"Allow User to Sort",
    in_sentence : "Sentence",
    in_paragraph : "Paragraph",
    go_back : "Go Back",
    goback_header : "Confirmation",
    goback_confirmation : "Do you really want to go to item list?",
    sceneChange_confirmation: "Your changes will be lost. Do you want to save this content ? ",
    show_preview : "Preview",
    xml : "XML",
    back_authoring : "Back to Authoring",
    title : "Title",
    stem : "Stem",
    content : "Content",
    error : "Error",
    playertag : "Player Tag",
    equationeditor : "Equation Editor",
    error_occured : "Something went wrong, Please try again.",
    click_preview : "Click To Preview",
    loading_module : "Loading Module",
    something_wrong : "Something went wrong, Please try again.",
    reload : "Reload",
    search_here : "Search here...",
    all_item : "All Items",
    max_error : "More than 6 options may cause this item to not render properly on a smartphone.",
    reset : "Reset",
    resetDB : "Reset DB",
    calculate_answer : "Calculating Answer",
    add : "Add",
    remove : "Remove",
    correct_answer : "Correct Answer",
    your_answer : "Your Answer",
    correct : "Correct",
    incorrect : "Incorrect",
    select_language : "Language",
    please_wait : "Please, be patient. We are working things up for you. ",
    sequence : "Sequence",
    multi_check : "Multi Check",
    default : "Default",
    heading_correct : "Heading for correct list item",
    heading_all : "Heading for all list item",
    open_doc : "uCertify Team has open this content for editing. Your changes might be lost.",
    getting_diff : "Please, be patient. We are calculating the differences for you.",
    getting_list : "Please, be patient. We are generating the list for you.",
    restore_currect : "Restore Current Version",
    submit : "Submit",
    getting_webpage : "Please, be patient. We are generating the Webpage list for you.",
    getting_docx : "Please, be patient. We are generating the Content in Docx Formatting for you.",
    getting_help : "Please, be patient. We are generating the help for you.",
    warning : "Warning!",
    row_limit : "You have reached the minimum number of rows you can delete.",
    col_limit : "You have reached the minimum number of columns you can delete.",
    del_confirmation : "Are you sure you want to delete it?",
    wrong_value_information : "Values of the row and column should always be multiples of ",
    min_row_col_value : "Insufficient value to make a table; there should be atleast four values.",
    provide_value_suggestion : "Insufficient value to make a table; please increase or decrease the value by 1.",
    totaloption : 'Total number of values available : ',
    max_row_col_error : "More than five rows and five columns may not render properly on a smartphone.",
    create_existing_variable : "Create Existing Variable",
    create_new_variable : "Create New variable",
    update_variable : "Update Variable",
    use_existing_variable : "Use existing variable",
    help : "Help",
    create_variable : "Create Variable",
    all_function_help : "* Do not give a variable name containing space.",
    randInt_function_help : "* Default value will be 1.",
    randint_randfloat_function_help1 : "* This function is used to find a random number between two given numbers.",
    randint_randfloat_function_help2 : "* Do not provide the non-integer value in the minimum and maximum fields.",
    randint_randfloat_function_help3 : "* Minimum value should always be less than the maximum value.",
    randobj_function_help1 : "* This function is used to find a random character or string separated by "+"\",\" (comma).",
    randobj_function_help2 : "* Provide the value like Java, React, Php, and C.",
    custom_function_help1 : "* This function is used to solve any expression.",
    custom_function_help2 : "* Some of the functions take a character/word as an argument so the argument must be passed between the # (hash) symbol.",
    custom_function_help3 : "* If you want to find Intersection, then the argument must be passed like this: math.setIntersect([#a#,#b#],[#a#,#b#,#c#]).",
    custom_function_help4 : "* If you want to find Differentiation, then the argument must be passed like this: math.derivative(#var1*obj1<sup>var2</sup>-var3*obj1+var4#,#obj1#).",
    edit_token: "Highlight correct token",
    edit_template: "Enter text",
    word: "Word",
    sentance: "Sentence",
    paragraph: "Paragraph",
    clear: "Clear",
    no_of_token: "Selected",
    token_highlight: "Token Highlight",
    direction: "Direction:",
    enableline : "Enable-line",
    language: "Language",
    add_testcase: "Add Testcase",
    is_graph : "Is Graph",
    ignore_error: "Ignore Error",
    ignore_formatting: "Ignore Formatting",
    ignore_reset_db: 'Ignore Reset DB',
    pre_tag: "Pre Tag",
    run: "Run",
    run_code: "Run Code",
    html_css_js: "HTML/ CSS/ JS",
    input: "Input",
    output: "Output",
    testcases: "Testcases",
    close: "Close",
    pre: "Pre",
    post: "Post",
    editor: "Editor",
    save_variable : "Save Variables",
    create_steps : "Create Steps",
    plain_text : "Plain text",
    interactive : "Interactive",
    no_validation : "No validation",
    sticky : "Sticky",
    "delete" : "Delete",
    confirm_delete_variable : "If this variable is used in steps it will be treated as text. Are you sure you want to delete it?",
    next : "Next",
    solve : "Solve",
    functions: "Functions",
    Allsymbols: "All Symbols",
    Basic: "Basic",
    xvariables: "x",
    sin: "sin",
    Misc: "Misc",
    Discrete: "Discrete",
    kg: "kg",
    lb: "lb",
    brackets: "Brackets",
    algo_xml: "Algo XML",
    val_variations: "Values variations",
    chem: "Chem",
    tools: "Tools",
    domain: "Domain",
    exam_objective: "Exam Objective",
    web_pages: "Web pages",
    docx_formatting: "Docx Formatting",
    analyze_ebook: "Analyze Ebook Item",
    inline: "Inline",
    bold: "Bold",
    italic: "Italic",
    underline: "Underline",
    strikethrough: "Strikethrough",
    superscript: "Superscript",
    subscript: "Subscript",
    small: "Small",
    subtype: "Tag SubType:",
    showangle: "Show Angle",
    alignment: "Alignment:",
    raw: "RAW",
    html: "HTML",
    css: "CSS",
    js: "JS",
    result: "Result",
    autograde: "Autograde",
    disable: "Disable/Hide",
    editable: "Editable",
    hidden: "Hidden",
    disabled: "Disabled",
    internalScript: "Internal Script",
    externalScript: "External Script",
    detail: "Detail",
    element_name: "Element Name",
    convert: "Convert",
    analyze_content: "Analyze Content",
    analyzing: "Analyzing",
    show_more: "Show more",
    show_less: "Show less",
    task:"Task",
    task_objective:"Task Objective",
    textsnippet:"Text Snippet",
    sectiondetail:"Section Details",
    tags:"Tags",
    item:"Item",
    itemType:"Item Type",
    type:"Type",
    comments:"Comments",
    cognitive_level:"Cognitive Level",
    refer_content:"Refer Content",
    create_equation:"Create Equation",
    help_video:"Help Video",
    diagnostic:"Diagnostic",
    keyboard_shortcut:"Keyboard Shortcut",
    delete_exist_element: "Are you sure you want to delete existing elements?",
    edit_dialog: "Edit Dialog",
    update: "Update",
    add_category: "Add Category",
    import_csv: "Import CSV",
    create_new_question: "Create New Question",
    max: "Max",
    min: "Min",
    step: "step",
    slider: "Slider",
    oops_msg: "Oops! Something went wrong please check your ParseXML Function.",
    minimum: "Minimum",
    maximum: "Maximum",
    step: "Step",
    ignore_grading: "Ignore grading",
    eval_ada1_msg: "1. Press 'CTRL+SHIFT+Enter key' to RUN the code",
    eval_ada2_msg: "2. Press 'CTRL+SHIFT+SPACE key' to goto Input/Output side",
    eval_ada_info: "ADA Information",
    annotationId: "Enter image annotation item ID here",
    annotationPlaceholder: "Enter image annotation title here",
    imageAnnotation: "An annotation player is used to add the image annotation in the middle of the e-book lessons.",
    select_lang: "Please select language",
    show_transcript: "Show transcript",
    audio_recorder: "Audio Recorder",
    starting_message: "Click on record to start recording",
    spoken_label: "What we heard",
    note_label: "Note: ",
    insensitive_message: "Matching is case insensitive.",
    recording_warning: "Recording will end automatically after 15 sec.",
    english_us: "English (United States)",
    english_in: "English (U.K.)",
    italiano: "Italian",
    suomi: "Finnish",
    svenska: "Swedish",
    confirm_label: "Confirm",
    modal_data: "It will override the previous recording. Do you want to continue?",
    no_label: "No",
    yes_label: "Yes",
    browser_support_msg: "Your browser does not support this feature. Please use latest version of chrome browser to use this feature.",
    recording_ended: "Recording ended.",
    no_data_msg: "No recorded data found.",
    matching_msg: "No matching data is found.",
    space_warning: "Do not use more than one space unnecessary.",
    separate_by_quote: "separate with &quot; , &quot",
    pre_code: "pre code",
    write_function_here: "Write your function here...",
    postcode: "post code",
    seperate_by_enter_key: "Separate input by 'enter' key",
    minus_1: "-1",
    case_insensitive: "Case Insensitive",
    partial_matching: "Partial Matching",
    partial_match: "Partial Match",
    special_char: "Special Char",
    input_seperated_comma: "Input seperated by ','",
    ignore_special_char: "Ignore Special Char",
    testcase: "TestCase",
    markPointColor: "Point Color",
    lightGreen: "Light Green",
    black: "Black",
    orange : "Orange",
    select_case_match: "Select case match",
    decimal_position: "please enter the decimal position between 1 to ",
    grid_one_to_ten: "Number Must be between 1 to 10",
    col_less_one : "Column Not allowed less then 1",
    type_one_to_seven: "Please type between 1 to 7",
    row_less_one: "Row Not allowed less then 1",
    type_one_to_ten: "Please type between 1 to 10",
    double_digit: "Double digit not accepted",
    less_one : "Less then 1 not accepted",
    number_from: "Insert number between 0 to ",
    another_option: "Select another option",
    layout_options: "Layout Options",
    row_count: "Row Count",
    col_count: "Column Count",
    empty_field: "Field value can not be empty",
    lock_author_cell: "To lock author shaded cells, it should be part of correct answer",
    delete_graph: 'Click on this button to delete the graph',
    delete_chart: 'Click on this button to delete the last point of the chart',
    ada_graph_msg: 'Press any key on this button to open modalbox to set the point for draw the graph without click on the graph board',
    ada_chart_msg: 'Press any key on this button to open modalbox to set the point for draw the chart without click on the chart board',
    add_chart_msg: 'Click on this button to add the point on the chart',
    edit_graph: 'Click on this button to open modalbox for change the graph view',
    edit_chart: 'Click on this button to open modalbox for change the chart view',
    validate_dialog: 'You have to put the image name',
    ada_message: "use control plus alt plus 1 to open the dialog for perform the task",
    token_message: "Please use ##pt for dot (.) and #cm for comma (,).",
    button_text: 'Shown on the button at the bottom of the intro screen.',
    level_text: 'Level',
    insert_note: 'Insert Note',
    load_more: 'Load More',
    placeholder_text: 'Enter the name of button',
    name_text: 'Name',
    note_placeholder: 'Insert text here',
    level_placeholder: 'Enter the label message',
    knowledge_check: 'This player tag is used to add questions in the middle of the ebook lessons.',
    enter_title: 'Enter the title',
    multi_item_id: 'Enter the comma-separated item id(s)',
    item_id: 'Item ID',
    graded: 'Graded Item(s)',
    coding: 'This player tag is used to test the web module’s XML and display its preview simultaneously in the ebook lessons.',
    simulation: 'This player tag is used to create menu-based questions in Word or Excel, in which only the tabs are working.',
    terminal: 'This player tag is used to add the Linux, DOS, or Java module questions in the middle of the ebook lessons.',
    lablink: 'This player tag is used to add live labs in the mid of ebook lessons which can then be clicked and opened in a new tab.',
    insight: 'This player tag is used to add the 3D chat questions in the middle of the ebook lessons.',
    playground: 'Coding Lab',
    simulation_txt: 'Simulation',
    terminal_txt: 'Terminal',
    livelab: 'Live Lab',
    lab3d: '3D Lab',
    java_txt: 'Java',
    linux_txt: 'Linux',
    dos_txt: 'DOS',
    default_val: 'Enter the default value. Example: dialog_name=options',
    enter_xml: 'Enter the XML',
    simulator_name: 'Simulator Name',
    simulator_place: 'Enter the simulator name. Example: msoffice-msword-2013',
    enter_item: 'Enter the item id',
    embed: 'Embed',
    new_tab: 'New Tab',
    overlay: 'Overlay',
    btn_name: 'Button Name',
    enter_btn_name: 'Enter the button name',
    correct_val: 'Enter the correct value. Example: dialog=fileoptionsdvanced',
    learn_mode: 'Learn Mode',
    audio_des: 'This player tag is used to add audios in the ebook lessons.',
    video_des: 'This player tag is used to add videos in the ebook lessons.',
    audio_txt: 'Audio',
    video_txt: 'Video',
    url_txt: 'URL',
    media_url: 'Enter the media url',
    transcript_id: 'Transcript ID',
    enter_id: 'Enter the transcript id',
    preview_img: 'Image Preview',
    preview_url: 'Enter the image preview url',
    security_info: 'This is required security configuration',
    security_txt: 'Security',
    security_place: "Enter the security data in json format {'token': '45674', 'wID': '89765'}",
    security_title: "Put the security data in json for example {'token': '45674', 'wID': '89765'}.",
    multiple_video: 'Multiple Videos',
    multiple_info: 'All media on this page will be grouped together in a single carousel.',
    add_interval: 'Add Interval',
    interval_txt: 'Interval',
    in_sec: '(In seconds)',
    action_txt: 'Action',
    caption_txt: 'Caption',
    one_num: '1',
    download_info: 'This player tag is used to attach pdf files, word documents, excel files, powerpoint presentations, or any kind of attachment in the ebook lessons.',
    pdf_info: 'This player tag is used to add the pdf files in the ebook lessons.',
    exhibit_info: 'This player tag is used to add an image or a table in a modal box in quizzes or questions.',
    weblink_info: 'This player tag is used to add the “Click to read” link, having an image in its background, in the middle of the ebook lessons, which redirects a user to the new link or web page.',
    download_txt: 'Download',
    exhibit_txt: 'Exhibit',
    pdf_txt: 'PDF',
    weblink_txt: 'Web Link',
    image_txt: 'Image',
    text: 'Text',
    select_img: 'Select an image',
    ms_access: 'MS Access',
    ms_excel: 'MS Excel',
    ms_word: 'MS Word',
    sas_txt: 'SAS',
    zip_txt: 'Zip',
    show_caption: 'Show Button Caption',
    img_show: 'When image will be shown',
    hide_caption: 'Hide Button Caption',
    img_hide: 'When image will be hide',
    btn_txt: 'Button',
    link_txt: 'Link',
    enter_url: 'Enter the url',
    enter_img_url: 'Enter the image url',
    enter_icon_url: 'Enter the image icon url',
    insert_img: 'Insert Image',
    img_alt: 'Image Alt',
    img_desc: "Enter the image's description in brief",
    img_height: 'Enter the image height. Example: 500px',
    frame_height: 'Enter the frame height. Example: 500px',
    frame_ht: 'Frame Height',
    imgage_ht: 'Image Height',
    img_width: 'Image Width',
    enter_img_width: 'Enter the image width. Example: 500px',
    enter_txt: 'Enter the text',
    border_txt: 'Bordered',
    player3d_des: 'A 3D Player tag is used to add images with their descriptions in a 3D structure in the middle of the e-book lessons.',
    snt_des: 'A UC Snt tag is used to add a statement notifying students that more than one option is correct for the given quiz or question.',
    snt_41: 'Each correct answer represents a complete solution. Choose all that apply.',
    snt_40: 'Each correct answer represents a part of the solution. Choose all that apply.',
    snt_39: 'Each correct answer represents a complete solution. Choose three.',
    snt_38: 'Each correct answer represents a part of the solution. Choose three.',
    snt_37: 'Each correct answer represents a complete solution. Choose two.',
    snt_36: 'Each correct answer represents a part of the solution. Choose two.',
    des_txt: 'Description',
    seq_des: 'A UC Seq tag is used to refer the correct and incorrect options in the single/multiple choice questions.',
    enter_seq_title: 'Enter the sequence letter',
    seq_lable: 'Sequence Letter: use a, b, c, d etc. as per the option',
    can_not_del: 'You can not Delete Default Node',
    unable_to_get: 'Unable to get data due to some error.',
    multi_err: 'Multiple item ids are not allowed.',
    invalid_id: 'Invalid Item id.',
    know_check_txt: 'Knowledge Check',
    lab_txt: 'Lab',
    media_txt: 'Media',
    obj3d_txt: '3D Object',
    instruction_txt: 'Instruction',
    opt_ref: 'Option Reference',
    edit_txt: 'Edit',
    list_content: 'List Contents',
    create_new_txt: 'Create New',
    search_item_txt: 'Search Item ID or text',
    no_record: 'No Record Found.',
    scorm_txt: 'Scorm',
    scorm_id: 'Scorm ID',
    scorm_place: 'Enter the scorm transcript id',
    mobile_url: 'Mobile URL',
    mobile_url_place: 'Enter the scorm URL for mobile devices',
    scorm_url: 'Enter the scorm URL',
    width_warning: 'The image width must be in between 100px to 1000px',
    height_warning: 'The image height must be in between 80px to 550px',
    valid_link: 'Please add a valid video link or Check the format for adding the transcript!',
    required_field: 'Please enter all the required fields!',
    vtt_unvalid: 'VTT format is Not valid!',
    vtt_added: 'Transcript ID is added!',
    load_course : 'Please load a course first!',
    asset_not_empty: 'URL can\'t be empty!',
    vtt_exists: 'Transcript is present for this video. ID added!',
    no_title: 'Do not show video title',
    normal_mode: 'Light Mode',
    dark_mode: 'Dark Mode',
    figure_caption_text: 'Figure caption',
    edit_marker_text: 'Edit Marker',
    markers_text: 'Markers',
    upload_media_text: 'Upload Media',
    image_url: 'Image Url',
    image_alt_type: 'Image Alt Text',
    are_you_sure_you_want_to_delete_marker: 'Are you sure you want to delete the marker?',
    add_image_text: 'Add image',
    upload_text: 'Upload',
    file_extension_text: 'File Extensions',
    number_of_files: 'Number of files',
    you_can_upload: '#You can upload upto 10 files only.',
    date_correct_answer_field_placeholder: 'Define The Date For Correct Answer',
    correct_answer_field_placeholder: 'Define The Value For Correct Answer',
    duration: 'Duration',
    vtt: 'VTT',
    enter_vtt: 'Enter VTT Here',
    add_vtt: 'ADD',
    add_transcript_msg: 'Add Transcript',
    edit_transcript_msg: 'Edit Transcript',
    edit_msg: 'Edit',
    parent_guid_found: 'You cannot make changes in a child item. Do you want to open the parent item for making changes?',
    del_row: 'Delete',
    update_child: 'Update Child Items',
    show_child: 'Show Child Item',
    show_all: 'Show all child items',
    generate_item: 'Generate Items',
    plz_sel: 'Please Select',
    csv_file: 'Import .csv file',
    show_all_label: 'Open',
    save_war_msg: 'The current item should be saved first before generating child items',
    generate_items: 'Generate child items',
    already_generated: 'Child items already generated',
    child_not_generated: 'Child items not generated yet',
    new_not_allowed: 'New .csv file cannot be added now, item already created',
    add_option: 'Add Option',
    add_child: 'Add row(s)',
    child_not_selected: 'Child items not selected yet',
    child_update: 'Changes have been made to the parent item. Do you want to update the child items?',
    deletion_not_allowed: 'Child items are created. Deletion is not allowed now',
    update_item: 'Update Item(s)',
    new_row_tooltip: 'New row(s) added. Update child items',
    interval_err: "Video interval can not be more than video duration",
    image_prev_msg: "Image preview cannot be added as video has intervals.",
    video_url_err: "Please add a valid video url",
    delete_warning: 'Do you really want to delete this form block?',
    add_elm: 'Add Elements',
    set_seq: 'Set Sequence',
    pass_elem: 'Password',
    num_elem: 'Number',
    time_elem: 'Time',
    textarea_elem: 'Long Message',
    text_elem: 'Short Message',
    file_elem: 'Upload Image',
    linear_elem: 'Linear Scale',
    select_elem: 'Drop Down',
    chk_elem: 'Checkbox',
    rad_elem: 'Radio',
    date_elem: 'Date',
    add_point: 'Add point',
    set_ans: 'Set Answer',
    ok_btn: 'OK',
    snap_to: 'SnapTo',
    yinterval_val: 'Y (enter multiple values)',
    xinterval_val: 'X (enter multiple values)',
    set_color: 'Set Color',
    primary_color: 'Primary',
    warning_color: 'Warning',
    danger_color: 'Danger',
    default_representation: 'Default representation of chart.',
    xaxis_title: 'X-axis Title',
    yaxis_title: 'Y-axis Title',
    chart_title: 'Chart Title',
    column_label: 'Column',
    line_label: 'Line',
    histogram_label: 'Histogram',
    height_label: 'Height [px]',
    width_label: 'Width [px]',
    chart_label: 'Chart',
    plot_graph: 'Plot Graph',
    xaxis_label: 'X-axis',
    yaxis_label: 'Y-axis',
    xaxis_interval: 'X-axis interval',
    yaxis_interval: 'Y-axis interval',
    width_label1: 'Width',
    height_label1: 'Height',
    axis_label: 'Axis',
    number_line_association: 'Numberline Association',
    numberline_plot: 'Numberline Plot',
    fill_warning: 'Please fill out this field',
    equation: 'Equation',
    both_xy: 'Both X & Y',
    only_x: 'X',
    only_y: 'Y',
    inequality_num: 'Inequality Number Line Equation:',
    equation_type: 'Equation Type',
    standard_form: 'Standard Form : y=m*x+c',
    circle_form: 'Standard Form : (x-x1)^2 + (y-y1)^2 = r^2',
    parabola_form: 'Vertex Form : y=a*(x-h)^2+k',
    sin_form: 'Standard Form : y=a*sin(b*x+c)+d',
    cos_form: 'Standard Form : y=a*cos(b*x+c)+d',
    polygon_type: 'Polygon Type',
    point_graph: 'Point Graph',
    line_graph: 'Line Graph',
    circle_graph: 'Circle Graph',
    ray_graph: 'Ray Graph',
    segment_graph: 'Segment Graph',
    vector_graph: 'Vector Graph',
    parabola_graph: 'Parabola Graph',
    sine_graph: 'Sine Graph',
    cos_graph: 'Cosine Graph',
    polygon_graph: 'Polygon Graph',
    association: 'Association',
    current_item: 'Current Item',
    used_in_items: 'Used In Items',
    file_uploaded: 'File uploaded successfully.',
    html5_not_supported: 'Browser does not support HTML5.',
    upload_valid_csv: 'Please upload a valid .csv file.',
    exact2_column_allowed: 'Exact 2 columns should be present in the .csv file. Upload denied.',
    blank_column_notallowed: 'Blank cell(s) found in the .csv file. Upload denied.',
    min_max_validation: 'Minimum 4 rows and maximum 500 rows are allowed in the .csv file. Upload denied.',
    check_network: 'Something went wrong. Please check your network connection and click the "Generate Items" button again.',
    min4_max500_allowed: 'Minimum 4 rows and maximum 500 rows are allowed for generate the child items.',
    child_items_generated: 'Child items generated successfully.',
    check_net_and_save: 'Something went wrong. Please check your network connection and save the current item.',
    min4_rows_allowed: 'Minimum number of rows should be 4.',
    child_updated: 'Child IDs updated successfully.',
    max500_rows_allowed: 'Maximum number of rows should be 500.',
    check_net_update_ids: 'Something went wrong. Please check your network connection and update the IDs again.',
    fill_required_field: 'Please fill all the required Field! ',
    image_width_range: 'Image width must be between 400px and 600px!',
    edit_image: 'Edit Image',
    image_url: 'Image URL',
    browse: 'Browse',
    image_alt: 'Image Alt',
    image_caption: 'Image Caption',
    image_width: 'Image Width',
    marker_color: 'Marker Color',
    text_align: 'Text Align',
    bottom: 'Bottom',
    on_click: 'On Click',
    mark_symbol: 'Mark Symbol',
    number_marker:'Number Marker',
    plus_marker:'Plus Marker',
    checkmark_marker:'Checkmark Marker',
    cross_marker:'Cross Marker',
    earth_marker:'Earth Marker',
    notification_marker:'Notification Marker',
    radio_marker:'Radio Marker',
    minus_marker:'Minus Marker',
    border: 'Border',
    copy: 'Copy',
    delete_points: 'Delete Points',
    delete_no_of_points: 'To delete the numbers or symbols from the list, delete their mark points.',
    change_image: "Changing Image or Image Width will reposition the markers (Not accurate).\n\n Do you want to reposition markers or reset the data?",
    reposition: 'Reposition',
    delete_confirmation: 'Deleting point will remove its content too! Do you want to delete?',
    copid_paste: ' copied, Click to Paste!',
    point: 'Point',
    deleted_text: ' Deleted!',
    image_err: 'Make Sure all the required fields are non-empty and Image width must be between 400px and 600px!',
    image_alt_text: 'Image Alternative Text ',
    reset_data: 'Do you really want to reset data?',
    delete_row: 'Delete Row',
    delete_column: 'Delete Column',
    min_val: 'Min Value',
    max_val: 'Max Value',
    current_val: 'Current Value',
    correct_val: 'Correct Answer',
    add_slider: 'Add Slider',
    canvas_options: 'Canvas Options',
    cell_width: 'Cell Width',
    multiple_of: 'Multiple of',
    cell_height: 'Cell Height',
    author_shaded: 'Author Shaded',
    lock_shaded_cells: 'Lock shaded cells',
    set_corr_ans: 'Set correct answer(s)',
    method: 'Method',
    set_corr_loc: 'Set Correct Location',
    set_corr_count: 'Set Correct Count',
    you_were_req_to_select: 'You were required to select',
    grid_mark_ans_correct: 'grids to mark the answer correct.',
    hindi_lang: 'Hindi',
    spanish_lang: 'Spanish',
    french_lang: 'French',
    german_lang: 'German',
    japanese_lang: 'Japanese',
    korean_lang: 'Korean',
    drag_drop_set_seq_msg: 'Drag and Drop to set sequence.',
    please_enter_reply_comment : 'Please enter the reply comment',
    exhibit_err: 'Exhibit player does not support this format',	
    embed_player: 'This player tag is used to embed a content.',
    icon_not_blank: 'Icons name should not be blank!',	
    check_net_update_ids: 'Something went wrong. Please check your network connection and update the IDs again.',
    heading_info: "Here, # is the parent (root) element of the tree and it will not be dragged, ## is the child of the parent element and it will also not be dragged, ### is the child of the parent's child element and it can be dragged and dropped.",	
    key_info: "Key|Option text|Icon (Put comma after each line) Where  option text is the label for option of contextmenu list and icon is icon for that label and key is numeric value that helps to create the list option.",	
    note_text: "*Note:",	
    icons_list: "Icons List",	
    hase_icon_3: "### icon",	
    hase_icon_2: "## icon",	
    hase_icon_1: "# icon",	
    no_icons: 'No icons found!',	
    search_icons: 'Search Icons',	
    loading_icons: 'Please wait, Loading Icons...',	
    select_icon: "You can get the icon name by clicking on the Icon list button!",
    light_blue: "Light Blue",
    dark_blue: "Dark Blue",
    peach: "Peach",
    green: "Green",
    purple: "Purple",
    table_width: "Table width",
    themes: "Themes",
    add_row: "Add row",
    add_column: 'Add column',
    upload_data: 'Upload Data',
    hour: 'Hour',
    day: 'Day',
    week: 'Week',
    month: 'Month',
    graph: 'Graph :',
    users: 'Users',
    course_code: 'Course Code',
    iot_graph: 'IOT Graphs',
    from: 'From',
    to: 'To',
    star: '*',
    apply: 'Apply',
    colon: ':',
    both_field_necessary: 'Both Date Field is necessary!',
    load_efficiency: 'Load Efficiency',
    avg_max_speed: 'Average load & max speed',
    recent_fuel: 'Recent Fuel Reading',
    truck_list: 'Truck List',
    show_graph: 'Show Graph',
    get_truck_list: 'Get Truck List',
    no_data_found : 'No data Found!',
    total_users: 'Total Users',
    time_interval : 'Time Interval',
    total_unique_users: 'Total Unique Users',
    total_unique_users_per_day: 'Total Unique Users Per Day',
    load_efficiency_for_truck: 'Load efficiency for Truck id',
    max_speed: 'Max Speed',
    avg_load : 'Average Load',
    fuel_reading: 'Fuel Reading',
    truck_id : 'Truck ID',
    comment_choiceMatrix : 'Use #cm for comma.',
    // dndAuthString.js
    draggable: 'Draggable',
    placeholder: 'Place Holder',
    input_box: 'Input Box',
    checkbox_input: 'Check Box Input',
    multiline_text_box: 'Multiline Text Box',
    radio_inout: 'Radio input',
    select: 'Select',
    select_dropdown: 'Select Dropdown',
    new_menu: 'New Menu',
    clickable: 'Clickable',
    new_label: 'New Label',
    hotspot : 'Hotspot',
    new_steps: 'New Step',
    insert_script: 'Insert Script',
    select_list: 'Select List',
    label: 'Label',
    area_matrix: 'Area Matrix',
    new_pills: 'New Pills',
    base: 'Base',
    choice_matrix: 'Choice Matrix',
    delete_txt: 'Do you want to delete it?',
    select_style: '-- Select Style --',
    heading_arial: 'Heading Arial',
    heading_georgia: 'Heading Georgia',
    heading_cambria: 'Heading Cambria',
    heading_calibri: 'Heading Calibri',
    heading_verdana: 'Heading Verdana',
    heading_roman: 'Heading Times New Roman',
    content_arial: 'Content Arial',
    content_georgia: 'Content Georgia',
    content_cambria: 'Content Camabria',
    content_calibri: 'Content Calibri',
    content_verdana: 'Content Verdana',
    content_roman: 'Content Times New Roman',
    select_class: '-- Select Class --',
    sql_terminal: 'SQL Terminal',
    width_of_draggable: 'Width of Draggable',
    height_of_drggable: 'Height of Draggable',
    top_of_draggable: 'Top of Draggable',
    top: 'Top',
    left: 'Left',
    left_of_drggable: 'Left of Draggable',
    title_of_drggable: 'Title of draggable',
    name_of_draggable: 'Name of draggable',
    border_color: 'Border Color',
    none: 'None',
    black: 'Black',
    gray: 'Gray',
    grp_name: 'Group Name',
    background_image: 'Background Image',
    bg_of_draggble: 'Background image of draggable',
    multiple_drag: 'Multiple Drag',
    invisible: 'Invisible',
    css_style: 'CSS Style',
    css_style_of_txt: 'CSS style of Textbox',
    detail_of_drag: 'Detail of draggable (guid or text)',
    width_of_placeholder: 'Width of Place holder',
    height_of_placeholder: 'Height of Place holder',
    top_of_ph: 'Top of Place holder',
    left_of_ph: 'Left of Place holder',
    tilte_of_ph: 'Title of Place holder',
    name_of_ph : 'Name of Place holder',
    correct_answer_of_ph: 'Correct answer of Place holder',
    default_answer_of_ph: 'Default answer of Place holder',
    css_style_of_ph: 'CSS style of Place holder',
    width_of_input : 'Width of Input box',
    height_of_input: 'Height of Input box',
    top_of_input: 'Top of Input box',
    left_of_input: 'Left of Input box',
    correct_answer_of_input: 'Correct answer of Input box',
    default_ans_of_input: 'Default answer of Input box',
    placeholder_of_ib: 'Place holder of Input box',
    text_box: 'Text box',
    password: 'Password',
    parser: 'Parser',
    parser_of_txt: 'Parser of Textbox',
    sql: 'SQL',
    case_insensitive: 'Case-insensitive',
    multi_crct_answer: 'Multiple Correct Answers',
    css_of_input: 'CSS style of Input box',
    font_style: 'Font Style',
    height_of_multiline: 'Height of Multiline',
    width_of_multiline: 'Width of Multiline',
    top_of_multiline: 'Top of Multiline',
    left_of_multiline: 'Left of Multiline',
    crct_ans_multiline: 'Correct answer of Multiline',
    def_ans_multiline: 'Default answer of Multiline',
    placeholder_multiline: 'Place holder of Multiline',
    parser_of_multiline: 'Parser of Multiline',
    css_class: 'CSS Class',
    width_of_checkbox: 'Width of Checkbox',
    height_of_checkbox: 'Height of Checkbox',
    top_of_checkbox: 'Top of Checkbox',
    left_of_checkbox: 'Left of Checkbox',
    crct_of_chk: 'Correct answer of Checkbox',
    def_of_chk : 'Default answer of checkbox',
    css_of_chk: 'CSS style of checkbox',
    width_of_radio: 'Width of Radio',
    height_of_radio: 'Height of Radio',
    top_of_radio: 'Top of Radio',
    left_of_radio: 'Left of Radio',
    crct_of_radio: 'Correct answer of Radio',
    def_of_radio : 'Default answer of Radio',
    chktype_of_radio: 'Check Type of Radio',
    chk_type: 'Check Type',
    css_style_radio: 'CSS style of Radio',
    width_of_button: 'Width of button',
    height_of_button: 'Height of button',
    top_of_button: 'Top of button',
    left_of_button: 'Left of button',
    value_of_button: 'Value of button',
    class_of_button: 'Class of button',
    value: 'Value',
    class: 'Class',
    css_style_btn: 'CSS style of Button',
    width_of_dropdown: 'Width of dropdown',
    height_of_dropdown: 'Height of dropdown',
    top_of_dropdown: 'Top of dropdown',
    left_of_dropdown: 'Left of dropdown',
    value_of_dropdown: 'Value of dropdown',
    class_of_dropdown: 'Class of dropdown',
    option_of_dropdown: 'Option of dropdown',
    css_style_of_drpdwn: 'CSS style of Dropdown',
    options: 'Options',
    width_of_listbox: 'Width of listbox',
    height_of_listbox: 'Height of listbox',
    top_of_listbox: 'Top of listbox',
    left_of_listbox: 'Left of listbox',
    option_of_listbox: 'Option of listbox',
    select_multiple: 'Select Multiple',
    css_style_of_listbox: 'CSS style of listbox',
    width_of_tabhead: 'Width of tabhead',
    height_of_tabhead: 'Height of tabhead',
    top_of_tabhead: 'Top of tabhead',
    left_of_tabhead: 'Left of tabhead',
    title_of_tabhead: 'Title of tabhead',
    class_of_tabhead: 'Class of tabhead',
    css_style_of_tabhead: 'CSS style of tabhead',
    width_of_image: 'Width of image',
    height_of_image: 'Height of image',
    top_of_image: 'Top of image',
    left_of_image: 'Left of image',
    title_of_image: 'Title of image',
    css_style_of_image: 'CSS style of image',
    bg_of_img: 'Background image of Image',
    width_of_label: 'Width of label',
    height_of_label: 'Height of label',
    top_of_label: 'Top of label',
    left_of_label: 'Left of label',
    title_of_label: 'Title of label',
    border_size: 'Border Size',
    blue: 'Blue',
    red: 'Red',
    bg_color: 'Background Color',
    rich_text: 'Rich Textbox',
    matrix: 'Matrix',
    width_of_area: 'Width of area',
    height_of_area: 'Height of area',
    top_of_area: 'Top of area',
    left_of_area: 'Left of area',
    matrix_of_area: 'Matrix of area',
    crt_of_area: 'Correct Answer of area',
    def_of_area: 'Default Answer of area',
    width_of_menulist: 'Width of menulist',
    height_of_menulist: 'Height of menulist',
    top_of_menulist: 'Top of menulist',
    left_of_menulist: 'Left of menulist',
    matrix_of_menulist: 'Matrix of menulist',
    crt_of_menulist: 'Correct Answer of menulist',
    event_value: 'Events value',
    event_val_menulist: 'Events value of Menulist',
    width_of_hotspot: 'Width of hotspot',
    height_of_hotspot: 'Height of hotspot',
    top_of_hotspot: 'Top of hotspot',
    left_of_hotspot: 'Left of hotspot',
    title_of_hotspot: 'Title of hotspot',
    name_of_hotspot: 'Title of hotspot',
    target_img: 'Target Image',
    hide_target: 'Hide Target',
    target_img_hpt: 'Target Image of Hotspot',
    width_of_click: 'Width of click',
    height_of_click: 'Height of click',
    top_of_click: 'Top of click',
    left_of_click: 'Left of click',
    title_of_tab: 'Title of tab',
    alt_of_image: 'Alt of image',
    bg_of_tab: 'Background image of tab',
    bg_of_step: 'Background image of Step',
    alt_text: 'Alt',
    display: 'Display',
    width_of_base: 'Width of base',
    height_of_base: 'Height of base',
    bg_alt_text: 'Background Alt Text',
    alt_text_base: 'Alt text of Base',
    bg_of_base: 'Background image of Base',
    add_border: 'Add Border',
    width_of_cm: 'Width of Choice Matrix',
    height_of_cm: 'Height of Choice Matrix',
    top_of_cm: 'Top of Choice Matrix',
    left_of_cm: 'Left of Choice Matrix',
    name_of_cm: 'Name of Choice Matrix',
    crt_of_cm: 'Correct Answer of Choice Matrix',
    def_of_cm: 'Default Answer of Choice Matrix',
    css_of_cm: 'CSS style of Choice Matrix',
    on_click: 'On Click',
    on_dbl_click: 'On Double Click',
    on_context: 'On Right Click',
    on_drag_start: 'On Drag Start',
    on_drag: 'On Drag',
    on_drag_end: 'On Drag End',
    on_drop: 'On Drop',
    on_mouse_over: 'On Mouse over',
    on_mouse_up : 'On Mouse Up',
    on_mouse_down: 'On Mouse Down',
    on_change: 'On Change',
    on_focus: 'On Focus',
    on_blur: 'On Blur',
    on_key_up: 'On Key Up',
    on_key_press: 'On Key Press',
    on_key_down: 'On Key Down',
    func_for: 'Function for ',
    old_xml: 'This is old version of XML<br/>If you edit this item it might not work in the Prepkit<br/>For further assistance, please contact New Editor Team.',
    base_steps: 'Base||Steps:',
    timestream: 'Timestream',
    edit_base: 'Base Settings',
    sample_img: 'Sample Image',
    module: 'Module',
    select_instruction: 'Select Module & Click List Contents button for finding all the guid. To select any guid click on the guid.',
    scene: 'Scene',
    intro: 'Intro',
    characters: 'Characters',
    assets: 'Assets',
    chat_windows: 'Chat Windows',
    mission: 'Mission',
    mission_name: 'Mission Name',
    communication: 'Communication',
    animation: 'Animation',
    click_to_select: 'Click to select the ',
    test: "Test",
    learn: "Learn",
    character_voice: 'Character Voice',
    male_one: 'Male 1',
    male_two: 'Male 2',
    male_three: 'Male 3',
    male_four: 'Male 4',
    male: 'Male',
    female: 'Female',
    female_one: 'Female 1',
    female_two: 'Female 2',
    female_three: 'Female 3',
    female_four: 'Female 4',
    female_five: 'Female 5',
    female_six: 'Female 6',
    visibility: 'Visibility',
    asset_visibility: 'Asset Visibility.',
    asset_animation: 'Asset animation.',
    tooltip: 'Tooltip',
    tooltip_txt: 'Tooltip Text',
    onclick_step: 'Onclick Step',
    points: 'Points',
    points_text: 'Provide points for the mission.',
    add_mission: 'Add Mission',
    choose_character: 'Choose character',
    not_visible: 'Not visible',
    voice: 'Voice',
    narrater_voice: 'Narrator Voice',
    conversion_type: 'Conversation Type',
    statement: 'Statement',
    choice: 'Choice',
    item: 'Item',
    multichoice: 'Multi Choice',
    alert: 'Alert',
    autocomplete: 'Auto Complete',
    autocomplete_txt: 'After enabling this it will automatically switch to next step when the statement of this step will end.',
    image_size_txt: 'Select image size more then 256KB and in png format.',
    result_bg: 'Upload Background Image For Result',
    result_info: 'Image displayed on game result screen.',

    image_link: 'Image Link',
    score: 'Score',
    score_value: 'Score Value',
    speech: 'Speech',
    speech_txt: 'Enable speech convertor.',
    speech_input: "After enabling this user will be able to answer by speaking. This feature will work on ucertify.com only.",
    branch_condition: 'Branching Condition',
    no_anim_avail: 'No animation available',
    enter_choice_text: 'Enter Choice Text',
    choice_text: 'Choice Text',
    enter_choice_feedback: 'Enter Choice Feedback',
    feedback_text: 'Feedback text',
    fb_char_name: "Select the feedback character's name.",
    fb_char: 'Feedback Character',
    true: 'True',
    false: 'False',
    step_index: "Step Index",
    step_index_txt: 'Provide the step index to go to that step.',
    new_mission: 'Click to add a new mission.',
    add_choice: 'Add Choice',
    new_step: 'Click to add a new step.',
    add_anim : 'Add Animation',
    animation_play: 'Animation Play',
    dialog: 'Dialog',
    enter_result_title: 'Enter result title',
    result_title: 'Result title',
    result_btn_info: 'If you want to write the result title of your choice, write another title, otherwise skip this step.',
    one_option_correct: 'Only one option can be selected or marked as correct.',
    one_option_require: 'Please set one option as correct answer.',
    delete_textbox: 'Do you want to delete the text box?',
    delete_msg: 'Click the plotted points to delete them.',
    last_delete_msg: 'Click the last plotted point of the item to delete the item!',
    fill_field: 'Please fill out this field.',
    value_gt_zero: 'Value must be greater than 0.',
    enter_number: 'Please enter only number.',
    graph_width: 'Width of graph',
    graph_height: 'Height of graph',
    xaxis_value: 'X-axis value',
    yaxis_value: 'Y-axis value',
    anskey: 'anskey',
    reflection: 'reflection',
    curve_start_point: 'This is the start point of the curve so you cannot delete this point',
    warning_this_for: 'In this case this.for gets undefined and curve does not remove but xml of user answer updated. So prevented xml for being update.',
    last_point: 'You are trying to delete a polygon but either the polygon is not drawn completely or you are trying to delete the polygon by clicking the point, which is not the last point',
    insert_numeric_data: 'Insert numeric data',
    pointy2: 'Point Y2',
    pointx2: 'Point X2',
    pointx1: 'Point X1',
    pointy1: 'Point Y1',
    pointx: 'Point X ',
    pointy: 'Point Y ',
    select_choics: 'Select true or false to indicate if the choice correct or not.',
    select_game_mode: 'Select the game mode.',
    start_button: 'Start Button.',
    set_chr_visiblity: 'Set character visibility.',
    add_chr_nm: 'Provide a character name.',
    chr_voice: "Select the character's voice.",
    type_of_step: 'Select the type of this step',
    guid_value: 'Guid Value',
    value_gt_one: 'Value must be greater than or equals to 1',
    value_gt_interval: 'Value must be greater than interval',
    value_gt_min: 'Value must be greater than min',
    deprecated: 'Association Module is deprecated and will not work!',
    exhibit_err: 'Exhibit player does not support this format',
    open_modal: 'ADA button click to open modal box',
    val_gt_limit: 'Value must be greater than 599!',
    select_one_tool: 'Please select at least one tool.',
    delete_point_msg: '* To delete the points, right click on the points.',
    reset_module: 'Do you want reset the module?',
    ans_correct: "Your's answer is correct!",
    ans_incorrect: "Your's answer is incorrect!",
    shortcuts: 'Shortcuts',
    keys: 'Keys',
    ctrl_z: 'Ctrl + Z or Ctrl + fn + Z',
    undo: 'Undo',
    ctrl_x: 'Ctrl + X or Ctrl + fn + X',
    cut: 'Cut',
    ctrl_y: 'Ctrl + Y or Ctrl + fn + Y',
    redo: 'Redo',
    enter : 'Enter',
    enable_tool: 'Enable the Draw Tool',
    shift_enter: 'Shift + Enter',
    shift_arrow: 'Shift + arrow keys',
    start_stop_tool: 'Start/Stop Drawing by Drawing tool',
    compass_tools: 'Move the Compass components like Radius,center or its Angle / Move the Drawing point',
    locking: 'Shift + L',
    locking_txt: 'Lock the current Point when user is already pressed Enter on current Point',
    draw_key: 'D',
    draw_txt: 'When drawing by scribble tool by key events then fixed the path',
    tab: 'Tab',
    shift_tab: 'Shift + Tab',
    esc: 'Esc',
    focus_next: 'To move towards the next focus points',
    focus_prev: 'To move towards the previous focus points',
    exit_txt: 'To Exit this shortcut window',
    compass_center: 'Compass Center',
    shift_arrow_use : 'Use Shift and arrow keys to move the compass',
    compass_radius: 'Compass Radius, Your Current Radius is ',
    shift_arrow_radius: 'Use Shift and arrow keys to increase or decrease the radius.',
    compass_angle: 'Compass Angle, Your Current Angle is ',
    degree: ' degree',
    compass_draw: 'Compass Draw',
    shift_arrow_draw: ' Use Shift and arrow keys to draw throughout the circumference',
    shift_arrow_angle: 'Use Shift and arrow keys to increase or decrease the radius angle',
    reset_btn: 'Reset Button',
    marking_tools: 'Marking tools',
    removing_tools: 'Removing tools',
    drawing_tools: 'Drawing Tools Container',
    draw_tools: 'Draw tools',
    scribble_tool: 'Scribble tool', 
    line_tool: 'line tool',
    compass_tool: 'compass tool',
    line: 'Line',
    compass: 'Compass',
    scribble: 'Scribble',
    delete_tool: 'Delete tool',
    clear_screen: 'Clear Screen',
    mark_finish_point: 'Mark/Finish Points',
    mark_ans_point: 'Mark/Finish Answer Points',
    mark_pnt: 'Mark Points',
    delete_points: 'Do you want to delete the points?',
    answer_point: 'Answer Points',
    add_show_point: 'Add/Show Point',
    add_finish_point: 'Add/Finish Focus Point',
    add_focus_pnt: 'Add Focus Point',
    def_mode: 'Default Mode',
    access_mode: 'Accessibility Mode',
    configuration: 'Configuration',
    alt_txt_image: 'Alt Text of Image',
    draw_color: 'Drawing Color',
    itemtype_0 : "This task contains the radio buttons and checkboxes for options. The shortcut keys to perform this task are A to H and alt+1 to alt+9.",
    itemtype_1 : "To perform the given task, you have to select an item from one side and place it in front of its correct item on the other side. The shortcut keys to perform this task are Press the Alt+down arrow key to activate. Press the arrow key to navigate through all the items. Copy the left item using the Enter key. Paste the item using the Enter key. If you want to remove any navigated item, then selected that item and press the Delete key to remove for Windows and the Fn+Delete key for Mac.",
    itemtype_4 : "In this type of question, you have to point out the specific area asked in the question. The shortcut keys to perform this task are. The Alt+down arrow key to activate the target. The arrow key to move the target.",
    itemtype_6 : "Here, you have to select the options given in the list. The shortcut keys to perform this task are. The Alt+down arrow key to activate the answer area.  Use the arrow key for navigation. Press the Enter key to select the item. Again, press the Enter key to deselect the item.",
    itemtype_7 : "Here, you have to arrange the options given in the list into their correct order. The shortcut keys to perform this task are. Press the Alt+down arrow key to activate the answer area. Navigate to the item using the arrow key. Press the Enter key to copy the item. Navigate the copied item to the desired position using the arrow keys. Press the Enter key to paste the item. If the item is at its correct position, just press the Enter key to keep that item in sequence. If you want to remove the item from its position, press the Delete key for Windows and the Fn+Delete key for Mac.",
    itemtype_9 : "Here, this type of question contains the select box, text box, and drag and drop boxes. The shortcut keys to perform this task are. Press the Alt+down arrow key to activate the target. Press the arrow key to navigate through all the items. If the selected item is a text box or a select box, it will automatically get focused. If you want to drop the item in the droppable field, navigate to any of the draggable using the Tab key, and press the Enter key to copy the draggable, Now, navigate to any of the droppable field and press the Enter key to drop the copied item. If you want to remove the item from the droppable field, navigate to the droppable field and press the Delete key for Windows and the Fn+Delete key to remove the item.",
    itemtype_14 : "Here, in this type of question, you have to match the item on the left with the correct item on the right by selecting and placing the item to its correct answer. Shortcut key to perform this task are. Press the Alt+down arrow key to activate the target. Press the arrow key to navigate through all the item. Copy the left item using the Enter key. Paste the item using the Enter key. If you want to remove the item, navigate to any of the left side items and press the Delete key to remove for Windows and the Fn+Delete key for Mac.",
    itemtype_26 : "To perform the given task, you have to select and place it in correct item on the. The shortcut keys to perform this task are Press the Alt+down arrow key to activate. Press the arrow key to navigate through all the items. Copy the left item using the Enter key. Paste the item using the Enter key. If you want to remove any navigated item, then selected that item and press the Delete key to remove for Windows and the Fn+Delete key for Mac.",
    itemtype_30 : "Here, in this type of questions, you have to access the range. you can use left arrow key for decreasing the value and right for increasing the value.",
    itemtype_17 : "Here, you have to select the options given in the list. The shortcut keys to perform this task are: Press the tab for navigation. Press the Enter key to select the item and move using the tab key. Again, press the Enter key to deselect the item and place it on the correct option.",
    itemtype_27 : "Here, in this type of questions, you have to identify the correct and incorrect statements by checking the True or False check boxes. The shortcut key to perform the task are. Press Tab for navigation. Press the Enter key for selecting the check box.",
    itemtype_15 : "To perform the given task, you have to select an item from one side and place it in front of its correct item on the other side. The shortcut keys to perform this task are Press the Alt+down arrow key to activate. Press the arrow key to navigate through all the items. Copy the left item using the Enter key. Paste the item using the Enter key. If you want to remove any navigated item, then selected that item and press the Delete key to remove for Windows and the Fn+Delete key for Mac.",
    itemtype_13 : "Here, this type of question contains the terminal. You have to write command to perform this task.",
    itemtype_22 : "Here, this type of question contains the cisco terminal. You have to write command to perform this task.",
    es6_warining: "You are using Internet Explorer, ES6 functionality of javascript will not work!",
    embed_content: "Embed Content"
};

/* src\EditorDetails.svelte generated by Svelte v3.40.2 */

const content_type = ['q', 'u', 'p', 'a', 'e', 'f', 's', 'c', 'v', 'x'];
const editorDetails = {};

content_type.map(type => {
	editorDetails[type] = {
		title: {
			view: false,
			label: "Title",
			placeHolder: "Place Your Text Here",
			restrict: null
		},
		stem: {
			view: false,
			label: "Stem",
			placeHolder: "Place Your Text Here",
			restrict: null
		},
		content: {
			view: false,
			label: "Content",
			placeHolder: "Place Your Text Here",
			restrict: null
		},
		remediation: {
			view: false,
			label: "Remediation",
			placeHolder: "Place Your Text Here",
			restrict: [57]
		},
		itemModule: { view: false, style: null, restrict: null },
		isFullMode: { view: false },
		showItemMetaIcon: { view: false },
		isQuestion: false,
		required: false,
		checkRequired: { view: "*", restrict: null },
		defaultVerticalView: false,
		typeAllowedSave: "*",
		domain: "*",
		showRefresh: { view: false, restrict: null }
	};
});

// q and u are used for question type
editorDetails.q.title.view = "*";

editorDetails.q.stem.view = "*";
editorDetails.q.remediation.view = "*";
editorDetails.q.itemModule.view = "*";
editorDetails.q.isQuestion = "*";
editorDetails.q.required = "stem";
editorDetails.q.isFullMode.view = [16, 17, 18, 24, 22, 23, 32, 36];
editorDetails.q.showItemMetaIcon.view = [25];
editorDetails.q.showXMl = { view: "*", restrict: [0, 8] };
editorDetails.u.title.view = "*";
editorDetails.u.stem.view = "*";
editorDetails.u.remediation.view = "*";
editorDetails.u.itemModule.view = "*";
editorDetails.u.isQuestion = "*";
editorDetails.u.required = "stem";
editorDetails.u.isFullMode.view = [16, 17, 18, 24, 22, 36, 23, 32];
editorDetails.u.showItemMetaIcon.view = [25];
editorDetails.u.showXMl = { view: "*", restrict: [0, 8] };

//------------END--------------------//
//---------Web Pages ------------------//
editorDetails.p.itemModule.view = "*";

editorDetails.p.itemModule.style = { overflowX: "auto" };

//editorDetails.p.content.view = "*";
editorDetails.p.defaultVerticalView = false;

editorDetails.p.domain = false;
editorDetails.p.webPageList = "*";
editorDetails.p.loadWebPages = "*";
editorDetails.p.showOtherType = "*";
editorDetails.p.showRefresh.view = "*";

//------------END------------------------//
//--------------Type f -------------------//
editorDetails.f.title.view = "*";

editorDetails.f.required = "title";
editorDetails.f.checkRequired = { view: "*", restrict: [52] };
editorDetails.f.title.restrict = [52];
editorDetails.f.content.view = "*";
editorDetails.f.content.restrict = [52];
editorDetails.f.itemModule.view = [45, 52];
editorDetails.f.itemModule.style = { overflowX: "auto" };
editorDetails.f.defaultVerticalView = false;
editorDetails.f.save_content_text = { view: [52] };
editorDetails.f.save_vtt_info = { view: [45] };
editorDetails.f.showRefresh.view = "*";

//--------------END-----------------------//
//--------- Other type ------------------//
editorDetails.a.title.view = "*";

editorDetails.a.content.view = "*";
editorDetails.a.loadWebPages = "*";
editorDetails.a.showRefresh.view = "*";
editorDetails.e.title.view = "*";
editorDetails.e.itemModule.view = "*";
editorDetails.e.itemModule.style = { overflowX: "auto" };
editorDetails.e.defaultVerticalView = false;
editorDetails.e.loadWebPages = "*";
editorDetails.e.showOtherType = "*";
editorDetails.s.title.view = "*";
editorDetails.s.required = "title";
editorDetails.s.content.view = "*";
editorDetails.s.showRefresh.view = "*";
editorDetails.c.title.view = "*";
editorDetails.c.title.required = "*";
editorDetails.c.content.view = "*";
editorDetails.c.showRefresh.view = "*";
editorDetails.v.title.view = "*";
editorDetails.v.content.view = "*";
editorDetails.v.showRefresh.view = "*";
editorDetails.x.title.view = "*";
editorDetails.x.content.view = "*";
editorDetails.x.showRefresh.view = "*";

/* src\EditorConfig.svelte generated by Svelte v3.40.2 */

let editorStage = false;
let updateParent = false;
let handleModal = false;
const text_data = "<div>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet. Duis sagittis ipsum. Praesent mauris. Fusce nec tellus sed augue semper porta. Mauris massa. Vestibulum lacinia arcu eget nulla. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Curabitur sodales ligula in libero. Sed dignissim lacinia nunc. Curabitur tortor. Pellentesque nibh. Aenean quam. In scelerisque sem at dolor. Maecenas mattis. Sed convallis tristique sem. Proin ut ligula vel nunc egestas porttitor. Morbi lectus risus, iaculis vel, suscipit quis, luctus non, massa. Fusce ac turpis quis ligula lacinia aliquet. Mauris ipsum. Nulla metus metus, ullamcorper vel, tincidunt sed, euismod in, nibh. Quisque volutpat condimentum velit. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Nam nec ante. Sed lacinia, urna non tincidunt mattis, tortor neque adipiscing diam, a cursus ipsum ante quis turpis. Nulla facilisi. Ut fringilla. Suspendisse potenti. Nunc feugiat mi a tellus consequat imperdiet. Vestibulum sapien. Proin quam. Etiam ultrices. Suspendisse in justo eu magna luctus suscipit. Sed lectus. Integer euismod lacus luctus magna. Quisque cursus, metus vitae pharetra auctor, sem massa mattis sem, at interdum magna augue eget diam. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Morbi lacinia molestie dui. Praesent blandit dolor. Sed non quam. In vel mi sit amet augue congue elementum. Morbi in ipsum sit amet pede facilisis laoreet. Donec lacus nunc, viverra nec.</div>";

const editorConfig = {
	getSection(data, type = false, node = false) {
		//let inlineClass = (type == "inline") ? " inline" : "";
		let sectionHtml = "";

		if (typeof data == "object") {
			let itemHtml = data.getAttribute('data-html');
			let itemType = data.getAttribute('data-type');

			//@Pradeep : code for class selection----------------------------------------------
			sectionHtml = getSectionAttr(itemHtml, itemType);
		} else {
			sectionHtml = checkUnWrapped(data, node);
		}

		return sectionHtml;
	},
	getSectionDef: getSectionAttr,
	eBookItemTypeOld: 'section[type="ebook-item"]',
	eBookItemType: 'div[type="ebook-item"]',
	initAddFeatureSelector(stem, remediation, content) {
		content = content ? content : "Place your text here.";

		return {
			'#stem': {
				data: stem,
				holder: "stem",
				copyInto: "oldStemData",
				store: { stem, oldStemData: stem },
				label: 'Stem'
			},
			'#remediation': {
				data: remediation,
				holder: "remediation",
				store: { remediation },
				label: 'Remediation',
				inline: "inline"
			},
			'#content': {
				data: content,
				holder: "content",
				store: { content },
				label: 'Content'
			}
		};
	},
	setParent(statUpdate, handleModalFunc) {
		updateParent = statUpdate;
		if (handleModalFunc) handleModal = handleModalFunc;
	},
	maintainAlignments(data, action = false) {
		if (!AH.isValid(data)) {
			data = "";
		}

		if (action == "all" && AH.isValid(data)) {
			for (let type in data) {
				data[type] = data[type].replace(/(?![^<>]*>)\s\s/g, '&#160; ');
			}
		} else {
			data = data.replace(/(?![^<>]*>)\s\s/g, '&#160; ');
		}

		return data;
	},
	getConfig(state, data = {}) {
		// Editor Layout will decide here what we are going to show.
		let subtype = +state.item;

		let type = state.content_type || state.moduleType;
		let configData = {};
		console.warn({ subtype, type });

		for (let key in editorDetails[type]) {
			if (editorDetails[type][key]) {
				if (typeof editorDetails[type][key] == "object") {
					if (editorDetails[type][key].view) {
						let isRestricted = editorDetails[type][key].restrict && editorDetails[type][key].restrict.find(restrict => restrict == subtype);

						if (isRestricted || isRestricted == 0) {
							configData[key] = false;
						} else {
							let isObject = editorDetails[type][key].view == "*"
							? true
							: editorDetails[type][key].view.find(allowedSubtype => allowedSubtype == subtype);

							configData[key] = isObject ? editorDetails[type][key] : false;
						}
					}
				} else {
					configData[key] = editorDetails[type][key];
				}
			}
		}

		return configData;
	},
	mathMl(type, target, state) {
		switch (type) {
			case 'reset':
				AH.get('mathjaxEnabled') && MathJax.typesetClear();
				break;
			case 'set':
				AH.get('mathjaxEnabled') && MathJax.typeset(["#previewSection"]);
				break;
			case 'setAll':
				AH.get('mathjaxEnabled') && MathJax.typeset();
				break;
			case 'getMathIn':
				AH.get('mathjaxEnabled') && MathJax.startup.document.getMathItemsWithin(target);
				break;
			case 'add':
				// Configure MathJax
				/*
MathJax = {
    startup: {
      elements: null,          // The elements to typeset (default is document body)
      typeset: true,           // Perform initial typeset?
      ready: Startup.defaultReady.bind(Startup),          // Called when components are loaded
      pageReady: Startup.defaultPageReady.bind(Startup),  // Called when MathJax and page are ready
      document: document,      // The document (or fragment or string) to work in
      input: [],               // The names of the input jax to use from among those loaded
      output: null,            // The name for the output jax to use from among those loaded
      handler: null,           // The name of the handler to register from among those loaded
      adaptor: null            // The name for the DOM adaptor to use from among those loaded
    }
  };
*/
				window.MathJax = {
					options: { enableMenu: false },
					startup: {
						elements: ["#previewSection"],
						ready: () => {
							console.warn('MathJax is loaded, but not yet initialized');
							MathJax.startup.defaultReady();
							console.warn('MathJax is initialized, and the initial typeset is queued');

							MathJax.startup.promise.then(() => {
								console.warn('MathJax initial typesetting complete');
								AH.set("mathjaxEnabled", true);
							});
						}
					}
				};
				AH.addScript("", 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js', { target: 'body' });
				// AH.ajax({
				//     url: `https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js`,
				//     async: true,
				//     data: {},
				//     type: 'GET',
				//     dataType: "script",
				// }).then((script)=> {
				//     setTimeout(()=> {
				//         AH.addScript(script);
				//     },10000)
				// });
				break;
		}
	},
	findMathError() {
		AH.set("mathjaxEnabled", false);
		let item = document.querySelectorAll('#authoringSection math');

		if (item) {
			nodeFinder.find(item, mathTagCorrection.bind(this));
		}
	},
	checkBlank(state, Items, updateModule) {
		if (state.viewConfig.checkRequired) {
			switch (state.viewConfig.required) {
				case 'stem':
					let check = Items.UI.doNotCheckStem && !Items.UI.doNotCheckStem(state);
					if (state.stem == "" && !check) {
						updateModule('message', "You must specify a question.");
						updateModule('saveDialog', false);
						updateModule('snackback', true);
						AH.activate(0);
						return true;
					}
					break;
				case 'title':
					if (state.title == "") {
						updateModule('message', "You must specify a title.");
						updateModule('saveDialog', false);
						updateModule('snackback', true);
						AH.activate(0);
						return true;
					}
					break;
			}
		}

		return false;
	},
	editorTable(lang) {
		return [
			{
				text: lang.deftable,
				html: "<table class='sorttable uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.smplbortab,
				html: "<table class='sorttable table1 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.unbortab,
				html: "<table class='sorttable table2 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.borbacktab,
				html: "<table class='sorttable table3 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.hrowsbor,
				html: "<table class='sorttable table4 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th</tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.strptab,
				html: "<table class='sorttable table5 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.tabhovdes,
				html: "<table class='sorttable table6 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.mulstrp,
				html: "<table class='sorttable table7 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.separate,
				html: "<table class='sorttable table8 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table>"
			},
			{
				text: lang.grycolor,
				html: "<table class='uc-table'><caption>Table 1: Add Table Caption Here</caption><thead><tr><th colspan='3' width='40%'>Do This</th><th>How & Why</th></tr></thead><tbody><tr><td>1.</td><td colspan='2'>Activate the <b>Index-Match</b> worksheet.</td><td class='gray-col'>It contains sales data by rep and product.</td></tr><tr><td>2.</td><td colspan='2'>Observe G10:I11.</td><td class='gray-col'>This range contains an interface for looking up sales values for a combination of rep and product. In this small a table, such an interface isn't entirely necessary. But you can imagine how useful this could be with a very large amount of data.</td></tr></tbody></table>"
			}
		];
	},
	onlyContent(type, subtype) {
		let restricted = { 'p': "n", 'f': '52' };

		if (restricted[type]) {
			return restricted[type].length > 1
			? restricted[type].includes(subtype)
			: true;
		}

		return false;
	},
	otherContent(content_type, subtype) {
		let type = {
			'p': "n",
			'a': "n",
			'e': "n",
			'f': "45,52"
		};

		if (type[content_type]) {
			return type[content_type].length > 1
			? type[content_type].includes(subtype)
			: true;
		}

		return false;
	},
	controls(config) {
		return `<main data-remove="true" contenteditable="false" class="controls_button"><div class="block-controls"><div class="block-controls__container"><div class="block-controls__bar"><div class="block-controls__config" style=""><button class="button--controls h-imp">Edit</button></div>${createControls(config)}</div></div></div></div></main>`;
	},
	add_item_button: '<main data-remove="true" class="remove_me text-center" style="outline:none;height:25px" contenteditable="false"><button type="button" class="add_item_template add_item_button_style">+</button></main>',
	keyboardShortcutLayout() {
		return `
            <div id="accordions" class="panel-group mb-0 mx-3 mt-3">
                <div class="card mb">
                    <div class="card-header p-0 height35 rounded-0 bg-secondary">
                        <a data-bs-toggle="collapse" href="#commonShortcuts" class="card-link text-white outline1 d-inline-block w-100 px-3 collapsed" aria-expanded="false"><p class="d-inline-block text-white font18 pt-1 mb-0">Common Shortcuts</p><span class="icomoon-arrow-down-2 s6 float-right pt-1"></span></a>
                    </div>
                    <div id="commonShortcuts" class="collapse show" data-parent="#accordions">
                        <div class="card-body">
                            <table role="presentation" class="m-0 border-0 common-shortcut-table table-striped font15">
                                <tbody>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + C</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Copy</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + X</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Cut</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + V</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Paste</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + F</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Find</span></div></td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="card mb">
                    <div class="card-header p-0 height35 rounded-0 bg-secondary">
                        <a data-bs-toggle="collapse" href="#testShortcuts" class="card-link text-white outline1 d-inline-block w-100 px-3"><p class="d-inline-block text-white font18 pt-1 mb-0">Editor Shortcuts</p><span class="icomoon-arrow-down-2 s6 float-right pt-1"></span></a>
                    </div>
                    <div id="testShortcuts" class="collapse" data-parent="#accordions">
                        <div class="card-body">
                            <table role="presentation" class="m-0 border-0 test-table table-striped font15">
                                <tbody>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Shift + Enter</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Cursor out from code block</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Enter + Enter</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Cursor out from list</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + C</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Code Format</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + H</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Open Keyboard shortcut (Help)</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + V</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Paste Special (Formatting)</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + N</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Next Item (Multiple Item)</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + P</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Previous Item (Multiple Item)</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + T</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Switch Tab (Editor View)</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + S</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Save</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + L</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Item List</span></div></td></tr>
                                    <tr><td class="py-1 font-weight-bold w-50 pr-0">Ctrl + Alt + Plus</td><td class="py-1"><div class="d-flex"><span class="font-weight-bold">:</span><span class="pl-3">Add New Section</span></div></td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>`;
	},
	createToolMenu(state, lang) {
		// Tool menu array
		let preCheck = !state.verticalView || state.content_type == "f";

		let toolMenuJson = [
			{
				id: 'xmlMenu',
				funcName: () => updateParent("", "", 'getXml'),
				label: "XML",
				view: state.viewConfig.showXMl ? true : false
			},
			{
				id: 'renderPlayerMenu',
				funcName: () => updateParent("", "", 'renderPlayer'),
				label: lang.render_tag,
				view: preCheck ? true : false
			},
			{
				id: 'todoMenu',
				funcName: loadTodoMenu,
				funcArg: "Show Todo",
				label: "Task Details",
				view: preCheck && todo_table ? true : false
			},
			{
				id: 'domainMenu',
				funcName: toggleDomain.bind(this, true),
				funcArg: true,
				label: lang.domain,
				view: is_domain && (('q,u').includes(state.content_type) || getQueryString("is_flashcard") == 1)
				? true
				: false
			},
			{
				id: 'versionControlMenu',
				funcName: versionControl.bind(this, true),
				funcArg: true,
				label: lang.version_control,
				view: content_for_newEditor ? true : false
			},
			{
				id: 'toggleExamMenu',
				funcName: toggleExam.bind(this, true),
				funcArg: true,
				label: lang.exam_objective,
				view: from_myproject == 1 && (state.content_type == 'u' && state.content_type == 'f')
				? true
				: false
			},
			{
				id: 'versionControlCurrentMenu',
				funcName: versionControlCurrent,
				funcArg: true,
				label: lang.restore_currect,
				view: version_date ? true : false
			},
			{
				id: 'web_pagesMenu',
				funcName: toggleDomain.bind(this, true),
				funcArg: true,
				label: lang.web_pages,
				view: state.content_type == 'p' ? true : false
			},
			// {
			//     id: 'diagnosticMenu',
			//     funcName: handleDiagnostic.bind(this, state),
			//     label: lang.diagnostic,
			//     extraProp: {disableEnforceFocus: true},
			//     view: true,
			// },
			{
				id: 'analyze_ebookMenu',
				funcName: () => updateParent('AnalyzeEbookMenu', true, ''),
				label: lang.analyze_ebook,
				view: state.oldStemData != '' ? true : false, // not showing currently
				
			},
			{
				id: 'vttParserMenu',
				funcName: vttParser,
				label: "VTT Parser",
				view: preCheck && (state.content_type == 'p' || state.item == 45)
				? true
				: false
			}
		];

		return toolMenuJson;
	},
	createIteractive() {
		// side pane section array
		return [
			{
				"text": {
					"p_tag": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/paragraph_000oaO.png",
						"label": l$1.para,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'>Place Your Text Here</div>"
					}
				},
				"list": {
					"interactive_tags_1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/black_arrow_bullet_000oao.png",
						"label": l$1.blarlist,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ul id='interactive_list' class='arrowlist-bullet'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ul></div>"
					},
					"interactive_tags_2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/blue_arrow_bullet_000oaP.png",
						"label": l$1.bluearlist,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ul id='interactive_list' class='arrow-bullet'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ul></div>"
					},
					"interactive_tags_3": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/blue_arrow_bullet_grey_bg_000oap.png",
						"label": l$1.blarbullet,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ul id='interactive_list' class='arrow-bullet arrow-bullet-list'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ul></div>"
					},
					"interactive_tags_4": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/blue_circle_bullet_000oau.png",
						"label": l$1.blcrcbbullet,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ul id='interactive_list' class='circle-bullet darkblue-txt'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ul></div>"
					},
					"interactive_tags_5": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/white_circle_list_000oaV.png",
						"label": l$1.whcrclist,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ol id='interactive_list' class='whitecircle-list la' style='counter-increment: li-counter 0;'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ol></div>"
					},
					"interactive_tags_6": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/redCircle_000A9f.png",
						"label": l$1.redcrlist,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ol id='interactive_list' class='circle-list' style='counter-increment: li-counter 0;'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ol></div>"
					},
					"interactive_tags_7": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/blue_circle_bullet_black_text_000oB8.png",
						"label": l$1.bcbwbt,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ul id='interactive_list' class='circle-bullet'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ul></div>"
					},
					"list_0": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/list_type0_000oB6.png",
						"label": l$1.tickbull,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ul id='interactive_list' class='tick-bullet'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ul></div>"
					},
					"list_1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/list_type1_000oB9.png",
						"label": l$1.listtype1,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ol id='interactive_list' class='list1'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ol></div>"
					},
					"list_2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/list_type2_000oB7.png",
						"label": l$1.listtype2,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ol id='interactive_list' class='list2'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ol></div>"
					},
					"list_3": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/list_type3_000oBA.png",
						"label": l$1.listtype3,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ol id='interactive_list' class='list3'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ol></div>"
					},
					"list_4": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/list_type4_000oBB.png",
						"label": l$1.listtype4,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ol id='interactive_list' class='list4'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><ol class='list4'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ol><li>PLACE YOUR TEXT HERE</li></ol></div>"
					},
					"list_5": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/list_type5_000oBa.png",
						"label": l$1.listtype5,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ol id='interactive_list' class='list5'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ol></div>"
					},
					"list_6": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/list_type6_000oBb.png",
						"label": l$1.listtype6,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><ul id='interactive_list' class='list6'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li><ul class='list6'><li>PLACE YOUR TEXT HERE</li><li>PLACE YOUR TEXT HERE</li></ul><li>PLACE YOUR TEXT HERE</li></ul>"
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"editing_type_1": "interactive_tags_1|arrowlist-bullet|#interactive_list,interactive_tags_2|arrow-bullet|#interactive_list,interactive_tags_3|arrow-bullet arrow-bullet-list|#interactive_list,interactive_tags_4|circle-bullet darkblue-txt|#interactive_list,interactive_tags_5|whitecircle-list la|#interactive_list,interactive_tags_6|circle-list|#interactive_list,list_1|list1|#interactive_list,list_2|list2|#interactive_list,list_3|list3|#interactive_list,list_4|list4|#interactive_list,list_5|list5|#interactive_list,list_6|list6|#interactive_list"
					}
				},
				"table": {
					"table_0": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_0_000oBE.png",
						"label": l$1.deftable,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_1_000oBf.png",
						"label": l$1.smplbortab,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table1 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_2_000oBc.png",
						"label": l$1.unbortab,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table2 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_3": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_3_000oBg.png",
						"label": l$1.borbacktab,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table3 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_4": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_4_000oBD.png",
						"label": l$1.hrowsbor,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table4 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th</tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_5": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_5_000oBd.png",
						"label": l$1.strptab,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table5 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_6": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_6_000oBe.png",
						"label": l$1.tabhovdes,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table6 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_7": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_7_000oBG.png",
						"label": l$1.mulstrp,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table7 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_8": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_8_000oBF.png",
						"label": l$1.separate,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table8 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					"table_9": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_9_0007d4.png",
						"label": l$1.grycolor,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='uc-table'><caption>Table 1: Add Table Caption Here</caption><thead><tr><th colspan='3' width='40%'>Field 1</th><th>Field 2</th></tr></thead><tbody><tr><td>1.</td><td colspan='2'>Lorem ipsum dolor sit amet,</td><td class='gray-col'>Lorem ipsum dolor sit amet.</td></tr><tr><td>2.</td><td colspan='2'>Lorem ipsum dolor sit amet,</td><td class='gray-col'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</td></tr></tbody></table></div>"
					},
					"table_10": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/table_10_000oBH.png",
						"label": l$1.blueshade,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><table class='sorttable table10 uc-table' tablesorter=''><caption>Table 1: Add Table Caption Here</caption><thead><tr><th>Name</th><th>Field 1</th></tr></thead><tbody><tr><td>Malcom</td><td>Lorem ipsum dolor sit amet, </td></tr></tbody></table></div>"
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"editing_type_1": "table_0|sorttable uc-table|.sorttable,table_1|sorttable table1 uc-table|.sorttable,table_2|sorttable table2 uc-table|.sorttable,table_3|sorttable table3 uc-table|.sorttable,table_4|sorttable table4 uc-table|.sorttable,table_5|sorttable table5 uc-table|.sorttable,table_6|sorttable table6 uc-table|.sorttable,table_7|sorttable table7 uc-table|.sorttable,table_8|sorttable table8 uc-table|.sorttable,table_10|sorttable table10 uc-table|.sorttable"
					}
				},
				"code-block": {
					"black": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/black_one_000oBL.png",
						"label": l$1.code_block2,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><uc:syntax console=''>Place Your Text Here<br />Place Your Text Here</uc:syntax></div>"
					},
					"black_nonum": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/black_nonum_000oBk.png",
						"label": l$1.code_block3,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><uc:syntax console='' hidelinenums=''>Place Your Text Here<br />Place Your Text Here</uc:syntax></div>"
					},
					"white": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/white_000oBl.png",
						"label": l$1.code_block4,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><uc:syntax white=''>Place Your Text Here<br />Place Your Text Here</uc:syntax></div>"
					},
					"white_nonum": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/white_nonum_000oBM.png",
						"label": l$1.code_block5,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><uc:syntax hidelinenums=''>Place Your Text Here<br />Place Your Text Here</uc:syntax></div>"
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"uc_syntax": true,
						// @uc-abk added this line due to not working change type dynamically.
						"editing_type_1": "Hide Numbers||uc\\:syntax|hidelinenums|default,black_nonum||uc\\:syntax|console|black|black_nonum||uc\\:syntax|console hidelinenums,white_nonum||uc\\:syntax|white|white_nonum"
					}, //by Saquib sir:  "editing_type_1":"Hide Numbers||uc\\:syntax|hidelinenums|default,black||uc\\:syntax|console,black_nonum||uc\\:syntax|console nonum,white||uc\\:syntax|white,white_nonum||uc\\:syntax|white,"
					
				},
				"panel": {
					"interactive_tags_13": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panels_1_000oBP.png",
						"label": l$1.panel_success,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='board panel-success'><div class='panel-heading'><span class='ebook_item_text'>PLACE HEADING FOR THE PANEL HERE</span></div><div class='panel-body'><div class='ebook_item_text'>PLACE YOUR TEXT/BODY OF THE PANEL HERE</div></div></div></div>"
					},
					"interactive_tags_14": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panels_2_000oBo.png",
						"label": l$1.panel_info,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='board panel-info'><div class='panel-heading'><span class='ebook_item_text'>PLACE HEADING FOR THE PANEL HERE</span></div><div class='panel-body'><div class='ebook_item_text'>PLACE YOUR TEXT/BODY OF THE PANEL HERE</div></div></div></div>"
					},
					"interactive_tags_15": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panels_3_000oBN.png",
						"label": l$1.panel_primary,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='board panel-primary'><div class='panel-heading'><span class='ebook_item_text'>PLACE HEADING FOR THE PANEL HERE</span></div><div class='panel-body'><div class='ebook_item_text'>PLACE YOUR TEXT/BODY OF THE PANEL HERE</div></div></div></div>"
					},
					"interactive_tags_16": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panels_4_000oBn.png",
						"label": l$1.panel_danger,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='board panel-danger'><div class='panel-heading'><span class='ebook_item_text'>PLACE HEADING FOR THE PANEL HERE</span></div><div class='panel-body'><div class='ebook_item_text'>PLACE YOUR TEXT/BODY OF THE PANEL HERE</div></div></div></div>"
					},
					"interactive_tags_17": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panels_5_000oBO.png",
						"label": l$1.panel_warning,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='board panel-warning'><div class='panel-heading'><span class='ebook_item_text'>PLACE HEADING FOR THE PANEL HERE</span></div><div class='panel-body'><div class='ebook_item_text'>PLACE YOUR TEXT/BODY OF THE PANEL HERE</div></div></div></div>"
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"editing_type_1": "interactive_tags_13|board panel-success|.board,interactive_tags_14|board panel-info|.board,interactive_tags_15|board panel-primary|.board,interactive_tags_16|board panel-danger|.board,interactive_tags_17|board panel-warning|.board"
					}
				},
				"Accordion": {
					"panel_1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panel_1_000oBp.png",
						"label": l$1.acc_list1,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><section type='ebook_item' sub_type='panel'><section class='drop_list drop_list_a drop_list1' nd='0'><section nd='1'><header class='ebook_item_text'><span style='cursor:auto;'>Panel 1</span></header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</article></section><section nd='1'><header class='ebook_item_text'><span style='cursor:auto;'>Panel 2</span></header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</article></section></section></section></div>"
					},
					"panel_2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panel_2_000oBQ.png",
						"label": l$1.acc_list2,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><section type='ebook_item' sub_type='panel'><section class='drop_list drop_list_a drop_list2' nd='0'><section nd='1'><header class='ebook_item_text'><span style='cursor:auto;'>Panel 1</span></header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. </article></section><section nd='1'><header class='ebook_item_text'><span style='cursor:auto;'>Panel 2</span></header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</article></section></section></section></div>"
					},
					"panel_3": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panel_3_000oBq.png",
						"label": l$1.acc_list3,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><section type='ebook_item' sub_type='panel'><section class='drop_list drop_list_b drop_list3' nd='0'><section nd='1'><header class='ebook_item_text'> This is a title for my toggle!</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. </article></section><section nd='1'><header class='ebook_item_text'> This is a title for my toggle!</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. </article></section><section nd='1'><header class='ebook_item_text'> This is a title for my toggle!</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</article></section></section></section></div>"
					},
					"panel_4": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/panel_4_000oBR.png",
						"label": l$1.acc_list4,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><section type='ebook_item' sub_type='panel'><section class='drop_list drop_list_b drop_list4' nd='0'><section nd='1'><header class='ebook_item_text'> This is a title for my toggle! </header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. </article></section><section nd='1'><header class='ebook_item_text'> This is a title for my toggle!</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. </article></section><section nd='1'><header class='ebook_item_text'> This is a title for my toggle!</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</article></section></section></section></div>"
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"editing_type_1": "panel_1|drop_list drop_list_a drop_list1|.drop_list,panel_2|drop_list drop_list_a drop_list2|.drop_list,panel_3|drop_list drop_list_b drop_list3|.drop_list,panel_4|drop_list drop_list_b drop_list4|.drop_list",
						"render_tags": true
					}
				},
				"box": {
					"interactive_tags_18": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/interactive_item/panels_6.png",
						"label": l$1.panelblue,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='bbox box1'><div class='ebook_item_text'>Place your text here</div></div></div>"
					},
					"interactive_tags_19": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/interactive_item/panels_7.png",
						"label": l$1.panelgreen,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='bbox box2'><div class='ebook_item_text'>Place your text here</div></div></div>"
					},
					"interactive_tags_20": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/interactive_item/panels_8.png",
						"label": l$1.panelsky,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='bbox box3'><div class='ebook_item_text'>Place your text here</div></div></div>"
					},
					"interactive_tags_21": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/interactive_item/panels_9.png",
						"label": l$1.panelgrad,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='bbox box4'><div class='ebook_item_text'>Place your text here</div></div></div>"
					},
					"interactive_tags_box22": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/interactive_item/block_bg.png",
						"label": l$1.blockgrey,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='bbox box5'><div class='ebook_item_text'>Place your text here</div></div></div>"
					},
					"interactive_tags_box23": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/box6_000o1Q.png",
						"label": l$1.block_with_border,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='bbox box6'><div class='ebook_item_text'>Place your text here</div></div></div>"
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"editing_type_1": "interactive_tags_18|box1 bbox|.bbox,interactive_tags_19|box2 bbox|.bbox,interactive_tags_20|bbox box3|.bbox,interactive_tags_21|bbox box4|.bbox,interactive_tags_box22|bbox box5|.bbox,interactive_tags_box23|bbox box6|.bbox"
					}
				},
				"CALLOUTS": {
					"SNT0": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/default_snt_000OjP_000oBr.jpg",
						"label": "Default Fact",
						"html": getIntractiveHtml("snt", {
							label: "Default Fact",
							icon: "default_v2"
						})
					},
					"SNT1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/note_snt_000Ojc_000oBU.jpg",
						"label": "Note",
						"html": getIntractiveHtml("snt", { label: "Note", icon: "notes_v2" })
					},
					"SNT2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/tips_snt_000OjD_000oBt.jpg",
						"label": "Tips",
						"html": getIntractiveHtml("snt", { label: "Tips", icon: "tips_v2" })
					},
					"SNT3": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/decision_snt_000Ojd_000oBw.jpg",
						"label": "Decision",
						"html": getIntractiveHtml("snt", { label: "Decision", icon: "decision_v2" })
					},
					"SNT4": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/example_snt_000OjE_000oBV.jpg",
						"label": "Example",
						"html": getIntractiveHtml("snt", { label: "Example", icon: "example_v2" })
					},
					"SNT5": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/cautions_snt_000Oje_000oBs.jpg",
						"label": "Cautions",
						"html": getIntractiveHtml("snt", { label: "Cautions", icon: "cautions_v2" })
					},
					"SNT6": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/lab_snt_000OjF_000oBv.jpg",
						"label": "Lab",
						"html": getIntractiveHtml("snt", { label: "Lab", icon: "lab_v2" })
					},
					"SNT7": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/warnig_snt_000Ojf_000oBW.jpg",
						"label": "Warnings",
						"html": getIntractiveHtml("snt", { label: "Warnings", icon: "warnings_v2" })
					},
					"SNT8": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/research_snt_000OjG_000oBT.jpg",
						"label": "Research",
						"html": getIntractiveHtml("snt", { label: "Research", icon: "notes_v2" })
					},
					"SNT9": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/know_snt_000Ojg_000oBS.jpg",
						"label": "Know",
						"html": getIntractiveHtml("snt", { label: "Know", icon: "know_v2" })
					},
					"SNT10": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/responsibilty_snt_000OjH_000oBu.jpg",
						"label": "Resp",
						"html": getIntractiveHtml("snt", { label: "Resp", icon: "resp_v2" })
					},
					"SNT11": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/spotlight_snt_000Ojh_000ob2.jpg",
						"label": "Spotlight",
						"html": getIntractiveHtml("snt", { label: "Spotlight", icon: "spotlight_v2" })
					},
					"SNT12": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/realworld_snt_000OjI_000ob1.jpg",
						"label": "RealWorld",
						"html": getIntractiveHtml("snt", { label: "RealWorld", icon: "realworld_v2" })
					},
					"SNT14": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/job_snt_000Oji_000oBz.jpg",
						"label": "Job",
						"html": getIntractiveHtml("snt", { label: "Job", icon: "job_v2" })
					},
					"SNT15": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/exam_snt_000OjJ_000oBy.jpg",
						"label": "Exam",
						"html": getIntractiveHtml("snt", { label: "Exam", icon: "exam_v2" })
					},
					"SNT16": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/learn_wgu_snt_000Ojj_000oBZ.jpg",
						"label": "Learn WGU",
						"html": getIntractiveHtml("snt", { label: "Learn WGU", icon: "learnwgu_v2" })
					},
					"SNT17": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/wgu_000OjR_000ob3.jpg",
						"label": "Learn Reflect Nursing",
						"html": getIntractiveHtml("snt", {
							label: "Learn Reflect Nursing",
							icon: "learn-reflect-nursing_v2"
						})
					},
					"SNT18": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/reading_nursing_snt_000OjK_000ob0.jpg",
						"label": "Reading Nursing",
						"html": getIntractiveHtml("snt", {
							label: "Reading Nursing",
							icon: "reading_v2"
						})
					},
					"SNT19": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/bits_snt_000Ojk_000oBx.jpg",
						"label": "Bits",
						"html": getIntractiveHtml("snt", { label: "Bits", icon: "bits_v2" })
					},
					"SNT20": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/bytes_snt_000OjL_000oBY.jpg",
						"label": "Bytes",
						"html": getIntractiveHtml("snt", { label: "Bytes", icon: "bytes_v2" })
					},
					"SNT21": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/ip_snt_000Ojl_000ob7.jpg",
						"label": "IP",
						"html": getIntractiveHtml("snt", { label: "IP", icon: "ip_v2" })
					},
					"SNT22": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/gp_snt_000OjM_000ob8.jpg",
						"label": "GP",
						"html": getIntractiveHtml("snt", { label: "GP", icon: "gp_v2" })
					},
					"SNT23": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/chain_snt_000Ojm_000ob9.jpg",
						"label": "Chain",
						"html": getIntractiveHtml("snt", { label: "Chain", icon: "chain_v2" })
					},
					"SNT24": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/ethics_snt_000OjN_000ob5.jpg",
						"label": "Ethics",
						"html": getIntractiveHtml("snt", { label: "Ethics", icon: "ethics_v2" })
					},
					"SNT25": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/excercise_snt_000Ojn_000ob6.jpg",
						"label": "Exercise",
						"html": getIntractiveHtml("snt", { label: "Exercise", icon: "exercise_v2" })
					},
					"SNT26": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/spinner_snt_000OjO_000obA.jpg",
						"label": "Spinner",
						"html": getIntractiveHtml("snt", { label: "Spinner", icon: "spinner_v2" })
					},
					"SNT27": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/design_scenario_000Ojo_000ob4.jpg",
						"label": "Design Scenario",
						"html": getIntractiveHtml("snt", {
							label: "Design Scenario",
							icon: "design_v2"
						})
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"editing_type_1": "SNT0|CUSTOM|CALLOUTS,SNT1|CUSTOM|CALLOUTS,SNT2|CUSTOM|CALLOUTS,SNT3|CUSTOM|CALLOUTS,SNT4|CUSTOM|CALLOUTS,SNT5|CUSTOM|CALLOUTS,SNT6|CUSTOM|CALLOUTS,SNT7|CUSTOM|CALLOUTS,SNT8|CUSTOM|CALLOUTS,SNT9|CUSTOM|CALLOUTS,SNT10|CUSTOM|CALLOUTS,SNT11|CUSTOM|CALLOUTS,SNT12|CUSTOM|CALLOUTS,SNT14|CUSTOM|CALLOUTS,SNT15|CUSTOM|CALLOUTS,SNT16|CUSTOM|CALLOUTS,SNT17|CUSTOM|CALLOUTS,SNT18|CUSTOM|CALLOUTS,SNT19|CUSTOM|CALLOUTS,SNT20|CUSTOM|CALLOUTS,SNT21|CUSTOM|CALLOUTS,SNT22|CUSTOM|CALLOUTS,SNT23|CUSTOM|CALLOUTS,SNT24|CUSTOM|CALLOUTS,SNT25|CUSTOM|CALLOUTS,SNT26|CUSTOM|CALLOUTS,SNT27|CUSTOM|CALLOUTS"
					}
				},
				"quotes": {
					"interactive_tags_11": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/quotes_000obB.png",
						"label": l$1.quotes,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='double_quotes relative'><span class='quote_fsize'>&ldquo;</span><span class='ebook_item_text'>PLACE YOUR TEXT HERE</span><span class='quote_fsize absolute'>&rdquo;</span></div></div>"
					}
				},
				"image-annotation": {
					"annotation": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/world_000Oyo_000obd.png",
						"label": "Image Annotation",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='an_c' d-n='0' style='width: 500px;'><div class='an_p' d-w='500' d-i='world_000OVa.png' d-c='0' d-v='1' d-m='0'><figure class='uc-figure'><img src='//s3.amazonaws.com/jigyaasa_content_static/world_000OVa.png' alt='Image Alternative Text ' class='img-bordered'><figcaption class='an_f'>Image Caption</figcaption></figure><svg class='an_svg h' width='100%' height='249'></svg></div></div><div img-anno-desc='d' class='ebook_item_text'></div></div>"
					}
				},
				"image-align": {
					"left_image_align": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/Screenshot_2020-11-13_at_4.34.56_PM_000ozv.png",
						"label": "Left Image Alignment",
						"html": getIntractiveHtml('imageAlign', {
							class: 'left_img1',
							width: '206',
							height: '137',
							caption: '',
							caption_class: 'caption_left1',
							is_center: false
						})
					},
					"right_image_align": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/right_align_000o1O_000obc.png",
						"label": "Right Image Alignment",
						"html": getIntractiveHtml('imageAlign', {
							class: 'right_img1',
							width: '206',
							height: '137',
							caption: '',
							caption_class: 'caption_right1',
							is_center: false
						})
					},
					"center_image_align": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/center_align_000o1l_000obb.png",
						"label": "Center Image Alignment",
						"html": getIntractiveHtml('imageAlign', {
							class: 'center_img1',
							width: '221',
							height: '149',
							caption: '',
							caption_class: 'caption_center1',
							is_center: true
						})
					},
					config: {
						//left_image_shadow_align|left_img2 i_align|.i_align,right_image_shadow_align|right_img2 i_align|.i_align,left_image_caption_align|caption_left1 i_align|.i_align,right_image_caption_align|caption_right1 i_align|.i_align,center_image_shadow_align|center_img2 i_align|.i_align,center_image_caption_align|caption_center1 i_align|.i_align
						"hide": true,
						"editing_type": "1",
						"editing_type_1": "left_image_align|left_img1 i_align|.i_align,right_image_align|right_img1 i_align|.i_align,center_image_align|center_img1 i_align|.i_align"
					}
				},
				"Multicolumn": {
					"interactive_tags_5": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/column_1_000obG.png",
						"label": "Column(For dividing in two columns)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='queue'><div class='prop-lg-6'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div><div class='prop-lg-6'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div></div></div>"
					},
					"division_1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_1_000obH.png",
						"label": "Division into two parts (Type1)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='division1'><span class='ebook_item_text'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/win1.jpg' alt='win1.jpg'/>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networksA computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.</span></div></div>"
					},
					"division_2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_2_000obK.png",
						"label": "Division into two parts (Type2)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='division2'><span class='ebook_item_text'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/win2.jpg' alt='win1.jpg'/>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networksA computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.</span></div></div>"
					},
					"division_3": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_3_000obl.png",
						"label": "Division into three part (Type1)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='division3'><span class='ebook_item_text'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/tab1.jpg' alt='tab1.jpg'/>A computer network is easily via various interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networksA computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.</span></div></div>"
					},
					"division_4": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_4_000obO.png",
						"label": "Division into three parts (Type2)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='division4'><span class='ebook_item_text'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/tab2.jpg' alt='tab2.jpg'/>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networksA computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.</span></div></div>"
					},
					"division_5": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_5_000obo.png",
						"label": "Division into four parts (Type1)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='division5'><span class='ebook_item_text'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/win2.jpg' alt='win1.jpg'/>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networksA computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.</span></div></div>"
					},
					"division_6": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_6_000obN.png",
						"label": "Division into four parts (Type2)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='division6'><span class='ebook_item_text'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/tab2.jpg' alt='tab1.jpg'/>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networksA computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via various means: email, instant messaging, chat rooms, telephone video telephone calls, and video conferencing. Providing access to information on shared storage devices is an important feature of many networks. A network allows sharing of files, data,and other types of information giving authorized users the ability to access information stored on other computers on the network. A network allows sharing of network and computing resources.</span></div></div>"
					},
					"division_7": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_4x8_000obM.png",
						"label": "Division with image and text (4 x 8)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='queue'><div class='prop-lg-4'><center><div class='ebook_item_text'><figure class='uc-figure'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/tab2.jpg' alt='Image1' /><figcaption>Figure 1-2: Image Caption</figcaption></figure></div></center></div><div class='prop-lg-8'><div class='ebook_item_text'>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</div></div></div></div>"
					},
					"division_8": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/division_image_left1_000obh.png",
						"label": "Division with image in left 1",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='left_img1'><div class='ebook_item_text'><figure class='uc-figure'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/tab2.jpg' alt='Image1' /></figure>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</div></div></div>"
					},
					"division_9": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/division_image_left2_000obj.png",
						"label": "Division with image in left 2",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='left_img2'><div class='ebook_item_text'><figure class='uc-figure'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/win2.jpg' alt='Image1' /></figure><div class='link'><b>Heading</div>:</b> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. </div></div></div>"
					},
					"division_12": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/right_000B9Y_000obP.png",
						"label": "Division with image in right 1",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='left_img1'><div class='ebook_item_text'><figure class='float-right'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/tab2.jpg' alt='Image1' class='float-right' /></figure>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</div></div></div>"
					},
					"division_10": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/division_image_right_7x5_000obi.png",
						"label": "Division with image in right 2",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='queue'><div class='ebook_item_text'><div class='prop-lg-7'>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</div><div class='prop-lg-5'><figure class='uc-figure'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/tab2.jpg' alt='Image1' /><figcaption>Figure 1-2: Image Caption</figcaption></figure></div></div></div></div>"
					},
					"interactive_tags_6": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/column_2_000obI.png",
						"label": "For dividing in three columns",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='queue'><div class='prop-md-4'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div><div class='prop-md-4'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div><div class='prop-md-4'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div></div></div>"
					},
					"interactive_tags_7": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/column_3_000obf.png",
						"label": "For dividing in four columns",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='queue'><div class='prop-sm-3'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div><div class='prop-sm-3'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div><div class='prop-sm-3'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div><div class='prop-sm-3'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div></div></div>"
					},
					"interactive_tags_8": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/column_4_000obJ.png",
						"label": "For dividing into columns with a divider line",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='queue'><div class='prop-lg-6 divider'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div><div class='prop-lg-6'><div class='ebook_item_text'>PLACE YOUR TEXT/IMAGE HERE</div></div></div></div>"
					},
					"division_11": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/divisions_7b_000obn.png",
						"label": "List Division",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div class='list_division1'><div class='ebook_item_text'><ul><li>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via varmeans: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing accesinformation on shared storage devices is an important feature of many networksA computer network facilitates interperscommunications</li><li>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via varmeans: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing accesinformation on shared storage devices is an important feature of many networksA computer network facilitates interperscommunications</li><li>A computer network facilitates interpersonal communications allowing users to communicate efficiently and easily via varmeans: email, instant messaging, chat rooms, telephone, video telephone calls, and video conferencing. Providing accesinformation on shared storage devices is an important feature of many networksA computer network facilitates interperscommunications</li></ul></div></div></div>"
					}
				},
				"embed": {
					"Knowledge Check": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/quiz_player_000obT.png",
						"label": "Knowledge Check",
						"html": getIntractiveHtml("player", {
							playerAttr: "category='knowledge_check' type='quiz' "
						})
					},
					"Lab": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/playground_player_000obU.png",
						"label": "Lab",
						"html": getIntractiveHtml("player", {
							playerAttr: "category='lab' type='playground'"
						})
					},
					"Link": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/download_player_000obu.png",
						"label": "Link",
						"html": getIntractiveHtml("player", {
							playerAttr: "category='link' type='download'"
						})
					},
					"Media": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/audio_player_000obV.png",
						"label": "Media",
						"html": getIntractiveHtml("player", {
							playerAttr: "category='media' type='audio'"
						})
					},
					"3D Object": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/insight_player_000obt.png",
						"label": "3D Object",
						"html": getIntractiveHtml("player", {
							playerAttr: "category='objects' type='object3d'"
						})
					},
					"Instruction": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/uc_snt_000obv.png",
						"label": "Instruction",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}' class='ebook_item_text'><snt refid='' data-style=''></snt></div>"
					},
					"Option Reference": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/UC_seq_000obs.png",
						"label": "Option Reference",
						"html": "<div type='ebook-item' sub_type='${itemType}' data-section='${stemClass}' class='ebook_item_text'><seq no=''></seq></div>"
					}
				},
				"Timeline": {
					"timeline": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/time_000obY.png",
						"label": l$1.timeline,
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='timeline' data-type='timeline' class='slide_data pt-3'><section  data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='3' data-top='-39'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section><section data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='3' data-top='-39'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section><section data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='3' data-top='-39'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section><section data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='3' data-top='-39'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section></div></div>"
					},
					"box_timeline": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/Screenshot_2020-09-30_at_8.09.12_AM_000oJk.png",
						"label": "Box Timeline",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='sub_timeline' data-type='timeline' class='slide_data'><ul class='box_timeline w-75 pt-3'><li data-parent='parent_element' ctrl-container='child_prep' data-position='relative' data-top='-26' data-right='9'><div data-child='child_element'><div class='ebook_item_text'>1990</div></div><div class='ebook_item_text'>Quisque ac laoreet purus, eu dapibus ligula. Mauris nec tincidunt mi, eget finibus sem. Morbi viverra.</divc></li><li data-parent='parent_element' ctrl-container='child_prep' data-position='relative' data-top='-26' data-right='9'><div data-child='child_element'><div class='ebook_item_text'>2000</div></div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed sed erat consectetur.</div></li></ul></div></div>"
					},
					"slideshow": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/slide_000obw.png",
						"label": "Box Timeline (Type 2)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='slideshow' data-type='timeline' class='slide_data pt-3'><section class='slider_fade active' data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='2' data-top='-24'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section><section class='slider_fade' data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='2' data-top='-24'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section><section class='slider_fade' data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='2' data-top='-24'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section><section class='slider_fade' data-parent='parent_element' ctrl-container='child_app' data-position='absolute' data-right='2' data-top='-24'><header data-child='child_element' class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</header><article class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit</article></section><a class='slider_prev slider_controls' onclick='changeSlide(this, -1)'>&#10094;</a><a class='slider_next slider_controls' onclick='changeSlide(this, 1)'>&#10095;</a></div></div>"
					},
					"vertical_timeline1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/Screenshot_2020-09-29_at_3.00.12_PM_000oiJ.png",
						"label": "Vertical Timeline (Type 1)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='sub_timeline' data-type='timeline' class='slide_data'><ul class='verticle_timeline'><li data-parent='parent_element' data-elm='li' data-position='absolute' data-top='16' data-right='2'><time class='ebook_item_text' datetime='2013-04-16'>4/16/13 21:30</time><div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div></div></li><li data-parent='parent_element' data-elm='li' data-position='absolute' data-top='16' data-right='2'><time class='ebook_item_text' datetime='2013-04-16 21:30'>4/16/13 21:30</time><div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div></div></li></ul></div></div>"
					},
					"vertical_timeline2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/Screenshot_2020-09-30_at_8.17.16_AM_000oJL.png",
						"label": "Vertical Timeline (Type 2)",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='sub_timeline' data-type='timeline' class='slide_data clearfix'><ul class='verticle_timeline2 w-100'><li data-parent='parent_element' ctrl-container='child_prep' data-position='absolute' data-top='-20' data-right='130'><div data-child='child_element'><div class='ebook_item_text'>9/2/1990</div></div><div class='ebook_item_text'>Quisque ac laoreet purus, eu dapibus ligula. Mauris nec tincidunt mi.</div></li><li data-parent='parent_element' ctrl-container='child_prep' data-position='absolute' data-top='-20' data-right='130'><div data-child='child_element'><div class='ebook_item_text'>9/2/1991</div></div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed sed erat consectetur, tempor odio sit amet.</div></li></ul></div></div>"
					},
					"listing_timeline1": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/Screenshot_2020-09-30_at_6.21.11_PM_000oj8.png",
						"label": "Listing Timeline",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='sub_timeline' data-type='timeline' class='slide_data'><ul class='listing_timeline pt-3'><li data-parent='parent_element' ctrl-container='child_prep' data-position='absolute' data-top='-27' data-right='-58'><div data-child='child_element'><div class='ebook_item_text'>2002</div></div><div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</div></div></li><li data-parent='parent_element' ctrl-container='child_prep' data-position='absolute' data-top='-27' data-right='-58'><div  data-child='child_element'><div class='ebook_item_text'>2003</div></div><div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</div></div></li></ul></div></div>"
					},
					"listing_timeline2": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/Screenshot_2020-09-30_at_6.12.43_PM_000oj6.png",
						"label": "Listing Timeline 2",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='sub_timeline' data-type='timeline' class='slide_data overflow'><div class='horizontal_timeline'><ul class='w-100 overflow pt-3'><li class='mt-3' data-parent='parent_element' ctrl-container='child_prep' data-position='absolute' data-top='-31' data-left='34' data-arrow='2'><div  data-child='child_element'><div class='ebook_item_text'>1990</div></div><div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</div></div></li><li class='mt-3' data-parent='parent_element' ctrl-container='child_prep' data-position='absolute' data-top='-31' data-left='34' data-arrow='2'><div  data-child='child_element'><div class='ebook_item_text'>1991</div></div><div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</div></div></li><li class='mt-3' data-parent='parent_element' ctrl-container='child_prep' data-position='absolute' data-top='-31' data-left='34' data-arrow='2'><div data-child='child_element'><div class='ebook_item_text'>1992</div></div><div><div class='ebook_item_text'>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</div></div></li></ul></div></div></div>"
					},
					"listing_timeline3": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/Screenshot_2020-09-30_at_6.16.19_PM_000oj7.png",
						"label": "Listing Timeline 3",
						"html": "<div data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'><div type='sub_timeline' data-type='timeline' class='slide_data'><div class='fw overflow table-responsive'><div class='timeline timeline-view'><div class='center-block flex'><div class='dot' data-parent='parent_element' data-elm='li' data-position='absolute'  data-right='-52' data-top='6' data-arrow='2'><span class='s3 icomoon-calendar'></span><div></div><section class='align-items-center d-flex justify-content-center'><div class='ebook_item_text'> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</div></section><date class='ebook_item_text'>09/10/2001</date></div><div class='dot' data-parent='parent_element' data-elm='li' data-position='absolute' data-right='-52' data-top='6' data-arrow='2'><span class='s3 icomoon-calendar'></span><div></div><section class='align-items-center d-flex justify-content-center'><div class='ebook_item_text'> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</div></section><date class='ebook_item_text'>09/10/2002</date></div><div class='dot' data-parent='parent_element' data-elm='li' data-position='absolute' data-right='-52' data-top='6' data-arrow='2'><span class='s3 icomoon-calendar'></span><div></div><section class='align-items-center d-flex justify-content-center'><div class='ebook_item_text'> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</div></section><date class='ebook_item_text'>09/10/2003</date></div><div class='dot' data-parent='parent_element' data-elm='li' data-position='absolute' data-right='-52' data-top='6' data-arrow='2'><span class='s3 icomoon-calendar'></span><div></div><section class='align-items-center d-flex justify-content-center'><div class='ebook_item_text'> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</div></section><date class='ebook_item_text'>09/10/2004</date></div></div></div></div></div></div>"
					},
					config: {
						"hide": true,
						"editing_type": "1",
						"editing_change_type": "2",
						"editing_type_1": "timeline|timeline|.slide_data,slideshow|slideshow|.slide_data,vertical_timeline1|verticaltimeline1|.slide_data,vertical_timeline2|verticaltimeline2|.slide_data,box_timeline|boxtimeline|.slide_data,listing_timeline1|listing_timeline1|.slide_data,listing_timeline2|listing_timeline2|.slide_data,listing_timeline3|listing_timeline3|.slide_data"
					}
				},
				"Others": {
					"next_feature": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/addnext_000obX.png",
						"label": "Next Feature",
						"html": "<div type='ebook-item' sub_type='${itemType}' data-section='${stemClass}' class='ebook_item_text'><div class='uc_step_explanation' data-btnnme='Next'><div class='uc_step'>This is Step1</div><div class='uc_step'>This is Step2</div><div class='addnext_caption' data-bs-toggle='tooltip' data-original-title='Enter Button Caption'>Next</div></div></div>"
					},
					"hint_feature": {
						"default_image": "//s3.amazonaws.com/jigyaasa_content_static/hintimage_000obx.png",
						"label": "Hint Feature",
						"html": "<div type='ebook-item' sub_type='${itemType}' data-section='${stemClass}' class='ebook_item_text'><ul class='uc_answer_hint list2'><li>Hint1</li><li>Hint2</li><li>Hint3</li><li>Hint4</li></ul></div>"
					},
					// "sub-slideshow":{
					//     "default_image":"//s3.amazonaws.com/jigyaasa_content_static/time_000obY.png",
					//     "label":"Sub-Slideshow",
					//     "html":"<div type='ebook-item' sub_type='${itemType}' data-section='${stemClass}' class='ebook_item_text'><div type='sub-slideshow' class='slide_data'><section><article><img src='//s3.amazonaws.com/jigyaasa_content_static/interactive_item/paragraph.png' /><br/>Content one</article></section><section><article>Content Two</article></section><section><article><img src='//s3.amazonaws.com/jigyaasa_content_static/interactive_item/paragraph.png'/><br/>Content Three</article></section><section><article>Content Four</article></section></div></div>"
					// },
					config: { "hide": true, "render_tags": true }
				}
			}
		];
	},
	getItemDetails(content_type, subtype, current_item_icon) {
		// get inforamtion from userArray
		if (userArray) {
			let editorItemArray = JSON.parse(userArray);

			if (content_type && subtype) {
				if (current_item_icon) {
					let current_icon_data = editorItemArray.editor_item_type_details[content_type][subtype][current_item_icon];
					return current_icon_data;
				} else {
					let current_icon_group = editorItemArray.editor_item_type_details[content_type][subtype];
					return AH.isValid(current_icon_group) ? current_icon_group : 0;
				}
			} else {
				return editorItemArray.content_sub_type_list_details;
			}
		}

		return null;
	},
	itemList() {
		// Create EditorItems list
		if (userArray) {
			let editorItems = [];
			let editorItemArray = JSON.parse(userArray);
			let allItem = editorItemArray.editor_item_type_details;
			let alphabet = ("a,c,e,f,p,q,s").split(',');

			alphabet.forEach(function (letter) {
				createEditorArray(allItem[alphabet[letter]], editorItems);
			});

			return editorItems;
		}
	},
	shouldWrap(container) {
		// check content is properly wrapped or not
		//let nodes = document.querySelector(container).childNodes;
		let nodes = AH.select(container).childNodes;

		let result = false;

		for (let item of nodes) {
			if (item.nodeType == 3 || !item.getAttribute('data-section') && !item.className.includes('sec_button') && !item.className.includes('sec_button_new')) {
				result = true;
				break;
			}
		}

		return result;
	},
	editorVideo(state) {
		let helpVideo = {
			0: '//player.vimeo.com/external/290348936.hd.mp4?s=a13a32bc22efff0e3b2813f64ee52ab6413166ea'
		};

		return helpVideo[state.item];
	},
	saveButton(state) {
		// Save dialog checkbox array
		let buttons = [
			{
				type: "save",
				label: "Save any unsaved changes",
				// func: (from_myproject == 1 && state.guid.length == 5 && state.course_list) ? self.publishSelected.bind(self) : self.saveData.bind(self, '0'), 
				tooltip: ''
			}
		];

		return buttons;
	},
	checkStage(state) {
		// Stage for current open guid
		let stageLimit = 3;

		if (from_myproject == 1 && AH.isValid(stageArray) && stageArray != "null") {
			editorStage = typeof stageArray == "object"
			? stageArray
			: JSON.parse(stageArray);

			editorStage = editorStage['item_stage'];
			editorStage && (stageLimit = editorStage.length);
		}

		AH.set("stageLimit", stageLimit);
		getItemStage(state);
	},
	stage(sateSeq) {
		// Sate array
		let stage = editorStage || {
			'-1': "Rework",
			0: "Designer",
			1: "SME",
			2: "Editor",
			3: "Reviewer",
			9: "Published",
			'-9': "Viewer",
			'-99': "N/A"
		};

		return stage[sateSeq] || "N/A";
	},
	status() {
		// Save dialog stage status config
		let stage = from_myproject == 1 ? AH.get('stage') : 9;

		let skipLabel = from_myproject == 1 ? "Skip" : "Skip";

		let status = {
			'-1': [
				{
					type: 'rework',
					label: "Discard Item",
					func: 'saveAction',
					permission: true,
					tooltip: 'Change stage to draft and rework.'
				},
				{
					type: 'cancel',
					label: "Cancel",
					func: false,
					permission: true,
					tooltip: 'Cancel the save action and proceed further.'
				},
				{
					type: 'skip',
					label: skipLabel,
					func: 'saveAction',
					permission: true,
					tooltip: 'Save content but not change the stage.'
				},
				{
					type: 'approve',
					label: "Move To Next Stage",
					stage: 1,
					permission: true,
					func: 'saveAction',
					btnBg: "primary",
					tooltip: 'Save and move to stage 1.'
				}
			],
			0: [
				{
					type: 'rework',
					label: "Discard Item",
					func: 'saveAction',
					permission: true,
					tooltip: 'Change stage to draft and rework.'
				},
				{
					type: 'cancel',
					label: "Cancel",
					func: false,
					permission: true,
					tooltip: 'Cancel the save action and proceed further.'
				},
				{
					type: 'skip',
					label: skipLabel,
					func: 'saveAction',
					permission: true,
					tooltip: 'Save content but not change the stage.'
				},
				{
					type: 'approve',
					label: "Move To Next Stage",
					stage: 1,
					permission: true,
					func: 'saveAction',
					btnBg: "primary",
					tooltip: 'Save and move to stage 1.'
				}
			],
			1: [
				{
					type: 'rework',
					label: "Discard Item",
					func: 'saveAction',
					permission: true,
					tooltip: 'Content has issue.'
				},
				{
					type: 'cancel',
					label: "Cancel",
					func: false,
					permission: true,
					tooltip: 'Cancel the save action and proceed further.'
				},
				{
					type: 'skip',
					label: skipLabel,
					func: 'saveAction',
					permission: true,
					tooltip: 'Save content but not change the stage.'
				},
				{
					type: 'approve',
					label: "Move To Next Stage",
					stage: 2,
					permission: true,
					func: 'saveAction',
					btnBg: "primary",
					tooltip: 'Save and move to stage 2.'
				}
			],
			2: [
				{
					type: 'rework',
					label: "Rework",
					permission: true,
					func: 'saveAction',
					tooltip: 'Change stage to draft and rework.'
				},
				{
					type: 'cancel',
					label: "Cancel",
					func: false,
					permission: true,
					tooltip: 'Cancel the save action and proceed further.'
				},
				{
					type: 'skip',
					label: skipLabel,
					func: 'saveAction',
					permission: true,
					tooltip: ''
				},
				{
					type: 'approve',
					label: "Approve",
					func: 'saveAction',
					stage: 3,
					btnBg: "primary",
					permission: true,
					tooltip: 'Save and move to stage 3.'
				}
			],
			3: [
				{
					type: 'rework',
					label: "Rework",
					func: 'saveAction',
					permission: true,
					tooltip: 'Change stage to draft and rework.'
				},
				{
					type: 'cancel',
					label: "Cancel",
					func: false,
					permission: true,
					tooltip: 'Cancel the save action and proceed further.'
				},
				{
					type: 'skip',
					label: skipLabel,
					func: 'saveAction',
					permission: true,
					tooltip: 'Save content but not change the stage.'
				},
				{
					type: 'approve',
					label: "Approve",
					func: 'saveAction',
					stage: 3,
					btnBg: "primary",
					permission: true,
					tooltip: 'Save only.'
				}
			],
			9: [
				{
					type: 'rework',
					label: "Discard Changes",
					func: 'saveAction',
					permission: false,
					tooltip: 'Change stage to draft and rework.'
				},
				{
					type: 'cancel',
					label: "Cancel",
					func: false,
					permission: true,
					tooltip: 'Cancel the save action and proceed further.'
				},
				{
					type: 'skip',
					label: false,
					func: 'saveAction',
					permission: false,
					tooltip: 'Save content but not change the stage.'
				},
				{
					type: 'approve',
					label: "Save",
					func: 'saveAction',
					btnClass: '',
					btnBg: "primary",
					permission: true,
					tooltip: 'Save only.'
				}
			]
		};

		return status[stage] || status[9];
	},
	getWebpageTags(type) {
		// webpage templates
		let tags = {
			'exam': `{# exam_objective_url (Exam objectives URL at vendor website.) #}
            <br /><br />
            {# exam_page_url (Exam page URL at vendor website.) #}
            <br /><br />
            {# exam_validity (Provide url and write short description to find out validity of this exam/certification) #}
            <br /><br />
            {# pre_requisites (free flow give details on prerequisites for the exam: Experience, other certifications or exams ) #}
            <br /><br />
            {# test_provider (exam conducted by) #}
            <br /><br />
            {# questions (Total Number of questions in actual exam.) #}
            <br /><br />
            {# duration (Time to complete the exam) in minutes#}
            <br /><br />
            {# exam_format (Describe exam format, question type question format and if exam is multipart or not. Also add any related notes) #}
            <br /><br />
            {# pass_score (Passing Score for the exam) #}
            <br /><br />
            {# min_score (minimum score in the scale on which exam is measured) #}
            <br /><br />
            {# max_score (maximum score in the scale on which exam is measured) #}
            <br /><br />
            {# exam_retake_policy (what is exam retake policy if you fail)#}
            <br /><br />
            {# exam_fee (exam fees, always in USD)#}
            <br /><br />
            {# exam_fee_notes (additional information about the exam fees )#}
            <br /><br />
            `,
			'examdetails': `{# keywords (Search terms being used by users to search the web for exam)#}
            <br /><br />
            {# about_product_short (typically 3-6 words) #}
            <br /><br />
            {# about_product #}
            <br /><br />
            {# about_exam_short (typically 2-3 sentences) #}
            <br /><br />
            {# about_exam (What is so special and unique about this exams) #}
            <br /><br />
            {# career_prospects (People who pass this exam normally have these job roles/career prospects) #}
            <br /><br />
            {# skills_measured(5-10 bullet points based on skills required.#}
            <br /><br />
            {# related_exams (related exams list)#}
            <br /><br />
            {# related_certification (related certification list)#}
            <br /><br />
            {# course_duration (Course Duration)#}
            <br /><br />
            {# video_tutorial (Video Tutorial)#} 
            <br /><br />
            {# video_thumbnail (Video Thumbnail)#}
            <br /><br /> 
            `
		};

		return tags[type];
	},
	isUnValidItem(state, subtype) {
		// chekcing of invalid item in editor
		if (!subtype && subtype != 0) {
			return true;
		} else if (subtype == "Blank") {
			return true;
		}

		if (AH.get('error') && subtype != 0 && subtype != 8) {
			return true;
		}

		return false;
	},
	isDeepUpdate(subType) {
		// deepUpdate allow for items
		var isDefined = [38, 4, 6, 7, 15, 13, 23, 24, 25, 16, 9, 17, 18, 22, 32, 33, 27, 36, 20];

		if (subType == 'Blank') {
			return true;
		} else {
			return isDefined.indexOf(+subType) != -1 ? true : false;
		}
	},
	setParentData(guid, subtye) {
		// seting instance of editor methods for call outside
		if (AH.isValid(guid) && AH.isValid(subtye)) {
			window.parent.new_guid = guid;
			window.parent.new_content_subtype = subtye;
		}
	},
	escapeSymbols(str = "") {
		// checking entity
		for (let i = 0; i < Object.keys(Symbols).length; i++) {
			let reg = new RegExp(Object.keys(Symbols)[i], "g");
			str = str.replace(reg, Symbols[Object.keys(Symbols)[i]]);
		}

		return str;
	},
	replaceUnwantedEntity(content, clean = false) {
		// valdiate mcq data
		if (AH.isValid(content)) {
			try {
				//@Prabhat: This is to convert the self closing seq tag to explict closing tag.
				// Examples: <seq refid="112" /> to <seq refid="112" ></seq> 
				let self_seq_close = content.match(/<seq(.*?)\s*\/>/g);

				if (self_seq_close) {
					content = content.replace(/<seq(.*?)\s*\/>/g, '<seq$1></seq>');
				}

				let self_snt_close = content.match(/<snt(.*?)\s*\/>/g);

				if (self_snt_close) {
					content = content.replace(/<snt(.*?)\s*\/>/g, '<snt$1></snt>');
				}

				if (clean == 'only_self_close') {
					return content;
				}

				if (clean) {
					content = content.replace(/&#65279;/g, "");

					if (clean == "revert") {
						content = content.replace(/&#160;/g, ' ');
					} else {
						content = content.replace(/> /g, '>&#160;');
					}

					if (clean == "onlyEntity") return content;
				}

				let val = content.match(/<map(.|\n)*?<\/map>/g);

				if (val) {
					val = val[0].replace(/<br \/>/g, '').replace(/<br\/>/g, '').replace(/<br>/g, '').replace(/\n/g, '').replace(/> </g, '><');
					content = content.replace(/<map(.|\n)*?<\/map>/g, val);
				}

				var matches = AH.find(content, ".ebook_item_text", 'all')[0].innerHTML;

				if (AH.isValid(matches) && matches.startsWith("<div>") && matches.endsWith("</div>")) {
					let pattern = matches;
					pattern = matches.replace(/\>\<\/seq\>/g, " \/\>");
					matches = matches.slice(5);
					matches = matches.substring(0, matches.length - 6);
					content = content.replace(pattern, matches);
				}
			} catch(e) {
				console.warn("It seems incorrect active area / cursor position");
			}
		}

		return content;
	},
	preTagTypes: [
		{
			tag: '<pre class="prettyprint black linenums">',
			customTag: '<uc:syntax console="">'
		},
		{
			tag: '<pre class="prettyprint linenums">',
			customTag: '<uc:syntax>'
		},
		{
			tag: '<pre class="prettyprint black linenums">',
			customTag: '<uc:syntax console>'
		},
		{
			tag: '<pre class="prettyprint cmd linenums">',
			customTag: '<uc:syntax command>'
		},
		{
			tag: '<pre class="prettyprint cmd linenums">',
			customTag: '<uc:syntax command="">'
		},
		{
			tag: '<pre class="prettyprint white linenums">',
			customTag: '<uc:syntax white>'
		},
		{
			tag: '<pre class="prettyprint white linenums">',
			customTag: '<uc:syntax white="">'
		},
		{
			tag: '<pre class="prettyprint">',
			customTag: '<uc:syntax hidelinenums>'
		},
		{
			tag: '<pre class="prettyprint">',
			customTag: '<uc:syntax hidelinenums="">'
		},
		{
			tag: '<pre class="prettyprint black">',
			customTag: '<uc:syntax console hidelinenums>'
		},
		{
			tag: '<pre class="prettyprint black">',
			customTag: '<uc:syntax console="" hidelinenums="">'
		},
		{
			tag: '<pre class="prettyprint white">',
			customTag: '<uc:syntax nonum white>'
		},
		{
			tag: '<pre class="prettyprint white">',
			customTag: '<uc:syntax nonum="" white="">'
		},
		{
			tag: '<pre class="prettyprint cmd">',
			customTag: '<uc:syntax command nonum>'
		},
		{
			tag: '<pre class="prettyprint cmd">',
			customTag: '<uc:syntax command="" nonum="">'
		},
		{
			tag: '<pre class="prettyprint linenums hidelinenums">',
			customTag: '<uc:syntax hidelinenums>'
		},
		{
			tag: '<pre class="prettyprint linenums hidelinenums">',
			customTag: '<uc:syntax hidelinenums="">'
		},
		{ tag: '</pre>', customTag: '</uc:syntax>' }
	],
	contextMenuList: "link image resp resp1 | player | addnew",
	toolbaarContext: " code | undo  redo | bold italic underline strikethrough | custom-alignleft custom-aligncenter custom-alignright | nanospell equationeditor mybutton2  mybutton | player",
	editorPlugin(owner) {
		// editor plugin config
		let isContext = owner == ".tinymce-editor" ? false : true;

		//`insertdatetime media table ${ isContext ? 'contextmenu' : ""} paste visualblocks playertag playericon changeInModule res equationeditor`,
		return [
			"placeholder",
			"lists link image",
			"searchreplace code",
			`table ${isContext ? 'contextmenu' : ""} paste playertag changeInModule res equationeditor`,
			"addnewsection",
			"charmap "
		]; //print preview anchor   (was part of this line)
		// fullscreen
	},
	editorTable_class_list: [
		{ title: "None", value: "" },
		{
			title: "Table1",
			value: "uc-table sorttable table1"
		},
		{
			title: "Table2",
			value: "uc-table sorttable table2"
		},
		{
			title: "Table3",
			value: "uc-table sorttable table3"
		},
		{
			title: "Table4",
			value: "uc-table sorttable table4"
		},
		{
			title: "Table5",
			value: "uc-table sorttable table5"
		},
		{
			title: "Table6",
			value: "uc-table sorttable table6"
		},
		{
			title: "Table7",
			value: "uc-table sorttable table7"
		},
		{
			title: "Table8",
			value: "uc-table sorttable table8"
		}
	],
	getSnt(content, state, strForRender) {
		// parse fetched snt from php
		let sntMatch = content
		? content.match(/<snt(.*?)<\/snt>|<snt(.*?)\/>/gmi)
		: "";

		if (sntMatch) {
			for (let i in sntMatch) {
				let refid = sntMatch[i].match(/refid="(.*?)"/gmi);
				refid = refid[0] ? refid[0].replace(/refid=|"/gmi, '') : "";
				sntMatch[i] = sntMatch[i].replace('></snt>', ' />').replace(/data-style="(.*?)"/, 'style="$1"');

				if (refid) {
					let newArray = state.sntTags;
					newArray[refid] = sntMatch[i];
					strForRender += '<<' + refid + sntMatch[i] + '>>';
					updateParent('sntTags', newArray);
				}
			}

			updateParent('strForRender', state.strForRender + strForRender);
		}
	},
	setSnt(content_id, parsedContent, state, previewSnt) {
		// Update snt ids
		let content = document.querySelector(content_id) && document.querySelector(content_id).innerHTML;

		let sntMatch = content ? content.match(/<snt(.*?)<\/snt>/gmi) : "";

		if (sntMatch) {
			for (let i in sntMatch) {
				let refid = sntMatch[i].match(/refid="(.*?)"/gmi);
				refid = refid[0] ? refid[0].replace(/refid=|"/gmi, '') : "";
				let regex = "<<" + refid.trim().toString() + "[\\s\\S]*?>>";
				let match_snt = parsedContent.toString().match(new RegExp(regex, "gim"));

				if (match_snt) {
					match_snt = match_snt[0].replace(/<<(.*?)</gmi, '<').replace(/>>/gmi, '');
					let newArray = state.sntTags;
					newArray[refid] = match_snt;
					updateParent('sntTags', newArray);
				}
			}
		}

		AH.select(content_id).innerHTML = previewSnt(content);
	}
};

function getItemStage(state) {
	// get item's current stage from php side
	if (state.guid) {
		let w = {
			columns: 'content_guid,stage',
			content_guid: state.guid
		};

		AH.getAPIDataJ('cat2.item_content_draft_get', w, async res => {
			if (res && res[state.guid]) {
				AH.set('stage', res[state.guid]['stage']);
			} else {
				AH.set('stage', 9);
			}
		});
	} // AH.ajax({
	//     url: baseUrl + 'editor/index.php',
} //     async: true,
//     data: { 

//         ajax: "1", 
//         action: 'get_item_stage', 
//         content_guid: state.guid,
//     }
// }).then((stage)=> {
//     if (stage) {
//         AH.set('stage', stage);
//         // Need to update parent after it
//     }
// });
function loadTodoMenu() {
	// show todo menu
	//self.handleMenuClose();
	let snippet = "";

	let type = {
		q: "Quiz",
		e: "Exercise",
		l: "Hands On test",
		g: "Glossary",
		f: "FlashCard",
		kc: "Knowledge check",
		t: "Test Prep &amp; Assessment",
		unas: "TBD"
	};

	if (todo_table) {
		let todo = [];
		let table = "";
		let cognitive_level_new = [];
		todo = JSON.parse(todo_table);
		cognitive_level_new = JSON.parse(cognitive_level);
		let todoView = "";

		todo.map(function (data) {
			todoView += `
                        <tr>
                        <td id="snippetVal">-</td>
                        <td>${JSON.parse(data.quote).task_obj}</td>
                        <td>${type[JSON.parse(data.quote).task_item]}</td>
                        <td id="itemTypeVal">-</td>
                        <td>${cognitive_level_new[JSON.parse(data.quote).cognitive_level]}</td>
                        <td>${data.text}</td>
                        <td id="tagsVal">-</td>
                    </tr>`;
		});

		table = `
                <table class="sorttable uc-table table-bordered">
                    <thead>
                        <tr>
                            <th>${l$1.textsnippet}</th>
                            <th>${l$1.sectiondetail}</th>
                            <th>${l$1.item}</th>
                            <th>${l$1.itemType}</th>
                            <th>${l$1.cognitive_level}</th>
                            <th>${l$1.comments}</th>
                            <th>${l$1.tags}</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${todoView}
                    </tbody>
                </table>`;

		AH.activate("2");

		AH.ajax({
			url: baseUrl + 'editor/index.php',
			cache: false,
			data: {
				action: "getTodoData",
				guid: JSON.parse(todo[0]['quote']).task_obj,
				course_code: editor.course
			}
		}).then(response => {
			//$("#todo_table").html(table);
			let modal = {
				header: { body: "Todo Table" },
				body: { body: table },
				footer: { body: [] },
				maxWidth: 'md'
			};

			//self.editorModalUpdate(true);
			handleModal(modal);

			AH.activate(0);
			snippet = JSON.parse(response);
			let arr = snippet;
			snippet = snippet[JSON.parse(todo[0]['quote']).task_obj]['snippet'];
			document.getElementById("snippetVal").innerHTML = snippet;
			let itemType = JSON.parse(todo[0]['quote']).task_type;
			itemType = itemType.split("|");

			try {
				document.getElementById('itemTypeVal').innerHTML = arr[itemType[0]][itemType[1]][itemType[2]]['title'];
			} catch(e) {
				console.warn("Item Type Not Found");
			}

			let tag_val = JSON.parse(todo[0]['quote']).task_tag;
			document.getElementById('tagsVal').innerHTML = arr['tag_snippet'][tag_val];
		});

		return table;
	}
}

function versionControl(flag) {
	updateParent('versionToggle', flag, 'editor');
}

function toggleExam(flag) {
	updateParent('examToggle', flag, 'editor');
}

function versionControlCurrent() {
	window.location = window.location.href.replace(/&get-diff(.*?)$/gmi, '');
}

function toggleDomain(flag) {
	updateParent('domainToggle', flag, 'editor');
}

function vttParser() {
	window.open(baseUrl + "utils/vtt_parser.php", '_blank');
}

function getIntractiveHtml(type, data) {
	// wrap up sections for editable
	let editorAttr = "data-section='${stemClass}' type='ebook-item' sub_type='${itemType}'";

	switch (type) {
		case 'snt':
			return `<div ${editorAttr} class='def_factbox_v2'><div class='title'><span class='fact_icon_v2 ${data.icon}'></span><span data-update='true' class='ebook_item_text'>${data.label}</span></div><div class='fact_description_v2'><div class='ebook_item_text'>PLACE YOUR TEXT HERE</div></div></div>`;
		case 'player':
			return `<div ${editorAttr} class='ebook_item_text'><player ${data.playerAttr}></player></div>`;
		case 'imageAlign':
			return `<div ${editorAttr} class='ebook_item_text'><div class='clearfix i_align ${data.class}'>${data.is_center == true ? text_data : ''}<figure class='uc-figure'><img src='//s3.amazonaws.com/jigyaasa_content_static/ebook_interactivity/images/a.jpg' alt='Write Figure description here' width='${data.width}' height='${data.height}' caption-class='${data.caption_class}' current-class='${data.class}' normal-class='${data.class}'/>${data.caption}</figure>${text_data}</div></div>`;
	}
}

function createControls(config) {
	// section control configs
	let controlList = [
		{
			className: '__move-up',
			title: 'Move Up',
			iconClass: 'icomoon-arrow-up-4'
		},
		{
			className: '__move-down',
			title: 'Move Down',
			iconClass: 'icomoon-arrow-down-4'
		},
		{
			className: '__change-type',
			title: 'Change Type',
			iconClass: 'icomoon-24px-edit-1',
			off: 'text,quotes,image-annotation,Others,Multicolumn'
		},
		{
			className: '__remove',
			title: 'Delete',
			iconClass: 'icomoon-new-24px-delete-1'
		},
		{
			className: '__add',
			title: 'Add',
			iconClass: 'icomoon-new-24px-add-circle-1'
		}
	];

	let links = "";

	controlList.forEach(item => {
		if (!item.off || !item.off.includes(config)) {
			links += `<a href="#" class="block-controls${item.className} ${item.iconClass}" data-bs-toggle="tooltip" title="${item.title}" data-bs-original-title="${item.title}"></a>`;
		}
	});

	return `<div class="block-controls__tools">${links}</div>`;
}

function createEditorArray(allItem, editorItems) {
	// editor's action new item list
	for (let subtype in allItem) {
		for (let icon in allItem[subtype]) {
			let currentItem = allItem[subtype][icon];

			if (is_external == "1") {
				if (currentItem.visible < 1) {
					continue;
				} // Hiding selected item for External users.
			}

			editorItems.push({
				title: currentItem.title,
				icon: currentItem.icon,
				type: currentItem.type,
				subtype: currentItem.subtype,
				content_icon: currentItem.content_icon,
				grading: currentItem.grading,
				category: currentItem.category,
				xml: currentItem.xml,
				group: currentItem.group,
				visible: currentItem.visible,
				inline_item: currentItem.inline_item ? currentItem.inline_item : "0",
				is_algo: currentItem.algo ? currentItem.algo : "0"
			});
		}
	}

	return editorItems;
}

function checkUnWrapped(data, node) {
	// let filter = ("#remediation" == node) ? false : true;
	//let filter = ("#stem" == node) ? false : true;
	// checking content that needed or not wrapping
	let container = document.querySelector(node);

	let wrappedHtml = "";
	let dataBuffer = "";
	let enableRawChecking = false;

	if (container) {
		container.childNodes.forEach((item, index) => {
			if (item.getAttribute && item.getAttribute('data-section')) {
				if (dataBuffer != "") {
					wrappedHtml += `<div data-section="sec_button" type="ebook-item" sub_type="text" class="ebook_item_text">${dataBuffer}</div>`;
					dataBuffer = "";
				}

				wrappedHtml += item.outerHTML;
			} else {
				enableRawChecking = "wrap";

				dataBuffer += AH.isValid(item.outerHTML)
				? item.outerHTML
				: item.textContent;

				if (container.childNodes.length == index + 1) {
					wrappedHtml += `<div data-section="sec_button" type="ebook-item" sub_type="text" class="ebook_item_text">${dataBuffer}</div>`;
					dataBuffer = "";
				}
			}
		});
	}

	if (enableRawChecking == "wrap") {
		data = wrappedHtml;
	} else {
		let reg = new RegExp(/^<div [^\/]+?(?:\".*?\"|'.*?'|.*?)*?>/);
		let res = reg.exec(data);

		if (!res || !res[0].includes('data-section')) {
			data = `<div data-section="sec_button" type="ebook-item" sub_type="text" class="ebook_item_text">${data}</div>`;
		}
	}

	return data;
}

function mathTagCorrection(currentNode) {
	// auto correction for math ml tag
	let convertTags = 'mstyle,mtd';

	return new Promise(resolve => {
			let newChild = false;

			if (currentNode.nodeType == 3) {
				newChild = document.createElement('mo');
			} else if (currentNode.nodeName.startsWith('m') && convertTags.includes(currentNode.nodeName)) {
				if (currentNode.childElementCount < 1) {
					currentNode.innerHTML = "<mo>" + currentNode.innerHTML + "</mo>";
				}
			} else if (!currentNode.nodeName.startsWith('m')) {
				newChild = document.createElement('mtext');
			}

			if (newChild && currentNode.nodeValue.trim().length > 0) {
				newChild.innerHTML = currentNode.nodeValue;
				currentNode.parentNode.replaceChild(newChild, currentNode);
				resolve(newChild);
			} else {
				resolve(currentNode);
			}
		});
}

function getSectionAttr(itemHtml, itemType) {
	// get attributes for content wrappers
	let trackStem = document.querySelector('#stem_show') || document.querySelector('#content_show');

	let stemClass = trackStem && trackStem.childNodes.length > 0
	? "sec_button_new"
	: "sec_button";

	let sectionHtml = itemHtml.replace('${stemClass}', stemClass).replace('${itemType}', itemType);
	return sectionHtml;
}

var nodeFinder = (function () {
	// node traveser for content
	var track,
		origin,
		changeNode = true,
		action = false,
		counter = false,
		round = 0,
		stack = false;

	var treeView = function (node, child, trigger) {
		var currentChild = child;

		if (track == node) {
			try {
				currentChild = trigger ? child : currentChild.nextSibling;
			} catch(e) {
				
			} //console.warn(e);
		} else {
			track = node;
			currentChild = node.firstChild;
		}

		if (currentChild && changeNode) {
			var innerChildCount = currentChild ? currentChild.childElementCount : 0;

			if (innerChildCount >= 1) {
				treeView(currentChild, null, false);
			} else {
				if (action) {
					action(currentChild).then(newChild => {
						treeView(node, newChild, false);
					});
				} else {
					treeView(node, currentChild, false);
				}
			}
		} else if (node != origin) {
			track = node.parentNode;
			treeView(node.parentNode, node, false);
		} else {
			track = null;

			if (round != counter && stack[round]) {
				round = round + 1;
				origin = stack[round];
				treeView(stack[round], null, false);
			}
		}
	};

	var find = function (root, newAction = false) {
		origin = root[0];
		track = null;
		action = newAction;
		counter = root.length;
		round = 0;
		stack = root;
		treeView(root[0], null, false);
	};

	return { find };
})();

// eneity list
const Symbols = {
	"″": "&quote;",
	"“": "&quote;",
	"”": "&quote;",
	"’": "&apos;",
	"′": "&apos;",
	"'": "&apos;",
	"¡": "&iexcl;",
	"¢": "&cent;",
	"£": "&pound;",
	"™": "&#8482;",
	"¤": "&curren;",
	"¥": "&yen;",
	"¦": "&brvbar;",
	"§": "&sect;",
	"¨": "&uml;",
	"©": "&copy;",
	"ª": "&ordf;",
	"«": "&laquo;",
	"¬": "&not;",
	"®": "&reg;",
	"¯": "&macr;",
	"°": "&deg;",
	"±": "&plusmn;",
	"²": "&sup2;",
	"³": "&sup3;",
	"´": "&acute;",
	"µ": "&micro;",
	"¶": "&para;",
	"¸": "&cedil;",
	"¹": "&sup1;",
	"º": "&ordm;",
	"»": "&raquo;",
	"¼": "&frac14;",
	"½": "&frac12;",
	"¾": "&frac34;",
	"¿": "&iquest;",
	"×": "&times;",
	"÷": "&divide;",
	"∀": "&forall;",
	"∂": "&part;",
	"∃": "&exist;",
	"∅": "&empty;",
	"∇": "&nabla;",
	"∈": "&isin;",
	"∉": "&notin;",
	"∋": "&ni;",
	"∏": "&prod;",
	"∑": "&sum;",
	"−": "&minus;",
	"∗": "&lowast;",
	"√": "&radic;",
	"∝": "&prop;",
	"∞": "&infin;",
	"∠": "&ang;",
	"∧": "&and;",
	"∨": "&or;",
	"∩": "&cap;",
	"∪": "&cup;",
	"∫": "&int;",
	"∴": "&there4;",
	"∼": "&sim;",
	"≅": "&cong;",
	"≈": "&asymp;",
	"≠": "&ne;",
	"≡": "&equiv;",
	"≤": "&le;",
	"≥": "&ge;",
	"⊂": "&sub;",
	"⊃": "&sup;",
	"⊄": "&nsub;",
	"⊆": "&sube;",
	"⊇": "&supe;",
	"⊕": "&oplus;",
	"⊗": "&otimes;",
	"⊥": "&perp;",
	"⋅": "&sdot;",
	"Α": "&Alpha;",
	"Β": "&Beta;",
	"Γ": "&Gamma;",
	"Δ": "&Delta;",
	"Ε": "&Epsilon;",
	"Ζ": "&Zeta;",
	"Η": "&Eta;",
	"Θ": "&Theta;",
	"Ι": "&Iota;",
	"Κ": "&Kappa;",
	"Λ": "&Lambda;",
	"Μ": "&Mu;",
	"Ν": "&Nu;",
	"Ξ": "&Xi;",
	"Ο": "&Omicron;",
	"Π": "&Pi;",
	"Ρ": "&Rho;",
	"Σ": "&Sigma;",
	"Τ": "&Tau;",
	"Υ": "&Upsilon;",
	"Φ": "&Phi;",
	"Χ": "&Chi;",
	"Ψ": "&Psi;",
	"Ω": "&Omega;",
	"α": "&alpha;",
	"β": "&beta;",
	"γ": "&gamma;",
	"δ": "&delta;",
	"ε": "&epsilon;",
	"ζ": "&zeta;",
	"η": "&eta;",
	"θ": "&theta;",
	"ι": "&iota;",
	"κ": "&kappa;",
	"λ": "&lambda;",
	"μ": "&mu;",
	"ν": "&nu;",
	"ξ": "&xi;",
	"ο": "&omicron;",
	"π": "&pi;",
	"ρ": "&rho;",
	"ς": "&sigmaf;",
	"σ": "&sigma;",
	"τ": "&tau;",
	"υ": "&upsilon;",
	"φ": "&phi;",
	"χ": "&chi;",
	"ψ": "&psi;",
	"ω": "&omega;",
	"ϑ": "&thetasym;",
	"ϒ": "&upsih;",
	"ϖ": "&piv;",
	"À": "&Agrave;",
	"Á": "&Aacute;",
	"Â": "&Acirc;",
	"Ã": "&Atilde;",
	"Ä": "&Auml;",
	"Å": "&Aring;",
	"Æ": "&AElig;",
	"Ç": "&Ccedil;",
	"È": "&Egrave;",
	"É": "&Eacute;",
	"Ê": "&Ecirc;",
	"Ë": "&Euml;",
	"Ì": "&Igrave;",
	"Í": "&Iacute;",
	"Î": "&Icirc;",
	"Ï": "&Iuml;",
	"Ð": "&ETH;",
	"Ñ": "&Ntilde;",
	"Ò": "&Ograve;",
	"Ó": "&Oacute;",
	"Ô": "&Ocirc;",
	"Õ": "&Otilde;",
	"Ö": "&Ouml;",
	"Ø": "&Oslash;",
	"Ù": "&Ugrave;",
	"Ú": "&Uacute;",
	"Û": "&Ucirc;",
	"Ü": "&Uuml;",
	"Ý": "&Yacute;",
	"Þ": "&THORN;",
	"ß": "&szlig;",
	"à": "&agrave;",
	"á": "&aacute;",
	"â": "&acirc;",
	"ã": "&atilde;",
	"ä": "&auml;",
	"å": "&aring;",
	"æ": "&aelig;",
	"ç": "&ccedil;",
	"è": "&egrave;",
	"é": "&eacute;",
	"ê": "&ecirc;",
	"ë": "&euml;",
	"ì": "&igrave;",
	"í": "&iacute;",
	"î": "&icirc;",
	"ï": "&iuml;",
	"ð": "&eth;",
	"ñ": "&ntilde;",
	"ò": "&ograve;",
	"ó": "&oacute;",
	"ô": "&ocirc;",
	"õ": "&otilde;",
	"ö": "&ouml;",
	"ø": "&oslash;",
	"ù": "&ugrave;",
	"ú": "&uacute;",
	"û": "&ucirc;",
	"ü": "&uuml;",
	"ý": "&yacute;",
	"þ": "&thorn;",
	"ÿ": "&yuml;"
};

/* src\ucEditor.svelte generated by Svelte v3.40.2 */

let editorConfig$1 = false;

const ucEditor = {
	getContent(selector, format = "default") {
		if (tinyMCE) {
			try {
				switch (format) {
					case 'default':
						return tinyMCE.editors[document.getElementById(selector).getAttribute('id')].getContent();
					default:
						return tinyMCE.editors[document.getElementById(selector).getAttribute('id')].getContent({ format: 'raw' });
				}
			} catch(error) {
				console.log(error);
			}
		} else {
			console.log("TinyMCE is not found.");
		}
	},
	insertContent(insertData, format = "default") {
		if (tinyMCE) {
			switch (format) {
				case 'default':
					return tinyMCE.activeEditor.insertContent(insertData);
				default:
					return tinyMCE.activeEditor.insertContent(insertData, { format });
			}
		} else {
			console.log("TinyMCE is not found.");
		}
	},
	initEditor(forPreview, selector = ".tinymce-editor") {
		forPreview = forPreview || false;
		let d = new Date();

		//selector = selector || ".tinymce-editor";
		tinymce.init({
			selector,
			inline: true,
			theme: "modern",
			resize: true,
			menubar: false,
			toolbar: false,
			elementpath: false,
			statusbar: false,
			convert_urls: false, // For not let tinymce change url
			relative_urls: false, // For not let tinymce change url
			forced_root_block: false,
			extended_valid_elements: "uc:syntax[id|class|num|nonum|white|console|hidelinenums]", // For know tinymce that it is valid tags and attrs
			custom_elements: "uc:syntax", // For know tinymce that it is valid tags
			closed: /^(br|hr|input|meta|img|link|param|area|seq|snt)$/,
			preformatted: true,
			entity_encoding: "numeric",
			valid_elements: "*[*]",
			readonly: forPreview ? true : false,
			fixed_toolbar_container: forPreview
			? "#toolbar_container_preview"
			: "#toolbar_container",
			visualblocks_default_state: false,
			external_plugins: { nanospell: "../lib/nanospell/plugin.js" },
			nanospell_server: "php", // choose "php" "asp" "asp.net" or "java"
			nanospell_ignore_char: "var",
			nanospell_ignore_block_caps: true,
			nanospell_autostart: false,
			paste_as_text: true,
			link_title: false,
			formats: {
				bold: { inline: "b" },
				italic: { inline: "i" }
			},
			setup(editor) {
				if (document.getElementById(editor.id) && document.getElementById(editor.id).getAttribute("readonly")) {
					editor.settings.readonly = true;
				}

				//@TODO:? @abhishek can we use array to add all the button and options
				editor.addButton("custom-alignleft", {
					icon: l$1.alignleft,
					onclick() {
						let selectNode = tinyMCE.activeEditor.selection.getNode();

						if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == selectNode.innerHTML) {
							if (selectNode.classList.contains("ebook_item_text")) {
								AH.alert(l$1.align_content_message);
							} else {
								editor.execCommand("mceToggleFormat", false, "alignleft");
							}
						} else {
							if (tinyMCE.activeEditor.selection.getNode().nodeName == "IMG" && selectNode.parents('.uc-figure')[0]) {
								selectNode.parents('.uc-figure').css({ 'text-align': 'left' });
							} else {
								editor.execCommand("mceToggleFormat", false, "div");
								editor.execCommand("mceToggleFormat", false, "alignleft");
							}
						}
					}
				});

				editor.addButton("custom-aligncenter", {
					icon: l$1.aligncenter,
					onclick() {
						let selectedNode = tinyMCE.activeEditor.selection.getNode();

						if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == tinyMCE.activeEditor.selection.getNode().innerHTML) {
							if (selectedNode?.classList?.value.includes("ebook_item_text")) {
								AH.alert("Please select content first.");
							} else {
								editor.execCommand("mceToggleFormat", false, "aligncenter");
							}
						} else {
							//AH.alert(l.align_content_message);
							if (tinyMCE.activeEditor.selection.getNode().nodeName == "IMG" && AH.parent(selectedNode, '.uc-figure')) {
								AH.parent(selectedNode, '.uc-figure').style.textAlign = 'center';
							} else {
								editor.execCommand("mceToggleFormat", false, "div");
								editor.execCommand("mceToggleFormat", false, "aligncenter");
							}
						}
					}
				});

				editor.addButton("custom-alignright", {
					icon: l$1.alignright,
					onclick() {
						let selectedNode = tinyMCE.activeEditor.selection.getNode();

						if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == tinyMCE.activeEditor.selection.getNode().innerHTML) {
							if (selectedNode.classList.contains("ebook_item_text")) {
								AH.alert("Please select content first.");
							} else {
								editor.execCommand("mceToggleFormat", false, "alignright");
							}
						} else {
							if (tinyMCE.activeEditor.selection.getNode().nodeName == "IMG" && AH.parent(selectedNode, '.uc-figure')) {
								AH.parent(selectedNode, '.uc-figure').style.textAlign = 'right';
							} else {
								editor.execCommand("mceToggleFormat", false, "div");
								editor.execCommand("mceToggleFormat", false, "alignright");
							}
						}
					}
				});

				editor.addButton("mybutton2", {
					text: l$1.formats,
					type: "menubutton",
					icon: false,
					menu: [
						{
							text: l$1.inline,
							icon: l$1.inlineAlign,
							menu: [
								{
									text: l$1.bold,
									icon: l$1.bits,
									onclick() {
										editor.execCommand("mceToggleFormat", false, "bold");
									}
								},
								{
									text: l$1.italic,
									icon: l$1.italics,
									onclick() {
										editor.execCommand("mceToggleFormat", false, "italic");
									}
								},
								{
									text: l$1.underline,
									icon: l$1.underlines,
									onclick() {
										editor.execCommand("mceToggleFormat", false, "underline");
									}
								},
								{
									text: l$1.strikethrough,
									icon: l$1.strikethroughs,
									onclick() {
										editor.execCommand("mceToggleFormat", false, "strikethrough");
									}
								},
								{
									text: l$1.superscript,
									icon: l$1.superscripts,
									onclick() {
										editor.execCommand("mceToggleFormat", false, "superscript");
									}
								},
								{
									text: l$1.subscript,
									icon: l$1.subscripts,
									onclick() {
										editor.execCommand("mceToggleFormat", false, "subscript");
									}
								},
								{
									text: l$1.small,
									icon: l$1.smalls,
									onclick() {
										tinymce.activeEditor.formatter.register("customsmallformat", { inline: "small" });
										tinymce.activeEditor.formatter.apply("customsmallformat");
									}
								}
							]
						},
						{
							text: l$1.heading,
							icon: l$1.headings,
							menu: [
								{
									text: l$1.heading1,
									onclick() {
										registerFormatter("h1"); // tinymce.activeEditor.formatter.register("customh1", {
										//   inline: "h1"

										toggleFormat("h1");
									}, // tinymce.activeEditor.formatter.register("customh1", {
									// });
									
								},
								{
									text: l$1.heading2, // tinymce.activeEditor.formatter.toggle("customh1");
									onclick() {
										registerFormatter("h2"); // tinymce.activeEditor.formatter.register("customh2", {
										//   inline: "h2"

										toggleFormat("h2");
									}, // tinymce.activeEditor.formatter.register("customh2", {
									// });
									
								},
								{
									text: l$1.heading3, // tinymce.activeEditor.formatter.toggle("customh2");
									onclick() {
										registerFormatter("h3"); // tinymce.activeEditor.formatter.register("customh3", {
										//   inline: "h3"

										toggleFormat("h3");
									}, // tinymce.activeEditor.formatter.register("customh3", {
									// });
									
								},
								{
									text: l$1.heading4, // tinymce.activeEditor.formatter.toggle("customh3");
									onclick() {
										registerFormatter("h4");
										toggleFormat("h4");
									}
								},
								{
									text: l$1.heading5,
									onclick() {
										registerFormatter("h5");
										toggleFormat("h5");
									}
								},
								{
									text: l$1.heading6,
									onclick() {
										registerFormatter("h6");
										toggleFormat("h6");
									}
								},
								{
									text: l$1.newspaper,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										// editor.insertContent('<div style="line-height:140%"><span class="newspaper_font">' + selected + '</span></div>');
										editor.insertContent('<span class="font40 toll-num">' + selected + "</span>");
									}
								}
							]
						},
						{
							text: l$1.blocks,
							icon: l$1.block,
							menu: [
								{
									text: l$1.para,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);
										var selected = "";

										if (editor.selection.getContent() == "") {
											selected += " ";
										} else {
											selected += editor.selection.getContent();
										}

										editor.insertContent('<p>' + selected + "</p>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.div,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);
										var selected = "";

										if (editor.selection.getContent() == "") {
											selected += " ";
										} else {
											selected += editor.selection.getContent();
										}

										editor.insertContent('<div>' + selected + "</div>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.block,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);
										var selected = "";

										if (editor.selection.getContent() == "") {
											selected += " ";
										} else {
											selected += editor.selection.getContent();
										}

										editor.insertContent('<blockquote>' + selected + "</blockquote>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.code,
									onclick() {
										tinymce.activeEditor.formatter.register("codeformat", {
											inline: "code",
											remove: "all",
											styles: { display: "inline" }
										});

										editor.execCommand("mceToggleFormat", false, "codeformat");
									}
								},
								{
									text: l$1.insnote,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);
										var selected = "Instructor Note: ";

										if (editor.selection.getContent() == "") {
											selected += " ";
										} else {
											selected += editor.selection.getContent();
										}

										editor.insertContent('<div class="ins_note">' + selected + "</div>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.insans,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										editor.insertContent('<div class="ins_ans space-15">' + selected + "</div>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								}
							]
						},
						{
							text: l$1.alignment,
							icon: l$1.alginments,
							menu: [
								{
									text: l$1.left,
									icon: l$1.alignleft,
									onclick() {
										let currNode = tinyMCE.activeEditor.selection.getNode();

										if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == currNode.innerHTML) {
											if (currNode.classList.contains("ebook_item_text")) {
												AH.alert(l$1.align_content_message);
											} else {
												editor.execCommand("mceToggleFormat", false, "alignleft");
											}
										} else {
											AH.alert(l$1.align_content_message);
										}
									}
								},
								{
									text: l$1.center,
									icon: l$1.aligncenter,
									onclick() {
										let currNode = tinyMCE.activeEditor.selection.getNode();

										if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == currNode.innerHTML) {
											if (currNode.classList.contains("ebook_item_text")) {
												AH.alert(l$1.align_content_message);
											} else {
												editor.execCommand("mceToggleFormat", false, "aligncenter");
											}
										} else {
											AH.alert(l$1.align_content_message);
										}
									}
								},
								{
									text: l$1.right,
									icon: l$1.alignright,
									onclick() {
										let currNode = tinyMCE.activeEditor.selection.getNode();

										if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == currNode.innerHTML) {
											if (currNode.classList.contains("ebook_item_text")) {
												AH.alert(l$1.align_content_message);
											} else {
												editor.execCommand("mceToggleFormat", false, "alignright");
											}
										} else {
											AH.alert(l$1.align_content_message);
										}
									}
								},
								{
									text: l$1.justify,
									icon: l$1.alignjustify,
									onclick() {
										let currNode = tinyMCE.activeEditor.selection.getNode();

										if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == currNode.innerHTML) {
											if (currNode.classList.contains("ebook_item_text")) {
												AH.alert(l$1.align_content_message);
											} else {
												editor.execCommand("mceToggleFormat", false, "alignjustify");
											}
										} else {
											AH.alert(l$1.align_content_message);
										}
									}
								}
							]
						},
						{
							text: l$1.cases,
							icon: l$1.case,
							menu: [
								{
									text: l$1.uppercase,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										selected = selected.toUpperCase();
										tinyMCE.activeEditor.execCommand("mceInsertContent", false, "<span>" + selected + "</span>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.lowercase,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										selected = selected.toLowerCase();
										tinyMCE.activeEditor.execCommand("mceInsertContent", false, "<span>" + selected + "</span>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.titlecase,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										//selected = selected.toLowerCase();
										selected = selected.replace(/\w\S*/g, function (txt) {
											return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
										});

										tinyMCE.activeEditor.execCommand("mceInsertContent", false, "<span>" + selected + "</span>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.sentence_case,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										selected = selected.charAt(0).toUpperCase() + selected.substr(1).toLowerCase();
										tinyMCE.activeEditor.execCommand("mceInsertContent", false, "<span>" + selected + "</span>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								},
								{
									text: l$1.toggle_case,
									onclick() {
										editor.focus();
										var bookmark = tinymce.activeEditor.selection.getBookmark(2, true);

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										const UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
										const LOWER = "abcdefghijklmnopqrstuvwxyz";
										const result = [];

										for (let x = 0; x < selected.length; x++) {
											if (UPPER.includes(selected[x])) {
												result.push(selected[x].toLowerCase());
											} else if (LOWER.includes(selected[x])) {
												result.push(selected[x].toUpperCase());
											} else {
												result.push(selected[x]);
											}
										}

										tinyMCE.activeEditor.execCommand("mceInsertContent", false, "<span>" + result.join("") + "</span>");
										tinymce.activeEditor.selection.moveToBookmark(bookmark);
									}
								}
							]
						},
						{
							text: l$1.color,
							icon: l$1.colors,
							menu: [
								{
									text: l$1.blue_color,
									icon: l$1.bsuccess,
									onclick() {
										tinymce.activeEditor.formatter.register("blue", {
											inline: "span",
											styles: { color: "#007bff" }
										});

										tinymce.activeEditor.formatter.apply("blue");
									}
								},
								{
									text: l$1.orange_color,
									icon: l$1.bwarning,
									onclick() {
										tinymce.activeEditor.formatter.register("orange", {
											inline: "span",
											styles: { color: "#ffc107" }
										});

										tinymce.activeEditor.formatter.apply("orange");
									}
								},
								{
									text: l$1.red_color,
									icon: l$1.bdanger,
									onclick() {
										tinymce.activeEditor.formatter.register("red", {
											inline: "span",
											styles: { color: "#dc3545" }
										});

										tinymce.activeEditor.formatter.apply("red");
									}
								},
								{
									text: l$1.white,
									icon: l$1.bwhite,
									onclick() {
										tinymce.activeEditor.formatter.register("white", {
											inline: "span",
											styles: { color: "#fff" }
										});

										tinymce.activeEditor.formatter.apply("white");
									}
								},
								{
									text: l$1.green,
									icon: l$1.bgreen,
									onclick() {
										tinymce.activeEditor.formatter.register("green", {
											inline: "span",
											styles: { color: "green" }
										});

										tinymce.activeEditor.formatter.apply("green");
									}
								},
								{
									text: l$1.golden_brown_color,
									icon: l$1.borange,
									onclick() {
										tinymce.activeEditor.formatter.register("golden-brown", {
											inline: "span",
											styles: { color: "#f89406" }
										});

										tinymce.activeEditor.formatter.apply("golden-brown");
									}
								},
								{
									text: l$1.black_color,
									icon: "b-black",
									onclick() {
										tinymce.activeEditor.formatter.register("black", {
											inline: "span",
											styles: { color: "#000" }
										});

										tinymce.activeEditor.formatter.apply("black");
									}
								}
							]
						},
						{
							text: l$1.bgcolor,
							icon: l$1.background,
							menu: [
								{
									text: l$1.green_color,
									icon: "bg-success",
									onclick() {
										tinymce.activeEditor.formatter.register("bg-green", {
											inline: "span",
											styles: {
												"background-color": "#28a745",
												color: "#000"
											}, // 'border-radius' : "3px",
											// 'padding' : "0 5px"
											
										});

										tinymce.activeEditor.formatter.apply("bg-green");
									}
								},
								{
									text: l$1.cyan_color,
									icon: l$1.binfo,
									onclick() {
										tinymce.activeEditor.formatter.register("bg-cyan", {
											inline: "span",
											styles: {
												"background-color": "#17a2b8",
												color: "#000"
											}, // 'border-radius' : "3px",
											// 'padding' : "0 5px"
											
										});

										tinymce.activeEditor.formatter.apply("bg-cyan");
									}
								},
								{
									text: l$1.blue_color,
									icon: l$1.bprimary,
									onclick() {
										tinymce.activeEditor.formatter.register("bg-blue", {
											inline: "span",
											styles: {
												"background-color": "#007bff",
												color: "#000"
											}, // 'border-radius' : "3px",
											// 'padding' : "0 5px"
											
										});

										tinymce.activeEditor.formatter.apply("bg-blue");
									}
								},
								{
									text: l$1.red_color,
									icon: l$1.bdanger,
									onclick() {
										tinymce.activeEditor.formatter.register("bg-red", {
											inline: "span",
											styles: {
												"background-color": "#dc3545",
												color: "#000"
											}, // 'border-radius' : "3px",
											// 'padding' : "0 5px"
											
										});

										tinymce.activeEditor.formatter.apply("bg-red");
									}
								},
								{
									text: l$1.orange_color,
									icon: l$1.bwarning,
									onclick() {
										tinymce.activeEditor.formatter.register("bg-orange", {
											inline: "span",
											styles: {
												"background-color": "#ffc107",
												color: "#000"
											}, // 'border-radius' : "3px",
											// 'padding' : "0 5px"
											
										});

										tinymce.activeEditor.formatter.apply("bg-orange");
									}
								},
								{
									text: l$1.black_color,
									icon: "b-black",
									onclick() {
										tinymce.activeEditor.formatter.register("bg-black", {
											inline: "span",
											styles: {
												"background-color": "#343a40",
												color: "#fff"
											}, // 'border-radius' : "3px",
											// 'padding' : "0 5px"
											
										});

										tinymce.activeEditor.formatter.apply("bg-black");
									}
								},
								{
									text: l$1.white,
									icon: "b-white",
									onclick() {
										tinymce.activeEditor.formatter.register("bg-white", {
											inline: "span",
											styles: {
												"background-color": "#fff",
												color: "#000"
											}
										});

										tinymce.activeEditor.formatter.apply("bg-white");
									}
								}
							]
						},
						{
							text: l$1.list,
							icon: l$1.lists,
							menu: [
								{
									text: l$1.numlist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											let tag_html = tag_parent.innerHTML;
											AH.replaceWith(tag_parent, "<ol>" + tag_html + "</ol>");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent("<ol>");

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ol>");
										}
									}
								},
								{
									text: l$1.alphlist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("class", "alpha-order ");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="alpha-order ">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.romanlist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("type", "I");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ol type="I">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ol>");
										}
									}
								},
								{
									text: l$1.numalphlist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											let tag_html = tag_parent.innerHTML;
											AH.replaceWith(tag_parent, '<ol nested="alpha-order">' + tag_html + "</ol>");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ol nested="alpha-order">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ol>");
										}
									}
								},
								{
									text: l$1.bullist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											let tag_html = tag_parent.innerHTML;
											AH.replaceWith(tag_parent, "<ul>" + tag_html + "</ul>");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent("<ul>");

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.blarlist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											tag_parent.setAttribute("class", "arrowlist-bullet");
											tag_parent.setAttribute("nested", "arrow-bullet,circle-bullet darkblue-txt");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul nested="arrow-bullet,circle-bullet darkblue-txt" class="arrowlist-bullet">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.bluearlist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											tag_parent.setAttribute("class", "arrow-bullet");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="arrow-bullet">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.blarbullet,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											tag_parent.setAttribute("class", "arrow-bullet arrow-bullet-list");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="arrow-bullet arrow-bullet-list">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.blcrcbbullet,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											tag_parent.setAttribute("class", "circle-bullet darkblue-txt");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="circle-bullet darkblue-txt">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.bcbwbt,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											tag_parent.setAttribute("class", "circle-bullet ");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="circle-bullet ">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.whcrclist,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											tag_parent.setAttribute("class", "whitecircle-list la");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="whitecircle-list la ">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.tickbull,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											tag_parent.setAttribute("class", "tick-bullet");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="tick-bullet">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.withoutBullet,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent.length > 0) {
											let tag_html = tag_parent.innerHTML;
											AH.replaceWith(tag_parent, "<ul class='list_nostyle'>" + tag_html + "</ul>");
										} else {
											var selected = editor.selection.getContent() == ""
											? "Place your Text here"
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent("<ul class='list_nostyle'>");

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.listtype1,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("class", "list1");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="list1">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.listtype2,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("class", "list2");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="list2">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.listtype3,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("class", "list3");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="list3">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.listtype4,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("class", "list4");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="list4 ">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.listtype5,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("class", "list5");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="list5">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								},
								{
									text: l$1.listtype6,
									onclick() {
										editor.focus();
										let tag = tinyMCE.activeEditor.selection.getNode();
										let tag_parent = getParent(tag);

										if (tag_parent) {
											tag_parent.setAttribute("class", "list6");
										} else {
											var selected = editor.selection.getContent() == ""
											? " "
											: editor.selection.getContent();

											selected = selected.split("<br />");
											editor.selection.setContent('<ul class="list6 ">');

											selected.map(function (data) {
												editor.selection.setContent("<li>" + data + "</li>");
											});

											editor.selection.setContent("</ul>");
										}
									}
								}
							]
						},
						{
							text: l$1.table,
							icon: l$1.tables,
							menu: createTable(editor, tinyMCE)
						},
						{
							text: l$1.box,
							icon: l$1.boxes,
							menu: [
								{
									text: l$1.panelblue,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										editor.selection.setContent('<div class="box1">' + selected + "</div> ");
									}
								},
								{
									text: l$1.panelgreen,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										editor.selection.setContent('<div class="box2">' + selected + "</div> ");
									}
								},
								{
									text: l$1.panelsky,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										editor.selection.setContent('<div class="box3">' + selected + "</div> ");
									}
								},
								{
									text: l$1.panelgrad,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										editor.selection.setContent('<div class="box4">' + selected + "</div> ");
									}
								},
								{
									text: l$1.blockgrey,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? " "
										: editor.selection.getContent();

										editor.selection.setContent('<div class="box5">' + selected + "</div> ");
									}
								}
							]
						},
						{
							text: l$1.symbols,
							icon: l$1.symbol,
							onclick() {
								editor.focus();
								tinyMCE.activeEditor.execCommand("mceShowCharmap");
							}
						},
						{
							text: l$1.ucsyntax,
							icon: l$1.ucsyntaxes,
							menu: [
								{
									text: l$1.uc_syntax_format1,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? l$1.dummyText
										: editor.selection.getContent();

										editor.selection.setContent('<uc:syntax white="">' + selected + "</uc:syntax>");
										editor.fire("change");
									}
								},
								{
									text: l$1.uc_syntax_format2,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? l$1.dummyText
										: editor.selection.getContent();

										editor.selection.setContent('<uc:syntax hidelinenums="">' + selected + "</uc:syntax>");
										editor.fire("change");
									}
								},
								{
									text: l$1.uc_syntax_format3,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? l$1.dummyText
										: editor.selection.getContent();

										editor.selection.setContent('<uc:syntax console="">' + selected + "</uc:syntax>");
										editor.fire("change");
									}
								},
								{
									text: l$1.uc_syntax_format4,
									onclick() {
										editor.focus();

										var selected = editor.selection.getContent() == ""
										? l$1.dummyText
										: editor.selection.getContent();

										editor.selection.setContent(`<uc:syntax console="" hidelinenums="">${selected}</uc:syntax>`);
										editor.fire("change");
									}
								}
							]
						},
						{
							text: "UC Feedback",
							icon: l$1.ucfeed,
							onclick() {
								editor.focus();

								var selected = editor.selection.getContent() == ""
								? " "
								: editor.selection.getContent();

								editor.selection.setContent("<ucfeedback>" + selected + "</ucfeedback>");
								editor.fire("change");
							}
						},
						{ text: "|" },
						{
							text: l$1.indentation,
							icon: l$1.outdent,
							onclick() {
								if (tinyMCE.activeEditor.selection.getSel().anchorNode.textContent == tinyMCE.activeEditor.selection.getNode().innerHTML) {
									if (tinyMCE.activeEditor.selection.getNode().classList.contains("ebook_item_text")) {
										AH.showmsg("Wrap your text in block element to indent");
									} else {
										tinyMCE.activeEditor.dom.toggleClass(tinyMCE.activeEditor.selection.getNode(), "indent_pad");
									}
								} else {
									AH.showmsg(l$1.wrap_text);
								}
							}
						},
						{
							text: l$1.clear_formatting,
							icon: l$1.removeformat,
							onclick() {
								editor.formatter.remove("removeformat");
							}
						}
					]
				});

				editor.on("focus", function () {
					tinymce.EditorManager.execCommand("mceVisualBlocks", false);
				});

				editor.on("blur", function () {
					
				}); //@saquib: focus issue
				//tinymce.EditorManager.execCommand('mceVisualBlocks', true);
			},
			table_default_styles: { width: "100%", height: "100%" },
			plugins: editorConfig$1.editorPlugin(selector),
			table_class_list: editorConfig$1.editorTable_class_list,
			contextmenu: editorConfig$1.contextMenuList,
			toolbar1: editorConfig$1.toolbaarContext,
			cache_suffix: '?v=' + d.getDate()
		});
	},
	setConfig(ref) {
		editorConfig$1 = ref;
	},
	initEditorFeatures() {
		
	}
};

function createTable(editor, tinyMCE) {
	var editorTable = editorConfig$1.editorTable(l$1);
	var tableList = [];

	editorTable.forEach(item => {
		tableList.push({
			text: item.text,
			onclick() {
				editor.focus();
				tinyMCE.activeEditor.execCommand("mceInsertContent", false, item.html);
			}
		});
	});

	//@TODO:? @abhishek we should create array same as interactive_item.js to define table, 
	return tableList;
}

function toggleFormat(name) {
	tinymce.activeEditor.formatter.toggle("custom" + name);
}

function removeformat(name) {
	tinymce.activeEditor.formatter.remove("custom" + name);
}

function canApply(name) {
	return tinymce.activeEditor.formatter.canApply("custom" + name);
}

function registerFormatter(name) {
	["h1", "h2", "h3", "h4", "h5", "h6"].forEach(formatName => {
		if (canApply(formatName)) {
			removeformat(formatName);
		}
	});

	tinymce.activeEditor.formatter.register("custom" + name, { inline: name });
}

/* src\EditorHeader.svelte generated by Svelte v3.40.2 */

const { console: console_1$2 } = globals;
const file$d = "src\\EditorHeader.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[46] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[49] = list[i];
	child_ctx[51] = i;
	return child_ctx;
}

// (445:28) {#if menuData.view}
function create_if_block_10(ctx) {
	let menuitem;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[30](/*menuData*/ ctx[49]);
	}

	menuitem = new Menuitem({
			props: {
				key: /*menuData*/ ctx[49].id,
				class: "font15",
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem.$on("click", click_handler);

	const block = {
		c: function create() {
			create_component(menuitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(menuitem, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const menuitem_changes = {};
			if (dirty[0] & /*toolMenu*/ 2) menuitem_changes.key = /*menuData*/ ctx[49].id;

			if (dirty[0] & /*toolMenu*/ 2 | dirty[1] & /*$$scope*/ 2097152) {
				menuitem_changes.$$scope = { dirty, ctx };
			}

			menuitem.$set(menuitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(menuitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(445:28) {#if menuData.view}",
		ctx
	});

	return block;
}

// (446:32) <Menuitem key={menuData.id} on:click={()=>menuData.funcName()} class="font15">
function create_default_slot_18(ctx) {
	let t_value = /*menuData*/ ctx[49].label + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*toolMenu*/ 2 && t_value !== (t_value = /*menuData*/ ctx[49].label + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(446:32) <Menuitem key={menuData.id} on:click={()=>menuData.funcName()} class=\\\"font15\\\">",
		ctx
	});

	return block;
}

// (444:24) {#each toolMenu as menuData, i (menuData.id)}
function create_each_block_1(key_1, ctx) {
	let first;
	let if_block_anchor;
	let current;
	let if_block = /*menuData*/ ctx[49].view && create_if_block_10(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*menuData*/ ctx[49].view) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*toolMenu*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(444:24) {#each toolMenu as menuData, i (menuData.id)}",
		ctx
	});

	return block;
}

// (451:24) {:else}
function create_else_block_1(ctx) {
	let menuitem;
	let current;

	menuitem = new Menuitem({
			props: {
				key: "toggleAlgo",
				class: "font15",
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem.$on("click", function () {
		if (is_function(/*handleCheckbox*/ ctx[2])) /*handleCheckbox*/ ctx[2].apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(menuitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(menuitem, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const menuitem_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem_changes.$$scope = { dirty, ctx };
			}

			menuitem.$set(menuitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(menuitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(451:24) {:else}",
		ctx
	});

	return block;
}

// (449:24) {#if editorState.variable_button}
function create_if_block_9(ctx) {
	let menuitem;
	let current;

	menuitem = new Menuitem({
			props: {
				key: "ditAlgo",
				class: "font15",
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem.$on("click", function () {
		if (is_function(/*editAlgo*/ ctx[3])) /*editAlgo*/ ctx[3].apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(menuitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(menuitem, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const menuitem_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem_changes.$$scope = { dirty, ctx };
			}

			menuitem.$set(menuitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(menuitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(449:24) {#if editorState.variable_button}",
		ctx
	});

	return block;
}

// (452:28) <Menuitem key="toggleAlgo" on:click={handleCheckbox} class="font15">
function create_default_slot_17(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Show Algorithmic");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(452:28) <Menuitem key=\\\"toggleAlgo\\\" on:click={handleCheckbox} class=\\\"font15\\\">",
		ctx
	});

	return block;
}

// (450:28) <Menuitem key="ditAlgo" on:click={editAlgo} class="font15">
function create_default_slot_16(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit Algorithmic");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(450:28) <Menuitem key=\\\"ditAlgo\\\" on:click={editAlgo} class=\\\"font15\\\">",
		ctx
	});

	return block;
}

// (454:24) {#if editorState.variable_button}
function create_if_block_8(ctx) {
	let div;
	let menuitem0;
	let t0;
	let menuitem1;
	let t1;
	let menuitem2;
	let current;

	menuitem0 = new Menuitem({
			props: {
				key: "solve_algo",
				class: "font15",
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem0.$on("click", function () {
		if (is_function(/*solveVariable*/ ctx[4])) /*solveVariable*/ ctx[4].apply(this, arguments);
	});

	menuitem1 = new Menuitem({
			props: {
				class: "font15",
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem1.$on("click", function () {
		if (is_function(/*analyzeVariable*/ ctx[5])) /*analyzeVariable*/ ctx[5].apply(this, arguments);
	});

	menuitem2 = new Menuitem({
			props: {
				class: "font15",
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem2.$on("click", /*click_handler_1*/ ctx[31]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(menuitem0.$$.fragment);
			t0 = space();
			create_component(menuitem1.$$.fragment);
			t1 = space();
			create_component(menuitem2.$$.fragment);
			attr_dev(div, "class", "algo_controls");
			add_location(div, file$d, 454, 28, 17197);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(menuitem0, div, null);
			append_dev(div, t0);
			mount_component(menuitem1, div, null);
			append_dev(div, t1);
			mount_component(menuitem2, div, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const menuitem0_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem0_changes.$$scope = { dirty, ctx };
			}

			menuitem0.$set(menuitem0_changes);
			const menuitem1_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem1_changes.$$scope = { dirty, ctx };
			}

			menuitem1.$set(menuitem1_changes);
			const menuitem2_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem2_changes.$$scope = { dirty, ctx };
			}

			menuitem2.$set(menuitem2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuitem0.$$.fragment, local);
			transition_in(menuitem1.$$.fragment, local);
			transition_in(menuitem2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuitem0.$$.fragment, local);
			transition_out(menuitem1.$$.fragment, local);
			transition_out(menuitem2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(menuitem0);
			destroy_component(menuitem1);
			destroy_component(menuitem2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(454:24) {#if editorState.variable_button}",
		ctx
	});

	return block;
}

// (456:32) <Menuitem key="solve_algo" on:click={solveVariable} class="font15">
function create_default_slot_15(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Solve Variables");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(456:32) <Menuitem key=\\\"solve_algo\\\" on:click={solveVariable} class=\\\"font15\\\">",
		ctx
	});

	return block;
}

// (459:32) <Menuitem on:click={analyzeVariable} class="font15">
function create_default_slot_14(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Analyze Variables");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(459:32) <Menuitem on:click={analyzeVariable} class=\\\"font15\\\">",
		ctx
	});

	return block;
}

// (462:32) <Menuitem on:click={()=> {editorState.variable_button = false }} class="font15">
function create_default_slot_13(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Remove Algorithmic");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(462:32) <Menuitem on:click={()=> {editorState.variable_button = false }} class=\\\"font15\\\">",
		ctx
	});

	return block;
}

// (438:20) <Menu origin="top left">
function create_default_slot_12(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let if_block1_anchor;
	let current;
	let each_value_1 = /*toolMenu*/ ctx[1];
	validate_each_argument(each_value_1);
	const get_key = ctx => /*menuData*/ ctx[49].id;
	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	const if_block_creators = [create_if_block_9, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*editorState*/ ctx[0].variable_button) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*editorState*/ ctx[0].variable_button && create_if_block_8(ctx);

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*toolMenu*/ 2) {
				each_value_1 = /*toolMenu*/ ctx[1];
				validate_each_argument(each_value_1);
				group_outros();
				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, t0.parentNode, outro_and_destroy_block, create_each_block_1, t0, get_each_context_1);
				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(t1.parentNode, t1);
			}

			if (/*editorState*/ ctx[0].variable_button) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*editorState*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_8(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(t0);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(438:20) <Menu origin=\\\"top left\\\">",
		ctx
	});

	return block;
}

// (440:28) <Button id="icon_menu" ripple={false} class="tools_btn" style="margin-top:4px;">
function create_default_slot_11(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Tools";
			add_location(span, file$d, 440, 32, 16328);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(440:28) <Button id=\\\"icon_menu\\\" ripple={false} class=\\\"tools_btn\\\" style=\\\"margin-top:4px;\\\">",
		ctx
	});

	return block;
}

// (439:24) 
function create_activator_slot(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				id: "icon_menu",
				ripple: false,
				class: "tools_btn",
				style: "margin-top:4px;",
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			attr_dev(div, "slot", "activator");
			add_location(div, file$d, 438, 24, 16162);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_activator_slot.name,
		type: "slot",
		source: "(439:24) ",
		ctx
	});

	return block;
}

// (478:20) <Button                          size="small"                          data-bs-original-title="Desktop View"                          data-bs-toggle="tooltip"                          data-bs-placement="bottom"                          style="background-color: transparent; height:44px;"                          on:click={toggleDevice.bind(this, "desktop")}                      >
function create_default_slot_10(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "responsiveBtn icomoon-laptop font18");
			attr_dev(span, "id", "desktop_btn");
			set_style(span, "cursor", "pointer");
			set_style(span, "color", "#000");
			add_location(span, file$d, 485, 24, 18675);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(478:20) <Button                          size=\\\"small\\\"                          data-bs-original-title=\\\"Desktop View\\\"                          data-bs-toggle=\\\"tooltip\\\"                          data-bs-placement=\\\"bottom\\\"                          style=\\\"background-color: transparent; height:44px;\\\"                          on:click={toggleDevice.bind(this, \\\"desktop\\\")}                      >",
		ctx
	});

	return block;
}

// (492:20) <Button                          size="small"                          data-bs-original-title="Tablet View"                          data-bs-toggle="tooltip"                          data-bs-placement="bottom"                          style="background-color: transparent; height:44px;"                          on:click={toggleDevice.bind(this, "tab")}                      >
function create_default_slot_9(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "responsiveBtn icomoon-tablet font18");
			attr_dev(span, "id", "tab_btn");
			set_style(span, "cursor", "pointer");
			set_style(span, "color", "#000");
			add_location(span, file$d, 499, 24, 19355);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(492:20) <Button                          size=\\\"small\\\"                          data-bs-original-title=\\\"Tablet View\\\"                          data-bs-toggle=\\\"tooltip\\\"                          data-bs-placement=\\\"bottom\\\"                          style=\\\"background-color: transparent; height:44px;\\\"                          on:click={toggleDevice.bind(this, \\\"tab\\\")}                      >",
		ctx
	});

	return block;
}

// (506:20) <Button                          size="small"                          data-bs-original-title="Mobile View"                          data-bs-toggle="tooltip"                          data-bs-placement="bottom"                          style="background-color: transparent;height:44px;"                          on:click={toggleDevice.bind(this, "mobile")}                      >
function create_default_slot_8(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "responsiveBtn icomoon-mobile font18");
			attr_dev(span, "id", "mobile_btn");
			set_style(span, "cursor", "pointer");
			set_style(span, "color", "#000");
			add_location(span, file$d, 513, 24, 20032);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(506:20) <Button                          size=\\\"small\\\"                          data-bs-original-title=\\\"Mobile View\\\"                          data-bs-toggle=\\\"tooltip\\\"                          data-bs-placement=\\\"bottom\\\"                          style=\\\"background-color: transparent;height:44px;\\\"                          on:click={toggleDevice.bind(this, \\\"mobile\\\")}                      >",
		ctx
	});

	return block;
}

// (528:16) {#if editorState.viewConfig.isQuestion  && editorState.editorView == "preview"}
function create_if_block_6(ctx) {
	let div;

	function select_block_type_1(ctx, dirty) {
		if (/*editorState*/ ctx[0].viewConfig.isFullMode) return create_if_block_7;
		return create_else_block$2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			set_style(div, "position", "relative");
			set_style(div, "height", "30px");
			set_style(div, "display", "flex");
			add_location(div, file$d, 528, 20, 20745);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(528:16) {#if editorState.viewConfig.isQuestion  && editorState.editorView == \\\"preview\\\"}",
		ctx
	});

	return block;
}

// (549:24) {:else}
function create_else_block$2(ctx) {
	let div1;
	let div0;
	let label;
	let input;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			label = element("label");
			input = element("input");
			t = text("\r\n                                        Review");
			attr_dev(input, "class", "form-check-input mt-2 pe-none");
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "id", "flexSwitchCheckChecked");
			set_style(input, "position", "absolute");
			set_style(input, "bottom", "4px");
			add_location(input, file$d, 560, 40, 22456);
			attr_dev(label, "class", "form-check-label mt-1");
			attr_dev(label, "for", "flexSwitchCheckChecked");
			set_style(label, "cursor", "pointer");
			set_style(label, "text-align", "right");
			set_style(label, "width", "93px");
			add_location(label, file$d, 555, 36, 22131);
			attr_dev(div0, "class", "form-check form-switch");
			add_location(div0, file$d, 554, 32, 22057);
			attr_dev(div1, "id", "remedToggle");
			attr_dev(div1, "class", "position-relative text-dark pr-1");
			set_style(div1, "height", "34px");
			set_style(div1, "font-size", "16px");
			add_location(div1, file$d, 549, 28, 21793);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, label);
			append_dev(label, input);
			append_dev(label, t);

			if (!mounted) {
				dispose = listen_dev(
					input,
					"click",
					function () {
						if (is_function(/*toggleRemediation*/ ctx[6])) /*toggleRemediation*/ ctx[6].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(549:24) {:else}",
		ctx
	});

	return block;
}

// (536:24) {#if editorState.viewConfig.isFullMode}
function create_if_block_7(ctx) {
	let div1;
	let div0;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			div0.textContent = `${"Check Answer"}`;
			attr_dev(div0, "id", "answerCheck");
			attr_dev(div0, "class", "px-2 py-1 pointer r-sm position-relative mr-2");
			attr_dev(div0, "data-bs-original-title", "Remediation");
			attr_dev(div0, "data-bs-toggle", "tooltip");
			attr_dev(div0, "data-bs-placement", "bottom");
			set_style(div0, "fontSize", "13px");
			set_style(div0, "top", "1px");
			set_style(div0, "cursor", "pointer");
			add_location(div0, file$d, 537, 32, 21127);
			attr_dev(div1, "id", "externalToggleDiv");
			add_location(div1, file$d, 536, 28, 21065);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(536:24) {#if editorState.viewConfig.isFullMode}",
		ctx
	});

	return block;
}

// (618:16) {#if window.frameElement}
function create_if_block_5(ctx) {
	let button;
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			attr_dev(span, "class", "icomoon-close s3");
			add_location(span, file$d, 628, 24, 25541);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "auto ml m-t-n-sm btn p-0 bg-transparent height44");
			attr_dev(button, "title", "Close");
			attr_dev(button, "data-bs-toggle", "tooltip");
			attr_dev(button, "tabindex", "0");
			attr_dev(button, "data-bs-placement", "bottom");
			attr_dev(button, "id", "editor_close");
			add_location(button, file$d, 618, 20, 25094);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*closeEditor*/ ctx[17], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(618:16) {#if window.frameElement}",
		ctx
	});

	return block;
}

// (652:12) {#if ((getQueryString('router_guid') || getQueryString('content_guid'))) }
function create_if_block_4(ctx) {
	let button;
	let span;
	let t_value = "List" + "";
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "class", "icomoon-dragselect s3");
			add_location(span, file$d, 662, 20, 26651);
			attr_dev(button, "id", "list_button");
			attr_dev(button, "type", "button");
			attr_dev(button, "tabindex", "0");
			attr_dev(button, "class", "auto bg-transparent pointer");
			attr_dev(button, "title", "Item List");
			attr_dev(button, "data-bs-toggle", "tooltip");
			attr_dev(button, "data-bs-placement", "bottom");
			add_location(button, file$d, 652, 16, 26257);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onItemListButton*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(652:12) {#if ((getQueryString('router_guid') || getQueryString('content_guid'))) }",
		ctx
	});

	return block;
}

// (666:12) {#if (window.from_myproject != 1 || (isNew && isNew.get('show_add_new_button') == 1) ) }
function create_if_block_3(ctx) {
	let button;
	let span;
	let t_value = "Add New" + "";
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "class", "icomoon-list-plus-new s3");
			add_location(span, file$d, 676, 22, 27309);
			attr_dev(button, "id", "back_editor_button");
			attr_dev(button, "type", "button");
			attr_dev(button, "tabindex", "0");
			attr_dev(button, "class", "auto bg-transparent ie_back_btn pointer text-truncate");
			attr_dev(button, "title", "Add New");
			attr_dev(button, "data-bs-toggle", "tooltip");
			attr_dev(button, "data-bs-placement", "top");
			add_location(button, file$d, 666, 18, 26871);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onListButton*/ ctx[19], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(666:12) {#if (window.from_myproject != 1 || (isNew && isNew.get('show_add_new_button') == 1) ) }",
		ctx
	});

	return block;
}

// (708:24) <Menuitem class="save_xml_btn dropdown-item vertical-center" action="save_as">
function create_default_slot_7(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Save As");
			attr_dev(span, "class", "icomoon-24px-save-as-3 mr-sm");
			add_location(span, file$d, 708, 28, 28818);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(708:24) <Menuitem class=\\\"save_xml_btn dropdown-item vertical-center\\\" action=\\\"save_as\\\">",
		ctx
	});

	return block;
}

// (750:12) {#if editorState.guid.length > 4 }
function create_if_block_1$2(ctx) {
	let div;
	let button;
	let span;
	let t0;
	let t1;
	let ul;
	let t2;
	let menuitem;
	let current;
	let if_block = /*editorState*/ ctx[0].viewConfig.isQuestion && (window.from_myproject == 1 || window.from_ebook == 1) && create_if_block_2$2(ctx);

	menuitem = new Menuitem({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem.$on("click", /*showItemMeta*/ ctx[21]);

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			span = element("span");
			t0 = text("Info");
			t1 = space();
			ul = element("ul");
			if (if_block) if_block.c();
			t2 = space();
			create_component(menuitem.$$.fragment);
			attr_dev(span, "class", "icomoon-info s3");
			add_location(span, file$d, 759, 24, 30982);
			attr_dev(button, "id", "infoButton");
			attr_dev(button, "type", "button");
			attr_dev(button, "tabindex", "0");
			attr_dev(button, "class", "btn_design backbtncomp r-sm bg-transparent");
			attr_dev(button, "data-bs-placement", "bottom");
			attr_dev(button, "data-bs-toggle", "dropdown");
			add_location(button, file$d, 751, 20, 30629);
			attr_dev(ul, "class", "dropdown-menu dropdown-menu-left info_controls");
			add_location(ul, file$d, 761, 20, 31076);
			add_location(div, file$d, 750, 16, 30602);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, span);
			append_dev(button, t0);
			append_dev(div, t1);
			append_dev(div, ul);
			if (if_block) if_block.m(ul, null);
			append_dev(ul, t2);
			mount_component(menuitem, ul, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*editorState*/ ctx[0].viewConfig.isQuestion && (window.from_myproject == 1 || window.from_ebook == 1)) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*editorState*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(ul, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const menuitem_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem_changes.$$scope = { dirty, ctx };
			}

			menuitem.$set(menuitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(menuitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(menuitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			destroy_component(menuitem);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(750:12) {#if editorState.guid.length > 4 }",
		ctx
	});

	return block;
}

// (763:24) {#if editorState.viewConfig.isQuestion && (window.from_myproject == 1 || window.from_ebook == 1)}
function create_if_block_2$2(ctx) {
	let menuitem;
	let current;

	menuitem = new Menuitem({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem.$on("click", /*showContext*/ ctx[20]);

	const block = {
		c: function create() {
			create_component(menuitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(menuitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const menuitem_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem_changes.$$scope = { dirty, ctx };
			}

			menuitem.$set(menuitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(menuitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(763:24) {#if editorState.viewConfig.isQuestion && (window.from_myproject == 1 || window.from_ebook == 1)}",
		ctx
	});

	return block;
}

// (764:28) <Menuitem on:click={showContext}>
function create_default_slot_6(ctx) {
	let span1;
	let span0;
	let t;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = text("\r\n                                    Context");
			attr_dev(span0, "class", "icomoon-newspaper mr-sm");
			add_location(span0, file$d, 765, 36, 31399);
			add_location(span1, file$d, 764, 32, 31355);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(764:28) <Menuitem on:click={showContext}>",
		ctx
	});

	return block;
}

// (771:24) <Menuitem on:click={showItemMeta}>
function create_default_slot_5(ctx) {
	let span1;
	let span0;
	let t;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = text("\r\n                                Item Details");
			attr_dev(span0, "class", "icomoon-globe-2 mr-sm");
			add_location(span0, file$d, 772, 32, 31732);
			add_location(span1, file$d, 771, 28, 31692);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(771:24) <Menuitem on:click={showItemMeta}>",
		ctx
	});

	return block;
}

// (792:20) <Menuitem on:click={handleHelp}>
function create_default_slot_4(ctx) {
	let span1;
	let span0;
	let t;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = text("Help Video");
			attr_dev(span0, "class", "icomoon-24px-help-video mr-sm");
			add_location(span0, file$d, 793, 28, 32581);
			add_location(span1, file$d, 792, 24, 32545);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(792:20) <Menuitem on:click={handleHelp}>",
		ctx
	});

	return block;
}

// (797:20) <Menuitem on:click={handleKeyboardShortcut}>
function create_default_slot_3(ctx) {
	let span1;
	let span0;
	let t;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = text("\r\n                            Accessibility");
			attr_dev(span0, "class", "icomoon-accessibility mr-sm");
			add_location(span0, file$d, 798, 28, 32836);
			add_location(span1, file$d, 797, 24, 32800);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(797:20) <Menuitem on:click={handleKeyboardShortcut}>",
		ctx
	});

	return block;
}

// (803:20) <Menuitem on:click={()=> handleHelp('editor')}>
function create_default_slot_2(ctx) {
	let span1;
	let span0;
	let t;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = text("\r\n                            Editor Video");
			attr_dev(span0, "class", "icomoon-24px-help-video mr-sm");
			add_location(span0, file$d, 804, 28, 33125);
			add_location(span1, file$d, 803, 24, 33089);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(803:20) <Menuitem on:click={()=> handleHelp('editor')}>",
		ctx
	});

	return block;
}

// (830:12) {#if openGudids}
function create_if_block$b(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*openGudids*/ ctx[9];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*openGudids, currentGuid, loadSelectedItem, editorRouter, itemDetails*/ 269824) {
				each_value = /*openGudids*/ ctx[9];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(830:12) {#if openGudids}",
		ctx
	});

	return block;
}

// (832:20) <Menuitem                          id={"seq_" + guidSeq}                          class="shortList border-bottom"                          on:click={loadSelectedItem.bind(this, editorRouter[guidSeq])}                          style="cursor: pointer; font-size: 15px; background:  {(guidSeq == currentGuid) ? '#e9ecef': 'none'}"                      >
function create_default_slot_1(ctx) {
	let span1;
	let span0;
	let span0_class_value;
	let t0;
	let t1_value = /*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]].snippet + "";
	let t1;
	let t2;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			set_style(span0, "margin-right", "3px");
			attr_dev(span0, "class", span0_class_value = "font16 position-relative m-r-xxs " + (/*itemDetails*/ ctx[11][/*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]].content_type][/*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]].content_subtype].icon || 'icomoon-all-items-2') + " sidepaneIcon top2");
			add_location(span0, file$d, 838, 28, 34401);
			attr_dev(span1, "class", "text-truncate");
			add_location(span1, file$d, 837, 24, 34343);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t0);
			append_dev(span1, t1);
			insert_dev(target, t2, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*itemDetails, editorRouter, openGudids*/ 3584 && span0_class_value !== (span0_class_value = "font16 position-relative m-r-xxs " + (/*itemDetails*/ ctx[11][/*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]].content_type][/*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]].content_subtype].icon || 'icomoon-all-items-2') + " sidepaneIcon top2")) {
				attr_dev(span0, "class", span0_class_value);
			}

			if (dirty[0] & /*editorRouter, openGudids*/ 1536 && t1_value !== (t1_value = /*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]].snippet + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(832:20) <Menuitem                          id={\\\"seq_\\\" + guidSeq}                          class=\\\"shortList border-bottom\\\"                          on:click={loadSelectedItem.bind(this, editorRouter[guidSeq])}                          style=\\\"cursor: pointer; font-size: 15px; background:  {(guidSeq == currentGuid) ? '#e9ecef': 'none'}\\\"                      >",
		ctx
	});

	return block;
}

// (831:16) {#each openGudids as guidSeq}
function create_each_block(ctx) {
	let menuitem;
	let current;

	menuitem = new Menuitem({
			props: {
				id: "seq_" + /*guidSeq*/ ctx[46],
				class: "shortList border-bottom",
				style: "cursor: pointer; font-size: 15px; background:  " + (/*guidSeq*/ ctx[46] == /*currentGuid*/ ctx[12]
				? '#e9ecef'
				: 'none'),
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem.$on("click", function () {
		if (is_function(/*loadSelectedItem*/ ctx[18].bind(this, /*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]]))) /*loadSelectedItem*/ ctx[18].bind(this, /*editorRouter*/ ctx[10][/*guidSeq*/ ctx[46]]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(menuitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(menuitem, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const menuitem_changes = {};
			if (dirty[0] & /*openGudids*/ 512) menuitem_changes.id = "seq_" + /*guidSeq*/ ctx[46];

			if (dirty[0] & /*openGudids, currentGuid*/ 4608) menuitem_changes.style = "cursor: pointer; font-size: 15px; background:  " + (/*guidSeq*/ ctx[46] == /*currentGuid*/ ctx[12]
			? '#e9ecef'
			: 'none');

			if (dirty[0] & /*editorRouter, openGudids, itemDetails*/ 3584 | dirty[1] & /*$$scope*/ 2097152) {
				menuitem_changes.$$scope = { dirty, ctx };
			}

			menuitem.$set(menuitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(menuitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(831:16) {#each openGudids as guidSeq}",
		ctx
	});

	return block;
}

// (814:0) <Sidepanel left bind:visible={listDrawer}>
function create_default_slot$2(ctx) {
	let div;
	let ul0;
	let li;
	let a;
	let span;
	let t0;
	let a_href_value;
	let t1;
	let ul1;
	let current;
	let if_block = /*openGudids*/ ctx[9] && create_if_block$b(ctx);

	const block = {
		c: function create() {
			div = element("div");
			ul0 = element("ul");
			li = element("li");
			a = element("a");
			span = element("span");
			t0 = text("\r\n                    Items");
			t1 = space();
			ul1 = element("ul");
			if (if_block) if_block.c();
			attr_dev(span, "class", "icomoon-toc-sm align-middle mr-sm s3");
			add_location(span, file$d, 823, 20, 33693);
			attr_dev(a, "class", "text-dark nav-link active");
			attr_dev(a, "href", a_href_value = "javascript:void(0);");
			add_location(a, file$d, 822, 16, 33605);
			attr_dev(li, "class", "nav-item");
			add_location(li, file$d, 821, 12, 33566);
			attr_dev(ul0, "class", "nav nav-pills m-0");
			add_location(ul0, file$d, 820, 8, 33522);
			set_style(ul1, "padding", "0");
			add_location(ul1, file$d, 828, 8, 33844);
			set_style(div, "font-size", "20px");
			set_style(div, "height", "51px");
			add_location(div, file$d, 814, 4, 33416);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, ul0);
			append_dev(ul0, li);
			append_dev(li, a);
			append_dev(a, span);
			append_dev(a, t0);
			append_dev(div, t1);
			append_dev(div, ul1);
			if (if_block) if_block.m(ul1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*openGudids*/ ctx[9]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*openGudids*/ 512) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(ul1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(814:0) <Sidepanel left bind:visible={listDrawer}>",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let div16;
	let div10;
	let header;
	let div5;
	let div1;
	let div0;
	let img;
	let img_src_value;
	let t0;
	let div2;
	let menu;
	let t1;
	let div3;
	let button0;
	let t2;
	let button1;
	let t3;
	let button2;
	let t4;
	let div4;
	let t5;
	let div9;
	let t6;
	let div6;
	let t7_value = /*editorState*/ ctx[0].guid + "";
	let t7;
	let t8;
	let div7;

	let t9_value = (/*editorState*/ ctx[0].draft == "1"
	? "Draft"
	: "Published") + "";

	let t9;
	let t10;
	let div8;
	let t12;
	let t13;
	let footer;
	let div15;
	let show_if_1 = getQueryString('router_guid') || getQueryString('content_guid');
	let t14;
	let show_if = window.from_myproject != 1 || /*isNew*/ ctx[16] && /*isNew*/ ctx[16].get('show_add_new_button') == 1;
	let t15;
	let div13;
	let button3;
	let span0;
	let t16;
	let t17;
	let div12;
	let button4;
	let t18;
	let div11;
	let menuitem0;
	let t19;
	let button5;
	let span1;
	let span2;
	let t21;
	let button6;
	let span3;
	let t22_value = /*editorSeq*/ ctx[13] + 1 + "";
	let t22;
	let t23;
	let t24;
	let t25;
	let button7;
	let span4;
	let t26;
	let t27;
	let t28;
	let div14;
	let button8;
	let span5;
	let t29;
	let t30;
	let ul;
	let menuitem1;
	let t31;
	let menuitem2;
	let t32;
	let menuitem3;
	let t33;
	let sidepanel;
	let updating_visible;
	let current;
	let mounted;
	let dispose;

	menu = new Menu({
			props: {
				origin: "top left",
				$$slots: {
					activator: [create_activator_slot],
					default: [create_default_slot_12]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0 = new Button({
			props: {
				size: "small",
				"data-bs-original-title": "Desktop View",
				"data-bs-toggle": "tooltip",
				"data-bs-placement": "bottom",
				style: "background-color: transparent; height:44px;",
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*toggleDevice*/ ctx[24].bind(this, "desktop"));

	button1 = new Button({
			props: {
				size: "small",
				"data-bs-original-title": "Tablet View",
				"data-bs-toggle": "tooltip",
				"data-bs-placement": "bottom",
				style: "background-color: transparent; height:44px;",
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*toggleDevice*/ ctx[24].bind(this, "tab"));

	button2 = new Button({
			props: {
				size: "small",
				"data-bs-original-title": "Mobile View",
				"data-bs-toggle": "tooltip",
				"data-bs-placement": "bottom",
				style: "background-color: transparent;height:44px;",
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button2.$on("click", /*toggleDevice*/ ctx[24].bind(this, "mobile"));
	let if_block0 = /*editorState*/ ctx[0].viewConfig.isQuestion && /*editorState*/ ctx[0].editorView == "preview" && create_if_block_6(ctx);
	let if_block1 = window.frameElement && create_if_block_5(ctx);
	let if_block2 = show_if_1 && create_if_block_4(ctx);
	let if_block3 = show_if && create_if_block_3(ctx);

	menuitem0 = new Menuitem({
			props: {
				class: "save_xml_btn dropdown-item vertical-center",
				action: "save_as",
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block4 = /*editorState*/ ctx[0].guid.length > 4 && create_if_block_1$2(ctx);

	menuitem1 = new Menuitem({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem1.$on("click", /*handleHelp*/ ctx[22]);

	menuitem2 = new Menuitem({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem2.$on("click", /*handleKeyboardShortcut*/ ctx[23]);

	menuitem3 = new Menuitem({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	menuitem3.$on("click", /*click_handler_4*/ ctx[34]);

	function sidepanel_visible_binding(value) {
		/*sidepanel_visible_binding*/ ctx[35](value);
	}

	let sidepanel_props = {
		left: true,
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	if (/*listDrawer*/ ctx[15] !== void 0) {
		sidepanel_props.visible = /*listDrawer*/ ctx[15];
	}

	sidepanel = new Sidepanel({ props: sidepanel_props, $$inline: true });
	binding_callbacks.push(() => bind(sidepanel, 'visible', sidepanel_visible_binding));

	const block = {
		c: function create() {
			div16 = element("div");
			div10 = element("div");
			header = element("header");
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			img = element("img");
			t0 = space();
			div2 = element("div");
			create_component(menu.$$.fragment);
			t1 = space();
			div3 = element("div");
			create_component(button0.$$.fragment);
			t2 = space();
			create_component(button1.$$.fragment);
			t3 = space();
			create_component(button2.$$.fragment);
			t4 = space();
			div4 = element("div");
			t5 = space();
			div9 = element("div");
			if (if_block0) if_block0.c();
			t6 = space();
			div6 = element("div");
			t7 = text(t7_value);
			t8 = space();
			div7 = element("div");
			t9 = text(t9_value);
			t10 = space();
			div8 = element("div");
			div8.textContent = "V2.0";
			t12 = space();
			if (if_block1) if_block1.c();
			t13 = space();
			footer = element("footer");
			div15 = element("div");
			if (if_block2) if_block2.c();
			t14 = space();
			if (if_block3) if_block3.c();
			t15 = space();
			div13 = element("div");
			button3 = element("button");
			span0 = element("span");
			t16 = text("Save");
			t17 = space();
			div12 = element("div");
			button4 = element("button");
			t18 = space();
			div11 = element("div");
			create_component(menuitem0.$$.fragment);
			t19 = space();
			button5 = element("button");
			span1 = element("span");
			span1.textContent = "Previous";
			span2 = element("span");
			t21 = space();
			button6 = element("button");
			span3 = element("span");
			t22 = text(t22_value);
			t23 = text(" of ");
			t24 = text(/*totalItem*/ ctx[14]);
			t25 = space();
			button7 = element("button");
			span4 = element("span");
			t26 = text("Next");
			t27 = space();
			if (if_block4) if_block4.c();
			t28 = space();
			div14 = element("div");
			button8 = element("button");
			span5 = element("span");
			t29 = text("Help");
			t30 = space();
			ul = element("ul");
			create_component(menuitem1.$$.fragment);
			t31 = space();
			create_component(menuitem2.$$.fragment);
			t32 = space();
			create_component(menuitem3.$$.fragment);
			t33 = space();
			create_component(sidepanel.$$.fragment);
			if (!src_url_equal(img.src, img_src_value = window.baseUrl + "layout/themes/bootstrap4/images/logo/ucertify_logo.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "id", "editor-header-img");
			attr_dev(img, "width", "160");
			attr_dev(img, "height", "44");
			attr_dev(img, "alt", "uCertify Editor");
			attr_dev(img, "header-logo", "1");
			add_location(img, file$d, 426, 24, 15642);
			attr_dev(div0, "id", "editor-header-logo");
			add_location(div0, file$d, 425, 20, 15586);
			attr_dev(div1, "id", "ucheader_logo");
			attr_dev(div1, "class", "text-center height44 uclogo width160");
			attr_dev(div1, "aria-hidden", "true");
			add_location(div1, file$d, 420, 16, 15392);
			add_location(div2, file$d, 436, 16, 16085);
			attr_dev(div3, "class", "device_btn text-center");
			attr_dev(div3, "id", "device_btn");
			set_style(div3, "display", "none");
			set_style(div3, "fontSize", "20px");
			set_style(div3, "color", "#000");
			add_location(div3, file$d, 468, 16, 17963);
			attr_dev(div4, "class", "toolbar_contain");
			attr_dev(div4, "id", "toolbar_container");
			set_style(div4, "margin-top", "7px");
			add_location(div4, file$d, 520, 16, 20328);
			attr_dev(div5, "id", "left_header");
			attr_dev(div5, "class", "float-left text-dark");
			set_style(div5, "display", "flex");
			set_style(div5, "color", "#212529", 1);
			add_location(div5, file$d, 412, 12, 15146);
			attr_dev(div6, "class", "badge badge-secondary font-weight-normal pt-1 pointer");
			attr_dev(div6, "id", "show_guid");
			attr_dev(div6, "data-bs-placement", "bottom");
			set_style(div6, "font-size", "14px");
			set_style(div6, "letter-spacing", "1px");
			set_style(div6, "width", "fit-content");
			set_style(div6, "display", /*editorState*/ ctx[0].guid ? 'inline' : 'none');
			set_style(div6, "height", "23px");
			set_style(div6, "font-family", "'PT Sans Caption', sans-serif");
			set_style(div6, "margin-top", "4px");
			add_location(div6, file$d, 575, 16, 23167);
			attr_dev(div7, "class", "badge badge-info font-weight-normal pt-1");
			attr_dev(div7, "id", "item_status");
			set_style(div7, "font-size", "14px");
			set_style(div7, "letter-spacing", "1px");
			set_style(div7, "width", "fit-content");
			set_style(div7, "display", /*editorState*/ ctx[0].guid ? 'inline' : 'none');
			set_style(div7, "height", "23px");
			set_style(div7, "font-family", "'PT Sans Caption', sans-serif");
			set_style(div7, "margin-top", "4px");
			set_style(div7, "margin-left", "3px");
			add_location(div7, file$d, 589, 16, 23808);
			attr_dev(div8, "class", "badge badge-primary font-weight-normal pt-1");
			attr_dev(div8, "id", "item_status");
			set_style(div8, "font-size", "14px");
			set_style(div8, "letter-spacing", "1px");
			set_style(div8, "width", "fit-content");
			set_style(div8, "display", "inline");
			set_style(div8, "height", "23px");
			set_style(div8, "font-family", "'PT Sans Caption', sans-serif");
			set_style(div8, "margin-top", "4px");
			set_style(div8, "margin-left", "3px");
			add_location(div8, file$d, 603, 16, 24465);
			attr_dev(div9, "id", "right_header");
			attr_dev(div9, "class", "float-right");
			set_style(div9, "display", "flex");
			set_style(div9, "bottom", "4px");
			set_style(div9, "padding-right", "13px");
			set_style(div9, "margin-top", "7px");
			add_location(div9, file$d, 522, 12, 20445);
			set_style(header, "background-color", "#fff");
			set_style(header, "height", "45px");
			attr_dev(header, "class", "navbar-light navbar-fixed-top fixed-top");
			add_location(header, file$d, 405, 8, 14944);
			attr_dev(div10, "id", "top");
			set_style(div10, "position", "fixed");
			set_style(div10, "top", "0");
			set_style(div10, "width", "100%");
			set_style(div10, "z-index", "99");
			add_location(div10, file$d, 396, 4, 14801);
			attr_dev(span0, "class", "icomoon-24px-save-3 s3");
			add_location(span0, file$d, 690, 20, 27853);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "class", "auto bg-transparent save_xml_btn r-sm");
			attr_dev(button3, "title", "Save Content");
			attr_dev(button3, "data-bs-toggle", "tooltip");
			attr_dev(button3, "data-bs-placement", "bottom");
			attr_dev(button3, "id", "save_xml");
			attr_dev(button3, "tabindex", "0");
			set_style(button3, "paddingRight", "0px");
			add_location(button3, file$d, 680, 16, 27451);
			attr_dev(button4, "id", "save_xml_new");
			attr_dev(button4, "title", "Save as new");
			attr_dev(button4, "type", "button");
			attr_dev(button4, "class", "btn bg-transparent dropdown-toggle");
			attr_dev(button4, "action", "none");
			attr_dev(button4, "data-bs-toggle", "dropdown");
			attr_dev(button4, "aria-haspopup", "true");
			attr_dev(button4, "aria-expanded", "false");
			attr_dev(button4, "tabindex", "0");
			set_style(button4, "paddingLeft", "10px");
			set_style(button4, "margin-top", "0");
			set_style(button4, "vertical-align", "bottom");
			add_location(button4, file$d, 693, 20, 28032);
			attr_dev(div11, "class", "dropdown-menu");
			attr_dev(div11, "aria-labelledby", "save_xml_new");
			add_location(div11, file$d, 706, 20, 28626);
			attr_dev(div12, "class", "btn-group");
			attr_dev(div12, "role", "group");
			set_style(div12, "margin-left", "-18px");
			add_location(div12, file$d, 692, 16, 27946);
			add_location(div13, file$d, 679, 12, 27428);
			set_style(span1, "bottom", "0");
			attr_dev(span1, "class", "text-truncate");
			add_location(span1, file$d, 723, 16, 29394);
			attr_dev(span2, "class", "icomoon-24px-previous");
			set_style(span2, "bottom", "-1px");
			add_location(span2, file$d, 723, 77, 29455);
			attr_dev(button5, "id", "previousBtn");
			attr_dev(button5, "tabindex", "0");
			attr_dev(button5, "type", "button");
			attr_dev(button5, "class", "btn_design backbtncomp r-sm bg-transparent");
			attr_dev(button5, "data-bs-original-title", "Previous");
			attr_dev(button5, "data-bs-toggle", "tooltip");
			attr_dev(button5, "data-bs-placement", "bottom");
			add_location(button5, file$d, 713, 12, 28998);
			attr_dev(span3, "class", "");
			add_location(span3, file$d, 735, 16, 29960);
			attr_dev(button6, "id", "counterButton");
			attr_dev(button6, "type", "button");
			attr_dev(button6, "tabindex", "0");
			attr_dev(button6, "class", "btn_design backbtncomp r-sm bg-transparent text-truncate");
			attr_dev(button6, "data-bs-original-title", "Current Item Sequence");
			attr_dev(button6, "data-bs-toggle", "tooltip");
			attr_dev(button6, "data-bs-placement", "bottom");
			set_style(button6, "padding", "0");
			add_location(button6, file$d, 725, 12, 29555);
			attr_dev(span4, "class", "icomoon-24px-next");
			set_style(span4, "bottom", "-1px");
			add_location(span4, file$d, 747, 16, 30449);
			attr_dev(button7, "id", "nextBtn");
			attr_dev(button7, "type", "button");
			attr_dev(button7, "tabindex", "0");
			attr_dev(button7, "class", "btn_design backbtncomp r-sm bg-transparent text-truncate");
			attr_dev(button7, "data-bs-original-title", "Next");
			attr_dev(button7, "data-bs-toggle", "tooltip");
			attr_dev(button7, "data-bs-placement", "bottom");
			add_location(button7, file$d, 737, 12, 30051);
			attr_dev(span5, "class", "icomoon-help s3");
			add_location(span5, file$d, 788, 20, 32320);
			attr_dev(button8, "id", "helpButton");
			attr_dev(button8, "type", "button");
			attr_dev(button8, "tabindex", "0");
			attr_dev(button8, "class", "btn_design backbtncomp r-sm bg-transparent");
			attr_dev(button8, "data-bs-placement", "top");
			attr_dev(button8, "data-bs-toggle", "dropdown");
			add_location(button8, file$d, 780, 16, 32002);
			attr_dev(ul, "class", "dropdown-menu dropdown-menu-left help_controls");
			add_location(ul, file$d, 790, 16, 32406);
			add_location(div14, file$d, 779, 12, 31979);
			attr_dev(div15, "id", "right_footer");
			attr_dev(div15, "class", "float-right footer_box");
			add_location(div15, file$d, 647, 8, 26061);
			attr_dev(footer, "style", "\r\n            background-color: #e9ecef; \r\n            height: 48px;\r\n            left : unset;\r\n            border-radius: 5px;\r\n            right: 40px;\r\n            padding-right: 8px;\r\n            padding-left: 8px;\r\n            border: 1px solid #ccc;\r\n        ");
			attr_dev(footer, "class", "navbar-light navbar-fixed-bottom fixed-bottom");
			add_location(footer, file$d, 634, 4, 25690);
			add_location(div16, file$d, 395, 0, 14790);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div16, anchor);
			append_dev(div16, div10);
			append_dev(div10, header);
			append_dev(header, div5);
			append_dev(div5, div1);
			append_dev(div1, div0);
			append_dev(div0, img);
			append_dev(div5, t0);
			append_dev(div5, div2);
			mount_component(menu, div2, null);
			append_dev(div5, t1);
			append_dev(div5, div3);
			mount_component(button0, div3, null);
			append_dev(div3, t2);
			mount_component(button1, div3, null);
			append_dev(div3, t3);
			mount_component(button2, div3, null);
			append_dev(div5, t4);
			append_dev(div5, div4);
			append_dev(header, t5);
			append_dev(header, div9);
			if (if_block0) if_block0.m(div9, null);
			append_dev(div9, t6);
			append_dev(div9, div6);
			append_dev(div6, t7);
			append_dev(div9, t8);
			append_dev(div9, div7);
			append_dev(div7, t9);
			append_dev(div9, t10);
			append_dev(div9, div8);
			append_dev(div9, t12);
			if (if_block1) if_block1.m(div9, null);
			append_dev(div16, t13);
			append_dev(div16, footer);
			append_dev(footer, div15);
			if (if_block2) if_block2.m(div15, null);
			append_dev(div15, t14);
			if (if_block3) if_block3.m(div15, null);
			append_dev(div15, t15);
			append_dev(div15, div13);
			append_dev(div13, button3);
			append_dev(button3, span0);
			append_dev(button3, t16);
			append_dev(div13, t17);
			append_dev(div13, div12);
			append_dev(div12, button4);
			append_dev(div12, t18);
			append_dev(div12, div11);
			mount_component(menuitem0, div11, null);
			append_dev(div15, t19);
			append_dev(div15, button5);
			append_dev(button5, span1);
			append_dev(button5, span2);
			append_dev(div15, t21);
			append_dev(div15, button6);
			append_dev(button6, span3);
			append_dev(span3, t22);
			append_dev(span3, t23);
			append_dev(span3, t24);
			append_dev(div15, t25);
			append_dev(div15, button7);
			append_dev(button7, span4);
			append_dev(button7, t26);
			append_dev(div15, t27);
			if (if_block4) if_block4.m(div15, null);
			append_dev(div15, t28);
			append_dev(div15, div14);
			append_dev(div14, button8);
			append_dev(button8, span5);
			append_dev(button8, t29);
			append_dev(div14, t30);
			append_dev(div14, ul);
			mount_component(menuitem1, ul, null);
			append_dev(ul, t31);
			mount_component(menuitem2, ul, null);
			append_dev(ul, t32);
			mount_component(menuitem3, ul, null);
			insert_dev(target, t33, anchor);
			mount_component(sidepanel, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button5, "click", /*click_handler_2*/ ctx[32], false, false, false),
					listen_dev(button7, "click", /*click_handler_3*/ ctx[33], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const menu_changes = {};

			if (dirty[0] & /*editorState, analyzeVariable, solveVariable, editAlgo, handleCheckbox, toolMenu*/ 63 | dirty[1] & /*$$scope*/ 2097152) {
				menu_changes.$$scope = { dirty, ctx };
			}

			menu.$set(menu_changes);
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const button2_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				button2_changes.$$scope = { dirty, ctx };
			}

			button2.$set(button2_changes);

			if (/*editorState*/ ctx[0].viewConfig.isQuestion && /*editorState*/ ctx[0].editorView == "preview") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					if_block0.m(div9, t6);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty[0] & /*editorState*/ 1) && t7_value !== (t7_value = /*editorState*/ ctx[0].guid + "")) set_data_dev(t7, t7_value);

			if (!current || dirty[0] & /*editorState*/ 1) {
				set_style(div6, "display", /*editorState*/ ctx[0].guid ? 'inline' : 'none');
			}

			if ((!current || dirty[0] & /*editorState*/ 1) && t9_value !== (t9_value = (/*editorState*/ ctx[0].draft == "1"
			? "Draft"
			: "Published") + "")) set_data_dev(t9, t9_value);

			if (!current || dirty[0] & /*editorState*/ 1) {
				set_style(div7, "display", /*editorState*/ ctx[0].guid ? 'inline' : 'none');
			}

			if (window.frameElement) if_block1.p(ctx, dirty);
			if (show_if_1) if_block2.p(ctx, dirty);
			if (show_if) if_block3.p(ctx, dirty);
			const menuitem0_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem0_changes.$$scope = { dirty, ctx };
			}

			menuitem0.$set(menuitem0_changes);
			if ((!current || dirty[0] & /*editorSeq*/ 8192) && t22_value !== (t22_value = /*editorSeq*/ ctx[13] + 1 + "")) set_data_dev(t22, t22_value);
			if (!current || dirty[0] & /*totalItem*/ 16384) set_data_dev(t24, /*totalItem*/ ctx[14]);

			if (/*editorState*/ ctx[0].guid.length > 4) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*editorState*/ 1) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_1$2(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div15, t28);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			const menuitem1_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem1_changes.$$scope = { dirty, ctx };
			}

			menuitem1.$set(menuitem1_changes);
			const menuitem2_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem2_changes.$$scope = { dirty, ctx };
			}

			menuitem2.$set(menuitem2_changes);
			const menuitem3_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				menuitem3_changes.$$scope = { dirty, ctx };
			}

			menuitem3.$set(menuitem3_changes);
			const sidepanel_changes = {};

			if (dirty[0] & /*openGudids, currentGuid, editorRouter, itemDetails*/ 7680 | dirty[1] & /*$$scope*/ 2097152) {
				sidepanel_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*listDrawer*/ 32768) {
				updating_visible = true;
				sidepanel_changes.visible = /*listDrawer*/ ctx[15];
				add_flush_callback(() => updating_visible = false);
			}

			sidepanel.$set(sidepanel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			transition_in(menuitem0.$$.fragment, local);
			transition_in(if_block4);
			transition_in(menuitem1.$$.fragment, local);
			transition_in(menuitem2.$$.fragment, local);
			transition_in(menuitem3.$$.fragment, local);
			transition_in(sidepanel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menu.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			transition_out(menuitem0.$$.fragment, local);
			transition_out(if_block4);
			transition_out(menuitem1.$$.fragment, local);
			transition_out(menuitem2.$$.fragment, local);
			transition_out(menuitem3.$$.fragment, local);
			transition_out(sidepanel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div16);
			destroy_component(menu);
			destroy_component(button0);
			destroy_component(button1);
			destroy_component(button2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			destroy_component(menuitem0);
			if (if_block4) if_block4.d();
			destroy_component(menuitem1);
			destroy_component(menuitem2);
			destroy_component(menuitem3);
			if (detaching) detach_dev(t33);
			destroy_component(sidepanel, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditorHeader', slots, []);
	let { editorState } = $$props;
	let { itemHelper } = $$props;
	let { handleModal } = $$props;
	let { updateEditorModule } = $$props;
	let { toolMenu } = $$props;
	let { handleCheckbox } = $$props;
	let { editAlgo } = $$props;
	let { solveVariable } = $$props;
	let { analyzeVariable } = $$props;
	let { toggleRemediation } = $$props;
	let { l } = $$props;

	let deviceIframeContainer = [
		"background:url(" + editor.baseUrlTheme + "svelte_items/images/mobile.svg);width:370px;height:707px;margin:0 auto;padding: 105px 5px;",
		"background:url(" + editor.baseUrlTheme + "svelte_items/images/tab.svg);width:871px;height:1242px;margin:0 auto;padding: 105px 5px;"
	];

	let deviceIframeProperty = [
		"overflow: auto;height: 500px;background: #fff;padding:0 10px;margin-left:2px;",
		"overflow: auto;height: 1045px;background: #fff;padding:0 10px;margin-left:2px;"
	];

	let openGudids;
	let editorRouter = [];

	let modal = {
		header: [],
		body: [],
		footer: [],
		width: 300
	};

	let isNew = window.frameElement
	? AH.url(window.frameElement.src)
	: false;

	let editorUrl = AH.url();
	let guid_group = [];
	let itemDetails = {};
	let currentGuid = "";
	let editorSeq = 0;
	let totalItem = 0;
	let listDrawer = false;

	onMount(async () => {
		editorUrl = new URLSearchParams(window.location.href);
		$$invalidate(11, itemDetails = editorConfig.getItemDetails());
		await tick();

		if (editorUrl.get('router_guid')) {
			guid_group = editorUrl.get('router_guid').split(',');
		} else {
			guid_group = editorUrl.get('content_guid');
		}

		$$invalidate(12, currentGuid = editorUrl.get('content_guid'));
		$$invalidate(13, editorSeq = currentGuid ? guid_group.indexOf(currentGuid) : 0);
		$$invalidate(14, totalItem = editorUrl.get('router_guid') ? guid_group.length : 1);
	});

	function closeEditor() {
		if (!AH.get('save_item')) {
			let saved = AH.isValid(AH.get('save_response'))
			? AH.get('save_response')
			: false;

			// Specific to Unity 
			let authFrame = document.getElementById("authoringFrame");

			if (authFrame && typeof authFrame.contentWindow.responsiveVoice !== 'undefined' && typeof authFrame.contentWindow.pauseVoice != 'undefined') {
				authFrame.contentWindow.pauseVoice();
			}

			if (window.parent.editorClose) {
				window.parent.editorClose(saved);
			} else {
				window.parent.close_frame_modal(saved);
			}
		} else {
			AH.set("unSavedProjectData", true);
			$$invalidate(0, editorState.saveDialog = true, editorState);
		}
	}

	function onItemListButton() {
		if (!AH.get('listUpdate')) {
			AH.activate(1);

			loadRouterGuids().then(res => {
				$$invalidate(15, listDrawer = res);
				AH.activate(0);
			});
		} else {
			$$invalidate(15, listDrawer = true);
		}
	}

	function loadRouterGuids() {
		return new Promise(resolve => {
				let group_guids = getQueryString('router_guid')
				? getQueryString('router_guid')
				: getQueryString('content_guid');

				AH.ajax({
					url: baseUrl + 'editor/index.php',
					data: {
						ajax: "1",
						action: 'get_router_guids',
						group_guids
					}
				}).then(response => {
					try {
						$$invalidate(10, editorRouter = JSON.parse(response));

						$$invalidate(9, openGudids = editorUrl.get('router_guid')
						? editorUrl.get('router_guid')
						: editorUrl.get('content_guid'));

						$$invalidate(9, openGudids = openGudids.replace('#', ''));
						$$invalidate(9, openGudids = openGudids ? openGudids.split(",") : []);
					} catch(e) {
						console.log(e);
						$$invalidate(10, editorRouter = []);
					}

					AH.set("listUpdate", true);
					resolve(true);
				});
			});
	}

	function loadSelectedItem(data) {
		if (getQueryString('router_guid')) {
			checkNavigation("click", data);
		}
	}

	async function onListButton(event) {
		AH.getBS(event.target, 'Tooltip').hide?.();
		await tick();

		if (!AH.get('save_item')) {
			goBack();
		} else {
			AH.set("unSavedBack", true);
			$$invalidate(0, editorState.saveDialog = true, editorState);
		}
	}

	function checkNavigation(action, data) {
		if (!editorUrl.get('router_guid')) {
			return false;
		}

		if (!AH.get('save_item')) {
			navigate(action, data);
		} else {
			AH.set("unsavedSata", true);
			AH.set('router_action', action);
			AH.set('router_data', data);
			AH.set('moveAction', action ? "Next" : "Previous");
			$$invalidate(0, editorState.saveDialog = true, editorState);
		}
	}

	function navigate(action, data) {
		let currentSelected = editorSeq;
		$$invalidate(12, currentGuid = editorUrl.get('content_guid'));
		AH.set('moveAction', false);

		if (action) {
			if (action == "click") {
				currentSelected = guid_group.findIndex(item => item == data.content_guid);
			} else {
				if (currentSelected + 1 == guid_group.length) {
					AH.showmsg("Editor is on last item.");
					return;
				} else {
					currentSelected = currentSelected + 1;
				}
			}
		} else {
			if (currentSelected > 0) {
				currentSelected = currentSelected - 1;
			} else {
				AH.showmsg("Editor is on first item.");
				return;
			}
		}

		$$invalidate(12, currentGuid = guid_group[currentSelected]);
		editorUrl.set('content_guid', currentGuid);

		if (editorUrl.get('get-diff') == 1) {
			editorUrl.delete('get-diff');
			editorUrl.delete('version_date');
			editorUrl.delete('from_draft');
		}

		AH.toggleDom(window.parent.document.querySelector('.load_data'), 'show');
		window.location = decodeURIComponent(editorUrl.toString());
	}

	function showContext() {
		AH.activate(1);

		AH.ajax({
			url: baseUrl + 'editor/index.php',
			data: {
				ajax: "1",
				action: 'get_parent_context',
				cource_code: editor.course,
				content_guid: parent2 || parent1,
				show_all: parent2 ? 0 : 1
			}
		}).then(response => {
			modal = {
				header: {
					body: '<div>Parent Context</div>',
					class: "editor_modal_title"
				},
				body: {
					body: response,
					class: "editor_modal_content",
					style: "height: 400px"
				},
				footer: { body: [], class: "editor_modal_action" },
				width: 500
			};

			AH.activate(0);
			handleModal(modal);
		});
	}

	function showItemMeta() {
		if (AH.get('current_item_icon')) {
			AH.set("current_item_icon", editorState.content_icon);
		}

		AH.activate(2);

		AH.ajax({
			url: baseUrl + 'editor/index.php',
			data: {
				ajax: "1",
				action: 'get_item_meta',
				cource_code: editor.course,
				content_guid: editorState.guid,
				content_id: editorState.propsAjaxData.content_id,
				content_icon: editorConfig.getItemDetails(editorState.content_type, editorState.item),
				current_icon_data: editorConfig.getItemDetails(editorState.content_type, editorState.item, editorState.content_icon),
				show_icon: editorState.viewConfig.showItemMetaIcon ? 1 : 0,
				draft: editorState.draft
			}
		}).then(response => {
			modal = {
				header: {
					body: '<div>Item Information</div>',
					class: "editor_modal_title"
				},
				body: {
					body: response,
					class: "editor_modal_content",
					style: "height: auto;"
				},
				footer: {
					body: [
						{
							label: 'Update',
							class: "inf_update_btn bg-primary text-white",
							style: "display: none;",
							onAction: () => updateItemInfData()
						}
					],
					class: "editor_modal_action"
				},
				width: 520
			};

			AH.activate(0);
			handleModal(modal);
		});
	}

	AH.listen(document, 'change', '#cong_level', function (_this) {
		updateItemInfData(_this);
	});

	function updateItemInfData(item) {
		if (item) {
			if (item.getAttribute('icon')) {
				AH.removeClass(".item_icon_list .active", 'active');
				AH.addClass(item, "active");
			} else if (item.id == "cong_level") {
				AH.set("cong_level", item.value);
			} else {
				item.setAttribute('contentEditable', true);
			}

			AH.select(".inf_update_btn").style.display = "inline-block";
		} else {
			AH.activate(2);

			let queryData = {
				ajax: "1",
				action: 'update_editor_item_inf',
				content_guid: AH.get('current_guid'),
				ref_id: AH.select(".item_ref_id").textContent,
				isDraft: AH.get('draft'),
				content_icon: AH.get("current_item_icon"),
				cong_level: AH.get("cong_level"),
				course: editor.course,
				anno_id: AH.select("#cong_level").getAttribute('annoid')
			};

			AH.ajax({
				url: baseUrl + 'editor/index.php',
				data: queryData
			}).then(response => {
				AH.activate(0);
				console.log(response);

				if (response == 1) {
					AH.showmsg("Data updated successfully.");
				} else {
					AH.showmsg("Updation failed.");
				}
			});
		}
	}

	function handleHelp(type) {
		let videoUrl = "";

		if (type == "editor") {
			videoUrl = editorConfig.editorVideo(editorState);
		} else if (itemHelper.UI && itemHelper.UI.helpVideo) {
			videoUrl = typeof itemHelper.UI.helpVideo == "object"
			? itemHelper.UI.helpVideo[editorState.content_icon]
			: itemHelper.UI.helpVideo;
		}

		let videoHtml = videoUrl
		? `<video src="${videoUrl}&amp;profile_id=174" controls height="100%" width="100%" height="100%" width="100%" autoplay />`
		: 'Help video not available for this item.';

		modal = {
			header: {
				body: type == "editor"
				? "Editor Help Video"
				: "Item Help Video",
				class: "editor_modal_title"
			},
			body: {
				body: videoHtml,
				class: "editor_modal_content",
				style: "width:669px"
			},
			footer: { body: [], class: "editor_modal_action" },
			width: 700
		};

		handleModal(modal);
	}

	function callPendingAction() {
		if (from_myproject == 1 && AH.get('unSavedProjectData')) {
			AH.set("unSavedProjectData", false);

			if (window.parent.close_frame_modal) {
				window.parent.close_frame_modal();
			} else {
				window.parent.editorClose();
			}
		} else if (AH.get("unSavedBack")) {
			AH.set("unSavedBack", false);
			goBack();
		} else if (AH.get('moveAction') && editorUrl.get('router_guid')) {
			navigate(AH.get('router_action'), AH.get('router_data'));
		}
	}

	function goBack() {
		let urlVars = AH.getUrlVars();
		let func = urlVars["func"];
		let action = urlVars["action"];

		let directNavigate = urlVars['content_subtype'] && urlVars['content_type']
		? 1
		: 0;

		if (func && func == "navigate_items" || action && action == "edit" || directNavigate == 1) {
			if (urlVars["from_myproject"] == 1) {
				window.location.href = baseUrl + "editor/?action=new&no_header=1$from_myproject=1&in_frame=1&in_full_preview=1&is_overlay=1";
			} else {
				//window.location.href = baseUrl + "editor/?action=new&no_header=1";
				//this.props.editorParent("addNew");
				updateEditorModule("", "", "addNew");
			}
		} else {
			setTimeout(
				function () {
					$$invalidate(0, editorState.myComponent = "back", editorState);
				},
				200
			);

			state.myComponent = "blank";
		}
	}

	function handleKeyboardShortcut() {
		modal = {
			header: {
				body: l.keyboard_shortcut,
				class: "editor_modal_title"
			},
			body: {
				body: editorConfig.keyboardShortcutLayout(),
				class: "editor_modal_content",
				style: "height:300px;"
			},
			footer: { body: [], class: "editor_modal_action" },
			width: 500
		};

		handleModal(modal);
	}

	function createVariableCall() {
		if (editorState.variable_button) ;
	}

	function toggleDevice(deviceName) {
		let arrIndex = '';

		if (deviceName == "mobile") arrIndex = 0; else if (deviceName == "tab") arrIndex = 1; else {
			AH.select("#previewSection").setAttribute('style', "overflow-x: auto; padding-bottom: 15px;");
			AH.select("#layoutMode").setAttribute('style', "");
			return;
		}

		AH.select("#previewSection").setAttribute('style', deviceIframeContainer[arrIndex]);
		AH.select("#layoutMode").setAttribute('style', deviceIframeProperty[arrIndex]);
	}

	const writable_props = [
		'editorState',
		'itemHelper',
		'handleModal',
		'updateEditorModule',
		'toolMenu',
		'handleCheckbox',
		'editAlgo',
		'solveVariable',
		'analyzeVariable',
		'toggleRemediation',
		'l'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<EditorHeader> was created with unknown prop '${key}'`);
	});

	const click_handler = menuData => menuData.funcName();

	const click_handler_1 = () => {
		$$invalidate(0, editorState.variable_button = false, editorState);
	};

	const click_handler_2 = () => checkNavigation(false);
	const click_handler_3 = () => checkNavigation(1);
	const click_handler_4 = () => handleHelp('editor');

	function sidepanel_visible_binding(value) {
		listDrawer = value;
		$$invalidate(15, listDrawer);
	}

	$$self.$$set = $$props => {
		if ('editorState' in $$props) $$invalidate(0, editorState = $$props.editorState);
		if ('itemHelper' in $$props) $$invalidate(25, itemHelper = $$props.itemHelper);
		if ('handleModal' in $$props) $$invalidate(26, handleModal = $$props.handleModal);
		if ('updateEditorModule' in $$props) $$invalidate(27, updateEditorModule = $$props.updateEditorModule);
		if ('toolMenu' in $$props) $$invalidate(1, toolMenu = $$props.toolMenu);
		if ('handleCheckbox' in $$props) $$invalidate(2, handleCheckbox = $$props.handleCheckbox);
		if ('editAlgo' in $$props) $$invalidate(3, editAlgo = $$props.editAlgo);
		if ('solveVariable' in $$props) $$invalidate(4, solveVariable = $$props.solveVariable);
		if ('analyzeVariable' in $$props) $$invalidate(5, analyzeVariable = $$props.analyzeVariable);
		if ('toggleRemediation' in $$props) $$invalidate(6, toggleRemediation = $$props.toggleRemediation);
		if ('l' in $$props) $$invalidate(28, l = $$props.l);
	};

	$$self.$capture_state = () => ({
		Menu,
		Menuitem,
		Button,
		Sidepanel,
		editorConfig,
		AH,
		onMount,
		tick,
		editorState,
		itemHelper,
		handleModal,
		updateEditorModule,
		toolMenu,
		handleCheckbox,
		editAlgo,
		solveVariable,
		analyzeVariable,
		toggleRemediation,
		l,
		deviceIframeContainer,
		deviceIframeProperty,
		openGudids,
		editorRouter,
		modal,
		isNew,
		editorUrl,
		guid_group,
		itemDetails,
		currentGuid,
		editorSeq,
		totalItem,
		listDrawer,
		closeEditor,
		onItemListButton,
		loadRouterGuids,
		loadSelectedItem,
		onListButton,
		checkNavigation,
		navigate,
		showContext,
		showItemMeta,
		updateItemInfData,
		handleHelp,
		callPendingAction,
		goBack,
		handleKeyboardShortcut,
		createVariableCall,
		toggleDevice
	});

	$$self.$inject_state = $$props => {
		if ('editorState' in $$props) $$invalidate(0, editorState = $$props.editorState);
		if ('itemHelper' in $$props) $$invalidate(25, itemHelper = $$props.itemHelper);
		if ('handleModal' in $$props) $$invalidate(26, handleModal = $$props.handleModal);
		if ('updateEditorModule' in $$props) $$invalidate(27, updateEditorModule = $$props.updateEditorModule);
		if ('toolMenu' in $$props) $$invalidate(1, toolMenu = $$props.toolMenu);
		if ('handleCheckbox' in $$props) $$invalidate(2, handleCheckbox = $$props.handleCheckbox);
		if ('editAlgo' in $$props) $$invalidate(3, editAlgo = $$props.editAlgo);
		if ('solveVariable' in $$props) $$invalidate(4, solveVariable = $$props.solveVariable);
		if ('analyzeVariable' in $$props) $$invalidate(5, analyzeVariable = $$props.analyzeVariable);
		if ('toggleRemediation' in $$props) $$invalidate(6, toggleRemediation = $$props.toggleRemediation);
		if ('l' in $$props) $$invalidate(28, l = $$props.l);
		if ('deviceIframeContainer' in $$props) deviceIframeContainer = $$props.deviceIframeContainer;
		if ('deviceIframeProperty' in $$props) deviceIframeProperty = $$props.deviceIframeProperty;
		if ('openGudids' in $$props) $$invalidate(9, openGudids = $$props.openGudids);
		if ('editorRouter' in $$props) $$invalidate(10, editorRouter = $$props.editorRouter);
		if ('modal' in $$props) modal = $$props.modal;
		if ('isNew' in $$props) $$invalidate(16, isNew = $$props.isNew);
		if ('editorUrl' in $$props) editorUrl = $$props.editorUrl;
		if ('guid_group' in $$props) guid_group = $$props.guid_group;
		if ('itemDetails' in $$props) $$invalidate(11, itemDetails = $$props.itemDetails);
		if ('currentGuid' in $$props) $$invalidate(12, currentGuid = $$props.currentGuid);
		if ('editorSeq' in $$props) $$invalidate(13, editorSeq = $$props.editorSeq);
		if ('totalItem' in $$props) $$invalidate(14, totalItem = $$props.totalItem);
		if ('listDrawer' in $$props) $$invalidate(15, listDrawer = $$props.listDrawer);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		editorState,
		toolMenu,
		handleCheckbox,
		editAlgo,
		solveVariable,
		analyzeVariable,
		toggleRemediation,
		onItemListButton,
		checkNavigation,
		openGudids,
		editorRouter,
		itemDetails,
		currentGuid,
		editorSeq,
		totalItem,
		listDrawer,
		isNew,
		closeEditor,
		loadSelectedItem,
		onListButton,
		showContext,
		showItemMeta,
		handleHelp,
		handleKeyboardShortcut,
		toggleDevice,
		itemHelper,
		handleModal,
		updateEditorModule,
		l,
		callPendingAction,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		sidepanel_visible_binding
	];
}

class EditorHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$d,
			create_fragment$d,
			safe_not_equal,
			{
				editorState: 0,
				itemHelper: 25,
				handleModal: 26,
				updateEditorModule: 27,
				toolMenu: 1,
				handleCheckbox: 2,
				editAlgo: 3,
				solveVariable: 4,
				analyzeVariable: 5,
				toggleRemediation: 6,
				l: 28,
				onItemListButton: 7,
				checkNavigation: 8,
				callPendingAction: 29
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditorHeader",
			options,
			id: create_fragment$d.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*editorState*/ ctx[0] === undefined && !('editorState' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'editorState'");
		}

		if (/*itemHelper*/ ctx[25] === undefined && !('itemHelper' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'itemHelper'");
		}

		if (/*handleModal*/ ctx[26] === undefined && !('handleModal' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'handleModal'");
		}

		if (/*updateEditorModule*/ ctx[27] === undefined && !('updateEditorModule' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'updateEditorModule'");
		}

		if (/*toolMenu*/ ctx[1] === undefined && !('toolMenu' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'toolMenu'");
		}

		if (/*handleCheckbox*/ ctx[2] === undefined && !('handleCheckbox' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'handleCheckbox'");
		}

		if (/*editAlgo*/ ctx[3] === undefined && !('editAlgo' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'editAlgo'");
		}

		if (/*solveVariable*/ ctx[4] === undefined && !('solveVariable' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'solveVariable'");
		}

		if (/*analyzeVariable*/ ctx[5] === undefined && !('analyzeVariable' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'analyzeVariable'");
		}

		if (/*toggleRemediation*/ ctx[6] === undefined && !('toggleRemediation' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'toggleRemediation'");
		}

		if (/*l*/ ctx[28] === undefined && !('l' in props)) {
			console_1$2.warn("<EditorHeader> was created without expected prop 'l'");
		}
	}

	get editorState() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemHelper() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemHelper(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleModal() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handleModal(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateEditorModule() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateEditorModule(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toolMenu() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toolMenu(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleCheckbox() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handleCheckbox(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editAlgo() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editAlgo(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get solveVariable() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set solveVariable(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get analyzeVariable() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set analyzeVariable(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggleRemediation() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggleRemediation(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get l() {
		throw new Error("<EditorHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onItemListButton() {
		return this.$$.ctx[7];
	}

	set onItemListButton(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checkNavigation() {
		return this.$$.ctx[8];
	}

	set checkNavigation(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get callPendingAction() {
		return this.$$.ctx[29];
	}

	set callPendingAction(value) {
		throw new Error("<EditorHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\ModuleQtype.svelte generated by Svelte v3.40.2 */

function getItems(subtype, state) {
	return new Promise(async resolve => {
			if (state.viewConfig.isQuestion) {
				switch (subtype) {
					case 8:
					case 0:
						resolve({
							"auth": (await import('./MultipleChoice-37f159b0.js')).default,
							"preview": (await import('./MultipleChoicePreview-bd2cfdf9.js')).default,
							"default": await import('./defaultXML-16ff871d.js'),
							"UI": (await import('./mcqHelper-c04f8f79.js')).itemHelper
						});
						break;
					case 4:
						{
							let hotXml = XMLToJSON(state.xml);

							//let type = hotXml && hotXml.smxml && hotXml.smxml.div && ["w", "s", "p"].includes(hotXml.smxml.div._type);
							let type = state.content_icon == 2 || state.content_icon == 4
							? true
							: false;

							resolve({
								"auth": type
								? (await import('./HotspotToken-e2f981ae.js')).default
								: (await import('./Hotspot-2ed3840a.js')).default,
								"preview": type
								? (await import('./HotspotTokenPreview-94e54a1d.js')).default
								: (await import('./HotspotPreview-0d2f2990.js')).default,
								"default": await import('./defaultXML-de09391c.js'),
								"UI": (await import('./hotspotHelper-34929aec.js')).itemHelper
							});
						}
						break;
					case 9:
						resolve({
							"auth": (await import('./FillInTheBlanks-233be9f6.js')).default,
							"preview": (await import('./FillInTheBlanksPreview-a6adec71.js')).default,
							"default": await import('./defaultXML-3e42f3dc.js'),
							"UI": (await import('./fillHelper-8701d59c.js')).itemHelper
						});
						break;
					case 1:
					case 3:
					case 15:
						resolve({
							"auth": (await import('./DragNDrop-3c257d10.js')).default,
							"preview": (await import('./DragNDropPreview-2d92faa3.js')).default,
							"default": await import('./defaultXML-df5634a8.js'),
							"UI": (await import('./DNDHelper-0f083852.js')).itemHelper
						});
						break;
					case 27:
						resolve({
							"auth": (await import('./ChoiceMatrix-e2f107f0.js')).default,
							"preview": (await import('./ChoiceMatrixPreview-b6cc491a.js')).default,
							"default": await import('./defaultXML-be97fab8.js'),
							"UI": await import('./choiceMatrixHelper-46c08022.js')
						});
					case 22:
						resolve({
							"auth": (await import('./Web-5764dea4.js')).default,
							"preview": (await import('./Web-5764dea4.js')).default,
							"default": await import('./defaultXML-49f3ba22.js'),
							"UI": await import('./WebHelper-47cd1c00.js')
						});
						break;
					case 36:
						resolve({
							"auth": (await import('./Insight-80172163.js')).default,
							"preview": "",
							"default": await import('./defaultXML-e596b4f5.js'),
							"UI": (await import('./insightHelper-d1ce241f.js')).itemHelper
						});
						break;
					case 20:
						resolve({
							"auth": (await import('./Graph-2a7cbce1.js')).default,
							"preview": (await import('./GraphPreview-6ac60b16.js')).default,
							"default": await import('./defaultXML-6ea2e5f7.js'),
							"UI": {
								helpVideo: '//player.vimeo.com/external/287907354.hd.mp4?s=aacf37c33f846bc4478bbafc7cf300efdd569537'
							}
						});
						break;
					case 38:
						resolve({
							"auth": (await import('./ChartAuthoring-7ec134bc.js')).default,
							"preview": (await import('./ChartPreview-91b6d4a6.js')).default,
							"default": await import('./defaultXML-ae241a92.js'),
							"UI": {
								helpVideo: '//player.vimeo.com/external/287907081.hd.mp4?s=46e83309850cafe52d14223f1b94a5f6e2968c76'
							}
						});
						break;
					case 14:
						resolve({
							"auth": (await import('./MatchList-1a8c1e89.js')).default,
							"preview": (await import('./MatchListPreview-5d3e6ecf.js')).default,
							"default": await import('./defaultXML-de4453f0.js'),
							"UI": (await import('./MatchListHelper-4324fe3a.js')).itemHelper
						});
						break;
					case 56:
						resolve({
							"auth": (await import('./Gridded-bac0d428.js')).default,
							"preview": (await import('./GriddedPreview-83e324a1.js')).default,
							"default": await import('./defaultXML-659e701e.js'),
							"UI": ""
						});
						break;
					case 57:
						resolve({
							"auth": (await import('./ListAuthoring-ead05382.js')).default,
							"preview": (await import('./ListPreview-25d92a03.js')).default,
							"default": await import('./defaultXML-f5a6115b.js'),
							"UI": ""
						});
						break;
					case 37:
						resolve({
							"auth": (await import('./ItemPlugin-3e3a8791.js')).default,
							"preview": (await import('./ItemPluginPreview-12aea822.js')).default,
							"default": await import('./defaultXML-7266cba3.js'),
							"UI": await import('./itemPluginHelper-ca0d59cc.js')
						});
						break;
					case 16:
						resolve({
							"auth": (await import('./External-9a707aa1.js')).default,
							"preview": (await import('./External-9a707aa1.js')).default,
							"default": await import('./defaultXML-2d57e716.js'),
							"UI": (await import('./externalHelper-0e4dea6b.js')).itemHelper
						});
						break;
					case 17:
						resolve({
							"auth": (await import('./Labsimulation-eb6d7a51.js')).default,
							"preview": (await import('./Labsimulation-eb6d7a51.js')).default,
							"default": await import('./defaultXML-89f1a7e6.js'),
							"UI": (await import('./labSimHelper-3644cfaa.js')).itemHelper
						});
						break;
					case 24:
						resolve({
							"auth": (await import('./Eval-a429f1d7.js')).default,
							//"preview": (await import('../clsSMEval/Eval.svelte')).default,
							"default": await import('./defaultXML-6168fc6e.js'),
							"UI": (await import('./evalHelper-8894b746.js')).itemHelper
						});
						break;
					case 25:
						resolve({
							"auth": (await import('./VirtualLab-80ce1bc7.js')).default,
							"preview": (await import('./VirtualLabPreview-ea3f9f08.js')).default,
							"default": await import('./defaultXML-c72c0c2a.js'),
							"UI": (await import('./virtualLabHelper-122a9f18.js')).itemHelper
						});
						break;
					case 35:
						resolve({
							"auth": (await import('./AlignMatch-b5408a93.js')).default,
							"preview": (await import('./AlignMatchPreview-f5f0314d.js')).default,
							"default": await import('./defaultXML-2b989487.js'),
							"UI": (await import('./AlignMatchHelper-dcc078f2.js')).itemHelper
						});
						break;
					case 5:
						resolve({
							"auth": (await import('./Essay-325bda73.js')).default,
							"preview": (await import('./EssayPreview-5ea86120.js')).default,
							"default": await import('./defaultXML-ed8972dd.js'),
							"UI": {}
						});
						break;
					case 7:
						resolve({
							"auth": (await import('./TreeViewAuthoring-45d9ae60.js')).default,
							"preview": (await import('./TreeViewPreview-1a607484.js')).default,
							"default": await import('./defaultXML-f5f44c33.js'),
							"UI": {}
						});
						break;
					case 6:
						let xml = state.ajaxData.special_module_xml && XMLToJSON(state.ajaxData.special_module_xml);
						resolve({
							"auth": xml && xml.smxml.list._row && (xml && xml.smxml.list._col)
							? (await import('./ChooseMultiGrid-f85d651f.js')).default
							: (await import('./ChooseNReorder-7e2b911c.js')).default,
							"preview": xml && xml.smxml.list._row && (xml && xml.smxml.list._col)
							? (await import('./ChooseMultiGridPreview-686cd544.js')).default
							: (await import('./ChooseNReorderPreview-9e74e069.js')).default,
							"default": await import('./defaultXML-16189ec3.js'),
							"UI": xml && xml.smxml.list._row && (xml && xml.smxml.list._col)
							? (await import('./ChooseMultiGridHelper-c40fefc1.js')).itemHelper
							: (await import('./chooseHelper-f0e7d898.js')).itemHelper
						});
						break;
					case 26:
						resolve({
							"auth": (await import('./ChooseMultiGrid-f85d651f.js')).default,
							"preview": (await import('./ChooseMultiGridPreview-686cd544.js')).default,
							"default": await import('./defaultXML-16189ec3.js'),
							"UI": (await import('./ChooseMultiGridHelper-c40fefc1.js')).itemHelper
						});
						break;
					case 30:
						resolve({
							"auth": (await import('./SliderItem-01876e09.js')).default,
							"preview": (await import('./SliderItemPreview-18dc534f.js')).default,
							"default": await import('./defaultXML-cba78af8.js'),
							"UI": (await import('./SliderItemHelper-a8079621.js')).itemHelper
						});
						break;
					case 44:
						resolve({
							"auth": (await import('./ShadingAuth-0dc3e736.js')).default,
							"preview": (await import('./ShadingPreview-0bf53d7a.js')).default,
							"default": await import('./defaultXML-4372cd31.js'),
							"UI": {}
						});
						break;
					case 43:
						resolve({
							"auth": (await import('./AudioRecorder-b84eaf9d.js')).default,
							"preview": (await import('./AudioPreview-9c088a9f.js')).default,
							"default": await import('./defaultXML-9857dc92.js'),
							"UI": (await import('./AudioHelper-6a9b146a.js')).itemHelper
						});
						break;
					case 41:
						resolve({
							"auth": (await import('./Drawing-77d41ec0.js')).default,
							"preview": (await import('./DrawingPreview-71dbbf4a.js')).default,
							"default": await import('./defaultXML-ada8b772.js'),
							"UI": {}
						});
						break;
					default:
						resolve({
							"auth": (await import('./UnderDev-56fbf9d8.js')).default,
							"preview": (await import('./UnderDev-56fbf9d8.js')).default,
							"default": "",
							"UI": ""
						});
						break;
				}
			} else if (state.content_type == 'f') {
				switch (subtype) {
					case 2:
						resolve({
							"auth": (await import('./UnderDev-56fbf9d8.js')).default,
							"preview": (await import('./UnderDev-56fbf9d8.js')).default,
							"default": "",
							"UI": ""
						});
						break;
					case 45:
						resolve({
							"auth": (await import('./VideoPlus-999630bb.js')).default,
							"preview": "",
							"default": "",
							"UI": ""
						});
						break;
					case 52:
						resolve({
							"auth": (await import('./ObjectEditor-41760494.js')).default,
							"preview": (await import('./ObjectEditor-41760494.js')).default,
							"default": "",
							"UI": ""
						});
						break;
					default:
						resolve({
							"auth": (await import('./UnderDev-56fbf9d8.js')).default,
							"preview": (await import('./UnderDev-56fbf9d8.js')).default,
							"default": "",
							"UI": ""
						});
						break;
				}
			} else if (state.viewConfig.loadWebPages) {
				resolve({
					"auth": (await import('./WebPages-a3ba8062.js')).default,
					"preview": false,
					"default": "",
					"UI": ""
				});
			} else {
				resolve({
					"auth": (await import('./UnderDev-56fbf9d8.js')).default,
					"preview": (await import('./UnderDev-56fbf9d8.js')).default,
					"default": "",
					"UI": ""
				});
			}
		});
}

function oe(n){return l=>{const o=Object.keys(n.$$.callbacks),i=[];return o.forEach(o=>i.push(listen(l,o,e=>bubble(n,e)))),{destroy:()=>{i.forEach(e=>e());}}}}function ie(){return "undefined"!=typeof window&&!(window.CSS&&window.CSS.supports&&window.CSS.supports("(--foo: red)"))}function se(e){var t;return "r"===e.charAt(0)?e=(t=(t=e).match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))&&4===t.length?"#"+("0"+parseInt(t[1],10).toString(16)).slice(-2)+("0"+parseInt(t[2],10).toString(16)).slice(-2)+("0"+parseInt(t[3],10).toString(16)).slice(-2):"":"transparent"===e.toLowerCase()&&(e="#00000000"),e}const{document:re}=globals;function ae(e){let t;return {c(){t=element("div"),attr(t,"class","ripple svelte-po4fcb");},m(n,l){insert(n,t,l),e[5](t);},p:noop,i:noop,o:noop,d(n){n&&detach(t),e[5](null);}}}function ce(e,t){e.style.transform=t,e.style.webkitTransform=t;}function de(e,t){e.style.opacity=t.toString();}const ue=function(e,t){const n=["touchcancel","mouseleave","dragstart"];let l=t.currentTarget||t.target;if(l&&!l.classList.contains("ripple")&&(l=l.querySelector(".ripple")),!l)return;const o=l.dataset.event;if(o&&o!==e)return;l.dataset.event=e;const i=document.createElement("span"),{radius:s,scale:r,x:a,y:c,centerX:d,centerY:u}=((e,t)=>{const n=t.getBoundingClientRect(),l=function(e){return "TouchEvent"===e.constructor.name}(e)?e.touches[e.touches.length-1]:e,o=l.clientX-n.left,i=l.clientY-n.top;let s=0,r=.3;const a=t.dataset.center;t.dataset.circle?(r=.15,s=t.clientWidth/2,s=a?s:s+Math.sqrt((o-s)**2+(i-s)**2)/4):s=Math.sqrt(t.clientWidth**2+t.clientHeight**2)/2;const c=(t.clientWidth-2*s)/2+"px",d=(t.clientHeight-2*s)/2+"px";return {radius:s,scale:r,x:a?c:o-s+"px",y:a?d:i-s+"px",centerX:c,centerY:d}})(t,l),p=l.dataset.color,f=2*s+"px";i.className="animation",i.style.width=f,i.style.height=f,i.style.background=p,i.classList.add("animation--enter"),i.classList.add("animation--visible"),ce(i,`translate(${a}, ${c}) scale3d(${r},${r},${r})`),de(i,0),i.dataset.activated=String(performance.now()),l.appendChild(i),setTimeout(()=>{i.classList.remove("animation--enter"),i.classList.add("animation--in"),ce(i,`translate(${d}, ${u}) scale3d(1,1,1)`),de(i,.25);},0);const v="mousedown"===e?"mouseup":"touchend",h=function(){document.removeEventListener(v,h),n.forEach(e=>{document.removeEventListener(e,h);});const e=performance.now()-Number(i.dataset.activated),t=Math.max(250-e,0);setTimeout(()=>{i.classList.remove("animation--in"),i.classList.add("animation--out"),de(i,0),setTimeout(()=>{i&&l.removeChild(i),0===l.children.length&&delete l.dataset.event;},300);},t);};document.addEventListener(v,h),n.forEach(e=>{document.addEventListener(e,h,{passive:!0});});},pe=function(e){0===e.button&&ue(e.type,e);},fe=function(e){if(e.changedTouches)for(let t=0;t<e.changedTouches.length;++t)ue(e.type,e.changedTouches[t]);};function ve(e,t,n){let l,o,{center:i=!1}=t,{circle:s=!1}=t,{color:r="currentColor"}=t;return onMount(async()=>{await tick();try{i&&n(0,l.dataset.center="true",l),s&&n(0,l.dataset.circle="true",l),n(0,l.dataset.color=r,l),o=l.parentElement;}catch(e){}if(!o)return void console.error("Ripple: Trigger element not found.");let e=window.getComputedStyle(o);0!==e.position.length&&"static"!==e.position||(o.style.position="relative"),o.addEventListener("touchstart",fe,{passive:!0}),o.addEventListener("mousedown",pe,{passive:!0});}),onDestroy(()=>{o&&(o.removeEventListener("mousedown",pe),o.removeEventListener("touchstart",fe));}),e.$set=e=>{"center"in e&&n(1,i=e.center),"circle"in e&&n(2,s=e.circle),"color"in e&&n(3,r=e.color);},[l,i,s,r,o,function(e){binding_callbacks[e?"unshift":"push"](()=>{n(0,l=e);});}]}class he extends SvelteComponent{constructor(e){var t;super(),re.getElementById("svelte-po4fcb-style")||((t=element("style")).id="svelte-po4fcb-style",t.textContent=".ripple.svelte-po4fcb{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-po4fcb .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-po4fcb .animation--enter{transition:none}.ripple.svelte-po4fcb .animation--in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-po4fcb .animation--out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}",append(re.head,t)),init(this,e,ve,ae,safe_not_equal,{center:1,circle:2,color:3});}}function ge(e){let t;const n=new he({props:{center:e[3],circle:e[3]}});return {c(){create_component(n.$$.fragment);},m(e,l){mount_component(n,e,l),t=!0;},p(e,t){const l={};8&t&&(l.center=e[3]),8&t&&(l.circle=e[3]),n.$set(l);},i(e){t||(transition_in(n.$$.fragment,e),t=!0);},o(e){transition_out(n.$$.fragment,e),t=!1;},d(e){destroy_component(n,e);}}}function me(t){let n,l,o,i,a,d;const p=t[22].default,v=create_slot(p,t,t[21],null);let h=t[10]&&ge(t),b=[{class:t[1]},{style:t[2]},t[14]],E={};for(let e=0;e<b.length;e+=1)E=assign(E,b[e]);return {c(){n=element("button"),v&&v.c(),l=space(),h&&h.c(),set_attributes(n,E),toggle_class(n,"raised",t[6]),toggle_class(n,"outlined",t[8]&&!(t[6]||t[7])),toggle_class(n,"shaped",t[9]&&!t[3]),toggle_class(n,"dense",t[5]),toggle_class(n,"fab",t[4]&&t[3]),toggle_class(n,"icon-button",t[3]),toggle_class(n,"toggle",t[11]),toggle_class(n,"active",t[11]&&t[0]),toggle_class(n,"full-width",t[12]&&!t[3]),toggle_class(n,"svelte-6bcb3a",!0);},m(s,u){insert(s,n,u),v&&v.m(n,null),append(n,l),h&&h.m(n,null),t[23](n),i=!0,a||(d=[listen(n,"click",t[16]),action_destroyer(o=t[15].call(null,n))],a=!0);},p(e,[t]){v&&v.p&&2097152&t&&update_slot(v,p,e,e[21],t,null,null),e[10]?h?(h.p(e,t),1024&t&&transition_in(h,1)):(h=ge(e),h.c(),transition_in(h,1),h.m(n,null)):h&&(group_outros(),transition_out(h,1,1,()=>{h=null;}),check_outros()),set_attributes(n,E=get_spread_update(b,[2&t&&{class:e[1]},4&t&&{style:e[2]},16384&t&&e[14]])),toggle_class(n,"raised",e[6]),toggle_class(n,"outlined",e[8]&&!(e[6]||e[7])),toggle_class(n,"shaped",e[9]&&!e[3]),toggle_class(n,"dense",e[5]),toggle_class(n,"fab",e[4]&&e[3]),toggle_class(n,"icon-button",e[3]),toggle_class(n,"toggle",e[11]),toggle_class(n,"active",e[11]&&e[0]),toggle_class(n,"full-width",e[12]&&!e[3]),toggle_class(n,"svelte-6bcb3a",!0);},i(e){i||(transition_in(v,e),transition_in(h),i=!0);},o(e){transition_out(v,e),transition_out(h),i=!1;},d(e){e&&detach(n),v&&v.d(e),h&&h.d(),t[23](null),a=!1,run_all(d);}}}function be(e,t,n){const l=createEventDispatcher(),o=oe(current_component);let i,{class:s=""}=t,{style:r=null}=t,{icon:a=!1}=t,{fab:c=!1}=t,{dense:d=!1}=t,{raised:u=!1}=t,{unelevated:f=!1}=t,{outlined:v=!1}=t,{shaped:h=!1}=t,{color:g=null}=t,{ripple:m=!0}=t,{toggle:b=!1}=t,{active:x=!1}=t,{fullWidth:w=!1}=t,$={};beforeUpdate(()=>{if(!i)return;let e=i.getElementsByTagName("svg"),t=e.length;for(let n=0;n<t;n++)e[n].setAttribute("width",z+(b&&!a?2:0)),e[n].setAttribute("height",z+(b&&!a?2:0));n(13,i.style.backgroundColor=u||f?g:"transparent",i);let l=getComputedStyle(i).getPropertyValue("background-color");n(13,i.style.color=u||f?function(e="#ffffff"){let t,n,l,o,i,s;if(0===e.length&&(e="#ffffff"),e=se(e),e=String(e).replace(/[^0-9a-f]/gi,""),!new RegExp(/^(?:[0-9a-f]{3}){1,2}$/i).test(e))throw new Error("Invalid HEX color!");e.length<6&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]);const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t=parseInt(r[1],16)/255,n=parseInt(r[2],16)/255,l=parseInt(r[3],16)/255,o=t<=.03928?t/12.92:Math.pow((t+.055)/1.055,2.4),i=n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4),s=l<=.03928?l/12.92:Math.pow((l+.055)/1.055,2.4),.2126*o+.7152*i+.0722*s}(l)>.5?"#000":"#fff":g,i);});let z,{$$slots:k={},$$scope:D}=t;return e.$set=e=>{n(20,t=assign(assign({},t),exclude_internal_props(e))),"class"in e&&n(1,s=e.class),"style"in e&&n(2,r=e.style),"icon"in e&&n(3,a=e.icon),"fab"in e&&n(4,c=e.fab),"dense"in e&&n(5,d=e.dense),"raised"in e&&n(6,u=e.raised),"unelevated"in e&&n(7,f=e.unelevated),"outlined"in e&&n(8,v=e.outlined),"shaped"in e&&n(9,h=e.shaped),"color"in e&&n(17,g=e.color),"ripple"in e&&n(10,m=e.ripple),"toggle"in e&&n(11,b=e.toggle),"active"in e&&n(0,x=e.active),"fullWidth"in e&&n(12,w=e.fullWidth),"$$scope"in e&&n(21,D=e.$$scope);},e.$$.update=()=>{{const{style:e,icon:l,fab:o,dense:i,raised:s,unelevated:r,outlined:a,shaped:c,color:d,ripple:u,toggle:p,active:f,fullWidth:v,...h}=t;!h.disabled&&delete h.disabled,delete h.class,n(14,$=h);}56&e.$$.dirty&&(z=a?c?24:d?20:24:d?16:18),139264&e.$$.dirty&&("primary"===g?n(17,g=ie()?"#1976d2":"var(--primary, #1976d2)"):"accent"==g?n(17,g=ie()?"#f50057":"var(--accent, #f50057)"):!g&&i&&n(17,g=i.style.color||i.parentElement.style.color||(ie()?"#333":"var(--color, #333)")));},t=exclude_internal_props(t),[x,s,r,a,c,d,u,f,v,h,m,b,w,i,$,o,function(e){b&&(n(0,x=!x),l("change",x));},g,z,l,t,D,k,function(e){binding_callbacks[e?"unshift":"push"](()=>{n(13,i=e);});}]}class ye extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-6bcb3a-style")||((t=element("style")).id="svelte-6bcb3a-style",t.textContent="button.svelte-6bcb3a:disabled{cursor:default}button.svelte-6bcb3a{cursor:pointer;font-family:Roboto, Helvetica, sans-serif;font-family:var(--button-font-family, Roboto, Helvetica, sans-serif);font-size:0.875rem;font-weight:500;letter-spacing:0.75px;text-decoration:none;text-transform:uppercase;will-change:transform, opacity;margin:0;padding:0 16px;display:-ms-inline-flexbox;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;height:36px;border:none;outline:none;line-height:inherit;user-select:none;overflow:hidden;vertical-align:middle;border-radius:4px}button.svelte-6bcb3a::-moz-focus-inner{border:0}button.svelte-6bcb3a:-moz-focusring{outline:none}button.svelte-6bcb3a:before{box-sizing:inherit;border-radius:inherit;color:inherit;bottom:0;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.2s cubic-bezier(0.25, 0.8, 0.5, 1);will-change:background-color, opacity}.toggle.svelte-6bcb3a:before{box-sizing:content-box}.active.svelte-6bcb3a:before{background-color:currentColor;opacity:0.3}.raised.svelte-6bcb3a{box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 5px 0 rgba(0, 0, 0, 0.12)}.outlined.svelte-6bcb3a{padding:0 14px;border-style:solid;border-width:2px}.shaped.svelte-6bcb3a{border-radius:18px}.dense.svelte-6bcb3a{height:32px}.icon-button.svelte-6bcb3a{line-height:0.5;border-radius:50%;padding:8px;width:40px;height:40px;vertical-align:middle}.icon-button.outlined.svelte-6bcb3a{padding:6px}.icon-button.fab.svelte-6bcb3a{border:none;width:56px;height:56px;box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 18px 0 rgba(0, 0, 0, 0.12)}.icon-button.dense.svelte-6bcb3a{width:36px;height:36px}.icon-button.fab.dense.svelte-6bcb3a{width:40px;height:40px}.outlined.svelte-6bcb3a:not(.shaped) .ripple{border-radius:0 !important}.full-width.svelte-6bcb3a{width:100%}@media(hover: hover){button.svelte-6bcb3a:hover:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}button.focus-visible.svelte-6bcb3a:focus:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.3}button.focus-visible.toggle.svelte-6bcb3a:focus:not(.active):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}}",append(document.head,t)),init(this,e,be,me,safe_not_equal,{class:1,style:2,icon:3,fab:4,dense:5,raised:6,unelevated:7,outlined:8,shaped:9,color:17,ripple:10,toggle:11,active:0,fullWidth:12});}}function Re(e,t){if("Tab"!==e.key&&9!==e.keyCode)return;let n=function(e=document){return Array.prototype.slice.call(e.querySelectorAll('button, [href], select, textarea, input:not([type="hidden"]), [tabindex]:not([tabindex="-1"])')).filter((function(e){const t=window.getComputedStyle(e);return !e.disabled&&!e.getAttribute("disabled")&&!e.classList.contains("disabled")&&"none"!==t.display&&"hidden"!==t.visibility&&t.opacity>0}))}(t);if(0===n.length)return void e.preventDefault();let l=document.activeElement,o=n.indexOf(l);e.shiftKey?o<=0&&(n[n.length-1].focus(),e.preventDefault()):o>=n.length-1&&(n[0].focus(),e.preventDefault());}function tn(e){let t="hidden"===document.body.style.overflow;if(e&&t){let e=Math.abs(parseInt(document.body.style.top));document.body.style.cssText=null,document.body.removeAttribute("style"),window.scrollTo(0,e);}else e||t||(document.body.style.top="-"+Math.max(document.body.scrollTop,document.documentElement&&document.documentElement.scrollTop||0)+"px",document.body.style.position="fixed",document.body.style.width="100%",document.body.style.overflow="hidden");}const nn=e=>({}),ln=e=>({}),on=e=>({}),sn=e=>({}),rn=e=>({}),an=e=>({});function cn(t){let n,l,o,i,d,p,v,h,b,D,C,E,Y;const j=t[19].title,T=create_slot(j,t,t[18],an),N=t[19].default,B=create_slot(N,t,t[18],null),I=t[19].actions,S=create_slot(I,t,t[18],sn),q=t[19].footer,_=create_slot(q,t,t[18],ln);let H=[{class:"dialog "+t[1]},{style:`width: ${t[3]}px;${t[2]}`},{tabindex:"-1"},t[6]],O={};for(let e=0;e<H.length;e+=1)O=assign(O,H[e]);return {c(){n=element("div"),l=element("div"),o=element("div"),T&&T.c(),i=space(),d=element("div"),B&&B.c(),p=space(),S&&S.c(),v=space(),_&&_.c(),attr(o,"class","title svelte-1pkw9hl"),attr(d,"class","content svelte-1pkw9hl"),set_attributes(l,O),toggle_class(l,"svelte-1pkw9hl",!0),attr(n,"class","overlay svelte-1pkw9hl");},m(s,a){insert(s,n,a),append(n,l),append(l,o),T&&T.m(o,null),append(l,i),append(l,d),B&&B.m(d,null),append(l,p),S&&S.m(l,null),append(l,v),_&&_.m(l,null),t[21](l),C=!0,E||(Y=[action_destroyer(h=t[8].call(null,l)),listen(l,"mousedown",stop_propagation(t[20])),listen(l,"mouseenter",t[22]),listen(n,"mousedown",t[23]),listen(n,"mouseup",t[24])],E=!0);},p(e,t){T&&T.p&&262144&t&&update_slot(T,j,e,e[18],t,rn,an),B&&B.p&&262144&t&&update_slot(B,N,e,e[18],t,null,null),S&&S.p&&262144&t&&update_slot(S,I,e,e[18],t,on,sn),_&&_.p&&262144&t&&update_slot(_,q,e,e[18],t,nn,ln),set_attributes(l,O=get_spread_update(H,[2&t&&{class:"dialog "+e[1]},12&t&&{style:`width: ${e[3]}px;${e[2]}`},{tabindex:"-1"},64&t&&e[6]])),toggle_class(l,"svelte-1pkw9hl",!0);},i(e){C||(transition_in(T,e),transition_in(B,e),transition_in(S,e),transition_in(_,e),b||add_render_callback(()=>{b=create_in_transition(l,scale,{duration:180,opacity:.5,start:.75,easing:quintOut}),b.start();}),add_render_callback(()=>{D||(D=create_bidirectional_transition(n,fade,{duration:180},!0)),D.run(1);}),C=!0);},o(e){transition_out(T,e),transition_out(B,e),transition_out(S,e),transition_out(_,e),D||(D=create_bidirectional_transition(n,fade,{duration:180},!1)),D.run(0),C=!1;},d(e){e&&detach(n),T&&T.d(e),B&&B.d(e),S&&S.d(e),_&&_.d(e),t[21](null),e&&D&&D.end(),E=!1,run_all(Y);}}}function dn(t){let n,l,o,i,s=t[0]&&cn(t);return {c(){s&&s.c(),n=empty();},m(r,a){s&&s.m(r,a),insert(r,n,a),l=!0,o||(i=[listen(window,"keydown",t[10]),listen(window,"popstate",t[11])],o=!0);},p(e,[t]){e[0]?s?(s.p(e,t),1&t&&transition_in(s,1)):(s=cn(e),s.c(),transition_in(s,1),s.m(n.parentNode,n)):s&&(group_outros(),transition_out(s,1,1,()=>{s=null;}),check_outros());},i(e){l||(transition_in(s),l=!0);},o(e){transition_out(s),l=!1;},d(e){s&&s.d(e),e&&detach(n),o=!1,run_all(i);}}}function un(e,n,l){const o=createEventDispatcher(),i=oe(current_component);let s,{class:r=""}=n,{style:a=""}=n,{visible:c=!1}=n,{width:d=320}=n,{modal:u=!1}=n,{closeByEsc:f=!0}=n,{beforeClose:v=(()=>!0)}=n,h=!1,g={},m=!1;function b(e){v()&&(o("close",e),l(0,c=!1));}async function x(){if(!s)return;await tick();let e=s.querySelectorAll('input:not([type="hidden"])'),t=e.length,n=0;for(;n<t&&!e[n].getAttribute("autofocus");n++);n<t?e[n].focus():t>0?e[0].focus():s.focus(),o("open");}onMount(async()=>{await tick(),l(14,m=!0);}),onDestroy(()=>{m&&tn(!0);});let{$$slots:w={},$$scope:$}=n;return e.$set=e=>{l(17,n=assign(assign({},n),exclude_internal_props(e))),"class"in e&&l(1,r=e.class),"style"in e&&l(2,a=e.style),"visible"in e&&l(0,c=e.visible),"width"in e&&l(3,d=e.width),"modal"in e&&l(4,u=e.modal),"closeByEsc"in e&&l(12,f=e.closeByEsc),"beforeClose"in e&&l(13,v=e.beforeClose),"$$scope"in e&&l(18,$=e.$$scope);},e.$$.update=()=>{{const{style:e,visible:t,width:o,modal:i,closeByEsc:s,beforeClose:r,...a}=n;l(6,g=a);}16385&e.$$.dirty&&(c?(m&&tn(!1),x()):(l(5,h=!1),m&&tn(!0)));},n=exclude_internal_props(n),[c,r,a,d,u,h,g,s,i,b,function(e){const t="Escape";27!==e.keyCode&&e.key!==t&&e.code!==t||f&&b(t),c&&Re(e,s);},function(){l(0,c=!1);},f,v,m,o,x,n,$,w,function(n){bubble(e,n);},function(e){binding_callbacks[e?"unshift":"push"](()=>{l(7,s=e);});},()=>{l(5,h=!1);},()=>{l(5,h=!0);},()=>{h&&!u&&b("clickOutside");}]}class pn extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-1pkw9hl-style")||((t=element("style")).id="svelte-1pkw9hl-style",t.textContent=".overlay.svelte-1pkw9hl{background-color:rgba(0, 0, 0, 0.5);cursor:pointer;position:fixed;left:0;top:0;right:0;bottom:0;z-index:30;display:flex;justify-content:center;align-items:center}.dialog.svelte-1pkw9hl{position:relative;font-size:1rem;background:#eee;background:var(--bg-panel, #eee);border-radius:4px;cursor:auto;box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14),\n\t\t\t0 9px 46px 8px rgba(0, 0, 0, 0.12);z-index:40;max-height:80%;overflow-x:hidden;overflow-y:auto}.dialog.svelte-1pkw9hl:focus{outline:none}.dialog.svelte-1pkw9hl::-moz-focus-inner{border:0}.dialog.svelte-1pkw9hl:-moz-focusring{outline:none}div.svelte-1pkw9hl .actions{min-height:48px;padding:8px;display:flex;align-items:center}div.svelte-1pkw9hl .center{justify-content:center}div.svelte-1pkw9hl .left{justify-content:flex-start}div.svelte-1pkw9hl .right{justify-content:flex-end}.title.svelte-1pkw9hl{padding:16px 16px 12px;font-size:24px;line-height:36px;background:rgba(0, 0, 0, 0.1);background:var(--divider, rgba(0, 0, 0, 0.1))}.content.svelte-1pkw9hl{margin:16px}",append(document.head,t)),init(this,e,un,dn,safe_not_equal,{class:1,style:2,visible:0,width:3,modal:4,closeByEsc:12,beforeClose:13});}}

/* src\EditorModal.svelte generated by Svelte v3.40.2 */
const file$e = "src\\EditorModal.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (8:0) <Dialog width={modal.width} beforeClose={beforeCloseFunc} style="background-color:#fff; border-radius: 5px;" bind:visible>
function create_default_slot_2$1(ctx) {
	let h4;
	let raw0_value = /*modal*/ ctx[1].header.body + "";
	let h4_style_value;
	let t;
	let div;
	let raw1_value = /*modal*/ ctx[1].body.body + "";
	let div_style_value;

	const block = {
		c: function create() {
			h4 = element("h4");
			t = space();
			div = element("div");
			attr_dev(h4, "class", "mt-1 font21 mb-4");
			attr_dev(h4, "style", h4_style_value = "text-align: left; " + /*modal*/ ctx[1].header.style);
			add_location(h4, file$e, 8, 4, 297);
			attr_dev(div, "class", "modalContent");
			attr_dev(div, "style", div_style_value = "overflow-y: auto; overflow-x: hidden; " + /*modal*/ ctx[1].body.style);
			add_location(div, file$e, 11, 4, 425);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			h4.innerHTML = raw0_value;
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);
			div.innerHTML = raw1_value;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*modal*/ 2 && raw0_value !== (raw0_value = /*modal*/ ctx[1].header.body + "")) h4.innerHTML = raw0_value;
			if (dirty & /*modal*/ 2 && h4_style_value !== (h4_style_value = "text-align: left; " + /*modal*/ ctx[1].header.style)) {
				attr_dev(h4, "style", h4_style_value);
			}

			if (dirty & /*modal*/ 2 && raw1_value !== (raw1_value = /*modal*/ ctx[1].body.body + "")) div.innerHTML = raw1_value;
			if (dirty & /*modal*/ 2 && div_style_value !== (div_style_value = "overflow-y: auto; overflow-x: hidden; " + /*modal*/ ctx[1].body.style)) {
				attr_dev(div, "style", div_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(8:0) <Dialog width={modal.width} beforeClose={beforeCloseFunc} style=\\\"background-color:#fff; border-radius: 5px;\\\" bind:visible>",
		ctx
	});

	return block;
}

// (14:8) {#if modal.action}
function create_if_block$c(ctx) {
	let html_tag;
	let raw_value = /*modal*/ ctx[1].action.body + "";
	let html_anchor;

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*modal*/ 2 && raw_value !== (raw_value = /*modal*/ ctx[1].action.body + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$c.name,
		type: "if",
		source: "(14:8) {#if modal.action}",
		ctx
	});

	return block;
}

// (13:4) 
function create_actions_slot(ctx) {
	let div;
	let if_block = /*modal*/ ctx[1].action && create_if_block$c(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			attr_dev(div, "slot", "actions");
			attr_dev(div, "class", "actions center");
			set_style(div, "display", /*modal*/ ctx[1].action ? 'block' : 'none');
			add_location(div, file$e, 12, 4, 551);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (/*modal*/ ctx[1].action) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$c(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*modal*/ 2) {
				set_style(div, "display", /*modal*/ ctx[1].action ? 'block' : 'none');
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_actions_slot.name,
		type: "slot",
		source: "(13:4) ",
		ctx
	});

	return block;
}

// (17:8) <Button color="#ccc" unelevated={true} outlined={true} on:click={()=> visible = false}>
function create_default_slot_1$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cancel");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(17:8) <Button color=\\\"#ccc\\\" unelevated={true} outlined={true} on:click={()=> visible = false}>",
		ctx
	});

	return block;
}

// (19:12) <Button                   on:click={item.onAction}                  class= {item.class}                  style = {item.style}                  color= {item.color || "primary"}                  unelevated={true}               outlined={true}              >
function create_default_slot$3(ctx) {
	let t0_value = /*item*/ ctx[5].label + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*modal*/ 2 && t0_value !== (t0_value = /*item*/ ctx[5].label + "")) set_data_dev(t0, t0_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(19:12) <Button                   on:click={item.onAction}                  class= {item.class}                  style = {item.style}                  color= {item.color || \\\"primary\\\"}                  unelevated={true}               outlined={true}              >",
		ctx
	});

	return block;
}

// (18:8) {#each modal.footer.body as item, index}
function create_each_block$1(ctx) {
	let button;
	let current;

	button = new ye({
			props: {
				class: /*item*/ ctx[5].class,
				style: /*item*/ ctx[5].style,
				color: /*item*/ ctx[5].color || "primary",
				unelevated: true,
				outlined: true,
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", function () {
		if (is_function(/*item*/ ctx[5].onAction)) /*item*/ ctx[5].onAction.apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*modal*/ 2) button_changes.class = /*item*/ ctx[5].class;
			if (dirty & /*modal*/ 2) button_changes.style = /*item*/ ctx[5].style;
			if (dirty & /*modal*/ 2) button_changes.color = /*item*/ ctx[5].color || "primary";

			if (dirty & /*$$scope, modal*/ 258) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(18:8) {#each modal.footer.body as item, index}",
		ctx
	});

	return block;
}

// (16:4) 
function create_footer_slot(ctx) {
	let div;
	let button;
	let t;
	let current;

	button = new ye({
			props: {
				color: "#ccc",
				unelevated: true,
				outlined: true,
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[3]);
	let each_value = /*modal*/ ctx[1].footer.body;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file$e, 15, 4, 722);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			append_dev(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (dirty & /*modal*/ 2) {
				each_value = /*modal*/ ctx[1].footer.body;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(16:4) ",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let dialog;
	let updating_visible;
	let current;

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[4](value);
	}

	let dialog_props = {
		width: /*modal*/ ctx[1].width,
		beforeClose: /*beforeCloseFunc*/ ctx[2],
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot],
			actions: [create_actions_slot],
			default: [create_default_slot_2$1]
		},
		$$scope: { ctx }
	};

	if (/*visible*/ ctx[0] !== void 0) {
		dialog_props.visible = /*visible*/ ctx[0];
	}

	dialog = new pn({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, 'visible', dialog_visible_binding));

	const block = {
		c: function create() {
			create_component(dialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dialog_changes = {};
			if (dirty & /*modal*/ 2) dialog_changes.width = /*modal*/ ctx[1].width;
			if (dirty & /*beforeCloseFunc*/ 4) dialog_changes.beforeClose = /*beforeCloseFunc*/ ctx[2];

			if (dirty & /*$$scope, modal, visible*/ 259) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty & /*visible*/ 1) {
				updating_visible = true;
				dialog_changes.visible = /*visible*/ ctx[0];
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditorModal', slots, []);
	let { visible = false } = $$props;
	let { modal } = $$props;
	let { beforeCloseFunc = null } = $$props;
	const writable_props = ['visible', 'modal', 'beforeCloseFunc'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorModal> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, visible = false);

	function dialog_visible_binding(value) {
		visible = value;
		$$invalidate(0, visible);
	}

	$$self.$$set = $$props => {
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('modal' in $$props) $$invalidate(1, modal = $$props.modal);
		if ('beforeCloseFunc' in $$props) $$invalidate(2, beforeCloseFunc = $$props.beforeCloseFunc);
	};

	$$self.$capture_state = () => ({
		visible,
		modal,
		beforeCloseFunc,
		Dialog: pn,
		Button: ye
	});

	$$self.$inject_state = $$props => {
		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
		if ('modal' in $$props) $$invalidate(1, modal = $$props.modal);
		if ('beforeCloseFunc' in $$props) $$invalidate(2, beforeCloseFunc = $$props.beforeCloseFunc);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [visible, modal, beforeCloseFunc, click_handler, dialog_visible_binding];
}

class EditorModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { visible: 0, modal: 1, beforeCloseFunc: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditorModal",
			options,
			id: create_fragment$e.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*modal*/ ctx[1] === undefined && !('modal' in props)) {
			console.warn("<EditorModal> was created without expected prop 'modal'");
		}
	}

	get visible() {
		throw new Error("<EditorModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visible(value) {
		throw new Error("<EditorModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get modal() {
		throw new Error("<EditorModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set modal(value) {
		throw new Error("<EditorModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get beforeCloseFunc() {
		throw new Error("<EditorModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set beforeCloseFunc(value) {
		throw new Error("<EditorModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\PlayerItem.svelte generated by Svelte v3.40.2 */
const file$f = "src\\PlayerItem.svelte";

function add_css$d(target) {
	append_styles(target, "svelte-1yg1q29", ".row.svelte-1yg1q29{margin-right:0 !important;margin-left:0 !important}.alignRight.svelte-1yg1q29{right:10px}.alignLeft.svelte-1yg1q29{left:10px}.simButton.svelte-1yg1q29{right:18px;bottom:5px}.exhibitShow.svelte-1yg1q29{flex-grow:0;max-width:41.66667%;flex-basis:41.66667%\r\n}.exhibiLink.svelte-1yg1q29{flex-grow:0;max-width:16.66667%;flex-basis:16.66667%}.width8P.svelte-1yg1q29{width:80%}.exhibitbtnlnk.svelte-1yg1q29{right:18px;position:relative;top:10px}.embedovrlyBtn.svelte-1yg1q29{position:relative;top:8px;left:3px}.insertImageTxt.svelte-1yg1q29{width:78%;margin-right:8px}.insertBtn.svelte-1yg1q29{position:relative;bottom:18px;width:129px}.textTranscript.svelte-1yg1q29{width:60%;margin-right:33px}.custom_checkbox_new.svelte-1yg1q29{position:relative;width:20px;height:20px;margin-bottom:0;cursor:pointer;font-size:18px}.textWidth.svelte-1yg1q29{width:140px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxheWVySXRlbS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBdXhCQSxJQUFJLGVBQUMsQ0FBQyxBQUNGLFlBQVksQ0FBRSxDQUFDLENBQUMsVUFBVSxDQUMxQixXQUFXLENBQUUsQ0FBQyxDQUFDLFVBQVUsQUFDN0IsQ0FBQyxBQUNELFdBQVcsZUFBQyxDQUFDLEFBQ1QsTUFBTSxJQUFJLEFBQ2QsQ0FBQyxBQUNELFVBQVUsZUFBQyxDQUFDLEFBQ1IsSUFBSSxDQUFFLElBQUksQUFDZCxDQUFDLEFBS0QsVUFBVSxlQUFDLENBQUMsQUFDUixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxHQUFHLEFBQ2YsQ0FBQyxBQUNELFlBQVksZUFBQyxDQUFDLEFBQ1YsU0FBUyxDQUFFLENBQUMsQ0FDWixTQUFTLENBQUUsU0FBUyxDQUNwQixVQUFVLENBQUUsU0FBUztBQUN6QixDQUFDLEFBQ0QsV0FBVyxlQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsQ0FBQyxDQUNaLFNBQVMsQ0FBRSxTQUFTLENBQ3BCLFVBQVUsQ0FBRSxTQUFTLEFBQ3pCLENBQUMsQUFDRCxRQUFRLGVBQUMsQ0FBQyxBQUNOLEtBQUssQ0FBRSxHQUFHLEFBQ2QsQ0FBQyxBQUNELGNBQWMsZUFBQyxDQUFDLEFBQ1osS0FBSyxDQUFFLElBQUksQ0FDWCxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsSUFBSSxBQUNiLENBQUMsQUFDRCxjQUFjLGVBQUMsQ0FBQyxBQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxHQUFHLENBQ1IsSUFBSSxDQUFFLEdBQUcsQUFDYixDQUFDLEFBQ0QsZUFBZSxlQUFDLENBQUMsQUFDYixLQUFLLENBQUUsR0FBRyxDQUNWLFlBQVksQ0FBRSxHQUFHLEFBQ3JCLENBQUMsQUFDRCx5QkFBVSxDQUFDLEFBQ1AsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsS0FBSyxBQUNoQixDQUFDLEFBQ0QsZUFBZSxlQUFDLENBQUMsQUFDYixLQUFLLENBQUUsR0FBRyxDQUNWLGFBQWEsSUFBSSxBQUNyQixDQUFDLEFBSUQsb0JBQW9CLGVBQUMsQ0FBQyxBQUNsQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osYUFBYSxDQUFFLENBQUMsQ0FDaEIsTUFBTSxDQUFFLE9BQU8sQ0FDZixTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBaUJELFVBQVUsZUFBQyxDQUFDLEFBQ1IsS0FBSyxDQUFFLEtBQUssQUFDaEIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQbGF5ZXJJdGVtLnN2ZWx0ZSJdfQ== */");
}

// (752:4) {:else}
function create_else_block_5(ctx) {
	let div3;
	let p;
	let t0_value = /*l*/ ctx[7].knowledge_check + "";
	let t0;
	let t1;
	let div0;
	let textfield0;
	let t2;
	let div1;
	let textfield1;
	let t3;
	let div2;
	let input0;
	let input0_value_value;
	let t4;
	let label;
	let t5_value = /*l*/ ctx[7].graded + "";
	let t5;
	let t6;
	let input1;
	let input1_value_value;
	let current;
	let mounted;
	let dispose;

	textfield0 = new Textfield({
			props: {
				placeholder: /*l*/ ctx[7].enter_title,
				fullWidth: "true",
				id: "title",
				label: /*l*/ ctx[7].title
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].multi_item_id,
				id: "asset",
				label: /*l*/ ctx[7].item_id,
				error: /*playerState*/ ctx[0].msg != ''
				? /*playerState*/ ctx[0].msg
				: false,
				helperText: /*playerState*/ ctx[0].msg,
				is_multiple: "1"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = element("div");
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t2 = space();
			div1 = element("div");
			create_component(textfield1.$$.fragment);
			t3 = space();
			div2 = element("div");
			input0 = element("input");
			t4 = space();
			label = element("label");
			t5 = text(t5_value);
			t6 = space();
			input1 = element("input");
			attr_dev(p, "class", "mt-2 mb-sm");
			add_location(p, file$f, 753, 12, 39924);
			add_location(div0, file$f, 754, 12, 39983);
			attr_dev(div1, "class", "mt-sm");
			add_location(div1, file$f, 762, 12, 40226);
			attr_dev(input0, "type", "checkbox");
			input0.__value = input0_value_value = /*playerState*/ ctx[0].nofeedback;
			input0.value = input0.__value;
			attr_dev(input0, "color", "default");
			attr_dev(input0, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input0, "id", "graded_checkbox");
			add_location(input0, file$f, 774, 16, 40689);
			attr_dev(label, "for", "graded_checkbox");
			attr_dev(label, "class", "position-relative top_minus4");
			add_location(label, file$f, 782, 16, 41009);
			attr_dev(div2, "class", "mt-4");
			add_location(div2, file$f, 773, 12, 40653);
			attr_dev(input1, "type", "hidden");
			attr_dev(input1, "id", "nofeedback");
			attr_dev(input1, "name", "nofeedback");
			input1.value = input1_value_value = /*playerState*/ ctx[0].nofeedback ? 0 : 1;
			add_location(input1, file$f, 786, 12, 41167);
			attr_dev(div3, "class", "knowledge_check_tag");
			attr_dev(div3, "key", "tag_quiz");
			add_location(div3, file$f, 752, 8, 39862);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, p);
			append_dev(p, t0);
			append_dev(div3, t1);
			append_dev(div3, div0);
			mount_component(textfield0, div0, null);
			append_dev(div3, t2);
			append_dev(div3, div1);
			mount_component(textfield1, div1, null);
			append_dev(div3, t3);
			append_dev(div3, div2);
			append_dev(div2, input0);
			input0.checked = /*playerState*/ ctx[0].nofeedback;
			append_dev(div2, t4);
			append_dev(div2, label);
			append_dev(label, t5);
			append_dev(div3, t6);
			append_dev(div3, input1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input0, "change", /*input0_change_handler_5*/ ctx[46]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 128) && t0_value !== (t0_value = /*l*/ ctx[7].knowledge_check + "")) set_data_dev(t0, t0_value);
			const textfield0_changes = {};
			if (dirty[0] & /*l*/ 128) textfield0_changes.placeholder = /*l*/ ctx[7].enter_title;
			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].title;
			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};
			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].multi_item_id;
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].item_id;

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.error = /*playerState*/ ctx[0].msg != ''
			? /*playerState*/ ctx[0].msg
			: false;

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.helperText = /*playerState*/ ctx[0].msg;
			textfield1.$set(textfield1_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && input0_value_value !== (input0_value_value = /*playerState*/ ctx[0].nofeedback)) {
				prop_dev(input0, "__value", input0_value_value);
				input0.value = input0.__value;
			}

			if (dirty[0] & /*playerState*/ 1) {
				input0.checked = /*playerState*/ ctx[0].nofeedback;
			}

			if ((!current || dirty[0] & /*l*/ 128) && t5_value !== (t5_value = /*l*/ ctx[7].graded + "")) set_data_dev(t5, t5_value);

			if (!current || dirty[0] & /*playerState*/ 1 && input1_value_value !== (input1_value_value = /*playerState*/ ctx[0].nofeedback ? 0 : 1)) {
				prop_dev(input1, "value", input1_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_component(textfield0);
			destroy_component(textfield1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_5.name,
		type: "else",
		source: "(752:4) {:else}",
		ctx
	});

	return block;
}

// (738:44) 
function create_if_block_39(ctx) {
	let div1;
	let p;
	let t0_value = /*l*/ ctx[7].seq_des + "";
	let t0;
	let t1;
	let div0;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].enter_seq_title,
				id: "no",
				label: /*l*/ ctx[7].seq_lable,
				value: /*playerState*/ ctx[0].seq
			},
			$$inline: true
		});

	textfield.$on("blur", /*blur_handler*/ ctx[45]);

	const block = {
		c: function create() {
			div1 = element("div");
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			create_component(textfield.$$.fragment);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 739, 12, 39455);
			add_location(div0, file$f, 740, 12, 39500);
			attr_dev(div1, "class", "seq_tag");
			attr_dev(div1, "key", "tag_seq");
			add_location(div1, file$f, 738, 8, 39406);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, p);
			append_dev(p, t0);
			append_dev(div1, t1);
			append_dev(div1, div0);
			mount_component(textfield, div0, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 128) && t0_value !== (t0_value = /*l*/ ctx[7].seq_des + "")) set_data_dev(t0, t0_value);
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].enter_seq_title;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].seq_lable;
			if (dirty[0] & /*playerState*/ 1) textfield_changes.value = /*playerState*/ ctx[0].seq;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(textfield);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_39.name,
		type: "if",
		source: "(738:44) ",
		ctx
	});

	return block;
}

// (715:44) 
function create_if_block_38(ctx) {
	let div2;
	let p;
	let t0_value = /*l*/ ctx[7].snt_des + "";
	let t0;
	let t1;
	let div1;
	let div0;
	let label;
	let t2_value = /*l*/ ctx[7].des_txt + "";
	let t2;
	let t3;
	let select;
	let option0;
	let t4_value = /*l*/ ctx[7].snt_41 + "";
	let t4;
	let option1;
	let t5_value = /*l*/ ctx[7].snt_40 + "";
	let t5;
	let option2;
	let t6_value = /*l*/ ctx[7].snt_39 + "";
	let t6;
	let option3;
	let t7_value = /*l*/ ctx[7].snt_38 + "";
	let t7;
	let option4;
	let t8_value = /*l*/ ctx[7].snt_37 + "";
	let t8;
	let option5;
	let t9_value = /*l*/ ctx[7].snt_36 + "";
	let t9;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div2 = element("div");
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			label = element("label");
			t2 = text(t2_value);
			t3 = space();
			select = element("select");
			option0 = element("option");
			t4 = text(t4_value);
			option1 = element("option");
			t5 = text(t5_value);
			option2 = element("option");
			t6 = text(t6_value);
			option3 = element("option");
			t7 = text(t7_value);
			option4 = element("option");
			t8 = text(t8_value);
			option5 = element("option");
			t9 = text(t9_value);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 716, 12, 38114);
			attr_dev(label, "for", "refid");
			attr_dev(label, "class", "text-dark d-inline");
			add_location(label, file$f, 719, 20, 38273);
			option0.__value = "00cRX";
			option0.value = option0.__value;
			add_location(option0, file$f, 727, 24, 38715);
			option1.__value = "00cRV";
			option1.value = option1.__value;
			add_location(option1, file$f, 728, 24, 38782);
			option2.__value = "00cRn";
			option2.value = option2.__value;
			add_location(option2, file$f, 729, 24, 38877);
			option3.__value = "00cRC";
			option3.value = option3.__value;
			add_location(option3, file$f, 730, 24, 38972);
			option4.__value = "00cRb";
			option4.value = option4.__value;
			add_location(option4, file$f, 731, 24, 39067);
			option5.__value = "00cRB";
			option5.value = option5.__value;
			add_location(option5, file$f, 732, 24, 39162);
			attr_dev(select, "id", "refid");
			attr_dev(select, "name", "refid");
			attr_dev(select, "class", "text-left border p-2 ml-md clearfix width99 pointer");
			if (/*playerState*/ ctx[0].snt === void 0) add_render_callback(() => /*select_change_handler_9*/ ctx[43].call(select));
			add_location(select, file$f, 720, 20, 38360);
			attr_dev(div0, "class", "pt-2 col-xs-12 alignRight position-relative svelte-1yg1q29");
			add_location(div0, file$f, 718, 16, 38194);
			attr_dev(div1, "class", "row svelte-1yg1q29");
			add_location(div1, file$f, 717, 12, 38159);
			attr_dev(div2, "class", "snt_tag");
			attr_dev(div2, "key", "tag_snt");
			add_location(div2, file$f, 715, 8, 38065);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, p);
			append_dev(p, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, label);
			append_dev(label, t2);
			append_dev(div0, t3);
			append_dev(div0, select);
			append_dev(select, option0);
			append_dev(option0, t4);
			append_dev(select, option1);
			append_dev(option1, t5);
			append_dev(select, option2);
			append_dev(option2, t6);
			append_dev(select, option3);
			append_dev(option3, t7);
			append_dev(select, option4);
			append_dev(option4, t8);
			append_dev(select, option5);
			append_dev(option5, t9);
			select_option(select, /*playerState*/ ctx[0].snt);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_9*/ ctx[43]),
					listen_dev(select, "change", /*change_handler_11*/ ctx[44], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t0_value !== (t0_value = /*l*/ ctx[7].snt_des + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*l*/ 128 && t2_value !== (t2_value = /*l*/ ctx[7].des_txt + "")) set_data_dev(t2, t2_value);
			if (dirty[0] & /*l*/ 128 && t4_value !== (t4_value = /*l*/ ctx[7].snt_41 + "")) set_data_dev(t4, t4_value);
			if (dirty[0] & /*l*/ 128 && t5_value !== (t5_value = /*l*/ ctx[7].snt_40 + "")) set_data_dev(t5, t5_value);
			if (dirty[0] & /*l*/ 128 && t6_value !== (t6_value = /*l*/ ctx[7].snt_39 + "")) set_data_dev(t6, t6_value);
			if (dirty[0] & /*l*/ 128 && t7_value !== (t7_value = /*l*/ ctx[7].snt_38 + "")) set_data_dev(t7, t7_value);
			if (dirty[0] & /*l*/ 128 && t8_value !== (t8_value = /*l*/ ctx[7].snt_37 + "")) set_data_dev(t8, t8_value);
			if (dirty[0] & /*l*/ 128 && t9_value !== (t9_value = /*l*/ ctx[7].snt_36 + "")) set_data_dev(t9, t9_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].snt);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_38.name,
		type: "if",
		source: "(715:44) ",
		ctx
	});

	return block;
}

// (692:48) 
function create_if_block_37(ctx) {
	let div2;
	let p;
	let t0_value = /*l*/ ctx[7].player3d_des + "";
	let t0;
	let t1;
	let div0;
	let textfield0;
	let t2;
	let div1;
	let textfield1;
	let current;

	textfield0 = new Textfield({
			props: {
				id: "title",
				fullWidth: "true",
				label: /*l*/ ctx[7].title,
				placeholder: /*l*/ ctx[7].enter_title
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				fullWidth: "true",
				id: "asset",
				placeholder: /*l*/ ctx[7].multi_item_id,
				label: /*l*/ ctx[7].item_id,
				error: /*playerState*/ ctx[0].msg != ''
				? /*playerState*/ ctx[0].msg
				: false,
				helperText: /*playerState*/ ctx[0].msg,
				is_multiple: 1
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div2 = element("div");
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t2 = space();
			div1 = element("div");
			create_component(textfield1.$$.fragment);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 693, 12, 37301);
			add_location(div0, file$f, 694, 12, 37351);
			add_location(div1, file$f, 702, 12, 37594);
			attr_dev(div2, "class", "objects_tag");
			attr_dev(div2, "key", "tag_objects");
			add_location(div2, file$f, 692, 8, 37244);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, p);
			append_dev(p, t0);
			append_dev(div2, t1);
			append_dev(div2, div0);
			mount_component(textfield0, div0, null);
			append_dev(div2, t2);
			append_dev(div2, div1);
			mount_component(textfield1, div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 128) && t0_value !== (t0_value = /*l*/ ctx[7].player3d_des + "")) set_data_dev(t0, t0_value);
			const textfield0_changes = {};
			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].title;
			if (dirty[0] & /*l*/ 128) textfield0_changes.placeholder = /*l*/ ctx[7].enter_title;
			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};
			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].multi_item_id;
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].item_id;

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.error = /*playerState*/ ctx[0].msg != ''
			? /*playerState*/ ctx[0].msg
			: false;

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.helperText = /*playerState*/ ctx[0].msg;
			textfield1.$set(textfield1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(textfield0);
			destroy_component(textfield1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_37.name,
		type: "if",
		source: "(692:48) ",
		ctx
	});

	return block;
}

// (448:45) 
function create_if_block_21(ctx) {
	let div2;
	let t0;
	let t1;
	let t2;
	let t3;
	let div1;
	let div0;
	let label;
	let t4_value = /*l*/ ctx[7].type + "";
	let t4;
	let t5;
	let select;
	let option0;
	let t6_value = /*l*/ ctx[7].download_txt + "";
	let t6;
	let option1;
	let t7_value = /*l*/ ctx[7].exhibit_txt + "";
	let t7;
	let option2;
	let t8_value = /*l*/ ctx[7].pdf_txt + "";
	let t8;
	let option3;
	let t9_value = /*l*/ ctx[7].weblink_txt + "";
	let t9;
	let option4;
	let t10_value = /*l*/ ctx[7].embed_content + "";
	let t10;
	let t11;
	let t12;
	let t13;
	let current_block_type_index;
	let if_block6;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*playerState*/ ctx[0].type == 'download' && create_if_block_36(ctx);
	let if_block1 = /*playerState*/ ctx[0].type == 'pdf' && create_if_block_35(ctx);
	let if_block2 = /*playerState*/ ctx[0].type == 'exhibit' && create_if_block_34(ctx);
	let if_block3 = /*playerState*/ ctx[0].type == 'weblink' && create_if_block_33(ctx);
	let if_block4 = /*playerState*/ ctx[0].type == "exhibit" && create_if_block_32(ctx);
	let if_block5 = /*playerState*/ ctx[0].type == "download" && create_if_block_31(ctx);
	const if_block_creators = [create_if_block_22, create_else_block_3];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*playerState*/ ctx[0].type == 'embed_content') return 0;
		return 1;
	}

	current_block_type_index = select_block_type_4(ctx);
	if_block6 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			div1 = element("div");
			div0 = element("div");
			label = element("label");
			t4 = text(t4_value);
			t5 = space();
			select = element("select");
			option0 = element("option");
			t6 = text(t6_value);
			option1 = element("option");
			t7 = text(t7_value);
			option2 = element("option");
			t8 = text(t8_value);
			option3 = element("option");
			t9 = text(t9_value);
			option4 = element("option");
			t10 = text(t10_value);
			t11 = space();
			if (if_block4) if_block4.c();
			t12 = space();
			if (if_block5) if_block5.c();
			t13 = space();
			if_block6.c();
			attr_dev(label, "for", "type");
			attr_dev(label, "class", "text-dark d-inline");
			add_location(label, file$f, 463, 20, 24428);
			option0.__value = "download";
			option0.value = option0.__value;
			add_location(option0, file$f, 471, 24, 24875);
			option1.__value = "exhibit";
			option1.value = option1.__value;
			add_location(option1, file$f, 472, 24, 24951);
			option2.__value = "pdf";
			option2.value = option2.__value;
			add_location(option2, file$f, 473, 24, 25025);
			option3.__value = "weblink";
			option3.value = option3.__value;
			add_location(option3, file$f, 474, 24, 25091);
			option4.__value = "embed_content";
			option4.value = option4.__value;
			add_location(option4, file$f, 475, 24, 25165);
			attr_dev(select, "id", "type");
			attr_dev(select, "name", "type");
			attr_dev(select, "class", "text-left btn border mr p-2 ml-md mr-2 w-60 clearfix pointer");
			if (/*playerState*/ ctx[0].type === void 0) add_render_callback(() => /*select_change_handler_5*/ ctx[30].call(select));
			add_location(select, file$f, 464, 20, 24511);
			attr_dev(div0, "class", "pt-2 col-xs-10 alignRight position-relative svelte-1yg1q29");
			add_location(div0, file$f, 462, 16, 24349);
			attr_dev(div1, "container", "");
			attr_dev(div1, "class", "row svelte-1yg1q29");
			add_location(div1, file$f, 461, 12, 24304);
			attr_dev(div2, "class", "link_tag");
			attr_dev(div2, "key", "tag_link");
			add_location(div2, file$f, 448, 8, 23771);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t0);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t1);
			if (if_block2) if_block2.m(div2, null);
			append_dev(div2, t2);
			if (if_block3) if_block3.m(div2, null);
			append_dev(div2, t3);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, label);
			append_dev(label, t4);
			append_dev(div0, t5);
			append_dev(div0, select);
			append_dev(select, option0);
			append_dev(option0, t6);
			append_dev(select, option1);
			append_dev(option1, t7);
			append_dev(select, option2);
			append_dev(option2, t8);
			append_dev(select, option3);
			append_dev(option3, t9);
			append_dev(select, option4);
			append_dev(option4, t10);
			select_option(select, /*playerState*/ ctx[0].type);
			append_dev(div0, t11);
			if (if_block4) if_block4.m(div0, null);
			append_dev(div0, t12);
			if (if_block5) if_block5.m(div0, null);
			append_dev(div2, t13);
			if_blocks[current_block_type_index].m(div2, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_5*/ ctx[30]),
					listen_dev(select, "change", /*change_handler_7*/ ctx[31], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*playerState*/ ctx[0].type == 'download') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_36(ctx);
					if_block0.c();
					if_block0.m(div2, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*playerState*/ ctx[0].type == 'pdf') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_35(ctx);
					if_block1.c();
					if_block1.m(div2, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*playerState*/ ctx[0].type == 'exhibit') {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_34(ctx);
					if_block2.c();
					if_block2.m(div2, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*playerState*/ ctx[0].type == 'weblink') {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_33(ctx);
					if_block3.c();
					if_block3.m(div2, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if ((!current || dirty[0] & /*l*/ 128) && t4_value !== (t4_value = /*l*/ ctx[7].type + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty[0] & /*l*/ 128) && t6_value !== (t6_value = /*l*/ ctx[7].download_txt + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty[0] & /*l*/ 128) && t7_value !== (t7_value = /*l*/ ctx[7].exhibit_txt + "")) set_data_dev(t7, t7_value);
			if ((!current || dirty[0] & /*l*/ 128) && t8_value !== (t8_value = /*l*/ ctx[7].pdf_txt + "")) set_data_dev(t8, t8_value);
			if ((!current || dirty[0] & /*l*/ 128) && t9_value !== (t9_value = /*l*/ ctx[7].weblink_txt + "")) set_data_dev(t9, t9_value);
			if ((!current || dirty[0] & /*l*/ 128) && t10_value !== (t10_value = /*l*/ ctx[7].embed_content + "")) set_data_dev(t10, t10_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].type);
			}

			if (/*playerState*/ ctx[0].type == "exhibit") {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_32(ctx);
					if_block4.c();
					if_block4.m(div0, t12);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*playerState*/ ctx[0].type == "download") {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_31(ctx);
					if_block5.c();
					if_block5.m(div0, null);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block6 = if_blocks[current_block_type_index];

				if (!if_block6) {
					if_block6 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block6.c();
				} else {
					if_block6.p(ctx, dirty);
				}

				transition_in(if_block6, 1);
				if_block6.m(div2, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_21.name,
		type: "if",
		source: "(448:45) ",
		ctx
	});

	return block;
}

// (269:46) 
function create_if_block_12(ctx) {
	let div3;
	let t0;
	let div0;
	let label;
	let t1_value = /*l*/ ctx[7].type + "";
	let t1;
	let t2;
	let select;
	let option0;
	let t3_value = /*l*/ ctx[7].audio_txt + "";
	let t3;
	let option1;
	let t4_value = /*l*/ ctx[7].video_txt + "";
	let t4;
	let t5;
	let div1;
	let textfield0;
	let t6;
	let div2;
	let textfield1;
	let t7;
	let div3_id_value;
	let current;
	let mounted;
	let dispose;

	function select_block_type_2(ctx, dirty) {
		if (/*playerState*/ ctx[0].type == 'audio') return create_if_block_20;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block0 = current_block_type(ctx);

	textfield0 = new Textfield({
			props: {
				id: "title",
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].enter_title,
				label: /*l*/ ctx[7].title,
				disabled: /*playerState*/ ctx[0].security && /*playerState*/ ctx[0].type == 'video'
				? true
				: false
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				id: "asset",
				fullWidth: "true",
				class: /*playerState*/ ctx[0].type == 'video'
				? "video_asset"
				: "audio_asset",
				placeholder: /*l*/ ctx[7].media_url,
				label: /*l*/ ctx[7].url_txt,
				disabled: /*playerState*/ ctx[0].security && /*playerState*/ ctx[0].type == 'video'
				? true
				: false
			},
			$$inline: true
		});

	textfield1.$on("change", function () {
		if (is_function(/*playerState*/ ctx[0].type == 'video'
		? /*change_handler_5*/ ctx[23]
		: null)) (/*playerState*/ ctx[0].type == 'video'
		? /*change_handler_5*/ ctx[23]
		: null).apply(this, arguments);
	});

	let if_block1 = /*playerState*/ ctx[0].type == 'video' && create_if_block_13(ctx);

	const block = {
		c: function create() {
			div3 = element("div");
			if_block0.c();
			t0 = space();
			div0 = element("div");
			label = element("label");
			t1 = text(t1_value);
			t2 = space();
			select = element("select");
			option0 = element("option");
			t3 = text(t3_value);
			option1 = element("option");
			t4 = text(t4_value);
			t5 = space();
			div1 = element("div");
			create_component(textfield0.$$.fragment);
			t6 = space();
			div2 = element("div");
			create_component(textfield1.$$.fragment);
			t7 = space();
			if (if_block1) if_block1.c();
			attr_dev(label, "for", "type");
			attr_dev(label, "class", "text-dark d-inline");
			add_location(label, file$f, 276, 16, 12800);
			option0.__value = "audio";
			option0.value = option0.__value;
			add_location(option0, file$f, 284, 20, 13215);
			option1.__value = "video";
			option1.value = option1.__value;
			add_location(option1, file$f, 285, 20, 13281);
			attr_dev(select, "id", "type");
			attr_dev(select, "name", "type");
			attr_dev(select, "class", "text-left btn border mr p-2 ml-md mr-2 w-60 clearfix pointer");
			if (/*playerState*/ ctx[0].type === void 0) add_render_callback(() => /*select_change_handler_4*/ ctx[21].call(select));
			add_location(select, file$f, 277, 16, 12879);
			attr_dev(div0, "class", "pt-1");
			add_location(div0, file$f, 275, 12, 12764);
			add_location(div1, file$f, 288, 12, 13386);
			attr_dev(div2, "class", "mt-sm");
			add_location(div2, file$f, 297, 12, 13730);
			attr_dev(div3, "class", "media_tag");

			attr_dev(div3, "id", div3_id_value = /*playerState*/ ctx[0].type == 'video'
			? "video_player_container"
			: 'audio_player_container');

			attr_dev(div3, "key", "tag_media");
			add_location(div3, file$f, 269, 8, 12433);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			if_block0.m(div3, null);
			append_dev(div3, t0);
			append_dev(div3, div0);
			append_dev(div0, label);
			append_dev(label, t1);
			append_dev(div0, t2);
			append_dev(div0, select);
			append_dev(select, option0);
			append_dev(option0, t3);
			append_dev(select, option1);
			append_dev(option1, t4);
			select_option(select, /*playerState*/ ctx[0].type);
			append_dev(div3, t5);
			append_dev(div3, div1);
			mount_component(textfield0, div1, null);
			append_dev(div3, t6);
			append_dev(div3, div2);
			mount_component(textfield1, div2, null);
			append_dev(div3, t7);
			if (if_block1) if_block1.m(div3, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_4*/ ctx[21]),
					listen_dev(select, "change", /*change_handler_4*/ ctx[22], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div3, t0);
				}
			}

			if ((!current || dirty[0] & /*l*/ 128) && t1_value !== (t1_value = /*l*/ ctx[7].type + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty[0] & /*l*/ 128) && t3_value !== (t3_value = /*l*/ ctx[7].audio_txt + "")) set_data_dev(t3, t3_value);
			if ((!current || dirty[0] & /*l*/ 128) && t4_value !== (t4_value = /*l*/ ctx[7].video_txt + "")) set_data_dev(t4, t4_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].type);
			}

			const textfield0_changes = {};
			if (dirty[0] & /*l*/ 128) textfield0_changes.placeholder = /*l*/ ctx[7].enter_title;
			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].title;

			if (dirty[0] & /*playerState*/ 1) textfield0_changes.disabled = /*playerState*/ ctx[0].security && /*playerState*/ ctx[0].type == 'video'
			? true
			: false;

			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.class = /*playerState*/ ctx[0].type == 'video'
			? "video_asset"
			: "audio_asset";

			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].media_url;
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].url_txt;

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.disabled = /*playerState*/ ctx[0].security && /*playerState*/ ctx[0].type == 'video'
			? true
			: false;

			textfield1.$set(textfield1_changes);

			if (/*playerState*/ ctx[0].type == 'video') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_13(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div3, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div3_id_value !== (div3_id_value = /*playerState*/ ctx[0].type == 'video'
			? "video_player_container"
			: 'audio_player_container')) {
				attr_dev(div3, "id", div3_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if_block0.d();
			destroy_component(textfield0);
			destroy_component(textfield1);
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(269:46) ",
		ctx
	});

	return block;
}

// (70:44) 
function create_if_block_1$3(ctx) {
	let div6;
	let p;
	let t0_value = /*labType*/ ctx[8][/*playerState*/ ctx[0].type] + "";
	let t0;
	let t1;
	let div1;
	let div0;
	let label;
	let t2_value = /*l*/ ctx[7].type + "";
	let t2;
	let t3;
	let select;
	let option0;
	let t4_value = /*l*/ ctx[7].playground + "";
	let t4;
	let option1;
	let t5_value = /*l*/ ctx[7].simulation_txt + "";
	let t5;
	let option2;
	let t6_value = /*l*/ ctx[7].terminal_txt + "";
	let t6;
	let option3;
	let t7_value = /*l*/ ctx[7].livelab + "";
	let t7;
	let option4;
	let t8_value = /*l*/ ctx[7].lab3d + "";
	let t8;
	let t9;
	let t10;
	let t11;
	let div3;
	let div2;
	let textfield;
	let t12;
	let t13;
	let div5;
	let div4;
	let current_block_type_index;
	let if_block3;
	let div4_class_value;
	let t14;
	let t15;
	let t16;
	let t17;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*playerState*/ ctx[0].type == "terminal" && create_if_block_11(ctx);
	let if_block1 = /*playerState*/ ctx[0].type == "insight" && create_if_block_10$1(ctx);

	textfield = new Textfield({
			props: {
				id: /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
				? "default"
				: "title",
				fullWidth: "1",
				label: /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
				? /*l*/ ctx[7].default
				: /*l*/ ctx[7].title,
				placeholder: /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
				? /*l*/ ctx[7].default_val
				: /*l*/ ctx[7].enter_title
			},
			$$inline: true
		});

	let if_block2 = /*playerState*/ ctx[0].type == 'playground' && /*playerState*/ ctx[0].oldPlayground && create_if_block_9$1(ctx);
	const if_block_creators = [create_if_block_8$1, create_else_block$3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*playerState*/ ctx[0].type == 'insight' && /*playerState*/ ctx[0].sub_type == 'scorm') return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block4 = /*playerState*/ ctx[0].type == 'simulation' && create_if_block_5$1(ctx);
	let if_block5 = /*playerState*/ ctx[0].type == 'insight' && /*playerState*/ ctx[0].sub_type == 'scorm' && create_if_block_4$1(ctx);
	let if_block6 = /*playerState*/ ctx[0].type == 'lablink' && create_if_block_3$1(ctx);
	let if_block7 = /*playerState*/ ctx[0].isplayer && create_if_block_2$3(ctx);

	const block = {
		c: function create() {
			div6 = element("div");
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			label = element("label");
			t2 = text(t2_value);
			t3 = space();
			select = element("select");
			option0 = element("option");
			t4 = text(t4_value);
			option1 = element("option");
			t5 = text(t5_value);
			option2 = element("option");
			t6 = text(t6_value);
			option3 = element("option");
			t7 = text(t7_value);
			option4 = element("option");
			t8 = text(t8_value);
			t9 = space();
			if (if_block0) if_block0.c();
			t10 = space();
			if (if_block1) if_block1.c();
			t11 = space();
			div3 = element("div");
			div2 = element("div");
			create_component(textfield.$$.fragment);
			t12 = space();
			if (if_block2) if_block2.c();
			t13 = space();
			div5 = element("div");
			div4 = element("div");
			if_block3.c();
			t14 = space();
			if (if_block4) if_block4.c();
			t15 = space();
			if (if_block5) if_block5.c();
			t16 = space();
			if (if_block6) if_block6.c();
			t17 = space();
			if (if_block7) if_block7.c();
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 71, 12, 2530);
			attr_dev(label, "for", "type");
			attr_dev(label, "class", "text-dark d-inline");
			add_location(label, file$f, 74, 20, 2700);
			option0.__value = "playground";
			option0.value = option0.__value;
			add_location(option0, file$f, 82, 24, 3148);
			option1.__value = "simulation";
			option1.value = option1.__value;
			add_location(option1, file$f, 83, 24, 3224);
			option2.__value = "terminal";
			option2.value = option2.__value;
			add_location(option2, file$f, 84, 24, 3304);
			option3.__value = "lablink";
			option3.value = option3.__value;
			add_location(option3, file$f, 85, 24, 3380);
			option4.__value = "insight";
			option4.value = option4.__value;
			add_location(option4, file$f, 86, 24, 3450);
			attr_dev(select, "id", "type");
			attr_dev(select, "name", "type");
			attr_dev(select, "class", "text-left btn border mr p-2 ml-md mr-2 w-60 clearfix pointer");
			if (/*playerState*/ ctx[0].type === void 0) add_render_callback(() => /*select_change_handler*/ ctx[11].call(select));
			add_location(select, file$f, 75, 20, 2784);
			attr_dev(div0, "class", "col-xs-12");
			add_location(div0, file$f, 73, 16, 2655);
			attr_dev(div1, "class", "row alignRight position-relative svelte-1yg1q29");
			add_location(div1, file$f, 72, 12, 2591);
			attr_dev(div2, "class", "col-xs-12");
			add_location(div2, file$f, 116, 16, 5025);
			attr_dev(div3, "class", "row alignRight position-relative svelte-1yg1q29");
			add_location(div3, file$f, 115, 12, 4960);

			attr_dev(div4, "class", div4_class_value = "col-xs-" + (/*playerState*/ ctx[0].type == 'simulation'
			? '9 mt-sm w-75'
			: '12'));

			add_location(div4, file$f, 141, 16, 6255);
			attr_dev(div5, "class", "row alignRight position-relative svelte-1yg1q29");
			add_location(div5, file$f, 140, 12, 6191);
			attr_dev(div6, "class", "lab_tag");
			attr_dev(div6, "key", "tag_lab");
			add_location(div6, file$f, 70, 8, 2481);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div6, anchor);
			append_dev(div6, p);
			append_dev(p, t0);
			append_dev(div6, t1);
			append_dev(div6, div1);
			append_dev(div1, div0);
			append_dev(div0, label);
			append_dev(label, t2);
			append_dev(div0, t3);
			append_dev(div0, select);
			append_dev(select, option0);
			append_dev(option0, t4);
			append_dev(select, option1);
			append_dev(option1, t5);
			append_dev(select, option2);
			append_dev(option2, t6);
			append_dev(select, option3);
			append_dev(option3, t7);
			append_dev(select, option4);
			append_dev(option4, t8);
			select_option(select, /*playerState*/ ctx[0].type);
			append_dev(div0, t9);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t10);
			if (if_block1) if_block1.m(div0, null);
			append_dev(div6, t11);
			append_dev(div6, div3);
			append_dev(div3, div2);
			mount_component(textfield, div2, null);
			append_dev(div6, t12);
			if (if_block2) if_block2.m(div6, null);
			append_dev(div6, t13);
			append_dev(div6, div5);
			append_dev(div5, div4);
			if_blocks[current_block_type_index].m(div4, null);
			append_dev(div5, t14);
			if (if_block4) if_block4.m(div5, null);
			append_dev(div6, t15);
			if (if_block5) if_block5.m(div6, null);
			append_dev(div6, t16);
			if (if_block6) if_block6.m(div6, null);
			append_dev(div6, t17);
			if (if_block7) if_block7.m(div6, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler*/ ctx[11]),
					listen_dev(select, "change", /*change_handler*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*playerState*/ 1) && t0_value !== (t0_value = /*labType*/ ctx[8][/*playerState*/ ctx[0].type] + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty[0] & /*l*/ 128) && t2_value !== (t2_value = /*l*/ ctx[7].type + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty[0] & /*l*/ 128) && t4_value !== (t4_value = /*l*/ ctx[7].playground + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty[0] & /*l*/ 128) && t5_value !== (t5_value = /*l*/ ctx[7].simulation_txt + "")) set_data_dev(t5, t5_value);
			if ((!current || dirty[0] & /*l*/ 128) && t6_value !== (t6_value = /*l*/ ctx[7].terminal_txt + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty[0] & /*l*/ 128) && t7_value !== (t7_value = /*l*/ ctx[7].livelab + "")) set_data_dev(t7, t7_value);
			if ((!current || dirty[0] & /*l*/ 128) && t8_value !== (t8_value = /*l*/ ctx[7].lab3d + "")) set_data_dev(t8, t8_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].type);
			}

			if (/*playerState*/ ctx[0].type == "terminal") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_11(ctx);
					if_block0.c();
					if_block0.m(div0, t10);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*playerState*/ ctx[0].type == "insight") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_10$1(ctx);
					if_block1.c();
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			const textfield_changes = {};

			if (dirty[0] & /*playerState*/ 1) textfield_changes.id = /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
			? "default"
			: "title";

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.label = /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
			? /*l*/ ctx[7].default
			: /*l*/ ctx[7].title;

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.placeholder = /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
			? /*l*/ ctx[7].default_val
			: /*l*/ ctx[7].enter_title;

			textfield.$set(textfield_changes);

			if (/*playerState*/ ctx[0].type == 'playground' && /*playerState*/ ctx[0].oldPlayground) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_9$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div6, t13);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block3 = if_blocks[current_block_type_index];

				if (!if_block3) {
					if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block3.c();
				} else {
					if_block3.p(ctx, dirty);
				}

				transition_in(if_block3, 1);
				if_block3.m(div4, null);
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div4_class_value !== (div4_class_value = "col-xs-" + (/*playerState*/ ctx[0].type == 'simulation'
			? '9 mt-sm w-75'
			: '12'))) {
				attr_dev(div4, "class", div4_class_value);
			}

			if (/*playerState*/ ctx[0].type == 'simulation') {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_5$1(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div5, null);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*playerState*/ ctx[0].type == 'insight' && /*playerState*/ ctx[0].sub_type == 'scorm') {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_4$1(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(div6, t16);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*playerState*/ ctx[0].type == 'lablink') {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_3$1(ctx);
					if_block6.c();
					if_block6.m(div6, t17);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*playerState*/ ctx[0].isplayer) {
				if (if_block7) ; else {
					if_block7 = create_if_block_2$3(ctx);
					if_block7.c();
					if_block7.m(div6, null);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(if_block5);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(if_block5);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div6);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component(textfield);
			if (if_block2) if_block2.d();
			if_blocks[current_block_type_index].d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(70:44) ",
		ctx
	});

	return block;
}

// (33:4) {#if playerState.category == "knowledge_check"}
function create_if_block$d(ctx) {
	let div3;
	let p;
	let t0_value = /*l*/ ctx[7].knowledge_check + "";
	let t0;
	let t1;
	let div0;
	let textfield0;
	let t2;
	let div1;
	let textfield1;
	let t3;
	let div2;
	let input0;
	let input0_value_value;
	let t4;
	let label;
	let t5_value = /*l*/ ctx[7].graded + "";
	let t5;
	let t6;
	let input1;
	let input1_value_value;
	let current;
	let mounted;
	let dispose;

	textfield0 = new Textfield({
			props: {
				placeholder: /*l*/ ctx[7].enter_title,
				fullWidth: "true",
				id: "title",
				label: /*l*/ ctx[7].title
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].multi_item_id,
				id: "asset",
				label: /*l*/ ctx[7].item_id,
				error: /*playerState*/ ctx[0].msg != ''
				? /*playerState*/ ctx[0].msg
				: false,
				helperText: /*playerState*/ ctx[0].msg,
				is_multiple: "1"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = element("div");
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t2 = space();
			div1 = element("div");
			create_component(textfield1.$$.fragment);
			t3 = space();
			div2 = element("div");
			input0 = element("input");
			t4 = space();
			label = element("label");
			t5 = text(t5_value);
			t6 = space();
			input1 = element("input");
			attr_dev(p, "class", "mt-2 mb-sm");
			add_location(p, file$f, 34, 12, 1070);
			add_location(div0, file$f, 35, 12, 1129);
			attr_dev(div1, "class", "mt-sm");
			add_location(div1, file$f, 43, 12, 1372);
			attr_dev(input0, "type", "checkbox");
			input0.__value = input0_value_value = /*playerState*/ ctx[0].nofeedback;
			input0.value = input0.__value;
			attr_dev(input0, "color", "default");
			attr_dev(input0, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input0, "id", "graded_checkbox");
			add_location(input0, file$f, 55, 16, 1835);
			attr_dev(label, "for", "graded_checkbox");
			attr_dev(label, "class", "position-relative top_minus4");
			add_location(label, file$f, 63, 16, 2155);
			attr_dev(div2, "class", "mt-4");
			add_location(div2, file$f, 54, 12, 1799);
			attr_dev(input1, "type", "hidden");
			attr_dev(input1, "id", "nofeedback");
			attr_dev(input1, "name", "nofeedback");
			input1.value = input1_value_value = /*playerState*/ ctx[0].nofeedback ? 0 : 1;
			add_location(input1, file$f, 67, 12, 2313);
			attr_dev(div3, "class", "knowledge_check_tag");
			attr_dev(div3, "key", "tag_quiz");
			add_location(div3, file$f, 33, 8, 1008);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, p);
			append_dev(p, t0);
			append_dev(div3, t1);
			append_dev(div3, div0);
			mount_component(textfield0, div0, null);
			append_dev(div3, t2);
			append_dev(div3, div1);
			mount_component(textfield1, div1, null);
			append_dev(div3, t3);
			append_dev(div3, div2);
			append_dev(div2, input0);
			input0.checked = /*playerState*/ ctx[0].nofeedback;
			append_dev(div2, t4);
			append_dev(div2, label);
			append_dev(label, t5);
			append_dev(div3, t6);
			append_dev(div3, input1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input0, "change", /*input0_change_handler*/ ctx[10]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 128) && t0_value !== (t0_value = /*l*/ ctx[7].knowledge_check + "")) set_data_dev(t0, t0_value);
			const textfield0_changes = {};
			if (dirty[0] & /*l*/ 128) textfield0_changes.placeholder = /*l*/ ctx[7].enter_title;
			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].title;
			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};
			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].multi_item_id;
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].item_id;

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.error = /*playerState*/ ctx[0].msg != ''
			? /*playerState*/ ctx[0].msg
			: false;

			if (dirty[0] & /*playerState*/ 1) textfield1_changes.helperText = /*playerState*/ ctx[0].msg;
			textfield1.$set(textfield1_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && input0_value_value !== (input0_value_value = /*playerState*/ ctx[0].nofeedback)) {
				prop_dev(input0, "__value", input0_value_value);
				input0.value = input0.__value;
			}

			if (dirty[0] & /*playerState*/ 1) {
				input0.checked = /*playerState*/ ctx[0].nofeedback;
			}

			if ((!current || dirty[0] & /*l*/ 128) && t5_value !== (t5_value = /*l*/ ctx[7].graded + "")) set_data_dev(t5, t5_value);

			if (!current || dirty[0] & /*playerState*/ 1 && input1_value_value !== (input1_value_value = /*playerState*/ ctx[0].nofeedback ? 0 : 1)) {
				prop_dev(input1, "value", input1_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_component(textfield0);
			destroy_component(textfield1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$d.name,
		type: "if",
		source: "(33:4) {#if playerState.category == \\\"knowledge_check\\\"}",
		ctx
	});

	return block;
}

// (450:12) {#if playerState.type == 'download'}
function create_if_block_36(ctx) {
	let p;
	let t_value = /*l*/ ctx[7].download_info + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 450, 16, 23876);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t_value !== (t_value = /*l*/ ctx[7].download_info + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_36.name,
		type: "if",
		source: "(450:12) {#if playerState.type == 'download'}",
		ctx
	});

	return block;
}

// (453:12) {#if playerState.type == 'pdf'}
function create_if_block_35(ctx) {
	let p;
	let t_value = /*l*/ ctx[7].pdf_info + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 453, 16, 23995);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t_value !== (t_value = /*l*/ ctx[7].pdf_info + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_35.name,
		type: "if",
		source: "(453:12) {#if playerState.type == 'pdf'}",
		ctx
	});

	return block;
}

// (456:12) {#if playerState.type == 'exhibit'}
function create_if_block_34(ctx) {
	let p;
	let t_value = /*l*/ ctx[7].exhibit_info + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 456, 16, 24113);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t_value !== (t_value = /*l*/ ctx[7].exhibit_info + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_34.name,
		type: "if",
		source: "(456:12) {#if playerState.type == 'exhibit'}",
		ctx
	});

	return block;
}

// (459:12) {#if playerState.type == 'weblink'}
function create_if_block_33(ctx) {
	let p;
	let t_value = /*l*/ ctx[7].weblink_info + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 459, 16, 24235);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t_value !== (t_value = /*l*/ ctx[7].weblink_info + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_33.name,
		type: "if",
		source: "(459:12) {#if playerState.type == 'weblink'}",
		ctx
	});

	return block;
}

// (478:20) {#if playerState.type == "exhibit"}
function create_if_block_32(ctx) {
	let select;
	let option0;
	let t0_value = /*l*/ ctx[7].item + "";
	let t0;
	let option1;
	let t1_value = /*l*/ ctx[7].image_txt + "";
	let t1;
	let option2;
	let t2_value = /*l*/ ctx[7].text + "";
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			select = element("select");
			option0 = element("option");
			t0 = text(t0_value);
			option1 = element("option");
			t1 = text(t1_value);
			option2 = element("option");
			t2 = text(t2_value);
			option0.__value = "item";
			option0.value = option0.__value;
			add_location(option0, file$f, 485, 28, 25732);
			option1.__value = "image";
			option1.value = option1.__value;
			add_location(option1, file$f, 486, 28, 25800);
			option2.__value = "text";
			option2.value = option2.__value;
			add_location(option2, file$f, 487, 28, 25874);
			attr_dev(select, "id", "sub_type");
			attr_dev(select, "name", "sub_type");
			attr_dev(select, "class", "text-left btn border p-2 width90 clearfix pointer");
			if (/*playerState*/ ctx[0].sub_type === void 0) add_render_callback(() => /*select_change_handler_6*/ ctx[32].call(select));
			add_location(select, file$f, 478, 24, 25335);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);
			append_dev(select, option0);
			append_dev(option0, t0);
			append_dev(select, option1);
			append_dev(option1, t1);
			append_dev(select, option2);
			append_dev(option2, t2);
			select_option(select, /*playerState*/ ctx[0].sub_type);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_6*/ ctx[32]),
					listen_dev(select, "change", /*change_handler_8*/ ctx[33], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t0_value !== (t0_value = /*l*/ ctx[7].item + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*l*/ 128 && t1_value !== (t1_value = /*l*/ ctx[7].image_txt + "")) set_data_dev(t1, t1_value);
			if (dirty[0] & /*l*/ 128 && t2_value !== (t2_value = /*l*/ ctx[7].text + "")) set_data_dev(t2, t2_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].sub_type);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_32.name,
		type: "if",
		source: "(478:20) {#if playerState.type == \\\"exhibit\\\"}",
		ctx
	});

	return block;
}

// (491:20) {#if playerState.type == "download"}
function create_if_block_31(ctx) {
	let select;
	let option0;
	let t0_value = /*l*/ ctx[7].select_img + "";
	let t0;
	let option1;
	let t1_value = /*l*/ ctx[7].download_txt + "";
	let t1;
	let option2;
	let t2_value = /*l*/ ctx[7].ms_access + "";
	let t2;
	let option3;
	let t3_value = /*l*/ ctx[7].ms_excel + "";
	let t3;
	let option4;
	let t4_value = /*l*/ ctx[7].ms_word + "";
	let t4;
	let option5;
	let t5_value = /*l*/ ctx[7].pdf_txt + "";
	let t5;
	let option6;
	let t6_value = /*l*/ ctx[7].sas_txt + "";
	let t6;
	let option7;
	let t7_value = /*l*/ ctx[7].text + "";
	let t7;
	let option8;
	let t8_value = /*l*/ ctx[7].zip_txt + "";
	let t8;

	const block = {
		c: function create() {
			select = element("select");
			option0 = element("option");
			t0 = text(t0_value);
			option1 = element("option");
			t1 = text(t1_value);
			option2 = element("option");
			t2 = text(t2_value);
			option3 = element("option");
			t3 = text(t3_value);
			option4 = element("option");
			t4 = text(t4_value);
			option5 = element("option");
			t5 = text(t5_value);
			option6 = element("option");
			t6 = text(t6_value);
			option7 = element("option");
			t7 = text(t7_value);
			option8 = element("option");
			t8 = text(t8_value);
			option0.__value = "";
			option0.value = option0.__value;
			add_location(option0, file$f, 492, 28, 26168);
			option1.__value = "ciw-integration/download-icon.png";
			option1.value = option1.__value;
			add_location(option1, file$f, 493, 28, 26238);
			option2.__value = "microsoft-office-access-icon-1_0008h7.png";
			option2.value = option2.__value;
			add_location(option2, file$f, 494, 28, 26343);
			option3.__value = "excel-icon_0008h9.png";
			option3.value = option3.__value;
			add_location(option3, file$f, 495, 28, 26453);
			option4.__value = "word_0009hl.png";
			option4.value = option4.__value;
			add_location(option4, file$f, 496, 28, 26542);
			option5.__value = "pdf_0003m4.png";
			option5.value = option5.__value;
			add_location(option5, file$f, 497, 28, 26624);
			option6.__value = "saslogo_0008AE.png";
			option6.value = option6.__value;
			add_location(option6, file$f, 498, 28, 26705);
			option7.__value = "text_0008ha.png";
			option7.value = option7.__value;
			add_location(option7, file$f, 499, 28, 26790);
			option8.__value = "zip-icon_000a4t.png";
			option8.value = option8.__value;
			add_location(option8, file$f, 500, 28, 26869);
			attr_dev(select, "id", "icon");
			attr_dev(select, "name", "icon");
			attr_dev(select, "class", "text-left btn border p-2 clearfix pointer");
			add_location(select, file$f, 491, 24, 26058);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);
			append_dev(select, option0);
			append_dev(option0, t0);
			append_dev(select, option1);
			append_dev(option1, t1);
			append_dev(select, option2);
			append_dev(option2, t2);
			append_dev(select, option3);
			append_dev(option3, t3);
			append_dev(select, option4);
			append_dev(option4, t4);
			append_dev(select, option5);
			append_dev(option5, t5);
			append_dev(select, option6);
			append_dev(option6, t6);
			append_dev(select, option7);
			append_dev(option7, t7);
			append_dev(select, option8);
			append_dev(option8, t8);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t0_value !== (t0_value = /*l*/ ctx[7].select_img + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*l*/ 128 && t1_value !== (t1_value = /*l*/ ctx[7].download_txt + "")) set_data_dev(t1, t1_value);
			if (dirty[0] & /*l*/ 128 && t2_value !== (t2_value = /*l*/ ctx[7].ms_access + "")) set_data_dev(t2, t2_value);
			if (dirty[0] & /*l*/ 128 && t3_value !== (t3_value = /*l*/ ctx[7].ms_excel + "")) set_data_dev(t3, t3_value);
			if (dirty[0] & /*l*/ 128 && t4_value !== (t4_value = /*l*/ ctx[7].ms_word + "")) set_data_dev(t4, t4_value);
			if (dirty[0] & /*l*/ 128 && t5_value !== (t5_value = /*l*/ ctx[7].pdf_txt + "")) set_data_dev(t5, t5_value);
			if (dirty[0] & /*l*/ 128 && t6_value !== (t6_value = /*l*/ ctx[7].sas_txt + "")) set_data_dev(t6, t6_value);
			if (dirty[0] & /*l*/ 128 && t7_value !== (t7_value = /*l*/ ctx[7].text + "")) set_data_dev(t7, t7_value);
			if (dirty[0] & /*l*/ 128 && t8_value !== (t8_value = /*l*/ ctx[7].zip_txt + "")) set_data_dev(t8, t8_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_31.name,
		type: "if",
		source: "(491:20) {#if playerState.type == \\\"download\\\"}",
		ctx
	});

	return block;
}

// (528:12) {:else}
function create_else_block_3(ctx) {
	let current_block_type_index;
	let if_block0;
	let t0;
	let div1;
	let div0;
	let textfield;
	let updating_value;
	let div0_class_value;
	let t1;
	let div1_class_value;
	let t2;
	let t3;
	let t4;
	let t5;
	let if_block5_anchor;
	let current;
	const if_block_creators = [create_if_block_30, create_else_block_4];
	const if_blocks = [];

	function select_block_type_5(ctx, dirty) {
		if (/*playerState*/ ctx[0].type != 'exhibit') return 0;
		return 1;
	}

	current_block_type_index = select_block_type_5(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function textfield_value_binding(value) {
		/*textfield_value_binding*/ ctx[37](value);
	}

	let textfield_props = {
		id: /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].exhibitType == 'link'
		? "layout"
		: "asset",
		fullWidth: "true",
		placeholder: /*playerState*/ ctx[0].type == 'exhibit'
		? /*l*/ ctx[7].enter_item
		: /*l*/ ctx[7].enter_url,
		label: /*playerState*/ ctx[0].type == 'exhibit'
		? /*l*/ ctx[7].item_id
		: /*l*/ ctx[7].url_txt,
		disabled: /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type != 'item'
		? true
		: false,
		error: /*playerState*/ ctx[0].msg != ''
		? /*playerState*/ ctx[0].msg
		: false,
		helperText: /*playerState*/ ctx[0].msg,
		is_multiple: /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'item'
		? 0
		: null
	};

	if (/*playerState*/ ctx[0].exhibitType !== void 0) {
		textfield_props.value = /*playerState*/ ctx[0].exhibitType;
	}

	textfield = new Textfield({ props: textfield_props, $$inline: true });
	binding_callbacks.push(() => bind(textfield, 'value', textfield_value_binding));
	let if_block1 = (/*playerState*/ ctx[0].type == 'weblink' || /*playerState*/ ctx[0].type == 'exhibit') && create_if_block_29(ctx);
	let if_block2 = (/*playerState*/ ctx[0].type == 'download' || /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image' || /*playerState*/ ctx[0].type == 'weblink' && /*playerState*/ ctx[0].embed != 'inline') && create_if_block_28(ctx);
	let if_block3 = /*playerState*/ ctx[0].type == 'weblink' && create_if_block_26(ctx);
	let if_block4 = /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'text' && create_if_block_25(ctx);
	let if_block5 = /*playerState*/ ctx[0].type == 'exhibit' && create_if_block_23(ctx);

	const block = {
		c: function create() {
			if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			create_component(textfield.$$.fragment);
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			t4 = space();
			if (if_block4) if_block4.c();
			t5 = space();
			if (if_block5) if_block5.c();
			if_block5_anchor = empty();

			attr_dev(div0, "class", div0_class_value = "mt-sm pr col-xs-" + (/*playerState*/ ctx[0].type == 'weblink'
			? '9 w-75'
			: /*playerState*/ ctx[0].type == 'exhibit'
				? '10 width8P'
				: '12') + " svelte-1yg1q29");

			add_location(div0, file$f, 571, 16, 30281);

			attr_dev(div1, "class", div1_class_value = /*playerState*/ ctx[0].type == 'exhibit'
			? 'd-flex'
			: /*playerState*/ ctx[0].type == 'weblink' ? 'd-flex' : '');

			add_location(div1, file$f, 570, 12, 30155);
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(textfield, div0, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			insert_dev(target, t2, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, t3, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t4, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, if_block5_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_5(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(t0.parentNode, t0);
			}

			const textfield_changes = {};

			if (dirty[0] & /*playerState*/ 1) textfield_changes.id = /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].exhibitType == 'link'
			? "layout"
			: "asset";

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.placeholder = /*playerState*/ ctx[0].type == 'exhibit'
			? /*l*/ ctx[7].enter_item
			: /*l*/ ctx[7].enter_url;

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.label = /*playerState*/ ctx[0].type == 'exhibit'
			? /*l*/ ctx[7].item_id
			: /*l*/ ctx[7].url_txt;

			if (dirty[0] & /*playerState*/ 1) textfield_changes.disabled = /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type != 'item'
			? true
			: false;

			if (dirty[0] & /*playerState*/ 1) textfield_changes.error = /*playerState*/ ctx[0].msg != ''
			? /*playerState*/ ctx[0].msg
			: false;

			if (dirty[0] & /*playerState*/ 1) textfield_changes.helperText = /*playerState*/ ctx[0].msg;

			if (dirty[0] & /*playerState*/ 1) textfield_changes.is_multiple = /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'item'
			? 0
			: null;

			if (!updating_value && dirty[0] & /*playerState*/ 1) {
				updating_value = true;
				textfield_changes.value = /*playerState*/ ctx[0].exhibitType;
				add_flush_callback(() => updating_value = false);
			}

			textfield.$set(textfield_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && div0_class_value !== (div0_class_value = "mt-sm pr col-xs-" + (/*playerState*/ ctx[0].type == 'weblink'
			? '9 w-75'
			: /*playerState*/ ctx[0].type == 'exhibit'
				? '10 width8P'
				: '12') + " svelte-1yg1q29")) {
				attr_dev(div0, "class", div0_class_value);
			}

			if (/*playerState*/ ctx[0].type == 'weblink' || /*playerState*/ ctx[0].type == 'exhibit') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_29(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div1_class_value !== (div1_class_value = /*playerState*/ ctx[0].type == 'exhibit'
			? 'd-flex'
			: /*playerState*/ ctx[0].type == 'weblink' ? 'd-flex' : '')) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (/*playerState*/ ctx[0].type == 'download' || /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image' || /*playerState*/ ctx[0].type == 'weblink' && /*playerState*/ ctx[0].embed != 'inline') {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_28(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t3.parentNode, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*playerState*/ ctx[0].type == 'weblink') {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_26(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t4.parentNode, t4);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'text') {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_25(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t5.parentNode, t5);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*playerState*/ ctx[0].type == 'exhibit') {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_23(ctx);
					if_block5.c();
					if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(textfield.$$.fragment, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(textfield.$$.fragment, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_component(textfield);
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t2);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(t3);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(if_block5_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(528:12) {:else}",
		ctx
	});

	return block;
}

// (506:12) {#if playerState.type == 'embed_content'}
function create_if_block_22(ctx) {
	let div1;
	let textfield;
	let t0;
	let div0;
	let input0;
	let input0_value_value;
	let t1;
	let label;
	let t2_value = /*l*/ ctx[7].inline + "";
	let t2;
	let t3;
	let input1;
	let input1_value_value;
	let current;
	let mounted;
	let dispose;

	textfield = new Textfield({
			props: {
				id: "asset",
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].enter_item,
				label: /*l*/ ctx[7].item_id,
				value: /*playerState*/ ctx[0].snt
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(textfield.$$.fragment);
			t0 = space();
			div0 = element("div");
			input0 = element("input");
			t1 = space();
			label = element("label");
			t2 = text(t2_value);
			t3 = space();
			input1 = element("input");
			attr_dev(input0, "type", "checkbox");
			attr_dev(input0, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input0, "id", "asset_checkbox");
			input0.__value = input0_value_value = /*playerState*/ ctx[0].inline;
			input0.value = input0.__value;
			attr_dev(input0, "color", "default");
			add_location(input0, file$f, 515, 24, 27453);
			attr_dev(label, "for", "asset_checkbox");
			attr_dev(label, "class", "position-relative top_minus4");
			add_location(label, file$f, 523, 24, 27830);
			attr_dev(input1, "type", "hidden");
			attr_dev(input1, "id", "inline");
			attr_dev(input1, "name", "inline");
			input1.value = input1_value_value = /*playerState*/ ctx[0].inline ? 1 : '';
			add_location(input1, file$f, 524, 24, 27939);
			attr_dev(div0, "class", "mt-4");
			add_location(div0, file$f, 514, 20, 27409);
			add_location(div1, file$f, 506, 16, 27104);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(textfield, div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, input0);
			input0.checked = /*playerState*/ ctx[0].inline;
			append_dev(div0, t1);
			append_dev(div0, label);
			append_dev(label, t2);
			append_dev(div0, t3);
			append_dev(div0, input1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input0, "change", /*input0_change_handler_2*/ ctx[34]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].enter_item;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].item_id;
			if (dirty[0] & /*playerState*/ 1) textfield_changes.value = /*playerState*/ ctx[0].snt;
			textfield.$set(textfield_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && input0_value_value !== (input0_value_value = /*playerState*/ ctx[0].inline)) {
				prop_dev(input0, "__value", input0_value_value);
				input0.value = input0.__value;
			}

			if (dirty[0] & /*playerState*/ 1) {
				input0.checked = /*playerState*/ ctx[0].inline;
			}

			if ((!current || dirty[0] & /*l*/ 128) && t2_value !== (t2_value = /*l*/ ctx[7].inline + "")) set_data_dev(t2, t2_value);

			if (!current || dirty[0] & /*playerState*/ 1 && input1_value_value !== (input1_value_value = /*playerState*/ ctx[0].inline ? 1 : '')) {
				prop_dev(input1, "value", input1_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(textfield);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_22.name,
		type: "if",
		source: "(506:12) {#if playerState.type == 'embed_content'}",
		ctx
	});

	return block;
}

// (539:12) {:else}
function create_else_block_4(ctx) {
	let div3;
	let div0;
	let textfield0;
	let div0_class_value;
	let t0;
	let div1;
	let textfield1;
	let div1_class_value;
	let t1;
	let div2;
	let select;
	let option0;
	let t2_value = /*l*/ ctx[7].btn_txt + "";
	let t2;
	let option1;
	let t3_value = /*l*/ ctx[7].link_txt + "";
	let t3;
	let div2_class_value;
	let current;
	let mounted;
	let dispose;

	textfield0 = new Textfield({
			props: {
				fullWidth: "true",
				id: "show_caption",
				label: /*l*/ ctx[7].show_caption,
				placeholder: /*l*/ ctx[7].img_show
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				fullWidth: "true",
				id: "hide_caption",
				label: /*l*/ ctx[7].hide_caption,
				placeholder: /*l*/ ctx[7].img_hide
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(textfield1.$$.fragment);
			t1 = space();
			div2 = element("div");
			select = element("select");
			option0 = element("option");
			t2 = text(t2_value);
			option1 = element("option");
			t3 = text(t3_value);
			attr_dev(div0, "item", "");

			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit'
			? 'mt-sm pr col-xs-5 exhibitShow'
			: 'mt-sm pr col-xs-5') + " svelte-1yg1q29"));

			add_location(div0, file$f, 540, 20, 28566);

			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit'
			? 'mt-sm col-xs-5 exhibitShow'
			: 'mt-sm col-xs-5') + " svelte-1yg1q29"));

			add_location(div1, file$f, 548, 20, 28988);
			option0.__value = "button";
			option0.value = option0.__value;
			add_location(option0, file$f, 564, 28, 29920);
			option1.__value = "link";
			option1.value = option1.__value;
			add_location(option1, file$f, 565, 28, 29993);
			attr_dev(select, "id", "layout");
			attr_dev(select, "name", "layout");
			attr_dev(select, "class", "text-left btn border p-2 clearfix mt-sm pointer");
			if (/*playerState*/ ctx[0].layout === void 0) add_render_callback(() => /*select_change_handler_7*/ ctx[35].call(select));
			add_location(select, file$f, 557, 24, 29533);

			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit'
			? 'pt-sm col-xs-2 exhibiLink exhibitbtnlnk'
			: 'pt-sm col-xs-2') + " svelte-1yg1q29"));

			add_location(div2, file$f, 556, 20, 29399);
			attr_dev(div3, "class", "row alignRight position-relative svelte-1yg1q29");
			add_location(div3, file$f, 539, 16, 28498);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			mount_component(textfield0, div0, null);
			append_dev(div3, t0);
			append_dev(div3, div1);
			mount_component(textfield1, div1, null);
			append_dev(div3, t1);
			append_dev(div3, div2);
			append_dev(div2, select);
			append_dev(select, option0);
			append_dev(option0, t2);
			append_dev(select, option1);
			append_dev(option1, t3);
			select_option(select, /*playerState*/ ctx[0].layout);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_7*/ ctx[35]),
					listen_dev(select, "change", /*change_handler_9*/ ctx[36], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};
			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].show_caption;
			if (dirty[0] & /*l*/ 128) textfield0_changes.placeholder = /*l*/ ctx[7].img_show;
			textfield0.$set(textfield0_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit'
			? 'mt-sm pr col-xs-5 exhibitShow'
			: 'mt-sm pr col-xs-5') + " svelte-1yg1q29"))) {
				attr_dev(div0, "class", div0_class_value);
			}

			const textfield1_changes = {};
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].hide_caption;
			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].img_hide;
			textfield1.$set(textfield1_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit'
			? 'mt-sm col-xs-5 exhibitShow'
			: 'mt-sm col-xs-5') + " svelte-1yg1q29"))) {
				attr_dev(div1, "class", div1_class_value);
			}

			if ((!current || dirty[0] & /*l*/ 128) && t2_value !== (t2_value = /*l*/ ctx[7].btn_txt + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty[0] & /*l*/ 128) && t3_value !== (t3_value = /*l*/ ctx[7].link_txt + "")) set_data_dev(t3, t3_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].layout);
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit'
			? 'pt-sm col-xs-2 exhibiLink exhibitbtnlnk'
			: 'pt-sm col-xs-2') + " svelte-1yg1q29"))) {
				attr_dev(div2, "class", div2_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_component(textfield0);
			destroy_component(textfield1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_4.name,
		type: "else",
		source: "(539:12) {:else}",
		ctx
	});

	return block;
}

// (529:12) {#if playerState.type != 'exhibit'}
function create_if_block_30(ctx) {
	let div;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				id: "title",
				placeholder: /*l*/ ctx[7].enter_title,
				fullWidth: "true",
				label: /*l*/ ctx[7].title,
				sval: "title"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(textfield.$$.fragment);
			add_location(div, file$f, 529, 16, 28164);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(textfield, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].enter_title;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].title;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(textfield);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_30.name,
		type: "if",
		source: "(529:12) {#if playerState.type != 'exhibit'}",
		ctx
	});

	return block;
}

// (585:16) {#if (playerState.type == 'weblink' || playerState.type == 'exhibit') }
function create_if_block_29(ctx) {
	let div;
	let select;
	let option0;
	let t0_value = /*l*/ ctx[7].embed + "";
	let t0;
	let option1;

	let t1_value = (/*playerState*/ ctx[0].type != 'exhibit'
	? /*l*/ ctx[7].new_tab
	: /*l*/ ctx[7].overlay) + "";

	let t1;
	let div_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			select = element("select");
			option0 = element("option");
			t0 = text(t0_value);
			option1 = element("option");
			t1 = text(t1_value);
			option0.__value = "inline";
			option0.value = option0.__value;
			add_location(option0, file$f, 593, 28, 31934);
			option1.__value = "new_tab";
			option1.value = option1.__value;
			add_location(option1, file$f, 594, 28, 32005);
			attr_dev(select, "id", "embed");
			attr_dev(select, "name", "embed");
			attr_dev(select, "class", "text-left btn border p-2 w-100 clearfix mt-sm pointer");
			if (/*playerState*/ ctx[0].embed === void 0) add_render_callback(() => /*select_change_handler_8*/ ctx[38].call(select));
			add_location(select, file$f, 586, 24, 31545);

			attr_dev(div, "class", div_class_value = "pt-sm col-xs-" + (/*playerState*/ ctx[0].type == 'weblink'
			? '3 textWidth'
			: /*playerState*/ ctx[0].type == 'exhibit'
				? '2 embedovrlyBtn'
				: '0') + " svelte-1yg1q29");

			add_location(div, file$f, 585, 20, 31383);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, select);
			append_dev(select, option0);
			append_dev(option0, t0);
			append_dev(select, option1);
			append_dev(option1, t1);
			select_option(select, /*playerState*/ ctx[0].embed);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_8*/ ctx[38]),
					listen_dev(select, "change", /*change_handler_10*/ ctx[39], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t0_value !== (t0_value = /*l*/ ctx[7].embed + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*playerState, l*/ 129 && t1_value !== (t1_value = (/*playerState*/ ctx[0].type != 'exhibit'
			? /*l*/ ctx[7].new_tab
			: /*l*/ ctx[7].overlay) + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].embed);
			}

			if (dirty[0] & /*playerState*/ 1 && div_class_value !== (div_class_value = "pt-sm col-xs-" + (/*playerState*/ ctx[0].type == 'weblink'
			? '3 textWidth'
			: /*playerState*/ ctx[0].type == 'exhibit'
				? '2 embedovrlyBtn'
				: '0') + " svelte-1yg1q29")) {
				attr_dev(div, "class", div_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_29.name,
		type: "if",
		source: "(585:16) {#if (playerState.type == 'weblink' || playerState.type == 'exhibit') }",
		ctx
	});

	return block;
}

// (600:12) {#if ((playerState.type == 'download' || (playerState.type == 'exhibit' && playerState.sub_type == 'image')) || (playerState.type == 'weblink' && playerState.embed != 'inline'))}
function create_if_block_28(ctx) {
	let div2;
	let div0;
	let textfield0;
	let div0_class_value;
	let t0;
	let div1;
	let button;
	let t1_value = /*l*/ ctx[7].insert_img + "";
	let t1;
	let div1_class_value;
	let div2_spacing_value;
	let div2_class_value;
	let t2;
	let div3;
	let textfield1;
	let current;
	let mounted;
	let dispose;

	textfield0 = new Textfield({
			props: {
				id: "img",
				fullWidth: "true",
				placeholder: /*playerState*/ ctx[0].type == 'download'
				? /*l*/ ctx[7].enter_icon_url
				: /*l*/ ctx[7].enter_img_url,
				label: /*l*/ ctx[7].image_txt
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				id: "alt",
				label: /*l*/ ctx[7].img_alt,
				placeholder: /*l*/ ctx[7].img_desc,
				fullWidth: "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t0 = space();
			div1 = element("div");
			button = element("button");
			t1 = text(t1_value);
			t2 = space();
			div3 = element("div");
			create_component(textfield1.$$.fragment);
			attr_dev(div0, "item", "");

			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'mt-sm pr col-xs-9 insertImageTxt'
			: 'mt-sm pr col-xs-9 insertImageTxt w-75') + " svelte-1yg1q29"));

			add_location(div0, file$f, 601, 20, 32602);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "btn btn-secondary clearfix mt-1 ml-xs w-100");
			add_location(button, file$f, 610, 24, 33300);

			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'pt-sm col-xs-3 mt-4 insertBtn'
			: 'pt-sm col-xs-3 mt-4 insertBtn') + " svelte-1yg1q29"));

			add_location(div1, file$f, 609, 20, 33126);
			attr_dev(div2, "container", "");
			attr_dev(div2, "spacing", div2_spacing_value = 12);

			attr_dev(div2, "class", div2_class_value = /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'd-flex'
			: /*playerState*/ ctx[0].type == 'download'
				? 'd-flex'
				: 'd-flex');

			add_location(div2, file$f, 600, 16, 32409);
			attr_dev(div3, "class", "mt-sm");
			add_location(div3, file$f, 613, 16, 33503);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			mount_component(textfield0, div0, null);
			append_dev(div2, t0);
			append_dev(div2, div1);
			append_dev(div1, button);
			append_dev(button, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, div3, anchor);
			mount_component(textfield1, div3, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[40], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};

			if (dirty[0] & /*playerState, l*/ 129) textfield0_changes.placeholder = /*playerState*/ ctx[0].type == 'download'
			? /*l*/ ctx[7].enter_icon_url
			: /*l*/ ctx[7].enter_img_url;

			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].image_txt;
			textfield0.$set(textfield0_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'mt-sm pr col-xs-9 insertImageTxt'
			: 'mt-sm pr col-xs-9 insertImageTxt w-75') + " svelte-1yg1q29"))) {
				attr_dev(div0, "class", div0_class_value);
			}

			if ((!current || dirty[0] & /*l*/ 128) && t1_value !== (t1_value = /*l*/ ctx[7].insert_img + "")) set_data_dev(t1, t1_value);

			if (!current || dirty[0] & /*playerState*/ 1 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'pt-sm col-xs-3 mt-4 insertBtn'
			: 'pt-sm col-xs-3 mt-4 insertBtn') + " svelte-1yg1q29"))) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div2_class_value !== (div2_class_value = /*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'd-flex'
			: /*playerState*/ ctx[0].type == 'download'
				? 'd-flex'
				: 'd-flex')) {
				attr_dev(div2, "class", div2_class_value);
			}

			const textfield1_changes = {};
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].img_alt;
			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].img_desc;
			textfield1.$set(textfield1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(textfield0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div3);
			destroy_component(textfield1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_28.name,
		type: "if",
		source: "(600:12) {#if ((playerState.type == 'download' || (playerState.type == 'exhibit' && playerState.sub_type == 'image')) || (playerState.type == 'weblink' && playerState.embed != 'inline'))}",
		ctx
	});

	return block;
}

// (623:12) {#if playerState.type == 'weblink'}
function create_if_block_26(ctx) {
	let div1;
	let div0;
	let textfield;
	let t;
	let current;

	textfield = new Textfield({
			props: {
				id: "height",
				fullWidth: "true",
				placeholder: /*playerState*/ ctx[0].embed == 'inline'
				? /*l*/ ctx[7].img_height
				: /*l*/ ctx[7].frame_height,
				label: /*playerState*/ ctx[0].embed == 'inline'
				? /*l*/ ctx[7].frame_ht
				: /*l*/ ctx[7].imgage_ht
			},
			$$inline: true
		});

	let if_block = /*playerState*/ ctx[0].embed != 'inline' && create_if_block_27(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(textfield.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr_dev(div0, "class", "mt-sm");
			add_location(div0, file$f, 624, 20, 33884);
			add_location(div1, file$f, 623, 16, 33857);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(textfield, div0, null);
			append_dev(div1, t);
			if (if_block) if_block.m(div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.placeholder = /*playerState*/ ctx[0].embed == 'inline'
			? /*l*/ ctx[7].img_height
			: /*l*/ ctx[7].frame_height;

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.label = /*playerState*/ ctx[0].embed == 'inline'
			? /*l*/ ctx[7].frame_ht
			: /*l*/ ctx[7].imgage_ht;

			textfield.$set(textfield_changes);

			if (/*playerState*/ ctx[0].embed != 'inline') {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_27(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(textfield);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_26.name,
		type: "if",
		source: "(623:12) {#if playerState.type == 'weblink'}",
		ctx
	});

	return block;
}

// (633:20) {#if playerState.embed != 'inline'}
function create_if_block_27(ctx) {
	let div;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				id: "width",
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].enter_img_width,
				label: /*l*/ ctx[7].img_width
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(textfield.$$.fragment);
			attr_dev(div, "class", "mt-sm");
			add_location(div, file$f, 633, 24, 34367);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(textfield, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].enter_img_width;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].img_width;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(textfield);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_27.name,
		type: "if",
		source: "(633:20) {#if playerState.embed != 'inline'}",
		ctx
	});

	return block;
}

// (645:12) {#if (playerState.type == 'exhibit' && playerState.sub_type == 'text')}
function create_if_block_25(ctx) {
	let div;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				id: "text",
				placeholder: /*l*/ ctx[7].enter_txt,
				multiline: "true",
				rows: "4",
				variant: "outlined",
				fullWidth: "true",
				label: /*l*/ ctx[7].text
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(textfield.$$.fragment);
			attr_dev(div, "class", "mt-sm");
			add_location(div, file$f, 645, 16, 34875);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(textfield, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].enter_txt;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].text;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(textfield);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_25.name,
		type: "if",
		source: "(645:12) {#if (playerState.type == 'exhibit' && playerState.sub_type == 'text')}",
		ctx
	});

	return block;
}

// (658:12) {#if (playerState.type == 'exhibit')}
function create_if_block_23(ctx) {
	let div1;
	let div0;
	let input0;
	let input0_value_value;
	let t0;
	let label;
	let t1_value = /*l*/ ctx[7].inline + "";
	let t1;
	let t2;
	let input1;
	let input1_value_value;
	let t3;
	let div1_class_value;
	let mounted;
	let dispose;
	let if_block = /*playerState*/ ctx[0].sub_type == 'image' && /*playerState*/ ctx[0].embed == 'inline' && create_if_block_24(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			input0 = element("input");
			t0 = space();
			label = element("label");
			t1 = text(t1_value);
			t2 = space();
			input1 = element("input");
			t3 = space();
			if (if_block) if_block.c();
			attr_dev(input0, "type", "checkbox");
			attr_dev(input0, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input0, "id", "exhibit_inline_checkbox");
			input0.__value = input0_value_value = /*playerState*/ ctx[0].inline;
			input0.value = input0.__value;
			attr_dev(input0, "color", "default");
			add_location(input0, file$f, 660, 24, 35573);
			attr_dev(label, "for", "exhibit_inline_checkbox");
			attr_dev(label, "class", "position-relative top_minus4");
			add_location(label, file$f, 668, 24, 35959);
			attr_dev(input1, "type", "hidden");
			attr_dev(input1, "id", "inline");
			attr_dev(input1, "name", "inline");
			input1.value = input1_value_value = /*playerState*/ ctx[0].inline ? 1 : '';
			add_location(input1, file$f, 669, 24, 36077);
			attr_dev(div0, "class", "mt-4");
			add_location(div0, file$f, 659, 20, 35529);

			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'd-flex alignRight position-relative'
			: 'row alignRight position-relative') + " svelte-1yg1q29"));

			add_location(div1, file$f, 658, 16, 35350);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, input0);
			input0.checked = /*playerState*/ ctx[0].inline;
			append_dev(div0, t0);
			append_dev(div0, label);
			append_dev(label, t1);
			append_dev(div0, t2);
			append_dev(div0, input1);
			append_dev(div1, t3);
			if (if_block) if_block.m(div1, null);

			if (!mounted) {
				dispose = listen_dev(input0, "change", /*input0_change_handler_3*/ ctx[41]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*playerState*/ 1 && input0_value_value !== (input0_value_value = /*playerState*/ ctx[0].inline)) {
				prop_dev(input0, "__value", input0_value_value);
				input0.value = input0.__value;
			}

			if (dirty[0] & /*playerState*/ 1) {
				input0.checked = /*playerState*/ ctx[0].inline;
			}

			if (dirty[0] & /*l*/ 128 && t1_value !== (t1_value = /*l*/ ctx[7].inline + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*playerState*/ 1 && input1_value_value !== (input1_value_value = /*playerState*/ ctx[0].inline ? 1 : '')) {
				prop_dev(input1, "value", input1_value_value);
			}

			if (/*playerState*/ ctx[0].sub_type == 'image' && /*playerState*/ ctx[0].embed == 'inline') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_24(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*playerState*/ 1 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*playerState*/ ctx[0].type == 'exhibit' && /*playerState*/ ctx[0].sub_type == 'image'
			? 'd-flex alignRight position-relative'
			: 'row alignRight position-relative') + " svelte-1yg1q29"))) {
				attr_dev(div1, "class", div1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_23.name,
		type: "if",
		source: "(658:12) {#if (playerState.type == 'exhibit')}",
		ctx
	});

	return block;
}

// (672:20) {#if (playerState.sub_type == 'image' && playerState.embed == 'inline')}
function create_if_block_24(ctx) {
	let div;
	let input0;
	let input0_value_value;
	let t0;
	let label;
	let t1_value = /*l*/ ctx[7].border_txt + "";
	let t1;
	let t2;
	let input1;
	let input1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			input0 = element("input");
			t0 = space();
			label = element("label");
			t1 = text(t1_value);
			t2 = space();
			input1 = element("input");
			attr_dev(input0, "type", "checkbox");
			input0.__value = input0_value_value = /*playerState*/ ctx[0].bordered;
			input0.value = input0.__value;
			attr_dev(input0, "color", "default");
			attr_dev(input0, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input0, "id", "bordered_checkbox");
			add_location(input0, file$f, 673, 28, 36358);
			attr_dev(label, "for", "bordered_checkbox");
			attr_dev(label, "class", "position-relative top_minus4");
			add_location(label, file$f, 681, 28, 36772);
			attr_dev(input1, "type", "hidden");
			attr_dev(input1, "id", "bordered");
			attr_dev(input1, "name", "bordered");
			input1.value = input1_value_value = /*playerState*/ ctx[0].bordered ? 1 : '';
			add_location(input1, file$f, 684, 28, 36956);
			attr_dev(div, "class", "mt-4");
			add_location(div, file$f, 672, 24, 36310);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input0);
			input0.checked = /*playerState*/ ctx[0].bordered;
			append_dev(div, t0);
			append_dev(div, label);
			append_dev(label, t1);
			append_dev(div, t2);
			append_dev(div, input1);

			if (!mounted) {
				dispose = listen_dev(input0, "change", /*input0_change_handler_4*/ ctx[42]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*playerState*/ 1 && input0_value_value !== (input0_value_value = /*playerState*/ ctx[0].bordered)) {
				prop_dev(input0, "__value", input0_value_value);
				input0.value = input0.__value;
			}

			if (dirty[0] & /*playerState*/ 1) {
				input0.checked = /*playerState*/ ctx[0].bordered;
			}

			if (dirty[0] & /*l*/ 128 && t1_value !== (t1_value = /*l*/ ctx[7].border_txt + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*playerState*/ 1 && input1_value_value !== (input1_value_value = /*playerState*/ ctx[0].bordered ? 1 : '')) {
				prop_dev(input1, "value", input1_value_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_24.name,
		type: "if",
		source: "(672:20) {#if (playerState.sub_type == 'image' && playerState.embed == 'inline')}",
		ctx
	});

	return block;
}

// (273:12) {:else}
function create_else_block_2(ctx) {
	let p;
	let t_value = /*l*/ ctx[7].video_des + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 273, 16, 12698);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t_value !== (t_value = /*l*/ ctx[7].video_des + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(273:12) {:else}",
		ctx
	});

	return block;
}

// (271:12) {#if playerState.type == 'audio'}
function create_if_block_20(ctx) {
	let p;
	let t_value = /*l*/ ctx[7].audio_des + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "mt-2");
			add_location(p, file$f, 271, 16, 12626);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t_value !== (t_value = /*l*/ ctx[7].audio_des + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_20.name,
		type: "if",
		source: "(271:12) {#if playerState.type == 'audio'}",
		ctx
	});

	return block;
}

// (309:12) {#if playerState.type == 'video'}
function create_if_block_13(ctx) {
	let div10;
	let div3;
	let div0;
	let textfield0;
	let t0;
	let div2;
	let div1;
	let button0;
	let t1_value = /*l*/ ctx[7].add_transcript_msg + "";
	let t1;
	let button0_title_value;
	let t2;
	let button1;
	let t3_value = /*l*/ ctx[7].edit_msg + "";
	let t3;
	let button1_title_value;
	let div3_class_value;
	let t4;
	let div4;
	let textfield1;
	let div4_rel_value;
	let div4_data_original_title_value;
	let t5;
	let div6;
	let div5;
	let input0;
	let input0_value_value;
	let input0_disabled_value;
	let t6;
	let label0;
	let t7_value = /*l*/ ctx[7].security_info + "";
	let t7;
	let t8;
	let label0_class_value;
	let div5_class_value;
	let t9;
	let t10;
	let div7;
	let input1;
	let input1_value_value;
	let input1_disabled_value;
	let t11;
	let label1;
	let t12_value = /*l*/ ctx[7].multiple_video + "";
	let t12;
	let label1_class_value;
	let t13;
	let t14;
	let div8;
	let input2;
	let input2_value_value;
	let input2_disabled_value;
	let t15;
	let label2;
	let t16_value = /*l*/ ctx[7].add_interval + "";
	let t16;
	let label2_class_value;
	let div8_class_value;
	let t17;
	let div9;
	let t18;
	let current;
	let mounted;
	let dispose;

	textfield0 = new Textfield({
			props: {
				id: "group_guids",
				fullWidth: "true",
				label: /*l*/ ctx[7].transcript_id,
				placeholder: /*l*/ ctx[7].enter_id,
				disabled: /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals || /*playerState*/ ctx[0].sub_type == 'youtube' || /*playerState*/ ctx[0].sub_type == 'lynda'
				? true
				: false
			},
			$$inline: true
		});

	textfield0.$on("change", function () {
		if (is_function(/*playerState*/ ctx[0].type == 'video'
		? /*change_handler_6*/ ctx[24]
		: null)) (/*playerState*/ ctx[0].type == 'video'
		? /*change_handler_6*/ ctx[24]
		: null).apply(this, arguments);
	});

	textfield1 = new Textfield({
			props: {
				id: "preview",
				label: /*l*/ ctx[7].preview_img,
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].preview_url,
				disabled: /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals
			},
			$$inline: true
		});

	function select_block_type_3(ctx, dirty) {
		if (/*playerState*/ ctx[0].security) return create_if_block_19;
		return create_else_block_1$1;
	}

	let current_block_type = select_block_type_3(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*playerState*/ ctx[0].security && create_if_block_18(ctx);
	let if_block2 = /*playerState*/ ctx[0].multiple && create_if_block_17(ctx);
	let if_block3 = /*playerState*/ ctx[0].intervals && create_if_block_15(ctx);
	let if_block4 = !/*playerState*/ ctx[0].security && !/*playerState*/ ctx[0].intervals && create_if_block_14(ctx);

	const block = {
		c: function create() {
			div10 = element("div");
			div3 = element("div");
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			button0 = element("button");
			t1 = text(t1_value);
			t2 = space();
			button1 = element("button");
			t3 = text(t3_value);
			t4 = space();
			div4 = element("div");
			create_component(textfield1.$$.fragment);
			t5 = space();
			div6 = element("div");
			div5 = element("div");
			input0 = element("input");
			t6 = space();
			label0 = element("label");
			t7 = text(t7_value);
			t8 = space();
			if_block0.c();
			t9 = space();
			if (if_block1) if_block1.c();
			t10 = space();
			div7 = element("div");
			input1 = element("input");
			t11 = space();
			label1 = element("label");
			t12 = text(t12_value);
			t13 = space();
			if (if_block2) if_block2.c();
			t14 = space();
			div8 = element("div");
			input2 = element("input");
			t15 = space();
			label2 = element("label");
			t16 = text(t16_value);
			t17 = space();
			div9 = element("div");
			if (if_block3) if_block3.c();
			t18 = space();
			if (if_block4) if_block4.c();
			attr_dev(div0, "item", "");
			attr_dev(div0, "class", "col-xs-7 position-relative textTranscript svelte-1yg1q29");
			add_location(div0, file$f, 313, 24, 14651);
			attr_dev(button0, "class", "btn btn-outline-dark add_transcript mr-2");
			attr_dev(button0, "title", button0_title_value = /*l*/ ctx[7].add_transcript_msg);
			add_location(button0, file$f, 325, 32, 15477);
			button1.disabled = "disabled";
			attr_dev(button1, "class", "btn btn-outline-dark edit_transcript");
			attr_dev(button1, "title", button1_title_value = /*l*/ ctx[7].edit_transcript_msg);
			add_location(button1, file$f, 332, 32, 15890);
			attr_dev(div1, "class", "mt-2 pull-right");
			add_location(div1, file$f, 324, 28, 15414);
			attr_dev(div2, "class", "col-xs-5");
			add_location(div2, file$f, 323, 24, 15362);

			attr_dev(div3, "class", div3_class_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals || /*playerState*/ ctx[0].sub_type == 'youtube' || /*playerState*/ ctx[0].sub_type == 'lynda'
			? 'transcript_container d-none'
			: 'd-flex transcript_container mt-sm');

			add_location(div3, file$f, 310, 20, 14372);
			attr_dev(div4, "class", "mt-sm");

			attr_dev(div4, "rel", div4_rel_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals
			? "tooltip"
			: "");

			attr_dev(div4, "data-original-title", div4_data_original_title_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals
			? /*l*/ ctx[7].image_prev_msg
			: '');

			add_location(div4, file$f, 336, 20, 16132);
			attr_dev(input0, "type", "checkbox");
			input0.__value = input0_value_value = /*playerState*/ ctx[0].security;
			input0.value = input0.__value;
			attr_dev(input0, "color", "default");
			attr_dev(input0, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input0, "id", "security_checkbox");
			input0.disabled = input0_disabled_value = /*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals;
			add_location(input0, file$f, 347, 28, 16849);
			attr_dev(label0, "for", "security_checkbox");

			attr_dev(label0, "class", label0_class_value = "position-relative top_minus4 " + (/*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals
			? 'text-muted'
			: ''));

			add_location(label0, file$f, 356, 28, 17353);

			attr_dev(div5, "class", div5_class_value = /*playerState*/ ctx[0].security
			? 'mt-2'
			: 'mt-2 d-flex ');

			add_location(div5, file$f, 346, 24, 16757);
			attr_dev(div6, "class", "mt-4");
			add_location(div6, file$f, 345, 20, 16713);
			attr_dev(input1, "type", "checkbox");
			input1.__value = input1_value_value = /*playerState*/ ctx[0].multiple;
			input1.value = input1.__value;
			attr_dev(input1, "color", "default");
			attr_dev(input1, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input1, "id", "multiple_checkbox");
			input1.disabled = input1_disabled_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals;
			add_location(input1, file$f, 377, 24, 18965);
			attr_dev(label1, "for", "multiple_checkbox");

			attr_dev(label1, "class", label1_class_value = "position-relative top_minus4 " + (/*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals
			? 'text-muted'
			: ''));

			add_location(label1, file$f, 386, 24, 19433);
			attr_dev(div7, "class", "mt-2");
			add_location(div7, file$f, 376, 20, 18921);
			attr_dev(input2, "type", "checkbox");
			input2.__value = input2_value_value = /*playerState*/ ctx[0].intervals;
			input2.value = input2.__value;
			attr_dev(input2, "color", "default");
			attr_dev(input2, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input2, "id", "intervals_checkbox");
			input2.disabled = input2_disabled_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].multiple;
			add_location(input2, file$f, 394, 24, 19938);
			attr_dev(label2, "for", "intervals_checkbox");

			attr_dev(label2, "class", label2_class_value = "position-relative top_minus4 " + (/*playerState*/ ctx[0].security || /*playerState*/ ctx[0].multiple
			? 'text-muted'
			: ''));

			add_location(label2, file$f, 403, 24, 20408);
			attr_dev(div8, "class", div8_class_value = /*playerState*/ ctx[0].multiple ? "mt-md" : "mt-2");
			add_location(div8, file$f, 393, 20, 19859);
			add_location(div9, file$f, 407, 20, 20676);
			add_location(div10, file$f, 309, 16, 14345);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div10, anchor);
			append_dev(div10, div3);
			append_dev(div3, div0);
			mount_component(textfield0, div0, null);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, button0);
			append_dev(button0, t1);
			append_dev(div1, t2);
			append_dev(div1, button1);
			append_dev(button1, t3);
			append_dev(div10, t4);
			append_dev(div10, div4);
			mount_component(textfield1, div4, null);
			append_dev(div10, t5);
			append_dev(div10, div6);
			append_dev(div6, div5);
			append_dev(div5, input0);
			input0.checked = /*playerState*/ ctx[0].security;
			append_dev(div5, t6);
			append_dev(div5, label0);
			append_dev(label0, t7);
			append_dev(label0, t8);
			if_block0.m(label0, null);
			append_dev(div6, t9);
			if (if_block1) if_block1.m(div6, null);
			append_dev(div10, t10);
			append_dev(div10, div7);
			append_dev(div7, input1);
			input1.checked = /*playerState*/ ctx[0].multiple;
			append_dev(div7, t11);
			append_dev(div7, label1);
			append_dev(label1, t12);
			append_dev(div7, t13);
			if (if_block2) if_block2.m(div7, null);
			append_dev(div10, t14);
			append_dev(div10, div8);
			append_dev(div8, input2);
			input2.checked = /*playerState*/ ctx[0].intervals;
			append_dev(div8, t15);
			append_dev(div8, label2);
			append_dev(label2, t16);
			append_dev(div10, t17);
			append_dev(div10, div9);
			if (if_block3) if_block3.m(div9, null);
			append_dev(div10, t18);
			if (if_block4) if_block4.m(div10, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler_1*/ ctx[25], false, false, false),
					listen_dev(input0, "change", /*input0_change_handler_1*/ ctx[26]),
					listen_dev(input1, "change", /*input1_change_handler*/ ctx[27]),
					listen_dev(input2, "change", /*input2_change_handler*/ ctx[28])
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const textfield0_changes = {};
			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].transcript_id;
			if (dirty[0] & /*l*/ 128) textfield0_changes.placeholder = /*l*/ ctx[7].enter_id;

			if (dirty[0] & /*playerState*/ 1) textfield0_changes.disabled = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals || /*playerState*/ ctx[0].sub_type == 'youtube' || /*playerState*/ ctx[0].sub_type == 'lynda'
			? true
			: false;

			textfield0.$set(textfield0_changes);
			if ((!current || dirty[0] & /*l*/ 128) && t1_value !== (t1_value = /*l*/ ctx[7].add_transcript_msg + "")) set_data_dev(t1, t1_value);

			if (!current || dirty[0] & /*l*/ 128 && button0_title_value !== (button0_title_value = /*l*/ ctx[7].add_transcript_msg)) {
				attr_dev(button0, "title", button0_title_value);
			}

			if ((!current || dirty[0] & /*l*/ 128) && t3_value !== (t3_value = /*l*/ ctx[7].edit_msg + "")) set_data_dev(t3, t3_value);

			if (!current || dirty[0] & /*l*/ 128 && button1_title_value !== (button1_title_value = /*l*/ ctx[7].edit_transcript_msg)) {
				attr_dev(button1, "title", button1_title_value);
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div3_class_value !== (div3_class_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals || /*playerState*/ ctx[0].sub_type == 'youtube' || /*playerState*/ ctx[0].sub_type == 'lynda'
			? 'transcript_container d-none'
			: 'd-flex transcript_container mt-sm')) {
				attr_dev(div3, "class", div3_class_value);
			}

			const textfield1_changes = {};
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].preview_img;
			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].preview_url;
			if (dirty[0] & /*playerState*/ 1) textfield1_changes.disabled = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals;
			textfield1.$set(textfield1_changes);

			if (!current || dirty[0] & /*playerState*/ 1 && div4_rel_value !== (div4_rel_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals
			? "tooltip"
			: "")) {
				attr_dev(div4, "rel", div4_rel_value);
			}

			if (!current || dirty[0] & /*playerState, l*/ 129 && div4_data_original_title_value !== (div4_data_original_title_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals
			? /*l*/ ctx[7].image_prev_msg
			: '')) {
				attr_dev(div4, "data-original-title", div4_data_original_title_value);
			}

			if (!current || dirty[0] & /*playerState*/ 1 && input0_value_value !== (input0_value_value = /*playerState*/ ctx[0].security)) {
				prop_dev(input0, "__value", input0_value_value);
				input0.value = input0.__value;
			}

			if (!current || dirty[0] & /*playerState*/ 1 && input0_disabled_value !== (input0_disabled_value = /*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals)) {
				prop_dev(input0, "disabled", input0_disabled_value);
			}

			if (dirty[0] & /*playerState*/ 1) {
				input0.checked = /*playerState*/ ctx[0].security;
			}

			if ((!current || dirty[0] & /*l*/ 128) && t7_value !== (t7_value = /*l*/ ctx[7].security_info + "")) set_data_dev(t7, t7_value);

			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(label0, null);
				}
			}

			if (!current || dirty[0] & /*playerState*/ 1 && label0_class_value !== (label0_class_value = "position-relative top_minus4 " + (/*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals
			? 'text-muted'
			: ''))) {
				attr_dev(label0, "class", label0_class_value);
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div5_class_value !== (div5_class_value = /*playerState*/ ctx[0].security
			? 'mt-2'
			: 'mt-2 d-flex ')) {
				attr_dev(div5, "class", div5_class_value);
			}

			if (/*playerState*/ ctx[0].security) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_18(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div6, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*playerState*/ 1 && input1_value_value !== (input1_value_value = /*playerState*/ ctx[0].multiple)) {
				prop_dev(input1, "__value", input1_value_value);
				input1.value = input1.__value;
			}

			if (!current || dirty[0] & /*playerState*/ 1 && input1_disabled_value !== (input1_disabled_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals)) {
				prop_dev(input1, "disabled", input1_disabled_value);
			}

			if (dirty[0] & /*playerState*/ 1) {
				input1.checked = /*playerState*/ ctx[0].multiple;
			}

			if ((!current || dirty[0] & /*l*/ 128) && t12_value !== (t12_value = /*l*/ ctx[7].multiple_video + "")) set_data_dev(t12, t12_value);

			if (!current || dirty[0] & /*playerState*/ 1 && label1_class_value !== (label1_class_value = "position-relative top_minus4 " + (/*playerState*/ ctx[0].security || /*playerState*/ ctx[0].intervals
			? 'text-muted'
			: ''))) {
				attr_dev(label1, "class", label1_class_value);
			}

			if (/*playerState*/ ctx[0].multiple) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_17(ctx);
					if_block2.c();
					if_block2.m(div7, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!current || dirty[0] & /*playerState*/ 1 && input2_value_value !== (input2_value_value = /*playerState*/ ctx[0].intervals)) {
				prop_dev(input2, "__value", input2_value_value);
				input2.value = input2.__value;
			}

			if (!current || dirty[0] & /*playerState*/ 1 && input2_disabled_value !== (input2_disabled_value = /*playerState*/ ctx[0].security || /*playerState*/ ctx[0].multiple)) {
				prop_dev(input2, "disabled", input2_disabled_value);
			}

			if (dirty[0] & /*playerState*/ 1) {
				input2.checked = /*playerState*/ ctx[0].intervals;
			}

			if ((!current || dirty[0] & /*l*/ 128) && t16_value !== (t16_value = /*l*/ ctx[7].add_interval + "")) set_data_dev(t16, t16_value);

			if (!current || dirty[0] & /*playerState*/ 1 && label2_class_value !== (label2_class_value = "position-relative top_minus4 " + (/*playerState*/ ctx[0].security || /*playerState*/ ctx[0].multiple
			? 'text-muted'
			: ''))) {
				attr_dev(label2, "class", label2_class_value);
			}

			if (!current || dirty[0] & /*playerState*/ 1 && div8_class_value !== (div8_class_value = /*playerState*/ ctx[0].multiple ? "mt-md" : "mt-2")) {
				attr_dev(div8, "class", div8_class_value);
			}

			if (/*playerState*/ ctx[0].intervals) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_15(ctx);
					if_block3.c();
					if_block3.m(div9, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (!/*playerState*/ ctx[0].security && !/*playerState*/ ctx[0].intervals) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_14(ctx);
					if_block4.c();
					if_block4.m(div10, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div10);
			destroy_component(textfield0);
			destroy_component(textfield1);
			if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13.name,
		type: "if",
		source: "(309:12) {#if playerState.type == 'video'}",
		ctx
	});

	return block;
}

// (361:32) {:else}
function create_else_block_1$1(ctx) {
	let span;
	let span_class_value;
	let span_title_value;

	const block = {
		c: function create() {
			span = element("span");

			attr_dev(span, "class", span_class_value = /*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals
			? "icomoon-info s2 align-middle pl MuiFormControlLabel-label-88 MuiFormControlLabel-disabled-87 position-relative"
			: "icomoon-info s2 align-middle pl position-relative");

			attr_dev(span, "rel", "tooltip");
			attr_dev(span, "title", span_title_value = /*l*/ ctx[7].security_title);
			add_location(span, file$f, 361, 36, 17980);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*playerState*/ 1 && span_class_value !== (span_class_value = /*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals
			? "icomoon-info s2 align-middle pl MuiFormControlLabel-label-88 MuiFormControlLabel-disabled-87 position-relative"
			: "icomoon-info s2 align-middle pl position-relative")) {
				attr_dev(span, "class", span_class_value);
			}

			if (dirty[0] & /*l*/ 128 && span_title_value !== (span_title_value = /*l*/ ctx[7].security_title)) {
				attr_dev(span, "title", span_title_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(361:32) {:else}",
		ctx
	});

	return block;
}

// (359:32) {#if playerState.security}
function create_if_block_19(ctx) {
	let span;
	let span_class_value;
	let span_title_value;

	const block = {
		c: function create() {
			span = element("span");

			attr_dev(span, "class", span_class_value = /*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals
			? "icomoon-info s2 align-middle pl MuiFormControlLabel-label-88 MuiFormControlLabel-disabled-87 "
			: "icomoon-info s2 align-middle pl position-relative");

			attr_dev(span, "rel", "tooltip");
			attr_dev(span, "title", span_title_value = /*l*/ ctx[7].security_title);
			add_location(span, file$f, 359, 36, 17640);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*playerState*/ 1 && span_class_value !== (span_class_value = /*playerState*/ ctx[0].multiple || /*playerState*/ ctx[0].intervals
			? "icomoon-info s2 align-middle pl MuiFormControlLabel-label-88 MuiFormControlLabel-disabled-87 "
			: "icomoon-info s2 align-middle pl position-relative")) {
				attr_dev(span, "class", span_class_value);
			}

			if (dirty[0] & /*l*/ 128 && span_title_value !== (span_title_value = /*l*/ ctx[7].security_title)) {
				attr_dev(span, "title", span_title_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_19.name,
		type: "if",
		source: "(359:32) {#if playerState.security}",
		ctx
	});

	return block;
}

// (366:24) {#if playerState.security}
function create_if_block_18(ctx) {
	let div;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				id: "security",
				label: /*l*/ ctx[7].security_txt,
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].security_place
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(textfield.$$.fragment);
			attr_dev(div, "class", "position-relative alignLeft svelte-1yg1q29");
			add_location(div, file$f, 366, 28, 18450);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(textfield, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].security_txt;
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].security_place;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(textfield);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_18.name,
		type: "if",
		source: "(366:24) {#if playerState.security}",
		ctx
	});

	return block;
}

// (390:24) {#if playerState.multiple}
function create_if_block_17(ctx) {
	let p;
	let t_value = /*l*/ ctx[7].multiple_info + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "mt-md mb-0");
			add_location(p, file$f, 390, 28, 19735);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t_value !== (t_value = /*l*/ ctx[7].multiple_info + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_17.name,
		type: "if",
		source: "(390:24) {#if playerState.multiple}",
		ctx
	});

	return block;
}

// (409:24) {#if playerState.intervals}
function create_if_block_15(ctx) {
	let div1;
	let div0;
	let t0;
	let table;
	let thead;
	let tr0;
	let th0;
	let t2;
	let th1;
	let t3_value = /*l*/ ctx[7].interval_txt + "";
	let t3;
	let t4;
	let br;
	let small;
	let t5_value = /*l*/ ctx[7].in_sec + "";
	let t5;
	let t6;
	let th2;
	let t7_value = /*l*/ ctx[7].caption_txt + "";
	let t7;
	let t8;
	let th3;
	let span0;
	let span0_data_original_title_value;
	let t9;
	let tbody;
	let tr1;
	let td0;
	let t10_value = /*l*/ ctx[7].one_num + "";
	let t10;
	let t11;
	let td1;
	let input0;
	let input0_placeholder_value;
	let t12;
	let td2;
	let input1;
	let input1_placeholder_value;
	let t13;
	let td3;
	let a;
	let span1;
	let span1_data_original_title_value;
	let t14;
	let t15;
	let button;
	let t16_value = /*l*/ ctx[7].add_interval + "";
	let t16;
	let t17;
	let input2;
	let t18;
	let input3;
	let mounted;
	let dispose;
	let if_block = /*playerState*/ ctx[0].msg != '' && create_if_block_16(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			table = element("table");
			thead = element("thead");
			tr0 = element("tr");
			th0 = element("th");
			th0.textContent = "#";
			t2 = space();
			th1 = element("th");
			t3 = text(t3_value);
			t4 = space();
			br = element("br");
			small = element("small");
			t5 = text(t5_value);
			t6 = space();
			th2 = element("th");
			t7 = text(t7_value);
			t8 = space();
			th3 = element("th");
			span0 = element("span");
			t9 = space();
			tbody = element("tbody");
			tr1 = element("tr");
			td0 = element("td");
			t10 = text(t10_value);
			t11 = space();
			td1 = element("td");
			input0 = element("input");
			t12 = space();
			td2 = element("td");
			input1 = element("input");
			t13 = space();
			td3 = element("td");
			a = element("a");
			span1 = element("span");
			t14 = space();
			if (if_block) if_block.c();
			t15 = space();
			button = element("button");
			t16 = text(t16_value);
			t17 = space();
			input2 = element("input");
			t18 = space();
			input3 = element("input");
			attr_dev(div0, "class", "get_video_duration h");
			add_location(div0, file$f, 410, 32, 20817);
			set_style(th0, "width", "11px");
			add_location(th0, file$f, 414, 44, 21121);
			add_location(br, file$f, 415, 81, 21234);
			add_location(small, file$f, 415, 86, 21239);
			attr_dev(th1, "class", "width80");
			add_location(th1, file$f, 415, 44, 21197);
			add_location(th2, file$f, 416, 44, 21315);
			attr_dev(span0, "class", "icomoon icomoon-new-24px-gear-1 s3");
			attr_dev(span0, "rel", "tooltip");
			attr_dev(span0, "data-original-title", span0_data_original_title_value = /*l*/ ctx[7].action_txt);
			add_location(span0, file$f, 417, 67, 21408);
			set_style(th3, "width", "1px");
			add_location(th3, file$f, 417, 44, 21385);
			add_location(tr0, file$f, 413, 40, 21071);
			add_location(thead, file$f, 412, 36, 21022);
			attr_dev(td0, "class", "align-middle sr");
			add_location(td0, file$f, 422, 44, 21760);
			attr_dev(input0, "type", "number");
			attr_dev(input0, "id", "num_input");
			attr_dev(input0, "name", "num_input");
			attr_dev(input0, "min", "0");
			attr_dev(input0, "step", "1");
			attr_dev(input0, "class", "intervaltext form-control form-control-sm width80 pr-sm");
			attr_dev(input0, "placeholder", input0_placeholder_value = /*l*/ ctx[7].interval_txt);
			add_location(input0, file$f, 423, 48, 21854);
			add_location(td1, file$f, 423, 44, 21850);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", "caption_input");
			attr_dev(input1, "name", "caption_input");
			attr_dev(input1, "maxlength", "200");
			attr_dev(input1, "class", "captiontext w-100 form-control form-control-sm");
			attr_dev(input1, "placeholder", input1_placeholder_value = /*l*/ ctx[7].caption_txt);
			add_location(input1, file$f, 424, 48, 22074);
			add_location(td2, file$f, 424, 44, 22070);
			attr_dev(span1, "rel", "tooltip");
			attr_dev(span1, "data-original-title", span1_data_original_title_value = /*l*/ ctx[7].delete);
			attr_dev(span1, "class", "icomoon icomoon-new-24px-delete-1 s3");
			add_location(span1, file$f, 425, 110, 22350);
			attr_dev(a, "href", "#");
			attr_dev(a, "class", "deleteinterval");
			attr_dev(a, "data-id", "1");
			add_location(a, file$f, 425, 63, 22303);
			attr_dev(td3, "class", "middle");
			add_location(td3, file$f, 425, 44, 22284);
			attr_dev(tr1, "data-id", "1");
			add_location(tr1, file$f, 421, 40, 21698);
			add_location(tbody, file$f, 420, 36, 21649);
			attr_dev(table, "class", "table table-hover table-striped stepplayertable table-bordered");
			attr_dev(table, "tablesorter", "");
			add_location(table, file$f, 411, 32, 20891);
			attr_dev(button, "class", "btn mt-3 btn-secondary float-left mt-lg");
			add_location(button, file$f, 432, 32, 22832);
			attr_dev(input2, "type", "hidden");
			attr_dev(input2, "id", "intervals");
			attr_dev(input2, "name", "intervals");
			input2.value = "";
			add_location(input2, file$f, 433, 32, 22987);
			attr_dev(input3, "type", "hidden");
			attr_dev(input3, "id", "stepcaptions");
			attr_dev(input3, "name", "stepcaptions");
			input3.value = "";
			add_location(input3, file$f, 434, 32, 23085);
			attr_dev(div1, "class", "mt-md");
			add_location(div1, file$f, 409, 28, 20764);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div1, t0);
			append_dev(div1, table);
			append_dev(table, thead);
			append_dev(thead, tr0);
			append_dev(tr0, th0);
			append_dev(tr0, t2);
			append_dev(tr0, th1);
			append_dev(th1, t3);
			append_dev(th1, t4);
			append_dev(th1, br);
			append_dev(th1, small);
			append_dev(small, t5);
			append_dev(tr0, t6);
			append_dev(tr0, th2);
			append_dev(th2, t7);
			append_dev(tr0, t8);
			append_dev(tr0, th3);
			append_dev(th3, span0);
			append_dev(table, t9);
			append_dev(table, tbody);
			append_dev(tbody, tr1);
			append_dev(tr1, td0);
			append_dev(td0, t10);
			append_dev(tr1, t11);
			append_dev(tr1, td1);
			append_dev(td1, input0);
			append_dev(tr1, t12);
			append_dev(tr1, td2);
			append_dev(td2, input1);
			append_dev(tr1, t13);
			append_dev(tr1, td3);
			append_dev(td3, a);
			append_dev(a, span1);
			append_dev(div1, t14);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t15);
			append_dev(div1, button);
			append_dev(button, t16);
			append_dev(div1, t17);
			append_dev(div1, input2);
			append_dev(div1, t18);
			append_dev(div1, input3);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[29], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t3_value !== (t3_value = /*l*/ ctx[7].interval_txt + "")) set_data_dev(t3, t3_value);
			if (dirty[0] & /*l*/ 128 && t5_value !== (t5_value = /*l*/ ctx[7].in_sec + "")) set_data_dev(t5, t5_value);
			if (dirty[0] & /*l*/ 128 && t7_value !== (t7_value = /*l*/ ctx[7].caption_txt + "")) set_data_dev(t7, t7_value);

			if (dirty[0] & /*l*/ 128 && span0_data_original_title_value !== (span0_data_original_title_value = /*l*/ ctx[7].action_txt)) {
				attr_dev(span0, "data-original-title", span0_data_original_title_value);
			}

			if (dirty[0] & /*l*/ 128 && t10_value !== (t10_value = /*l*/ ctx[7].one_num + "")) set_data_dev(t10, t10_value);

			if (dirty[0] & /*l*/ 128 && input0_placeholder_value !== (input0_placeholder_value = /*l*/ ctx[7].interval_txt)) {
				attr_dev(input0, "placeholder", input0_placeholder_value);
			}

			if (dirty[0] & /*l*/ 128 && input1_placeholder_value !== (input1_placeholder_value = /*l*/ ctx[7].caption_txt)) {
				attr_dev(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty[0] & /*l*/ 128 && span1_data_original_title_value !== (span1_data_original_title_value = /*l*/ ctx[7].delete)) {
				attr_dev(span1, "data-original-title", span1_data_original_title_value);
			}

			if (/*playerState*/ ctx[0].msg != '') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_16(ctx);
					if_block.c();
					if_block.m(div1, t15);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*l*/ 128 && t16_value !== (t16_value = /*l*/ ctx[7].add_interval + "")) set_data_dev(t16, t16_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15.name,
		type: "if",
		source: "(409:24) {#if playerState.intervals}",
		ctx
	});

	return block;
}

// (430:32) {#if playerState.msg != ''}
function create_if_block_16(ctx) {
	let p;
	let t_value = /*playerState*/ ctx[0].msg + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			attr_dev(p, "class", "help-block text-danger mb-0 mt");
			add_location(p, file$f, 430, 36, 22696);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*playerState*/ 1 && t_value !== (t_value = /*playerState*/ ctx[0].msg + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16.name,
		type: "if",
		source: "(430:32) {#if playerState.msg != ''}",
		ctx
	});

	return block;
}

// (439:20) {#if (!playerState.security && !playerState.intervals)}
function create_if_block_14(ctx) {
	let div;
	let input0;
	let input0_value_value;
	let t;
	let input1;
	let input1_value_value;

	const block = {
		c: function create() {
			div = element("div");
			input0 = element("input");
			t = space();
			input1 = element("input");
			attr_dev(input0, "type", "hidden");
			attr_dev(input0, "id", "is_multiple");
			attr_dev(input0, "name", "is_multiple");
			input0.value = input0_value_value = /*playerState*/ ctx[0].multiple ? 1 : 0;
			add_location(input0, file$f, 440, 28, 23388);
			attr_dev(input1, "type", "hidden");
			attr_dev(input1, "id", "sub_type");
			attr_dev(input1, "name", "sub_type");
			input1.value = input1_value_value = /*playerState*/ ctx[0].sub_type;
			add_location(input1, file$f, 441, 28, 23514);
			add_location(div, file$f, 439, 24, 23353);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input0);
			append_dev(div, t);
			append_dev(div, input1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*playerState*/ 1 && input0_value_value !== (input0_value_value = /*playerState*/ ctx[0].multiple ? 1 : 0)) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (dirty[0] & /*playerState*/ 1 && input1_value_value !== (input1_value_value = /*playerState*/ ctx[0].sub_type)) {
				prop_dev(input1, "value", input1_value_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14.name,
		type: "if",
		source: "(439:20) {#if (!playerState.security && !playerState.intervals)}",
		ctx
	});

	return block;
}

// (89:20) {#if playerState.type == "terminal"}
function create_if_block_11(ctx) {
	let select;
	let option0;
	let t0_value = /*l*/ ctx[7].java_txt + "";
	let t0;
	let option1;
	let t1_value = /*l*/ ctx[7].linux_txt + "";
	let t1;
	let option2;
	let t2_value = /*l*/ ctx[7].dos_txt + "";
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			select = element("select");
			option0 = element("option");
			t0 = text(t0_value);
			option1 = element("option");
			t1 = text(t1_value);
			option2 = element("option");
			t2 = text(t2_value);
			option0.__value = "java";
			option0.value = option0.__value;
			add_location(option0, file$f, 96, 28, 4004);
			option1.__value = "linus";
			option1.value = option1.__value;
			add_location(option1, file$f, 97, 28, 4076);
			option2.__value = "dos";
			option2.value = option2.__value;
			add_location(option2, file$f, 98, 28, 4150);
			attr_dev(select, "id", "sub_type");
			attr_dev(select, "name", "sub_type");
			attr_dev(select, "class", "text-left btn border p-2 width80 clearfix pointer");
			if (/*playerState*/ ctx[0].sub_type === void 0) add_render_callback(() => /*select_change_handler_1*/ ctx[13].call(select));
			add_location(select, file$f, 89, 24, 3607);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);
			append_dev(select, option0);
			append_dev(option0, t0);
			append_dev(select, option1);
			append_dev(option1, t1);
			append_dev(select, option2);
			append_dev(option2, t2);
			select_option(select, /*playerState*/ ctx[0].sub_type);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_1*/ ctx[13]),
					listen_dev(select, "change", /*change_handler_1*/ ctx[14], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t0_value !== (t0_value = /*l*/ ctx[7].java_txt + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*l*/ 128 && t1_value !== (t1_value = /*l*/ ctx[7].linux_txt + "")) set_data_dev(t1, t1_value);
			if (dirty[0] & /*l*/ 128 && t2_value !== (t2_value = /*l*/ ctx[7].dos_txt + "")) set_data_dev(t2, t2_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].sub_type);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(89:20) {#if playerState.type == \\\"terminal\\\"}",
		ctx
	});

	return block;
}

// (102:20) {#if playerState.type == "insight"}
function create_if_block_10$1(ctx) {
	let select;
	let option0;
	let t0_value = /*l*/ ctx[7].lab3d + "";
	let t0;
	let option1;
	let t1_value = /*l*/ ctx[7].scorm_txt + "";
	let t1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			select = element("select");
			option0 = element("option");
			t0 = text(t0_value);
			option1 = element("option");
			t1 = text(t1_value);
			option0.__value = "insight";
			option0.value = option0.__value;
			add_location(option0, file$f, 109, 28, 4724);
			option1.__value = "scorm";
			option1.value = option1.__value;
			add_location(option1, file$f, 110, 28, 4796);
			attr_dev(select, "id", "sub_type");
			attr_dev(select, "name", "sub_type");
			attr_dev(select, "class", "text-left btn border p-2 clearfix pointer");
			if (/*playerState*/ ctx[0].sub_type === void 0) add_render_callback(() => /*select_change_handler_2*/ ctx[15].call(select));
			add_location(select, file$f, 102, 24, 4335);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);
			append_dev(select, option0);
			append_dev(option0, t0);
			append_dev(select, option1);
			append_dev(option1, t1);
			select_option(select, /*playerState*/ ctx[0].sub_type);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_2*/ ctx[15]),
					listen_dev(select, "change", /*change_handler_2*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 128 && t0_value !== (t0_value = /*l*/ ctx[7].lab3d + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*l*/ 128 && t1_value !== (t1_value = /*l*/ ctx[7].scorm_txt + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].sub_type);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10$1.name,
		type: "if",
		source: "(102:20) {#if playerState.type == \\\"insight\\\"}",
		ctx
	});

	return block;
}

// (126:12) {#if playerState.type == 'playground' && playerState.oldPlayground}
function create_if_block_9$1(ctx) {
	let div1;
	let div0;
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				id: "xml_data",
				placeholder: /*l*/ ctx[7].enter_xml,
				multiline: "true",
				rows: "4",
				variant: "outlined",
				fullWidth: "true",
				label: /*l*/ ctx[7].xml
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(textfield.$$.fragment);
			attr_dev(div0, "class", "col-xs-12 mt-sm");
			add_location(div0, file$f, 127, 20, 5694);
			attr_dev(div1, "class", "row svelte-1yg1q29");
			add_location(div1, file$f, 126, 16, 5655);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(textfield, div0, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].enter_xml;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].xml;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(textfield);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9$1.name,
		type: "if",
		source: "(126:12) {#if playerState.type == 'playground' && playerState.oldPlayground}",
		ctx
	});

	return block;
}

// (150:20) {:else}
function create_else_block$3(ctx) {
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				id: /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
				? "config"
				: "asset",
				fullWidth: "true",
				label: /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
				? /*l*/ ctx[7].simulator_name
				: /*l*/ ctx[7].item_id,
				placeholder: /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
				? /*l*/ ctx[7].simulator_place
				: /*l*/ ctx[7].enter_item,
				error: /*playerState*/ ctx[0].msg != ''
				? /*playerState*/ ctx[0].msg
				: false,
				messagePersist: true,
				helperText: /*playerState*/ ctx[0].msg,
				is_multiple: "0"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(textfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};

			if (dirty[0] & /*playerState*/ 1) textfield_changes.id = /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
			? "config"
			: "asset";

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.label = /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
			? /*l*/ ctx[7].simulator_name
			: /*l*/ ctx[7].item_id;

			if (dirty[0] & /*playerState, l*/ 129) textfield_changes.placeholder = /*playerState*/ ctx[0].type == 'simulation' && /*playerState*/ ctx[0].oldSimulation
			? /*l*/ ctx[7].simulator_place
			: /*l*/ ctx[7].enter_item;

			if (dirty[0] & /*playerState*/ 1) textfield_changes.error = /*playerState*/ ctx[0].msg != ''
			? /*playerState*/ ctx[0].msg
			: false;

			if (dirty[0] & /*playerState*/ 1) textfield_changes.helperText = /*playerState*/ ctx[0].msg;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(150:20) {:else}",
		ctx
	});

	return block;
}

// (143:20) {#if (playerState.type == 'insight' && playerState.sub_type == 'scorm')}
function create_if_block_8$1(ctx) {
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				id: "asset",
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].scorm_url,
				label: /*l*/ ctx[7].url_txt
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(textfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].scorm_url;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].url_txt;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$1.name,
		type: "if",
		source: "(143:20) {#if (playerState.type == 'insight' && playerState.sub_type == 'scorm')}",
		ctx
	});

	return block;
}

// (164:16) {#if playerState.type == 'simulation'}
function create_if_block_5$1(ctx) {
	let div0;
	let select;
	let option0;
	let t0_value = /*l*/ ctx[7].embed + "";
	let t0;
	let option1;
	let t1_value = /*l*/ ctx[7].new_tab + "";
	let t1;
	let option2;
	let t2_value = /*l*/ ctx[7].overlay + "";
	let t2;
	let t3;
	let div2;
	let div1;
	let t4;
	let current;
	let mounted;
	let dispose;
	let if_block0 = (/*playerState*/ ctx[0].embed == 'overlay' || /*playerState*/ ctx[0].embed == 'new_tab') && create_if_block_7$1(ctx);
	let if_block1 = /*playerState*/ ctx[0].embed == 'inline' && /*playerState*/ ctx[0].oldSimulation && create_if_block_6$1(ctx);

	const block = {
		c: function create() {
			div0 = element("div");
			select = element("select");
			option0 = element("option");
			t0 = text(t0_value);
			option1 = element("option");
			t1 = text(t1_value);
			option2 = element("option");
			t2 = text(t2_value);
			t3 = space();
			div2 = element("div");
			div1 = element("div");
			if (if_block0) if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			option0.__value = "inline";
			option0.value = option0.__value;
			add_location(option0, file$f, 172, 28, 8065);
			option1.__value = "new_tab";
			option1.value = option1.__value;
			add_location(option1, file$f, 173, 28, 8136);
			option2.__value = "overlay";
			option2.value = option2.__value;
			add_location(option2, file$f, 174, 28, 8210);
			attr_dev(select, "id", "embed");
			attr_dev(select, "name", "embed");
			attr_dev(select, "class", "text-left btn border p-2 w-100 clearfix mt-3 pointer");
			if (/*playerState*/ ctx[0].embed === void 0) add_render_callback(() => /*select_change_handler_3*/ ctx[17].call(select));
			add_location(select, file$f, 165, 24, 7677);
			attr_dev(div0, "class", "col-xs-3 pt-sm pr w-25 position-relative simButton svelte-1yg1q29");
			add_location(div0, file$f, 164, 20, 7587);
			attr_dev(div1, "class", "col-xs-12 mt-sm pr-0");
			add_location(div1, file$f, 178, 20, 8404);
			attr_dev(div2, "class", "row position-relative alignRight svelte-1yg1q29");
			add_location(div2, file$f, 177, 16, 8335);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, select);
			append_dev(select, option0);
			append_dev(option0, t0);
			append_dev(select, option1);
			append_dev(option1, t1);
			append_dev(select, option2);
			append_dev(option2, t2);
			select_option(select, /*playerState*/ ctx[0].embed);
			insert_dev(target, t3, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t4);
			if (if_block1) if_block1.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler_3*/ ctx[17]),
					listen_dev(select, "change", /*change_handler_3*/ ctx[18], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 128) && t0_value !== (t0_value = /*l*/ ctx[7].embed + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty[0] & /*l*/ 128) && t1_value !== (t1_value = /*l*/ ctx[7].new_tab + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty[0] & /*l*/ 128) && t2_value !== (t2_value = /*l*/ ctx[7].overlay + "")) set_data_dev(t2, t2_value);

			if (dirty[0] & /*playerState*/ 1) {
				select_option(select, /*playerState*/ ctx[0].embed);
			}

			if (/*playerState*/ ctx[0].embed == 'overlay' || /*playerState*/ ctx[0].embed == 'new_tab') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_7$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t4);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*playerState*/ ctx[0].embed == 'inline' && /*playerState*/ ctx[0].oldSimulation) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*playerState*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_6$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(164:16) {#if playerState.type == 'simulation'}",
		ctx
	});

	return block;
}

// (180:24) {#if (playerState.embed == 'overlay' || playerState.embed == 'new_tab')}
function create_if_block_7$1(ctx) {
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				placeholder: /*l*/ ctx[7].enter_btn_name,
				fullWidth: "true",
				id: "button_name",
				label: /*l*/ ctx[7].btn_name
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(textfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].enter_btn_name;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].btn_name;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$1.name,
		type: "if",
		source: "(180:24) {#if (playerState.embed == 'overlay' || playerState.embed == 'new_tab')}",
		ctx
	});

	return block;
}

// (188:24) {#if (playerState.embed == 'inline' && playerState.oldSimulation)}
function create_if_block_6$1(ctx) {
	let textfield;
	let current;

	textfield = new Textfield({
			props: {
				placeholder: /*l*/ ctx[7].correct_val,
				fullWidth: "true",
				id: "correct",
				label: /*l*/ ctx[7].correct
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(textfield.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textfield_changes = {};
			if (dirty[0] & /*l*/ 128) textfield_changes.placeholder = /*l*/ ctx[7].correct_val;
			if (dirty[0] & /*l*/ 128) textfield_changes.label = /*l*/ ctx[7].correct;
			textfield.$set(textfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$1.name,
		type: "if",
		source: "(188:24) {#if (playerState.embed == 'inline' && playerState.oldSimulation)}",
		ctx
	});

	return block;
}

// (201:12) {#if (playerState.type == 'insight' && playerState.sub_type == 'scorm')}
function create_if_block_4$1(ctx) {
	let div1;
	let div0;
	let textfield0;
	let t0;
	let div3;
	let div2;
	let textfield1;
	let t1;
	let div6;
	let div4;
	let textfield2;
	let t2;
	let div5;
	let button;
	let t3_value = /*l*/ ctx[7].insert_img + "";
	let t3;
	let t4;
	let div8;
	let div7;
	let textfield3;
	let current;
	let mounted;
	let dispose;

	textfield0 = new Textfield({
			props: {
				id: "asset_m",
				label: /*l*/ ctx[7].mobile_url,
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].mobile_url_place
			},
			$$inline: true
		});

	textfield1 = new Textfield({
			props: {
				id: "group_guids",
				label: /*l*/ ctx[7].transcript_id,
				fullWidth: "true",
				placeholder: /*l*/ ctx[7].scorm_place
			},
			$$inline: true
		});

	textfield2 = new Textfield({
			props: {
				id: "img",
				fullWidth: "true",
				placeholder: /*playerState*/ ctx[0].type == 'download'
				? /*l*/ ctx[7].enter_icon_url
				: /*l*/ ctx[7].enter_img_url,
				label: /*l*/ ctx[7].image_txt
			},
			$$inline: true
		});

	textfield3 = new Textfield({
			props: {
				id: "alt",
				label: /*l*/ ctx[7].img_alt,
				placeholder: /*l*/ ctx[7].img_desc,
				fullWidth: "true"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t0 = space();
			div3 = element("div");
			div2 = element("div");
			create_component(textfield1.$$.fragment);
			t1 = space();
			div6 = element("div");
			div4 = element("div");
			create_component(textfield2.$$.fragment);
			t2 = space();
			div5 = element("div");
			button = element("button");
			t3 = text(t3_value);
			t4 = space();
			div8 = element("div");
			div7 = element("div");
			create_component(textfield3.$$.fragment);
			attr_dev(div0, "class", "col-xs-6 mt-sm");
			add_location(div0, file$f, 202, 20, 9534);
			attr_dev(div1, "class", "row position-relative alignRight svelte-1yg1q29");
			add_location(div1, file$f, 201, 16, 9466);
			attr_dev(div2, "class", "col-xs-12 mt-sm");
			add_location(div2, file$f, 212, 20, 9964);
			attr_dev(div3, "class", "row position-relative alignRight svelte-1yg1q29");
			add_location(div3, file$f, 211, 16, 9896);
			attr_dev(div4, "class", "container col-xs-9 mt-sm pr");
			attr_dev(div4, "item", "");
			add_location(div4, file$f, 222, 20, 10397);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "btn btn-secondary clearfix mt-1 ml-xs w-100");
			add_location(button, file$f, 231, 24, 10857);
			attr_dev(div5, "class", "col-xs-3 pt-sm");
			add_location(div5, file$f, 230, 20, 10803);
			attr_dev(div6, "class", "row position-relative alignRight svelte-1yg1q29");
			add_location(div6, file$f, 221, 16, 10329);
			attr_dev(div7, "class", "col-xs-12 mt-sm");
			add_location(div7, file$f, 239, 20, 11246);
			attr_dev(div8, "class", "row position-relative alignRight svelte-1yg1q29");
			add_location(div8, file$f, 238, 16, 11178);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(textfield0, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			mount_component(textfield1, div2, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, div6, anchor);
			append_dev(div6, div4);
			mount_component(textfield2, div4, null);
			append_dev(div6, t2);
			append_dev(div6, div5);
			append_dev(div5, button);
			append_dev(button, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, div8, anchor);
			append_dev(div8, div7);
			mount_component(textfield3, div7, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[19], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textfield0_changes = {};
			if (dirty[0] & /*l*/ 128) textfield0_changes.label = /*l*/ ctx[7].mobile_url;
			if (dirty[0] & /*l*/ 128) textfield0_changes.placeholder = /*l*/ ctx[7].mobile_url_place;
			textfield0.$set(textfield0_changes);
			const textfield1_changes = {};
			if (dirty[0] & /*l*/ 128) textfield1_changes.label = /*l*/ ctx[7].transcript_id;
			if (dirty[0] & /*l*/ 128) textfield1_changes.placeholder = /*l*/ ctx[7].scorm_place;
			textfield1.$set(textfield1_changes);
			const textfield2_changes = {};

			if (dirty[0] & /*playerState, l*/ 129) textfield2_changes.placeholder = /*playerState*/ ctx[0].type == 'download'
			? /*l*/ ctx[7].enter_icon_url
			: /*l*/ ctx[7].enter_img_url;

			if (dirty[0] & /*l*/ 128) textfield2_changes.label = /*l*/ ctx[7].image_txt;
			textfield2.$set(textfield2_changes);
			if ((!current || dirty[0] & /*l*/ 128) && t3_value !== (t3_value = /*l*/ ctx[7].insert_img + "")) set_data_dev(t3, t3_value);
			const textfield3_changes = {};
			if (dirty[0] & /*l*/ 128) textfield3_changes.label = /*l*/ ctx[7].img_alt;
			if (dirty[0] & /*l*/ 128) textfield3_changes.placeholder = /*l*/ ctx[7].img_desc;
			textfield3.$set(textfield3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(textfield2.$$.fragment, local);
			transition_in(textfield3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(textfield2.$$.fragment, local);
			transition_out(textfield3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(textfield0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div3);
			destroy_component(textfield1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div6);
			destroy_component(textfield2);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div8);
			destroy_component(textfield3);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(201:12) {#if (playerState.type == 'insight' && playerState.sub_type == 'scorm')}",
		ctx
	});

	return block;
}

// (250:12) {#if playerState.type == 'lablink'}
function create_if_block_3$1(ctx) {
	let div;
	let input;
	let t0;
	let label;
	let t1_value = /*l*/ ctx[7].learn_mode + "";
	let t1;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t0 = space();
			label = element("label");
			t1 = text(t1_value);
			attr_dev(input, "type", "checkbox");
			input.__value = /*isPlayerCheck*/ ctx[1];
			input.value = input.__value;
			attr_dev(input, "color", "default");
			attr_dev(input, "class", "custom_checkbox_new svelte-1yg1q29");
			attr_dev(input, "id", "isplayer_checkbox");
			add_location(input, file$f, 251, 20, 11702);
			attr_dev(label, "for", "isplayer_checkbox");
			attr_dev(label, "class", "position-relative top_minus4");
			add_location(label, file$f, 259, 20, 12038);
			attr_dev(div, "class", "mt-4");
			add_location(div, file$f, 250, 16, 11662);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			input.checked = /*isPlayerCheck*/ ctx[1];
			append_dev(div, t0);
			append_dev(div, label);
			append_dev(label, t1);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[20]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*isPlayerCheck*/ 2) {
				prop_dev(input, "__value", /*isPlayerCheck*/ ctx[1]);
				input.value = input.__value;
			}

			if (dirty[0] & /*isPlayerCheck*/ 2) {
				input.checked = /*isPlayerCheck*/ ctx[1];
			}

			if (dirty[0] & /*l*/ 128 && t1_value !== (t1_value = /*l*/ ctx[7].learn_mode + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(250:12) {#if playerState.type == 'lablink'}",
		ctx
	});

	return block;
}

// (265:12) {#if playerState.isplayer}
function create_if_block_2$3(ctx) {
	let input;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "hidden");
			attr_dev(input, "id", "isplayer");
			attr_dev(input, "name", "isplayer");
			input.value = "1";
			add_location(input, file$f, 265, 16, 12277);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(265:12) {#if playerState.isplayer}",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;

	const if_block_creators = [
		create_if_block$d,
		create_if_block_1$3,
		create_if_block_12,
		create_if_block_21,
		create_if_block_37,
		create_if_block_38,
		create_if_block_39,
		create_else_block_5
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*playerState*/ ctx[0].category == "knowledge_check") return 0;
		if (/*playerState*/ ctx[0].category == 'lab') return 1;
		if (/*playerState*/ ctx[0].category == 'media') return 2;
		if (/*playerState*/ ctx[0].category == 'link') return 3;
		if (/*playerState*/ ctx[0].category == 'objects') return 4;
		if (/*playerState*/ ctx[0].category == 'snt') return 5;
		if (/*playerState*/ ctx[0].category == 'seq') return 6;
		return 7;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			add_location(div, file$f, 31, 0, 940);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PlayerItem', slots, []);
	let { playerState } = $$props;
	let { isPlayerCheck } = $$props;
	let { setInputState } = $$props;
	let { setVideoAsset } = $$props;
	let { handleTranscriptDialog } = $$props;
	let { insertImage } = $$props;
	let { createSteptable } = $$props;
	let { correctLabelStyle } = $$props;
	let { l } = $$props;

	let labType = {
		'playground': l.coding,
		'simulation': l.simulation,
		'terminal': l.terminal,
		'lablink': l.lablink,
		'insight': l.insight
	};

	onMount(() => {
		let changeTimer = setTimeout(
			function () {
				if (tinyMCE.activeEditor.selection.getContent()) {
					AH.selectAll("#showPlayerList input[id='show_caption'], #showPlayerList input[id='title']", 'value', tinyMCE.activeEditor.selection.getContent());
					correctLabelStyle();
				}

				clearTimeout(changeTimer);
			},
			500
		);
	});

	const writable_props = [
		'playerState',
		'isPlayerCheck',
		'setInputState',
		'setVideoAsset',
		'handleTranscriptDialog',
		'insertImage',
		'createSteptable',
		'correctLabelStyle',
		'l'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayerItem> was created with unknown prop '${key}'`);
	});

	function input0_change_handler() {
		playerState.nofeedback = this.checked;
		$$invalidate(0, playerState);
	}

	function select_change_handler() {
		playerState.type = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler = e => {
		setInputState('type', e.target.value);
	};

	function select_change_handler_1() {
		playerState.sub_type = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_1 = e => {
		setInputState('sub_type', e.target.value);
	};

	function select_change_handler_2() {
		playerState.sub_type = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_2 = e => {
		setInputState('sub_type', e.target.value);
	};

	function select_change_handler_3() {
		playerState.embed = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_3 = e => {
		setInputState('embed', e.target.value);
	};

	const click_handler = () => {
		insertImage('img');
	};

	function input_change_handler() {
		isPlayerCheck = this.checked;
		$$invalidate(1, isPlayerCheck);
	}

	function select_change_handler_4() {
		playerState.type = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_4 = e => {
		setInputState('type', e.target.value);
	};

	const change_handler_5 = e => {
		setVideoAsset('asset', e.target.value);
	};

	const change_handler_6 = e => {
		setVideoAsset('guid', e.target.value);
	};

	const click_handler_1 = () => {
		handleTranscriptDialog();
	};

	function input0_change_handler_1() {
		playerState.security = this.checked;
		$$invalidate(0, playerState);
	}

	function input1_change_handler() {
		playerState.multiple = this.checked;
		$$invalidate(0, playerState);
	}

	function input2_change_handler() {
		playerState.intervals = this.checked;
		$$invalidate(0, playerState);
	}

	const click_handler_2 = () => {
		createSteptable('add');
	};

	function select_change_handler_5() {
		playerState.type = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_7 = e => {
		setInputState('type', e.target.value);
	};

	function select_change_handler_6() {
		playerState.sub_type = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_8 = e => {
		setInputState('sub_type', e.target.value);
	};

	function input0_change_handler_2() {
		playerState.inline = this.checked;
		$$invalidate(0, playerState);
	}

	function select_change_handler_7() {
		playerState.layout = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_9 = e => {
		setInputState('layout', e.target.value);
	};

	function textfield_value_binding(value) {
		if ($$self.$$.not_equal(playerState.exhibitType, value)) {
			playerState.exhibitType = value;
			$$invalidate(0, playerState);
		}
	}

	function select_change_handler_8() {
		playerState.embed = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_10 = e => {
		setInputState('embed', e.target.value);
	};

	const click_handler_3 = () => {
		insertImage('img');
	};

	function input0_change_handler_3() {
		playerState.inline = this.checked;
		$$invalidate(0, playerState);
	}

	function input0_change_handler_4() {
		playerState.bordered = this.checked;
		$$invalidate(0, playerState);
	}

	function select_change_handler_9() {
		playerState.snt = select_value(this);
		$$invalidate(0, playerState);
	}

	const change_handler_11 = e => {
		setInputState('snt', e.target.value);
	};

	const blur_handler = e => {
		setInputState('seq', e.target.value);
	};

	function input0_change_handler_5() {
		playerState.nofeedback = this.checked;
		$$invalidate(0, playerState);
	}

	$$self.$$set = $$props => {
		if ('playerState' in $$props) $$invalidate(0, playerState = $$props.playerState);
		if ('isPlayerCheck' in $$props) $$invalidate(1, isPlayerCheck = $$props.isPlayerCheck);
		if ('setInputState' in $$props) $$invalidate(2, setInputState = $$props.setInputState);
		if ('setVideoAsset' in $$props) $$invalidate(3, setVideoAsset = $$props.setVideoAsset);
		if ('handleTranscriptDialog' in $$props) $$invalidate(4, handleTranscriptDialog = $$props.handleTranscriptDialog);
		if ('insertImage' in $$props) $$invalidate(5, insertImage = $$props.insertImage);
		if ('createSteptable' in $$props) $$invalidate(6, createSteptable = $$props.createSteptable);
		if ('correctLabelStyle' in $$props) $$invalidate(9, correctLabelStyle = $$props.correctLabelStyle);
		if ('l' in $$props) $$invalidate(7, l = $$props.l);
	};

	$$self.$capture_state = () => ({
		onMount,
		Textfield,
		AH,
		playerState,
		isPlayerCheck,
		setInputState,
		setVideoAsset,
		handleTranscriptDialog,
		insertImage,
		createSteptable,
		correctLabelStyle,
		l,
		labType
	});

	$$self.$inject_state = $$props => {
		if ('playerState' in $$props) $$invalidate(0, playerState = $$props.playerState);
		if ('isPlayerCheck' in $$props) $$invalidate(1, isPlayerCheck = $$props.isPlayerCheck);
		if ('setInputState' in $$props) $$invalidate(2, setInputState = $$props.setInputState);
		if ('setVideoAsset' in $$props) $$invalidate(3, setVideoAsset = $$props.setVideoAsset);
		if ('handleTranscriptDialog' in $$props) $$invalidate(4, handleTranscriptDialog = $$props.handleTranscriptDialog);
		if ('insertImage' in $$props) $$invalidate(5, insertImage = $$props.insertImage);
		if ('createSteptable' in $$props) $$invalidate(6, createSteptable = $$props.createSteptable);
		if ('correctLabelStyle' in $$props) $$invalidate(9, correctLabelStyle = $$props.correctLabelStyle);
		if ('l' in $$props) $$invalidate(7, l = $$props.l);
		if ('labType' in $$props) $$invalidate(8, labType = $$props.labType);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		playerState,
		isPlayerCheck,
		setInputState,
		setVideoAsset,
		handleTranscriptDialog,
		insertImage,
		createSteptable,
		l,
		labType,
		correctLabelStyle,
		input0_change_handler,
		select_change_handler,
		change_handler,
		select_change_handler_1,
		change_handler_1,
		select_change_handler_2,
		change_handler_2,
		select_change_handler_3,
		change_handler_3,
		click_handler,
		input_change_handler,
		select_change_handler_4,
		change_handler_4,
		change_handler_5,
		change_handler_6,
		click_handler_1,
		input0_change_handler_1,
		input1_change_handler,
		input2_change_handler,
		click_handler_2,
		select_change_handler_5,
		change_handler_7,
		select_change_handler_6,
		change_handler_8,
		input0_change_handler_2,
		select_change_handler_7,
		change_handler_9,
		textfield_value_binding,
		select_change_handler_8,
		change_handler_10,
		click_handler_3,
		input0_change_handler_3,
		input0_change_handler_4,
		select_change_handler_9,
		change_handler_11,
		blur_handler,
		input0_change_handler_5
	];
}

class PlayerItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$f,
			create_fragment$f,
			safe_not_equal,
			{
				playerState: 0,
				isPlayerCheck: 1,
				setInputState: 2,
				setVideoAsset: 3,
				handleTranscriptDialog: 4,
				insertImage: 5,
				createSteptable: 6,
				correctLabelStyle: 9,
				l: 7
			},
			add_css$d,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PlayerItem",
			options,
			id: create_fragment$f.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*playerState*/ ctx[0] === undefined && !('playerState' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'playerState'");
		}

		if (/*isPlayerCheck*/ ctx[1] === undefined && !('isPlayerCheck' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'isPlayerCheck'");
		}

		if (/*setInputState*/ ctx[2] === undefined && !('setInputState' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'setInputState'");
		}

		if (/*setVideoAsset*/ ctx[3] === undefined && !('setVideoAsset' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'setVideoAsset'");
		}

		if (/*handleTranscriptDialog*/ ctx[4] === undefined && !('handleTranscriptDialog' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'handleTranscriptDialog'");
		}

		if (/*insertImage*/ ctx[5] === undefined && !('insertImage' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'insertImage'");
		}

		if (/*createSteptable*/ ctx[6] === undefined && !('createSteptable' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'createSteptable'");
		}

		if (/*correctLabelStyle*/ ctx[9] === undefined && !('correctLabelStyle' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'correctLabelStyle'");
		}

		if (/*l*/ ctx[7] === undefined && !('l' in props)) {
			console.warn("<PlayerItem> was created without expected prop 'l'");
		}
	}

	get playerState() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set playerState(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isPlayerCheck() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isPlayerCheck(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setInputState() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setInputState(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setVideoAsset() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setVideoAsset(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleTranscriptDialog() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handleTranscriptDialog(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get insertImage() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set insertImage(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get createSteptable() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set createSteptable(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get correctLabelStyle() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set correctLabelStyle(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get l() {
		throw new Error("<PlayerItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<PlayerItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Player.svelte generated by Svelte v3.40.2 */

const { Object: Object_1, console: console_1$3 } = globals;
const file$g = "src\\Player.svelte";

function add_css$e(target) {
	append_styles(target, "svelte-cjxtvl", ".submitBtton{background-color:#616970!important}.deleteinterval:hover{text-decoration:none}.deleteinterval{color:#b0281a}.BtnDark{color:#fff!important;background-color:#343a40!important;border-color:#343a40!important;position:relative;left:6px}.BtnOutline{color:#343a40!important;border:1px solid #343a40!important}.bttmBtn{display:inline-block;float:right;position:relative;right:24px;bottom:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxheWVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF3bENZLFlBQVksQUFBRSxDQUFDLEFBQ25CLGdCQUFnQixDQUFFLE9BQU8sVUFBVSxBQUN2QyxDQUFDLEFBRU8scUJBQXFCLEFBQUUsQ0FBQyxBQUM1QixlQUFlLENBQUUsSUFBSSxBQUN6QixDQUFDLEFBRU8sZUFBZSxBQUFFLENBQUMsQUFDdEIsS0FBSyxDQUFFLE9BQU8sQUFDbEIsQ0FBQyxBQUVPLFFBQVEsQUFBRSxDQUFDLEFBQ2YsS0FBSyxDQUFFLElBQUksVUFBVSxDQUNyQixnQkFBZ0IsQ0FBRSxPQUFPLFVBQVUsQ0FDbkMsWUFBWSxDQUFFLE9BQU8sVUFBVSxDQUMvQixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxBQUNiLENBQUMsQUFFTyxXQUFXLEFBQUUsQ0FBQyxBQUNsQixLQUFLLENBQUUsT0FBTyxVQUFVLENBQ3hCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sVUFBVSxBQUN2QyxDQUFDLEFBRU8sUUFBUSxBQUFFLENBQUMsQUFDZixPQUFPLENBQUUsWUFBWSxDQUNyQixLQUFLLENBQUUsS0FBSyxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQUFDaEIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQbGF5ZXIuc3ZlbHRlIl19 */");
}

// (976:16) {#if ((state.from_coverage == 1 || getQueryString("is_flashcard") == 1) && in_frame)}
function create_if_block$e(ctx) {
	let span;
	let button0;
	let t1;
	let button1;
	let t3;
	let div0;
	let input;
	let input_placeholder_value;
	let t4;
	let div1;
	let table;
	let thead;
	let tr;
	let th0;
	let t6;
	let th1;
	let t8;
	let tbody;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			button0 = element("button");
			button0.textContent = `${l$1.list_content}`;
			t1 = space();
			button1 = element("button");
			button1.textContent = `${l$1.create_new_txt}`;
			t3 = space();
			div0 = element("div");
			input = element("input");
			t4 = space();
			div1 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th0 = element("th");
			th0.textContent = `${l$1.item_id}`;
			t6 = space();
			th1 = element("th");
			th1.textContent = `${l$1.title}`;
			t8 = space();
			tbody = element("tbody");
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-secondary clearfix pull-left listContent");
			add_location(button0, file$g, 977, 24, 50316);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-secondary clearfix pull-left listContent ml-2");
			add_location(button1, file$g, 978, 24, 50469);
			attr_dev(input, "class", "form-control search search_width");
			attr_dev(input, "id", "search");
			attr_dev(input, "name", "search");
			attr_dev(input, "type", "text");
			attr_dev(input, "placeholder", input_placeholder_value = l$1.search_item_txt);
			add_location(input, file$g, 980, 28, 50734);
			attr_dev(div0, "class", "mb-xl col-md-5 col-sm-4 col-5 pull-right p-0 list_content h");
			add_location(div0, file$g, 979, 24, 50631);
			attr_dev(th0, "class", "span1_imp");
			add_location(th0, file$g, 986, 40, 51251);
			attr_dev(th1, "colspan", "2");
			add_location(th1, file$g, 987, 40, 51331);
			add_location(tr, file$g, 985, 36, 51205);
			attr_dev(thead, "class", "always_show");
			add_location(thead, file$g, 984, 32, 51140);
			attr_dev(tbody, "id", "table_list");
			add_location(tbody, file$g, 990, 32, 51480);
			attr_dev(table, "id", "list_content_tbl");
			attr_dev(table, "class", "table table_list table_search table-striped table-hover");
			add_location(table, file$g, 983, 28, 51013);
			attr_dev(div1, "class", "list_content");
			set_style(div1, "display", "none");
			add_location(div1, file$g, 982, 24, 50935);
			add_location(span, file$g, 976, 20, 50284);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, button0);
			append_dev(span, t1);
			append_dev(span, button1);
			append_dev(span, t3);
			append_dev(span, div0);
			append_dev(div0, input);
			append_dev(span, t4);
			append_dev(span, div1);
			append_dev(div1, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th0);
			append_dev(tr, t6);
			append_dev(tr, th1);
			append_dev(table, t8);
			append_dev(table, tbody);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*listContent*/ ctx[10], false, false, false),
					listen_dev(button1, "click", /*addNewContent*/ ctx[11], false, false, false),
					listen_dev(input, "keyup", /*searchTable*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$e.name,
		type: "if",
		source: "(976:16) {#if ((state.from_coverage == 1 || getQueryString(\\\"is_flashcard\\\") == 1) && in_frame)}",
		ctx
	});

	return block;
}

// (936:0) <Dialog width="600" class="remove_right_margin" bind:visible={state.open} style="background-color:#fff; border-radius: 5px;">
function create_default_slot_8$1(ctx) {
	let h40;
	let div1;
	let div0;
	let t1;
	let div8;
	let div3;
	let select;
	let option0;
	let option1;
	let option2;
	let option3;
	let option4;
	let option5;
	let option6;
	let t9;
	let div2;
	let playeritem;
	let updating_playerState;
	let t10;
	let div7;
	let div4;
	let button;
	let t11_value = l$1.edit_txt + "";
	let t11;
	let button_class_value;
	let t12;
	let show_if = (/*state*/ ctx[0].from_coverage == 1 || getQueryString("is_flashcard") == 1) && in_frame;
	let t13;
	let div5;
	let t14;
	let div6;
	let t16;
	let center;
	let loader;
	let t17;
	let h41;
	let div7_class_value;
	let current;
	let mounted;
	let dispose;

	function playeritem_playerState_binding(value) {
		/*playeritem_playerState_binding*/ ctx[21](value);
	}

	let playeritem_props = {
		isPlayerCheck: /*state*/ ctx[0].isPlayerCheck,
		setInputState: /*setInputState*/ ctx[5],
		setVideoAsset: /*setVideoAsset*/ ctx[7],
		handleTranscriptDialog: /*handleTranscriptDialog*/ ctx[15],
		insertImage: /*insertImage*/ ctx[6],
		createSteptable: /*createSteptable*/ ctx[2],
		correctLabelStyle: /*correctLabelStyle*/ ctx[1],
		l: l$1
	};

	if (/*state*/ ctx[0] !== void 0) {
		playeritem_props.playerState = /*state*/ ctx[0];
	}

	playeritem = new PlayerItem({ props: playeritem_props, $$inline: true });
	binding_callbacks.push(() => bind(playeritem, 'playerState', playeritem_playerState_binding));
	let if_block = show_if && create_if_block$e(ctx);

	loader = new Loader({
			props: { size: 60, thickness: 2 },
			$$inline: true
		});

	const block = {
		c: function create() {
			h40 = element("h4");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Player Info";
			t1 = space();
			div8 = element("div");
			div3 = element("div");
			select = element("select");
			option0 = element("option");
			option0.textContent = `${l$1.know_check_txt}`;
			option1 = element("option");
			option1.textContent = `${l$1.lab_txt}`;
			option2 = element("option");
			option2.textContent = `${l$1.link_txt}`;
			option3 = element("option");
			option3.textContent = `${l$1.media_txt}`;
			option4 = element("option");
			option4.textContent = `${l$1.obj3d_txt}`;
			option5 = element("option");
			option5.textContent = `${l$1.instruction_txt}`;
			option6 = element("option");
			option6.textContent = `${l$1.opt_ref}`;
			t9 = space();
			div2 = element("div");
			create_component(playeritem.$$.fragment);
			t10 = space();
			div7 = element("div");
			div4 = element("div");
			button = element("button");
			t11 = text(t11_value);
			t12 = space();
			if (if_block) if_block.c();
			t13 = space();
			div5 = element("div");
			t14 = space();
			div6 = element("div");
			div6.textContent = `${l$1.no_record}`;
			t16 = space();
			center = element("center");
			create_component(loader.$$.fragment);
			t17 = space();
			h41 = element("h4");
			h41.textContent = "Please, be patient. We are working things up for you.";
			add_location(div0, file$g, 938, 12, 48275);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file$g, 937, 8, 48217);
			attr_dev(h40, "class", "mt-1 font21");
			add_location(h40, file$g, 936, 4, 48183);
			option0.__value = "knowledge_check";
			option0.value = option0.__value;
			add_location(option0, file$g, 950, 16, 48805);
			option1.__value = "lab";
			option1.value = option1.__value;
			add_location(option1, file$g, 951, 16, 48882);
			option2.__value = "link";
			option2.value = option2.__value;
			add_location(option2, file$g, 952, 16, 48940);
			option3.__value = "media";
			option3.value = option3.__value;
			add_location(option3, file$g, 953, 16, 49000);
			option4.__value = "objects";
			option4.value = option4.__value;
			add_location(option4, file$g, 954, 16, 49062);
			option5.__value = "snt";
			option5.value = option5.__value;
			add_location(option5, file$g, 955, 16, 49126);
			option6.__value = "seq";
			option6.value = option6.__value;
			add_location(option6, file$g, 956, 16, 49192);
			attr_dev(select, "id", "#playerCat");
			set_style(select, "margin-left", "0px");
			attr_dev(select, "class", "text-left v-bottom btn dialogSelectBorder p-2");
			if (/*state*/ ctx[0].category === void 0) add_render_callback(() => /*select_change_handler*/ ctx[20].call(select));
			add_location(select, file$g, 943, 12, 48528);
			attr_dev(div2, "id", "showPlayerList");
			add_location(div2, file$g, 958, 12, 49269);
			set_style(div3, "padding-right", "0px");
			set_style(div3, "padding-left", "0px");
			set_style(div3, "width", "100%");
			attr_dev(div3, "class", "col-12 pull-left npl npr mt-md");
			add_location(div3, file$g, 942, 8, 48411);
			attr_dev(button, "type", "button");

			attr_dev(button, "class", button_class_value = /*state*/ ctx[0].editBtnVisibility
			? "btn btn-secondary mr-2 clearfix pull-left mb-2"
			: "h");

			add_location(button, file$g, 974, 16, 49991);
			add_location(div4, file$g, 973, 12, 49968);
			attr_dev(div5, "class", "table_list_guid");
			add_location(div5, file$g, 996, 12, 51667);
			attr_dev(div6, "class", "alert alert-danger mt-5");
			attr_dev(div6, "id", "not_found");
			set_style(div6, "display", "none");
			add_location(div6, file$g, 997, 12, 51716);
			add_location(h41, file$g, 1000, 16, 51959);
			attr_dev(center, "id", "list_process");
			attr_dev(center, "class", "mt-5 pt-1");
			set_style(center, "display", "none");
			add_location(center, file$g, 998, 12, 51823);

			attr_dev(div7, "class", div7_class_value = /*state*/ ctx[0].islistContent
			? "col-md-12 mt-lg pt-sm pl-0 pr-0 float-left"
			: "h");

			attr_dev(div7, "id", "guid_list");
			add_location(div7, file$g, 972, 8, 49851);
			set_style(div8, "max-height", "400px");
			set_style(div8, "overflow-y", "auto");
			set_style(div8, "padding-right", "18px");
			add_location(div8, file$g, 941, 4, 48330);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h40, anchor);
			append_dev(h40, div1);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div8, anchor);
			append_dev(div8, div3);
			append_dev(div3, select);
			append_dev(select, option0);
			append_dev(select, option1);
			append_dev(select, option2);
			append_dev(select, option3);
			append_dev(select, option4);
			append_dev(select, option5);
			append_dev(select, option6);
			select_option(select, /*state*/ ctx[0].category);
			append_dev(div3, t9);
			append_dev(div3, div2);
			mount_component(playeritem, div2, null);
			append_dev(div8, t10);
			append_dev(div8, div7);
			append_dev(div7, div4);
			append_dev(div4, button);
			append_dev(button, t11);
			append_dev(div4, t12);
			if (if_block) if_block.m(div4, null);
			append_dev(div7, t13);
			append_dev(div7, div5);
			append_dev(div7, t14);
			append_dev(div7, div6);
			append_dev(div7, t16);
			append_dev(div7, center);
			mount_component(loader, center, null);
			append_dev(center, t17);
			append_dev(center, h41);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler*/ ctx[20]),
					listen_dev(select, "change", /*handlePlayer*/ ctx[4], false, false, false),
					listen_dev(button, "click", /*click_handler*/ ctx[22], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1) {
				select_option(select, /*state*/ ctx[0].category);
			}

			const playeritem_changes = {};
			if (dirty[0] & /*state*/ 1) playeritem_changes.isPlayerCheck = /*state*/ ctx[0].isPlayerCheck;

			if (!updating_playerState && dirty[0] & /*state*/ 1) {
				updating_playerState = true;
				playeritem_changes.playerState = /*state*/ ctx[0];
				add_flush_callback(() => updating_playerState = false);
			}

			playeritem.$set(playeritem_changes);

			if (!current || dirty[0] & /*state*/ 1 && button_class_value !== (button_class_value = /*state*/ ctx[0].editBtnVisibility
			? "btn btn-secondary mr-2 clearfix pull-left mb-2"
			: "h")) {
				attr_dev(button, "class", button_class_value);
			}

			if (dirty[0] & /*state*/ 1) show_if = (/*state*/ ctx[0].from_coverage == 1 || getQueryString("is_flashcard") == 1) && in_frame;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$e(ctx);
					if_block.c();
					if_block.m(div4, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty[0] & /*state*/ 1 && div7_class_value !== (div7_class_value = /*state*/ ctx[0].islistContent
			? "col-md-12 mt-lg pt-sm pl-0 pr-0 float-left"
			: "h")) {
				attr_dev(div7, "class", div7_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(playeritem.$$.fragment, local);
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(playeritem.$$.fragment, local);
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h40);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div8);
			destroy_component(playeritem);
			if (if_block) if_block.d();
			destroy_component(loader);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$1.name,
		type: "slot",
		source: "(936:0) <Dialog width=\\\"600\\\" class=\\\"remove_right_margin\\\" bind:visible={state.open} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (1006:8) <Button              unelevated={true}              outlined={true}              color="#ccc"              on:click={handleClose}              class="#ccc"          >
function create_default_slot_7$1(ctx) {
	let t_value = l$1.cancel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(1006:8) <Button              unelevated={true}              outlined={true}              color=\\\"#ccc\\\"              on:click={handleClose}              class=\\\"#ccc\\\"          >",
		ctx
	});

	return block;
}

// (1015:8) <Button              id="xmlDone"              class="submitBtton"              unelevated={true}              on:click={validateItemId}              color="primary"          >
function create_default_slot_6$1(ctx) {
	let t_value = l$1.submit + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(1015:8) <Button              id=\\\"xmlDone\\\"              class=\\\"submitBtton\\\"              unelevated={true}              on:click={validateItemId}              color=\\\"primary\\\"          >",
		ctx
	});

	return block;
}

// (1005:4) 
function create_footer_slot_2(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				unelevated: true,
				outlined: true,
				color: "#ccc",
				class: "#ccc",
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleClose*/ ctx[3]);

	button1 = new Button({
			props: {
				id: "xmlDone",
				class: "submitBtton",
				unelevated: true,
				color: "primary",
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*validateItemId*/ ctx[14]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file$g, 1004, 4, 52079);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot_2.name,
		type: "slot",
		source: "(1005:4) ",
		ctx
	});

	return block;
}

// (1027:0) <Dialog width="600" bind:visible={state.delNode} style="background-color:#fff; border-radius: 5px;">
function create_default_slot_5$1(ctx) {
	let h4;
	let div1;
	let div0;
	let t1;
	let div2;

	const block = {
		c: function create() {
			h4 = element("h4");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = `${l$1.save_header}`;
			t1 = space();
			div2 = element("div");
			div2.textContent = `${l$1.del_confirmation}`;
			add_location(div0, file$g, 1029, 12, 52797);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file$g, 1028, 8, 52739);
			attr_dev(h4, "class", "mt-1 font21 mb-2");
			add_location(h4, file$g, 1027, 4, 52700);
			add_location(div2, file$g, 1032, 4, 52856);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, div1);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(1027:0) <Dialog width=\\\"600\\\" bind:visible={state.delNode} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (1035:8) <Button              id="xmlDone"              variant="contained"              disableRipple="true"              on:click={setInputState.bind(this, 'delNode', false)}              color="#ccc"          >
function create_default_slot_4$1(ctx) {
	let t_value = l$1.no_label + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(1035:8) <Button              id=\\\"xmlDone\\\"              variant=\\\"contained\\\"              disableRipple=\\\"true\\\"              on:click={setInputState.bind(this, 'delNode', false)}              color=\\\"#ccc\\\"          >",
		ctx
	});

	return block;
}

// (1044:8) <Button              variant="contained"              disableRipple="true"              on:click={changeDeleteValues}              color="primary"          >
function create_default_slot_3$1(ctx) {
	let t_value = l$1.yes_label + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(1044:8) <Button              variant=\\\"contained\\\"              disableRipple=\\\"true\\\"              on:click={changeDeleteValues}              color=\\\"primary\\\"          >",
		ctx
	});

	return block;
}

// (1034:4) 
function create_footer_slot_1(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				id: "xmlDone",
				variant: "contained",
				disableRipple: "true",
				color: "#ccc",
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*setInputState*/ ctx[5].bind(this, 'delNode', false));

	button1 = new Button({
			props: {
				variant: "contained",
				disableRipple: "true",
				color: "primary",
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*changeDeleteValues*/ ctx[13]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "footer");
			set_style(div, "border-top", "1px solid var(--divider, rgba(0, 0, 0, 0.1))");
			add_location(div, file$g, 1033, 4, 52893);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot_1.name,
		type: "slot",
		source: "(1034:4) ",
		ctx
	});

	return block;
}

// (1054:0) <Dialog width="600" bind:visible={state.add_transcript} style="background-color:#fff; border-radius: 5px;">
function create_default_slot_2$2(ctx) {
	let h4;
	let div1;
	let div0;
	let t1;
	let div10;
	let div9;
	let div8;
	let div7;
	let form;
	let input0;
	let t2;
	let div2;
	let label0;
	let span0;
	let t4;
	let input1;
	let input1_placeholder_value;
	let input1_title_value;
	let t5;
	let div3;
	let label1;
	let span1;
	let t7;
	let input2;
	let input2_placeholder_value;
	let input2_title_value;
	let t8;
	let input3;
	let t9;
	let input4;
	let t10;
	let div4;
	let video;
	let t11;
	let div6;
	let label2;
	let span2;
	let t13;
	let div5;
	let t14;
	let textarea;
	let textarea_placeholder_value;
	let textarea_title_value;

	const block = {
		c: function create() {
			h4 = element("h4");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = `${l$1.add_transcript_msg}`;
			t1 = space();
			div10 = element("div");
			div9 = element("div");
			div8 = element("div");
			div7 = element("div");
			form = element("form");
			input0 = element("input");
			t2 = space();
			div2 = element("div");
			label0 = element("label");
			span0 = element("span");
			span0.textContent = `${l$1.title}`;
			t4 = space();
			input1 = element("input");
			t5 = space();
			div3 = element("div");
			label1 = element("label");
			span1 = element("span");
			span1.textContent = `${l$1.duration}`;
			t7 = space();
			input2 = element("input");
			t8 = space();
			input3 = element("input");
			t9 = space();
			input4 = element("input");
			t10 = space();
			div4 = element("div");
			video = element("video");
			t11 = space();
			div6 = element("div");
			label2 = element("label");
			span2 = element("span");
			span2.textContent = `${l$1.vtt}`;
			t13 = space();
			div5 = element("div");
			t14 = space();
			textarea = element("textarea");
			add_location(div0, file$g, 1056, 12, 53700);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file$g, 1055, 8, 53642);
			attr_dev(h4, "class", "mt-1 font21 mb-4");
			add_location(h4, file$g, 1054, 4, 53603);
			attr_dev(input0, "type", "hidden");
			attr_dev(input0, "class", "form-control vtt_input");
			attr_dev(input0, "name", "media_url");
			attr_dev(input0, "id", "media_url");
			add_location(input0, file$g, 1064, 24, 53997);
			attr_dev(span0, "class", "mendatory_label float-left");
			add_location(span0, file$g, 1066, 108, 54266);
			attr_dev(label0, "class", "control-label font-weight-normal d-inline-flex");
			attr_dev(label0, "for", "media_title");
			add_location(label0, file$g, 1066, 28, 54186);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "class", "form-control vtt_input");
			attr_dev(input1, "name", "media_title");
			attr_dev(input1, "id", "media_title");
			attr_dev(input1, "placeholder", input1_placeholder_value = l$1.title);
			attr_dev(input1, "title", input1_title_value = l$1.title);
			add_location(input1, file$g, 1067, 28, 54361);
			attr_dev(div2, "class", "form-group text-left video_title h");
			add_location(div2, file$g, 1065, 24, 54108);
			attr_dev(span1, "class", "mendatory_label float-left");
			add_location(span1, file$g, 1070, 111, 54716);
			attr_dev(label1, "class", "control-label font-weight-normal d-inline-flex");
			attr_dev(label1, "for", "media_duration");
			add_location(label1, file$g, 1070, 28, 54633);
			attr_dev(input2, "type", "text");
			attr_dev(input2, "class", "form-control vtt_input");
			attr_dev(input2, "name", "media_duration");
			attr_dev(input2, "id", "media_duration");
			attr_dev(input2, "placeholder", input2_placeholder_value = l$1.duration);
			attr_dev(input2, "title", input2_title_value = l$1.duration);
			add_location(input2, file$g, 1071, 28, 54814);
			attr_dev(div3, "class", "form-group text-left video_duration_container");
			add_location(div3, file$g, 1069, 24, 54544);
			attr_dev(input3, "type", "hidden");
			attr_dev(input3, "class", "form-control vtt_input");
			attr_dev(input3, "name", "courses");
			attr_dev(input3, "id", "courses");
			add_location(input3, file$g, 1073, 24, 55009);
			attr_dev(input4, "type", "hidden");
			attr_dev(input4, "class", "form-control vtt_input");
			attr_dev(input4, "name", "func");
			input4.value = "from_video_player";
			attr_dev(input4, "id", "func");
			add_location(input4, file$g, 1074, 24, 55116);
			attr_dev(video, "id", "myVideo");
			attr_dev(video, "width", "320");
			attr_dev(video, "height", "240");
			video.controls = true;
			add_location(video, file$g, 1076, 28, 55288);
			attr_dev(div4, "class", "h");
			add_location(div4, file$g, 1075, 24, 55243);
			attr_dev(span2, "class", "mendatory_label float-left");
			add_location(span2, file$g, 1080, 100, 55574);
			attr_dev(label2, "class", "control-label font-weight-normal d-inline-flex");
			attr_dev(label2, "for", "vtt");
			add_location(label2, file$g, 1080, 28, 55502);
			attr_dev(div5, "class", "mb-2 message_block text-b-red h");
			add_location(div5, file$g, 1081, 28, 55667);
			attr_dev(textarea, "name", "vtt");
			attr_dev(textarea, "class", "form-control max_height_350 min_height_295 vtt_input vtt_textarea");
			attr_dev(textarea, "placeholder", textarea_placeholder_value = l$1.enter_vtt);
			attr_dev(textarea, "title", textarea_title_value = l$1.enter_vtt);
			attr_dev(textarea, "id", "vtt");
			attr_dev(textarea, "rows", "12");
			attr_dev(textarea, "cols", "250");
			add_location(textarea, file$g, 1082, 28, 55748);
			attr_dev(div6, "class", "form-group text-left");
			add_location(div6, file$g, 1079, 24, 55438);
			attr_dev(form, "name", "vtt_module");
			attr_dev(form, "id", "vtt_module");
			add_location(form, file$g, 1063, 20, 53931);
			attr_dev(div7, "class", "col-12");
			add_location(div7, file$g, 1062, 16, 53889);
			attr_dev(div8, "class", "row");
			add_location(div8, file$g, 1061, 12, 53854);
			attr_dev(div9, "class", "add_transcript_dialog min_height_352");
			add_location(div9, file$g, 1060, 8, 53790);
			attr_dev(div10, "style", "");
			add_location(div10, file$g, 1059, 4, 53766);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, div1);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div10, anchor);
			append_dev(div10, div9);
			append_dev(div9, div8);
			append_dev(div8, div7);
			append_dev(div7, form);
			append_dev(form, input0);
			append_dev(form, t2);
			append_dev(form, div2);
			append_dev(div2, label0);
			append_dev(label0, span0);
			append_dev(div2, t4);
			append_dev(div2, input1);
			append_dev(form, t5);
			append_dev(form, div3);
			append_dev(div3, label1);
			append_dev(label1, span1);
			append_dev(div3, t7);
			append_dev(div3, input2);
			append_dev(form, t8);
			append_dev(form, input3);
			append_dev(form, t9);
			append_dev(form, input4);
			append_dev(form, t10);
			append_dev(form, div4);
			append_dev(div4, video);
			append_dev(form, t11);
			append_dev(form, div6);
			append_dev(div6, label2);
			append_dev(label2, span2);
			append_dev(div6, t13);
			append_dev(div6, div5);
			append_dev(div6, t14);
			append_dev(div6, textarea);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div10);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(1054:0) <Dialog width=\\\"600\\\" bind:visible={state.add_transcript} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (1091:8) <Button              variant="contained"              disableRipple="true"              on:click={handleTranscriptDialog}              color="primary"              class="BtnOutline"          >
function create_default_slot_1$2(ctx) {
	let t_value = l$1.cancel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(1091:8) <Button              variant=\\\"contained\\\"              disableRipple=\\\"true\\\"              on:click={handleTranscriptDialog}              color=\\\"primary\\\"              class=\\\"BtnOutline\\\"          >",
		ctx
	});

	return block;
}

// (1100:8) <Button              id="xmlDone"              variant="contained"              disableRipple="true"              on:click={addTranscript}              color="primary"              class="BtnDark"          >
function create_default_slot$4(ctx) {
	let t_value = l$1.add_vtt + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(1100:8) <Button              id=\\\"xmlDone\\\"              variant=\\\"contained\\\"              disableRipple=\\\"true\\\"              on:click={addTranscript}              color=\\\"primary\\\"              class=\\\"BtnDark\\\"          >",
		ctx
	});

	return block;
}

// (1090:4) 
function create_footer_slot$1(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				variant: "contained",
				disableRipple: "true",
				color: "primary",
				class: "BtnOutline",
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleTranscriptDialog*/ ctx[15]);

	button1 = new Button({
			props: {
				id: "xmlDone",
				variant: "contained",
				disableRipple: "true",
				color: "primary",
				class: "BtnDark",
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*addTranscript*/ ctx[8]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "footer bttmBtn");
			set_style(div, "border-top", "1px solid var(--divider, rgba(0, 0, 0, 0.1))");
			add_location(div, file$g, 1089, 4, 56069);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot$1.name,
		type: "slot",
		source: "(1090:4) ",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let dialog0;
	let updating_visible;
	let t0;
	let dialog1;
	let updating_visible_1;
	let t1;
	let dialog2;
	let updating_visible_2;
	let current;

	function dialog0_visible_binding(value) {
		/*dialog0_visible_binding*/ ctx[23](value);
	}

	let dialog0_props = {
		width: "600",
		class: "remove_right_margin",
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot_2],
			default: [create_default_slot_8$1]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].open !== void 0) {
		dialog0_props.visible = /*state*/ ctx[0].open;
	}

	dialog0 = new Dialog({ props: dialog0_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog0, 'visible', dialog0_visible_binding));

	function dialog1_visible_binding(value) {
		/*dialog1_visible_binding*/ ctx[24](value);
	}

	let dialog1_props = {
		width: "600",
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot_1],
			default: [create_default_slot_5$1]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].delNode !== void 0) {
		dialog1_props.visible = /*state*/ ctx[0].delNode;
	}

	dialog1 = new Dialog({ props: dialog1_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog1, 'visible', dialog1_visible_binding));

	function dialog2_visible_binding(value) {
		/*dialog2_visible_binding*/ ctx[25](value);
	}

	let dialog2_props = {
		width: "600",
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot$1],
			default: [create_default_slot_2$2]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].add_transcript !== void 0) {
		dialog2_props.visible = /*state*/ ctx[0].add_transcript;
	}

	dialog2 = new Dialog({ props: dialog2_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog2, 'visible', dialog2_visible_binding));

	const block = {
		c: function create() {
			create_component(dialog0.$$.fragment);
			t0 = space();
			create_component(dialog1.$$.fragment);
			t1 = space();
			create_component(dialog2.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dialog0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(dialog1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(dialog2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const dialog0_changes = {};

			if (dirty[0] & /*state*/ 1 | dirty[1] & /*$$scope*/ 262144) {
				dialog0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 1) {
				updating_visible = true;
				dialog0_changes.visible = /*state*/ ctx[0].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog0.$set(dialog0_changes);
			const dialog1_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				dialog1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_1 && dirty[0] & /*state*/ 1) {
				updating_visible_1 = true;
				dialog1_changes.visible = /*state*/ ctx[0].delNode;
				add_flush_callback(() => updating_visible_1 = false);
			}

			dialog1.$set(dialog1_changes);
			const dialog2_changes = {};

			if (dirty[1] & /*$$scope*/ 262144) {
				dialog2_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_2 && dirty[0] & /*state*/ 1) {
				updating_visible_2 = true;
				dialog2_changes.visible = /*state*/ ctx[0].add_transcript;
				add_flush_callback(() => updating_visible_2 = false);
			}

			dialog2.$set(dialog2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog0.$$.fragment, local);
			transition_in(dialog1.$$.fragment, local);
			transition_in(dialog2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog0.$$.fragment, local);
			transition_out(dialog1.$$.fragment, local);
			transition_out(dialog2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dialog0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(dialog1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(dialog2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function youtube_parser(url) {
	let regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
	let match = url.match(regExp);
	return match && match[7].length == 11 ? match[7] : false;
}

function openTranscript(media_guid) {
	var anchor_tag = document.createElement('a');
	anchor_tag.href = baseUrl + 'editor/v2/?action=edit&content_guid=' + media_guid + '&no_header=1&react_content=1&no_domain=1&video_player=1';
	anchor_tag.target = '_blank';
	anchor_tag.click();
}

function swapJson(json) {
	let swap = {};

	if (json) {
		for (let key in json) {
			swap[json[key]] = key;
		}
	}

	return swap;
}

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Player', slots, []);
	let { playerBookmark } = $$props;
	let { editorState } = $$props;
	let { value } = $$props;
	let { renderPlayerFunc } = $$props;

	let itemArray = [
		'quiz',
		'link',
		'terminal',
		'object3d',
		'exhibit',
		'insight',
		'lablink',
		'playground',
		'simulation'
	];

	const option = [
		'nofeedback',
		'embed',
		'no_of_attempt',
		'correct',
		'default',
		'preview',
		'isplayer',
		'display',
		'mode_checkbox',
		'show_caption',
		'hide_caption',
		'button_name',
		'intervals',
		'notitle',
		'token',
		'wid',
		'loid',
		'inline'
	];

	const style = [
		'class',
		'style',
		'height',
		'width',
		'color',
		'align',
		'size',
		'layout',
		'bordered'
	];

	const guid = ['guid', 'guids', 'labguid', 'help', 'asset'];

	const category = {
		'quiz': 'knowledge_check',
		'terminal': 'lab',
		'simulation': 'lab',
		'insight': 'lab',
		'lablink': 'lab',
		'playground': 'lab',
		'video': 'media',
		'audio': 'media',
		'exhibit': 'link',
		'pdf': 'link',
		'weblink': 'link',
		'download': 'link',
		'object3d': 'objects'
	};

	const mapping = {
		'stepplayer': 'video',
		'wguvideo': 'video',
		'external': 'simulation',
		'label': 'title',
		'imgwidth': 'width',
		'imgheight': 'height',
		'imgsrc': 'img',
		'imgalt': 'alt',
		'image_url': 'img',
		'alt_txt': 'alt',
		'toggle_link': 'hide_caption',
		'lab': 'insight',
		'image': 'img',
		'scorm_caption_id': 'group_guids'
	};

	const listItem = ['exhibit', 'insight', 'lablink', 'playground', 'simulation', 'external'];
	const transcript_hide = ['youtube', 'lynda'];
	let state = {};
	let prevState = {};

	let hdd = writable({
		open: true,
		add_transcript: false,
		category: 'knowledge_check',
		type: 'quiz',
		nofeedback: true,
		embed: 'inline',
		isplayer: false,
		isPlayerCheck: false,
		security: false,
		multiple: false,
		intervals: false,
		btn_style: 'btn',
		exhibitType: 'asset',
		editBtnVisibility: false,
		sqlLab: false,
		layout: 'button',
		from_coverage: false,
		snt: '00cRX',
		seq: '',
		weblinkEmbed: false,
		spanstyle: '',
		islistContent: false,
		content_type: 'q,u',
		content_subtype: '',
		sub_type: '',
		bordered: false,
		delNode: false,
		rowID: '',
		showData: false,
		msg: '',
		oldPlayground: false,
		oldSimulation: false,
		inline: false,
		prevValue: ""
	});

	const unsubscribe = hdd.subscribe(items => {
		$$invalidate(0, state = items);
	});

	onMount(async () => {
		console.warn("on player mount", editorState.playerArr);

		if (typeof window.WebVTTParser == "undefined") {
			AH.addScript("", baseUrlTheme + 'svelte_items/src/libs/editorLib/webparser.js');
		}

		prevState = state;
		$$invalidate(0, state.prevValue = editorState.playerArr, state);
		didMount();
	});

	beforeUpdate(async () => {
		console.warn("Before update", {
			pre: state.prevValue,
			player: editorState.playerArr
		});

		onUpdate(editorState.playerArr);
	});

	function onUpdate(oldValue) {
		console.warn({ l: "onUpdate", oldValue });

		//It will only when dialog will be opened
		if (oldValue && !state.showData) {
			let input_id,
				tag_name,
				player_category = '',
				player_type = '',
				new_key = '',
				json_value = '';

			if (AI.isValid(oldValue.obj)) {
				tag_name = oldValue.obj.outerHTML.match(/\w+/gim)[0];
			}

			//Manage player type for both new and old player tag
			player_type = AI.isValid(mapping[oldValue.type])
			? mapping[oldValue.type]
			: oldValue.type;

			if (player_type == 'toggleoutput' || tag_name == 'span') {
				player_type = 'exhibit';
			}

			//Manage player category for both new and old player tag
			if (oldValue.category && oldValue.category != '') {
				player_category = oldValue.category;
			} else if (AI.isValid(category[player_type])) {
				player_category = category[player_type];
			}

			//Get type for snt and seq tag
			if (player_type == '' || player_type == undefined) {
				player_category = player_type = tag_name;
			}

			$$invalidate(0, state.msg = '', state);
			player_type && $$invalidate(0, state.type = player_type, state);
			player_category && $$invalidate(0, state.category = player_category, state);
			$$invalidate(0, state.editBtnVisibility = oldValue.asset ? true : false, state);

			$$invalidate(
				0,
				state.oldPlayground = oldValue.playground && player_type == 'playground' && !AI.isValid(oldValue.asset)
				? true
				: false,
				state
			);

			$$invalidate(
				0,
				state.oldSimulation = oldValue.config && player_type == 'simulation' && !AI.isValid(oldValue.asset)
				? true
				: false,
				state
			);

			$$invalidate(0, state.open = true, state);
			$$invalidate(0, state.showData = true, state);
			input_id = '.' + player_category + '_tag';

			let updateTimer = setTimeout(
				() => {
					if (transcript_hide.indexOf(editorState.playerArr.sub_type) == -1) {
						AH.setAttr('.edit_transcript', { 'disabled': true, 'guid': '' });
					}

					for (let key in editorState.playerArr) {
						if (key != 'type' && key != 'obj' && key != 'bookmark' && key != 'category' && editorState.playerArr[key] != '') {
							if (key == 'security' || key == 'token') {
								$$invalidate(0, state.security = true, state);
							}

							if (key == 'is_multiple' && editorState.playerArr[key] == 1) {
								$$invalidate(0, state.multiple = true, state);
							}

							if (!state.intervals && (key == 'stepcaptions' || key == 'intervals')) {
								$$invalidate(0, state.intervals = true, state);
							}

							if ((key == 'sub_type' || key == 'imgsrc') && player_type == 'weblink') {
								$$invalidate(
									0,
									state.embed = editorState.playerArr[key] == 'embed' && !AI.isValid(editorState.playerArr.imgsrc)
									? 'inline'
									: 'new_tab',
									state
								);
							} else if (key == 'sub_type') {
								$$invalidate(0, state.sub_type = editorState.playerArr[key], state);
							}

							if (state.sub_type != 'scorm' && AI.isValid(editorState.playerArr.asset_m)) {
								$$invalidate(0, state.sub_type = 'scorm', state);
							}

							if (key == 'is_sql') {
								$$invalidate(0, state.embed = 'overlay', state);
							}

							if (key == 'border_check') {
								$$invalidate(0, state.bordered = true, state);
							}

							if (editorState.playerArr.img && player_type == 'weblink' && state.embed != 'new_tab') {
								$$invalidate(0, state.embed = 'new_tab', state);
							}

							if (guid.indexOf(key) > -1) {
								new_key = 'asset';
							} else if (tag_name == 'span' && key == 'playground') {
								new_key = "show_caption";
							} else if (mapping[key] != undefined) {
								new_key = mapping[key];
							} else {
								new_key = key;
							}

							//Manage Old exhibit, toggleout, span tag and convert into new exhibit
							if (player_type == 'exhibit' && editorState.playerArr.category == undefined) {
								if (AI.isValid(editorState.playerArr.asset) || AI.isValid(editorState.playerArr.guid) && editorState.playerArr['guid'].trim().length == 5) {
									$$invalidate(0, state.sub_type = 'item', state);
									$$invalidate(0, state.embed = 'overlay', state);

									$$invalidate(
										0,
										state.layout = tag_name == 'span' || editorState.playerArr.layout == 'link'
										? 'link'
										: 'button',
										state
									);
								} else if (AI.isValid(editorState.playerArr.img) || AI.isValid(editorState.playerArr.layout) && editorState.playerArr.layout == 'link') {
									$$invalidate(0, state.sub_type = 'image', state);
									$$invalidate(0, state.embed = 'overlay', state);
									$$invalidate(0, state.layout = editorState.playerArr.layout ? 'link' : 'button', state);
								} else if (AI.isValid(editorState.playerArr.image_url) || AI.isValid(editorState.playerArr.toggle_link)) {
									$$invalidate(0, state.sub_type = tag_name == 'span' ? 'text' : 'image', state);
									$$invalidate(0, state.embed = 'inline', state);
									$$invalidate(0, state.layout = 'button', state);

									if (tag_name == 'span') {
										AH.selectAll('.span_text_data', 'removeClass', 'span_text_data');
										AH.selectAll(oldValue.obj, 'addClass', 'span_text_data');
										AH.select('.link_tag #text').value = AH.select('.span_text_data').nextElementSibling.textContent;

										if (key == 'guid') {
											new_key = 'false';
										}
									}
								}

								if (key == 'title') {
									new_key = 'show_caption';
								}
							}

							if (player_type == 'snt') {
								$$invalidate(0, state.snt = editorState.playerArr[key], state);
							} else if (player_type == 'seq') {
								$$invalidate(0, state.seq = editorState.playerArr[key], state);
							}

							if (document.querySelectorAll(input_id + ' #' + new_key).length > 0) {
								AH.select(input_id + ' #' + new_key).value = editorState.playerArr[key].trim();
							}

							if (player_type == "video") {
								if (new_key == 'group_guids' && editorState.playerArr[key].trim().length == 5) {
									AH.setAttr('.edit_transcript', { 'guid': editorState.playerArr[key] });
									AH.select('.edit_transcript').disabled = false;
								} else if (new_key == "asset") {
									var asset_value = editorState.playerArr[key].trim();
									AH.select(input_id + ' #' + new_key).setAttribute('data-value', asset_value);

									AH.select(input_id + ' #' + new_key).value = editorState.playerArr.sub_type == 'youtube'
									? 'https://www.youtube.com/watch?v=' + asset_value
									: asset_value;
								}
							}

							if (player_type == 'download' && key == 'img') {
								AH.select(input_id + ' #icon').value = editorState.playerArr[key];
							}

							//Convert player version 1 attributes into player version 2
							if (editorState.playerArr.category == undefined && option.indexOf(key) > -1) {
								json_value += json_value != ''
								? `,"${key}":"${editorState.playerArr[key].trim()}"`
								: `{"${key}":"${editorState.playerArr[key].trim()}"`;
							}

							if (key == 'token' || key == 'wid') {
								json_value = json_value.replace('}', '').replace('wid', 'wID') + '}';
								AH.select(input_id + ' #security').value = json_value;
							} else if (key == 'option' || key == 'styles' || json_value != '') {
								if (json_value != '') {
									json_value = json_value.replace('}', '') + '}';
								} else {
									json_value = editorState.playerArr[key];
								}

								getJsonAttrValue(json_value, input_id);
								json_value = '';
							}
						}
					}

					if (editorState.playerArr.stepcaptions) {
						createSteptable('create');
					}

					if (editorState.playerArr.playground && !AI.isValid(editorState.playerArr.asset)) {
						let playground_val = editorState.playerArr.playground.replace(/#nl#/g, "\n").replace(/\#t\#/g, "\t").replace(/\#s\#/g, "  ").replace(/\#lt\#/g, "<").replace(/\#gt\#/g, ">");

						if (playground_val.indexOf('<playcode style="display: none;">') > -1) {
							playground_val = playground_val.split('<playcode style="display: none;">')[1].replace('</playcode></player>', '');
						}

						AH.select('#xml_data').value = playground_val.trim();
					}

					correctLabelStyle();
					clearTimeout(updateTimer);
				},
				100
			);
		} else if (!state.open) {
			$$invalidate(0, state.open = true, state);
		}
	}

	afterUpdate(async () => {
		AH.enableBsAll("[rel=tooltip]", 'Tooltip'); // Enable tooltip for all selected dom.
		let isFound = itemArray.indexOf(state.type);

		if (isFound > -1) {
			setContentType();

			if (!state.islistContent && listItem.indexOf(state.type) == -1) {
				$$invalidate(0, state.islistContent = true, state);
			} else if (state.islistContent && listItem.indexOf(state.type) > -1) {
				$$invalidate(0, state.islistContent = false, state);
			}
		} else if (isFound == -1 && state.islistContent) {
			$$invalidate(0, state.islistContent = false, state);
		}

		if (AH.select('.link_tag #sub_type').value == 'item' && state.sub_type != 'item') {
			$$invalidate(0, state.sub_type = 'item', state);
		}

		if (prevState.type != state.type || prevState.sub_type != state.sub_type) {
			$$invalidate(0, state.msg = '', state);
		}

		if (prevState.type != state.type) {
			$$invalidate(0, state.embed = 'inline', state);
			AH.select('.' + state.category + '_tag input[disabled]').setAttribute("disabled", false);
		}

		AH.addClass('.' + state.category + '_tag input[disabled]', "cursor_not_allowed");
		prevState = state;
	});

	function didMount() {
		AH.listen(document.body, 'click', '.deleteinterval', function (_this) {
			if (AH.selectAll('.stepplayertable tbody tr').length > 1) {
				$$invalidate(0, state.delNode = true, state);
				$$invalidate(0, state.rowID = _this.getAttribute('data-id'), state);
			} else {
				AH.showmsg(l$1.can_not_del);
			}
		});

		AH.listen(document.body, 'click', '#table_list tr', function (_this) {
			let item_id = AH.select('#showPlayerList #asset').value.trim();
			AH.find(_this, 'td', 'all')[0].classList.toggle('tick');

			AH.selectAll("#table_list tr td.tick").forEach(function (elm) {
				item_id += item_id != ''
				? ',' + elm.parentElement.getAttribute('id')
				: elm.parentElement.getAttribute('id');
			});

			if (!AH.find(_this, 'td', 'all')[0].classList.contains('tick')) {
				item_id = item_id.replace(',' + _this.getAttribute('id'), '');
			}

			AH.select('#showPlayerList #asset').value = Array.from(new Set(item_id.split(','))).toString();
			correctLabelStyle();
		});

		AH.listen(document.body, 'change', '#showPlayerList input[type="text"], #showPlayerList textarea', function () {
			correctLabelStyle();
		});

		AH.listen(document, "click", ".edit_item_id", function (_elm) {
			editContent(_elm.getAttribute('guid'));
		});

		AH.listen(document.body, 'click', '.edit_transcript', function () {
			openTranscript(AH.select('.edit_transcript').getAttribute('guid'));
		});

		AH.listen(document.body, 'change', '.link_tag #icon', function () {
			AH.select('.link_tag #img').value = AH.select('.link_tag #icon option', 'selected')[0].value;
			AH.select('.link_tag #alt').value = AH.select('.link_tag #icon option[value!=""]', 'selected')[0].textContent;
			correctLabelStyle();
		});

		AH.listen(document.body, 'keyup', '.vtt_textarea', function () {
			validateVTT();
		});
	}

	function getJsonAttrValue(data, input_id) {
		if (data != '') {
			let tempValue = '';
			data = JSON.parse(data);

			for (var key in data) {
				if (state[key] != undefined && key != 'intervals') {
					tempValue = data[key];

					if (key == 'nofeedback') {
						tempValue = data[key] == 0 ? true : false;
					}

					$$invalidate(
						0,
						state[key] = tempValue == 1 || tempValue == 0
						? Boolean(tempValue)
						: tempValue,
						state
					);
				}

				if (AH.selectAll(input_id + ' #' + key).length > 0) {
					AH.select(input_id + ' #' + key).value = data[key];
				}
			}
		}
	}

	function correctLabelStyle(input_id) {
		input_id = input_id || '.' + state.category + '_tag';

		AH.find(input_id, 'input[type="text"], textarea', 'all').forEach(function (_this) {
			if (_this.value.trim().length != 0) {
				AH.find(_this.parentElement.parentElement, 'label', 'all').forEach(_currThis => AH.setCss(_currThis, {
					transform: "translate(0, 1.5px) scale(0.75)",
					"color": "rgba(0, 0, 0, 0.54)"
				}));
			} else {
				AH.find(_this.parentElement.parentElement, 'label', 'all').forEach(_currThis => _currThis.removeAttribute('style'));
			}
		});
	}

	function createSteptable(type) {
		if (type == 'add') {
			appendData();
		} else {
			let intervals = AH.select('#intervals').value;
			let interval_array = intervals != undefined ? intervals.split(",") : [];
			let stepcaptions = AH.select('#stepcaptions').value;

			let stepcaption_array = stepcaptions != undefined
			? stepcaptions.split("###")
			: [];

			for (let i in stepcaption_array) {
				stepcaption_array[i] = stepcaption_array[i].replace(/\\(\W)/g, "$1");
			}

			AH.select('.stepplayertable tbody').innerHTML = '';

			(forEach((val, i) => {
				appendData(val, stepcaption_array[i]);
			}));
		}
	}

	function appendData(intervalvalue, captiontext) {
		intervalvalue = intervalvalue || '';
		captiontext = captiontext || '';
		let seq_num = parseInt(AH.selectAll('.stepplayertable tbody tr').length) + 1;
		AH.insert('.stepplayertable tbody', `<tr data-id="${seq_num}"><td class="align-middle">${seq_num}</td><td><input type="number" min="0" step="1" class="intervaltext form-control form-control-sm width80 pr-sm" placeholder="Interval" value="${intervalvalue}" /></td><td><input type="text" class="captiontext w-100 form-control form-control-sm" placeholder="Caption" maxlength="200" value="${captiontext}" /></td><td><a href="#" class="deleteinterval" data-id="${seq_num}"><span rel="tooltip" data-original-title="Delete" class="icomoon icomoon-new-24px-delete-1 s3"></span></a></td></tr>`, 'beforeend');
	}

	function handleClose() {
		$$invalidate(0, state.open = false, state);
		$$invalidate(0, state.showData = false, state);
		$$invalidate(16, editorState.playerState = false, editorState);
	}

	function handlePlayer(event) {
		AH.select('#showPlayerList input[type="text"]').value = '';

		AH.selectAll('.listContent, #search').forEach(elm => {
			elm.setAttribute('disabled', false);
			elm.classList.remove('cursor_not_allowed');
		});

		AH.selectAll('.list_content, #not_found, .table_list_guid', 'hide');
		let tag_category = swapJson(category);
		$$invalidate(0, state.editBtnVisibility = false, state);
		$$invalidate(0, state.category = event.target.value, state);

		$$invalidate(
			0,
			state.type = tag_category[event.target.value] != undefined
			? tag_category[event.target.value]
			: event.target.value,
			state
		);
	}

	function setInputState(key, value) {
		$$invalidate(0, state[key] = value !== false ? value : !state[key], state);
	}

	function insertImage(id) {
		try {
			AH.editorModal(id);
		} catch(err) {
			AH.getBS("#modal-media-upload", 'Modal').show();
		}
	}

	function setVideoAsset(id, newValue) {
		if (newValue.startsWith('https://www.youtube')) {
			newValue = youtube_parser(newValue);
			$$invalidate(0, state.sub_type = 'youtube', state);
		} else if ((newValue.indexOf("//player.vimeo.com") != -1 || id == 'guid' && newValue.trim() != '') && AH.select('#group_guids').value.trim() != '') {
			$$invalidate(0, state.sub_type = 'video_plus', state);
		} else if (newValue.startsWith('//www.lynda.com')) {
			$$invalidate(0, state.sub_type = 'lynda', state);
		} else {
			$$invalidate(0, state.sub_type = '', state);
		}

		if (id != 'guid') {
			AH.select('.media_tag #asset').setAttribute('data-value', newValue);
			AH.setAttr('.edit_transcript', { 'disabled': true, 'guid': '' });
			AH.select('#group_guids', 'enabled')[0].value = '';
			AH.trigger(AH.select('#group_guids', 'enabled')[0], 'change');
		} else {
			AH.select('.edit_transcript').setAttribute('guid', newValue);
			AH.select('.edit_transcript').disabled = !(AH.select('.edit_transcript').getAttribute('guid').length == '5');
		}
	}

	function validateVTT() {
		let parser = new WebVTTParser();
		let result = parser.parse(AH.select('.vtt_textarea').value, "subtitles/captions/descriptions");

		if (result.errors.length > 0) {
			let msg = 'Error : <br>';

			for (let index = 0; index < result.errors.length; index++) {
				let error = result.errors[index];
				let message = index + 1 + ") Line " + error.line;

				if (error.col) {
					message += ", column " + error.col;
				}

				msg += message + ": " + error.message + '<br>';
			}

			AH.select('.message_block').classList.remove('h');
			AH.select('.message_block').innerHTML = msg;
			AH.select('#save_btn').disabled = true;
		} else {
			AH.select('.message_block').classList.add('h');
			AH.select('.message_block').innerHTML = '';
			AH.select('#save_btn').disabled = false;
		}
	}

	function addTranscript() {
		let is_error = 0;

		AH.selectAll('.vtt_input').forEach(function (_this) {
			if (_this.value == '') {
				is_error = 1;
			}
		});

		if (is_error == 1) {
			AI.showmsg(l$1.required_field);
		} else {
			AH.ajax({
				url: baseUrl + 'utils/vtt_parser.php',
				type: 'POST',
				data: AH.serialize('#vtt_module'),
				onStart() {
					AI.activate(2);
				}
			}).then(response => {
				$$invalidate(0, state.add_transcript = false, state);
				AH.select('.media_tag #group_guids').value = response;
				AH.trigger('.media_tag #group_guids', 'change');
				AH.select('.edit_transcript').setAttribute('guid', response);
				AH.select('.edit_transcript').disabled = false;
				AH.showmsg(l$1.vtt_added);
				AI.activate(0);
			});
		}
	}

	function updateVideoLink() {
		let url = document.getElementById('media_url').value.trim();
		let video = document.getElementById('myVideo');
		let source = document.createElement('source');
		source.setAttribute('type', 'video/mp4');
		let get_duration = 1;
		AH.select('.video_duration_container').classList.add('h');
		AH.select('#media_title').value.trim() == '' && AH.select('.video_title').classList.remove('h');

		if (url.indexOf("http://youtube.com") == 0) {
			AH.select('.video_duration_container').classList.remove('h');
			get_duration = 0;
		} else if (url.indexOf("//player.vimeo.com") != -1) {
			source.setAttribute('src', url);
		} else {
			source.setAttribute('src', 'http://s3.amazonaws.com/jigyaasa_content_stream/' + url);
		}

		//AH.select(video).innerHTML = source;
		video.append(source);

		AH.select('#media_duration').setAttribute('value', '');
		updateVideoDuration(get_duration);
	}

	function updateVideoDuration(get_duration) {
		if (!get_duration) {
			return;
		}

		let video = document.getElementById('myVideo');
		AI.activate(2);

		video.addEventListener('loadedmetadata', function () {
			AH.select('#media_duration').value = Math.ceil(video.duration);
			AI.activate(0);
		});

		video.addEventListener(
			'error',
			function (event) {
				AH.showmsg(l$1.valid_link);
				$$invalidate(0, state.add_transcript = false, state);
				AI.activate(0);
			},
			true
		);
	}

	function editContent(edit_item_id) {
		let src;

		if (!edit_item_id) {
			let guid = AH.select('#showPlayerList #asset').value;
			src = baseUrl + "editor/v2/?action=edit&content_guid=" + guid + "&in_frame=1&from_ebook=1&react_content=1&course_code=" + editor.course;

			if (guid.indexOf(',') !== -1) {
				AH.selectAll(".table_list_guid, #listProcess, .list_content", 'hide');
				let guidList = "<table class='table table-striped'><thead><tr><th style='background-color:#E3E3E3;'>Item ID</th><th class='check-mail' style='background-color:#E3E3E3;'>Action</th></tr></thead>";
				guid = guid.split(',');

				for (let i in guid) {
					guidList += "<tr><td>" + guid[i] + "</td><td><button type='button' guid='" + guid[i] + "' class='edit_item_id btn btn-secondary pull-right'>Edit</button></td></tr>";
				}

				guidList += "</table>";
				AH.selectAll(".table_list_guid", 'show')[0].innerHTML = guidList;
			} else {
				openEditorFrame(src);
			}
		} else {
			src = baseUrl + "editor/v2/?action=edit&from_myproject=1&content_guid=" + edit_item_id + "&in_frame=1&react_content=1&from_coverage=1&course_code=" + editor.course;
			openEditorFrame(src, "quiz_new");
		}
	}

	function setContentType() {
		let content_type = '', content_subtype = '';

		switch (state.type) {
			case "quiz":
				content_type = "q,u";
				break;
			case "exhibit":
				content_type = "f";
				break;
			case "terminal":
				content_type = "q,f";
				content_subtype = "13";
				break;
			case "object3d":
				content_type = "f";
				content_subtype = "52";
				break;
			case "insight":
				content_type = "f,q";
				content_subtype = "32,34,36";
				break;
			case "lablink":
				content_type = "q";
				content_subtype = "25";
				break;
			case "playground":
				content_type = "q";
				content_subtype = "24";
				break;
			case "simulation":
				content_type = "q";
				content_subtype = "16";
				break;
			default:
				content_type = content_subtype = '';
				break;
		}

		if (state.content_type != content_type || state.content_subtype != content_subtype) {
			$$invalidate(0, state.content_type = content_type, state);
			$$invalidate(0, state.content_subtype = content_subtype, state);
		}
	}

	/**
 * Function to list the content list.
*/
	function listContent() {
		AH.selectAll(".list_content, #not_found, .table_list_guid", 'hide');
		AH.toggleDom("#list_process", 'show');
		AH.select('#list_process', 'removeClass', ['h']);

		let listTimer = setTimeout(
			function () {
				if (state.content_type != '' || state.content_subtype != '') {
					AH.ajax({
						url: baseUrl + 'educator/project/index.php?func=get_content_list&ajax=1',
						data: {
							course_code: editor.course,
							content_type: state.content_type.split(','),
							content_subtype: state.content_subtype != ''
							? state.content_subtype.split(',')
							: ''
						}
					}).then(response => {
						AH.select('#list_process', 'addClass', ['h']);
						AH.toggleDom("#list_process", 'hide');
						AH.toggleDom(".list_content", 'show');

						if (response == "") {
							AH.toggleDom(".list_content", 'hide');
							AH.toggleDom("#not_found", 'show');
						} else {
							AH.toggleDom("#not_found", 'hide');
							AH.select("#table_list").innerHTML = response;
						}
					}).catch(e => {
						AH.showmsg(l$1.unable_to_get);
						AI.activate(0);
					});
				} else {
					AH.toggleDom("#list_process", 'hide');
					AH.toggleDom("#not_found", 'show');
				}

				clearTimeout(listTimer);
			},
			500
		);
	}

	function addNewContent() {
		let src = baseUrl + 'editor/?action=new&in_frame=1&from_educator=1&add_coverage=1&from_myproject=1&is_flashcard=1&refer_content=1&course_code=' + editor.course + '&p1=' + parent1 + '&p2=' + parent2;

		if (state.type == 'snt' || state.type == 'link') {
			src = src + '&content_type=f&content_subtype=22';
		} else {
			src = src + '&group_type=q,u,f&goback=1';
		}

		if (state.type == 'quiz') {
			openEditorFrame(src, 'quiz_new');
		} else {
			openEditorFrame(src);
		}

		$$invalidate(0, state.editBtnVisibility = true, state);
	}

	function searchTable(event) {
		let input_val = event.target.value, count = 0;

		AH.selectAll('.table_search tbody tr').forEach((val, key) => {
			if (val.textContent.toLowerCase().indexOf(input_val.toLowerCase()) == -1) {
				AH.selectAll('.table_search tbody tr')[key].style.display = "none";
			} else {
				AH.selectAll('.table_search tbody tr')[key].style.display = "block";
				count++;
			}
		});

		if (count > 0) {
			AH.toggleDom('#not_found', 'hide');
			AH.toggleDom('#list_content_tbl', 'show');
		} else {
			AH.toggleDom('#not_found', 'show');
			AH.toggleDom('#list_content_tbl', 'hide');
		}
	}

	function openEditorFrame(src, type) {
		type = type || 0;
		let data = '<div style="height:101%"><div class="load_data"><img class="absolute" style="top:0;bottom:0;left:0;right:0;margin:auto;" src="' + themeUrl + 'foundation/css/images/loading.gif"/></div><iframe allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true" id="editorFrame" class="editor_frame" type="' + type + '" frameborder = "0" src = "' + src + '" height = "0" width = "0" onload=showWeblinkIframeEditor(this)></iframe></div>';
		AH.select("#frame_container").innerHTML = data;

		if (AH.select('#go_back_window') == 'object') {
			AH.select('#go_back_window').closest('#bottombar').style.display = "none";
		}

		AH.select("#modal_editor").classList.add("no_margin_top");
		AH.find('#modal_editor', '.modal-dialog').style.width = '100%';

		AH.setCss(AH.find('#modal_editor', '.modal-content'), {
			'height': window.innerHeight - 47,
			'margin': 'auto',
			'max-width': window.innerWidth
		});

		AH.getBS('#modal_editor', 'Modal', { 'backdrop': 'static' }).show();
	}

	function changeDeleteValues() {
		AH.select('.stepplayertable tr[data-id=' + state.rowID + ']').remove();
		$$invalidate(0, state.delNode = false, state);
	}

	function handleSubmit() {
		let player = '',
			option_attr = '',
			style_attr = '',
			id_value = '',
			tag_category = category[state.type] != undefined
			? category[state.type]
			: '';

		player = '<player category="' + tag_category + '" type="' + state.type + '"';

		if (state.type == 'video') {
			if (state.intervals) {
				let interval_array = [], caption_array = [];

				AH.selectAll('.stepplayertable tbody tr').forEach(function (_this) {
					let intervaltext = _this.querySelector('.intervaltext').value;
					let captiontext = _this.querySelector('.captiontext').value;
					captiontext = captiontext.replace(/([^\ \w])/g, "\\$1");
					interval_array.push(intervaltext);
					caption_array.push(captiontext);
				});

				AH.select('.media_tag #intervals').value = interval_array.join(",");
				let captionstr = caption_array.join("###");
				AH.select('.media_tag #stepcaptions').value = captionstr;
			} else if (!state.security) {
				let transcript = AH.select('.media_tag #group_guids').value.trim();
				setVideoAsset(transcript != '' ? 'guid' : 'asset', AH.select('.media_tag #asset').value);
				AH.select('.media_tag #sub_type').value = state.sub_type;
			}
		}

		let selector = state.category + '_tag',
			exhibit_txt = '',
			entity = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'\'': '&apos;',
				'"': '&quot;'
			};

		AH.selectAll('.' + selector + ' input, .' + selector + ' select, .' + selector + ' #text').forEach(_this => {
			if (_this.getAttribute('id') != undefined && _this.getAttribute('id') != 'type' && _this.getAttribute('id') != 'icon' && !_this.disabled) {
				if (option.indexOf(_this.getAttribute('id')) > -1) {
					option_attr += option_attr != ''
					? ',"' + _this.getAttribute('id') + '":"' + _this.value.trim() + '"'
					: '"' + _this.getAttribute('id') + '":"' + _this.value.trim() + '"';
				} else if (style.indexOf(_this.getAttribute('id')) > -1) {
					style_attr += style_attr != ''
					? ',"' + _this.getAttribute('id') + '":"' + _this.value.trim() + '"'
					: '"' + _this.getAttribute('id') + '":"' + _this.value.trim() + '"';
				} else if (guid.indexOf(_this.getAttribute('id')) > -1) {
					player += ' asset="' + (_this.closest('.video_asset')
					? _this.getAttribute('data-value').trim()
					: _this.value.trim()) + '"';
				} else {
					if (_this.getAttribute('id') == 'security') {
						id_value = _this.value.trim();
						player += " " + _this.getAttribute('id') + "='" + id_value.replace(/'/g, '"') + "'";
					} else if (_this.getAttribute('id') == 'text') {
						exhibit_txt = _this.value.trim();

						for (var i in entity) {
							if (exhibit_txt.indexOf(i)) {
								exhibit_txt = exhibit_txt.replace(new RegExp(i, 'g'), entity[i]);
							}
						}

						player += ` ${_this.getAttribute('id')}="${exhibit_txt}"`;
					} else {
						player += ` ${_this.getAttribute('id')}="${_this.value.trim()}"`;
					}
				}
			}
		});

		player = createPlayerVersionTwo(player, option_attr, style_attr);

		if (state.type == 'playground' && document.querySelector('#xml_data')) {
			let xml_data = AH.select('#xml_data').value;
			xml_data = xml_data.replace(/\n/g, "#nl#").replace(/\r\n/g, "#nl#").replace(/\t/g, "#t#").replace(/\ \ /g, "#s#").replace(/\</g, "#lt#").replace(/\>/g, "#gt#");
			player += '><playcode style="display: none">' + xml_data.trim() + '</playcode></player>';
		} else if (state.category == 'snt' || state.category == 'seq') {
			let tag_attr = state.category == 'snt'
			? 'refid="' + state.snt + '"'
			: 'no="' + state.seq + '"';

			player = '<' + state.category + ' ' + tag_attr + '></' + state.category + '>';
		} else {
			player = player + '></player>';
		}

		var tinyInsertTimer = setTimeout(
			function () {
				AH.select('#' + tinyMCE.activeEditor.id + '_show').innerHTML = AH.select('#' + tinyMCE.activeEditor.id).innerHTML;
				clearTimeout(tinyInsertTimer);
			},
			200
		);

		if (value.obj) {
			value.obj.remove();
		}

		// Insert on submit
		tinyMCE.activeEditor.insertContent("#rmv" + player + "#rmv");

		//Prevent to remove editor content
		setTimeout(
			function () {
				var text = tinyMCE.activeEditor.getContent();
				var newText = text.replace(/#rmv/g, "");
				tinyMCE.activeEditor.setContent(newText);
			},
			100
		);

		let bookmark = value.bookmark ? value.bookmark : playerBookmark;

		bookmark
		? tinyMCE.activeEditor.selection.moveToBookmark(bookmark)
		: '';

		$$invalidate(0, state.open = false, state);
		$$invalidate(0, state.showData = false, state);
		$$invalidate(16, editorState.playerState = false, editorState);

		//Set tag in editor
		setTimeout(
			function () {
				renderPlayerFunc();
			},
			500
		);
	}

	function createPlayerVersionTwo(player, option_attr, style_attr) {
		if (option_attr != '') {
			player += " option='{" + option_attr + "}'";
			$$invalidate(0, state.isPlayerCheck = true, state);
		}

		if (style_attr != '') {
			player += " styles='{" + style_attr + "}'";
			$$invalidate(0, state.isPlayerCheck = false, state);
		}

		return player;
	}

	function validateItemId() {
		let msg = '';
		let input_id = document.querySelector('#showPlayerList #asset');

		let asset = input_id && input_id.getAttribute('is_multiple')
		? input_id.value.trim()
		: '';

		let is_valid = true;

		let updateTimer = setTimeout(
			function () {
				if (asset != '') {
					if (!!asset.match(/,(\s+)?$/) && !asset.match(/^[,]*$/)) {
						asset = asset.replace(/,(\s+)?$/, '');
						input_id.value = asset;
					}

					if (input_id.getAttribute('is_multiple') == 0) {
						if (asset.indexOf(',') > -1) {
							$$invalidate(0, state.msg = l$1.multi_err, state);
							is_valid = false;
						} else if (!asset.match('^[A-Za-z0-9]+$') || asset.length != 5) {
							$$invalidate(0, state.msg = l$1.invalid_id, state);
							is_valid = false;
						}
					}

					if (is_valid) {
						AI.activate(2);

						AH.ajax({
							url: baseUrl + 'editor/index.php?func=get_item_details',
							data: { item_id: asset, player: state.type }
						}).then(response => {
							if (response != 1) {
								asset = asset.split(',');
								let obj = JSON.parse(response);
								let item_id = '';
								let invalid_id = '';
								let content_type = state.content_type;
								let content_subtype = '';

								for (let i in obj) {
									content_subtype = state.content_subtype != ''
									? state.content_subtype
									: obj[i].content_subtype;

									if (content_type.indexOf(obj[i].content_type) === -1 || content_subtype.indexOf(obj[i].content_subtype) === -1) {
										item_id += item_id != ''
										? ', ' + obj[i].content_guid
										: obj[i].content_guid;
									}
								}

								if (Object.keys(obj).length != asset.length) {
									for (let i in asset) {
										if (!AI.isValid(obj[asset[i]])) {
											invalid_id += invalid_id != '' ? ', ' + asset[i] : asset[i];
										}
									}
								}

								if (item_id != '' || invalid_id != '') {
									msg = "Item id" + (item_id.indexOf(',') > -1 ? "s" : "") + " (" + item_id + ") " + (item_id.indexOf(',') > -1 ? "do" : "does") + " not match with the selected player type" + (invalid_id != '' ? " and " : ".");

									if (invalid_id != '') {
										msg = item_id != '' ? msg : '';
										msg += "Item id" + (invalid_id.indexOf(',') > -1 ? "s" : "") + " (" + invalid_id + ") " + (invalid_id.indexOf(',') > -1 ? "are" : "is") + " invalid.";
									}
								} else {
									handleSubmit();
								}
							} else {
								msg = l$1.invalid_id;
							}

							$$invalidate(0, state.msg = msg, state);
							AI.activate(0);
						}).catch(e => {
							AH.showmsg(l$1.unable_to_get);
							AI.activate(0);
						});
					}
				} else {
					//Check video intervals should not more than video duration
					if (state.type == 'video' && state.intervals) {
						validateVideoIterval();
					} else {
						$$invalidate(0, state.msg = msg, state);
						handleSubmit();
					}
				}

				clearTimeout(updateTimer);
			},
			100
		);
	}

	function validateVideoIterval() {
		let video_url = AH.select('.media_tag #asset').value;
		AH.empty('.get_video_duration');

		if (video_url != '') {
			if (video_url.indexOf("//s3.amazonaws.com/jigyaasa_content_stream/") == -1 && video_url.indexOf("https://") == -1 && video_url.indexOf("//player.vimeo.com") == -1) {
				video_url = '//s3.amazonaws.com/jigyaasa_content_stream/' + video_url;
			}

			AH.insert('.get_video_duration', '<video id="temp_video_tag" autoplay muted><source src="' + video_url + '" type="video/mp4"></video>', 'afterend');
			AI.activate(2);

			let video_iterval = 0,
				video = document.getElementById('temp_video_tag'),
				video_duration = 0;

			video.addEventListener('loadedmetadata', function getVideoDuration(event) {
				AH.selectAll('.stepplayertable .intervaltext').forEach(function (_this) {
					video_iterval += parseInt(_this.value);
				});

				video_duration = Math.ceil(video.duration);
				AH.empty('.get_video_duration');
				AI.activate(0);
				video.removeEventListener('loadedmetadata', getVideoDuration);

				if (video_iterval > video_duration) {
					$$invalidate(0, state.msg = l$1.interval_err + ' (' + video_duration + ' seconds)', state);
				} else {
					handleSubmit();
				}
			});

			video.addEventListener(
				'error',
				function playVideoError() {
					AI.showmsg(l$1.video_url_err);
					AI.activate(0);
					video.removeEventListener('error', playVideoError);
				},
				true
			);
		}
	}

	function handleTranscriptDialog() {
		if (!state.add_transcript) {
			if (window.editor.course == null) {
				AH.alert(l$1.load_course);
			} else if (AH.select('.media_tag #asset').value == '') {
				AH.alert(l$1.asset_not_empty);
			} else {
				AH.activate(2);
				let url = AH.select('.media_tag #asset').getAttribute('data-value');

				AH.ajax({
					url: baseUrl + 'utils/vtt_parser.php',
					data: {
						func: 'check_media',
						ajax: 1,
						video_url: url
					}
				}).then(
					response => {
						if (response.msg == 'Media already exist!') {
							AI.showmsg(l$1.vtt_exists);
							AH.select('.edit_transcript').disabled = response.vtt != 1;
							AH.select('.edit_transcript').setAttribute('guid', response.guid);
							AH.select('.media_tag #group_guids').value = response.guid;
							AH.trigger('.media_tag #group_guids', 'change');
						} else {
							$$invalidate(0, state.add_transcript = true, state);

							if (state.add_transcript) {
								setTimeout(
									function () {
										AH.select('#media_title').value = AH.select('.media_tag #title').value;
										AH.select('#media_url').value = AH.select('.media_tag #asset').getAttribute('data-value');
										AH.select('#courses').value = window.editor.course;
										updateVideoLink();
									},
									100
								);
							}
						}

						AH.activate(0);
					},
					'json'
				);
			}
		} else {
			$$invalidate(0, state.add_transcript = false, state);
		}
	}

	const writable_props = ['playerBookmark', 'editorState', 'value', 'renderPlayerFunc'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Player> was created with unknown prop '${key}'`);
	});

	function select_change_handler() {
		state.category = select_value(this);
		$$invalidate(0, state);
	}

	function playeritem_playerState_binding(value) {
		state = value;
		$$invalidate(0, state);
	}

	const click_handler = () => {
		editContent(false);
	};

	function dialog0_visible_binding(value) {
		if ($$self.$$.not_equal(state.open, value)) {
			state.open = value;
			$$invalidate(0, state);
		}
	}

	function dialog1_visible_binding(value) {
		if ($$self.$$.not_equal(state.delNode, value)) {
			state.delNode = value;
			$$invalidate(0, state);
		}
	}

	function dialog2_visible_binding(value) {
		if ($$self.$$.not_equal(state.add_transcript, value)) {
			state.add_transcript = value;
			$$invalidate(0, state);
		}
	}

	$$self.$$set = $$props => {
		if ('playerBookmark' in $$props) $$invalidate(17, playerBookmark = $$props.playerBookmark);
		if ('editorState' in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ('value' in $$props) $$invalidate(18, value = $$props.value);
		if ('renderPlayerFunc' in $$props) $$invalidate(19, renderPlayerFunc = $$props.renderPlayerFunc);
	};

	$$self.$capture_state = () => ({
		onMount,
		beforeUpdate,
		afterUpdate,
		Button,
		Dialog,
		writable,
		AH,
		Loader,
		PlayerItem,
		l: l$1,
		playerBookmark,
		editorState,
		value,
		renderPlayerFunc,
		itemArray,
		option,
		style,
		guid,
		category,
		mapping,
		listItem,
		transcript_hide,
		state,
		prevState,
		hdd,
		unsubscribe,
		onUpdate,
		didMount,
		getJsonAttrValue,
		correctLabelStyle,
		createSteptable,
		appendData,
		handleClose,
		handlePlayer,
		setInputState,
		insertImage,
		youtube_parser,
		setVideoAsset,
		validateVTT,
		addTranscript,
		openTranscript,
		updateVideoLink,
		updateVideoDuration,
		editContent,
		setContentType,
		listContent,
		addNewContent,
		searchTable,
		openEditorFrame,
		changeDeleteValues,
		handleSubmit,
		createPlayerVersionTwo,
		validateItemId,
		validateVideoIterval,
		swapJson,
		handleTranscriptDialog
	});

	$$self.$inject_state = $$props => {
		if ('playerBookmark' in $$props) $$invalidate(17, playerBookmark = $$props.playerBookmark);
		if ('editorState' in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ('value' in $$props) $$invalidate(18, value = $$props.value);
		if ('renderPlayerFunc' in $$props) $$invalidate(19, renderPlayerFunc = $$props.renderPlayerFunc);
		if ('itemArray' in $$props) itemArray = $$props.itemArray;
		if ('state' in $$props) $$invalidate(0, state = $$props.state);
		if ('prevState' in $$props) prevState = $$props.prevState;
		if ('hdd' in $$props) hdd = $$props.hdd;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		correctLabelStyle,
		createSteptable,
		handleClose,
		handlePlayer,
		setInputState,
		insertImage,
		setVideoAsset,
		addTranscript,
		editContent,
		listContent,
		addNewContent,
		searchTable,
		changeDeleteValues,
		validateItemId,
		handleTranscriptDialog,
		editorState,
		playerBookmark,
		value,
		renderPlayerFunc,
		select_change_handler,
		playeritem_playerState_binding,
		click_handler,
		dialog0_visible_binding,
		dialog1_visible_binding,
		dialog2_visible_binding
	];
}

class Player extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$g,
			create_fragment$g,
			safe_not_equal,
			{
				playerBookmark: 17,
				editorState: 16,
				value: 18,
				renderPlayerFunc: 19
			},
			add_css$e,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Player",
			options,
			id: create_fragment$g.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*playerBookmark*/ ctx[17] === undefined && !('playerBookmark' in props)) {
			console_1$3.warn("<Player> was created without expected prop 'playerBookmark'");
		}

		if (/*editorState*/ ctx[16] === undefined && !('editorState' in props)) {
			console_1$3.warn("<Player> was created without expected prop 'editorState'");
		}

		if (/*value*/ ctx[18] === undefined && !('value' in props)) {
			console_1$3.warn("<Player> was created without expected prop 'value'");
		}

		if (/*renderPlayerFunc*/ ctx[19] === undefined && !('renderPlayerFunc' in props)) {
			console_1$3.warn("<Player> was created without expected prop 'renderPlayerFunc'");
		}
	}

	get playerBookmark() {
		throw new Error("<Player>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set playerBookmark(value) {
		throw new Error("<Player>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<Player>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<Player>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Player>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Player>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderPlayerFunc() {
		throw new Error("<Player>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderPlayerFunc(value) {
		throw new Error("<Player>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Domain.svelte generated by Svelte v3.40.2 */

const { Object: Object_1$1, console: console_1$4 } = globals;
const file$h = "src\\Domain.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	return child_ctx;
}

// (450:8) {#if fromProject}
function create_if_block_5$2(ctx) {
	let ul;
	let li0;
	let a0;
	let t1;
	let li1;
	let a1;
	let initExamListner_action;
	let t3;
	let li2;
	let a2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			ul = element("ul");
			li0 = element("li");
			a0 = element("a");
			a0.textContent = "Coverage";
			t1 = space();
			li1 = element("li");
			a1 = element("a");
			a1.textContent = "Exam Objective";
			t3 = space();
			li2 = element("li");
			a2 = element("a");
			a2.textContent = "Refer Content";
			attr_dev(a0, "class", "nav-link active");
			attr_dev(a0, "data-bs-toggle", "pill");
			attr_dev(a0, "href", "#coverage");
			add_location(a0, file$h, 455, 20, 17065);
			attr_dev(li0, "class", "nav-item");
			add_location(li0, file$h, 454, 16, 17022);
			attr_dev(a1, "class", "nav-link exam-obj");
			attr_dev(a1, "data-bs-toggle", "pill");
			attr_dev(a1, "href", "#ExamTab");
			add_location(a1, file$h, 464, 20, 17381);
			attr_dev(li1, "class", "nav-item exam-obj");
			add_location(li1, file$h, 463, 16, 17329);
			attr_dev(a2, "class", "nav-link");
			attr_dev(a2, "data-bs-toggle", "pill");
			attr_dev(a2, "href", "#refer_content");
			add_location(a2, file$h, 474, 20, 17749);
			attr_dev(li2, "class", "nav-item");
			add_location(li2, file$h, 473, 16, 17706);
			attr_dev(ul, "class", "nav nav-pills");
			set_style(ul, "border-bottom", "2px solid #ebebeb", 1);
			add_location(ul, file$h, 450, 12, 16876);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			append_dev(ul, li0);
			append_dev(li0, a0);
			append_dev(ul, t1);
			append_dev(ul, li1);
			append_dev(li1, a1);
			append_dev(ul, t3);
			append_dev(ul, li2);
			append_dev(li2, a2);

			if (!mounted) {
				dispose = action_destroyer(initExamListner_action = /*initExamListner*/ ctx[8].call(null, a1, /*action*/ ctx[4]));
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$2.name,
		type: "if",
		source: "(450:8) {#if fromProject}",
		ctx
	});

	return block;
}

// (487:16) {#if isNew == 1}
function create_if_block_4$2(ctx) {
	let div;
	let label;
	let t1;
	let select;
	let select_disabled_value;
	let mounted;
	let dispose;
	let each_value_3 = /*courses*/ ctx[5];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			label = element("label");
			label.textContent = "Course";
			t1 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			set_style(label, "color", "rgba(0, 0, 0, 0.87)");
			set_style(label, "bottom", "15px");
			set_style(label, "width", "25%");
			attr_dev(label, "for", "course_select");
			add_location(label, file$h, 488, 24, 18266);
			attr_dev(select, "id", "course_select");
			set_style(select, "margin", "2px 24px");
			set_style(select, "width", "50%");
			select.disabled = select_disabled_value = /*url*/ ctx[7].get("todo_table") == 1 ? true : false;
			if (/*state*/ ctx[2].courses === void 0) add_render_callback(() => /*select_change_handler*/ ctx[29].call(select));
			add_location(select, file$h, 498, 24, 18665);
			attr_dev(div, "class", "ml-4 mb-4");
			add_location(div, file$h, 487, 20, 18217);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, label);
			append_dev(div, t1);
			append_dev(div, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*state*/ ctx[2].courses);

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler*/ ctx[29]),
					listen_dev(select, "change", /*handleCourseChange*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*courses*/ 32) {
				each_value_3 = /*courses*/ ctx[5];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			if (dirty[0] & /*state, courses*/ 36) {
				select_option(select, /*state*/ ctx[2].courses);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(487:16) {#if isNew == 1}",
		ctx
	});

	return block;
}

// (506:28) {#each courses as data}
function create_each_block_3(ctx) {
	let option;
	let t0_value = /*data*/ ctx[43].label + "";
	let t0;
	let t1;
	let option_value_value;
	let option_key_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = space();
			option.__value = option_value_value = /*data*/ ctx[43].value;
			option.value = option.__value;
			attr_dev(option, "key", option_key_value = /*data*/ ctx[43].key);
			add_location(option, file$h, 506, 32, 19098);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(506:28) {#each courses as data}",
		ctx
	});

	return block;
}

// (529:24) {#each items as data}
function create_each_block_2(ctx) {
	let option;
	let t0_value = /*data*/ ctx[43].label + "";
	let t0;
	let t1;
	let option_value_value;
	let option_key_value;
	let option_selected_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = space();
			option.__value = option_value_value = /*data*/ ctx[43].value;
			option.value = option.__value;
			attr_dev(option, "key", option_key_value = /*data*/ ctx[43].key);

			option.selected = option_selected_value = /*data*/ ctx[43].value == /*state*/ ctx[2].value
			? 'selected'
			: "";

			add_location(option, file$h, 529, 28, 20053);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*items*/ 8 && t0_value !== (t0_value = /*data*/ ctx[43].label + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*items*/ 8 && option_value_value !== (option_value_value = /*data*/ ctx[43].value)) {
				prop_dev(option, "__value", option_value_value);
				option.value = option.__value;
			}

			if (dirty[0] & /*items*/ 8 && option_key_value !== (option_key_value = /*data*/ ctx[43].key)) {
				attr_dev(option, "key", option_key_value);
			}

			if (dirty[0] & /*items, state, courses*/ 44 && option_selected_value !== (option_selected_value = /*data*/ ctx[43].value == /*state*/ ctx[2].value
			? 'selected'
			: "")) {
				prop_dev(option, "selected", option_selected_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(529:24) {#each items as data}",
		ctx
	});

	return block;
}

// (536:16) {#if state.showCoverage == true && fromProject && objectives && coverage_data}
function create_if_block_3$2(ctx) {
	let div;
	let label;
	let t2;
	let select;
	let select_test_value;
	let select_disabled_value;
	let mounted;
	let dispose;
	let each_value_1 = /*state*/ ctx[2].itemsCoverage;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			label = element("label");
			label.textContent = `Section${" "}`;
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(label, "class", "coverage_label");
			attr_dev(label, "for", "domain_select");
			add_location(label, file$h, 537, 24, 20490);
			set_style(select, "margin", "2px 24px");
			set_style(select, "width", "70%");
			attr_dev(select, "class", "domain_select");
			attr_dev(select, "id", "domain_select");
			attr_dev(select, "test", select_test_value = /*state*/ ctx[2].coverage_guid);
			select.disabled = select_disabled_value = /*url*/ ctx[7].get("todo_table") == 1 ? true : false;
			add_location(select, file$h, 543, 24, 20726);
			attr_dev(div, "class", "mt-3 ml-4");
			add_location(div, file$h, 536, 20, 20441);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, label);
			append_dev(div, t2);
			append_dev(div, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			if (!mounted) {
				dispose = listen_dev(select, "change", /*handleCoverageChange*/ ctx[11], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4) {
				each_value_1 = /*state*/ ctx[2].itemsCoverage;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*state, courses*/ 36 && select_test_value !== (select_test_value = /*state*/ ctx[2].coverage_guid)) {
				attr_dev(select, "test", select_test_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(536:16) {#if state.showCoverage == true && fromProject && objectives && coverage_data}",
		ctx
	});

	return block;
}

// (552:28) {#each state.itemsCoverage as data}
function create_each_block_1$1(ctx) {
	let option;
	let t0_value = /*data*/ ctx[43].label + "";
	let t0;
	let t1;
	let option_value_value;
	let option_key_value;
	let option_selected_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = space();
			option.__value = option_value_value = /*data*/ ctx[43].value;
			option.value = option.__value;
			attr_dev(option, "key", option_key_value = /*data*/ ctx[43].key);

			option.selected = option_selected_value = /*data*/ ctx[43].value == /*state*/ ctx[2].coverage_guid
			? 'selected'
			: "";

			add_location(option, file$h, 552, 32, 21225);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4 && t0_value !== (t0_value = /*data*/ ctx[43].label + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*state, courses*/ 36 && option_value_value !== (option_value_value = /*data*/ ctx[43].value)) {
				prop_dev(option, "__value", option_value_value);
				option.value = option.__value;
			}

			if (dirty[0] & /*state, courses*/ 36 && option_key_value !== (option_key_value = /*data*/ ctx[43].key)) {
				attr_dev(option, "key", option_key_value);
			}

			if (dirty[0] & /*state, courses*/ 36 && option_selected_value !== (option_selected_value = /*data*/ ctx[43].value == /*state*/ ctx[2].coverage_guid
			? 'selected'
			: "")) {
				prop_dev(option, "selected", option_selected_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(552:28) {#each state.itemsCoverage as data}",
		ctx
	});

	return block;
}

// (560:16) {#if (url.get("in_frame") == 1 && fromProject && smdata.content_type != "f") || url.get("todo_table") == 1 || url.get("from_coverage") == 1}
function create_if_block$f(ctx) {
	let div1;
	let div0;
	let t;
	let current;
	let if_block0 = window.objectives && window.coverage_data && create_if_block_2$4(ctx);
	let if_block1 = test_set["-4"] == 1 && create_if_block_1$4(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(div0, "class", "col-md-12");
			add_location(div0, file$h, 561, 24, 21790);
			attr_dev(div1, "class", "col-md-12 pl-0 mt-3 ml-2");
			add_location(div1, file$h, 560, 20, 21726);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div1, t);
			if (if_block1) if_block1.m(div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (window.objectives && window.coverage_data) if_block0.p(ctx, dirty);
			if (test_set["-4"] == 1) if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$f.name,
		type: "if",
		source: "(560:16) {#if (url.get(\\\"in_frame\\\") == 1 && fromProject && smdata.content_type != \\\"f\\\") || url.get(\\\"todo_table\\\") == 1 || url.get(\\\"from_coverage\\\") == 1}",
		ctx
	});

	return block;
}

// (563:28) {#if window.objectives && window.coverage_data}
function create_if_block_2$4(ctx) {
	let div;
	let label;
	let t2;
	let select;
	let select_disabled_value;
	let mounted;
	let dispose;
	let each_value = /*state*/ ctx[2].testSetList;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			label = element("label");
			label.textContent = `Test${" "}`;
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(label, "class", "coverage_label");
			attr_dev(label, "for", "test_select");
			set_style(label, "width", "14%");
			add_location(label, file$h, 564, 36, 21967);
			set_style(select, "width", "73%");
			attr_dev(select, "class", "domain_select");
			attr_dev(select, "id", "test_select");
			select.disabled = select_disabled_value = /*smdata*/ ctx[1].item == 36 ? true : false;
			add_location(select, file$h, 571, 36, 22331);
			add_location(div, file$h, 563, 32, 21924);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, label);
			append_dev(div, t2);
			append_dev(div, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			if (!mounted) {
				dispose = listen_dev(select, "change", /*handleTestChange*/ ctx[13], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4) {
				each_value = /*state*/ ctx[2].testSetList;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty[0] & /*smdata*/ 2 && select_disabled_value !== (select_disabled_value = /*smdata*/ ctx[1].item == 36 ? true : false)) {
				prop_dev(select, "disabled", select_disabled_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(563:28) {#if window.objectives && window.coverage_data}",
		ctx
	});

	return block;
}

// (579:40) {#each state.testSetList as data}
function create_each_block$2(ctx) {
	let option;
	let t0_value = /*data*/ ctx[43].label + "";
	let t0;
	let t1;
	let option_value_value;
	let option_key_value;
	let option_selected_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = space();
			option.__value = option_value_value = /*data*/ ctx[43].value;
			option.value = option.__value;
			attr_dev(option, "key", option_key_value = /*data*/ ctx[43].key);

			option.selected = option_selected_value = /*state*/ ctx[2].test.t == /*data*/ ctx[43].value
			? 'selected'
			: '';

			add_location(option, file$h, 579, 44, 22835);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4 && t0_value !== (t0_value = /*data*/ ctx[43].label + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*state, courses*/ 36 && option_value_value !== (option_value_value = /*data*/ ctx[43].value)) {
				prop_dev(option, "__value", option_value_value);
				option.value = option.__value;
			}

			if (dirty[0] & /*state, courses*/ 36 && option_key_value !== (option_key_value = /*data*/ ctx[43].key)) {
				attr_dev(option, "key", option_key_value);
			}

			if (dirty[0] & /*state, courses*/ 36 && option_selected_value !== (option_selected_value = /*state*/ ctx[2].test.t == /*data*/ ctx[43].value
			? 'selected'
			: '')) {
				prop_dev(option, "selected", option_selected_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(579:40) {#each state.testSetList as data}",
		ctx
	});

	return block;
}

// (588:24) {#if test_set["-4"] == 1}
function create_if_block_1$4(ctx) {
	let div;
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				id: "preAssessment",
				checked: /*state*/ ctx[2].test.p,
				color: "primary",
				disabled: /*smdata*/ ctx[1].item == 36 ? true : false,
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox.$on("click", /*updateTestValue*/ ctx[14].bind(this, "p"));

	const block = {
		c: function create() {
			div = element("div");
			create_component(checkbox.$$.fragment);
			attr_dev(div, "class", "col-md-12 preAssessment mt-3");
			add_location(div, file$h, 588, 28, 23334);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(checkbox, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty[0] & /*state*/ 4) checkbox_changes.checked = /*state*/ ctx[2].test.p;
			if (dirty[0] & /*smdata*/ 2) checkbox_changes.disabled = /*smdata*/ ctx[1].item == 36 ? true : false;

			if (dirty[1] & /*$$scope*/ 2097152) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(checkbox);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(588:24) {#if test_set[\\\"-4\\\"] == 1}",
		ctx
	});

	return block;
}

// (590:32) <Checkbox                                      id="preAssessment"                                      checked={state.test.p}                                      on:click={updateTestValue.bind(this, "p")}                                      color = "primary"                                      disabled={smdata.item == 36 ? true : false}                                  >
function create_default_slot_3$2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Pre Assessment";
			add_location(span, file$h, 596, 36, 23824);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(590:32) <Checkbox                                      id=\\\"preAssessment\\\"                                      checked={state.test.p}                                      on:click={updateTestValue.bind(this, \\\"p\\\")}                                      color = \\\"primary\\\"                                      disabled={smdata.item == 36 ? true : false}                                  >",
		ctx
	});

	return block;
}

// (443:0) <Dialog bind:visible={state.open} width="700" style="background: #fff; border-radius: 5px;">
function create_default_slot_2$3(ctx) {
	let h4;
	let div1;
	let div0;
	let t1;
	let div14;
	let t2;
	let div13;
	let div3;
	let t3;
	let div2;
	let label0;
	let t5;
	let select;
	let select_test_value;
	let select_disabled_value;
	let t6;
	let t7;
	let show_if = /*url*/ ctx[7].get("in_frame") == 1 && /*fromProject*/ ctx[6] && /*smdata*/ ctx[1].content_type != "f" || /*url*/ ctx[7].get("todo_table") == 1 || /*url*/ ctx[7].get("from_coverage") == 1;
	let t8;
	let div10;
	let div9;
	let div7;
	let div5;
	let div4;
	let span;
	let t9;
	let input0;
	let t10;
	let div6;
	let a;
	let t11;
	let a_href_value;
	let t12;
	let div8;
	let ul;
	let t13;
	let div12;
	let div11;
	let label1;
	let t15;
	let input1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*fromProject*/ ctx[6] && create_if_block_5$2(ctx);
	let if_block1 = /*isNew*/ ctx[0] == 1 && create_if_block_4$2(ctx);
	let each_value_2 = /*items*/ ctx[3];
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block2 = /*state*/ ctx[2].showCoverage == true && /*fromProject*/ ctx[6] && objectives && coverage_data && create_if_block_3$2(ctx);
	let if_block3 = show_if && create_if_block$f(ctx);

	const block = {
		c: function create() {
			h4 = element("h4");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Content Settings";
			t1 = space();
			div14 = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			div13 = element("div");
			div3 = element("div");
			if (if_block1) if_block1.c();
			t3 = space();
			div2 = element("div");
			label0 = element("label");
			label0.textContent = "Lesson";
			t5 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t6 = space();
			if (if_block2) if_block2.c();
			t7 = space();
			if (if_block3) if_block3.c();
			t8 = space();
			div10 = element("div");
			div9 = element("div");
			div7 = element("div");
			div5 = element("div");
			div4 = element("div");
			span = element("span");
			t9 = space();
			input0 = element("input");
			t10 = space();
			div6 = element("div");
			a = element("a");
			t11 = text("Create new");
			t12 = space();
			div8 = element("div");
			ul = element("ul");
			t13 = space();
			div12 = element("div");
			div11 = element("div");
			label1 = element("label");
			label1.textContent = "Case ID";
			t15 = space();
			input1 = element("input");
			add_location(div0, file$h, 445, 12, 16726);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file$h, 444, 8, 16668);
			attr_dev(h4, "class", "mt-1 font21 mb-4");
			add_location(h4, file$h, 443, 4, 16629);
			attr_dev(label0, "class", "coverage_label");
			attr_dev(label0, "for", "select_domain");
			add_location(label0, file$h, 514, 20, 19414);
			attr_dev(select, "id", "select_domain");
			set_style(select, "margin", "2px 24px");
			set_style(select, "width", "70%");
			attr_dev(select, "class", "domain_select");
			attr_dev(select, "test", select_test_value = /*state*/ ctx[2].value);
			select.disabled = select_disabled_value = /*url*/ ctx[7].get("todo_table") == 1 ? true : false;
			add_location(select, file$h, 520, 20, 19620);
			attr_dev(div2, "class", "ml-4");
			add_location(div2, file$h, 513, 16, 19374);
			attr_dev(div3, "id", "coverage");
			attr_dev(div3, "class", "tab-pane fade in active ");
			add_location(div3, file$h, 485, 12, 18109);
			attr_dev(span, "class", "icomoon-search-3 input-group-text");
			add_location(span, file$h, 608, 24, 24346);
			attr_dev(div4, "class", "input-group-prepend");
			add_location(div4, file$h, 607, 20, 24287);
			attr_dev(input0, "type", "search");
			attr_dev(input0, "class", "form-control");
			attr_dev(input0, "id", "search_text");
			attr_dev(input0, "placeholder", "Search");
			attr_dev(input0, "results", "");
			add_location(input0, file$h, 610, 20, 24451);
			attr_dev(div5, "class", "col-md-9 pr-0 search_box input-group");
			add_location(div5, file$h, 606, 20, 24215);
			attr_dev(a, "href", a_href_value = window.baseUrl + "educator/project/exam_objective_mapping.php?course_code=" + editor.course + "&from_myproject=1&exam_obj_h=1");
			attr_dev(a, "rel", "noreferrer");
			attr_dev(a, "target", "_blank");
			attr_dev(a, "class", "btn btn-primary");
			add_location(a, file$h, 619, 24, 24795);
			attr_dev(div6, "class", "col-md-3 pl-2 pr-0");
			add_location(div6, file$h, 618, 20, 24737);
			attr_dev(div7, "class", "row");
			add_location(div7, file$h, 605, 16, 24176);
			attr_dev(ul, "class", "parent_ul list-unstyled check-link");
			add_location(ul, file$h, 630, 20, 25404);
			attr_dev(div8, "class", "col-md-12 border overflow-y exam_obj_list relative");
			set_style(div8, "top", "5px");
			set_style(div8, "height", "250px");
			set_style(div8, "font-size", "14px");
			add_location(div8, file$h, 629, 16, 25271);
			attr_dev(div9, "class", "exam_modal_body npt");
			attr_dev(div9, "id", "exam_obj_body");
			add_location(div9, file$h, 604, 16, 24106);
			attr_dev(div10, "id", "ExamTab");
			attr_dev(div10, "class", "tab-pane fade");
			add_location(div10, file$h, 603, 12, 24048);
			attr_dev(label1, "for", "caseid");
			attr_dev(label1, "class", "coverage_label");
			add_location(label1, file$h, 636, 20, 25656);
			attr_dev(input1, "id", "caseid");
			attr_dev(input1, "type", "text");
			attr_dev(input1, "placeholder", "Enter Case ID");
			set_style(input1, "margin-left", "10px");
			set_style(input1, "height", "40px");
			set_style(input1, "width", "50%");
			attr_dev(input1, "class", "mt-3 domain_select");
			attr_dev(input1, "variant", "outlined");
			add_location(input1, file$h, 642, 20, 25858);
			attr_dev(div11, "id", "testcase");
			attr_dev(div11, "class", "ml-4");
			add_location(div11, file$h, 635, 16, 25602);
			attr_dev(div12, "id", "refer_content");
			attr_dev(div12, "class", "tab-pane fade");
			add_location(div12, file$h, 634, 12, 25538);
			attr_dev(div13, "class", "tab-content mt-2");
			set_style(div13, "height", "296px");
			add_location(div13, file$h, 484, 8, 18042);
			attr_dev(div14, "class", "overflow-hide");
			set_style(div14, "height", "328px");
			add_location(div14, file$h, 448, 4, 16786);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, div1);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div14, anchor);
			if (if_block0) if_block0.m(div14, null);
			append_dev(div14, t2);
			append_dev(div14, div13);
			append_dev(div13, div3);
			if (if_block1) if_block1.m(div3, null);
			append_dev(div3, t3);
			append_dev(div3, div2);
			append_dev(div2, label0);
			append_dev(div2, t5);
			append_dev(div2, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			append_dev(div3, t6);
			if (if_block2) if_block2.m(div3, null);
			append_dev(div3, t7);
			if (if_block3) if_block3.m(div3, null);
			append_dev(div13, t8);
			append_dev(div13, div10);
			append_dev(div10, div9);
			append_dev(div9, div7);
			append_dev(div7, div5);
			append_dev(div5, div4);
			append_dev(div4, span);
			append_dev(div5, t9);
			append_dev(div5, input0);
			append_dev(div7, t10);
			append_dev(div7, div6);
			append_dev(div6, a);
			append_dev(a, t11);
			append_dev(div9, t12);
			append_dev(div9, div8);
			append_dev(div8, ul);
			append_dev(div13, t13);
			append_dev(div13, div12);
			append_dev(div12, div11);
			append_dev(div11, label1);
			append_dev(div11, t15);
			append_dev(div11, input1);
			set_input_value(input1, /*state*/ ctx[2].caseid_val);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*handleChange*/ ctx[10], false, false, false),
					listen_dev(input1, "input", /*handleCaseID*/ ctx[12], false, false, false),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[30])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*fromProject*/ ctx[6]) if_block0.p(ctx, dirty);

			if (/*isNew*/ ctx[0] == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$2(ctx);
					if_block1.c();
					if_block1.m(div3, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*items, state*/ 12) {
				each_value_2 = /*items*/ ctx[3];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			if (!current || dirty[0] & /*state, courses*/ 36 && select_test_value !== (select_test_value = /*state*/ ctx[2].value)) {
				attr_dev(select, "test", select_test_value);
			}

			if (/*state*/ ctx[2].showCoverage == true && /*fromProject*/ ctx[6] && objectives && coverage_data) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_3$2(ctx);
					if_block2.c();
					if_block2.m(div3, t7);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*smdata*/ 2) show_if = /*url*/ ctx[7].get("in_frame") == 1 && /*fromProject*/ ctx[6] && /*smdata*/ ctx[1].content_type != "f" || /*url*/ ctx[7].get("todo_table") == 1 || /*url*/ ctx[7].get("from_coverage") == 1;

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*smdata*/ 2) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$f(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div3, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*state, courses*/ 36 && input1.value !== /*state*/ ctx[2].caseid_val) {
				set_input_value(input1, /*state*/ ctx[2].caseid_val);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div14);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(443:0) <Dialog bind:visible={state.open} width=\\\"700\\\" style=\\\"background: #fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (658:8) <Button               key = {"domainClose"}               unelevated={true}              outlined={true}              on:click={handleClose}               color="#ccc"          >
function create_default_slot_1$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(658:8) <Button               key = {\\\"domainClose\\\"}               unelevated={true}              outlined={true}              on:click={handleClose}               color=\\\"#ccc\\\"          >",
		ctx
	});

	return block;
}

// (667:8) <Button              key = {"domainSave"}              unelevated={true}              outlined={true}              classes="bg-primary text-white"              on:click={handleSave}              color="primary"          >
function create_default_slot$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Save");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(667:8) <Button              key = {\\\"domainSave\\\"}              unelevated={true}              outlined={true}              classes=\\\"bg-primary text-white\\\"              on:click={handleSave}              color=\\\"primary\\\"          >",
		ctx
	});

	return block;
}

// (657:4) 
function create_footer_slot$2(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				key: "domainClose",
				unelevated: true,
				outlined: true,
				color: "#ccc",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleClose*/ ctx[16]);

	button1 = new Button({
			props: {
				key: "domainSave",
				unelevated: true,
				outlined: true,
				classes: "bg-primary text-white",
				color: "primary",
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*handleSave*/ ctx[15]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file$h, 656, 4, 26373);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 2097152) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot$2.name,
		type: "slot",
		source: "(657:4) ",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let dialog;
	let updating_visible;
	let current;

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[31](value);
	}

	let dialog_props = {
		width: "700",
		style: "background: #fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot$2],
			default: [create_default_slot_2$3]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[2].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[2].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, 'visible', dialog_visible_binding));

	const block = {
		c: function create() {
			create_component(dialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const dialog_changes = {};

			if (dirty[0] & /*state, smdata, items, isNew*/ 15 | dirty[1] & /*$$scope*/ 2097152) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 4) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[2].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Domain', slots, []);
	let { guid } = $$props;
	let { selectedDomain } = $$props;
	let { selectedTest } = $$props;
	let { isNew } = $$props;
	let { smdata } = $$props;
	let { setCourse } = $$props;
	let { updateModule } = $$props;
	let { saveDomain } = $$props;
	let { closeDomainDialog } = $$props;
	let { domainToggle } = $$props;
	let { selectedObjective } = $$props;
	let { selectedCoverage } = $$props;
	let { editorState } = $$props;
	let { caseid_val } = $$props;
	let items = []; // array to store domains
	let action = "";
	let itemsCoverage = []; // coverage holder
	let testSetList = []; // test list
	let testType = []; // test type for list
	let courses = []; // courses
	let error = {};
	let state = {};
	let domainData = "";
	let fromProject = getQueryString("from_myproject") == 1 ? true : false;
	let url = AH.url();

	//State creation
	let hdd = writable({
		open: false,
		value: 0,
		domainArray: [],
		guid: "",
		coverage_guid: 0,
		itemsCoverage: [],
		courses: 0,
		showCoverage: true,
		mapping: false,
		disExercise: false,
		testSetList: [],
		caseid_val: "",
		test: {
			q: false,
			p: false,
			f: false,
			l: false,
			u: false,
			t: 0
		}
	});

	const unsubscribe = hdd.subscribe(item => {
		$$invalidate(2, state = item);
	});

	onMount(async () => {
		init();

		if (AH.get('domainData')) {
			domainData = AH.get('domainData')[editorState.guid];
			setDomainData();
		} else if (fromProject && url.get('router_guid')) {
			var router_guid = url.get('router_guid').split(',');
			router_guid = Object.assign({}, [...router_guid]);
			AH.activate(1);

			AH.ajax({
				url: baseUrl + "editor/index.php",
				data: {
					ajax: "1",
					course_code: editor.course,
					action: "get_domain",
					guids: router_guid,
					keys: 'e,d'
				}
			}).then(response => {
				response = JSON.parse(response);
				domainData = response[guid];
				AH.set('domainData', domainData);
				setDomainData();
				AH.activate(0);
			});
		}

		// Default Data for domain
		items.push({
			value: 0,
			key: "0",
			label: "Select Domain"
		});

		itemsCoverage.push({
			value: 0,
			key: "0",
			label: "Select Section"
		});

		courses.push({
			value: 0,
			key: "0",
			label: "Select Course"
		});

		if (!error['domains']) {
			let is_draft = '';

			for (let i in domains) {
				if (AH.isValid(domains[i].is_draft) && domains[i].is_draft == 1) {
					is_draft = ' (Unpublished)';
				}

				items.push({
					value: i,
					key: i,
					label: domains[i].f + " " + domains[i].snippet.replace(/&nbsp;|&\#160;/g, " ") + is_draft
				});
			}
		}

		if (!error['my_coursess']) {
			for (let i in my_courses) {
				courses.push({
					value: my_courses[i]["course_code"],
					key: i,
					label: my_courses[i]["course_name"] + " "
				});
			}
		}

		// Get data setting from create url
		if (url.get("from_educator") == 1 && url.get("in_frame") == 1 || url.get("from_coverage") == 1) {
			setTestValue("t", url.get("e"));
			setTestValue("p", url.get("d"));
		}

		var objTemp = state.test;
		objTemp["t"] = objTemp["t"] ? parseInt(objTemp["t"]) : 0;
		objTemp["p"] = objTemp["p"] ? parseInt(objTemp["p"]) : 0;
		testSetList = [];
		testSetList.push({ value: 0, key: "0", label: "Select Test" });

		if (test_set) {
			for (let i = 1; i <= test_set.p; i++) {
				testSetList.push({
					value: i,
					key: i,
					label: `Practice Test ${i}`
				});
			}

			if (test_set["-2"] == 1) {
				testSetList.push({
					value: -2,
					key: "-2",
					label: "Post Assessment"
				});
			}

			if (test_set["-13"] == 1) {
				testSetList.push({ value: -13, key: "-13", label: "Lab1" });
				testSetList.push({ value: -14, key: "-14", label: "Lab2" });
			}
		}

		testSetList.push({ value: -3, key: "-3", label: "Quiz" });
		testSetList.push({ value: -1, key: "-1", label: "Exercise" });

		//@ Vaibhav : for kc option at domain
		testSetList.push({
			value: -10,
			key: "-10",
			label: "Knowledge Check"
		});

		$$invalidate(2, state.test = objTemp, state);

		if (objTemp.t == "-13" || objTemp.t == "-14") {
			$$invalidate(2, state.disExercise = true, state);
		}

		$$invalidate(2, state.testSetList = testSetList, state);
		$$invalidate(2, state.itemsCoverage = itemsCoverage, state);

		// Get Item mapping
		AH.ajax({
			url: baseUrl + "editor/index.php",
			withUrl: true,
			data: {
				ajax: "1",
				course_code: editor.course,
				action: "get_items_mapping"
			}
		}).then(response => {
			$$invalidate(2, state.mapping = JSON.parse(response), state);
			setDomainMapping();
		});

		// Checking mapping of domain
		setTimeout(
			function () {
				if (state.mapping && guid) {
					setDomainMapping();
				} else if (content_domain) {
					let tempValue = content_domain.match(/[0-9]/) ? content_domain : 0;
					$$invalidate(2, state.value = tempValue, state);
					selectedDomain(tempValue);
				}

				selectedTest(state.test);
			},
			500
		);
	});

	function setDomainData() {
		if (domainData && url.get('router_guid')) {
			url.set("e", domainData["e"]);
			url.set("d", domainData["d"]);
			url.set("p1", domainData["p1"]);
			url.set("p2", domainData["p2"]);
			url.set('group_type', "q,u,f,c");
			url.set('in_frame', 1);
			setTestValue("t", domainData["e"]);
			setTestValue("p", domainData["d"]);
		} else if (url.get("from_educator") == 1 && url.get("in_frame") == 1 || url.get("from_coverage") == 1) {
			setTestValue("t", url.get("e"));
			setTestValue("p", url.get("d"));
		}
	}

	beforeUpdate(async () => {
		$$invalidate(2, state.caseid_val = caseid_val, state);

		if (domainToggle != state.open) {
			$$invalidate(2, state.open = domainToggle, state);

			if (state.test.t == -3 || state.test.t == -14 || state.test.t == -13 || state.test.t == -1) {
				setTimeout(
					function () {
						AH.selectAll(".preAssessment", 'hide');
					},
					100
				);
			} else {
				setTimeout(
					function () {
						AH.selectAll(".preAssessment", 'show');
					},
					100
				);
			}
		}
	});

	// Checking data recieved from php and parse
	function init() {
		error = {};

		try {
			domains = typeof domains == "object"
			? domains
			: JSON.parse(domains);
		} catch(err) {
			error['domains'] = err;
		}

		try {
			my_courses = typeof my_courses == "object"
			? my_courses
			: JSON.parse(my_courses);
		} catch(err) {
			error['my_courses'] = err;
		}

		try {
			objectives = typeof objectives == "object"
			? objectives
			: JSON.parse(objectives);
		} catch(e) {
			error['objectives'] = e;
		}

		try {
			coverage_data = typeof coverage_data == "object"
			? coverage_data
			: JSON.parse(coverage_data);
		} catch(e) {
			error['coverage_data'] = e;
		}

		try {
			test_set = test_set
			? typeof test_set == "object"
				? test_set
				: JSON.parse(test_set)
			: "";
		} catch(e) {
			error['test_set'] = e;
		}

		try {
			var isAssessment = isAssessment ? isAssessment.split(",") : null;

			if (isAssessment != null) {
				if (isAssessment[isAssessment.length - 1].length == 5) {
					var converge_parent = isAssessment[isAssessment.length - 1];
					isAssessment.splice(-1, 1);
				}
			}
		} catch(e) {
			error['isAssessment'] = e;
		}

		testType = {
			"-4": "p",
			"-2": "f",
			q: "q",
			u: "u",
			t: "t"
		};
	}

	// Handle Test change
	function setTestValue(type, value) {
		$$invalidate(2, state.test[type] = value, state);
	}

	// Event for Exam objective changes
	function initExamListner() {
		AH.listen(document.body, 'click', '.exam-obj', function (_this) {
			loadExamObjective && loadExamObjective(_this);
		});

		AH.listen(document.body, 'keyup', '#search_text', function (_this) {
			searchText && searchText(_this);
		});

		AH.listen(document.body, 'click', '#assign_exam_obj', function (_this) {
			assignObjective && assignObjective(_this);
		});

		AH.listen(document.body, 'click', '.exam_obj_radio', function (_this) {
			selectObjRadio && selectObjRadio(_this);
		});
	}

	// Handle domain data update
	function setDomainMapping() {
		if (state.mapping[guid]) {
			$$invalidate(2, state.value = state.mapping[guid], state);
			selectedDomain(state.mapping[guid]);

			try {
				if (objectives) {
					if (objectives[state.mapping[guid]]) {
						let obj = objectives[state.mapping[guid]].toString().split(",");

						for (let i = 0; i < obj.length - 1; i++) {
							let seq_no = coverage_data[obj[i]].f;

							itemsCoverage.push({
								value: obj[i],
								key: i,
								label: seq_no + " " + coverage_data[obj[i]].snippet.replace(/&nbsp;|&\#160;/g, " ")
							});
						}
					}

					$$invalidate(2, state.itemsCoverage = itemsCoverage, state);
					$$invalidate(2, state.coverage_guid = 0, state);
				}
			} catch(e) {
				console.warn(e);
			}

			if (typeof converge_parent != "undefined") {
				$$invalidate(2, state.coverage_guid = converge_parent, state);
			}
		} else {
			$$invalidate(2, state.value = 0, state);
			selectedDomain(0);
		}

		if ((url.get("p1") || url.get("p2")) && fromProject) {
			setTimeout(
				function () {
					try {
						if (objectives && typeof state.mapping[guid] === "undefined") {
							if (objectives[url.get("p1")]) {
								let obj = objectives[url.get("p1")].toString().split(",");

								for (let i = 0; i < obj.length - 1; i++) {
									itemsCoverage.push({
										value: obj[i],
										key: i,
										label: coverage_data[obj[i]].snippet.replace(/&nbsp;|&\#160;/g, " ")
									});
								}
							}
						}

						$$invalidate(2, state.itemsCoverage = itemsCoverage, state);
						$$invalidate(2, state.value = url.get("p1"), state);
						$$invalidate(2, state.coverage_guid = url.get("p2"), state);
						selectedDomain(url.get("p1"));
						selectedCoverage(url.get("p2"));
					} catch(e) {
						console.log(e);
					}
				},
				100
			);
		}
	}

	// Handle course change from list
	function handleCourseChange(event) {
		let course = event.target.value;
		$$invalidate(2, state.courses = course, state);
		setCourse(course);

		try {
			AH.activate(1);

			AH.ajax({
				url: baseUrl + "editor/index.php",
				withUrl: true,
				data: {
					ajax: "1",
					course_code: course,
					action: "get_new_coverage"
				}
			}).then(response => {
				try {
					var chapters = JSON.parse(response);
					$$invalidate(3, items.length = 0, items);

					items.push({
						value: 0,
						key: "0",
						label: "Select Section"
					});

					for (let i in chapters[0]) {
						items.push({
							value: i,
							key: i,
							label: chapters[0][i].f + " " + chapters[0][i].snippet.replace(/&nbsp;|&\#160;/g, " ")
						});
					}

					$$invalidate(2, state.objectives = chapters[1], state);
					$$invalidate(2, state.coverage = chapters[2], state);
					$$invalidate(2, state.value = items, state);
					AH.activate(0);
				} catch(e) {
					console.log("Coverage no found");
				}
			});
		} catch(e) {
			console.log(e);
		}
	}

	// Handle Objective change from list
	function handleChange(event) {
		let value = event.target.value;
		$$invalidate(2, state.value = value, state);
		console.log('state.value', state.value);

		try {
			if (objectives || state.objectives) {
				if (state.objectives) {
					objectives = state.objectives;
					coverage_data = state.coverage;
				}

				itemsCoverage.length = 0;

				itemsCoverage.push({
					value: 0,
					key: "0",
					label: "Select Section"
				});

				if (objectives[value]) {
					let obj = objectives[value].toString().split(",");

					for (let i = 0; i < obj.length - 1; i++) {
						let seq_no = coverage_data[obj[i]].f;

						itemsCoverage.push({
							value: obj[i],
							key: i,
							label: seq_no + " " + coverage_data[obj[i]].snippet.replace(/&nbsp;|&\#160;/g, " ")
						});
					}
				}

				$$invalidate(2, state.itemsCoverage = itemsCoverage, state);
				$$invalidate(2, state.coverage_guid = 0, state);
			}
		} catch(e) {
			console.log(e);
		}

		AH.set('save_item', true);
	}

	// Handle coverage data change
	function handleCoverageChange(event) {
		let value = event.target.value;
		$$invalidate(2, state.coverage_guid = value, state);
		AH.set('save_item', true);
	}

	// Handle case Id change from domain dialog
	function handleCaseID(e) {
		$$invalidate(2, state.caseid_val = e.target.value, state);
		updateModule('caseid_val', e.target.value);
	}

	// Handle Test change from list
	function handleTestChange(event) {
		let value = event.target.value;
		let objTemp = state.test;
		objTemp["t"] = value;

		if (value == -3 || value == -14 || value == -13 || value == -1) {
			objTemp["p"] = false;
			AH.selectAll(".preAssessment", 'hide');
		} else {
			AH.selectAll(".preAssessment", 'show');
		}

		$$invalidate(2, state.test = objTemp, state);
		$$invalidate(2, state.disExercise = value == -13 || value == -14 ? true : false, state);
	}

	// Update json for test
	function updateTestValue(type) {
		let objTemp = state.test;
		objTemp[type] = +!objTemp[type];
		$$invalidate(2, state.test = objTemp, state);
	}

	// check saving
	function handleSave() {
		handleClose();

		//set state of editor
		$$invalidate(17, editorState.exam_objective_mapping_save = 1, editorState);

		setTimeout(
			function () {
				AH.activate(1);

				if (from_coverage) {
					// for add new content
					saveDomain(1);
				} else {
					saveDomain();
				}
			},
			100
		);
	}

	// Handle Close action
	function handleClose() {
		try {
			closeDomainDialog(false);
			selectedDomain(state.value);

			if (fromProject && objectives && coverage_data) {
				selectedCoverage(state.coverage_guid ? state.coverage_guid : state.value);
			}

			state.test ? selectedTest(state.test) : null;
			let tag_list = [];

			AH.select('input[name="exam_obj[]"]', 'checked').forEach(function (_this, i) {
				tag_list[i] = _this.value;
			});

			selectedObjective(tag_list.toString());
		} catch(e) {
			console.log(e);
		}
	}

	const writable_props = [
		'guid',
		'selectedDomain',
		'selectedTest',
		'isNew',
		'smdata',
		'setCourse',
		'updateModule',
		'saveDomain',
		'closeDomainDialog',
		'domainToggle',
		'selectedObjective',
		'selectedCoverage',
		'editorState',
		'caseid_val'
	];

	Object_1$1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<Domain> was created with unknown prop '${key}'`);
	});

	function select_change_handler() {
		state.courses = select_value(this);
		$$invalidate(2, state);
		$$invalidate(5, courses);
	}

	function input1_input_handler() {
		state.caseid_val = this.value;
		$$invalidate(2, state);
		$$invalidate(5, courses);
	}

	function dialog_visible_binding(value) {
		if ($$self.$$.not_equal(state.open, value)) {
			state.open = value;
			$$invalidate(2, state);
		}
	}

	$$self.$$set = $$props => {
		if ('guid' in $$props) $$invalidate(18, guid = $$props.guid);
		if ('selectedDomain' in $$props) $$invalidate(19, selectedDomain = $$props.selectedDomain);
		if ('selectedTest' in $$props) $$invalidate(20, selectedTest = $$props.selectedTest);
		if ('isNew' in $$props) $$invalidate(0, isNew = $$props.isNew);
		if ('smdata' in $$props) $$invalidate(1, smdata = $$props.smdata);
		if ('setCourse' in $$props) $$invalidate(21, setCourse = $$props.setCourse);
		if ('updateModule' in $$props) $$invalidate(22, updateModule = $$props.updateModule);
		if ('saveDomain' in $$props) $$invalidate(23, saveDomain = $$props.saveDomain);
		if ('closeDomainDialog' in $$props) $$invalidate(24, closeDomainDialog = $$props.closeDomainDialog);
		if ('domainToggle' in $$props) $$invalidate(25, domainToggle = $$props.domainToggle);
		if ('selectedObjective' in $$props) $$invalidate(26, selectedObjective = $$props.selectedObjective);
		if ('selectedCoverage' in $$props) $$invalidate(27, selectedCoverage = $$props.selectedCoverage);
		if ('editorState' in $$props) $$invalidate(17, editorState = $$props.editorState);
		if ('caseid_val' in $$props) $$invalidate(28, caseid_val = $$props.caseid_val);
	};

	$$self.$capture_state = () => ({
		onMount,
		beforeUpdate,
		Button,
		Dialog,
		Checkbox,
		writable,
		AH,
		guid,
		selectedDomain,
		selectedTest,
		isNew,
		smdata,
		setCourse,
		updateModule,
		saveDomain,
		closeDomainDialog,
		domainToggle,
		selectedObjective,
		selectedCoverage,
		editorState,
		caseid_val,
		items,
		action,
		itemsCoverage,
		testSetList,
		testType,
		courses,
		error,
		state,
		domainData,
		fromProject,
		url,
		hdd,
		unsubscribe,
		setDomainData,
		init,
		setTestValue,
		initExamListner,
		setDomainMapping,
		handleCourseChange,
		handleChange,
		handleCoverageChange,
		handleCaseID,
		handleTestChange,
		updateTestValue,
		handleSave,
		handleClose
	});

	$$self.$inject_state = $$props => {
		if ('guid' in $$props) $$invalidate(18, guid = $$props.guid);
		if ('selectedDomain' in $$props) $$invalidate(19, selectedDomain = $$props.selectedDomain);
		if ('selectedTest' in $$props) $$invalidate(20, selectedTest = $$props.selectedTest);
		if ('isNew' in $$props) $$invalidate(0, isNew = $$props.isNew);
		if ('smdata' in $$props) $$invalidate(1, smdata = $$props.smdata);
		if ('setCourse' in $$props) $$invalidate(21, setCourse = $$props.setCourse);
		if ('updateModule' in $$props) $$invalidate(22, updateModule = $$props.updateModule);
		if ('saveDomain' in $$props) $$invalidate(23, saveDomain = $$props.saveDomain);
		if ('closeDomainDialog' in $$props) $$invalidate(24, closeDomainDialog = $$props.closeDomainDialog);
		if ('domainToggle' in $$props) $$invalidate(25, domainToggle = $$props.domainToggle);
		if ('selectedObjective' in $$props) $$invalidate(26, selectedObjective = $$props.selectedObjective);
		if ('selectedCoverage' in $$props) $$invalidate(27, selectedCoverage = $$props.selectedCoverage);
		if ('editorState' in $$props) $$invalidate(17, editorState = $$props.editorState);
		if ('caseid_val' in $$props) $$invalidate(28, caseid_val = $$props.caseid_val);
		if ('items' in $$props) $$invalidate(3, items = $$props.items);
		if ('action' in $$props) $$invalidate(4, action = $$props.action);
		if ('itemsCoverage' in $$props) itemsCoverage = $$props.itemsCoverage;
		if ('testSetList' in $$props) testSetList = $$props.testSetList;
		if ('testType' in $$props) testType = $$props.testType;
		if ('courses' in $$props) $$invalidate(5, courses = $$props.courses);
		if ('error' in $$props) error = $$props.error;
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
		if ('domainData' in $$props) domainData = $$props.domainData;
		if ('fromProject' in $$props) $$invalidate(6, fromProject = $$props.fromProject);
		if ('url' in $$props) $$invalidate(7, url = $$props.url);
		if ('hdd' in $$props) hdd = $$props.hdd;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*state*/ 4) {
			 console.log('state.value', state.value);
		}
	};

	return [
		isNew,
		smdata,
		state,
		items,
		action,
		courses,
		fromProject,
		url,
		initExamListner,
		handleCourseChange,
		handleChange,
		handleCoverageChange,
		handleCaseID,
		handleTestChange,
		updateTestValue,
		handleSave,
		handleClose,
		editorState,
		guid,
		selectedDomain,
		selectedTest,
		setCourse,
		updateModule,
		saveDomain,
		closeDomainDialog,
		domainToggle,
		selectedObjective,
		selectedCoverage,
		caseid_val,
		select_change_handler,
		input1_input_handler,
		dialog_visible_binding
	];
}

class Domain extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$h,
			create_fragment$h,
			safe_not_equal,
			{
				guid: 18,
				selectedDomain: 19,
				selectedTest: 20,
				isNew: 0,
				smdata: 1,
				setCourse: 21,
				updateModule: 22,
				saveDomain: 23,
				closeDomainDialog: 24,
				domainToggle: 25,
				selectedObjective: 26,
				selectedCoverage: 27,
				editorState: 17,
				caseid_val: 28
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Domain",
			options,
			id: create_fragment$h.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*guid*/ ctx[18] === undefined && !('guid' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'guid'");
		}

		if (/*selectedDomain*/ ctx[19] === undefined && !('selectedDomain' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'selectedDomain'");
		}

		if (/*selectedTest*/ ctx[20] === undefined && !('selectedTest' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'selectedTest'");
		}

		if (/*isNew*/ ctx[0] === undefined && !('isNew' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'isNew'");
		}

		if (/*smdata*/ ctx[1] === undefined && !('smdata' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'smdata'");
		}

		if (/*setCourse*/ ctx[21] === undefined && !('setCourse' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'setCourse'");
		}

		if (/*updateModule*/ ctx[22] === undefined && !('updateModule' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'updateModule'");
		}

		if (/*saveDomain*/ ctx[23] === undefined && !('saveDomain' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'saveDomain'");
		}

		if (/*closeDomainDialog*/ ctx[24] === undefined && !('closeDomainDialog' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'closeDomainDialog'");
		}

		if (/*domainToggle*/ ctx[25] === undefined && !('domainToggle' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'domainToggle'");
		}

		if (/*selectedObjective*/ ctx[26] === undefined && !('selectedObjective' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'selectedObjective'");
		}

		if (/*selectedCoverage*/ ctx[27] === undefined && !('selectedCoverage' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'selectedCoverage'");
		}

		if (/*editorState*/ ctx[17] === undefined && !('editorState' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'editorState'");
		}

		if (/*caseid_val*/ ctx[28] === undefined && !('caseid_val' in props)) {
			console_1$4.warn("<Domain> was created without expected prop 'caseid_val'");
		}
	}

	get guid() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set guid(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedDomain() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedDomain(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedTest() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedTest(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isNew() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isNew(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smdata() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smdata(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setCourse() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setCourse(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateModule() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set updateModule(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get saveDomain() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set saveDomain(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeDomainDialog() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeDomainDialog(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get domainToggle() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set domainToggle(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedObjective() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedObjective(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedCoverage() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedCoverage(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get caseid_val() {
		throw new Error("<Domain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set caseid_val(value) {
		throw new Error("<Domain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\VersionControl.svelte generated by Svelte v3.40.2 */

const { Object: Object_1$2, console: console_1$5 } = globals;
const file$i = "src\\VersionControl.svelte";

// (246:12) {:else}
function create_else_block$4(ctx) {
	let div1;
	let center;
	let loader;
	let t;
	let div0;
	let current;

	loader = new Loader({
			props: {
				msg: "Fetching version history",
				size: 70
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			center = element("center");
			create_component(loader.$$.fragment);
			t = space();
			div0 = element("div");
			attr_dev(center, "id", "replaced_diff_loader");
			attr_dev(center, "class", "pt-5");
			add_location(center, file$i, 247, 20, 12138);
			attr_dev(div0, "id", "changesData");
			attr_dev(div0, "class", "col-12 mt-4");
			add_location(div0, file$i, 250, 20, 12314);
			attr_dev(div1, "id", "modifiedData");
			attr_dev(div1, "class", "row col-12 mt-4 m-0 p-0 border-muted rounded border");
			set_style(div1, "height", "267px");
			set_style(div1, "overflow", "overlay");
			add_location(div1, file$i, 246, 16, 11991);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, center);
			mount_component(loader, center, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(246:12) {:else}",
		ctx
	});

	return block;
}

// (185:12) {#if state.tableData && state.tableData.length > 0}
function create_if_block$g(ctx) {
	let div7;
	let div6;
	let div3;
	let div0;
	let b;

	let t0_value = (/*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].ulist
	? Object.values(/*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].ulist).join(', ')
	: /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].name) + "";

	let t0;
	let t1;
	let br;
	let t2;
	let t3_value = new Date(/*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date_format + " UTC").toString().replace(/GMT.*/g, "") + "";
	let t3;
	let t4;
	let div2;
	let button0;
	let i0;
	let button0_class_value;
	let button0_data_version_value;
	let t5;
	let div1;
	let p;
	let t6_value = /*state*/ ctx[1].clicks + 1 + "";
	let t6;
	let t7;
	let t8_value = /*state*/ ctx[1].tableData.length + "";
	let t8;
	let t9;
	let button1;
	let i1;
	let button1_class_value;
	let button1_data_version_value;
	let t10;
	let button2;
	let span;
	let t11;
	let button2_class_value;
	let button2_data_version_value;
	let t12;
	let button3;
	let i2;
	let t13;
	let button3_data_version_value;
	let t14;
	let div5;
	let center0;
	let loader0;
	let t15;
	let div4;
	let center1;
	let loader1;
	let current;
	let mounted;
	let dispose;

	loader0 = new Loader({
			props: {
				msg: "Fetching next version history",
				size: 70
			},
			$$inline: true
		});

	loader1 = new Loader({
			props: { msg: "Preparing Layout", size: 70 },
			$$inline: true
		});

	const block = {
		c: function create() {
			div7 = element("div");
			div6 = element("div");
			div3 = element("div");
			div0 = element("div");
			b = element("b");
			t0 = text(t0_value);
			t1 = space();
			br = element("br");
			t2 = space();
			t3 = text(t3_value);
			t4 = space();
			div2 = element("div");
			button0 = element("button");
			i0 = element("i");
			t5 = space();
			div1 = element("div");
			p = element("p");
			t6 = text(t6_value);
			t7 = text(" / ");
			t8 = text(t8_value);
			t9 = space();
			button1 = element("button");
			i1 = element("i");
			t10 = space();
			button2 = element("button");
			span = element("span");
			t11 = text(" Restore");
			t12 = space();
			button3 = element("button");
			i2 = element("i");
			t13 = text(" Source Code");
			t14 = space();
			div5 = element("div");
			center0 = element("center");
			create_component(loader0.$$.fragment);
			t15 = space();
			div4 = element("div");
			center1 = element("center");
			create_component(loader1.$$.fragment);
			attr_dev(b, "class", "text-dark");
			add_location(b, file$i, 189, 32, 7914);
			add_location(br, file$i, 190, 32, 8113);
			attr_dev(div0, "class", "col-5 m-0 pl-2 pr-2");
			add_location(div0, file$i, 188, 28, 7847);
			attr_dev(i0, "class", "icomoon-24px-previous");
			set_style(i0, "font-size", "12px");
			add_location(i0, file$i, 202, 36, 8970);
			attr_dev(button0, "data-bs-toggle", "tooltip");
			attr_dev(button0, "id", "prev_btn");
			attr_dev(button0, "title", "Previous");

			attr_dev(button0, "class", button0_class_value = /*state*/ ctx[1].clicks <= 0
			? "btn btn-light mr-1 disabled"
			: "btn btn-light");

			attr_dev(button0, "data-version", button0_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date);
			add_location(button0, file$i, 194, 32, 8400);
			attr_dev(p, "class", "font16");
			add_location(p, file$i, 205, 36, 9215);
			attr_dev(div1, "class", "relative text-right m-2 d-inline-block");
			set_style(div1, "top", "3px");
			add_location(div1, file$i, 204, 32, 9108);
			attr_dev(i1, "class", "icomoon-24px-next");
			set_style(i1, "font-size", "12px");
			add_location(i1, file$i, 214, 36, 9901);
			attr_dev(button1, "data-bs-toggle", "tooltip");
			attr_dev(button1, "title", "Next");

			attr_dev(button1, "class", button1_class_value = /*state*/ ctx[1].clicks <= /*state*/ ctx[1].tableData.length - 2
			? "btn btn-light mr-1"
			: "btn btn-light mr-1 disabled");

			attr_dev(button1, "data-version", button1_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date);
			add_location(button1, file$i, 207, 32, 9356);
			attr_dev(span, "class", "icomoon-new-tab-2");
			set_style(span, "font-size", "12px");
			set_style(span, "text-align", "center");
			add_location(span, file$i, 223, 36, 10558);
			attr_dev(button2, "data-bs-toggle", "tooltip");
			attr_dev(button2, "title", "Restore this Version");
			attr_dev(button2, "type", "button");

			attr_dev(button2, "class", button2_class_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].name
			? "btn edit_version btn-light in_draft mr-1"
			: "btn edit_version btn-light mr-1");

			attr_dev(button2, "data-version", button2_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date);
			add_location(button2, file$i, 216, 32, 10036);
			attr_dev(i2, "class", "icomoon-embed");
			set_style(i2, "font-size", "12px");
			set_style(i2, "text-align", "center");
			add_location(i2, file$i, 231, 36, 11093);
			attr_dev(button3, "data-bs-toggle", "tooltip");
			attr_dev(button3, "title", "Source Code");
			attr_dev(button3, "class", "btn get-diff btn-light");
			attr_dev(button3, "data-version", button3_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date);
			add_location(button3, file$i, 225, 32, 10727);
			attr_dev(div2, "class", "col-7 m-0 pl-2 pr-0 text-right");
			add_location(div2, file$i, 193, 28, 8322);
			attr_dev(div3, "class", "row col-12 m-0 p-0");
			add_location(div3, file$i, 187, 24, 7785);
			attr_dev(center0, "id", "replaced_diff_loader");
			attr_dev(center0, "class", "pt-5");
			set_style(center0, "display", "none");
			add_location(center0, file$i, 236, 28, 11470);
			add_location(center1, file$i, 240, 32, 11773);
			attr_dev(div4, "id", "changesData");
			attr_dev(div4, "class", "col-12 mt-4");
			add_location(div4, file$i, 239, 28, 11697);
			attr_dev(div5, "id", "modifiedData");
			attr_dev(div5, "class", "row col-12 mt-4 m-0 p-0 border-muted rounded border");
			set_style(div5, "height", "267px");
			set_style(div5, "overflow", "overlay");
			add_location(div5, file$i, 235, 24, 11315);
			attr_dev(div6, "class", "row m-0 diff-table");
			add_location(div6, file$i, 186, 20, 7727);
			attr_dev(div7, "key", "one");
			add_location(div7, file$i, 185, 16, 7690);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, div3);
			append_dev(div3, div0);
			append_dev(div0, b);
			append_dev(b, t0);
			append_dev(div0, t1);
			append_dev(div0, br);
			append_dev(div0, t2);
			append_dev(div0, t3);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div2, button0);
			append_dev(button0, i0);
			append_dev(div2, t5);
			append_dev(div2, div1);
			append_dev(div1, p);
			append_dev(p, t6);
			append_dev(p, t7);
			append_dev(p, t8);
			append_dev(div2, t9);
			append_dev(div2, button1);
			append_dev(button1, i1);
			append_dev(div2, t10);
			append_dev(div2, button2);
			append_dev(button2, span);
			append_dev(button2, t11);
			append_dev(div2, t12);
			append_dev(div2, button3);
			append_dev(button3, i2);
			append_dev(button3, t13);
			append_dev(div6, t14);
			append_dev(div6, div5);
			append_dev(div5, center0);
			mount_component(loader0, center0, null);
			append_dev(div5, t15);
			append_dev(div5, div4);
			append_dev(div4, center1);
			mount_component(loader1, center1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(
						button0,
						"click",
						function () {
							if (is_function(/*decreaseItem*/ ctx[4].bind(this, /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks - 1]))) /*decreaseItem*/ ctx[4].bind(this, /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks - 1]).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						button1,
						"click",
						function () {
							if (is_function(/*incrementItem*/ ctx[3].bind(this, /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks + 1]))) /*incrementItem*/ ctx[3].bind(this, /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks + 1]).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if ((!current || dirty & /*state*/ 2) && t0_value !== (t0_value = (/*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].ulist
			? Object.values(/*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].ulist).join(', ')
			: /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].name) + "")) set_data_dev(t0, t0_value);

			if ((!current || dirty & /*state*/ 2) && t3_value !== (t3_value = new Date(/*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date_format + " UTC").toString().replace(/GMT.*/g, "") + "")) set_data_dev(t3, t3_value);

			if (!current || dirty & /*state*/ 2 && button0_class_value !== (button0_class_value = /*state*/ ctx[1].clicks <= 0
			? "btn btn-light mr-1 disabled"
			: "btn btn-light")) {
				attr_dev(button0, "class", button0_class_value);
			}

			if (!current || dirty & /*state*/ 2 && button0_data_version_value !== (button0_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date)) {
				attr_dev(button0, "data-version", button0_data_version_value);
			}

			if ((!current || dirty & /*state*/ 2) && t6_value !== (t6_value = /*state*/ ctx[1].clicks + 1 + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty & /*state*/ 2) && t8_value !== (t8_value = /*state*/ ctx[1].tableData.length + "")) set_data_dev(t8, t8_value);

			if (!current || dirty & /*state*/ 2 && button1_class_value !== (button1_class_value = /*state*/ ctx[1].clicks <= /*state*/ ctx[1].tableData.length - 2
			? "btn btn-light mr-1"
			: "btn btn-light mr-1 disabled")) {
				attr_dev(button1, "class", button1_class_value);
			}

			if (!current || dirty & /*state*/ 2 && button1_data_version_value !== (button1_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date)) {
				attr_dev(button1, "data-version", button1_data_version_value);
			}

			if (!current || dirty & /*state*/ 2 && button2_class_value !== (button2_class_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].name
			? "btn edit_version btn-light in_draft mr-1"
			: "btn edit_version btn-light mr-1")) {
				attr_dev(button2, "class", button2_class_value);
			}

			if (!current || dirty & /*state*/ 2 && button2_data_version_value !== (button2_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date)) {
				attr_dev(button2, "data-version", button2_data_version_value);
			}

			if (!current || dirty & /*state*/ 2 && button3_data_version_value !== (button3_data_version_value = /*state*/ ctx[1].tableData[/*state*/ ctx[1].clicks].version_date)) {
				attr_dev(button3, "data-version", button3_data_version_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div7);
			destroy_component(loader0);
			destroy_component(loader1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$g.name,
		type: "if",
		source: "(185:12) {#if state.tableData && state.tableData.length > 0}",
		ctx
	});

	return block;
}

// (170:0) <Dialog bind:visible={state.open} style="width: 75%; background-color:#fff; border-radius: 5px;">
function create_default_slot_2$4(ctx) {
	let h4;
	let t0_value = /*l*/ ctx[0].version_control + "";
	let t0;
	let t1;
	let div4;
	let div0;
	let t2;
	let center0;
	let div1;
	let t3_value = /*l*/ ctx[0].getting_diff + "";
	let t3;
	let t4;
	let center1;
	let div2;
	let t5_value = /*l*/ ctx[0].getting_list + "";
	let t5;
	let t6;
	let div3;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$g, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*state*/ ctx[1].tableData && /*state*/ ctx[1].tableData.length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			h4 = element("h4");
			t0 = text(t0_value);
			t1 = space();
			div4 = element("div");
			div0 = element("div");
			t2 = space();
			center0 = element("center");
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			center1 = element("center");
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			div3 = element("div");
			if_block.c();
			attr_dev(h4, "class", "mt-0 font21 mb-5");
			add_location(h4, file$i, 170, 4, 7069);
			attr_dev(div0, "id", "show_diff");
			attr_dev(div0, "class", "mt-xl");
			set_style(div0, "display", "none");
			set_style(div0, "min-height", "200px");
			add_location(div0, file$i, 174, 8, 7150);
			add_location(div1, file$i, 177, 12, 7376);
			attr_dev(center0, "id", "diff_loader");
			attr_dev(center0, "class", "mt-xl pt-5");
			set_style(center0, "display", "none");
			set_style(center0, "min-height", "200px");
			add_location(center0, file$i, 175, 8, 7240);
			add_location(div2, file$i, 181, 12, 7546);
			attr_dev(center1, "id", "getting_list");
			attr_dev(center1, "class", "mt-xl");
			set_style(center1, "display", "none");
			add_location(center1, file$i, 179, 8, 7432);
			add_location(div3, file$i, 183, 8, 7602);
			add_location(div4, file$i, 173, 4, 7135);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			append_dev(div4, t2);
			append_dev(div4, center0);
			append_dev(center0, div1);
			append_dev(div1, t3);
			append_dev(div4, t4);
			append_dev(div4, center1);
			append_dev(center1, div2);
			append_dev(div2, t5);
			append_dev(div4, t6);
			append_dev(div4, div3);
			if_blocks[current_block_type_index].m(div3, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*l*/ 1) && t0_value !== (t0_value = /*l*/ ctx[0].version_control + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*l*/ 1) && t3_value !== (t3_value = /*l*/ ctx[0].getting_diff + "")) set_data_dev(t3, t3_value);
			if ((!current || dirty & /*l*/ 1) && t5_value !== (t5_value = /*l*/ ctx[0].getting_list + "")) set_data_dev(t5, t5_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div3, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div4);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(170:0) <Dialog bind:visible={state.open} style=\\\"width: 75%; background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (258:8) <Button              key = {"versionBack"}              id="back_to_list"              class="h-imp"              color="#ccc"              unelevated={true}          >
function create_default_slot_1$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Back to list");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(258:8) <Button              key = {\\\"versionBack\\\"}              id=\\\"back_to_list\\\"              class=\\\"h-imp\\\"              color=\\\"#ccc\\\"              unelevated={true}          >",
		ctx
	});

	return block;
}

// (267:8) <Button              key = {"versionClose"}              on:click={handleClose}              color="#ccc"              unelevated={true}          >
function create_default_slot$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(267:8) <Button              key = {\\\"versionClose\\\"}              on:click={handleClose}              color=\\\"#ccc\\\"              unelevated={true}          >",
		ctx
	});

	return block;
}

// (257:4) 
function create_footer_slot$3(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				key: "versionBack",
				id: "back_to_list",
				class: "h-imp",
				color: "#ccc",
				unelevated: true,
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1 = new Button({
			props: {
				key: "versionClose",
				color: "#ccc",
				unelevated: true,
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*handleClose*/ ctx[2]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file$i, 256, 4, 12461);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot$3.name,
		type: "slot",
		source: "(257:4) ",
		ctx
	});

	return block;
}

function create_fragment$i(ctx) {
	let dialog;
	let updating_visible;
	let current;

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[8](value);
	}

	let dialog_props = {
		style: "width: 75%; background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot$3],
			default: [create_default_slot_2$4]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[1].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[1].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, 'visible', dialog_visible_binding));

	const block = {
		c: function create() {
			create_component(dialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dialog_changes = {};

			if (dirty & /*$$scope, state, l*/ 4099) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty & /*state*/ 2) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[1].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getParameterByName(name) {
	let match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
	return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function instance$i($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('VersionControl', slots, []);
	let { versionToggle } = $$props;
	let { guid } = $$props;
	let { closeVersionDialog } = $$props;
	let { l } = $$props;

	let hdd = writable({
		open: false,
		tableData: [],
		currectVersion: "",
		guid: "",
		clicks: 0
	});

	let state = {};

	const unsubscribe = hdd.subscribe(item => {
		$$invalidate(1, state = item);
	});

	onMount(async () => {
		AH.listen(document, 'click', '.edit_version', function (_this) {
			let from_draft = AH.select(".check-link").getAttribute("content_status");
			let url = window.location.href.replace(/&get-diff(.*?)$/g, '');
			url = url + '&get-diff=1&version_date=' + _this.getAttribute('data-version') + '&from_draft=' + from_draft;
			window.location = url;
		});

		AH.listen(document, 'click', '.get-diff', function (_this) {
			AH.toggleDom('#diff_loader', 'show');
			AH.toggleDom('.diff-table', 'hide');

			let current_diff = AH.select("#prev_btn").classList.contains("disabled")
			? "1"
			: "-1";

			AH.ajax({
				url: baseUrl + 'educator/project/content_version.php',
				data: {
					ajax: 1,
					current_diff,
					content_guid: state.guid,
					version_date: _this.getAttribute('data-version'),
					react_content_diff: 1,
					get_source: 1
				}
			}).then(response => {
				AH.toggleDom('#diff_loader', 'hide');
				AH.select('#back_to_list').classList.remove("h-imp");
				AH.select('#show_diff').innerHTML = response;
				AH.toggleDom('#show_diff', 'show'); //.prepend('<button type="button" class="btn btn-light mb-xl pull-right" id="back_to_list">Back To List</button>').show();
			});
		});

		AH.listen(document, 'click', '#back_to_list', function () {
			AH.toggleDom('.diff-table', 'show');
			AH.select('#back_to_list').classList.add("h-imp");
			AH.empty('#show_diff');
			AH.toggleDom('#show_diff', 'hide');
		});
	});

	onDestroy(() => {
		AH.toggleDom('.diff-table', 'hide');
		AH.toggleDom('#getting_list', 'show');
	});

	// $: console.log("version-",state.tableData)
	beforeUpdate(async () => {
		if (versionToggle != state.open) {
			($$invalidate(1, state.guid = guid, state), $$invalidate(1, state.open = versionToggle, state));
			AH.toggleDom('#getting_list', 'show');
			AH.toggleDom('.diff-table', 'hide');

			AH.ajax({
				url: baseUrl + 'educator/project/content_version.php',
				data: {
					ajax: 1,
					action: "get_version_list",
					content_guid: guid
				}
			}).then(response => {
				if (response) {
					try {
						response = JSON.parse(response);
					} catch(e) {
						return false;
					}

					$$invalidate(1, state.tableData = response, state);
					AH.setCss('.diff_modal', { 'padding-top': window.innerHeight / 20 });
					AH.toggleDom('.diff-table', 'show');
					AH.selectAll('#getting_list', 'hide');
					var current_data = getParameterByName('version_date');

					if (current_data) {
						AH.parent(AH.contains("td", current_data), 'tr').classList.contains('bg-danger');
					}

					AH.toggleDom('#replaced_diff_loader', 'show');

					if (response.length > 0) {
						AH.ajax({
							url: baseUrl + 'educator/project/content_version.php',
							data: {
								ajax: 1,
								current_diff: 1,
								content_guid: state.guid,
								version_date: response[0].version_date,
								react_content_diff: 1
							}
						}).then(_response => {
							console.log("Inner ajax");
							AH.toggleDom('#replaced_diff_loader', 'hide');
							_response = _response.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/ucLT/g, "&lt;").replace(/ucGT/g, "&gt;");
							AH.select('#changesData').innerHTML = _response;
							AH.toggleDom('#changesData', 'show');
						});
					}
				}
			});
		}
	});

	function handleClose() {
		closeVersionDialog(false);
		$$invalidate(1, state.open = false, state);
		AH.toggleDom('.diff-table', 'hide');
	}

	function getDiffData(timeStamp, prev_indx) {
		AH.toggleDom('#replaced_diff_loader', 'show');
		AH.toggleDom('#changesData', 'hide');
		let current_diff = prev_indx == "0" ? "1" : "-1";
		let currentRequest = null;

		currentRequest = AH.ajax({
			url: baseUrl + 'educator/project/content_version.php',
			data: {
				ajax: 1,
				current_diff,
				content_guid: state.guid,
				version_date: timeStamp,
				react_content_diff: 1
			},
			onStart() {
				if (currentRequest != null) {
					currentRequest.abort();
				}
			}
		}).then(response => {
			AH.toggleDom('#replaced_diff_loader', 'hide');
			response = response.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/ucLT/g, "&lt;").replace(/ucGT/g, "&gt;");
			AH.select('#changesData').innerHTML = response;
			AH.toggleDom('#changesData', 'show');
		});
	}

	function incrementItem(data) {
		if (state.clicks <= state.tableData.length - 2) {
			getDiffData(data.version_date, '1');
			$$invalidate(1, state.clicks = state.clicks + 1, state);
		} else {
			$$invalidate(1, state.clicks = state.tableData.length - 1, state);
		}
	}

	function decreaseItem(data) {
		let prev_indx = state.clicks - 1;

		if (state.clicks <= 0) {
			$$invalidate(1, state.clicks = 0, state);
		} else {
			$$invalidate(1, state.clicks = state.clicks - 1, state);
			getDiffData(data.version_date, prev_indx);
		}
	}

	const writable_props = ['versionToggle', 'guid', 'closeVersionDialog', 'l'];

	Object_1$2.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<VersionControl> was created with unknown prop '${key}'`);
	});

	function dialog_visible_binding(value) {
		if ($$self.$$.not_equal(state.open, value)) {
			state.open = value;
			$$invalidate(1, state);
		}
	}

	$$self.$$set = $$props => {
		if ('versionToggle' in $$props) $$invalidate(5, versionToggle = $$props.versionToggle);
		if ('guid' in $$props) $$invalidate(6, guid = $$props.guid);
		if ('closeVersionDialog' in $$props) $$invalidate(7, closeVersionDialog = $$props.closeVersionDialog);
		if ('l' in $$props) $$invalidate(0, l = $$props.l);
	};

	$$self.$capture_state = () => ({
		onMount,
		beforeUpdate,
		onDestroy,
		Button,
		Dialog,
		writable,
		AH,
		Loader,
		versionToggle,
		guid,
		closeVersionDialog,
		l,
		hdd,
		state,
		unsubscribe,
		getParameterByName,
		handleClose,
		getDiffData,
		incrementItem,
		decreaseItem
	});

	$$self.$inject_state = $$props => {
		if ('versionToggle' in $$props) $$invalidate(5, versionToggle = $$props.versionToggle);
		if ('guid' in $$props) $$invalidate(6, guid = $$props.guid);
		if ('closeVersionDialog' in $$props) $$invalidate(7, closeVersionDialog = $$props.closeVersionDialog);
		if ('l' in $$props) $$invalidate(0, l = $$props.l);
		if ('hdd' in $$props) hdd = $$props.hdd;
		if ('state' in $$props) $$invalidate(1, state = $$props.state);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		l,
		state,
		handleClose,
		incrementItem,
		decreaseItem,
		versionToggle,
		guid,
		closeVersionDialog,
		dialog_visible_binding
	];
}

class VersionControl extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
			versionToggle: 5,
			guid: 6,
			closeVersionDialog: 7,
			l: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VersionControl",
			options,
			id: create_fragment$i.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*versionToggle*/ ctx[5] === undefined && !('versionToggle' in props)) {
			console_1$5.warn("<VersionControl> was created without expected prop 'versionToggle'");
		}

		if (/*guid*/ ctx[6] === undefined && !('guid' in props)) {
			console_1$5.warn("<VersionControl> was created without expected prop 'guid'");
		}

		if (/*closeVersionDialog*/ ctx[7] === undefined && !('closeVersionDialog' in props)) {
			console_1$5.warn("<VersionControl> was created without expected prop 'closeVersionDialog'");
		}

		if (/*l*/ ctx[0] === undefined && !('l' in props)) {
			console_1$5.warn("<VersionControl> was created without expected prop 'l'");
		}
	}

	get versionToggle() {
		throw new Error("<VersionControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set versionToggle(value) {
		throw new Error("<VersionControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get guid() {
		throw new Error("<VersionControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set guid(value) {
		throw new Error("<VersionControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeVersionDialog() {
		throw new Error("<VersionControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeVersionDialog(value) {
		throw new Error("<VersionControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get l() {
		throw new Error("<VersionControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<VersionControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\WebpageList.svelte generated by Svelte v3.40.2 */

const { console: console_1$6 } = globals;
const file$j = "src\\WebpageList.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	child_ctx[11] = i;
	return child_ctx;
}

// (147:24) {#each state.domainArray as items, i (items.key)}
function create_each_block$3(key_1, ctx) {
	let option;
	let t_value = /*items*/ ctx[9].data + "";
	let t;
	let option_key_value;
	let option_value_value;
	let option_selected_value;

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			option = element("option");
			t = text(t_value);
			attr_dev(option, "key", option_key_value = /*items*/ ctx[9].key);
			option.__value = option_value_value = /*items*/ ctx[9].key;
			option.value = option.__value;
			option.selected = option_selected_value = /*items*/ ctx[9].selected ? "selected" : null;
			add_location(option, file$j, 147, 28, 5316);
			this.first = option;
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*state*/ 1 && t_value !== (t_value = /*items*/ ctx[9].data + "")) set_data_dev(t, t_value);

			if (dirty & /*state*/ 1 && option_key_value !== (option_key_value = /*items*/ ctx[9].key)) {
				attr_dev(option, "key", option_key_value);
			}

			if (dirty & /*state*/ 1 && option_value_value !== (option_value_value = /*items*/ ctx[9].key)) {
				prop_dev(option, "__value", option_value_value);
				option.value = option.__value;
			}

			if (dirty & /*state*/ 1 && option_selected_value !== (option_selected_value = /*items*/ ctx[9].selected ? "selected" : null)) {
				prop_dev(option, "selected", option_selected_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(147:24) {#each state.domainArray as items, i (items.key)}",
		ctx
	});

	return block;
}

// (125:0) <Dialog width="600" bind:visible={state.open}>
function create_default_slot_1$5(ctx) {
	let div3;
	let div0;
	let center;
	let loader;
	let t0;
	let h3;
	let t2;
	let div2;
	let label;
	let t4;
	let div1;
	let select;
	let option;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let mounted;
	let dispose;

	loader = new Loader({
			props: { size: 60, thickness: 2 },
			$$inline: true
		});

	let each_value = /*state*/ ctx[0].domainArray;
	validate_each_argument(each_value);
	const get_key = ctx => /*items*/ ctx[9].key;
	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			center = element("center");
			create_component(loader.$$.fragment);
			t0 = space();
			h3 = element("h3");
			h3.textContent = `${l.getting_webpage}`;
			t2 = space();
			div2 = element("div");
			label = element("label");
			label.textContent = "Select Webpage :";
			t4 = space();
			div1 = element("div");
			select = element("select");
			option = element("option");
			option.textContent = "Select for webpage";

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(h3, file$j, 132, 16, 4531);
			attr_dev(center, "id", "process");
			add_location(center, file$j, 130, 12, 4440);
			attr_dev(div0, "id", "showWebpage");
			set_style(div0, "min-width", "500px");
			set_style(div0, "min-height", "200px");
			set_style(div0, "margin", "25px 15px");
			add_location(div0, file$j, 129, 8, 4340);
			attr_dev(label, "class", "mr-md");
			attr_dev(label, "for", "domains");
			add_location(label, file$j, 136, 12, 4724);
			option.__value = "0";
			option.value = option.__value;
			option.selected = true;
			add_location(option, file$j, 145, 24, 5157);
			attr_dev(select, "id", "domains");
			attr_dev(select, "class", "form-control form-control-md w-100 select2 webpage_list");
			select.disabled = "";
			attr_dev(select, "name", "webpage");
			add_location(select, file$j, 138, 20, 4844);
			attr_dev(div1, "class", "col-12");
			add_location(div1, file$j, 137, 16, 4802);
			attr_dev(div2, "id", "webpage_list");
			set_style(div2, "min-width", "500px");
			set_style(div2, "min-height", "310px");
			set_style(div2, "margin", "25px 15px");
			set_style(div2, "display", "none");
			add_location(div2, file$j, 135, 8, 4608);
			add_location(div3, file$j, 128, 4, 4325);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div0, center);
			mount_component(loader, center, null);
			append_dev(center, t0);
			append_dev(center, h3);
			append_dev(div3, t2);
			append_dev(div3, div2);
			append_dev(div2, label);
			append_dev(div2, t4);
			append_dev(div2, div1);
			append_dev(div1, select);
			append_dev(select, option);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(select, "blur", /*handleChange*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*state*/ 1) {
				each_value = /*state*/ ctx[0].domainArray;
				validate_each_argument(each_value);
				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$3, null, get_each_context$3);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_component(loader);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(125:0) <Dialog width=\\\"600\\\" bind:visible={state.open}>",
		ctx
	});

	return block;
}

// (126:4) 
function create_title_slot(ctx) {
	let div1;
	let div0;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Webpage List";
			attr_dev(div0, "style", "");
			add_location(div0, file$j, 126, 8, 4275);
			attr_dev(div1, "slot", "title");
			set_style(div1, "text-align", "left");
			add_location(div1, file$j, 125, 4, 4221);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot.name,
		type: "slot",
		source: "(126:4) ",
		ctx
	});

	return block;
}

// (155:8) <Button              on:click={handleClose}              color="primary"          >
function create_default_slot$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(155:8) <Button              on:click={handleClose}              color=\\\"primary\\\"          >",
		ctx
	});

	return block;
}

// (154:4) 
function create_footer_slot$4(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				color: "primary",
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*handleClose*/ ctx[1]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "footer");
			set_style(div, "border-top", "1px solid var(--divider, rgba(0, 0, 0, 0.1))");
			add_location(div, file$j, 153, 4, 5548);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot$4.name,
		type: "slot",
		source: "(154:4) ",
		ctx
	});

	return block;
}

function create_fragment$j(ctx) {
	let dialog;
	let updating_visible;
	let current;

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[6](value);
	}

	let dialog_props = {
		width: "600",
		$$slots: {
			footer: [create_footer_slot$4],
			title: [create_title_slot],
			default: [create_default_slot_1$5]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[0].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, 'visible', dialog_visible_binding));

	const block = {
		c: function create() {
			create_component(dialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dialog_changes = {};

			if (dirty & /*$$scope, state*/ 4097) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty & /*state*/ 1) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[0].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('WebpageList', slots, []);
	let { editorState } = $$props;
	let { domainToggle } = $$props;
	let { selectedDomain } = $$props;

	//let webpage_selected = (webpage_selected) ? JSON.parse(webpage_selected) : [];
	let state = {};

	let hdd = writable({
		open: false,
		value: 0,
		webpageArray: [],
		guid: "",
		domainArray: []
	});

	const unsubscribe = hdd.subscribe(items => {
		$$invalidate(0, state = items);
	});

	onMount(async () => {
		// state.domainToggle = domainToggle;
		AH.listen(document, 'change', '#domains', _this => {
			let value = _this.value;
			$$invalidate(3, editorState.domainToggle = false, editorState);
			activate(2);
			$$invalidate(0, state.value = value, state);

			if (value != 0) {
				AH.ajax({
					url: baseUrl + "editor/",
					data: {
						"action": "loadwebpage",
						"content_guid": value,
						"ajax": 1
					}
				}).then(
					data => {
						let webpageArray = [];

						for (let i in data) {
							AH.select('#' + i, 'html', data[i]);
							webpageArray[i] = data[i];
						}

						$$invalidate(3, editorState.webpageArray = webpageArray, editorState);
						AH.select('#show_guid', 'html', value).style.display = 'block';
						$$invalidate(3, editorState.guid = value, editorState);
						activate(0);
					},
					"json"
				);

				AH.select('#save_xml', 'removeClass', 'disabled');
				AH.select('#save_xml', 'attr', { disabled: false });
			}
		});
	});

	beforeUpdate(async () => {
		if (domainToggle != state.open) {
			$$invalidate(0, state.open = domainToggle, state);
			AH.select('#showWebpage', 'show');
			AH.select('#webpage_list', 'hide');
			let items = [];

			AH.ajax({
				url: baseUrl + "editor/",
				data: {
					ajax: 1,
					"action": "get_webpage_templates",
					content_subtype: editorState.item
				}
			}).then(data => {
				if (data) {
					for (var i in data) {
						items.push({
							key: i,
							value: i,
							selected: AH.select('#show_guid').innerHTML == i ? true : false,
							data: data[i]
						});
					}
				}

				AH.select('#showWebpage', 'hide');
				AH.select('#webpage_list', 'show');
				$$invalidate(0, state.domainArray = items, state);
				$$invalidate(0, state.value = 0, state);

				try {
					AH.select2('.select2', {
						placeholder: "Select for webpage",
						allowClear: false
					});
				} catch(e) {
					console.log(e); // .on("select2:opening", function() {
				}
			});
		}
	});

	function handleClose() {
		$$invalidate(3, editorState.domainToggle = false, editorState);
		selectedDomain(state.value);

		//editorState.domain = state.value;
		$$invalidate(0, state.open = false, state);
	}

	function handleChange(event, index, value) {
		value = event.target.value;
		$$invalidate(3, editorState.domainToggle = false, editorState);
		activate(2);
		$$invalidate(0, state.value = value, state);

		if (value != 0) {
			AH.ajax({
				url: baseUrl + "editor/",
				data: {
					"action": "loadwebpage",
					"content_guid": value,
					"ajax": 1
				}
			}).then(data => {
				for (i in data) {
					AH.select('#' + i, 'html', data[i]);
				}

				AH.select('#show_guid', 'html', value);
				$$invalidate(3, editorState.guid = value, editorState);
				activate(0);
			});

			AH.select('#save_xml', 'removeClass', 'disabled');
			AH.select('#save_xml', 'attr', { disabled: false });
		}
	}

	const writable_props = ['editorState', 'domainToggle', 'selectedDomain'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$6.warn(`<WebpageList> was created with unknown prop '${key}'`);
	});

	function dialog_visible_binding(value) {
		if ($$self.$$.not_equal(state.open, value)) {
			state.open = value;
			$$invalidate(0, state);
		}
	}

	$$self.$$set = $$props => {
		if ('editorState' in $$props) $$invalidate(3, editorState = $$props.editorState);
		if ('domainToggle' in $$props) $$invalidate(4, domainToggle = $$props.domainToggle);
		if ('selectedDomain' in $$props) $$invalidate(5, selectedDomain = $$props.selectedDomain);
	};

	$$self.$capture_state = () => ({
		beforeUpdate,
		onMount,
		Button,
		Dialog,
		writable,
		AH,
		Loader,
		editorState,
		domainToggle,
		selectedDomain,
		state,
		hdd,
		unsubscribe,
		handleClose,
		handleChange
	});

	$$self.$inject_state = $$props => {
		if ('editorState' in $$props) $$invalidate(3, editorState = $$props.editorState);
		if ('domainToggle' in $$props) $$invalidate(4, domainToggle = $$props.domainToggle);
		if ('selectedDomain' in $$props) $$invalidate(5, selectedDomain = $$props.selectedDomain);
		if ('state' in $$props) $$invalidate(0, state = $$props.state);
		if ('hdd' in $$props) hdd = $$props.hdd;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		handleClose,
		handleChange,
		editorState,
		domainToggle,
		selectedDomain,
		dialog_visible_binding
	];
}

class WebpageList extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			editorState: 3,
			domainToggle: 4,
			selectedDomain: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WebpageList",
			options,
			id: create_fragment$j.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*editorState*/ ctx[3] === undefined && !('editorState' in props)) {
			console_1$6.warn("<WebpageList> was created without expected prop 'editorState'");
		}

		if (/*domainToggle*/ ctx[4] === undefined && !('domainToggle' in props)) {
			console_1$6.warn("<WebpageList> was created without expected prop 'domainToggle'");
		}

		if (/*selectedDomain*/ ctx[5] === undefined && !('selectedDomain' in props)) {
			console_1$6.warn("<WebpageList> was created without expected prop 'selectedDomain'");
		}
	}

	get editorState() {
		throw new Error("<WebpageList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<WebpageList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get domainToggle() {
		throw new Error("<WebpageList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set domainToggle(value) {
		throw new Error("<WebpageList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedDomain() {
		throw new Error("<WebpageList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedDomain(value) {
		throw new Error("<WebpageList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\libs\CreateVariable.svelte generated by Svelte v3.40.2 */

const { Object: Object_1$3, console: console_1$7 } = globals;
const file$k = "src\\libs\\CreateVariable.svelte";

function add_css$f(target) {
	append_styles(target, "svelte-urimaj", ".side-panel{width:330px !important}.algo_function:hover{-webkit-transition:color 1s;-moz-transition:color 1s;transition:color 1s;color:#00bcd4;font-size:14.2px}.deleteIcon:hover{text-decoration:none}.deleteIcon{color:#b0281a}.cursorPonter{cursor:auto}@media screen and (max-width: 800px){.validate.svelte-urimaj{font-size:12px;padding:0.375rem 0.50rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3JlYXRlVmFyaWFibGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJ4QlksV0FBVyxBQUFFLENBQUMsQUFDbEIsS0FBSyxDQUFFLEtBQUssQ0FBQyxVQUFVLEFBQzNCLENBQUMsQUFDTyxvQkFBb0IsQUFBRSxDQUFDLEFBQzNCLGtCQUFrQixDQUFFLEtBQUssQ0FBQyxFQUFFLENBQzVCLGVBQWUsQ0FBRSxLQUFLLENBQUMsRUFBRSxDQUN6QixVQUFVLENBQUUsS0FBSyxDQUFDLEVBQUUsQ0FDcEIsS0FBSyxDQUFFLE9BQU8sQ0FDZCxTQUFTLENBQUUsTUFBTSxBQUNyQixDQUFDLEFBQ08saUJBQWlCLEFBQUUsQ0FBQyxBQUN4QixlQUFlLENBQUUsSUFBSSxBQUN6QixDQUFDLEFBRU8sV0FBVyxBQUFFLENBQUMsQUFDbEIsS0FBSyxDQUFFLE9BQU8sQUFDbEIsQ0FBQyxBQUVPLGFBQWEsQUFBRSxDQUFDLEFBQ3BCLE1BQU0sQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFDRCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxLQUFLLENBQUMsQUFBQyxDQUFDLEFBQ2xDLFNBQVMsY0FBQyxDQUFDLEFBQ1AsU0FBUyxDQUFFLElBQUksQ0FDZixPQUFPLENBQUUsUUFBUSxDQUFDLE9BQU8sQUFDN0IsQ0FBQyxBQUNMLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ3JlYXRlVmFyaWFibGUuc3ZlbHRlIl19 */");
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[35] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

function get_each_context_3$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[44] = i;
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[44] = i;
	return child_ctx;
}

// (642:20) <Button                           variant="fab"                           color="primary"                          aria-label="Add"                          on:click={addVariable}                          unelevated={true}                    outlined={true}                          class="rounded-circle float-end shadow"                          style="width: 35px; height: 35px; background: #4285f4; margin-top:5px;"                      >
function create_default_slot_7$2(ctx) {
	let i;

	const block = {
		c: function create() {
			i = element("i");
			attr_dev(i, "class", "icomoon-plus");
			add_location(i, file$k, 651, 24, 26435);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$2.name,
		type: "slot",
		source: "(642:20) <Button                           variant=\\\"fab\\\"                           color=\\\"primary\\\"                          aria-label=\\\"Add\\\"                          on:click={addVariable}                          unelevated={true}                    outlined={true}                          class=\\\"rounded-circle float-end shadow\\\"                          style=\\\"width: 35px; height: 35px; background: #4285f4; margin-top:5px;\\\"                      >",
		ctx
	});

	return block;
}

// (657:24) {#if item}
function create_if_block$h(ctx) {
	let div3;
	let div0;
	let t0_value = /*item*/ ctx[41].split('=')[0].trim() + "";
	let t0;
	let div0_id_value;
	let div0_contenteditable_value;
	let t1;
	let div1;
	let t2_value = /*item*/ ctx[41].split('=')[1].trim() + "";
	let t2;
	let div1_id_value;
	let div1_contenteditable_value;
	let t3;
	let div2;
	let a;
	let t4;
	let hr;
	let t5;
	let div3_key_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text(t2_value);
			t3 = space();
			div2 = element("div");
			a = element("a");
			t4 = space();
			hr = element("hr");
			t5 = space();
			attr_dev(div0, "class", "inline-block section_table form-control func_name cursorPonter");
			attr_dev(div0, "id", div0_id_value = "var_name_" + /*index*/ ctx[44]);
			attr_dev(div0, "contenteditable", div0_contenteditable_value = true);
			set_style(div0, "margin", "8px 4px");
			set_style(div0, "border", "1px solid grey");
			add_location(div0, file$k, 658, 32, 26820);
			attr_dev(div1, "class", "inline-block bundle_width form-control func_values cursorPonter");
			attr_dev(div1, "id", div1_id_value = "var_value_" + /*index*/ ctx[44]);
			attr_dev(div1, "contenteditable", div1_contenteditable_value = true);
			set_style(div1, "margin", "8px 4px");
			set_style(div1, "border", "1px solid grey");
			set_style(div1, "word-break", "break-all");
			set_style(div1, "height", "37px");
			set_style(div1, "overflow", "auto");
			add_location(div1, file$k, 666, 32, 27314);
			attr_dev(a, "href", "#");
			set_style(a, "font-size", "16px");
			set_style(a, "margin-left", "6.3px");
			attr_dev(a, "class", "btn-md icomoon-new-24px-delete-1 deleteIcon");
			add_location(a, file$k, 679, 36, 28233);
			attr_dev(div2, "class", "mt-2 pt-1");
			set_style(div2, "width", "33px");
			set_style(div2, "display", "inline-block");
			set_style(div2, "border-radius", "50%");
			set_style(div2, "font-size", "17px");
			set_style(div2, "border", "2px solid white");
			set_style(div2, "height", "33px");
			add_location(div2, file$k, 674, 32, 27862);
			add_location(hr, file$k, 681, 32, 28419);
			attr_dev(div3, "key", div3_key_value = /*index*/ ctx[44]);
			attr_dev(div3, "class", "new_variable seq_inbox d-flex");
			add_location(div3, file$k, 657, 28, 26731);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div0, t0);
			append_dev(div3, t1);
			append_dev(div3, div1);
			append_dev(div1, t2);
			append_dev(div3, t3);
			append_dev(div3, div2);
			append_dev(div2, a);
			append_dev(div3, t4);
			append_dev(div3, hr);
			append_dev(div3, t5);

			if (!mounted) {
				dispose = listen_dev(div2, "click", /*deleteConfirm*/ ctx[10].bind(this, /*index*/ ctx[44]), false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*editorState*/ 1 && t0_value !== (t0_value = /*item*/ ctx[41].split('=')[0].trim() + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*editorState*/ 1 && t2_value !== (t2_value = /*item*/ ctx[41].split('=')[1].trim() + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$h.name,
		type: "if",
		source: "(657:24) {#if item}",
		ctx
	});

	return block;
}

// (656:20) {#each editorState.single_variables as item, index}
function create_each_block_4(ctx) {
	let if_block_anchor;
	let if_block = /*item*/ ctx[41] && create_if_block$h(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*item*/ ctx[41]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$h(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4.name,
		type: "each",
		source: "(656:20) {#each editorState.single_variables as item, index}",
		ctx
	});

	return block;
}

// (633:4) <Sidepanel right bind:visible={state.toggleVariableDrawer} width="300px">
function create_default_slot_6$2(ctx) {
	let div4;
	let div3;
	let div0;
	let t0_value = /*l*/ ctx[1].create_variable + "";
	let t0;
	let t1;
	let span;
	let t2;
	let button0;
	let t3;
	let div1;
	let hr;
	let t4;
	let t5;
	let div2;
	let button1;
	let t6_value = /*l*/ ctx[1].save_variable + "";
	let t6;
	let current;
	let mounted;
	let dispose;

	button0 = new Button({
			props: {
				variant: "fab",
				color: "primary",
				"aria-label": "Add",
				unelevated: true,
				outlined: true,
				class: "rounded-circle float-end shadow",
				style: "width: 35px; height: 35px; background: #4285f4; margin-top:5px;",
				$$slots: { default: [create_default_slot_7$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*addVariable*/ ctx[9]);
	let each_value_4 = /*editorState*/ ctx[0].single_variables;
	validate_each_argument(each_value_4);
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const block = {
		c: function create() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = space();
			create_component(button0.$$.fragment);
			t3 = space();
			div1 = element("div");
			hr = element("hr");
			t4 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t5 = space();
			div2 = element("div");
			button1 = element("button");
			t6 = text(t6_value);
			attr_dev(div0, "class", "inline-block relative");
			set_style(div0, "font-size", "20px");
			set_style(div0, "top", "8px");
			add_location(div0, file$k, 635, 16, 25562);
			attr_dev(span, "class", "icomoon-help");
			set_style(span, "font-size", "20px");
			set_style(span, "margin-left", "10px");
			set_style(span, "cursor", "pointer");
			set_style(span, "position", "relative");
			set_style(span, "top", "11px");
			add_location(span, file$k, 636, 20, 25679);
			add_location(hr, file$k, 654, 20, 26586);
			attr_dev(div1, "class", "outer_variables mt-xl clearboth");
			add_location(div1, file$k, 653, 20, 26519);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-primary float-end");
			add_location(button1, file$k, 687, 20, 28632);
			set_style(div2, "textAlign", "right");
			set_style(div2, "margin-top", "6px");
			add_location(div2, file$k, 686, 16, 28563);
			attr_dev(div3, "class", "");
			set_style(div3, "padding", "5px 10px");
			set_style(div3, "width", "inherit");
			set_style(div3, "height", "100%");
			add_location(div3, file$k, 634, 12, 25474);
			attr_dev(div4, "tabindex", "0");
			attr_dev(div4, "role", "button");
			set_style(div4, "margin-top", "14px");
			add_location(div4, file$k, 633, 8, 25403);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div3);
			append_dev(div3, div0);
			append_dev(div0, t0);
			append_dev(div3, t1);
			append_dev(div3, span);
			append_dev(div3, t2);
			mount_component(button0, div3, null);
			append_dev(div3, t3);
			append_dev(div3, div1);
			append_dev(div1, hr);
			append_dev(div1, t4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, button1);
			append_dev(button1, t6);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(span, "click", /*showHelpingPane*/ ctx[6], false, false, false),
					listen_dev(button1, "click", /*saveVariables*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 2) && t0_value !== (t0_value = /*l*/ ctx[1].create_variable + "")) set_data_dev(t0, t0_value);
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 32768) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);

			if (dirty[0] & /*deleteConfirm, editorState*/ 1025) {
				each_value_4 = /*editorState*/ ctx[0].single_variables;
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_4.length;
			}

			if ((!current || dirty[0] & /*l*/ 2) && t6_value !== (t6_value = /*l*/ ctx[1].save_variable + "")) set_data_dev(t6, t6_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_component(button0);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$2.name,
		type: "slot",
		source: "(633:4) <Sidepanel right bind:visible={state.toggleVariableDrawer} width=\\\"300px\\\">",
		ctx
	});

	return block;
}

// (705:24) {#each modal_array as item, index}
function create_each_block_3$1(ctx) {
	let html_tag;
	let raw_value = /*item*/ ctx[41] + "";
	let html_anchor;

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*modal_array*/ 4 && raw_value !== (raw_value = /*item*/ ctx[41] + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$1.name,
		type: "each",
		source: "(705:24) {#each modal_array as item, index}",
		ctx
	});

	return block;
}

// (693:4) <Sidepanel right bind:visible={state.toggleHelpingDrawer}>
function create_default_slot_5$2(ctx) {
	let div4;
	let div3;
	let div0;
	let t0_value = /*l*/ ctx[1].functions + "";
	let t0;
	let t1;
	let span;
	let t2;
	let div2;
	let hr;
	let t3;
	let div1;
	let mounted;
	let dispose;
	let each_value_3 = /*modal_array*/ ctx[2];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
	}

	const block = {
		c: function create() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = space();
			div2 = element("div");
			hr = element("hr");
			t3 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div0, "class", "inline-block");
			set_style(div0, "font-size", "20px");
			add_location(div0, file$k, 695, 16, 29043);
			attr_dev(span, "class", "icomoon-arrow-right-6 font24 relative");
			set_style(span, "top", "5px");
			set_style(span, "left", "62%");
			add_location(span, file$k, 696, 16, 29131);
			add_location(hr, file$k, 702, 20, 29414);
			add_location(div1, file$k, 703, 20, 29442);
			attr_dev(div2, "class", "outer_variables mt-xl clearboth");
			add_location(div2, file$k, 701, 16, 29347);
			attr_dev(div3, "class", "relative");
			set_style(div3, "padding", "5px 10px");
			set_style(div3, "width", "inherit");
			set_style(div3, "height", "100%");
			set_style(div3, "top", "55px");
			add_location(div3, file$k, 694, 12, 28938);
			attr_dev(div4, "tabindex", "0");
			attr_dev(div4, "role", "button");
			add_location(div4, file$k, 693, 8, 28892);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div3);
			append_dev(div3, div0);
			append_dev(div0, t0);
			append_dev(div3, t1);
			append_dev(div3, span);
			append_dev(div3, t2);
			append_dev(div3, div2);
			append_dev(div2, hr);
			append_dev(div2, t3);
			append_dev(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			if (!mounted) {
				dispose = listen_dev(span, "click", /*closeHelpingPane*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 2 && t0_value !== (t0_value = /*l*/ ctx[1].functions + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*modal_array*/ 4) {
				each_value_3 = /*modal_array*/ ctx[2];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$2.name,
		type: "slot",
		source: "(693:4) <Sidepanel right bind:visible={state.toggleHelpingDrawer}>",
		ctx
	});

	return block;
}

// (713:4) <Dialog bind:visible={state.algoxmlDialog} width={700}>
function create_default_slot_4$2(ctx) {
	let div;
	let textarea;
	let textarea_value_value;

	const block = {
		c: function create() {
			div = element("div");
			textarea = element("textarea");
			attr_dev(textarea, "id", "algoxml_Dialog");
			set_style(textarea, "width", "100%");
			set_style(textarea, "margin", "3px 0");
			set_style(textarea, "min-height", (window.in_frame == 1 ? '100px' : '250px') + ",\r\n                    border: 0px");
			set_style(textarea, "resize", "none");
			set_style(textarea, "outline", "none");
			set_style(textarea, "box-shadow", "none");
			set_style(textarea, "border-bottom", "1px solid #777373");
			textarea.value = textarea_value_value = /*state*/ ctx[4].algovalue;
			add_location(textarea, file$k, 717, 12, 29966);
			set_style(div, "borderBottom", "1px solid #00000000");
			set_style(div, "overflow-y", "auto");
			set_style(div, "overflow-x", "hidden");
			set_style(div, "height", "365px");
			add_location(div, file$k, 716, 8, 29853);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, textarea);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[4].algovalue)) {
				prop_dev(textarea, "value", textarea_value_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(713:4) <Dialog bind:visible={state.algoxmlDialog} width={700}>",
		ctx
	});

	return block;
}

// (714:8) 
function create_title_slot_1(ctx) {
	let div;
	let t_value = /*l*/ ctx[1].algo_xml + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "slot", "title");
			set_style(div, "text-align", "left");
			add_location(div, file$k, 713, 8, 29757);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 2 && t_value !== (t_value = /*l*/ ctx[1].algo_xml + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot_1.name,
		type: "slot",
		source: "(714:8) ",
		ctx
	});

	return block;
}

// (733:12) <Button on:click={()=> state.algoxmlDialog = false}>
function create_default_slot_3$3(ctx) {
	let t_value = /*l*/ ctx[1].cancel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 2 && t_value !== (t_value = /*l*/ ctx[1].cancel + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(733:12) <Button on:click={()=> state.algoxmlDialog = false}>",
		ctx
	});

	return block;
}

// (736:12) <Button on:click={saveAlgo}>
function create_default_slot_2$5(ctx) {
	let t_value = /*l*/ ctx[1].save + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 2 && t_value !== (t_value = /*l*/ ctx[1].save + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$5.name,
		type: "slot",
		source: "(736:12) <Button on:click={saveAlgo}>",
		ctx
	});

	return block;
}

// (732:8) 
function create_footer_slot_1$1(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[18]);

	button1 = new Button({
			props: {
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*saveAlgo*/ ctx[12]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "footer");
			set_style(div, "border-top", "1px solid var(--divider, rgba(0, 0, 0, 0.1))");
			add_location(div, file$k, 731, 8, 30472);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[0] & /*l*/ 2 | dirty[1] & /*$$scope*/ 32768) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[0] & /*l*/ 2 | dirty[1] & /*$$scope*/ 32768) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot_1$1.name,
		type: "slot",
		source: "(732:8) ",
		ctx
	});

	return block;
}

// (761:28) {#each Object.keys(arr_val) as item, i}
function create_each_block_2$1(ctx) {
	let th;
	let t0_value = /*item*/ ctx[41] + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*arr_val*/ ctx[5][/*item*/ ctx[41]] + "";
	let t2;
	let t3;
	let th_key_value;

	const block = {
		c: function create() {
			th = element("th");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			set_style(span, "font-size", "10px");
			add_location(span, file$k, 763, 36, 31831);
			attr_dev(th, "key", th_key_value = /*i*/ ctx[40]);
			add_location(th, file$k, 761, 32, 31737);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, t0);
			append_dev(th, t1);
			append_dev(th, span);
			append_dev(span, t2);
			append_dev(th, t3);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$1.name,
		type: "each",
		source: "(761:28) {#each Object.keys(arr_val) as item, i}",
		ctx
	});

	return block;
}

// (772:32) {#each Object.keys(p) as k, i}
function create_each_block_1$2(ctx) {
	let td;
	let t_value = /*p*/ ctx[35][/*k*/ ctx[38]] + "";
	let t;
	let td_key_value;

	const block = {
		c: function create() {
			td = element("td");
			t = text(t_value);
			attr_dev(td, "key", td_key_value = /*i*/ ctx[40]);
			add_location(td, file$k, 772, 36, 32238);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*analyze_array*/ 8 && t_value !== (t_value = /*p*/ ctx[35][/*k*/ ctx[38]] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$2.name,
		type: "each",
		source: "(772:32) {#each Object.keys(p) as k, i}",
		ctx
	});

	return block;
}

// (770:24) {#each analyze_array as p}
function create_each_block$4(ctx) {
	let tr;
	let t;
	let each_value_1 = Object.keys(/*p*/ ctx[35]);
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			add_location(tr, file$k, 770, 28, 32132);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*analyze_array*/ 8) {
				each_value_1 = Object.keys(/*p*/ ctx[35]);
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(770:24) {#each analyze_array as p}",
		ctx
	});

	return block;
}

// (742:4) <Dialog bind:visible={state.analyzeValuesDialog} width={700}>
function create_default_slot_1$6(ctx) {
	let div1;
	let div0;
	let table;
	let thead;
	let tr;
	let t;
	let tbody;
	let each_value_2 = Object.keys(/*arr_val*/ ctx[5]);
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	}

	let each_value = /*analyze_array*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(tr, file$k, 759, 24, 31630);
			add_location(thead, file$k, 758, 20, 31597);
			add_location(tbody, file$k, 768, 20, 32043);
			attr_dev(table, "class", "sorttable table4 uc-table mce-item-table");
			add_location(table, file$k, 757, 16, 31519);
			attr_dev(div0, "id", "analyzeValues_Dialog");
			set_style(div0, "width", "100%");
			set_style(div0, "margin", "3px 0");
			set_style(div0, "minHeight", window.in_frame == 1 ? "100px" : "250px");
			set_style(div0, "border", "0px");
			set_style(div0, "resize", "none");
			set_style(div0, "outline", "none");
			set_style(div0, "boxShadow", "none");
			add_location(div0, file$k, 746, 12, 31118);
			set_style(div1, "borderBottom", "1px solid #00000000");
			set_style(div1, "overflow-y", "auto");
			set_style(div1, "overflow-x", "hidden");
			set_style(div1, "height", "358px");
			add_location(div1, file$k, 745, 8, 31005);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, table);
			append_dev(table, thead);
			append_dev(thead, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(table, t);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*arr_val*/ 32) {
				each_value_2 = Object.keys(/*arr_val*/ ctx[5]);
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (dirty[0] & /*analyze_array*/ 8) {
				each_value = /*analyze_array*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$6.name,
		type: "slot",
		source: "(742:4) <Dialog bind:visible={state.analyzeValuesDialog} width={700}>",
		ctx
	});

	return block;
}

// (743:8) 
function create_title_slot$1(ctx) {
	let div;
	let t_value = /*l*/ ctx[1].val_variations + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "slot", "title");
			set_style(div, "text-align", "left");
			add_location(div, file$k, 742, 8, 30902);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 2 && t_value !== (t_value = /*l*/ ctx[1].val_variations + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot$1.name,
		type: "slot",
		source: "(743:8) ",
		ctx
	});

	return block;
}

// (782:12) <Button                   on:click={()=>state.analyzeValuesDialog = false}                  unelevated={true}               outlined={true}                  color="#ccc"              >
function create_default_slot$8(ctx) {
	let t_value = /*l*/ ctx[1].cancel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 2 && t_value !== (t_value = /*l*/ ctx[1].cancel + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(782:12) <Button                   on:click={()=>state.analyzeValuesDialog = false}                  unelevated={true}               outlined={true}                  color=\\\"#ccc\\\"              >",
		ctx
	});

	return block;
}

// (781:8) 
function create_footer_slot$5(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				unelevated: true,
				outlined: true,
				color: "#ccc",
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler_1*/ ctx[20]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file$k, 780, 8, 32472);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[0] & /*l*/ 2 | dirty[1] & /*$$scope*/ 32768) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot$5.name,
		type: "slot",
		source: "(781:8) ",
		ctx
	});

	return block;
}

function create_fragment$k(ctx) {
	let div;
	let button;
	let t0_value = /*l*/ ctx[1].algo_xml + "";
	let t0;
	let t1;
	let sidepanel0;
	let updating_visible;
	let t2;
	let sidepanel1;
	let updating_visible_1;
	let t3;
	let dialog0;
	let updating_visible_2;
	let t4;
	let dialog1;
	let updating_visible_3;
	let t5;
	let textarea;
	let current;
	let mounted;
	let dispose;

	function sidepanel0_visible_binding(value) {
		/*sidepanel0_visible_binding*/ ctx[16](value);
	}

	let sidepanel0_props = {
		right: true,
		width: "300px",
		$$slots: { default: [create_default_slot_6$2] },
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].toggleVariableDrawer !== void 0) {
		sidepanel0_props.visible = /*state*/ ctx[4].toggleVariableDrawer;
	}

	sidepanel0 = new Sidepanel({ props: sidepanel0_props, $$inline: true });
	binding_callbacks.push(() => bind(sidepanel0, 'visible', sidepanel0_visible_binding));

	function sidepanel1_visible_binding(value) {
		/*sidepanel1_visible_binding*/ ctx[17](value);
	}

	let sidepanel1_props = {
		right: true,
		$$slots: { default: [create_default_slot_5$2] },
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].toggleHelpingDrawer !== void 0) {
		sidepanel1_props.visible = /*state*/ ctx[4].toggleHelpingDrawer;
	}

	sidepanel1 = new Sidepanel({ props: sidepanel1_props, $$inline: true });
	binding_callbacks.push(() => bind(sidepanel1, 'visible', sidepanel1_visible_binding));

	function dialog0_visible_binding(value) {
		/*dialog0_visible_binding*/ ctx[19](value);
	}

	let dialog0_props = {
		width: 700,
		$$slots: {
			footer: [create_footer_slot_1$1],
			title: [create_title_slot_1],
			default: [create_default_slot_4$2]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].algoxmlDialog !== void 0) {
		dialog0_props.visible = /*state*/ ctx[4].algoxmlDialog;
	}

	dialog0 = new Dialog({ props: dialog0_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog0, 'visible', dialog0_visible_binding));

	function dialog1_visible_binding(value) {
		/*dialog1_visible_binding*/ ctx[21](value);
	}

	let dialog1_props = {
		width: 700,
		$$slots: {
			footer: [create_footer_slot$5],
			title: [create_title_slot$1],
			default: [create_default_slot_1$6]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].analyzeValuesDialog !== void 0) {
		dialog1_props.visible = /*state*/ ctx[4].analyzeValuesDialog;
	}

	dialog1 = new Dialog({ props: dialog1_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog1, 'visible', dialog1_visible_binding));

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			create_component(sidepanel0.$$.fragment);
			t2 = space();
			create_component(sidepanel1.$$.fragment);
			t3 = space();
			create_component(dialog0.$$.fragment);
			t4 = space();
			create_component(dialog1.$$.fragment);
			t5 = space();
			textarea = element("textarea");
			attr_dev(button, "style", "margin-right : 6px");
			attr_dev(button, "class", "btn btn-light validate btn-sm d-none svelte-urimaj");
			attr_dev(button, "type", "button");
			add_location(button, file$k, 624, 4, 25112);
			attr_dev(textarea, "class", "h-imp");
			attr_dev(textarea, "id", "algo_qxml");
			add_location(textarea, file$k, 791, 4, 32798);
			add_location(div, file$k, 623, 0, 25101);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, t0);
			append_dev(div, t1);
			mount_component(sidepanel0, div, null);
			append_dev(div, t2);
			mount_component(sidepanel1, div, null);
			append_dev(div, t3);
			mount_component(dialog0, div, null);
			append_dev(div, t4);
			mount_component(dialog1, div, null);
			append_dev(div, t5);
			append_dev(div, textarea);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*getalgoXml*/ ctx[11], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 2) && t0_value !== (t0_value = /*l*/ ctx[1].algo_xml + "")) set_data_dev(t0, t0_value);
			const sidepanel0_changes = {};

			if (dirty[0] & /*l, editorState*/ 3 | dirty[1] & /*$$scope*/ 32768) {
				sidepanel0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 16) {
				updating_visible = true;
				sidepanel0_changes.visible = /*state*/ ctx[4].toggleVariableDrawer;
				add_flush_callback(() => updating_visible = false);
			}

			sidepanel0.$set(sidepanel0_changes);
			const sidepanel1_changes = {};

			if (dirty[0] & /*modal_array, l*/ 6 | dirty[1] & /*$$scope*/ 32768) {
				sidepanel1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_1 && dirty[0] & /*state*/ 16) {
				updating_visible_1 = true;
				sidepanel1_changes.visible = /*state*/ ctx[4].toggleHelpingDrawer;
				add_flush_callback(() => updating_visible_1 = false);
			}

			sidepanel1.$set(sidepanel1_changes);
			const dialog0_changes = {};

			if (dirty[0] & /*l, state*/ 18 | dirty[1] & /*$$scope*/ 32768) {
				dialog0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_2 && dirty[0] & /*state*/ 16) {
				updating_visible_2 = true;
				dialog0_changes.visible = /*state*/ ctx[4].algoxmlDialog;
				add_flush_callback(() => updating_visible_2 = false);
			}

			dialog0.$set(dialog0_changes);
			const dialog1_changes = {};

			if (dirty[0] & /*state, l, analyze_array*/ 26 | dirty[1] & /*$$scope*/ 32768) {
				dialog1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_3 && dirty[0] & /*state*/ 16) {
				updating_visible_3 = true;
				dialog1_changes.visible = /*state*/ ctx[4].analyzeValuesDialog;
				add_flush_callback(() => updating_visible_3 = false);
			}

			dialog1.$set(dialog1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sidepanel0.$$.fragment, local);
			transition_in(sidepanel1.$$.fragment, local);
			transition_in(dialog0.$$.fragment, local);
			transition_in(dialog1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sidepanel0.$$.fragment, local);
			transition_out(sidepanel1.$$.fragment, local);
			transition_out(dialog0.$$.fragment, local);
			transition_out(dialog1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(sidepanel0);
			destroy_component(sidepanel1);
			destroy_component(dialog0);
			destroy_component(dialog1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function createValuesObject(obj, name, value) {
	if (typeof obj[name] == "undefined") {
		obj[name] = {};
	}

	obj[name] = value;
}

function instance$k($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CreateVariable', slots, []);
	let { editorState } = $$props;
	let { handleAlgoState } = $$props;
	let { l } = $$props;
	let ALGO = { mathtype: "" };
	let modal_array = [];
	let arr_val = {};
	let analyze_array = [{ 'var1': 1 }];
	let store = "";

	let state = {
		opened: false,
		deleteIndex: "",
		showPane: false,
		algoQXML: "",
		algoxmlDialog: false,
		analyzeValuesDialog: false,
		algovalue: '',
		toggleVariableDrawer: false,
		toggleHelpingDrawer: false
	};

	onMount(async () => {
		if (editorState.algo_qxml) {
			AH.select("#algo_qxml").value = editorState.algo_qxml;
		}

		algoFunction();
		getText();

		AH.listen(document, 'click', '.algo_function', function (_this, event) {
			pasteFunc(_this);
		});

		AH.listen(document, 'click', '.func_values', function (_this, event) {
			store = _this.getAttribute('id');
		});
	});

	function pasteFunc(_this) {
		console.log(store);
		window.tt = _this;
		let val = _this.textContent;
		$$invalidate(4, state.toggleHelpingDrawer = false, state);

		if (store) {
			AH.select('#' + store, 'text', val);
		} else {
			AH.showmsg("Focus on variable value first");
		}
	}

	function algoFunction() {
		ALGO.math = {
			algo_randObj: {
				text: "Random Word",
				description: "Find the random string or character",
				param: "(javascript,java,C,react,php)",
				use: "algo_randObj('JS,PHP,JAVA')",
				f(object) {
					let val_eval = object.split(',');
					return true;
				}
			},
			algo_randInt: {
				text: "Random Integer",
				description: "Find the random integer value (min-value, max-value, no. of values after decimal)",
				param: "minimunvalue,maximumvalue",
				agrlength: 2,
				use: "algo_randInt(1,4,2)",
				f(min, max, fix_decimal) {
					return (Math.floor(Math.random() * (max - min + 1)) + min).toFixed(fix_decimal);
				}
			},
			algo_randFloat: {
				text: "Random Float",
				description: "Find the random float/decimal value (min-value, max-value, no. of values after decimal)",
				param: "minimunvalue,maximumvalue",
				agrlength: 2,
				use: "algo_randFloat(1.1,4.5,2)",
				f(min, max, fix_decimal) {
					return (Math.random() * (max - min) + min).toFixed(fix_decimal);
				}
			},
			algo_ucSqrt: {
				text: "Square root",
				description: "Find the square root (value, no. of values after decimal)",
				param: "minimunvalue,maximumvalue",
				agrlength: 2,
				use: "algo_ucSqrt(9,2)",
				f(min, max) {
					return Math.sqrt(min).toFixed(max);
				}
			},
			algo_ucPow: {
				text: "Power",
				description: "Return the value of the number 4 to the power of 3(value, power, no. of values after decimal)",
				param: "minimunvalue,maximumvalue",
				agrlength: 2,
				use: "algo_ucPow(4,3,2)",
				f(min, max, fix_decimal) {
					return Math.pow(min, max).toFixed(fix_decimal);
				}
			},
			algo_current: {
				text: "Variables",
				description: "To directly use any variable",
				use: "algo_current('var1')",
				f(min) {
					return Math.pow(min);
				}
			},
			algo_ucAbs: {
				text: "Absolute",
				description: "To use any absolute value",
				use: "algo_ucAbs(-5)",
				f(min) {
					return Math.abs(min);
				}
			},
			algo_ucRound: {
				text: "Round",
				description: "To use any value in round figure",
				use: "algo_ucRound(2.5)",
				f(val) {
					return Math.round(val);
				}
			},
			algo_evalCondition: {
				text: "Evaluate",
				description: "To evaluate any condition",
				use: "algo_evalCondition(2>1,'true','false')",
				f(ex, tr, fl) {
					if (ex) {
						return tr;
					} else {
						return fl;
					}
				}
			},
			algo_compareValue: {
				text: "Compare values",
				description: "To compare any two values",
				use: "algo_compareValue(2,1,'greater','smaller','equal')",
				f(min, max, greater, smaller, equal) {
					if (min > max) {
						return greater;
					} else if (min < max) {
						return smaller;
					} else if (min == max) {
						return equal;
					}
				}
			},
			algo_fixed: {
				text: "Fixed values",
				description: "To fix any value after specific decimals",
				use: "algo_fixed(2.345231,2)",
				f(min, max) {
					return;
				}
			},
			algo_randomStep: {
				text: "Get multiple",
				description: "To get any random step number between two values",
				use: "algo_randomStep(1,30,5)",
				f(min, max, step) {
					return;
				}
			},
			algo_randpythagorus: {
				text: "Pythagorus",
				description: "Generate the random pythagorian value (key, min-value, max-value)",
				param: "index,minimunvalue,maximumvalue",
				agrlength: 2,
				use: "algo_randpythagorus(1,1,50)",
				f(indexkey, min, max) {
					return;
				}
			},
			algo_reduced: {
				text: "Reduced ratio",
				description: "Gives ratio based on first argument in reduced form.",
				param: "var1, var2",
				agrlength: 2,
				use: 'algo_reduced(algo_current("var1"),algo_current("var2"))',
				f(min, max) {
					return;
				}
			},
			algo_groupObj: {
				text: "Group Object",
				description: "Generate the random value of same index (objectvalues, group_alias)",
				param: "objectvalues, group_alias",
				agrlength: 2,
				use: 'algo_groupObj("frontend,backend,database","g1") & algo_groupObj("javascript,php,oracle","g1")',
				f(objects, group_alias) {
					return;
				}
			}
		};
	}

	function analyzeValues(res) {
		if (Object.keys(res[0]).length === 1) {
			AH.showmsg("Save Variables first!!");
			return;
		}

		editorState.single_variables.map(function (data, i) {
			let variable_value = data.split("=");
			createValuesObject(arr_val, variable_value[0], variable_value[1]);
		});

		$$invalidate(3, analyze_array = res);

		var timer = setTimeout(
			() => {
				AH.enableBsAll('[data-toggle="tooltip"]', 'Tooltip');
				clearTimeout(timer);
			},
			100
		);

		$$invalidate(4, state.analyzeValuesDialog = true, state);
		return;
	}

	function openHelpModal() {
		//jQuery('#helpModal').modal('show');
		AH.getBS('#helpModal', 'Modal', {});
	}

	function getText() {
		let modal_help = [];
		let temp_count = 0;

		for (let i in ALGO.math) {
			let text = '<h4 class="inline-block">' + ALGO.math[i].text + ':</h4><span class="algo_function pointer"> ' + ALGO.math[i].use + '</span>';
			text += '<div><b>Description</b>: <span>' + ALGO.math[i].description + '</span></div><hr />';
			modal_help[temp_count] = text;
			temp_count++;
		}

		$$invalidate(2, modal_array = modal_help);
	}

	function showPane(afterCall) {
		$$invalidate(4, state.toggleVariableDrawer = true, state);
		afterCall && afterCall();
	}

	function showHelpingPane() {
		$$invalidate(4, state.toggleHelpingDrawer = true, state);

		document.querySelector('[contenteditable]').addEventListener('paste', function (e) {
			e.preventDefault();
			let text = '';

			if (e.clipboardData || e.originalEvent.clipboardData) {
				text = (e.originalEvent || e).clipboardData.getData('text/plain');
			} else if (window.clipboardData) {
				text = window.clipboardData.getData('Text');
			}

			if (document.queryCommandSupported('insertText')) {
				document.execCommand('insertText', false, text);
			} else {
				document.execCommand('paste', false, text);
			}
		});
	}

	function closeHelpingPane() {
		$$invalidate(4, state.toggleHelpingDrawer = false, state);
	}

	function closePane(call) {
		$$invalidate(4, state.toggleVariableDrawer = false, state);

		if (!editorState.variable_button && call == "changeAlgoState" && handleAlgoState) {
			handleAlgoState();
		}
	}

	function saveVariables(valid) {
		let algo = "<algostatic>";
		let algo_str = '';
		let next_line = '';

		document.querySelectorAll('.new_variable').forEach(function (_this, i) {
			let var_name = _this.querySelector('#var_name_' + i).innerText;
			let var_value = _this.querySelector('#var_value_' + i).innerText;
			var_value = var_value.replace(/&nbsp;/g, "");
			var_value = var_value.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
			createValuesObject(arr_val, var_name, var_value);
			let final_values = var_name + "=" + var_value;
			algo_str = algo_str + next_line + final_values;
			$$invalidate(0, editorState.single_variables[i] = final_values, editorState);
			algo = algo + final_values + "\n";
			next_line = '\n';
		});

		algo = algo + "</algostatic>";
		if (checkRepeated()) return;
		if (unOrdered()) return;

		if (checkValidFunc(algo_str)) {
			$$invalidate(4, state.algoQXML = algo, state);
			$$invalidate(0, editorState.algo_qxml = algo, editorState);
			AH.selectAll("#algo_qxml", 'value', algo);
			console.log('-->', algo);
			$$invalidate(0, editorState.variable_button = true, editorState);
			closePane("changeAlgoState");
		}
	}

	function checkRepeated() {
		let check_var = [];

		editorState.single_variables.map(function (item, i) {
			check_var.push(item.split('=')[0]);
		});

		let counts = [];

		for (let i = 0; i <= check_var.length; i++) {
			if (counts[check_var[i]] === undefined) {
				counts[check_var[i]] = 1;
			} else {
				AH.showmsg("<b>" + check_var[i] + " is repeated.</b><br />A variable cannot be defined multiple times!");
				return true;
			}
		}

		return false;
	}

	function unOrdered() {
		let check_var = [];
		let used_var = '';
		let condition_check = false;

		editorState.single_variables.map(function (item, i) {
			check_var.push(item.split('=')[0].trim());
			used_var = item.split('=')[1];
			let check_format = item.match(/var\d+/g);

			if (check_format) {
				check_format.map(function (data) {
					let find_elem = check_var.indexOf(data);

					if (find_elem == -1) {
						AH.showmsg("<b>" + data + " cannot be used before it is defined.</b>");
						condition_check = true;
					}
				});
			}
		});

		return condition_check;
	}

	function checkValidFunc(algo_str) {
		let var_list = '';

		try {
			var_list = generateVariables(algo_str);

			if (var_list != true) {
				AH.showmsg(var_list);
				return false;
			}
		} catch(e) {
			AH.showmsg("<b>" + e + "<br/><br/>Variables are not correctly defined.</b>");
		}

		return var_list;
	}

	function generateVariables(algostr) {
		const regex_mathtype = /is_advance[\s]*=([\s"'\d]*)/;
		let fnName = "";
		let var_list = {};
		let xml = algostr.split("\n");

		try {
			ALGO.mathtype = +xml[0].match(regex_mathtype)[1].match(/[\d]+/);
		} catch(err) {
			ALGO.mathtype = "";
		}

		for (let i = 0; i < xml.length; i++) {
			let xml_id = xml[i], xml_arr = xml_id.split("=");
			let algo_fn = xml_arr[1].indexOf('algo_');
			fnName = xml_arr[1].substring(algo_fn, xml_arr[1].indexOf('(')).trim();
			let invalidArgument = "Number of arguments in " + xml_arr[0] + " is incorrect";

			if (typeof ALGO.math[fnName] != 'object') {
				fnName = "";
			}

			if (fnName != "") {
				const regExp = /\(([\s\S]*)\)/;

				let val_eval = [],
					matches = regExp.exec(xml_arr[1]),
					min,
					max,
					fix_decimal,
					indexkey;

				switch (fnName.trim()) {
					case "algo_randInt":
						val_eval = matches[1].split(',');
						if (val_eval.length > 3 || val_eval.length < 2) {
							return invalidArgument;
						}
						min = parseInt(val_eval[0]);
						max = parseInt(val_eval[1]);
						fix_decimal = parseInt(val_eval[2]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max, fix_decimal);
						break;
					case "algo_randFloat":
						val_eval = matches[1].split(',');
						if (val_eval.length > 3 || val_eval.length < 2) {
							return invalidArgument;
						}
						min = parseFloat(val_eval[0]);
						max = parseFloat(val_eval[1]);
						fix_decimal = parseInt(val_eval[2]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max, fix_decimal);
						break;
					case "algo_ucSqrt":
						val_eval = matches[1].split(',');
						if (val_eval.length > 2 || val_eval.length < 1) {
							return invalidArgument;
						}
						min = parseInt(val_eval[0]);
						max = parseInt(val_eval[1]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max);
						break;
					case "algo_ucPow":
						val_eval = matches[1].split(',');
						if (val_eval.length > 3 || val_eval.length < 2) {
							return invalidArgument;
						}
						min = parseInt(val_eval[0]);
						max = parseInt(val_eval[1]);
						fix_decimal = parseInt(val_eval[2]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max, fix_decimal);
						break;
					case "algo_current":
						val_eval = matches[1].split(',');
						if (val_eval.length > 1) {
							return invalidArgument;
						}
						min = parseInt(val_eval[0]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min);
						break;
					case "algo_ucAbs":
						val_eval = matches[1].split(',');
						if (val_eval.length > 1) {
							return invalidArgument;
						}
						min = parseInt(val_eval[0]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min);
						break;
					case "algo_ucRound":
						val_eval = matches[1].split(',');
						if (val_eval.length > 1) {
							return invalidArgument;
						}
						let val = val_eval[0];
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(val);
						break;
					case "algo_evalCondition":
						val_eval = matches[1].split(',');
						if (val_eval.length != 3) {
							return invalidArgument;
						}
						fix_decimal = val_eval[0];
						min = val_eval[1];
						max = val_eval[2];
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(fix_decimal, min, max);
					case "algo_compareValue":
						val_eval = matches[1].split(',');
						if (val_eval.length != 5) {
							return invalidArgument;
						}
						min = val_eval[0];
						max = val_eval[1];
						let greater = val_eval[2];
						let smaller = val_eval[3];
						fix_decimal = val_eval[4];
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max, greater, smaller, fix_decimal);
					case "algo_fixed":
						val_eval = matches[1].split(',');
						if (val_eval.length != 2) {
							return invalidArgument;
						}
						min = val_eval[0];
						max = val_eval[1];
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max);
						break;
					case "algo_randomStep":
						val_eval = matches[1].split(',');
						if (val_eval.length > 3 || val_eval.length < 2) {
							return invalidArgument;
						}
						min = val_eval[0];
						max = val_eval[1];
						fix_decimal = val_eval[2];
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max, fix_decimal);
					case "algo_randpythagorus":
						val_eval = matches[1].split(',');
						if (val_eval.length != 3) {
							return invalidArgument;
						}
						indexkey = parseInt(val_eval[0]);
						min = parseInt(val_eval[1]);
						max = parseInt(val_eval[2]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(indexkey, min, max);
						break;
					case "algo_groupObj":
						val_eval = matches[1].split(',');
						var objects = parseInt(val_eval[0]);
						var group_alias = parseInt(val_eval[1]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(objects, group_alias);
						break;
					case "algo_reduced":
						val_eval = matches[1].split(',');
						if (val_eval.length != 2) {
							return invalidArgument;
						}
						min = parseInt(val_eval[0]);
						max = parseInt(val_eval[1]);
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(min, max);
						break;
					default:
						let string = JSON.stringify(matches[1]);
						string = string.trim().replace(/"|\\/g, '');
						var_list[xml_arr[0].trim()] = ALGO.math[fnName].f(string);
				}
			}

			if (fnName == "") {
				const regExp_arth = /(\*|\+|\-|\/|\^|\%|\(|\)|\,|\[|\]|\#)/g,
					regExp_semicolon = /;|\\/g;

				let test = xml_arr[1].split(regExp_arth), expression = "";
				var iscartesian = false;

				for (let j = 0; j < test.length; j++) {
					test[j] = test[j].trim();

					if (test[j] != ";" && test[j] != "") {
						test[j] = test[j].replace(regExp_semicolon, '');

						if (test[j] == "#") {
							test[j] = "'";
						} else {
							test[j] = var_list.hasOwnProperty(test[j])
							? var_list[test[j]]
							: isNaN(+test[j]) ? test[j] : +test[j];
						}

						let t = test[j];
						t = typeof t == "string" ? t.trim() : t;

						if (t == 'math.setCartesian') {
							iscartesian = true;
						}

						expression = expression + test[j];
					} else {
						continue;
					}
				}

				if (ALGO.mathtype == 2) {
					if (iscartesian == true) {
						let testing = eval(expression);
						let str = "";

						for (let k = 0; k < testing.length; k++) {
							testing[k] = "(" + testing[k] + ") ";
							str = str + testing[k];
						}

						var_list[xml_arr[0].trim()] = str;
					}

					if (!iscartesian) {
						var_list[xml_arr[0].trim()] = eval(expression).toString();
					}

					if (var_list[xml_arr[0].trim()] == "") {
						var_list[xml_arr[0].trim()] = "None of these";
					}
				}

				if (ALGO.mathtype == "") {
					var_list[xml_arr[0].trim()] = eval(expression.trim());
				}
			}
		}

		return true;
	}

	function addVariable() {
		let tempVar = editorState.single_variables;
		tempVar.push("var=0");
		$$invalidate(0, editorState.single_variables = tempVar, editorState);
	}

	function deleteVar(index) {
		$$invalidate(4, state.opened = true, state);
		$$invalidate(4, state.deleteIndex = index, state);
	}

	function deleteConfirm(index) {
		if (editorState.single_variables.length != 1) {
			let tempVar = editorState.single_variables[index].split('=');
			delete arr_val[tempVar[0]];
			let tempAlgoVar = editorState.single_variables;
			tempAlgoVar.splice(index, 1);
			$$invalidate(0, editorState.single_variables = tempAlgoVar, editorState);
		} else {
			AH.showmsg("Minimum one variable is required.");
		}

		$$invalidate(4, state.opened = false, state);
	}

	function handleCloseVariable() {
		$$invalidate(4, state.opened = false, state);
	}

	function getalgoXml() {
		$$invalidate(4, state.algoxmlDialog = true, state);
		AH.select('#algoxml_Dialog').value = `<algostatic>${single_variables.join('\n')}</algostatic>`;
	}

	function saveAlgo() {
		let dialogXml = AH.select("#algoxml_Dialog").value;
		dialogXml = dialogXml.replace(/<algostatic>/g, "").replace(/<\/algostatic>/g, "");
		dialogXml = dialogXml.trim();
		editorState.single_variables.splice(0, editorState.single_variables.length);

		dialogXml.split("\n").map(function (data, i) {
			$$invalidate(0, editorState.single_variables[i] = data.trim(), editorState);
		});

		if (checkRepeated()) return;
		if (unOrdered()) return;

		if (checkValidFunc(dialogXml)) {
			$$invalidate(4, state.algoQXML = AH.select("#algoxml_Dialog").value, state);
			document.querySelector("#algo_qxml").value = document.querySelector("#algoxml_Dialog").value;
			$$invalidate(0, editorState.algo_qxml = AH.select("#algoxml_Dialog").value, editorState);
			$$invalidate(4, state.algoxmlDialog = false, state);
		}
	}

	const writable_props = ['editorState', 'handleAlgoState', 'l'];

	Object_1$3.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$7.warn(`<CreateVariable> was created with unknown prop '${key}'`);
	});

	function sidepanel0_visible_binding(value) {
		if ($$self.$$.not_equal(state.toggleVariableDrawer, value)) {
			state.toggleVariableDrawer = value;
			$$invalidate(4, state);
		}
	}

	function sidepanel1_visible_binding(value) {
		if ($$self.$$.not_equal(state.toggleHelpingDrawer, value)) {
			state.toggleHelpingDrawer = value;
			$$invalidate(4, state);
		}
	}

	const click_handler = () => $$invalidate(4, state.algoxmlDialog = false, state);

	function dialog0_visible_binding(value) {
		if ($$self.$$.not_equal(state.algoxmlDialog, value)) {
			state.algoxmlDialog = value;
			$$invalidate(4, state);
		}
	}

	const click_handler_1 = () => $$invalidate(4, state.analyzeValuesDialog = false, state);

	function dialog1_visible_binding(value) {
		if ($$self.$$.not_equal(state.analyzeValuesDialog, value)) {
			state.analyzeValuesDialog = value;
			$$invalidate(4, state);
		}
	}

	$$self.$$set = $$props => {
		if ('editorState' in $$props) $$invalidate(0, editorState = $$props.editorState);
		if ('handleAlgoState' in $$props) $$invalidate(13, handleAlgoState = $$props.handleAlgoState);
		if ('l' in $$props) $$invalidate(1, l = $$props.l);
	};

	$$self.$capture_state = () => ({
		onMount,
		Button,
		Dialog,
		Sidepanel,
		AH,
		editorState,
		handleAlgoState,
		l,
		ALGO,
		modal_array,
		arr_val,
		analyze_array,
		store,
		state,
		pasteFunc,
		algoFunction,
		analyzeValues,
		openHelpModal,
		getText,
		showPane,
		showHelpingPane,
		closeHelpingPane,
		closePane,
		createValuesObject,
		saveVariables,
		checkRepeated,
		unOrdered,
		checkValidFunc,
		generateVariables,
		addVariable,
		deleteVar,
		deleteConfirm,
		handleCloseVariable,
		getalgoXml,
		saveAlgo
	});

	$$self.$inject_state = $$props => {
		if ('editorState' in $$props) $$invalidate(0, editorState = $$props.editorState);
		if ('handleAlgoState' in $$props) $$invalidate(13, handleAlgoState = $$props.handleAlgoState);
		if ('l' in $$props) $$invalidate(1, l = $$props.l);
		if ('ALGO' in $$props) ALGO = $$props.ALGO;
		if ('modal_array' in $$props) $$invalidate(2, modal_array = $$props.modal_array);
		if ('arr_val' in $$props) $$invalidate(5, arr_val = $$props.arr_val);
		if ('analyze_array' in $$props) $$invalidate(3, analyze_array = $$props.analyze_array);
		if ('store' in $$props) store = $$props.store;
		if ('state' in $$props) $$invalidate(4, state = $$props.state);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		editorState,
		l,
		modal_array,
		analyze_array,
		state,
		arr_val,
		showHelpingPane,
		closeHelpingPane,
		saveVariables,
		addVariable,
		deleteConfirm,
		getalgoXml,
		saveAlgo,
		handleAlgoState,
		analyzeValues,
		showPane,
		sidepanel0_visible_binding,
		sidepanel1_visible_binding,
		click_handler,
		dialog0_visible_binding,
		click_handler_1,
		dialog1_visible_binding
	];
}

class CreateVariable extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$k,
			create_fragment$k,
			safe_not_equal,
			{
				editorState: 0,
				handleAlgoState: 13,
				l: 1,
				analyzeValues: 14,
				showPane: 15
			},
			add_css$f,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CreateVariable",
			options,
			id: create_fragment$k.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*editorState*/ ctx[0] === undefined && !('editorState' in props)) {
			console_1$7.warn("<CreateVariable> was created without expected prop 'editorState'");
		}

		if (/*handleAlgoState*/ ctx[13] === undefined && !('handleAlgoState' in props)) {
			console_1$7.warn("<CreateVariable> was created without expected prop 'handleAlgoState'");
		}

		if (/*l*/ ctx[1] === undefined && !('l' in props)) {
			console_1$7.warn("<CreateVariable> was created without expected prop 'l'");
		}
	}

	get editorState() {
		throw new Error("<CreateVariable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<CreateVariable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleAlgoState() {
		throw new Error("<CreateVariable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handleAlgoState(value) {
		throw new Error("<CreateVariable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get l() {
		throw new Error("<CreateVariable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<CreateVariable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get analyzeValues() {
		return this.$$.ctx[14];
	}

	set analyzeValues(value) {
		throw new Error("<CreateVariable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showPane() {
		return this.$$.ctx[15];
	}

	set showPane(value) {
		throw new Error("<CreateVariable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\InteractiveItem.svelte generated by Svelte v3.40.2 */

const { Object: Object_1$4 } = globals;
const file$l = "src\\components\\InteractiveItem.svelte";

function create_fragment$l(ctx) {
	let div37;
	let div5;
	let div4;
	let div3;
	let div1;
	let div0;
	let t1;
	let button0;
	let t3;
	let button1;
	let t5;
	let div2;
	let ul0;
	let t6;
	let div13;
	let div12;
	let div11;
	let div7;
	let button2;
	let t8;
	let div6;
	let t10;
	let div10;
	let div9;
	let div8;
	let span;
	let t11;
	let input;
	let t12;
	let ul1;
	let t13;
	let div17;
	let div16;
	let div15;
	let div14;
	let t14;
	let div24;
	let div23;
	let div22;
	let div18;
	let h4;
	let t16;
	let button3;
	let t18;
	let div20;
	let div19;
	let t19;
	let div21;
	let button4;
	let t21;
	let button5;
	let t23;
	let div31;
	let div30;
	let div29;
	let div26;
	let button6;
	let t25;
	let div25;
	let t27;
	let div28;
	let ul2;
	let t28;
	let div27;
	let button7;
	let t30;
	let div36;
	let div35;
	let div34;
	let div32;
	let textarea;
	let t31;
	let div33;
	let button8;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div37 = element("div");
			div5 = element("div");
			div4 = element("div");
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Change Type";
			t1 = space();
			button0 = element("button");
			button0.textContent = "Advance";
			t3 = space();
			button1 = element("button");
			button1.textContent = "×";
			t5 = space();
			div2 = element("div");
			ul0 = element("ul");
			t6 = space();
			div13 = element("div");
			div12 = element("div");
			div11 = element("div");
			div7 = element("div");
			button2 = element("button");
			button2.textContent = "×";
			t8 = space();
			div6 = element("div");
			div6.textContent = "Block Library";
			t10 = space();
			div10 = element("div");
			div9 = element("div");
			div8 = element("div");
			span = element("span");
			t11 = space();
			input = element("input");
			t12 = space();
			ul1 = element("ul");
			t13 = space();
			div17 = element("div");
			div16 = element("div");
			div15 = element("div");
			div14 = element("div");
			t14 = space();
			div24 = element("div");
			div23 = element("div");
			div22 = element("div");
			div18 = element("div");
			h4 = element("h4");
			h4.textContent = "Edit content";
			t16 = space();
			button3 = element("button");
			button3.textContent = "×";
			t18 = space();
			div20 = element("div");
			div19 = element("div");
			t19 = space();
			div21 = element("div");
			button4 = element("button");
			button4.textContent = "Done";
			t21 = space();
			button5 = element("button");
			button5.textContent = "Close";
			t23 = space();
			div31 = element("div");
			div30 = element("div");
			div29 = element("div");
			div26 = element("div");
			button6 = element("button");
			button6.textContent = "×";
			t25 = space();
			div25 = element("div");
			div25.textContent = "Nested list";
			t27 = space();
			div28 = element("div");
			ul2 = element("ul");
			t28 = space();
			div27 = element("div");
			button7 = element("button");
			button7.textContent = "Apply";
			t30 = space();
			div36 = element("div");
			div35 = element("div");
			div34 = element("div");
			div32 = element("div");
			textarea = element("textarea");
			t31 = space();
			div33 = element("div");
			button8 = element("button");
			button8.textContent = "Done";
			set_style(div0, "float", "left");
			add_location(div0, file$l, 60, 20, 2887);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "advance_btn_class h-imp ml btn-primary");
			attr_dev(button0, "id", "advance_id");
			add_location(button0, file$l, 61, 20, 2951);
			set_style(button1, "font-size", "23px");
			set_style(button1, "position", "relative");
			set_style(button1, "bottom", "6px");
			set_style(button1, "float", "right");
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "close");
			attr_dev(button1, "data-bs-dismiss", "modal");
			add_location(button1, file$l, 62, 20, 3074);
			set_style(div1, "padding", "20px 20px 20px 13px");
			attr_dev(div1, "class", "border-bottom mb-3");
			add_location(div1, file$l, 59, 16, 2796);
			attr_dev(ul0, "class", "sub_type list-unstyled");
			set_style(ul0, "padding", "0");
			add_location(ul0, file$l, 70, 20, 3433);
			attr_dev(div2, "class", "modal-body p-3");
			add_location(div2, file$l, 69, 16, 3383);
			attr_dev(div3, "class", "modal-content");
			add_location(div3, file$l, 58, 12, 2751);
			attr_dev(div4, "class", "modal-dialog");
			add_location(div4, file$l, 57, 8, 2711);
			attr_dev(div5, "class", "modal fade left");
			attr_dev(div5, "id", "type_change");
			attr_dev(div5, "role", "dialog");
			set_style(div5, "z-index", "9999", 1);
			set_style(div5, "width", "100%");
			add_location(div5, file$l, 56, 4, 2599);
			set_style(button2, "font-size", "23px");
			attr_dev(button2, "type", "button");
			attr_dev(button2, "class", "close m-0");
			attr_dev(button2, "data-bs-dismiss", "modal");
			add_location(button2, file$l, 80, 20, 3912);
			attr_dev(div6, "class", "");
			add_location(div6, file$l, 87, 20, 4248);
			set_style(div7, "padding", "15px 15px 15px 8px");
			attr_dev(div7, "class", "border-bottom mb-3");
			add_location(div7, file$l, 79, 16, 3822);
			attr_dev(span, "class", "icomoon-search-3 input-group-text");
			add_location(span, file$l, 92, 22, 4502);
			attr_dev(div8, "class", "input-group-prepend");
			add_location(div8, file$l, 91, 21, 4445);
			attr_dev(input, "id", "searchText");
			attr_dev(input, "placeholder", "Search");
			attr_dev(input, "class", "form-control");
			attr_dev(input, "type", "text");
			add_location(input, file$l, 94, 21, 4609);
			attr_dev(div9, "class", "px-2 input-group pb-3");
			add_location(div9, file$l, 90, 20, 4387);
			attr_dev(ul1, "class", "main_items");
			attr_dev(ul1, "id", "main_items");
			add_location(ul1, file$l, 96, 20, 4762);
			attr_dev(div10, "class", "modal-body");
			set_style(div10, "padding", "0");
			add_location(div10, file$l, 89, 16, 4323);
			attr_dev(div11, "class", "modal-content");
			add_location(div11, file$l, 78, 12, 3777);
			attr_dev(div12, "class", "modal-dialog");
			add_location(div12, file$l, 77, 8, 3737);
			attr_dev(div13, "class", "modal left fade in");
			attr_dev(div13, "id", "interactive_items");
			attr_dev(div13, "role", "dialog");
			attr_dev(div13, "data-backdrop", "true");
			set_style(div13, "z-index", "9999", 1);
			set_style(div13, "width", "321px");
			add_location(div13, file$l, 76, 4, 3594);
			attr_dev(div14, "class", "modal-body modal_items");
			add_location(div14, file$l, 105, 12, 5097);
			attr_dev(div15, "class", "modal-content");
			add_location(div15, file$l, 104, 12, 5056);
			attr_dev(div16, "class", "modal-dialog");
			add_location(div16, file$l, 103, 8, 5016);
			attr_dev(div17, "class", "modal left_second fade");
			attr_dev(div17, "id", "items_list");
			attr_dev(div17, "role", "dialog");
			set_style(div17, "z-index", "9998", 1);
			add_location(div17, file$l, 102, 4, 4909);
			attr_dev(h4, "class", "modal-title");
			add_location(h4, file$l, 114, 20, 5411);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "class", "close");
			attr_dev(button3, "data-bs-dismiss", "modal");
			add_location(button3, file$l, 115, 20, 5474);
			attr_dev(div18, "class", "modal-header");
			add_location(div18, file$l, 113, 16, 5363);
			attr_dev(div19, "id", "edit_tab");
			attr_dev(div19, "class", "edit_modal_body");
			add_location(div19, file$l, 118, 20, 5652);
			attr_dev(div20, "class", "modal-body edit_options");
			add_location(div20, file$l, 117, 16, 5592);
			attr_dev(button4, "id", "done_button");
			attr_dev(button4, "type", "button");
			attr_dev(button4, "class", "btn btn-light");
			attr_dev(button4, "data-bs-dismiss", "modal");
			add_location(button4, file$l, 121, 20, 5791);
			attr_dev(button5, "type", "button");
			attr_dev(button5, "class", "btn btn-light");
			attr_dev(button5, "data-bs-dismiss", "modal");
			add_location(button5, file$l, 122, 20, 5911);
			attr_dev(div21, "class", "modal-footer");
			add_location(div21, file$l, 120, 16, 5743);
			attr_dev(div22, "class", "modal-content");
			add_location(div22, file$l, 112, 12, 5318);
			attr_dev(div23, "class", "modal-dialog");
			add_location(div23, file$l, 111, 8, 5278);
			attr_dev(div24, "class", "modal fade");
			attr_dev(div24, "id", "edit_item_modal");
			attr_dev(div24, "role", "dialog");
			add_location(div24, file$l, 110, 4, 5209);
			set_style(button6, "font-size", "23px");
			set_style(button6, "position", "relative");
			set_style(button6, "bottom", "6px");
			attr_dev(button6, "type", "button");
			attr_dev(button6, "class", "close");
			attr_dev(button6, "data-bs-dismiss", "modal");
			add_location(button6, file$l, 131, 20, 6358);
			attr_dev(div25, "class", "");
			add_location(div25, file$l, 138, 20, 6720);
			set_style(div26, "padding", "20px 20px 20px 13px");
			add_location(div26, file$l, 130, 16, 6294);
			attr_dev(ul2, "class", "nested_items");
			add_location(ul2, file$l, 141, 20, 6857);
			attr_dev(button7, "type", "button");
			attr_dev(button7, "class", "btn btn-primary save_sublist");
			add_location(button7, file$l, 144, 24, 7020);
			attr_dev(div27, "class", "mr-md");
			set_style(div27, "text-align", "right");
			set_style(div27, "margin-top", "6px");
			add_location(div27, file$l, 143, 20, 6931);
			attr_dev(div28, "class", "modal-body");
			set_style(div28, "padding", "0");
			add_location(div28, file$l, 140, 16, 6793);
			attr_dev(div29, "class", "modal-content");
			add_location(div29, file$l, 129, 12, 6249);
			attr_dev(div30, "class", "modal-dialog");
			add_location(div30, file$l, 128, 8, 6209);
			attr_dev(div31, "class", "modal left fade in");
			attr_dev(div31, "id", "advance_list");
			attr_dev(div31, "role", "dialog");
			attr_dev(div31, "data-backdrop", "true");
			set_style(div31, "z-index", "9999", 1);
			set_style(div31, "width", "321px");
			add_location(div31, file$l, 127, 4, 6071);
			attr_dev(textarea, "rows", "20");
			set_style(textarea, "width", "100%");
			attr_dev(textarea, "id", "alt_text");
			add_location(textarea, file$l, 154, 20, 7448);
			attr_dev(div32, "class", "modal-body edit_options");
			add_location(div32, file$l, 153, 16, 7388);
			attr_dev(button8, "id", "alt_done");
			attr_dev(button8, "type", "button");
			attr_dev(button8, "class", "btn btn-light");
			attr_dev(button8, "data-bs-dismiss", "modal");
			add_location(button8, file$l, 157, 20, 7603);
			attr_dev(div33, "class", "modal-footer");
			add_location(div33, file$l, 156, 16, 7555);
			attr_dev(div34, "class", "modal-content");
			add_location(div34, file$l, 152, 12, 7343);
			attr_dev(div35, "class", "modal-dialog");
			add_location(div35, file$l, 151, 8, 7303);
			attr_dev(div36, "class", "modal fade");
			attr_dev(div36, "id", "alt_description");
			attr_dev(div36, "role", "dialog");
			set_style(div36, "z-index", "99999", 1);
			add_location(div36, file$l, 150, 4, 7199);
			attr_dev(div37, "class", "items_block");
			add_location(div37, file$l, 55, 0, 2568);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div37, anchor);
			append_dev(div37, div5);
			append_dev(div5, div4);
			append_dev(div4, div3);
			append_dev(div3, div1);
			append_dev(div1, div0);
			append_dev(div1, t1);
			append_dev(div1, button0);
			append_dev(div1, t3);
			append_dev(div1, button1);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, ul0);
			append_dev(div37, t6);
			append_dev(div37, div13);
			append_dev(div13, div12);
			append_dev(div12, div11);
			append_dev(div11, div7);
			append_dev(div7, button2);
			append_dev(div7, t8);
			append_dev(div7, div6);
			append_dev(div11, t10);
			append_dev(div11, div10);
			append_dev(div10, div9);
			append_dev(div9, div8);
			append_dev(div8, span);
			append_dev(div9, t11);
			append_dev(div9, input);
			append_dev(div10, t12);
			append_dev(div10, ul1);
			append_dev(div37, t13);
			append_dev(div37, div17);
			append_dev(div17, div16);
			append_dev(div16, div15);
			append_dev(div15, div14);
			append_dev(div37, t14);
			append_dev(div37, div24);
			append_dev(div24, div23);
			append_dev(div23, div22);
			append_dev(div22, div18);
			append_dev(div18, h4);
			append_dev(div18, t16);
			append_dev(div18, button3);
			append_dev(div22, t18);
			append_dev(div22, div20);
			append_dev(div20, div19);
			append_dev(div22, t19);
			append_dev(div22, div21);
			append_dev(div21, button4);
			append_dev(div21, t21);
			append_dev(div21, button5);
			append_dev(div37, t23);
			append_dev(div37, div31);
			append_dev(div31, div30);
			append_dev(div30, div29);
			append_dev(div29, div26);
			append_dev(div26, button6);
			append_dev(div26, t25);
			append_dev(div26, div25);
			append_dev(div29, t27);
			append_dev(div29, div28);
			append_dev(div28, ul2);
			append_dev(div28, t28);
			append_dev(div28, div27);
			append_dev(div27, button7);
			append_dev(div37, t30);
			append_dev(div37, div36);
			append_dev(div36, div35);
			append_dev(div35, div34);
			append_dev(div34, div32);
			append_dev(div32, textarea);
			append_dev(div34, t31);
			append_dev(div34, div33);
			append_dev(div33, button8);

			if (!mounted) {
				dispose = [
					listen_dev(button2, "click", /*click_handler*/ ctx[2], false, false, false),
					listen_dev(input, "keyup", /*searchItem*/ ctx[0], false, false, false),
					listen_dev(button6, "click", /*click_handler_1*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div37);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('InteractiveItem', slots, []);
	let snt_icon = "";

	function searchItem(_this) {
		document.querySelectorAll(".items_list").forEach(elm => {
			if (elm.textContent.toLowerCase().includes(_this.value.toLowerCase())) {
				AH.toggleDom(elm, 'show');
			} else {
				AH.toggleDom(elm, 'hide');
			}
		});
	}

	function createItems() {
		AH.selectAll('.main_items,.modal_items', 'html', '');
		document.getElementById("searchText").value = '';

		interactive_item.map(data => {
			for (let item in data) {
				let filter = AI.get('filter_item')
				? AI.get('filter_item').includes(item)
				: true;

				if (filter) {
					AH.insert("#main_items", `<li id="${item}" class="items_list font14">${item}</li>`, 'beforeend');
				}
			}
		});

		interactive_item.map(function (o) {
			Object.keys(o).forEach(function (key) {
				Object.keys(o[key]).map(function (e) {
					let item = o[key][e];

					if (item.hide != true) {
						document.querySelectorAll('.modal_items').forEach(elm => {
							AH.insert(elm, `<div id="${item.label}" data-html="${item.html}" data-type="${key}" class="${key} item_int thumbnail btn col-sm-5 border" style="max-width:100%;height:130px;background-image:url(${item.default_image});background-size:contain;background-position:center;background-repeat:no-repeat;overflow:hidden;background-color:#fff;"><div class="item_labelClass">${item.label}</div></div>`, 'beforeend');
						});
					}
				});
			});
		});

		AI.listen('#main_items', 'click', '.items_list', function (_this, e) {
			AH.selectAll(".items_list", 'removeClass', "colorremover");
			var show = _this.textContent;
			AH.selectAll('.item_int', 'hide');
			AH.selectAll('.' + show, 'show');
			_this.classList.add("colorremover");
			AH.getBS("#items_list", 'Modal').show();
		});

		AH.bind('#go_back', 'click', function (event) {
			AH.getBS("#interactive_items", 'Modal').show();
			AH.getBS("#items_list", 'Modal').hide();
		});

		AH.bind("#advance_id", 'click', function (event) {
			AH.getBS("#advance_list", 'Modal').show();
		});
	}

	const writable_props = [];

	Object_1$4.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InteractiveItem> was created with unknown prop '${key}'`);
	});

	const click_handler = () => AH.getBS('#items_list', 'Modal').hide();
	const click_handler_1 = () => AH.getBS('#advance_list', 'Modal').hide();
	$$self.$capture_state = () => ({ AH, snt_icon, searchItem, createItems });

	$$self.$inject_state = $$props => {
		if ('snt_icon' in $$props) snt_icon = $$props.snt_icon;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [searchItem, createItems, click_handler, click_handler_1];
}

class InteractiveItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$l, safe_not_equal, { createItems: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InteractiveItem",
			options,
			id: create_fragment$l.name
		});
	}

	get createItems() {
		return this.$$.ctx[1];
	}

	set createItems(value) {
		throw new Error("<InteractiveItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\CommentModal.svelte generated by Svelte v3.40.2 */

const { console: console_1$8 } = globals;
const file$m = "src\\components\\CommentModal.svelte";

function add_css$g(target) {
	append_styles(target, "svelte-9h2q0c", ".comment_tab.active{text-decoration:none;border:1px solid #ccc;border-bottom:1px solid #e9ecef;border-radius:3px}.mr{margin-right:8px}a{color:#b0281a;text-decoration:none!important}a:hover{color:#0d5bdd;text-decoration:none!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tbWVudE1vZGFsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtY1MsbUJBQW1CLEFBQUUsQ0FBQyxBQUN2QixlQUFlLENBQUUsSUFBSSxDQUNyQixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQ3RCLGFBQWEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDaEMsYUFBYSxDQUFFLEdBQUcsQUFDekIsQ0FBQyxBQUNVLEdBQUcsQUFBRSxDQUFDLEFBQ1YsWUFBWSxDQUFFLEdBQUcsQUFDckIsQ0FBQyxBQUVPLENBQUMsQUFBRSxDQUFDLEFBQ1IsS0FBSyxDQUFFLE9BQU8sQ0FDZCxlQUFlLENBQUUsSUFBSSxVQUFVLEFBQ25DLENBQUMsQUFFTyxPQUFPLEFBQUUsQ0FBQyxBQUNkLEtBQUssQ0FBRSxPQUFPLENBQ2QsZUFBZSxDQUFFLElBQUksVUFBVSxBQUNuQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNvbW1lbnRNb2RhbC5zdmVsdGUiXX0= */");
}

function create_fragment$m(ctx) {
	let button0;
	let t1;
	let div7;
	let div6;
	let div5;
	let div3;
	let ul;
	let li0;
	let a0;
	let t3;
	let li1;
	let a1;
	let t5;
	let li2;
	let a2;
	let t7;
	let div2;
	let div0;
	let button1;
	let span0;
	let t8;
	let t9;
	let div1;
	let button2;
	let span1;
	let t10;
	let t11;
	let div4;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button0 = element("button");
			button0.textContent = "Comment";
			t1 = space();
			div7 = element("div");
			div6 = element("div");
			div5 = element("div");
			div3 = element("div");
			ul = element("ul");
			li0 = element("li");
			a0 = element("a");
			a0.textContent = "Comments";
			t3 = space();
			li1 = element("li");
			a1 = element("a");
			a1.textContent = "Techcheck";
			t5 = space();
			li2 = element("li");
			a2 = element("a");
			a2.textContent = "Context";
			t7 = space();
			div2 = element("div");
			div0 = element("div");
			button1 = element("button");
			span0 = element("span");
			t8 = text("\r\n                            Add New");
			t9 = space();
			div1 = element("div");
			button2 = element("button");
			span1 = element("span");
			t10 = text("\r\n                            Add New");
			t11 = space();
			div4 = element("div");
			attr_dev(button0, "type", "button");
			attr_dev(button0, "id", "editor_comment_modal_btn");
			attr_dev(button0, "class", "btn btn-primary h");
			attr_dev(button0, "data-bs-toggle", "modal");
			attr_dev(button0, "data-bs-target", "#editor_comment_modal");
			set_style(button0, "position", "fixed");
			set_style(button0, "top", "48%");
			set_style(button0, "right", "-28px");
			set_style(button0, "transform", "rotate(-90deg)");
			set_style(button0, "z-index", "1200");
			add_location(button0, file$m, 471, 0, 22850);
			attr_dev(a0, "data-bs-toggle", "tab");
			attr_dev(a0, "href", "#comment_load");
			attr_dev(a0, "class", "active comment_tab");
			attr_dev(a0, "data-comment_type", "3");
			set_style(a0, "padding", "12px 15px");
			add_location(a0, file$m, 486, 24, 23555);
			add_location(li0, file$m, 486, 20, 23551);
			attr_dev(a1, "data-bs-toggle", "tab");
			attr_dev(a1, "href", "#techcheck_load");
			attr_dev(a1, "class", "comment_tab");
			attr_dev(a1, "data-comment_type", "4");
			set_style(a1, "padding", "12px 15px");
			add_location(a1, file$m, 487, 24, 23760);
			add_location(li1, file$m, 487, 20, 23756);
			attr_dev(a2, "data-toggle", "tab");
			attr_dev(a2, "href", "#context_load");
			attr_dev(a2, "class", "comment_tab font14");
			attr_dev(a2, "data-comment_type", "1");
			set_style(a2, "padding", "12px 15px");
			add_location(a2, file$m, 488, 24, 23961);
			add_location(li2, file$m, 488, 20, 23957);
			attr_dev(ul, "class", "nav nav-tabs commentTabs");
			set_style(ul, "margin-left", "15px");
			set_style(ul, "padding", "10px 0");
			add_location(ul, file$m, 485, 16, 23448);
			attr_dev(span0, "class", "icomoon-new-24px-add-comment-1 s3");
			add_location(span0, file$m, 493, 28, 24486);
			attr_dev(button1, "title", "Add New Comment");
			attr_dev(button1, "class", "btn add_new_comment float-right mr-sm");
			attr_dev(button1, "techcheck", "0");
			set_style(button1, "position", "relative");
			set_style(button1, "left", "3px");
			add_location(button1, file$m, 492, 24, 24326);
			attr_dev(div0, "id", "comment_load");
			attr_dev(div0, "class", "tab-pane fade in active");
			add_location(div0, file$m, 491, 20, 24245);
			attr_dev(span1, "class", "icomoon-new-24px-add-comment-1 s3");
			add_location(span1, file$m, 499, 28, 24856);
			attr_dev(button2, "title", "Add New Techcheck");
			attr_dev(button2, "class", "btn techcheck_comment float-right");
			attr_dev(button2, "techcheck", "1");
			add_location(button2, file$m, 498, 24, 24736);
			attr_dev(div1, "id", "techcheck_load");
			attr_dev(div1, "class", "tab-pane fade");
			add_location(div1, file$m, 497, 20, 24663);
			attr_dev(div2, "class", "tab-content comment_modal_button");
			add_location(div2, file$m, 490, 16, 24177);
			attr_dev(div3, "class", "editor_comment_header");
			add_location(div3, file$m, 484, 12, 23395);
			attr_dev(div4, "class", "max_height_initial modal-body");
			attr_dev(div4, "id", "comment_modal_body");
			add_location(div4, file$m, 505, 12, 25069);
			attr_dev(div5, "class", "editor_comment_box modal-content");
			attr_dev(div5, "id", "editor_comment_box");
			add_location(div5, file$m, 483, 8, 23311);
			attr_dev(div6, "class", "modal-dialog");
			attr_dev(div6, "role", "document");
			add_location(div6, file$m, 482, 4, 23259);
			attr_dev(div7, "class", "modal right fade");
			attr_dev(div7, "id", "editor_comment_modal");
			attr_dev(div7, "tabindex", "-1");
			attr_dev(div7, "role", "dialog");
			attr_dev(div7, "aria-labelledby", "myModalLabel2");
			add_location(div7, file$m, 481, 0, 23137);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, div5);
			append_dev(div5, div3);
			append_dev(div3, ul);
			append_dev(ul, li0);
			append_dev(li0, a0);
			append_dev(ul, t3);
			append_dev(ul, li1);
			append_dev(li1, a1);
			append_dev(ul, t5);
			append_dev(ul, li2);
			append_dev(li2, a2);
			append_dev(div3, t7);
			append_dev(div3, div2);
			append_dev(div2, div0);
			append_dev(div0, button1);
			append_dev(button1, span0);
			append_dev(button1, t8);
			append_dev(div2, t9);
			append_dev(div2, div1);
			append_dev(div1, button2);
			append_dev(button2, span1);
			append_dev(button2, t10);
			append_dev(div5, t11);
			append_dev(div5, div4);

			if (!mounted) {
				dispose = [
					listen_dev(a0, "click", /*loadComments*/ ctx[0].bind(this, 3), false, false, false),
					listen_dev(a1, "click", /*loadComments*/ ctx[0].bind(this, 4), false, false, false),
					listen_dev(a2, "click", /*loadComments*/ ctx[0].bind(this, 1), false, false, false)
				];

				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div7);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CommentModal', slots, []);
	let { funcname } = $$props;
	let { user_guid } = $$props;
	let { user } = $$props;
	let { questionGuid } = $$props;
	let { l } = $$props;
	let commentCguid = false;
	let CREATEAPP_PATH = baseUrl + "educator/project/";
	let userName = user.first_name + " " + user.last_name;

	// var userName = "<{$user_fname}> <{$user_lname}>";
	// var funcname = "<{$data.func}>";
	let anno_type_new = funcname == 'view_full_asset' ? "4" : "3";

	onMount(() => {
		init();
	});

	function loadComments(type) {
		const comment_tab_list = AH.selectAll('.comment_tab');

		Array.prototype.forEach.call(comment_tab_list, function (curr) {
			curr.classList.remove('active');
		});

		AH.select('[data-comment_type="' + type + '"]').classList.add('active');
		anno_type_new = type;
		let CurrGuid = AH.get('current_guid');

		if (AH && CurrGuid) {
			AH.set('comments_type', type);
			AH.activate(2);

			AH.ajax({
				url: `${CREATEAPP_PATH}?func=get_comments&content_guid=${CurrGuid}&user_guid=${user_guid}&add_ui=1&annotation_type=${type}`,
				withUrl: true
			}).then(res => {
				AH.activate(0);
				AH.select('#comment_modal_body').innerHTML = res;
				AH.initDropdown();
			});
		}
	}

	function init() {
		/*comment events*/
		AH.listen(document.body, 'click', '.open_comment', function (_this) {
			var guid = _this.closest('section').getAttribute('guid');

			if (typeof guid != 'undefined') {
				AH.activate(1);

				AH.ajax({
					url: baseUrl + `educator/project/?func=get_comments&content_guid=${guid}&user_guid=${user_guid}`,
					withUrl: true
				}).then(res => {
					AH.activate(0);
					AH.select('#comment_modal_body').innerHTML = res;
					AH.initDropdown();

					//$("[rel=tooltip]").tooltip();
					AH.getBS('#comment_modal', 'Modal').show();
				});
			}
		});

		/*reply buttons*/
		AH.listen(document.body, 'click', '.reply_textbox', _this => {
			var props = [
				{
					class: 'btn btn-info btn-sm',
					text: 'Reply',
					type: 'reply'
				},
				{
					class: 'btn btn-light btn-sm ml-2',
					text: 'Cancel',
					type: 'reply_cancel'
				}
			];

			if (AH.find(_this.parentElement, '.comment_btns', 'all').length < 1) {
				_this.parentElement.append(createButtons(props));
			}
		});

		AH.listen(document.body, 'click', '.comment_btns [btntype=reply]', function (_this) {
			replyOnComment(_this);
		});

		AH.listen(document.body, 'click', '.comment_btns [btntype=reply_cancel]', function (_this) {
			_this.parentElement.remove();
		});

		/*reply buttons end*/
		/*comment edit*/
		AH.listen(document.body, 'click', '.comment_edit', function (_this) {
			AH.find('.comment_footer', '.reply_textbox').value = '';

			if (AH.select('.comment_btns').hasOwnProperty('remove')) {
				AH.select('.comment_btns').remove();
			}

			AH.find(_this.closest('.comment_container'), '.reply_textbox').classList.add('h');

			let props = [
				{
					class: 'btn btn-info btn-sm',
					text: 'Save',
					type: 'edit'
				},
				{
					class: 'btn btn-light btn-sm ml-md',
					text: 'Cancel',
					type: 'edit_cancel'
				}
			];

			if (AH.find(_this.closest('.comment_container'), '.comment_btns', 'all').length < 1) {
				AH.find(_this.closest('.comment_container'), '.comment_footer').append(createButtons(props));
				AH.find(_this.closest('.comment_container'), '.comment_footer').classList.add('comment_foo');
			}

			let commentText = AH.find(_this.closest('.comment_container'), '.comment_text');
			window.commentTextData = commentText.innerText;
			commentText.setAttribute('contentEditable', true);
			commentText.focus();

			AH.addClass(commentText, [
				'comment_text_editing',
				'darkgrey_border',
				'pt-xs',
				'pb-xs',
				'pl-xs',
				'pr-xs'
			]);
		});

		AH.listen(document.body, 'click', '.comment_container', function (_this) {
			if (typeof AH != "undefined" && AH.get('current_guid')) {
				let find_id = AH.get('current_guid') + "_" + _this.getAttribute('id');

				try {
					document.getElementById(find_id).scrollIntoView({ block: 'end', behavior: 'smooth' });
				} catch(e) {
					
				} // when scrollIntoView not found.
			}
		});

		/*comment delete*/
		AH.listen(document.body, 'click', '.comment_delete', function (_this) {
			deleteComment(_this);
		});

		AH.listen(document.body, 'click', '.comment_btns [btntype=edit],.comment_btns [btntype=edit_cancel]', function (_this) {
			editComment(_this);
		});

		AH.bind('#comment_modal', 'hide.bs.modal', function (event) {
			AH.find('#comment_modal', '.modal-body').innerHTML = '';
		});

		AH.listen(document.body, 'click', '.comment_btns [btntype=comment],.comment_btns [btntype=comment_cancel]', function (_this) {
			newComment(_this);
		});

		AH.listen(document.body, 'click', '.resolve_btn', function (_this) {
			resolveComment(_this);
		});

		AH.listen(document.body, 'click', '.add_new_comment, .techcheck_comment', function (_this) {
			addComment(_this.getAttribute('techcheck'));
		});

		AH.listen(document.body, 'click', '.comment_resolved_btn', function (_this) {
			let cmtResolvNode = AH.find(_this, '.comment_resolved_ic');

			if (cmtResolvNode.classList.contains('icomoon-arrow-down')) {
				cmtResolvNode.classList.remove('icomoon-arrow-down');
				cmtResolvNode.classList.add('icomoon-arrow-right-1');
			} else {
				cmtResolvNode.classList.remove('icomoon-arrow-right-1');
				cmtResolvNode.classList.add('icomoon-arrow-down');
			}

			var resolvedComment = _this.getAttribute('id');
			AH.selectAll('.comment_container_head[data-resolve="' + resolvedComment + '"]', 'toggleClass', 'h');
		});

		AH.listen(document, "click", ".delete_comment_block", function (_this) {
			AH.parent(_this, ".comment_container").remove();
		});
	}

	function createButtons(props) {
		let buttons = document.createElement('div');
		buttons.setAttribute('class', 'comment_btns mt-1');

		for (let i = 0; i < props.length; i++) {
			let btn = document.createElement('button');

			AH.setAttr(btn, {
				class: props[i].class,
				text: props[i].text,
				btnType: props[i].type
			});

			AH.select(btn, 'text', props[i].text);
			buttons.append(btn);
		}

		return buttons;
	}

	

	function replyOnComment(t) {
		let btnType = t.getAttribute('btntype');
		let reply = AH.find(t.closest('.comment_footer'), '.reply_textbox').value;

		if (reply == "") {
			AH.showmsg(`${l.please_enter_reply_comment}`);
			return false;
		}

		let contentGuid = t.closest('.comment_container_head').getAttribute('content-guid');
		let creatorGuid = t.closest('.comment_container_head').getAttribute('creator-guid');
		let userGuidR = user_guid;
		let anno_id = t.closest('.comment_container').getAttribute('anno_id');
		let id = t.closest('.comment_container').getAttribute('id');

		//console.log(contentGuid, creatorGuid, userGuidR);
		AH.find(t.closest('.comment_footer'), '.reply_textbox', { action: 'value', actionData: '' });

		t.closest('.comment_btns').remove();

		if (btnType == 'reply') {
			var _data = {
				user_guid_r: userGuidR,
				content_guid: contentGuid,
				creator_guid: creatorGuid,
				text: reply,
				annotation_type: anno_type_new,
				parent_anno_id: anno_id
			};

			AH.activate(1, '.comment_modal_body');

			AH.ajax({
				url: `${CREATEAPP_PATH}?func=save_reply`,
				data: _data
			}).then(data => {
				if (data != "") {
					addUI(contentGuid);
					var noOfComment = AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers').innerHTML;

					if (noOfComment) {
						noOfComment = noOfComment.trim();

						if (isNaN(noOfComment) || noOfComment == "") {
							noOfComment = 1;
						} else {
							noOfComment = parseInt(noOfComment) + 1;
						}

						AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers', { action: 'html', actionData: noOfComment });
					}
				} else {
					AH.activate(0, '.comment_modal_body');
					AH.showmsg('Reply cannot be saved');
				}
			});
		}
	}

	

	function editComment(t) {
		var btnType = t.getAttribute('btntype');
		var comment = AH.find(t.closest('.comment_container'), '.comment_text').innerHTML;
		var creatorGuid = t.closest('.comment_container_head').getAttribute('creator-guid');
		var contentGuid = t.closest('.comment_container_head').getAttribute('content-guid');
		var timestamp = t.closest('.comment_container').getAttribute('time-span');
		var id = t.closest('.comment_container').getAttribute('id');
		var anno_id = t.closest('.comment_container').getAttribute('anno_id');
		AH.find(t.closest('.comment_container'), '.comment_text').setAttribute('contentEditable', false);
		AH.find(t.closest('.comment_container'), '.comment_text').classList.remove(['darkgrey_border', 'pt-xs', 'pb-xs', 'pl-xs', 'pr-xs']);

		if (!AH.find(t.closest('.comment_footer'), '.reply_textbox')?.classList.contains('disable_reply')) {
			AH.find(t.closest('.comment_footer'), '.reply_textbox').value = '';
			AH.find(t.closest('.comment_footer'), '.reply_textbox').classList.remove('h');
		}

		if (!AH.find(t.closest('.comment_container'), '.comment_footer').classList.contains('last_thread')) {
			AH.find(t.closest('.comment_container'), '.comment_footer').classList.remove('comment_foo');
		}

		t.closest('.comment_btns').remove();

		if (btnType == 'edit') {
			comment = comment.replace(new RegExp('<div>', 'g'), '\n');
			comment = comment.replace(new RegExp('<br>', 'g'), '\n');
			comment = comment.replace(new RegExp('</div>', 'g'), '');

			let _data = {
				user_guid_r: user_guid,
				content_guid: contentGuid,
				creator_guid: creatorGuid,
				text: comment,
				timestamp,
				id,
				anno_id,
				tags: typeof AH != "undefined" && AH.get('comments_type')
				? AH.get('comments_type')
				: -2
			};

			console.log('data', _data);

			AH.ajax({
				url: `${CREATEAPP_PATH}?func=edit_comment`,
				data: _data
			}).then(data => {
				if (data != "") {
					AH.showmsg("Comment updated successfully.");
				} else {
					AH.showmsg("Error in updating comment, Please try again.");
				}
			});
		}
	}

	

	function deleteComment(t) {
		let deleteAll = t.getAttribute('delete') == "all" ? true : false;
		let userGuidR = t.closest('.comment_container').getAttribute('user-guid');
		let creatorGuid = t.closest('.comment_container_head').getAttribute('creator-guid');
		let contentGuid = t.closest('.comment_container_head').getAttribute('content-guid');
		let timestamp = t.closest('.comment_container').getAttribute('time-span');
		let id = t.closest('.comment_container').getAttribute('id');

		let _data = {
			user_guid_r: userGuidR,
			base: contentGuid,
			creator_guid: creatorGuid,
			timestamp,
			id,
			tags: typeof AH != "undefined" && AH.get('comments_type')
			? AH.get('comments_type')
			: -2
		};

		if (deleteAll) {
			_data = {
				delete_all: "1",
				base: contentGuid,
				creator_guid: creatorGuid
			};
		}

		AH.activate(2);

		AH.ajax({
			url: baseUrl + "store.php?action=destroy",
			method: "POST",
			data: _data
		}).then(res => {
			if (res == true || res.length > 5) {
				addUI(contentGuid);
				var comment_numbers = AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers').innerHTML;

				if (comment_numbers) {
					comment_numbers = comment_numbers.trim();

					if (isNaN(comment_numbers) || comment_numbers == "") {
						comment_numbers = 1;
					} else {
						if (comment_numbers == "0") {
							comment_numbers = 0;
						} else {
							comment_numbers = parseInt(comment_numbers) - 1;
						}
					}

					AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers', {
						action: 'html',
						actionData: comment_numbers
					});

					AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers', {
						action: 'css',
						actionData: { display: 'block' }
					});
				}

				AH.showmsg("Comment deleted successfully.");
			} else {
				AH.showmsg("Error in deleting comment, Please try again.");
			}

			AH.activate(0);
		});
	}

	

	function resolveComment(t) {
		var userGuidR = user_guid;
		var creatorGuid = t.closest('.comment_container_head').getAttribute('creator-guid');
		var contentGuid = t.closest('.comment_container_head').getAttribute('content-guid');
		var anno_id = t.closest('.comment_container').getAttribute('anno_id');
		var id = t.closest('.comment_container').getAttribute('id');

		var _data = {
			user_guid_r: userGuidR,
			content_guid: contentGuid,
			creator_guid: creatorGuid,
			anno_id,
			id
		};

		AH.activate(1, '.comment_modal_body');

		AH.ajax({
			url: `${CREATEAPP_PATH}?func=resolve_comment`,
			data: _data
		}).then(data => {
			if (data != "") {
				addUI(contentGuid);
				AH.showmsg("Comment resolved successfully.");
			} else {
				AH.showmsg("Error in resolving comment,Please try again.");
				AH.activate(0, '.comment_modal_body');
			}
		});
	}

	

	function newComment(t) {
		var btnType = t.getAttribute('btntype');
		var techcheck = t.getAttribute('techcheck');

		if (btnType == 'comment') {
			var comment = t.closest('.comment_container').querySelector('.comment_text').querySelector('textarea').value;
			comment = comment.trim();

			if (comment == "") {
				AH.showmsg(LANG.fill_com);
				return false;
			}

			var contentGuid = t.closest('.comment_container').getAttribute('content-guid');

			let _data = {
				user_guid_r: user.user_guid,
				content_guid: contentGuid,
				text: comment,
				annotation_type: anno_type_new,
				tags: techcheck == 1 ? -5 : -2
			};

			AH.activate(2);

			AH.ajax({
				url: `${CREATEAPP_PATH}?func=new_comment`,
				data: _data
			}).then(data => {
				if (data != "") {
					addUI(contentGuid);
					let comment_numbers = AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers').innerHTML;

					if (comment_numbers) {
						comment_numbers = comment_numbers.trim();

						if (isNaN(comment_numbers) || comment_numbers == "") {
							comment_numbers = 1;

							AH.find(`[comment_guid='${contentGuid}']`, '.icomoon-new-24px-add-comment-1', {
								action: 'remove',
								actionData: 'icomoon-new-24px-add-comment-1'
							});

							AH.find(`[comment_guid='${contentGuid}']`, '.icomoon-new-24px-add-comment-1', {
								action: 'add',
								actionData: 'icomoon-24px-comment-2'
							});
						} else {
							comment_numbers = parseInt(comment_numbers) + 1;
						}

						AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers', {
							action: 'html',
							actionData: comment_numbers
						});

						AH.find(`[comment_guid='${contentGuid}']`, '.comment_numbers', {
							action: 'css',
							actionData: { display: "block" }
						});
					}

					AH.getBS('#comment_modal', 'Modal').hide?.();
					AH.showmsg("Comment added successfully.");
				} else {
					AH.showmsg("Error in adding comment, Please try again.");
				}

				AH.activate(0);
			});
		} else {
			//$('.comment_container').remove();
			AH.parent(t, '.comment_container').remove();

			AH.getBS('#comment_modal', 'Modal').hide?.();
		}
	}

	

	function addComment(techcheck) {
		var new_block_count = 1;

		document.querySelectorAll('#comment_modal  #comment_modal_body .comment_container').forEach((elm, i) => {
			if (elm.querySelector(".comment_text > textarea").value == "") {
				new_block_count += 1;
			}
		});

		if (new_block_count > 1) {
			AH.showmsg(LANG.please_fill_comment_before_adding_new_comment_block);
			return false;
		}

		let user_nm_char = userName.trim();

		userName = user_nm_char.length == '0'
		? `${user.first_name} ${user.last_name}`
		: userName;

		commentCguid = commentCguid ? commentCguid : questionGuid;

		var commentHtml = `<div 
                            class="comment_container card_shadow_2 d-inline-block relative bg-white w-100 pl-3 pr-3 pb-3 pt-1 mt-3" content-guid="${commentCguid}"
                        >
                            <div class="comment_header clearfix">
                                <div class="comment_user line_height3 float-left d-inline-block">
                                    <span class="icomoon-bubble-user s3"></span>
                                </div>
                                <div class="comment_name d-inline-block ml-1 font-weight-normal float-left font14">
                                    <p rel="tooltip">${userName}<br/></p>
                                </div>
                            </div>
                            <div class="comment_text mb font12 min_height40 overflow-y">
                                <textarea class="w-100 rounded" placeholder="Comment..."></textarea>
                            </div>
                            <div class="comment_footer comment_foo m-t-n-sm m-l-n-sm m-r-n-sm m-b-n-sm p-md">
                                <div class="comment_btns mt-1">
                                    <button class="btn btn-light btn-sm float-right delete_comment_block ml-1">${l.delete}</button>
                                    <button class="btn btn-light btn-sm float-right ml-md" btntype="comment_cancel">${l.cancel}</button>
                                    <button class="btn btn-primary mr-1 text-white btn-sm float-right" btntype="comment" techcheck = "${techcheck}">Comment</button>
                                </div>
                            </div>
                        </div>`;

		AH.insert('#comment_modal_body', commentHtml, 'beforeend');
		new_block_count = new_block_count + 1;

		try {
			let objDiv = document.querySelector('#comment_modal_body');
			objDiv.scrollTop = objDiv.scrollHeight;
		} catch(err) {
			console.warn(err);
		}
	}

	function addUI(contentGuid) {
		if (funcname != "view_full_asset") {
			AH.ajax({
				url: `${CREATEAPP_PATH}?func=get_comments&content_guid=${contentGuid}&user_guid=${user_guid}&add_ui=1&annotation_type=${anno_type_new}`,
				withUrl: true
			}).then(res => {
				AH.activate(0);
				AH.select('#comment_modal_body').innerHTML = res;
				AH.initDropdown();
			});
		} else {
			AH.ajax({
				url: `${CREATEAPP_PATH}?func=get_comments&content_guid=${contentGuid}&user_guid=${user_guid}`,
				withUrl: true,
				type: "GET"
			}).then(res => {
				AH.activate(0);
				AH.select('#comment_modal_body').innerHTML = res;
				AH.initDropdown();
			});
		}
	}

	
	const writable_props = ['funcname', 'user_guid', 'user', 'questionGuid', 'l'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$8.warn(`<CommentModal> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('funcname' in $$props) $$invalidate(1, funcname = $$props.funcname);
		if ('user_guid' in $$props) $$invalidate(2, user_guid = $$props.user_guid);
		if ('user' in $$props) $$invalidate(3, user = $$props.user);
		if ('questionGuid' in $$props) $$invalidate(4, questionGuid = $$props.questionGuid);
		if ('l' in $$props) $$invalidate(5, l = $$props.l);
	};

	$$self.$capture_state = () => ({
		onMount,
		AH,
		funcname,
		user_guid,
		user,
		questionGuid,
		l,
		commentCguid,
		CREATEAPP_PATH,
		userName,
		anno_type_new,
		loadComments,
		init,
		createButtons,
		replyOnComment,
		editComment,
		deleteComment,
		resolveComment,
		newComment,
		addComment,
		addUI
	});

	$$self.$inject_state = $$props => {
		if ('funcname' in $$props) $$invalidate(1, funcname = $$props.funcname);
		if ('user_guid' in $$props) $$invalidate(2, user_guid = $$props.user_guid);
		if ('user' in $$props) $$invalidate(3, user = $$props.user);
		if ('questionGuid' in $$props) $$invalidate(4, questionGuid = $$props.questionGuid);
		if ('l' in $$props) $$invalidate(5, l = $$props.l);
		if ('commentCguid' in $$props) commentCguid = $$props.commentCguid;
		if ('CREATEAPP_PATH' in $$props) CREATEAPP_PATH = $$props.CREATEAPP_PATH;
		if ('userName' in $$props) userName = $$props.userName;
		if ('anno_type_new' in $$props) anno_type_new = $$props.anno_type_new;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [loadComments, funcname, user_guid, user, questionGuid, l, init];
}

class CommentModal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$m,
			create_fragment$m,
			safe_not_equal,
			{
				funcname: 1,
				user_guid: 2,
				user: 3,
				questionGuid: 4,
				l: 5,
				init: 6
			},
			add_css$g
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommentModal",
			options,
			id: create_fragment$m.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*funcname*/ ctx[1] === undefined && !('funcname' in props)) {
			console_1$8.warn("<CommentModal> was created without expected prop 'funcname'");
		}

		if (/*user_guid*/ ctx[2] === undefined && !('user_guid' in props)) {
			console_1$8.warn("<CommentModal> was created without expected prop 'user_guid'");
		}

		if (/*user*/ ctx[3] === undefined && !('user' in props)) {
			console_1$8.warn("<CommentModal> was created without expected prop 'user'");
		}

		if (/*questionGuid*/ ctx[4] === undefined && !('questionGuid' in props)) {
			console_1$8.warn("<CommentModal> was created without expected prop 'questionGuid'");
		}

		if (/*l*/ ctx[5] === undefined && !('l' in props)) {
			console_1$8.warn("<CommentModal> was created without expected prop 'l'");
		}
	}

	get funcname() {
		throw new Error("<CommentModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set funcname(value) {
		throw new Error("<CommentModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get user_guid() {
		throw new Error("<CommentModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set user_guid(value) {
		throw new Error("<CommentModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get user() {
		throw new Error("<CommentModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set user(value) {
		throw new Error("<CommentModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get questionGuid() {
		throw new Error("<CommentModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set questionGuid(value) {
		throw new Error("<CommentModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get l() {
		throw new Error("<CommentModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<CommentModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		return this.$$.ctx[6];
	}

	set init(value) {
		throw new Error("<CommentModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */

var jquery = createCommonjsModule(function (module) {
( function( global, factory ) {

	{

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );
});

const ITEMPLAYER = {};
const tabindex = {
    z: 1,
    n: "-1"
};
const DOWNLOAD_ASSETS_URL = '//s3.amazonaws.com/jigyaasa_download/';
const DOWNLOAD_IMAGE_URL = '//s3.amazonaws.com/jigyaasa_content_static/';
const iframe_title = {
    '0': 'Inline Player',
    'object3d': '3-D Object Viewer',
    'brain_games': 'Brain Games',
    'quiz': 'Quiz Player',
    'wguvideo': 'Video Player',
    'flashcard': 'Flashcard Player',
    'external': 'Simulation Player',
    'video': 'Video Player',
    'pdf': 'PDF Viewer'
};
let DEFAULTMATHOPTIONS = {
    delimiters: [
        { left: '\\begin{equation}', right: '\\end{equation}', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
    ],
    macros: {
        '\\mbox': '',
        '$': '\\$'
    },
    ignoredTags: ["script", "noscript", "style", "textarea", "code", "option"],
};

ITEMPLAYER.download = function (player, asset, title, description, img) {
    let r = new RegExp('^(?:[a-z]+:)?//', 'i');
    let ASSET_URL = r.test(asset) ? asset : DOWNLOAD_ASSETS_URL + asset;
    let download_html = '<div class="row download_asset"><table class="border"><tbody><tr><td class="align-middle span1"><img src="' + DOWNLOAD_IMAGE_URL + img + '" class="img-polaroid"></td><td class="align-middle"><h3><strong>' + title + '</strong></h3><p id="descript" class="descript-downld">' + description + '</p></td><td class="align-middle span3"><a tabindex="' + tabindex.z + '" class="btn btn-primary btn-block" href="' + ASSET_URL + '" target="_blank">Download</a></td></tr></tbody></table></div>';
    if (!(player instanceof HTMLElement)) {
        player = document.querySelector(player);
    }
    player.innerHTML = download_html;
    document.querySelector('.descript-downld').style.display = 'block';
    document.querySelector('.descript-downld').style.margin = '0';
};
ITEMPLAYER.test = function (player, content_guid, player_id, asset, embed, no_of_attempts) {
    AH.ajax({
        url: baseUrl + 'index.php',
        data: { 'func': 'start_test', 'player_id': content_guid + '_' + player_id, 'assignment_code': asset, 'is_player': 1, 'embed': embed, 'no_of_attempts': no_of_attempts, 'ajax': 1 },
    }).then((data) => {
        if (data) {
            AH.insert(player, data, 'afterend');
        }
    });
};

ITEMPLAYER.stepplayer = function () { };
const ucTimeline = {
    inViewport: function (element, detectPartial) {
        element = jquery(element);
        detectPartial = (!!detectPartial);
        var viewport = jquery(window),
            vpWidth = viewport.width(),
            vpHeight = viewport.height(),
            vpTop = viewport.scrollTop(),
            vpBottom = vpTop + vpHeight,
            vpLeft = viewport.scrollLeft(),
            vpRight = vpLeft + vpWidth,

            elementOffset = element.offset(),
            elementTopArea = elementOffset.top + ((detectPartial) ? element.height() : 0),
            elementBottomArea = elementOffset.top + ((detectPartial) ? 0 : element.height()),
            elementLeftArea = elementOffset.left + ((detectPartial) ? element.width() : 0),
            elementRightArea = elementOffset.left + ((detectPartial) ? 0 : element.width());
        return ((elementBottomArea <= vpBottom) && (elementTopArea >= vpTop)) && ((elementRightArea <= vpRight) && (elementLeftArea >= vpLeft));
    },
    ucNewSlideshow: function () {
        var divSlide = document.querySelectorAll('#columnize #slide');
        var myNodeList = divSlide.length;
        for (var i = 0; i < myNodeList; i++) {
            if (!divSlide[i].closest('#authoringSection')) {
                var type = divSlide[i].getAttribute('type');
                if (type == 'slideshow') {
                    var timeline = divSlide[i];

                    jquery('#previewSection [type=slideshow] section').not(jquery('#previewSection #columnize [type=slideshow] section')).addClass('carousel-item top48');
                    jquery('#previewSection [type=slideshow] section header').not(jquery('#previewSection #columnize [type=slideshow] section header')).addClass('tip-c mt-mdx');
                    jquery('#previewSection [type=slideshow] section article').not(jquery('#previewSection #columnize [type=slideshow] section article')).addClass('tip-c mt-mdx');
                    jquery('#previewSection [type=slideshow]').not(jquery('#previewSection #columnize [type=slideshow]')).each(function (i, ele) {
                        if (jquery('#columnize [type=slideshow]').children('BR')) {
                            jquery('#columnize [type=slideshow]').children('BR').remove();
                        }
                        jquery(ele).children('section:first').addClass('active');
                    });

                    timeline.insertAdjacentHTML('afterbegin', '<a class="carousel-control-prev index2 width1" href="#myCarousel" data-slide="prev"> <span class="carousel-control-prev-icon icomoon-arrow-left ann_text text-body fa.s7"></span> </a>');
                    timeline.insertAdjacentHTML('afterbegin', '<a class="carousel-control-next index2 width1" href="#myCarousel" data-slide="next"> <span class="carousel-control-next-icon icomoon-arrow-right-2 ann_text text-body fa.s7"></span> </a>');
                    jquery('#previewSection [type=slideshow]').wrapInner('<div class=\'carousel slide\' id=\'myCarousel\' data-ride=\'carousel\'></div>');
                    jquery('#previewSection [type=slideshow] section').wrapAll('<div class=\'carousel-inner overflow-initial min_height_352\' type=\'slideshow\'></div>');
                }
            }
        }
    },
    ucNewSubSlideshow: function () {
        let divSlide = jquery('#columnize #slide');
        let myNodeList = divSlide.length;
        let slideNoSub = 1;
        let showSlideNumber = 1;
        if (navigator.appName == 'Microsoft Internet Explorer' || !!(navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/rv:11/)) || (typeof jquery.browser !== 'undefined' && jquery.browser.msie == 1)) {
            if (jquery('#columnize div[type = "sub-slideshow"]').find('.ucie_subslider').length < 0) {
                jquery('#columnize div[type = "sub-slideshow"]').append('<div class="ucie_subslider"><input type="range" min="0" max="100" value="0" id="myRange" class="uc_input_slider ucie_input_slider"></div>');
            }
        } else {
            if (jquery('#columnize div[type = "sub-slideshow"]').find('.uc_subslider').length < 0) {
                jquery('#columnize div[type = "sub-slideshow"]').append('<div class="uc_subslider ml-sm mr-sm"><input type="range" min="0" max="100" value="0" id="myRange" class="uc_input_slider"></div>');
            }
        }
        let i;
        for (i = 0; i < myNodeList; i++) {
            let type = divSlide[i].getAttribute('type');
            if (type == 'sub-slideshow') {
                let timeline = divSlide[i];
                jquery('#columnize [type=sub-slideshow] section').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\'] section')).addClass('hideClass');
                jquery('#columnize [type=sub-slideshow]').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\']')).each(function (i, ele) {
                    if (jquery('#columnize [type=sub-slideshow]').children('BR')) {
                        jquery('#columnize [type=sub-slideshow]').children('BR').remove();
                    }

                    jquery(ele).children('section:first').removeClass('hideClass').addClass('active');
                });
                let stepsData = jquery('#columnize div[type = "sub-slideshow"] section').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\'] section'));
                for (i = 0; i < stepsData.length; i++) {
                    stepsData[i].setAttribute('id', 'uc_subslide_section_' + i);
                }

                let calculateStep = 100 / (stepsData.length - 1);
                jquery('.uc_input_slider').attr('step', calculateStep.toFixed(2));
                if (jquery('.widthRowTwo').length < 2) {
                    timeline.insertAdjacentHTML('afterbegin', '<div class="row widthRowTwo"><div class="col-lg-12 row pr-0"><div class="np classText col-4 col-xs-4 col-md-4 col-lg-4"><a class="left uc_sub_prev carousel-control" href="#myCarousel" data-slide="prev"><span class="btn btn-primary">&larr; Previous</span></a></div><div class=" col-4 col-xs-4 col-md-4 col-lg-4 uc_sub_margin"><span class="uc_show_progress">' + showSlideNumber + '/' + jquery('#columnize').find('[type=sub-slideshow]').children('section').length + '</span></div><div class="np classTextRight col-4 col-xs-4 col-md-4 col-lg-4 pr-0"><a class="right uc_sub_next  carousel-control" href="#myCarousel" data-slide="next"><span class="btn btn-primary">Next &rarr;</span></a></div></div></div>');
                }
                if (jquery('.widthRow').length < 2) {
                    jquery('#columnize div[type = "sub-slideshow"]').append('<div class="row widthRow"><div class="col-lg-12 row pr-0"><div class="np classText col-4 col-xs-4 col-md-4 col-lg-4"><a class="left uc_sub_prev uc_subprev_bottom carousel-control" href="#myCarousel" data-slide="prev"><span class="btn btn-primary">&larr; Previous</span></a></div><div class="col-4 col-xs-4 col-md-4 col-lg-4 uc_sub_margin"><span class="uc_showprogress_bottom">' + showSlideNumber + '/' + jquery('#columnize').find('[type=sub-slideshow]').children('section').length + '</span></div><div class="np classTextRight col-4 col-xs-4 col-md-4 col-lg-4 pr-0"><a class="right uc_sub_next uc_subnext_bottom  carousel-control" href="#myCarousel" data-slide="next"><span class="btn btn-primary">Next &rarr;</span></a></div></div></div>');
                }
            }
        }

        jquery('.uc_input_slider').bind('click', function () {
            let valueStep = jquery(this).val();
            let stepsData = jquery('#columnize div[type = "sub-slideshow"] section').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\']')).length - 1;
            let calculateStep = 0;
            if (valueStep == 0) {
                calculateStep = 0;
            } else {
                calculateStep = Math.ceil((valueStep * stepsData) / 100);
            }
            let sectionData = jquery('#columnize div[type = "sub-slideshow"] section').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\'] section'));
            let i;
            for (i = 0; i < sectionData.length; i++) {
                let checkSection = sectionData[i].id.substr(20);
                if (calculateStep == checkSection) {
                    showSlideNumber = calculateStep + 1;
                    let totChild = jquery('#columnize div[type = "sub-slideshow"] section').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\'] section'));
                    for (i = 0; i < totChild.length; i++) {
                        if (totChild[i].getAttribute('class').indexOf('active') != -1) {
                            slideNoSub = i + 1;
                            let current = jquery('#' + totChild[i].id);
                            current.removeClass('active');
                            current.removeClass('fadeInLeft');
                            current.removeClass('fadeInRight');
                            current.addClass('hideClass');
                        }
                    }
                    let prevEl = sectionData[i].id;
                    jquery('#' + prevEl).addClass('active');
                    jquery('#' + prevEl).addClass('animated');
                    jquery('#' + prevEl).addClass('fadeInLeft');
                    jquery('#' + prevEl).removeClass('hideClass');
                    if (jquery(this).parents('#previewSection').length > 0) {
                        document.querySelector('#previewSection .uc_show_progress').innerHTML = showSlideNumber + '/' + totChild.length;
                        document.querySelector('#previewSection .uc_showprogress_bottom').innerHTML = showSlideNumber + '/' + totChild.length;
                    } else {
                        document.querySelector('#columnize .uc_show_progress').innerHTML = showSlideNumber + '/' + totChild.length;
                        document.querySelector('#columnize .uc_showprogress_bottom').innerHTML = showSlideNumber + '/' + totChild.length;
                    }
                    jquery('.uc_input_slider').attr('value', valueStep);
                }
            }
        });

        jquery('.uc_sub_prev').bind('click', function () {
            let select = jquery('#columnize div[type = "sub-slideshow"]').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\']'));
            let totChild = select.children('section');
            for (let i = 0; i < totChild.length; i++) {
                if (totChild[i].getAttribute('class').indexOf('active') != -1) {
                    slideNoSub = i + 1;
                }
            }
            let current = select.children('.active');
            let prevEl = current.prev('section');
            if (slideNoSub == totChild.length || slideNoSub >= 1) {
                if (prevEl.length == 1) {
                    showSlideNumber--;
                    prevEl = current.prev();
                    current.removeClass('active');
                    current.removeClass('fadeInLeft');
                    current.removeClass('fadeInRight');
                    current.addClass('hideClass');
                    prevEl.addClass('active');
                    prevEl.addClass('animated');
                    prevEl.addClass('fadeInLeft');
                    prevEl.removeClass('hideClass');
                } else {
                    showSlideNumber = 4;
                    current.removeClass('active');
                    current.removeClass('fadeInLeft');
                    current.removeClass('fadeInRight');
                    current.addClass('hideClass');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:last').addClass('active');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:last').addClass('animated');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:last').addClass('fadeInLeft');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:last').removeClass('hideClass');
                }
            } else {
                slideNoSub = 1;
            }
            if (jquery(this).parents('#previewSection').length > 0) {
                document.querySelector('#previewSection .uc_show_progress').innerHTML = showSlideNumber + '/' + totChild.length;
                document.querySelector('#previewSection .uc_showprogress_bottom').innerHTML = showSlideNumber + '/' + totChild.length;
            } else {
                document.querySelector('#columnize .uc_show_progress').innerHTML = showSlideNumber + '/' + totChild.length;
                document.querySelector('#columnize .uc_showprogress_bottom').innerHTML = showSlideNumber + '/' + totChild.length;
            }
            let stepsData = jquery('#columnize div[type = "sub-slideshow"] section').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\'] section')).length - 1;
            let calculateStep = 0;
            if (showSlideNumber == 1) {
                calculateStep = 0;
            } else {
                calculateStep = (((showSlideNumber - 1) / stepsData) * 100);
            }
            jquery('.uc_input_slider').attr('value', calculateStep);
        });
        jquery('.uc_sub_next').bind('click', function () {
            let select = jquery('#columnize div[type = "sub-slideshow"]').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\']'));
            let totChild = select.children('section');
            for (let i = 0; i < totChild.length; i++) {
                if (totChild[i].getAttribute('class').indexOf('active') != -1) {
                    slideNoSub = i + 1;
                }
            }
            let current = select.children('.active');
            let prevEl = current.next('section');
            if (slideNoSub < totChild.length) {
                if (prevEl.length == 1) {
                    showSlideNumber++;
                    prevEl = current.next();
                    current.removeClass('active');
                    current.removeClass('fadeInRight');
                    current.removeClass('fadeInLeft');
                    current.addClass('hideClass');
                    prevEl.addClass('animated');
                    prevEl.addClass('fadeInRight');
                    prevEl.addClass('active');
                    prevEl.removeClass('hideClass');
                } else {
                    showSlideNumber = 1;
                    current.removeClass('active');
                    current.removeClass('fadeInRight');
                    current.removeClass('fadeInLeft');
                    current.addClass('hideClass');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:first').addClass('animated');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:first').addClass('fadeInRight');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:first').addClass('active');
                    prevEl = jquery('#columnize div[type = "sub-slideshow"]').children('section:first').removeClass('hideClass');
                }
            } else {
                slideNoSub = 1;
            }
            if (jquery(this).parents('#previewSection').length > 0) {
                document.querySelector('#previewSection .uc_show_progress').innerHTML = showSlideNumber + '/' + totChild.length;
                document.querySelector('#previewSection .uc_showprogress_bottom').innerHTML = showSlideNumber + '/' + totChild.length;
            } else {
                document.querySelector('.uc_show_progress').innerHTML = showSlideNumber + '/' + totChild.length;
                document.querySelector('.uc_showprogress_bottom').innerHTML = showSlideNumber + '/' + totChild.length;
            }
            let stepsData = jquery('#columnize div[type = "sub-slideshow"] section').not(jquery('#authoringSection #columnize div[type = \'sub-slideshow\'] section')).length - 1;
            let calculateStep = 0;
            if (showSlideNumber == 1) {
                calculateStep = 0;
            } else {
                calculateStep = (((showSlideNumber - 1) / stepsData) * 100);
            }
            jquery('.uc_input_slider').attr('value', calculateStep);
        });
    },
    ucInit: function () {
        ucTimeline.ucNewSlideshow();
        ucTimeline.ucNewSubSlideshow();
    }
};

function initEbookInteractivity() {
    AH.selectAll('.drop_list3').forEach((_this) => {
        AH.find(_this, 'dd', { action: 'hide' });
    });
    AH.bind('.drop_list3 dt a', 'click', function (event) {
        let el = event.target, parent = event.target.closest('.drop_list3');
        if (el.classList.contains('active')) {
            AH.find(parent, 'dd').slideToggle();
            el.classList.remove('active');
        } else {
            AH.find(parent, 'dd').slideToggle();
            el.classList.add('active');
        }
        return false;
    });

    AH.selectAll('table[table_caption]').forEach(function (currenttab) {
        var tabTextshow = currenttab.getAttribute('table_caption');
        AH.insert(currenttab, '<div class=\'table_capt_center\'>' + tabTextshow + '</div>', 'afterend');
    });
    //@SAQUIB: uccaption taking extra margin with prettyprint
    AH.selectAll('uc\\:caption').forEach(function (_this) {
        let currentPrev = _this.previousElementSibling;
        if (currentPrev && currentPrev.nodeName != 'undefined') {
            if ((currentPrev.nodeName == 'PRE' && currentPrev.classList.contains('prettyprint')) || currentPrev.classList.contains('pre-block')) {
                _this.style.paddingTop = '0';
            }
        }
    });
    //JS("#columnize table").wrap("<div class='overflow'></div>");
    if (AH.selectAll('.timeline.timeline-view').length > 0) {
        AH.select('.timeline.timeline-view', 'css', { width: AH.select('.center-block.flex').clientWidth });
    }

    AH.bind('.horizontal_timeline li div:last-child', 'mouseover', function (event) {
        AH.selectAll(event.target, 'removeClass', 'timeline_clamp');
    });
    AH.bind('.horizontal_timeline li div:last-child', 'mouseout', function (event) {
        AH.selectAll(event.target, 'addClass', 'timeline_clamp');
    });
    AH.selectAll('.horizontal_timeline li div:last-child', 'addClass', 'timeline_clamp');
    var linum = AH.selectAll('.horizontal_timeline li').length;
    AH.setCss('.horizontal_timeline ul', { width: linum * 500 });

    AH.selectAll('.drop_list1 > dd', 'hide');
    AH.selectAll('.drop_list1 > dd:first-of-type', 'show');
    AH.selectAll('.drop_list1 > dt:first-of-type', 'addClass', 'accordion-active');
    AH.bind('.drop_list1 > dt', 'click', function (event) {
        let _this = event.target;
        let target = _this.nextElementSibling;
        if (!_this.classList.contains('accordion-active')) {
            AH.findChild(_this.parentElement, 'dd').slideUp();
            AH.selectAll('.drop_list1 > dt', 'removeClass', 'accordion-active');
            _this.classList.add('accordion-active');
            target.slideDown();
        }
        return false;
    });

    AH.selectAll('.drop_list4').forEach(function (_this) {
        AH.selectAll(_this.querySelector('dd'), 'hide');
    });

    AH.bind('.drop_list4 dt a', 'click', function (event) {
        var el = event.target, parent = el.closest('.drop_list4');
        if (el.classList.contains('active')) {
            parent.querySelector('dd').slideToggle();
            el.classList.remove('active');
        } else {
            parent.querySelector('dd').slideToggle();
            el.classList.add('active');
        }
        return false;
    });

    AH.selectAll('.drop_list2 > dd', 'hide');
    AH.selectAll('.drop_list2 > dd:first-of-type', 'show');
    AH.selectAll('.drop_list2 > dt:first-of-type', 'addClass', 'accordion-active');
    AH.bind('.drop_list2 > dt', 'click', function (event) {
        let _this = event.target;
        let target = _this.next();
        if (!_this.hasClass('accordion-active')) {
            _this.parent().children('dd').slideUp();
            AH.selectAll('.drop_list2 > dt', 'removeClass', 'accordion-active');
            _this.classList.add('accordion-active');
            target.slideDown();
        }
        return false;
    });
    //setSlider3dArrowPos();
    if (AH.find(document, 'div[type=timeline]', 'all').length > 1 || AH.find(document, 'div[type=slideshow]', 'all').length > 1 || AH.find(document, 'div[type=sub-slideshow]', 'all').length > 1) {
        ucTimeline.ucInit();
    }
    try {
        if (AH.find(document, '#ebook_container figure[type=\'item-annotation\']', 'all').length >= 1) {
            AH.find(document, '#ebook_container figure[type=\'item-annotation\']', 'all').forEach(function (_this, i) {
                _this.classList.add('ann_item_' + i);
                ucImageAnnotation && ucImageAnnotation.ucInit('.ann_item_' + i);
            });
        }
    } catch (e) {
        console.warn('Image Annotation Error', e);
    }

    initAccordion && initAccordion();
    //@saquib: Multiple Video Caraosel
    try {
        if (AH.selectAll('.base player[type=\'video\'][is_multiple=\'1\']').length > 0) {
            AH.selectAll('player[type=\'video\'][is_multiple=\'1\']').forEach(function (_this) {
                videoPlayerCaraousel.containerArray.push(
                    AH.parent(_this, '.base').getAttribute('id')
                );
            });
            videoPlayerCaraousel.containerArray = AH.unique(videoPlayerCaraousel.containerArray);
            videoPlayerCaraousel.containerArray.forEach((i) => {
                videoPlayerCaraousel.init(videoPlayerCaraousel.containerArray[i]);
            });
        }
    } catch (e) {
        console.warn(e);
    }
}

function tag_player(obj) {
    if (typeof (obj) != 'undefined') {
        //obj = obj.querySelectorAll('player');
        obj = AH.find(obj,'player','all');
    } else {
        obj = document.querySelectorAll('player');
    }

    //Define Player depenencies.
    let case_sensitive = '',
        type = '',
        config = '',
        ques_type = '',
        options = '',
        asset = '',
        sub_type = '',
        preview_image = '',
        player_id = 0,
        description = '',
        player_info = '',
        no_of_attempts = '',
        is_review = window.is_review ? window.is_review : 0,
        is_full_url = false,
        _full_url = "",
        test_session_id = window.test_session_id ? window.test_session_id : 0,
        group_guids = '',
        hint = '',
        border_check = '',
        guids = "",
        topology = "",
        single = "",
        style = "",
        get_guid = "";

    //Iterate all player tags
    obj.forEach((_this, index) => {
        // Set Default value
        type = 'quiz';
        asset = '';
        guids = '';
        preview_image = '';
        title = '';
        options = '';
        topology = '';
        config = '';
        case_sensitive = 0;
        single = '';
        style = '';
        no_of_attempts = '';
        img = '';
        get_guid = '';
        description = '';
        alt = '';
        hint = '';
        sub_type = '';
        group_guids = '';
        border_check = '';
        if (_this.hasAttribute('title')) {
            title = _this.getAttribute('title');
        }
        if (_this.hasAttribute('asset')) {
            asset = _this.getAttribute('asset');
        } else if (_this.hasAttribute('guid')) {
            asset = _this.getAttribute('guid');
        }
        if (_this.hasAttribute('subtype')) {
            sub_type = _this.getAttribute('subtype');
        } else if (_this.hasAttribute('sub_type')) {
            sub_type = _this.getAttribute('sub_type');
        }
        if (_this.hasAttribute('ques_type')) {
            ques_type = _this.getAttribute('ques_type');
        }
        if (_this.hasAttribute('options')) {
            options = _this.getAttribute('options');
        }
        if (_this.hasAttribute('single')) {
            single = _this.getAttribute('single');
        }
        if (_this.hasAttribute('config')) {
            config = _this.getAttribute('config');
        }
        if (_this.hasAttribute('img')) {
            img = _this.getAttribute('img');
        } else if (_this.hasAttribute('imgsrc')) {
            img = _this.getAttribute('imgsrc');
        }
        if (_this.hasAttribute('alt')) {
            alt = _this.getAttribute('alt');
        } else if (_this.hasAttribute('alt_txt')) {
            alt = _this.getAttribute('alt_txt');
        } else if (_this.hasAttribute('imgalt')) {
            alt = _this.getAttribute('imgalt');
        }
        if (_this.getAttribute('type') != undefined) {
            type = _this.getAttribute('type').toLowerCase();
        }
        if (_this.getAttribute('topology') != undefined) {
            topology = _this.getAttribute('topology');
        }
        if (_this.getAttribute('case_sensitive') != undefined) {
            case_sensitive = _this.getAttribute('case_sensitive');
        }
        if (_this.getAttribute('ui') != undefined) {
            ui = _this.getAttribute('ui');
        }
        if (_this.innerHTML != undefined && _this.innerHTML != '') {
            description = _this.innerHTML;
        }
        if (_this.getAttribute('group_guids') != undefined) {
            group_guids = _this.getAttribute('group_guids');
        }
        if (_this.getAttribute('style') != undefined) {
            style = _this.getAttribute('style');
        }
        if (_this.getAttribute('hint') != undefined) {
            hint = _this.getAttribute('hint');
        }
        if (_this.getAttribute('no_of_attempts') != undefined) {
            no_of_attempts = _this.getAttribute('no_of_attempts');
        }
        if (_this.getAttribute('device_type') != undefined) {
            device_type = _this.getAttribute('device_type');
        }
        if (_this.getAttribute('device_name') != undefined) {
            device_name = _this.getAttribute('device_name');
        }
        if (_this.getAttribute('show_caption') != undefined) {
            show_caption = _this.getAttribute('show_caption');
        }
        if (_this.getAttribute('hide_caption') != undefined) {
            hide_caption = _this.getAttribute('hide_caption');
        }
        if (_this.getAttribute('border_check') != undefined) {
            border_check = _this.getAttribute('border_check');
        }
        if (_this.getAttribute('image_url') != undefined) {
            image_url = _this.getAttribute('image_url');
        }
        var embed = getPlayerAttrVal(_this, 'embed');
        preview_image = getPlayerAttrVal(_this, 'preview');

        domain = '';
        asset = asset.trim();
        type = type.trim();
        var extension = asset.split('.').pop();
        if (extension == 'swf' && navigator.userAgent.toLowerCase().match(/iphone|ipod|ipad/)) {
            player_info = '<h6 class="m-0"><small>This is based on the Adobe Flash and will no work on iPad or iPhone</small></h6>';
        }
        //checking absolute url
        if (asset.substr(0, 7) == 'http://' || asset.substr(0, 8) == 'https://') {
            is_full_url = true;
            var domain = asset.match(/:\/\/(www\.)?(.[^/:]+)/)[2]; //fetching domain
            //alert(domain);
        }
        var entity = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '\'': '&apos;', '"': '&quot;' };
        for (var i in entity) {
            if (title.indexOf(i)) {
                title = title.replace(new RegExp(i, 'g'), entity[i]);
            }
        }
        var iframe_src, c1, c2, tag_url, self, text, tag_div, tag_html, terminal_url, intervals, attrs, player_title = title || iframe_title[type] || iframe_title['0'];

        switch (type) {
            case 'quiz':
                var quiz_attr = '';
                if (_this.hasAttribute('quick_feedback')) {
                    quiz_attr = '&quick_feedback=1';
                }
                if (_this.hasAttribute('random_quiz')) {
                    quiz_attr += '&random_quiz=' + _this.getAttribute('random_quiz');
                }
                if (_this.hasAttribute('algo_quiz')) {
                    quiz_attr += '&algo_quiz=' + _this.getAttribute('algo_quiz');
                }
                if (_this.hasAttribute('dont_randomize')) {
                    quiz_attr += '&dont_randomize=' + _this.getAttribute('dont_randomize');
                }
                quiz_attr += '&nofeedback=' + getPlayerAttrVal(_this, 'nofeedback');
                var chapter_guid = '';
                if (typeof ajaxEbook === 'object' && ajaxEbook['parent_guid'] !== '') {
                    chapter_guid = ajaxEbook['parent_guid'];
                }
                iframe_src = baseUrl + 'index.php?func=navigate_items&player_id=' + chapter_guid + '_' + player_id + '&group_guid=' + asset + '&chapter_guid=' + chapter_guid + '&title=' + title + '&player_setting' + options + quiz_attr + '&handler_type=quizPlayer';
                var attributes = 'class="quiz_player" name="' + chapter_guid + '_' + player_id + '" id="' + chapter_guid + '_' + player_id + '" style="' + options + '" onLoad="window.parent.autoResize(this.id, 1)"';
                AH.insert(_this, createPlayerEmbed('inline', player_title, iframe_src, attributes), 'afterend');
                player_id++;
                break;
            case 'flashcard':
                iframe_src = baseUrl + 'quiz_player.php?func=get_flashcard&player_id=' + content_guid + '_' + player_id + '&group_guid=' + asset + '&title=' + title + '&player_setting' + options + '&item_sequence=1';
                let tempFlashCardHtml = '<iframe tabindex=\'' + tabindex.z + '\' title=\'' + player_title + '\' class=\'quiz_player\' name=' + content_guid + '_' + player_id + ' id=' + content_guid + '_' + player_id + ' src=\'' + iframe_src + '\' style=\'' + options + '\' onLoad=\'window.parent.autoResize(this.id)\'></iframe>';
                AH.insert(_this, tempFlashCardHtml, 'afterend');
                player_id++;
                break;
            case 'download':
                ITEMPLAYER.download(_this, asset, title, description, img, alt);
                player_id++;
                break;
            case 'terminal':
                var include_assets = "";
                var terminalType = sub_type.toLowerCase(),
                    terminal_title_tag = '',
                    user = _this.getAttribute('user'),
                    default_comm = _this.getAttribute('default_comm'),
                    init_comm = _this.getAttribute('init_comm'),
                    testsession_id = window.test_session_id ? window.test_session_id : 0,
                    contentguid = window.content_guid ? window.content_guid : 0,
                    forSm = true;
                var terminalInEditor = typeof __inEditor__ == 'undefined' ? false : __inEditor__;
                if (_this.hasAttribute('guids')) {
                    asset = _this.getAttribute('guids');
                }
                if (terminalInEditor) {
                    contentguid = 0;
                }
                if (title != '') {
                    terminal_title_tag = '<div class="alert alert-info clearfix lab-title p-md">' + title + '</div>';
                }
                switch (terminalType) {
                    case 'java':
                    case 'php':
                        forSm = false;
                        url = baseUrl + 'sim/?module=terminal_lib&type=' + terminalType;
                        if (ques_type == 'new') {
                            url += '&new=1';
                        }
                        if (single != '') {
                            _this.wrapInner('<a tabindex="' + tabindex.z + '" href="' + url + '" onclick="return open_single_lab(this)"/>');
                        } else if (asset != '') {
                            terminal_url = '';
                            if (is_review == 1 && sub_type == 'assessment') {
                                terminal_url = 'javascipt:;\' disabled=\'disabled\'';
                            } else {
                                terminal_url = url + '&full_page=1&content_guid=' + asset + '&is_overlay=1';
                            }
                            if (title == '') {
                                title = 'Try it';
                            }
                            terminal_url = 'open_test(\'' + terminal_url + '\')';
                            terminal_url = 'onclick="' + terminal_url + '"';
                            AH.insert(_this, '<a tabindex="' + tabindex.z + '" class="btn btn-primary startlab focus_lab" ' + terminal_url + ' target="_blank">' + title + '</a>', 'beforebegin');
                        } else {
                            _this.load(url + '&full_page=1');
                        }
                        break;
                }
                if (forSm) {
                    if (ques_type == 'sim') {
                        AH.insert(_this, '<h1>this item is depricated, please contact ucertify support</h1>', 'afterend');
                    } else {
                        if (AH.selectAll('.UC_TERMINAL').length <= 0) {
                            if (_this.hasAttribute('exclude_asset')) {
                                include_assets = '';
                            }
                            AH.insert(_this, include_assets + terminal_title_tag + '<div class="UC_TERMINAL" style="' + options + '; height:240px; width: 99%;"><div class="term_container"><div id="terminal_font"><span class="icomoon-plus plus" rel="tooltip" data-original-title="Increase font size"></span><span class="icomoon-minus minus mt" rel="tooltip" data-original-title="Decrease font size"></span></div></div></div>', 'afterend');
                            AH.getBS('#terminal_font span', 'Tooltip').enable();
                        }
                        if (typeof updateTFS != 'undefined') {
                            updateTFS();
                        }
                        if (typeof speechSynth != 'undefined') {
                            speechSynth._init();
                        }
                    }
                    if (is_review == 1) {
                        AH.setCss('.UC_TERMINAL', { 'background-image': 'url(' + baseThemeUrl + 'images/' + terminalType.toLowerCase() + '-terminal.png)', 'background-repeat': 'no-repeat', 'height': '180px' });
                    } else {
                        switch (terminalType) {
                            case 'dos':
                                create_dos_terminal(case_sensitive, contentguid, test_session_id, user);
                                break;
                            case 'unix':
                                if (default_comm == 1) {
                                    default_exce_comm(init_comm, user, testsession_id, contentguid);
                                }
                                create_unix_terminal(case_sensitive, user, testsession_id, contentguid);
                                break;
                        }
                    }
                }
                break;
            case 'insight':
            case 'lab':
                var insight_ui, lab_title_tag = '<div>',
                    smart_chat_url;
                if (sub_type == 'smart_chat' || sub_type == 'insight') {
                    if (sub_type == 'smart_chat') {
                        content_guid = (_this.getAttribute('content_guid')) ? _this.getAttribute('content_guid') : asset;
                        smart_chat_url = baseUrl + 'sim/smartsim/index.php?action=player&content_guid=' + content_guid + '&no_header=1';
                        if (_this.hasAttribute('skip_intro')) {
                            smart_chat_url += '&skip_intro=1';
                        }
                        insight_ui = ['smartchat-playertag', 'Start discussion', 0];
                    }
                    if (sub_type == 'insight') {
                        var insight_asset = '';
                        if (asset.length == 5) {
                            insight_asset = baseUrl + 'sim/smartsim/index.php?action=player&content_guid=' + asset + '&no_header=1&insight=1&tech=unity&insight_navigation=1';
                        }
                        smart_chat_url = insight_asset;
                        insight_ui = ['insight-playertag', 'Start', 1];
                        var insight_call = sub_type;
                    }
                    smart_chat_url = 'openOverlayWeblink(\'' + smart_chat_url + '\', ' + insight_ui[2] + ',\'' + insight_call + '\')';
                    smart_chat_url = 'onclick="' + smart_chat_url + '"';
                    if (_this.innerHTML.trim() != '') {
                        var _playerHtml = '<div tabindex=\'' + tabindex.z + '\' class=\'' + insight_ui[0] + ' pointer\' ' + smart_chat_url + '>' + _this.innerHTML + '</div>';
                        _this.innerHTML = _playerHtml;
                        _this.querySelector('img').classList.add('noImgModal');
                    } else if (_this.hasAttribute('img')) {
                        var alt = 'Introduction Slide';
                        if (_this.hasAttribute('imgalt')) {
                            alt = _this.getAttribute('imgalt');
                        }
                        _this.html('<center><div tabindex="' + tabindex.z + '" class="' + insight_ui[0] + ' " style="position:relative;display:inline-block;min-width:500px;max-width:800px;border:1px solid"><img class="noImgModal" alt="' + alt + '" src="' + DOWNLOAD_IMAGE_URL + _this.getAttribute('img') + '"/><span ' + smart_chat_url + ' class="play-video-icon pointer" style="position:absolute;z-index:10;left:50%;top:50%;margin-top:-30px;margin-left:-30px;"></span></div></center>');
                    } else {
                        smartchatbuttontext = _this.hasAttribute('text') ? _this.getAttribute('text') : insight_ui[1];
                        lab_title_tag = '<div class="alert alert-info clearfix lab-title p-md">' + title;
                        _this.innerHTML = lab_title_tag + '<a tabindex=\'' + tabindex.z + '\' class=\'btn btn-primary float-right startlab\' ' + smart_chat_url + ' target=\'_blank\'>' + smartchatbuttontext + '</a></div>';
                    }
                    player_id++;
                    break;
                }
                title = title.replace(/'/g, '&#039');
                if (sub_type == 'scorm') {
                    var image = '';
                    if (_this.hasAttribute('image') && _this.getAttribute('image') != '') {
                        image = _this.getAttribute('image');
                    } else {
                        image = img;
                    }
                    if (_this.getAttribute('get_guid') != undefined) {
                        get_guid = _this.getAttribute('get_guid');
                    } else {
                        get_guid = _this.closest('.base').getAttribute('id');
                    }
                    if (_this.hasAttribute('asset_m') && isiPad) {
                        asset = _this.getAttribute('asset_m');
                    }
                    var insight_player_vtt = '';
                    if (_this.hasAttribute('scorm_caption_id') && _this.getAttribute('scorm_caption_id') != '') {
                        insight_player_vtt = '&scorm_caption_id=' + _this.getAttribute('scorm_caption_id');
                    }
                    if (insight_player_vtt == '') {
                        insight_player_vtt = '&scorm_caption_id=' + group_guids;
                    }
                    if (isiPad) {
                        insight_player_vtt = '';
                    }
                    SCORM_url = baseUrl + 'lab_player.php?test_session_id=' + test_session_id + '&content_guid=' + content_guid + '&lab_code=' + asset + '&type=' + type + '&sub_type=' + sub_type + '&get_guid=' + get_guid + '&lab_title=' + encodeURIComponent(title) + '&SCOInst=1' + insight_player_vtt;
                    SCORM_url = 'open_test(\'' + SCORM_url + '\')';
                    SCORM_url = 'onclick="' + SCORM_url + '"';
                    AH.insert(_this, '<div style=\'left: -340px;position: relative;height: 500px;\'><a tabindex=\'' + tabindex.z + '\' id=\'scormid\' class=\'btn btn-primary float-right startlab\' ' + SCORM_url + '><img class =\'noImgModal\' alt=\'' + alt + '\' src=\'' + DOWNLOAD_IMAGE_URL + image + '\'/><span class=\'play-video-icon\' style=\'position:absolute;z-index:10;left:74.5%;top:49%;margin-top:-30px;margin-left:-30px;\'></span><div id=\'get_status\' style=\'margin-top: 7px;\'><span>Slide - 00:00:00       </span><span style=\'padding-left: 20px;\'>Lesson Status - incomplete  </span></div></a>' + '</div>', 'beforebegin');
                    var seturl = baseUrl + 'lab_player.php?action=scorm_status&get_guid=' + get_guid;
                    setTimeout(function () {
                        AH.ajax({
                            type: 'POST',
                            url: seturl,
                        }).then((res) => {
                            if (res != '') {
                                try {
                                    var st = JSON.parse(res);
                                    if (st.lessonstatus != null && st.timespent != null) {
                                        var scorm_time1 = st['timespent'];
                                        var scorm_time = scorm_time1.split(':');
                                        var update_scorm_time = (scorm_time[0].substring(2, 4)) + ':' + scorm_time[1] + ':' + Math.round(scorm_time[2]);
                                        AH.select('#get_status').innerHTML = '<span>Slide - ' + update_scorm_time + ' </span><span style=\'padding-left: 20px;\'>  Lesson Status - ' + st['lessonstatus'] + '</span>';
                                    }
                                } catch (e) {
                                    console.warn('Scorm data fetch rrror', e);
                                }
                            }
                        });
                    }, 1000);
                    break;
                }
                if (title != '') {
                    lab_title_tag = '<div class="alert alert-info clearfix lab-title p-md">' + title;
                } else {
                    lab_title_tag = '<div class="alert alert-info clearfix lab-title p-md">&nbsp; ';
                }
                var SCORM_url = '';
                if (is_review == 1 && sub_type == 'assessment') {
                    SCORM_url = 'javascipt:;\' disabled=\'disabled\'';
                } else {
                    SCORM_url = baseUrl + 'lab_player.php?test_session_id=' + test_session_id + '&content_guid=' + content_guid + '&lab_code=' + asset + '&type=' + type + '&sub_type=' + sub_type + '&lab_title=' + encodeURIComponent(title) + '&SCOInst=1';
                    if (typeof open_test == 'function') {
                        SCORM_url = 'open_test(\'' + SCORM_url + '\')';
                        SCORM_url = 'onclick="' + SCORM_url + '"';
                    } else {
                        SCORM_url = 'href="' + SCORM_url + '"';
                    }
                }
                if (typeof open_test == 'function') {
                    AH.insert(_this, lab_title_tag + '<a tabindex=\'' + tabindex.z + '\' class=\'btn btn-primary float-right startlab\' ' + SCORM_url + '>Start Lab</a>' + player_info + '</div>', 'beforebegin');
                } else {
                    AH.insert(_this, lab_title_tag + '<a tabindex=\'' + tabindex.z + '\' class=\'btn btn-primary float-right startlab\' ' + SCORM_url + ' target=\'_blank\'>Start Lab</a>' + player_info + '</div>', 'beforebegin');
                }
                break;
            case 'external':
            case 'simulation':
                var default_action = '',
                    correct_ans = '';
                self = _this;
                if (asset != '') {
                    AH.ajax({
                        url: baseUrl + 'index.php',
                        data: { 'func': 'get_item_xml', 'item_id': asset, 'ajax': 1, is_parse: 1 },
                    }).then((data) => {
                        obj = JSON.parse(data);
                        config = obj.config;
                        if (obj.default != undefined) {
                            default_action = obj.default;
                        }
                        if (obj.correct != undefined) {
                            correct_ans = obj.correct;
                        }
                        createSimulationHtml(config, default_action, correct_ans, embed, self, is_review, hint, player_id, player_title);
                        player_id++;
                    });
                } else {
                    default_action = getPlayerAttrVal(_this, 'default');
                    correct_ans = getPlayerAttrVal(_this, 'correct');
                    createSimulationHtml(config, default_action, correct_ans, embed, self, is_review, hint, player_id, player_title);
                    player_id++;
                }
                break;
            case 'annotation':
                iframe_src = baseUrl + 'quiz_player.php?player_id=' + asset + '_' + player_id + '&group_guid=' + asset + '&image_annotation=1';
                AH.insert(_this, '<iframe tabindex=\'' + tabindex.z + '\' class=\'quiz_player\' name=' + asset + '_' + player_id + ' id=' + asset + '_' + player_id + ' src=\'' + iframe_src + '\' style=\'' + options + '\' onLoad=\'window.parent.autoResize(this.id,1)\' allowfullscreen title=\'' + player_title + '\'></iframe>', 'afterend');
                player_id++;
                break;
            case 'exhibit':
                self = this;
                var btn_style = '',
                    img_tag = '',
                    action = '',
                    bordered = show_caption = getPlayerAttrVal(_this, 'bordered'),
                    show_caption = getPlayerAttrVal(_this, 'show_caption'),
                    hide_caption = getPlayerAttrVal(_this, 'hide_caption'),
                    layout = getPlayerAttrVal(_this, 'layout'),
                    is_inline = getPlayerAttrVal(_this, 'inline');
                //For old exhibit tag
                if (!_this.hasAttribute('category')) {
                    embed = 'overlay';
                    if (asset != '') {
                        sub_type = 'item';
                    } else {
                        sub_type = 'image';
                    }
                    if (layout != 'link') {
                        layout = 'button';
                    }
                    show_caption = title;
                }
                if (img != '' && img != undefined) {
                    img = (img.indexOf('//s3.amazonaws.com') > -1) ? img : DOWNLOAD_IMAGE_URL + img;
                    img_tag = '<img src="' + img + '" alt="' + alt + '"' + (bordered ? 'class="img-bordered"' : '') + ' />';
                } else {
                    img_tag = _this.innerHTML;
                }
                if (embed == 'inline') {
                    action = 'showToggleOutput(_this)';
                } else if (embed == 'overlay') {
                    action = 'scenarioAction(_this)';
                }
                var html_tag = (is_inline) ? 'span' : 'div';
                if (layout == 'button') {
                    btn_style = `<button type="button" onclick="${action}" class="toggleoutputbtn btn btn-primary ${sub_type}_tag_btn" data-player="${player_id}" data-show="${show_caption}" data-hide="${hide_caption}" tabindex="0">${show_caption}</button>`;
                } else if (layout == 'link') {
                    btn_style = `<span class="link-2" onclick="${action}" data-player="${player_id}" data-show="${show_caption}" data-hide="${hide_caption}">${show_caption}</span>`;
                }
                if (sub_type == 'image') {
                    var button_tag = btn_style + `<div class="toggleoutputimg pt-md h" data-player="${player_id}">${img_tag}</div>`;
                    _this.innerHTML = `<${html_tag}>${button_tag}</${html_tag}>`;
                    player_id++;
                } else if (sub_type == 'item' && asset != '') {
                    var old_player_id = player_id, old_assest = asset;
                    AH.ajax({
                        url: baseUrl + 'index_data.php?func=get_exhibit',
                        data: { 
                            'guid': asset, 
                            'ajax': 1 
                        },
                    }).then((data) => {
                        let pdfDoc = `<${html_tag}>${btn_style}<div class="toggleoutputimg pt h text-left exhibit_${old_assest}_${old_player_id}" data-player="${old_player_id}">${data}</div></${html_tag}>`;
                        _this.innerHTML = pdfDoc;
                        if (AH.find('.exhibit_' + old_assest + '_' + old_player_id, 'player', 'all').length != 0 && embed == 'inline') {
                            tag_player(document.querySelector(`.exhibit_${old_assest}_${old_player_id}`));
                        }
                        player_id++;
                    }).catch(function() {
                        console.log("error");
                    });                } else if (sub_type == 'text') {
                    text = '';
                    var span_tag = '';
                    if (_this.hasAttribute('text')) {
                        text = _this.getAttribute('text');
                    }
                    if (embed == 'inline') {
                        btn_style = (layout == 'button') ? 'btn btn-primary' : '';
                        hide_caption = (hide_caption == '') ? show_caption : hide_caption;
                        span_tag = '<span class="link ' + btn_style + ' nohover ' + sub_type + '_tag_btn" embed="inline" guid="sample" toggle_link="' + hide_caption + '" layout="button" tabindex="0">' + show_caption + '</span><div class="span-inline h pt">' + text + '</div>';
                    } else {
                        span_tag = btn_style + '<div class="toggleoutputimg h" data-player="' + player_id + '">' + text + '</div>';
                    }
                    _this.innerHTML = span_tag;
                    player_id++;
                }
                break;
            case 'playground':
                var isEval = _this.getAttribute('isEval') ? _this.getAttribute('isEval') : 0;
                var theme = _this.getAttribute('theme') ? _this.getAttribute('theme') : 0;
                var title = (title != '') ? title : 'Try it yourself';
                self = _this;
                web_count += 1;
                if (asset != '') {
                    AH.ajax({
                        url: baseUrl + 'index.php',
                        data: { 'func': 'get_item_xml', 'item_id': asset, 'ajax': 1 },
                    }).then((data) => {
                        createPlaygroundHtml(data, isEval, theme, web_count, self, title);
                        player_id++;
                    });
                } else {
                    var smxml = _this.querySelector('playcode').textContent;
                    smxml = smxml.replace(/#lt#/g, '<').replace(/#gt#/g, '>').replace(/#nl#/g, '\n').replace(/#t#/g, '\t').replace(/#s#/g, '  ');
                    createPlaygroundHtml(smxml, isEval, theme, web_count, self, title);
                    player_id++;
                }
                break;
            case 'video':
                if (_this.hasAttribute('security')) {
                    wguVideoPlayer(_this, player_title);
                    player_id++;
                    break;
                }
                if (_this.hasAttribute('stepcaptions')) {
                    intervals = getPlayerAttrVal(_this, 'intervals');
                    ITEMPLAYER.stepplayer(_this, asset, title, intervals, _this.getAttribute('stepcaptions'));
                    player_id++;
                    break;
                }
                var video_title_tag = '', video_alt = '', no_title = false;
                //Do not show title if notitle is added in player tag
                no_title = getPlayerAttrVal(_this, 'notitle');
                if (title.trim() == '') {
                    no_title = true;
                }
                if (!no_title) {
                    if (title != '') {
                        title = replaceLTGT(title);
                        var title_span = `<span titleid = "${player_id}" class="video-player-title"></span>`;
                        video_title_tag = `<div class="mb-xl alert alert-info lab-title p-md"><span class="icomoon-camera-8 pr-2"></span>${title_span + player_info}</div>`;
                    } else if (player_info != '') {
                        video_title_tag = `<div class="mb-xl alert alert-info lab-title p-md"><span class="icomoon-camera-8 pr-2"></span>Video${player_info}</div>`;
                    }
                }

                if (sub_type == 'video_plus') {
                    c1 = (asset.indexOf('.') == -1);
                    c2 = (asset.indexOf('youtube') > 1);
                    if ((!is_full_url && c1) || c2) {
                        sub_type = 'youtube';
                    }
                }
                if (sub_type == 'youtube') {
                    if (asset.indexOf('youtube') > -1) {
                        var match = asset.match(/^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/);
                        asset = (match && match[7].length == 11) ? match[7] : false;
                    }
                }
                if (sub_type == '' && (asset.indexOf('jigyaasa.info') > -1 || asset.indexOf('ucertify.com') > -1)) {
                    AH.insert(_this, video_title_tag + '<center><div class="bg-black ml-md"><video class="outline0" controls name="media"><source src="' + asset + '" type="video/mp4"></video></div></center>', 'afterend');
                } else if (sub_type == 'video_plus') {
                    if (!preview_image || preview_image == '') {
                        preview_image = asset.replace(extension, 'png');
                        if (preview_image.indexOf('s3.amazonaws.com') > -1) {
                            preview_image = preview_image.split('jigyaasa_content_stream/').pop();
                        }
                    }
                    preview_image = (preview_image.indexOf('vimeocdn') == -1) ? DOWNLOAD_IMAGE_URL + preview_image : preview_image;
                    try {
                        group_guids = group_guids.trim();
                    } catch (err) {
                        console.warn(err);
                    }
                    var v_plus_id = 'v-plus-preview' + group_guids, bg_zoom = '';
                    var v_plus_previewbox_class = 'col-md-7 col-12 p-0';
                    var v_plus_previewbox2_class = 'col-md-5 col-sm-12 col-12 p-0';
                    var framework = '';
                    var vtt_preview_html = '<div class="pb-md pl-lg pr-md v-transcript-container clearboth h-100"></div>';
                    if (typeof page !== 'undefined' && page == 'pe-virtual_lab') {
                        v_plus_previewbox_class = 'col-md-12';
                        v_plus_previewbox2_class = 'col-md-12 mt-md';
                        bg_zoom = '50%'; framework = page;
                    }
                    if (getTestFrameworkDetail() === 'split') {
                        v_plus_previewbox_class = 'col-md-12';
                        v_plus_previewbox2_class = 'col-md-12 mt-md';
                        bg_zoom = '60%';
                        framework = 'pe-virtual_lab';
                        vtt_preview_html = '';
                    }
                    var add_class = (_this.hasAttribute('is_multiple') && _this.getAttribute('is_multiple') == 1) ? 'class="mx-auto width10"' : '';
                    var v_plus_preview_html = '<center cid="' + v_plus_id + '" style="display:flex;" ' + add_class + '><div tabindex="' + tabindex.z + '" class="click_on_enter col-md-12 col-sm-12 v-plus-preview pointer p-0 mb-0" id="' + v_plus_id + '" title="' + player_title + '" isrc="' + baseUrl + 'utils/video_plus/index.php?content_guid=' + group_guids + '&no_header=1&question=1&img=' + preview_image + '&framework=' + framework + '"><div class="row mx-0"><div class="' + v_plus_previewbox_class + ' v-preview-box"><div class="v-container mr-md-3"><div class="play-video-icon video_play_icon"></div></div></div><div class="' + v_plus_previewbox2_class + '"><div class="v-sidebar h-100 overflow-hide"><div class="v-p-toolbar"><div class="float-left pl-md"><span>Video transcript</span></div><div class="float-right pr-md"><span class="float-right pointer v-vtt-download"><i class=icomoon-file-download></i> Download</span></div></div>' + vtt_preview_html + '</div></div></div></div></center>';
                    AH.insert(_this, video_title_tag + v_plus_preview_html, 'afterend');
                    var v_p_url = 'url("' + preview_image + '")';
                    //_this.find('.v-container').css({ 'background-image': v_p_url, 'zoom': bg_zoom });
                    AH.select('.v-container','css',{backgroundImage:v_p_url,zoom: bg_zoom});
                } else {
                    if (is_full_url && asset.indexOf('vimeo') == -1 && sub_type != 'youtube') {
                        var _asset = (sub_type == 'hostedvideo') ? asset : asset + '?vq=hd1080';
                        AH.insert(_this, video_title_tag + '<center><iframe tabindex="' + tabindex.z + '" style="' + options + '" class="video_frame" src="' + _asset + '" frameborder="0" title="' + player_title + '" allowfullscreen></iframe></center>', 'afterend');
                    } else if (domain == 'youtube' || sub_type == 'youtube') {
                        AH.insert(_this, video_title_tag + '<center><iframe tabindex="' + tabindex.z + '" style="' + options + '" class="video_frame" src="https://www.youtube.com/embed/' + asset + '?vq=hd1080' + '" frameborder="0" title="' + player_title + '" allowfullscreen></iframe></center>', 'afterend');
                    } else if (domain == 'lynda' || sub_type == 'lynda') {
                        AH.insert(_this, video_title_tag + '<center><iframe tabindex="' + tabindex.z + '" style="' + options + '" class="video_frame" src="//www.lynda.com/player/embed/' + asset + '?fs=3&ps=paused&utm_medium=referral&utm_source=embed+video&utm_campaign=ldc-website&utm_content=vid-' + asset + '" mozallowfullscreen="true" webkitallowfullscreen="true" allowfullscreen="true" frameborder="0" title="' + player_title + '"></iframe></center>', 'afterend');
                    } else if (extension != '') {
                        _full_url = '';
                        if (!preview_image || preview_image == '') {
                            preview_image = asset.replace(extension, 'png');
                            if (preview_image.indexOf('s3.amazonaws.com') > -1) {
                                preview_image = preview_image.split('jigyaasa_content_stream/').pop();
                            }
                        }
                        if (!is_full_url && asset.indexOf('vimeo') == -1 && asset.indexOf('s3.amazonaws.com') == -1) {
                            _full_url = '//s3.amazonaws.com/jigyaasa_content_stream/';
                        }
                        if (typeof _this.getAttribute('alt') == 'undefined') {
                            video_alt = 'Click to play video';
                        } else {
                            video_alt = (_this.getAttribute('alt') == '') ? 'Click to play video' : _this.getAttribute('alt');
                        }
                        preview_image = (preview_image.indexOf('vimeocdn') == -1) ? DOWNLOAD_IMAGE_URL + preview_image : preview_image;
                        var new_player_id = player_id;
                        if (AH.selectAll('#video_player_' + player_id).length > 0) {
                            new_player_id = player_id + Math.floor(Math.random() * 90 + 10);
                        }
                        AH.insert(_this, video_title_tag + '<center><div tabindex="' + tabindex.z + '" title="Video" class="video_preview" id="video_player_' + new_player_id + '" embed=1 style="position:relative;display:inline-block;min-width:500px;max-width:800px" asset="' + _full_url + asset + '"' + '><img title="' + video_alt + '" src="' + preview_image + '"/><span class="play-video-icon" style="position:absolute;cursor:pointer;z-index:10;left:50%;top:50%;margin-top:-30px;margin-left:-30px;" ></span></div></center>', 'afterend');
                    }
                }
                AH.find(_this, `[titleid="${player_id}"]`, { action: 'html', actionData: title });
                player_id++;
                break;
            case 'audio':
                var audio_title_tag = '';
                if (title != '') {
                    audio_title_tag = '<div class="mb-xl alert alert-info lab-title p-xl"><span class="icomoon-play-3 mr"></span>' + title;
                }
                if (!is_full_url) {
                    asset = '//s3.amazonaws.com/jigyaasa_content_stream/' + asset;
                }
                AH.insert(_this, audio_title_tag + '<audio controls="controls" class="position-absolute right5 bottom6 m-b-xxs"><source src="' + asset + '" type="audio/mpeg"></audio></div>', 'afterend');
                break;
            case 'pdf':
                var pdf_url, download_html, des_css = (description == '') ? { 'display': 'none' } : { 'display': 'block', 'margin': '0' };
                if (asset.match('^https://')) {
                    asset = asset.replace('https://', 'http://');
                }
                embed = (embed == '') ? 'player' : embed;
                if (embed != '' || embed != 'inline') {
                    var img = '//s3.amazonaws.com/jigyaasa_content_static/pdf_0003m4.png',
                        content_guid = _this.closest('.base').getAttribute('id');
                    if (embed == 'overlay') {
                        download_html = '<div class="row download_asset"><table class="border"><tbody><tr><td style="width:150px" class="align-middle"><img src="' + img + '" class="img-polaroid"></td><td class="align-middle"><h3>' + title + '</h3><p class="descript-pdf">' + description + '</p></td><td class="align-middle span3"><a tabindex="' + tabindex.z + '" class="btn btn-primary btn-block" onclick="open_test(\'' + baseUrl + 'utils/pdf/?filename=' + asset + '&content_guid=' + content_guid + '\')">Open</a></td></tr></tbody></table></div>';
                        _this.innerHTML = download_html;
                    } else if (embed == 'player') {
                        if (isiPad) {
                            pdf_url = 'http://docs.google.com/gview?url=' + asset + '&embedded=true';
                            AH.setCss('player[type="pdf"]', { 'position': 'relative', 'top': '-30px' });
                        } else {
                            pdf_url = baseUrl + 'labs/?destination=' + asset + '#zoom=100';
                        }
                        if (document.documentMode || /Edge/.test(navigator.userAgent)) {
                            download_html = '<div class="row download_asset"><table class="border"><tbody><tr><td style="width:150px" class="align-middle"><img src="' + img + '" class="img-polaroid"></td><td class="align-middle"><h3>' + title + '</h3><p class="descript-pdf">' + description + '</p></td><td class="align-middle span3"><a tabindex="' + tabindex.z + '" class="btn btn-primary btn-block" href="' + pdf_url + '" target="_blank">Open</a></td></tr></tbody></table></div>';
                        } else {
                            download_html = '<iframe tabindex=\'' + tabindex.z + '\' onLoad = \'window.parent.ucPdfLoad(this.id)\' frameborder=\'0\' scrolling=\'auto\' style=\'height:400px;\' class=\'quiz_player download_asset\' name=\'pdf' + content_guid + '\' id=\'pdf' + content_guid + '\' src=\'' + pdf_url + '\' title=\'' + player_title + '\'></iframe>';
                        }
                        _this.innerHTML = download_html;
                    } else {
                        download_html = '<div class="row download_asset"><table class="border"><tbody><tr><td style="width:150px" class="align-middle"><img src="' + img + '" class="img-polaroid"></td><td class="align-middle"><h3>' + title + '</h3><p class="descript-pdf">' + description + '</p></td><td class="align-middle span3"><a tabindex="' + tabindex.z + '" class="btn btn-primary btn-block" href="' + baseUrl + 'utils/pdf/?filename=' + asset + '&content_guid=' + content_guid + '" target="_blank">Open</a></td></tr></tbody></table></div>';
                        _this.innerHTML = download_html;
                    }
                }
                AH.setCss('.descript-pdf', des_css);
                player_id++;
                break;
            case 'weblink':
                var frame_height = getPlayerAttrVal(_this, 'height'),
                    frame_width = (sub_type == 'embed' || embed == 'inline') ? '100%' : getPlayerAttrVal(_this, 'width');
                if (sub_type == 'embed' || embed == 'inline') {
                    frame_height = (frame_height == '') ? '500px' : frame_height;
                    AH.insert(_this, '<center><div class=\'weblinkContainer\' style=\'position:relative;height:' + frame_height + ';width:' + frame_width + '\' id=\'weblinkEmbed_' + player_id + '\'><iframe src=\'' + asset + '\' height=\'100%\' width=\'' + frame_width + '\' allowfullscreen=\'true\' class=\'weblink_player\' id=\'weblinkFrame_' + player_id + '\'></iframe><button class=\'bg-light\' title=\'Full Screen\' onclick=\'weblinkfullscreen(weblinkEmbed_' + player_id + ')\' rel=\'tooltip\' style=\'position:absolute;top:0;right:0;border:0;padding:10px\'><i class=\'icomoon-new-24px-expand-1 fullScreenIcon\' /><span class=\'fullscreenBtn pl-md align-top pull-right\'>Full Screen</span></button></div></center>', 'afterend');
                    weblinkHeight = frame_height.replace(/px|%/g, '');
                    document.addEventListener('fullscreenchange', exitHandler);
                    document.addEventListener('webkitfullscreenchange', exitHandler);
                    document.addEventListener('mozfullscreenchange', exitHandler);
                    document.addEventListener('MSFullscreenChange', exitHandler);
                    player_id++;
                    break;
                }
                if (sub_type == 'redirect' || embed == 'new_tab') {
                    asset = baseUrl + 'labs/?destination=' + asset;
                }
                var player_txt = _this.innerHTML || '',
                    html_arr = [];
                var center_tag = (player_txt == '') ? ['<center>', '</center>'] : ['', ''];
                html_arr[0] = center_tag[0] + '<div tabindex="' + tabindex.z + '" class="weblink" style="position:relative;display:inline-block;min-width:166px;max-width:860px;cursor:pointer" asset="' + asset + '" title="' + title + '">';
                if (_this.hasAttribute('icon') && _this.getAttribute('icon') !== '') {
                    html_arr[1] = '<span class="' + _this.getAttribute('icon') + ' s8 float-left"></span>';
                } else {
                    html_arr[1] = (img === '') ? '' : '<img class ="noImgModal" title="Click to open Link" src="' + DOWNLOAD_IMAGE_URL + img + '" alt="' + alt + '" style="height:' + frame_height + '; max-width:' + frame_width + '; margin-right:10px"/>';
                }
                var frame_align = (player_txt == '') ? '' : 'tip-c';
                if (html_arr[1] == '') frame_align = '';
                html_arr[2] = `<div class="${frame_align}">${player_txt}</div></div>${center_tag[1]}`;
                _this.innerHTML = html_arr.join('');
                if (_this.hasAttribute('overlay') && _this.getAttribute('overlay') == '1') {
                    _this.querySelector('.weblink').classList.add('overlay');
                }
                if (_this.hasAttribute('innewwindow') && _this.getAttribute('innewwindow') == '1') {
                    _this.querySelector('.weblink').classList.add('innewwindow');
                }
                if (_this.hasAttribute('display') && _this.getAttribute('display') == '1') {
                    AH.setCss(_this.querySelector('.weblink'), { 'display': 'block', 'max-width': '' });
                }
                player_id++;
                break;
            case 'wguvideo':
                var token = _this.getAttribute('token') || '',
                    loid = _this.getAttribute('loid') || 0,
                    wid = _this.getAttribute('wid') || '';
                tag_url = 'https://fod.infobase.com/OnDemandEmbed.aspx?token=' + token + '&amp;wID=' + wid + '&amp;plt=FOD&amp;loid=' + loid;
                var tag_prefix = '<iframe tabindex="' + tabindex.z + '" title="' + player_title + '" allowfullscreen="" frameborder="0" height="410" src="https://wgu.idm.oclc.org/login?' + 'url=',
                    tag_postfix = '&amp;w=640&amp;h=360&amp;fWidth=660&amp;fHeight=410&#10;ref=http://wgu.libguides.com.wgu.idm.oclc.org/c.php?g=57662&amp;p=1384747" style="border:1px solid #ddd;" width="660">&amp;amp;nbsp;</iframe>',
                    frame = tag_prefix + tag_url + tag_postfix;
                var tag_href = 'https://wgu.idm.oclc.org/login?&url=' + tag_url + '&amp;w=640&amp;h=360&amp;fWidth=660&amp;fHeight=410';
                var msg = '<div class="alert alert-info clearfix"><b>Error in displaying video?</b> Please click on SHOW VIDEO button to open the video in new tab.';
                msg += '<a class="btn btn-primary float-right" href="' + tag_href + '" target="_blank">Show Video</a></div>';
                AH.insert(_this, msg + frame, 'afterend');
                player_id++;
                break;
            case 'object3d':
                if (_this.hasAttribute('guids')) {
                    asset = _this.getAttribute('guids');
                }
                var asset_arr = (asset.indexOf(',') !== -1) ? asset.split(',') : asset;
                tag_html = '';
                if (Array.isArray(asset_arr)) {
                    iframe_src = baseUrl + 'utils/3d_objects/?func=load_in_frame&cguds=' + asset;
                    tag_html = '<iframe tabindex=\'' + tabindex.z + '\' title=\'' + player_title + ' \'class=\'quiz_player 3d_player\'  name=\'3d' + player_id + '\' id=\'3d' + player_id + '\' src=\'' + iframe_src + '\'  onLoad=\'window.parent.autoResize(this.id)\'></iframe>';
                } else if (_this.hasAttribute('inline')) {
                    tag_html = '<span class="open-3d-object inline-3d-object-link">' + title + '</span>';
                } else {
                    tag_html = '<div class="alert alert-info clearfix p-md">' + title + '<a tabindex="' + tabindex.z + '" class="btn btn-primary float-right open-3d-object" title="' + title + '">3D View</a></div>';
                }
                AH.insert(_this, tag_html, 'afterend');
                player_id++;
                break;
            case 'math features':
                var subtypeContainer = [],
                    proctor_tool = [],
                    ruler_tool = [],
                    image_tool = [],
                    direction_tool = [];

                proctor_tool['btn_value'] = 'Protractor';
                proctor_tool['link'] = 'protractor.png';
                proctor_tool['style'] = 'width:385px;height:200px;';
                proctor_tool['class'] = 'icomoon-learn-sm';
                proctor_tool['img_class'] = 'maths_protractor';
                proctor_tool['close_style'] = 'top:96px;';

                ruler_tool['btn_value'] = 'Ruler';
                ruler_tool['link'] = 'ruler.png';
                ruler_tool['style'] = 'width:500px;height:auto;';
                ruler_tool['class'] = 'icomoon-sort';
                ruler_tool['img_class'] = 'maths_ruler';
                ruler_tool['close_style'] = 'top:40px;';

                image_tool['btn_value'] = 'Image Tool';
                image_tool['link'] = 'image_tool.png';
                image_tool['style'] = 'width:300px;height:300px;';
                image_tool['class'] = 'icomoon-table-2';
                image_tool['img_class'] = 'maths_imagetool';
                image_tool['close_style'] = 'top:144px;';

                direction_tool['btn_value'] = 'Direction Tool';
                direction_tool['link'] = 'direction.png';
                direction_tool['style'] = 'width:auto;height:auto;';
                direction_tool['class'] = 'icomoon-compass';
                direction_tool['img_class'] = 'maths_direction';
                direction_tool['close_style'] = 'top:197px;';

                subtypeContainer['Protactor Tool'] = proctor_tool;
                subtypeContainer['Ruler Tool'] = ruler_tool;
                subtypeContainer['Image Tool'] = image_tool;
                subtypeContainer['Direction Tool'] = direction_tool;

                var math_tools = '<button class = "btn btn-primary m-t-n-xs pull-right math_btn"><span class="m-xs mr-1 align-middle ml0 v-align-ih ' + subtypeContainer[sub_type]['class'] + '"></span>' + subtypeContainer[sub_type]['btn_value'] + '</button>' +
                    '<div class="math_clickable absolute"><div id="math_draggable" class="math_draggable" style="cursor:move;z-index:1050"><div id="math_target" class="math_target">' +
                    '<span class="icomoon-close relative closing_btn pointer"style =' + subtypeContainer[sub_type]['close_style'] + ' data-bs-toggle="tooltip" title="Click to close!"></span>' +
                    '<img id="img_drag" data-bs-toggle="tooltip" title="Drag to measure!" class=' + subtypeContainer[sub_type]['img_class'] + ' style="max-width:none;' + subtypeContainer[sub_type]['style'] + '" src="' + themeUrl + 'foundation/css/images/' + subtypeContainer[sub_type]['link'] + '"></img>' +
                    '</div></div></div>';
                AH.insert(_this, math_tools, 'afterend');
                if (typeof (rotatable) == 'undefined') {
                    AH.getJSON(baseThemeUrl + 'ux/js/jquery.ui.rotatable.js').then(function () {
                        //JS('#math_target').rotatable();
                    });
                    setTimeout(function () {
                        AH.select('.ui-rotatable-handle').getAttribute('data-bs-toggle', 'tooltip');
                        AH.select('.ui-rotatable-handle').getAttribute('title', 'Rotate the Tool!');
                    }, 5000);
                }
                //JS('#math_draggable').draggable();
                AH.toggleDom('.math_clickable', 'hide');
                AH.bind('.math_btn', 'click', function () {
                    AH.toggleDom('.math_clickable', 'show');
                });
                AH.bind('.closing_btn', 'click', function () {
                    AH.toggleDom('.math_clickable', 'hide');
                });
                player_id++;
                break;
            case 'stepplayer':
                intervals = getPlayerAttrVal(_this, 'intervals'), stepcaptions = '';
                if (_this.hasAttribute('stepcaptions')) {
                    stepcaptions = _this.getAttribute('stepcaptions');
                }
                ITEMPLAYER.stepplayer(_this, asset, title, intervals, stepcaptions);
                player_id++;
                break;
            case 'toggleoutput':
                var _div = '<button class="toggleoutputbtn btn btn-sm btn-outline-secondary" style="padding: 1px 10px;margin-bottom: 2px;" data-player="' + player_id + '" data-show="' + show_caption + '" data-hide="' + hide_caption + '" tabindex="0" onclick=showToggleOutput(_this)>' + show_caption + '</button><div class="toggleoutputimg my-3 text-center h" data-player="' + player_id + '"><img ' + (border_check ? 'class="img-bordered"' : '') + ' src="' + image_url + '" alt="' + alt + '" /></div>';
                _this.innerHTML = _div;
                player_id++;
                break;
            case 'lablink':
                if (_this.hasAttribute('labguid')) {
                    asset = _this.getAttribute('labguid');
                }
                if (_this.hasAttribute('label')) {
                    title = _this.getAttribute('label');
                }
                var lab_url = baseUrl + '?func=start_test&test_type=-13&inline_guid=' + asset;
                var isplayer = getPlayerAttrVal(_this, 'isplayer');
                if (isplayer == 1) {
                    lab_url = baseUrl + 'quiz_player.php?func=full_mode&content_guid=' + asset + '&is_frame=1';
                }
                var lab_html = '<div class="alert alert-info clearfix p-md">' + title + '<a tabindex="' + tabindex.z + '" class="btn btn-primary float-right" href= "' + lab_url + '" target="_blank">Open</a></div>';
                AH.insert(_this, lab_html, 'afterend');
                player_id++;
                break;
            case 'integrate':
                alt = 'Preview of the video';
                if (_this.hasAttribute('title')) {
                    if (_this.getAttribute('title') != '') {
                        alt = 'Preview of the ' + _this.getAttribute('title') + ' video';
                    }
                }
                AH.insert(_this, '<center><div tabindex="' + tabindex.z + '" class="integrate" style="position:relative;display:inline-block;min-width:500px;max-width:800px;cursor:pointer" asset="' + asset + '" title="' + title + '"><img class="noImgModal" alt="' + alt + '" title="Click to play video" src="' + DOWNLOAD_IMAGE_URL + preview_image + '"/><span class="play-video-icon" style="position:absolute;z-index:10;left:50%;top:50%;margin-top:-30px;margin-left:-30px;"></span></div></center>', 'afterend');

                if (_this.hasAttribute('display')) {
                    AH.selectAll(_this.querySelectorAll('.integrate'), 'addClass', _this.getAttribute('display'));
                }
                if (_this.hasAttribute('border')) {
                    if (_this.getAttribute('border') == '1') _this.querySelector('.integrate').style.border = '1px solid #000';
                }

                player_id++;
                break;
            case 'geometry':
                var alignValue = AH.select('player').getAttribute('align');
                var labelValue = AH.select('player').getAttribute('label');
                var showAngle = AH.select('player').getAttribute('display');

                var angleValue = [],
                    colorValue, heightValue, widthValue, classStyle, distance;
                var x1, y1, x2, y2;
                if (labelValue) {
                    labelValue = labelValue.trim().split(',');
                }

                if (AH.select('player').getAttribute('color') != '') {
                    colorValue = AH.select('player').getAttribute('color');
                } else {
                    colorValue = 'red';
                }
                if (alignValue == 'Center Align') {
                    classStyle = 'float-none';
                } else if (alignValue == 'Right Align') {
                    classStyle = 'float-right';
                } else {
                    classStyle = 'float-left';
                }

                if (AH.select('player').getAttribute('subtype') == 'Triangles') {
                    angleValue = AH.select('player').getAttribute('triangle');
                    if (angleValue) {
                        angleValue = angleValue.trim().split(',');
                    } else {
                        console.log('no angle');
                    }

                    x1 = 250, y1 = 350, c1 = 400, c2 = 350;
                    heightValue = '400px';
                    widthValue = '600px';

                    var A, B, C, a = c1 - x1,
                        c, b;

                    C = angleValue[0];
                    B = angleValue[1];
                    angleValue[2] = 'x';
                    var answer = solveTriangle(A, B, C, a, b, c);
                    var solution = answer.slice(0, 6);

                    x2 = xcoordinate(solution[4], C) + x1;
                    y2 = y1 - ycoordinate(solution[4], C);

                    distance = 'M ' + c1 + ',' + c2 + ' L ' + x1 + ',' + y1 + ' L ' + x2 + ',' + y2 + 'Z';

                } else {
                    var sizeValue = AH.select('player').getAttribute('size');

                    if (AH.select('player').getAttribute('angle') != '') {
                        angleValue[0] = AH.select('player').getAttribute('angle');
                    } else {
                        angleValue[0] = 60;
                    }

                    angleValue[1] = '';
                    angleValue[2] = '';

                    if (sizeValue == 'Large') {
                        x1 = 300, y1 = 250, c1 = 600, c2 = 250;
                        heightValue = '510px';
                        widthValue = '610px';
                    } else if (sizeValue == 'Medium') {
                        x1 = 250, y1 = 250, c1 = 500, c2 = 250;
                        heightValue = '410px';
                        widthValue = '510px';
                    } else {
                        x1 = 250, y1 = 150, c1 = 400, c2 = 150;
                        heightValue = '310px';
                        widthValue = '410px';
                    }

                    x2 = xcoordinate(c1 - x1, angleValue[0]) + x1;
                    y2 = y1 - ycoordinate(c1 - x1, angleValue[0]);

                    distance = 'M ' + c1 + ',' + c2 + ' L ' + x1 + ',' + y1 + ' L ' + x2 + ',' + y2;
                }

                _this.innerHTML = '<svg id="angles" height=' + heightValue + ' width=' + widthValue + ' class="mx-auto d-block ' + classStyle + '"></svg>';

                var path, fill = 'none',
                    strokeWidth = '3',
                    svg = document.getElementById('angles'),
                    ns = 'http://www.w3.org/2000/svg';

                path = document.createElementNS(ns, 'path');
                path.setAttribute('d', distance);
                path.setAttribute('fill', fill);
                path.setAttribute('stroke', colorValue);
                path.setAttribute('stroke-width', strokeWidth);
                svg.appendChild(path);

                var textContentValue = [{
                    'x': x1,
                    'y': y1,
                    'x_inside': x1 + 7,
                    'y_inside': y1 - 3,
                    'text': labelValue[2],
                    'angle': angleValue[0],
                    'id': 'first'
                },
                {
                    'x': c1,
                    'y': c2,
                    'x_inside': c1 - 27,
                    'y_inside': c2 - 5,
                    'text': labelValue[1],
                    'angle': angleValue[1],
                    'id': 'second'
                },
                {
                    'x': x2,
                    'y': y2,
                    'x_inside': x2 + 2,
                    'y_inside': y2 + 20,
                    'text': labelValue[0],
                    'angle': angleValue[2],
                    'id': 'third'
                }
                ];

                var valueChange = 15;
                for (var geo_i = 0; geo_i < textContentValue.length; geo_i++) {
                    var svg_ref = document.createElementNS(ns, 'text');
                    var text_ref = document.createElementNS(ns, 'text');
                    var circle_ref = document.createElementNS(ns, 'circle');
                    circle_ref.setAttribute('cx', textContentValue[geo_i]['x']);
                    circle_ref.setAttribute('cy', textContentValue[geo_i]['y']);
                    circle_ref.setAttribute('stroke', 'black');
                    circle_ref.setAttribute('stroke-width', 4);
                    circle_ref.setAttribute('r', 2);
                    svg_ref.setAttribute('x', textContentValue[geo_i]['x'] - valueChange);
                    svg_ref.setAttribute('y', textContentValue[geo_i]['y'] + valueChange);
                    svg_ref.textContent = textContentValue[geo_i]['text'];
                    svg.appendChild(svg_ref);
                    svg.appendChild(circle_ref);
                    if (showAngle == 'check') {
                        text_ref.setAttribute('x', textContentValue[geo_i]['x_inside']);
                        text_ref.setAttribute('y', textContentValue[geo_i]['y_inside']);
                        text_ref.setAttribute('id', textContentValue[geo_i]['id']);
                        text_ref.textContent = textContentValue[geo_i]['angle'];
                        svg.appendChild(text_ref);
                    }
                }

                if (showAngle == 'check') {
                    if (AH.select('player').getAttribute('subtype') == 'Triangles') {
                        console.log('triangle');
                        document.getElementById('second').appendChild(document.createTextNode(String.fromCharCode(176)));
                        document.getElementById('third').appendChild(document.createTextNode(String.fromCharCode(176)));
                    }
                    document.getElementById('first').appendChild(document.createTextNode(String.fromCharCode(176)));
                }
                player_id++;
                break;
            case 'braingames':
                var game = _this.getAttribute('game');
                if (game) {
                    iframe_src = baseUrl + 'utils/brain_games/' + game + '/index.php';
                    tag_html = '<iframe tabindex=\'' + tabindex.z + '\' title=\'' + player_title + ' \'class=\'quiz_player brain_games\'  name=\'brain_game' + player_id + '\' id=\'brain_game' + player_id + '\' src=\'' + iframe_src + '\'  onLoad=\'window.parent.autoResize(this.id)\'></iframe>';
                }
                AH.insert(_this, tag_html, 'afterend');
                player_id++;
                break;
            case 'plugin':
                tag_div = '<div class="alert alert-info clearfix p-md" plugin-cmp-id="' + player_id + '" player-asset="' + asset + '"><span style="line-height:34px;">' + title;
                tag_div += '</span><a tabindex=\'' + tabindex.z + '\' class=\'btn btn-primary float-right open-plugin-component\'>Open</a></div>';
                if (AH.selectAll('[plugin-cmp-id="' + player_id + '"]').length == 0) {
                    AH.insert(_this, tag_div, 'afterend');
                }
                player_id++;
                break;
            case 'lms':
                tag_url = '';
                attrs = _this.attrAsObj();
                tag_url = AH.param2Url(attrs);
                tag_url = baseUrl + 'utils/temp/lms1.php?' + tag_url;
                var ovelay_class = '';
                if (typeof attrs['overlay'] != 'undefined') {
                    ovelay_class = 'overlay_external_link overlay';
                }
                tag_div = '<div class="alert alert-info clearfix p-md" lms-cmp-id="' + player_id + '">' + title;
                tag_div += '<a tabindex=\'' + tabindex.z + '\' target=\'_blank\' href=\'' + tag_url + '\' asset=\'' + tag_url + '\' class=\'edited btn btn-primary float-right open-lms-link  ' + ovelay_class + '\'>Open</a></div>';
                _this.innerHTML = tag_div;
                player_id++;
                break;
            case 'card':
                tag_div = '<div class="alert alert-info d-flex justify-content-between align-items-center" player-asset="' + asset + '">' + title;
                var link_text = _this.hasAttribute('caption') ? _this.getAttribute('caption') : 'Open';
                attrs = _this.attrAsObj();
                if (_this.hasAttribute('ctitle') && _this.getAttribute('ctitle') != '') {
                    attrs['ctitle'] = _this.getAttribute('ctitle');
                }
                var cardTypes = { 1: 3, 2: 3, 3: 2, 4: 3, 5: 2, }; // This is to map appropriate flashcard.
                /*attrs['is_player'] = 1;
                attrs['is_overlay'] = 1;*/
                attrs['title'] = 'Cards';
                attrs['func'] = 'get_flash_card';
                attrs['flashcard_type'] = _this.hasAttribute('card_type') ? cardTypes[_this.getAttribute('card_type')] : 3;
                attrs['is_frame'] = '';
                attrs['item_sequence'] = 1;

                card_url = AH.param2Url(attrs);
                card_url = baseUrl + 'index.php?' + card_url;
                card_url = 'open_test(\'' + card_url + '\')';
                card_url = 'onclick="' + card_url + '"';
                tag_div += '<a tabindex=\'' + tabindex.z + '\' ' + card_url + ' class=\'btn btn-primary card_player\'>' + link_text + '</a></div>';
                AH.insert(_this, tag_div, 'afterend');
                player_id++;
                break;
            case 'live_lab':
                AH.insert(_this, '<a tabindex="' + tabindex.z + '" class="btn btn-primary startlab" href="' + baseUrl + 'quiz_player.php?func=full_mode&player_id=' + player_id + '&content_guid=' + guids + '&group_guid=' + group_guids + '&virtual_lab=1&is_player=1" target="_blank">' + title + '</a>', 'beforebegin');
                player_id++;
                break;
            case 'test':
                ITEMPLAYER.test(_this, content_guid, player_id, asset, embed, no_of_attempts);
                player_id++;
                break;
            default:
                iframe_src = baseUrl + 'quiz_player.php?player_id=' + content_guid + '_' + player_id + '&group_guid=' + asset + '&title=' + title + '&player_setting' + options;
                AH.insert(_this, '<iframe tabindex=\'' + tabindex.z + '\' class=\'quiz_player\' name=' + content_guid + '_' + player_id + ' id=' + content_guid + '_' + player_id + ' src=\'' + iframe_src + '\' style=\'' + options + '\' onLoad=\'window.parent.autoResize(this.id)\' title=\'' + player_title + '\'></iframe>', 'afterend');
                player_id++;
                break;
        }
    });
}

function getTestFrameworkDetail(checkViewAttr) {
    debugger;
    var detail = -1;
    if (AH.select('#uc-item-test-template').length === 1) {
        var tempTestView = AH.select('#uc-item-test-template').getAttribute('temp_test_view');
        if (!checkViewAttr && tempTestView && tempTestView != '') {
            return tempTestView;
        }
        return AH.select('#uc-item-test-template').nodeName && AH.select('#uc-item-test-template').getAttribute('view');
    }
    return detail;
}

function initAccordion() {
    if (AI.selectAll('.drop_list section[nd="1"]').length < 1) {
        return true;
    }
    AH.selectAll('.drop_list section[nd="1"] article', 'hide');
    let init = AH.select('.drop_list_a > section[nd="1"]:first-child');
    AH.selectAll(init, 'addClass', "accordion-active");
    init.nodeType && AH.find(init, 'article', { action: 'show' });

    AH.selectAll('.drop_list_a section[nd="1"]', 'removeClass', "active");
    AH.listenAll('.drop_list_a section[nd="1"]', 'click', (event) => {
        let _this = AH.parent(event.target, 'section[nd="1"]');
        let sib = AH.siblings(_this, 'section[nd="1"]');
        // window.tt = _this;
        // console.log(_this, sib);
        AH.selectAll(sib, 'removeClass', 'accordion-active');
        sib.forEach((_elm) => { AH.find(_elm, 'article', { action: 'hide' }); });
        AH.select(_this, 'addClass', 'accordion-active');
        AH.find(_this, 'article', { action: 'show' });
    });
    AH.selectAll('.drop_list_b section[nd="1"]', 'removeClass', ["accordion-active", "active"]);

    AH.listenAll('.drop_list_b section[nd="1"]', 'click', (event) => {
        let self = event.target, parent = event.target.closest('section[nd="1"]');
        if (event.target.localName == 'header')
            AH.find(parent, 'article', { action: 'toggleDisplay' });
        // self.toggleClass('active');
    });
}
const contentUpdateFuncs = {
    pre: function (config) {
        if (AH.selectAll('.prettyprint .linenums li').length <= 0 && typeof prettyPrint == 'function') {
            prettyPrint();
        }
    },

    // player: function (config) {
    //     if (typeof config.player_id != 'undefined') {
    //         tag_player(config.player_id);
    //     } else {
    //         tag_player();
    //     }
    // },

    math: function (config) {
        console.log("is_math_required", config.is_math_required);
        mathMLRender(config.math_id, config.is_math_required);
    },

    caption: function (config) {
        AH.selectAll('img[imgtext]').forEach(function (currentImg) {
            const imgTextshow = currentImg.attr('imgtext');
            AH.nextElm(currentImg, 'uc\\:caption').remove();
            AH.insert(currentImg, '<uc:caption>' + imgTextshow + '</uc:caption>', 'afterend');
        });
        if (typeof setUcCaptionWidth == 'function') {
            var _delay = config.caption_delay || 3000;
            setUcCaptionWidth(_delay);
        }
    },

    list: function (config) {
        AH.selectAll('.list4[start],.list2[start]').forEach(function (_this) {
            var num = parseInt(_this.getAttribute('start')) - 1;
            AH.setCss(_this, { 'counter-increment': 'li ' + num });
        });
    },

    table: function (config) {
        AH.selectAll('table[table_caption]').ForEach(function (currenttab) {
            let _next = currenttab.nextElementSibling;
            if (!_next.classList.contains('table_capt_center')) {
                let tabTextshow = currenttab.getAttribute('table_caption');
                AH.insert(currenttab, '<div class=\'table_capt_center\'>' + tabTextshow + '</div>', 'afterend');
            }
        });
    },
    imgAltText: function (config) {
        //(config.ajax) ? imageSpeech.getAltTextAjax(config.container): imageSpeech.getAltText(config.container);
    },
    link: function (config) {
        AH.select('.link').setAttribute('tabindex', tabindex.z);
        AH.addClass('.link[layout="button"]', 'btn btn-default nohover');
    },
    ucHint: function (config) {
        if (!AH.selectAll('.uc_answer_hint').length && !AH.selectAll('.uc_step_explanation').length) {
            return false;
        }
        AH.select('.edit_chapter').removeAttribute('tabindex');
        AH.selectAll('.uc_answer_hint, .uc_step_explanation').forEach(function (el, i) {
            var exp_steps = el.classList.contains('uc_step_explanation');

            if (exp_steps) {
                AH.find(el, '.uc_step', 'all').forEach(function (elm, j) {
                    if (elm.innerHTML.trim().match(/^<br/g) == null) {
                        AH.insert(elm, '<br/>', 'beforebegin');
                    }
                });
                var btnCaption = (el.getAttribute('data-btnnme') != undefined && el.getAttribute('data-btnnme') != '') ? el.getAttribute('data-btnnme') : 'Next';
                if (AH.find(el, '.exp_next_btn', 'all').length > 0) {
                    AH.find(el, '.exp_next_btn').remove();
                }
                AH.find(el, '.addnext_caption').remove();
                AH.insert(el, '<button type="button" onclick="showUcExpStep(this)" class="exp_next_btn btn btn-sm btn-outline-primary bg-white imgcenter mx-auto text-primary" style="width: 15%; font-size: 15px; margin-top: 15px;">' + btnCaption + '</button>', 'aftertend');
            } else {
                // for hint
                var head_caption = 'Hint';
                var step_caption = 'hint';
                if (el.hasAttribute('head_caption')) {
                    head_caption = el.getAttribute('head_caption');
                }
                if (el.hasAttribute('step_caption')) {
                    step_caption = el.getAttribute('step_caption');
                }
                var msg = '<b>' + head_caption + ': </b> <span class=\'li_count\'>' + AH.find(el, 'li', 'all').length + '</span> ' + step_caption + '(s) are available.';
                var _btn = '<button type="button" style="margin-top:-4px" onclick="showHints(this)" class="hint_show btn btn-primary float-right">Show</button>';
                var _btn_hide = '<button type="button" style="margin-top:-4px" onclick="hideHints(this)" class="ml-md hint_hide btn btn-primary hidden float-right">Hide</button>';
                var pre_block = '<section id=\'uc_hint_' + i + '\' class=\'mt uc_hint_section white-bg alert text_lightBlack m-b-md alert-info\'>' + _btn_hide + _btn + msg + '</section>';
                el.innerHTML = pre_block + el.innerHTML;
                el.classList.add('list2');
            }
        });
        window.showHints = function (t) {
            var that = t.closest('.uc_answer_hint');
            AH.toggleDom(AH.find(that, 'li', 'hidden')[0], 'show');
            let len = AH.find(that, 'li', 'hidden').length;
            if (typeof QUIZPLAYERID != 'undefined') {
                window.parent.autoResize(QUIZPLAYERID);
            }
            if (len === 0) {
                len = 'No';
                AH.find(that, '.hint_show').setAttribute('disabled', true);
                AH.find(that, '.hint_hide').prop('disabled', false);
                AH.find(that, '.hint_hide').classList.remove('hidden');
            }
            AH.find(that, '.li_count').innerHTML = len;
        };
        window.hideHints = function (t) {
            var that = t.closest('.uc_answer_hint');
            AH.toggleDom(AH.find(that, 'li', 'visible').pop(), 'hide');
            var len = AH.find(that, 'li', 'visible').length;
            var total_len = AH.find(that, 'li', 'all').length;
            if (typeof QUIZPLAYERID != 'undefined') {
                window.parent.autoResize(QUIZPLAYERID);
            }
            if (len == 0) {
                len = total_len;
                AH.find(that, '.hint_hide').disabled = true;
                AH.find(that, '.hint_show').disabled = false;
            } else {
                AH.find(that, '.hint_hide').disabled = false;
                AH.find(that, '.hint_show').disabled = true;
            }
            AH.find(that, '.li_count').innerHTML = len;
        };
        window.showUcExpStep = function (t) {
            var that = t.closest('.uc_step_explanation');
            AH.toggleDom(AH.find(that, '.uc_step', 'hidden')[0], 'show');
            var len = AH.find(that, '.uc_step', 'hidden').length;
            if (len === 0) {
                AH.toggleDom(t, 'hide');
                if (typeof QUIZPLAYERID != 'undefined') {
                    t.remove();
                    AH.setCss('#' + QUIZPLAYERID, { height: AH.select('#' + QUIZPLAYERID).clientHeight - 100 });
                }
            }

            if (typeof QUIZPLAYERID != 'undefined') {
                setTimeout(function () { window.parent.autoResize(QUIZPLAYERID); }, 200);
            }
            if (typeof setUcCaptionWidth != 'undefined') {
                setUcCaptionWidth();
            }
        };
    },
    tableWrap: function (config) {
        AH.wrap('table', '<div class=\'overflow\'></div>');
    }
};
function getPlayerAttrVal(self, item) {
    let option_attr = '', style_attr = '', data = '';
    if (self.hasAttribute(item)) {
        data = self.getAttribute(item);
    } else {
        if (self.hasAttribute('option') && self.getAttribute('option').trim() != '') {
            option_attr = AH.parseJSON(self.getAttribute('option'));
        }
        if (self.hasAttribute('styles') && self.getAttribute('styles').trim() != '') {
            style_attr = AH.parseJSON(self.getAttribute('styles'));
        }
        if (option_attr[item] != undefined) {
            data = option_attr[item];
        } else if (style_attr[item] != undefined) {
            let item_val = style_attr[item];
            data = (!isNaN(item_val) && item_val.indexOf('px') == -1 && item_val.indexOf('%') == -1) ? item_val + 'px' : item_val;
        }
    }

    return data;
}
function createPlayerEmbed(embed, player_title, src, attributes, button_name) {
    var embed_html = '';
    src = src || false;
    player_title = player_title || false;
    button_name = button_name || false;
    if (embed == 'inline') {
        embed_html = '<iframe tabindex="' + tabindex.z + '" title="' + player_title + '" src="' + src + '" onload="autoResize(this.id)" allowfullscreen ' + attributes + '></iframe>';
    } else if (embed == 'overlay') {
        embed_html = '<button tabindex="' + tabindex.z + '" type="button" ' + attributes + '>' + button_name + '</button>';
    } else if (embed == 'new_tab') {
        embed_html = '<a tabindex="' + tabindex.z + '" href="' + src + '" target="_blank" ' + attributes + '>' + button_name + '</a>';
    }

    return embed_html;
}
function replaceLTGT(str) {
    if (str == '') {
        return str;
    }
    str = str.replace(/&lt;/g, '<');
    str = str.replace(/&gt;/g, '>');
    return str;
}
function mathMLRender(id_mathML, is_required) {
    console.log("Math rendering..");
    if (!is_required) {
        return false;
    }
    let id = id_mathML || false;
    let el = document.body;
    if (id) {
        el = document.getElementById(id);
    }
    if (typeof renderMathInElement == 'function') {
        try {
            renderMathInElement(el, DEFAULTMATHOPTIONS);
        } catch (e) {
            console.warn(e);
        }
    } else {
        let css = '<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous">';
        AH.insert(document.body, css, 'afterend');
        AH.ajax({
            type: 'GET',
            url: itemUrl + '/src/libs/katex.min.js',//window.baseUrlTheme + 'src/libs/katex.min.js',
            async: false,
            dataType: 'script',
        }).then(function (script) {
            AH.addScript(script);
            try {
                renderMathInElement(el, DEFAULTMATHOPTIONS);
            } catch (e) {
                console.warn(e);
            }
        });
    }
}

function ajaxContentUpdate$1(config) {
    let funclist = Object.keys(contentUpdateFuncs);
    let func_len = funclist.length;
    for (let i = 0; i < func_len; i++) {
        let func = funclist[i];
        config[func] = config[func] || 0;
        if (config[func] == 1) {
            if (typeof contentUpdateFuncs[func] === 'function') {
                contentUpdateFuncs[func](config);
            }
        }
    }
    // disable find
    // if (jQuery && typeof jQuery.fn.disableFind == 'function') {
    //     if (AH.selectAll('[uc_item_content_subtype="8"]').length == 0) {
    //         if (typeof config.protect_find == 'undefined') {
    //             AH.selectAll('.uc_protect_find').disableFind();
    //         }
    //     }
    // }
}

/* src\components\Media.svelte generated by Svelte v3.40.2 */

const { console: console_1$9 } = globals;
const file$n = "src\\components\\Media.svelte";

function add_css$h(target) {
	append_styles(target, "svelte-zofhgz", ".lightBoxControls{position:fixed;top:50%;height:50px;width:50px;color:#fff !important;background:#343a40;cursor:pointer;font-size:30px;border-radius:50%}#lightBoxDialog{width:100vw;max-width:none;height:100%;margin:0}#modal_plugin .modal{z-index:299203 !important}.lightBoxSlides{display:none;margin:auto;width:90%}.showSlide{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVkaWEuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWt0Q1ksaUJBQWlCLEFBQUUsQ0FBQyxBQUN4QixRQUFRLENBQUUsS0FBSyxDQUNmLEdBQUcsQ0FBRSxHQUFHLENBQ1IsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLEtBQUssQ0FBRSxJQUFJLENBQUMsVUFBVSxDQUN0QixVQUFVLENBQUUsT0FBTyxDQUNuQixNQUFNLENBQUUsT0FBTyxDQUNmLFNBQVMsQ0FBRSxJQUFJLENBQ2YsYUFBYSxDQUFFLEdBQUcsQUFDdEIsQ0FBQyxBQUNPLGVBQWUsQUFBRSxDQUFDLEFBQ3RCLEtBQUssQ0FBRSxLQUFLLENBQ1osU0FBUyxDQUFFLElBQUksQ0FDZixNQUFNLENBQUUsSUFBSSxDQUNaLE1BQU0sQ0FBRSxDQUFDLEFBQ2IsQ0FBQyxBQUNPLG9CQUFvQixBQUFFLENBQUMsQUFDM0IsT0FBTyxDQUFFLE1BQU0sQ0FBQyxVQUFVLEFBQzlCLENBQUMsQUFDTyxlQUFlLEFBQUUsQ0FBQyxBQUN0QixPQUFPLENBQUUsSUFBSSxDQUNiLE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLEdBQUcsQUFDZCxDQUFDLEFBQ08sVUFBVSxBQUFFLENBQUMsQUFDakIsUUFBUSxLQUFLLEFBQ2pCLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVkaWEuc3ZlbHRlIl19 */");
}

// (971:56) {:else}
function create_else_block$5(ctx) {
	let input;
	let input_accept_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "file");
			attr_dev(input, "tabindex", "-1");
			attr_dev(input, "name", "files[]");
			attr_dev(input, "accept", input_accept_value = /*default_media_configuration*/ ctx[0].file_type);
			attr_dev(input, "id", "fileUploadSelector");
			attr_dev(input, "data-id", "fileUploadInput");
			attr_dev(input, "class", "fileUploadInput");
			add_location(input, file$n, 971, 60, 46412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler_1*/ ctx[9]),
					listen_dev(input, "change", /*onUploadMedia*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*default_media_configuration*/ 1 && input_accept_value !== (input_accept_value = /*default_media_configuration*/ ctx[0].file_type)) {
				attr_dev(input, "accept", input_accept_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(971:56) {:else}",
		ctx
	});

	return block;
}

// (958:56) {#if default_media_configuration.max_file_allowed != "1"}
function create_if_block_1$5(ctx) {
	let input;
	let input_accept_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "file");
			attr_dev(input, "tabindex", "-1");
			attr_dev(input, "name", "files[]");
			attr_dev(input, "accept", input_accept_value = /*default_media_configuration*/ ctx[0].file_type);
			input.multiple = true;
			attr_dev(input, "id", "fileUploadSelector");
			attr_dev(input, "data-id", "fileUploadInput");
			attr_dev(input, "class", "fileUploadInput");
			add_location(input, file$n, 958, 60, 45346);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[8]),
					listen_dev(input, "change", /*onUploadMedia*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*default_media_configuration*/ 1 && input_accept_value !== (input_accept_value = /*default_media_configuration*/ ctx[0].file_type)) {
				attr_dev(input, "accept", input_accept_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(958:56) {#if default_media_configuration.max_file_allowed != \\\"1\\\"}",
		ctx
	});

	return block;
}

// (1061:36) {#if default_media_configuration.select_multiple_media == "true"}
function create_if_block$i(ctx) {
	let div;
	let button;
	let span;
	let t0;
	let ul;
	let li0;
	let a0;
	let i0;
	let t1;
	let t2;
	let li1;
	let a1;
	let i1;
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			span = element("span");
			t0 = space();
			ul = element("ul");
			li0 = element("li");
			a0 = element("a");
			i0 = element("i");
			t1 = text("Select Media");
			t2 = space();
			li1 = element("li");
			a1 = element("a");
			i1 = element("i");
			t3 = text("Use selected media");
			attr_dev(span, "class", "icomoon-menu-2 setting_icon s3");
			add_location(span, file$n, 1063, 48, 52496);
			attr_dev(button, "tabindex", "0");
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "px-0 btn btn-light transparent_threedot my-1 move_renew_dropdown gridview_open_btn position-relative");
			attr_dev(button, "data-bs-toggle", "dropdown");
			add_location(button, file$n, 1062, 44, 52276);
			attr_dev(i0, "class", " icomoon-images-2 mr-2");
			attr_dev(i0, "aria-hidden", "true");
			add_location(i0, file$n, 1068, 56, 53005);
			attr_dev(a0, "href", "#");
			attr_dev(a0, "class", "dropdown-item rounded-0 text-left text-dark border-0");
			attr_dev(a0, "data-bs-toggle", "tooltip");
			add_location(a0, file$n, 1067, 52, 52823);
			attr_dev(li0, "class", "dropdown-item pointer use_media");
			add_location(li0, file$n, 1066, 48, 52725);
			attr_dev(i1, "class", "icomoon-image mr-2");
			attr_dev(i1, "aria-hidden", "true");
			add_location(i1, file$n, 1073, 56, 53577);
			attr_dev(a1, "href", "#");
			attr_dev(a1, "tabindex", "-1");
			set_style(a1, "margin", "0 0 6px 11px");
			attr_dev(a1, "class", "border-0 dropdown-item useSelectedMedia disable_license pointer_event_none rounded-0 text-dark text-left");
			attr_dev(a1, "data-bs-toggle", "tooltip");
			add_location(a1, file$n, 1072, 52, 53295);
			add_location(li1, file$n, 1071, 48, 53237);
			attr_dev(ul, "class", "dropdown-menu");
			add_location(ul, file$n, 1065, 44, 52649);
			attr_dev(div, "class", "form-group pr-2 mt-2");
			add_location(div, file$n, 1061, 40, 52196);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			append_dev(button, span);
			append_dev(div, t0);
			append_dev(div, ul);
			append_dev(ul, li0);
			append_dev(li0, a0);
			append_dev(a0, i0);
			append_dev(a0, t1);
			append_dev(ul, t2);
			append_dev(ul, li1);
			append_dev(li1, a1);
			append_dev(a1, i1);
			append_dev(a1, t3);

			if (!mounted) {
				dispose = [
					listen_dev(a0, "click", selectMedias, false, false, false),
					listen_dev(a1, "click", useSelectedMedia, false, false, false)
				];

				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$i.name,
		type: "if",
		source: "(1061:36) {#if default_media_configuration.select_multiple_media == \\\"true\\\"}",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let div38;
	let div23;
	let div22;
	let div21;
	let div0;
	let ul;
	let li0;
	let a0;
	let t1;
	let li1;
	let a1;
	let t3;
	let button0;
	let span0;
	let t5;
	let div19;
	let div1;
	let t6;
	let div18;
	let div17;
	let div7;
	let div5;
	let i0;
	let t7;
	let div2;
	let t9;
	let p;
	let t11;
	let link0;
	let link0_href_value;
	let t12;
	let link1;
	let link1_href_value;
	let t13;
	let t14;
	let form;
	let t15;
	let div4;
	let div3;
	let span3;
	let span2;
	let i1;
	let t16;
	let span1;
	let t18;
	let t19;
	let div6;
	let t20;
	let div16;
	let div14;
	let div8;
	let input1;
	let t21;
	let div9;
	let label;
	let t23;
	let div10;
	let input2;
	let input2_value_value;
	let t24;
	let div11;
	let input3;
	let input3_value_value;
	let t25;
	let div12;
	let button1;
	let span4;
	let t26;
	let div13;
	let button2;
	let span5;
	let t27;
	let t28;
	let div15;
	let t29;
	let div20;
	let button3;
	let t31;
	let div30;
	let div29;
	let div28;
	let div24;
	let h40;
	let t33;
	let button4;
	let span6;
	let t35;
	let div26;
	let div25;
	let t36;
	let div27;
	let button5;
	let t38;
	let button6;
	let t40;
	let div37;
	let div36;
	let div35;
	let div31;
	let h41;
	let t42;
	let button7;
	let t44;
	let div33;
	let div32;
	let input4;
	let t45;
	let span8;
	let button8;
	let span7;
	let t46;
	let div34;
	let button9;
	let t48;
	let div45;
	let div44;
	let div43;
	let div39;
	let button10;
	let t49;
	let div41;
	let div40;
	let t50;
	let a2;
	let t52;
	let a3;
	let t54;
	let div42;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*default_media_configuration*/ ctx[0].max_file_allowed != "1") return create_if_block_1$5;
		return create_else_block$5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*default_media_configuration*/ ctx[0].select_multiple_media == "true" && create_if_block$i(ctx);

	const block = {
		c: function create() {
			div38 = element("div");
			div23 = element("div");
			div22 = element("div");
			div21 = element("div");
			div0 = element("div");
			ul = element("ul");
			li0 = element("li");
			a0 = element("a");
			a0.textContent = "Upload";
			t1 = space();
			li1 = element("li");
			a1 = element("a");
			a1.textContent = "Gallery";
			t3 = space();
			button0 = element("button");
			span0 = element("span");
			span0.textContent = "×";
			t5 = space();
			div19 = element("div");
			div1 = element("div");
			t6 = space();
			div18 = element("div");
			div17 = element("div");
			div7 = element("div");
			div5 = element("div");
			i0 = element("i");
			t7 = space();
			div2 = element("div");
			div2.textContent = "Drag files here";
			t9 = space();
			p = element("p");
			p.textContent = "Or";
			t11 = space();
			link0 = element("link");
			t12 = space();
			link1 = element("link");
			t13 = space();
			t14 = space();
			form = element("form");
			t15 = space();
			div4 = element("div");
			div3 = element("div");
			span3 = element("span");
			span2 = element("span");
			i1 = element("i");
			t16 = space();
			span1 = element("span");
			span1.textContent = "Upload files";
			t18 = space();
			if_block0.c();
			t19 = space();
			div6 = element("div");
			t20 = space();
			div16 = element("div");
			div14 = element("div");
			div8 = element("div");
			input1 = element("input");
			t21 = space();
			div9 = element("div");
			label = element("label");
			label.textContent = "Between";
			t23 = space();
			div10 = element("div");
			input2 = element("input");
			t24 = space();
			div11 = element("div");
			input3 = element("input");
			t25 = space();
			div12 = element("div");
			button1 = element("button");
			span4 = element("span");
			t26 = space();
			div13 = element("div");
			button2 = element("button");
			span5 = element("span");
			t27 = space();
			if (if_block1) if_block1.c();
			t28 = space();
			div15 = element("div");
			t29 = space();
			div20 = element("div");
			button3 = element("button");
			button3.textContent = "Cancel";
			t31 = space();
			div30 = element("div");
			div29 = element("div");
			div28 = element("div");
			div24 = element("div");
			h40 = element("h4");
			h40.textContent = "Review Media";
			t33 = space();
			button4 = element("button");
			span6 = element("span");
			span6.textContent = "×";
			t35 = space();
			div26 = element("div");
			div25 = element("div");
			t36 = space();
			div27 = element("div");
			button5 = element("button");
			button5.textContent = "Cancel";
			t38 = space();
			button6 = element("button");
			button6.textContent = "Upload Details";
			t40 = space();
			div37 = element("div");
			div36 = element("div");
			div35 = element("div");
			div31 = element("div");
			h41 = element("h4");
			h41.textContent = "Copy Embed Code";
			t42 = space();
			button7 = element("button");
			button7.textContent = "×";
			t44 = space();
			div33 = element("div");
			div32 = element("div");
			input4 = element("input");
			t45 = space();
			span8 = element("span");
			button8 = element("button");
			span7 = element("span");
			t46 = space();
			div34 = element("div");
			button9 = element("button");
			button9.textContent = "Cancel";
			t48 = space();
			div45 = element("div");
			div44 = element("div");
			div43 = element("div");
			div39 = element("div");
			button10 = element("button");
			t49 = space();
			div41 = element("div");
			div40 = element("div");
			t50 = space();
			a2 = element("a");
			a2.textContent = "❮";
			t52 = space();
			a3 = element("a");
			a3.textContent = "❯";
			t54 = space();
			div42 = element("div");
			attr_dev(a0, "href", "#upload_tab");
			attr_dev(a0, "id", "tab1");
			attr_dev(a0, "data-bs-toggle", "tab");
			attr_dev(a0, "tabindex", "0");
			attr_dev(a0, "title", "Upload");
			attr_dev(a0, "class", "active nav-link");
			add_location(a0, file$n, 927, 28, 42394);
			attr_dev(li0, "class", "nav-item");
			add_location(li0, file$n, 926, 24, 42343);
			attr_dev(a1, "href", "#gallery_tab");
			attr_dev(a1, "id", "tab2");
			attr_dev(a1, "data-bs-toggle", "tab");
			attr_dev(a1, "tabindex", "0");
			attr_dev(a1, "title", "Gallery");
			attr_dev(a1, "class", "nav-link");
			add_location(a1, file$n, 930, 28, 42617);
			attr_dev(li1, "class", "nav-item");
			add_location(li1, file$n, 929, 24, 42566);
			attr_dev(ul, "class", "nav nav-pills");
			add_location(ul, file$n, 925, 20, 42291);
			attr_dev(span0, "aria-hidden", "true");
			add_location(span0, file$n, 933, 80, 42890);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "close");
			attr_dev(button0, "data-bs-dismiss", "modal");
			add_location(button0, file$n, 933, 20, 42830);
			attr_dev(div0, "class", "modal-header");
			add_location(div0, file$n, 924, 16, 42243);
			attr_dev(div1, "class", "flash_disabled alert alert-danger mt-2 h");
			add_location(div1, file$n, 936, 20, 43065);
			attr_dev(i0, "class", "icomoon-cloud-upload s15");
			add_location(i0, file$n, 941, 36, 43432);
			attr_dev(div2, "id", "dragandrophandler");
			add_location(div2, file$n, 942, 36, 43510);
			attr_dev(p, "class", "orpara");
			add_location(p, file$n, 943, 36, 43597);
			attr_dev(link0, "onload", "this.rel='stylesheet'");
			attr_dev(link0, "rel", "preload");
			attr_dev(link0, "as", "style");
			attr_dev(link0, "href", link0_href_value = "" + (window.themeUrl + "ux/media_modal_box/css/jquery.fileupload-ui.css"));
			attr_dev(link0, "crossorigin", "anonymous");
			add_location(link0, file$n, 945, 36, 43730);
			attr_dev(link1, "onload", "this.rel='stylesheet'");
			attr_dev(link1, "rel", "preload");
			attr_dev(link1, "as", "style");
			attr_dev(link1, "href", link1_href_value = "" + (window.themeUrl + "media_modal_box/blueimp/css/blueimp-gallery.min.css"));
			attr_dev(link1, "crossorigin", "anonymous");
			add_location(link1, file$n, 946, 36, 43926);
			attr_dev(i1, "class", "fa fa-plus mr-1");
			attr_dev(i1, "aria-hidden", "true");
			add_location(i1, file$n, 955, 56, 45017);
			attr_dev(span1, "class", "pull-right");
			add_location(span1, file$n, 956, 56, 45125);
			attr_dev(span2, "title", "Upload files");
			attr_dev(span2, "data-bs-toggle", "tooltip");
			attr_dev(span2, "data-title", "Browse file");
			add_location(span2, file$n, 954, 52, 44882);
			attr_dev(span3, "class", "btn btn-primary fileinput-button");
			attr_dev(span3, "tabindex", "0");
			add_location(span3, file$n, 953, 48, 44768);
			attr_dev(div3, "class", "p-0");
			attr_dev(div3, "id", "fileSelector");
			add_location(div3, file$n, 952, 44, 44683);
			attr_dev(div4, "class", "fileupload-buttonbar pt-md sticky-top index2");
			add_location(div4, file$n, 951, 40, 44579);
			attr_dev(form, "id", "fileupload");
			attr_dev(form, "action", "");
			attr_dev(form, "method", "POST");
			attr_dev(form, "enctype", "multipart/form-data");
			add_location(form, file$n, 949, 36, 44352);
			attr_dev(div5, "class", "drag_media text-center clearfix");
			add_location(div5, file$n, 940, 32, 43349);
			attr_dev(div6, "class", "upload_status");
			add_location(div6, file$n, 990, 32, 47726);
			attr_dev(div7, "class", "tab-pane active");
			attr_dev(div7, "id", "upload_tab");
			add_location(div7, file$n, 939, 28, 43270);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "tabindex", "0");
			attr_dev(input1, "name", "find");
			attr_dev(input1, "id", "find");
			attr_dev(input1, "class", "form-control form-control-md");
			attr_dev(input1, "title", "Search media Name or Tags");
			attr_dev(input1, "placeholder", "Search Name or Tags");
			add_location(input1, file$n, 995, 40, 48051);
			attr_dev(div8, "class", "form-group pr-1");
			add_location(div8, file$n, 994, 36, 47980);
			attr_dev(label, "for", "start_date");
			attr_dev(label, "class", "fs-6");
			add_location(label, file$n, 1006, 40, 48734);
			attr_dev(div9, "class", "form-group pr-2 mr-1");
			add_location(div9, file$n, 1005, 36, 48658);
			attr_dev(input2, "type", "date");
			attr_dev(input2, "tabindex", "0");
			attr_dev(input2, "autocomplete", "off");
			attr_dev(input2, "name", "start_date");
			attr_dev(input2, "id", "start_date");
			attr_dev(input2, "datepicker", "1");
			attr_dev(input2, "placeholder", "From Date");
			attr_dev(input2, "title", "Search media from uploaded date");
			attr_dev(input2, "class", "form-control-md form-control col-12");
			input2.value = input2_value_value = new Date();
			attr_dev(input2, "dt", "u");
			add_location(input2, file$n, 1009, 40, 48949);
			attr_dev(div10, "class", "form-group pr-2 mr-1 pl-0");
			add_location(div10, file$n, 1008, 36, 48868);
			attr_dev(input3, "type", "date");
			attr_dev(input3, "tabindex", "0");
			attr_dev(input3, "autocomplete", "off");
			attr_dev(input3, "name", "end_date");
			attr_dev(input3, "id", "end_date");
			attr_dev(input3, "datepicker", "1");
			attr_dev(input3, "placeholder", "To Date");
			attr_dev(input3, "title", "Search media till this date");
			attr_dev(input3, "class", "form-control-md form-control col-12");
			input3.value = input3_value_value = new Date();
			attr_dev(input3, "dt", "u");
			add_location(input3, file$n, 1024, 40, 49893);
			attr_dev(div11, "class", "form-group pr-2 pl-1");
			add_location(div11, file$n, 1023, 36, 49817);
			attr_dev(span4, "class", "icomoon-search-3");
			add_location(span4, file$n, 1046, 44, 51240);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "tabindex", "0");
			attr_dev(button1, "class", "btn btn-light btn-md");
			attr_dev(button1, "title", "Search");
			add_location(button1, file$n, 1039, 40, 50821);
			attr_dev(div12, "class", "form-group pr-2");
			add_location(div12, file$n, 1038, 36, 50750);
			attr_dev(span5, "class", "icomoon-24px-reset");
			add_location(span5, file$n, 1057, 44, 51916);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "tabindex", "0");
			attr_dev(button2, "class", "btn btn-light btn-md");
			attr_dev(button2, "title", "Refresh");
			add_location(button2, file$n, 1050, 40, 51482);
			attr_dev(div13, "class", "form-group pr-2");
			add_location(div13, file$n, 1049, 36, 51411);
			attr_dev(div14, "class", "row");
			add_location(div14, file$n, 993, 32, 47925);
			attr_dev(div15, "id", "media_list");
			attr_dev(div15, "class", "mt-4");
			set_style(div15, "height", "100%");
			set_style(div15, "overflow", "auto");
			add_location(div15, file$n, 1080, 32, 53977);
			attr_dev(div16, "class", "tab-pane");
			attr_dev(div16, "id", "gallery_tab");
			set_style(div16, "min-height", "200px");
			add_location(div16, file$n, 992, 28, 47825);
			attr_dev(div17, "class", "tab-content tab_widther");
			add_location(div17, file$n, 938, 24, 43203);
			attr_dev(div18, "class", "form-inline mt-3");
			add_location(div18, file$n, 937, 20, 43147);
			attr_dev(div19, "class", "modal-body pt-0 overflow-auto");
			set_style(div19, "max-height", "426px");
			add_location(div19, file$n, 935, 16, 42974);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "tabindex", "0");
			attr_dev(button3, "class", "btn btn-light mr-3");
			attr_dev(button3, "name", "cancel");
			attr_dev(button3, "id", "cancel");
			attr_dev(button3, "data-bs-dismiss", "modal");
			attr_dev(button3, "aria-hidden", "true");
			button3.value = "Cancel";
			add_location(button3, file$n, 1086, 20, 54238);
			attr_dev(div20, "class", "modal-footer");
			add_location(div20, file$n, 1085, 16, 54190);
			attr_dev(div21, "class", "modal-content");
			add_location(div21, file$n, 923, 12, 42198);
			attr_dev(div22, "class", "modal-dialog modal-dialog-centered modal-lg overflow-hide");
			add_location(div22, file$n, 922, 8, 42113);
			attr_dev(div23, "class", "modal fade upload_containter");
			attr_dev(div23, "id", "modal-media-upload");
			set_style(div23, "z-index", "99999", 1);
			add_location(div23, file$n, 921, 4, 42002);
			attr_dev(h40, "class", "modal-title");
			add_location(h40, file$n, 1106, 20, 55078);
			attr_dev(span6, "aria-hidden", "true");
			add_location(span6, file$n, 1112, 24, 55327);
			attr_dev(button4, "type", "button");
			attr_dev(button4, "class", "close");
			attr_dev(button4, "data-bs-dismiss", "modal");
			add_location(button4, file$n, 1107, 20, 55141);
			attr_dev(div24, "class", "modal-header");
			add_location(div24, file$n, 1105, 16, 55030);
			attr_dev(div25, "class", "media_information_container");
			add_location(div25, file$n, 1116, 20, 55481);
			attr_dev(div26, "class", "modal-body");
			add_location(div26, file$n, 1115, 16, 55434);
			attr_dev(button5, "class", "btn btn-light btn-md media_info_cancel");
			attr_dev(button5, "title", "Cancel");
			attr_dev(button5, "data-bs-dismiss", "modal");
			attr_dev(button5, "tabindex", "0");
			attr_dev(button5, "type", "button");
			attr_dev(button5, "aria-hidden", "true");
			add_location(button5, file$n, 1120, 20, 55641);
			attr_dev(button6, "class", "btn btn-primary btn-md media_info_submit");
			attr_dev(button6, "title", "Upload Details");
			attr_dev(button6, "tabindex", "0");
			attr_dev(button6, "type", "button");
			attr_dev(button6, "aria-hidden", "true");
			add_location(button6, file$n, 1131, 20, 56098);
			attr_dev(div27, "class", "modal-footer");
			add_location(div27, file$n, 1119, 16, 55593);
			attr_dev(div28, "class", "modal-content min_height_500 shadow border border-dark");
			add_location(div28, file$n, 1104, 12, 54944);
			attr_dev(div29, "class", "modal-dialog modal-dialog-centered modal-lg overflow-hide");
			add_location(div29, file$n, 1103, 8, 54859);
			attr_dev(div30, "class", "modal");
			attr_dev(div30, "id", "media_information");
			attr_dev(div30, "tabindex", "-1");
			set_style(div30, "z-index", "99999", 1);
			add_location(div30, file$n, 1102, 4, 54758);
			attr_dev(h41, "class", "modal-title");
			add_location(h41, file$n, 1149, 20, 56842);
			attr_dev(button7, "type", "button");
			attr_dev(button7, "class", "close embed_modal");
			attr_dev(button7, "data-bs-dismiss", "modal");
			attr_dev(button7, "aria-hidden", "true");
			add_location(button7, file$n, 1150, 20, 56908);
			attr_dev(div31, "class", "modal-header");
			add_location(div31, file$n, 1148, 16, 56794);
			attr_dev(input4, "type", "text");
			attr_dev(input4, "name", "embed_code");
			attr_dev(input4, "title", "Embed Link");
			attr_dev(input4, "id", "embed_code");
			attr_dev(input4, "class", "form-control form-control-md pr-2 pointer");
			input4.readOnly = "readonly";
			add_location(input4, file$n, 1161, 24, 57330);
			attr_dev(span7, "class", "icomoon-copy-2");
			attr_dev(span7, "title", "Copy to clipboard");
			add_location(span7, file$n, 1172, 32, 58015);
			attr_dev(button8, "class", "btn btn-light to_be_copied");
			attr_dev(button8, "type", "button");
			attr_dev(button8, "title", "Click to copy");
			add_location(button8, file$n, 1171, 28, 57902);
			attr_dev(span8, "class", "input-group-append tooltip_change section_copied");
			attr_dev(span8, "data-clipboard-target", "#embed_code");
			add_location(span8, file$n, 1170, 24, 57773);
			attr_dev(div32, "class", "input-group");
			add_location(div32, file$n, 1160, 20, 57279);
			attr_dev(div33, "class", "modal-body");
			add_location(div33, file$n, 1159, 16, 57232);
			attr_dev(button9, "class", "btn btn-light btn-md embed_modal");
			attr_dev(button9, "data-bs-dismiss", "modal");
			attr_dev(button9, "title", "Cancel");
			attr_dev(button9, "type", "button");
			attr_dev(button9, "aria-hidden", "true");
			add_location(button9, file$n, 1178, 20, 58268);
			attr_dev(div34, "class", "modal-footer");
			add_location(div34, file$n, 1177, 16, 58220);
			attr_dev(div35, "class", "modal-content shadow border");
			add_location(div35, file$n, 1147, 12, 56735);
			attr_dev(div36, "class", "modal-dialog modal-dialog-centered");
			add_location(div36, file$n, 1146, 8, 56673);
			attr_dev(div37, "class", "modal");
			attr_dev(div37, "id", "details_div");
			attr_dev(div37, "tabindex", "-1");
			set_style(div37, "z-index", "99999", 1);
			add_location(div37, file$n, 1145, 4, 56578);
			attr_dev(div38, "class", "modal_plugin");
			add_location(div38, file$n, 920, 0, 41970);
			attr_dev(button10, "type", "button");
			attr_dev(button10, "class", "btn-close");
			attr_dev(button10, "data-bs-dismiss", "modal");
			attr_dev(button10, "aria-label", "Close");
			add_location(button10, file$n, 1204, 16, 59169);
			attr_dev(div39, "class", "modal-header");
			add_location(div39, file$n, 1203, 12, 59125);
			attr_dev(div40, "id", "lighBoxSlider");
			add_location(div40, file$n, 1207, 16, 59360);
			attr_dev(a2, "href", "#lightBoxControls");
			attr_dev(a2, "class", "lightBoxControls prev text-center");
			set_style(a2, "left", "5%");
			set_style(a2, "padding", "2px 2px 0 0");
			add_location(a2, file$n, 1209, 16, 59458);
			attr_dev(a3, "href", "#lightBoxControls");
			attr_dev(a3, "class", "lightBoxControls next text-center");
			set_style(a3, "right", "5%");
			set_style(a3, "padding", "2px 0 0 2px");
			add_location(a3, file$n, 1217, 16, 59785);
			attr_dev(div41, "class", "modal-body fs-5");
			attr_dev(div41, "id", "lightBoxBody");
			add_location(div41, file$n, 1206, 12, 59295);
			attr_dev(div42, "class", "modal-footer");
			add_location(div42, file$n, 1226, 12, 60129);
			attr_dev(div43, "class", "modal-content");
			set_style(div43, "height", window.innerHeight + "px");
			add_location(div43, file$n, 1202, 8, 59044);
			attr_dev(div44, "class", "modal-dialog");
			attr_dev(div44, "id", "lightBoxDialog");
			set_style(div44, "height", window.innerHeight + "px");
			add_location(div44, file$n, 1201, 4, 58948);
			attr_dev(div45, "class", "modal fade");
			attr_dev(div45, "id", "lightBoxModal");
			attr_dev(div45, "tabindex", "-1");
			attr_dev(div45, "aria-labelledby", "Gallary");
			attr_dev(div45, "aria-hidden", "true");
			set_style(div45, "z-index", "99999", 1);
			add_location(div45, file$n, 1193, 0, 58768);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div38, anchor);
			append_dev(div38, div23);
			append_dev(div23, div22);
			append_dev(div22, div21);
			append_dev(div21, div0);
			append_dev(div0, ul);
			append_dev(ul, li0);
			append_dev(li0, a0);
			append_dev(ul, t1);
			append_dev(ul, li1);
			append_dev(li1, a1);
			append_dev(div0, t3);
			append_dev(div0, button0);
			append_dev(button0, span0);
			append_dev(div21, t5);
			append_dev(div21, div19);
			append_dev(div19, div1);
			append_dev(div19, t6);
			append_dev(div19, div18);
			append_dev(div18, div17);
			append_dev(div17, div7);
			append_dev(div7, div5);
			append_dev(div5, i0);
			append_dev(div5, t7);
			append_dev(div5, div2);
			append_dev(div5, t9);
			append_dev(div5, p);
			append_dev(div5, t11);
			append_dev(div5, link0);
			append_dev(div5, t12);
			append_dev(div5, link1);
			append_dev(div5, t13);
			append_dev(div5, t14);
			append_dev(div5, form);
			append_dev(form, t15);
			append_dev(form, div4);
			append_dev(div4, div3);
			append_dev(div3, span3);
			append_dev(span3, span2);
			append_dev(span2, i1);
			append_dev(span2, t16);
			append_dev(span2, span1);
			append_dev(span2, t18);
			if_block0.m(span2, null);
			append_dev(div7, t19);
			append_dev(div7, div6);
			append_dev(div17, t20);
			append_dev(div17, div16);
			append_dev(div16, div14);
			append_dev(div14, div8);
			append_dev(div8, input1);
			append_dev(div14, t21);
			append_dev(div14, div9);
			append_dev(div9, label);
			append_dev(div14, t23);
			append_dev(div14, div10);
			append_dev(div10, input2);
			append_dev(div14, t24);
			append_dev(div14, div11);
			append_dev(div11, input3);
			append_dev(div14, t25);
			append_dev(div14, div12);
			append_dev(div12, button1);
			append_dev(button1, span4);
			append_dev(div14, t26);
			append_dev(div14, div13);
			append_dev(div13, button2);
			append_dev(button2, span5);
			append_dev(div14, t27);
			if (if_block1) if_block1.m(div14, null);
			append_dev(div16, t28);
			append_dev(div16, div15);
			append_dev(div21, t29);
			append_dev(div21, div20);
			append_dev(div20, button3);
			append_dev(div38, t31);
			append_dev(div38, div30);
			append_dev(div30, div29);
			append_dev(div29, div28);
			append_dev(div28, div24);
			append_dev(div24, h40);
			append_dev(div24, t33);
			append_dev(div24, button4);
			append_dev(button4, span6);
			append_dev(div28, t35);
			append_dev(div28, div26);
			append_dev(div26, div25);
			append_dev(div28, t36);
			append_dev(div28, div27);
			append_dev(div27, button5);
			append_dev(div27, t38);
			append_dev(div27, button6);
			append_dev(div38, t40);
			append_dev(div38, div37);
			append_dev(div37, div36);
			append_dev(div36, div35);
			append_dev(div35, div31);
			append_dev(div31, h41);
			append_dev(div31, t42);
			append_dev(div31, button7);
			append_dev(div35, t44);
			append_dev(div35, div33);
			append_dev(div33, div32);
			append_dev(div32, input4);
			append_dev(div32, t45);
			append_dev(div32, span8);
			append_dev(span8, button8);
			append_dev(button8, span7);
			append_dev(div35, t46);
			append_dev(div35, div34);
			append_dev(div34, button9);
			insert_dev(target, t48, anchor);
			insert_dev(target, div45, anchor);
			append_dev(div45, div44);
			append_dev(div44, div43);
			append_dev(div43, div39);
			append_dev(div39, button10);
			append_dev(div43, t49);
			append_dev(div43, div41);
			append_dev(div41, div40);
			append_dev(div41, t50);
			append_dev(div41, a2);
			append_dev(div41, t52);
			append_dev(div41, a3);
			append_dev(div43, t54);
			append_dev(div43, div42);

			if (!mounted) {
				dispose = [
					listen_dev(a1, "click", /*getMedia*/ ctx[5], false, false, false),
					listen_dev(button1, "click", /*getMedia*/ ctx[5], false, false, false),
					listen_dev(button2, "click", /*getMedia*/ ctx[5].bind(this, 1), false, false, false),
					listen_dev(button5, "click", /*onCancelMediaInfo*/ ctx[2], false, false, false),
					listen_dev(button6, "click", /*mediaInfoSubmit*/ ctx[3], false, false, false),
					listen_dev(input4, "click", click_handler, false, false, false),
					listen_dev(a2, "click", /*navigateGallary*/ ctx[6].bind(this, -1), false, false, false),
					listen_dev(a3, "click", /*navigateGallary*/ ctx[6].bind(this, 1), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(span2, null);
				}
			}

			if (/*default_media_configuration*/ ctx[0].select_multiple_media == "true") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$i(ctx);
					if_block1.c();
					if_block1.m(div14, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div38);
			if_block0.d();
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t48);
			if (detaching) detach_dev(div45);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const MEDIA_URL = '//s3.amazonaws.com/jigyaasa_content_static/';

// for comparing the 2 array return 0 if all the tree element will be in the branch
function compareArray(tree, branch) {
	let matchedBranch = [];

	for (let index = 0; index < tree.length; index++) {
		for (let sub_index = 0; sub_index < branch.length; sub_index++) {
			if (branch[sub_index] == tree[index]) {
				matchedBranch.push(branch[sub_index]);
				continue;
			}
		}
	}

	let result = tree.length - matchedBranch.length;
	return result < 0 ? 0 : result;
}

//     dataType: 'text', // what to expect back from the PHP script, if anything
//     cache: false,
//     contentType: false,
//     processData: false,
//     data: form_data,
//     type: 'POST',
//     success: function(php_script_response) {
//         media_variable.upload_success_ajax_count++;
//         if (media_variable.upload_success_ajax_count == media_variable.upload_ajax_count) {
//             media_variable.upload_success_ajax_count = 0;
//             media_variable.upload_ajax_count = 0;
//             if ($('.modal-body a[data-bs-toggle="tab"].active').attr('href') == '#S3') {
//                 $('#S3').prepend('<div class="alert alert_epub alert-success"><a href="#" class="close" data-bs-dismiss="alert" aria-label="close">&times;</a><strong>Images are successfully uploaded</strong><div>Your Folder Path is s3.amazonaws.com/jigyaasa_content_static/' + $("#folder_name").val() + '/</div></div>');
//             }
//             if ($('.modal-body a[data-bs-toggle="tab"].active').attr('href') == '#LO_merge') {
//                 $('.download_lo').show();
//             }
//             media_information_modal.hide();
//             activate(0);
//         }
//     }
// });
// function for fetching unique data in the array
function uniqueData(value, uni_index, self) {
	return self.indexOf(value) === uni_index;
}

/** Used in case of select_multiple_media : true */
function selectMedias() {
	
} //$('.checkbox_container').removeClass('d-none');

function enableOptions() {
	
} // var is_checkbox_checked = 0;
// $('.file_select').each(function() {

//     if (($(this).prop('checked'))) {
//         return is_checkbox_checked = 1;
//     }
// });
// if (is_checkbox_checked) {
//     $('.useSelectedMedia').removeClass('disable_license pointer_event_none').removeAttr('tabindex style');
//     $('.useSelectedMedia').parent().addClass('dropdown-item pointer');
//     $('.use_media').hide();
// } else {
//     $('.useSelectedMedia').addClass('disable_license pointer_event_none').attr({
//         'tabindex': '-1',
//         'style': 'margin: 0 0 6px 11px',
//     });
//     $('.useSelectedMedia').parent().removeClass('dropdown-item pointer');
//     $('.use_media').show();
// }
function useSelectedMedia() {
	
} // var file_name = '';
// $('.file_select:checked').each(function() {

const click_handler = e => e.target.select();

function instance$n($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Media', slots, []);

	let { default_media_configuration = {
		file_type: 'image/*', // required parameter, for file type by default it will be image/*
		file_ext: 'png,gif,jpg,jpeg,svg', // required parameter, for file extension by default it will be png,gif,jpg,jpeg,svg
		max_file_allowed: 4, // no of files allowed at a time for uploading, by default its value is 4 if there is no limit for the no of files uploading set its value to "no-limit"
		file_size: 3, // file size in MB
		set_name: false, // Set directly files name to the textbox, by default it will be false
		select_multiple_media: false, // if it is true multiple media can be selected, by default it will be false it will only work in when autoload="true" & is_author: "0"
		append_in: 'body', // in which element, tag or class the data will append if not given then its default value will be body and will append in body
		auto_load: true, // for auto loading of script by default it will be true
		review_media_dialog: true, // for review media dialog visibility by default it will be true
		is_author: 0, // 0 when only uploading fucntionality needed that is no gallery needed.
		
	} } = $$props;

	let is_react = 1;
	let upload_field_id = "";
	let thumbnail_data = [];
	let uploaded_file = '';
	let uploaded_file_mceu = '';
	let manual_item_id = '#authoring-modal #base-bgimg, #MatchlistImg, #backgroundImage, #img, #drag-image';

	const media_array = {
		'pdf': 'pdf_000nsM.png',
		'mp3': 'mp3_000nsm.png',
		'xlsx': 'excel_sheet_000nsl.png',
		'xls': 'excel_sheet_000nsl.png',
		'ppt': 'ptt_image_000nsL.jpg',
		'pptx': 'ptt_image_000nsL.jpg',
		'zip': 'zip-file-format-489644_000nsn.png',
		'other': 'doc_icon_000nsN.png'
	};

	let html = '';
	let files;
	let mediaData = {};

	let media_variable = {
		first_time_msg: 1,
		video_count: 0,
		ajax_count: 0,
		upload_ajax_count: 0,
		upload_success_ajax_count: 0
	};

	let media_information_modal;
	let media_upload_modal;

	onMount(() => {
		init();

		if (window.AI) {
			window.AI.editorModal = setImage;
			window.setImage = setImage;
		}

		var clipboard = new ClipboardJS('.section_copied');

		clipboard.on('success', function (e) {
			AH.showmsg('Image Source has been copied to the clipboard!');
		});

		clipboard.on('error', function (e) {
			AH.showmsg('There is some issue!');
		});
	});

	AH.listen("body", 'click', '.embed', function (_this) {
		AH.select('#embed_code').value = _this.getAttribute('data-image');
	});

	// for setting the default configuration
	function setConfiguration() {
		// set the configuration in local variable 
		if (window.default_media_configuration != undefined) {
			$$invalidate(0, default_media_configuration = window.default_media_configuration);
		}

		// if autoload is not given then set the value of auto load to true by default
		if (default_media_configuration.auto_load == undefined) {
			$$invalidate(0, default_media_configuration.auto_load = true, default_media_configuration);
		}

		// if review_media_dialog is not given then set its value to true by default
		if (default_media_configuration.review_media_dialog == undefined) {
			$$invalidate(0, default_media_configuration.review_media_dialog = true, default_media_configuration);
		}

		// if max_file_allowed is not given then 4 will be set by default
		if (default_media_configuration.max_file_allowed == undefined) {
			$$invalidate(0, default_media_configuration.max_file_allowed = 4, default_media_configuration);
		}

		// set is_author value 0 if it is not given
		if (default_media_configuration.is_author == undefined) {
			$$invalidate(0, default_media_configuration.is_author = 0, default_media_configuration);
		}

		// by default append in the body
		if (default_media_configuration.append_in == undefined) {
			$$invalidate(0, default_media_configuration.append_in = 'body', default_media_configuration);
		}

		// if file size is not given the 3MB will set by default
		if (default_media_configuration.file_size == undefined) {
			$$invalidate(0, default_media_configuration.file_size = 3, default_media_configuration);
		}

		// by default set_name will set to false if not given
		if (default_media_configuration.set_name == undefined) {
			$$invalidate(0, default_media_configuration.set_name = false, default_media_configuration);
		}

		// by default select_multiple_media will set to false if not given
		if (default_media_configuration.select_multiple_media == undefined) {
			$$invalidate(0, default_media_configuration.select_multiple_media = false, default_media_configuration);
		}

		// if file_type or file_ext is not given then by default this value will be set
		if (default_media_configuration.file_ext == undefined || default_media_configuration.file_type == undefined) {
			$$invalidate(0, default_media_configuration.file_type = 'image/*', default_media_configuration);
			$$invalidate(0, default_media_configuration.file_ext = 'png,gif,jpg,jpeg,svg', default_media_configuration);
		}
	}

	// for initiation the media plugin
	function init() {
		setConfiguration();
		mediaData.start_date = new Date('%d-%b-%y');
		mediaData.end_date = new Date('%d-%b-%y');

		if (default_media_configuration.auto_load) {
			if (default_media_configuration.is_editor) ; // call in smeditor
			//getHtml(1);
		} else {
			refresh();
		}

		//Get modal Refrences.
		media_upload_modal = AH.getBS("#modal-media-upload", 'Modal');

		media_information_modal = AH.getBS("#media_information", 'Modal', { backdrop: 'static', keyboard: false });
		AH.addTagViewCss();

		AH.listen(document, 'click', '.gridViewImg', (_this, event) => {
			showGallary(_this);
			return false;
		});
	}

	// function getHtml(isLoader) {
	//     AH.ajax({
	//         url: baseUrl + "media_modal_box/index.php",
	//         data: default_media_configuration,
	//         onStart: function() {
	//             isLoader && activate(2);
	//         },
	//     }).then((data)=> {
	//         html = data;
	//         refresh();
	//         isLoader && activate(0);
	//     });
	// }
	// responsible for adding the scripts into head
	function mergingScript(url) {
		let imported = document.createElement('script');
		imported.src = baseUrlTheme + url;
		AH.insert('.modal_plugin', imported, 'afterend');
	}

	// add the media plugin and neccesary script into the dom
	function refresh() {
		AH.select('.modal_plugin').remove?.();

		//AH.insert(default_media_configuration.append_in, '<div class="modal_plugin">' + html + '</div>', 'afterend');
		getLibraryFiles();

		bindUpEvents();
		console.log("Media Initiallize");
	}

	function setImage(action, file) {
		if (action != 0) {
			media_upload_modal.show?.();
			upload_field_id = action;
		} else if (document.getElementById(upload_field_id)) {
			document.getElementById(upload_field_id).value = file;
			AH.trigger(document.getElementById(upload_field_id), 'change');
		} else {
			try {
				window.frames['authoringFrame'].document.getElementById(upload_field_id).value = file;
				AH.trigger(window.frames['authoringFrame'].document.getElementById(upload_field_id), 'change');
			} catch(error) {
				console.log(error);
			}
		}
	}

	/** Some common drag & drop events used for the media plugin */
	function bindUpEvents() {
		let obj = document.getElementById("dragandrophandler");

		AH.listen(document, 'dragenter', '#dragandrophandler', function (_this, e) {
			e.stopPropagation();
			e.preventDefault();
			_this.style.border = '2px doted #92AAB0';
		});

		AH.listen(document, 'dragover', '#dragandrophandler', function (_this, e) {
			e.stopPropagation();
			e.preventDefault();
		});

		AH.listen(document, 'drop', '#dragandrophandler', function (_this, event) {
			_this.style.border = '2px dotted #0B85A1';
			event.preventDefault();
			thumbnail_data = [];
			let dragged_files = event.originalEvent.dataTransfer.files;
			window.files = dragged_files;

			if (validateConfig(dragged_files)) {
				if (default_media_configuration.review_media_dialog) {
					handleFileSelect(event);

					var media_timeout = setTimeout(
						function () {
							fetchFileData(dragged_files);
							clearTimeout(media_timeout);
						},
						100
					);
				} else {
					uploadFiles(dragged_files);
				}
			}
		});

		AH.listen(document, 'dragenter', '.upload_containter', function (_this, e) {
			e.stopPropagation();
			e.preventDefault();
		});

		AH.listen(document, 'dragover', '.upload_containter', function (_this, e) {
			e.stopPropagation();
			e.preventDefault();
			obj.css('border', '2px dotted #0B85A1');
		});

		AH.listen(document, 'drop', '.upload_containter', function (_this, e) {
			e.stopPropagation();
			e.preventDefault();
		});

		AH.listen(document).on('click', '#blueimp-gallery .description', function (_this, e) {
			if (e.target.id == 'description') {
				if (AH.select('.description-table').visible) {
					AH.select('.description-table').classList.add('h');
				} else {
					AH.select('.description-table').classList.remove('h');
				}
			}
		});

		AH.listen(document, 'click', '.media_info_cancel', function (_this) {
			thumbnail_data = [];
			media_information_modal.hide();
		});

		AH.listen(document, 'change', '#fileUploadSelector', function (_this, event) {
			var choosed_file = event.target.files;
			window.files = choosed_file;

			if (validateConfig(choosed_file)) {
				if (default_media_configuration.review_media_dialog) {
					showmsg('Processing Media', "", 1);
					handleFileSelect(event);

					var media_timeout = setTimeout(
						function () {
							fetchFileData(choosed_file);
							clearTimeout(media_timeout);
						},
						100
					);
				} else {
					uploadFiles(choosed_file);
				}
			}
		});

		// for epub condition
		if (default_media_configuration.is_epub == 1) {
			AH.listen(document, 'click', '#fileUploadSelector', function (_this, event) {
				var accepted_type = '';

				if (AH.select('.modal-body a[data-bs-toggle="tab"].active ').getAttribute('href') == '#LO_merge') {
					accepted_type = '.html,.xhtml,.xml,.dita';
					$$invalidate(0, default_media_configuration.file_ext = 'html,xhtml,xml,dita', default_media_configuration);
				} else {
					accepted_type = 'image/*';
					$$invalidate(0, default_media_configuration.file_ext = 'png,gif,jpg,jpeg,svg', default_media_configuration);
				}

				AH.select("#fileUploadSelector").setAttribute('accept', accepted_type);
				$$invalidate(0, default_media_configuration.file_type = accepted_type, default_media_configuration);
			});
		}

		AH.listen(document, 'keyup', '.fileinput-button', function (_this, event) {
			if (event.keyCode == 13) {
				AH.trigger('#fileUploadSelector', 'click');
			}
		});

		AH.listen(document, 'keyup keydown', '.media_loader_activate', function (_this, event) {
			if (event.keyCode == 9) {
				event.preventDefault();
			}
		});

		AH.listen(document.body, 'shown.bs.modal', '#modal-media-upload', function () {
			AH.select('.fileinput-button').focus();
		});

		AH.listen(document.body, "hidden.bs.modal", '#modal-media-upload', function () {
			AH.trigger('#tab1', 'click');
		});

		AH.listen(document.body, 'click', '.upload_containter #tab2', function () {
			if (AH.selectAll('#media_list', 'empty').length > 0 || AH.findChild('#media_list', '.no_media_found')) {
				getMedia();
			}
		});

		AH.listen(document.body, 'click', '.upload_containter #tab1', function () {
			AH.activate(0);
		});

		AH.listen(document.body, 'focus', '.bootstrap-tagsinput input', function (_this) {
			_this.parentElement.classList.add('focus');
		});

		AH.listen(document.body, 'blur', '.bootstrap-tagsinput input', function (_this) {
			_this.parentElement.classList.remove('focus');
		});
	}

	function onCancelMediaInfo() {
		AH.select("#fileUploadSelector", 'value', '');
	}

	function mediaInfoSubmit(event) {
		var is_blank = 0;

		AH.selectAll('[require="1"]').forEach(function (elem) {
			if (elem.value == '') {
				return is_blank = 1;
			}
		});

		if (is_blank == 0) {
			for (let index = 0; index < files.length; index++) {
				if (document.getElementById('image_file' + index) != null) {
					var width = document.getElementById('image_file' + index).naturalWidth;
					var height = document.getElementById('image_file' + index).naturalHeight;
					AH.select('[ data-dimension="' + index + '"]').value = width + "*" + height;
				}

				AH.selectAll("[data-index='" + index + "']").forEach(function (element, value) {
					var key = element.getAttribute('data-key');
					$$invalidate(1, files[index][key] = element.value, files);
				});
			}

			uploadFiles(files);
			thumbnail_data = [];
		} else {
			AH.showmsg?.("Please enter all the fields!");
		}
	}

	function onUploadMedia(event) {
		event.preventDefault();
		thumbnail_data = [];

		//let dragged_files = event.originalEvent.dataTransfer.files;
		window.files = files;

		if (validateConfig(files)) {
			if (default_media_configuration.review_media_dialog) {
				handleFileSelect(event);

				var media_timeout = setTimeout(
					function () {
						fetchFileData(files);
						clearTimeout(media_timeout);
					},
					100
				);
			} else {
				uploadFiles(files);
			}
		}
	}

	// for validation the configuration
	function validateConfig(files) {
		if (files.length == 0) {
			return 0;
		}

		let is_error = 0;
		let error_msg = '';

		if (default_media_configuration.max_file_allowed != 'no-limit' && files.length > default_media_configuration.max_file_allowed) {
			is_error = 1;
			error_msg = 'Maximum ' + default_media_configuration.max_file_allowed + ' file is allowed at a time!';
		}

		let file_size_exceed = 0;
		let file_ext = [];

		for (let index = 0; index < files.length; index++) {
			if (!file_size_exceed && (files[index].size / (1024 * 1024)).toFixed(2) > default_media_configuration.file_size) {
				file_size_exceed = 1;
			}

			let cur_ext = files[index].name.substr(files[index].name.lastIndexOf('.') + 1, files[index].name.length);
			file_ext.push(cur_ext.toLowerCase());
		}

		file_ext = file_ext.filter(uniqueData);

		if (file_size_exceed) {
			is_error = 1;
			error_msg = 'Maximum ' + default_media_configuration.file_size + 'MB file is allowed!';
		}

		if (compareArray(file_ext, default_media_configuration.file_ext.toLowerCase().split(',')) != 0) {
			is_error = 1;

			error_msg = 'Only ' + default_media_configuration.file_ext.toLowerCase().split(',').join(', ').replace(/  +/g, ' ') + '  ' + (default_media_configuration.file_ext.split(',').length > 1
			? 'extensions are'
			: 'extension is') + ' allowed!';
		}

		if (is_error) {
			typeof showmsg == "function" && showmsg(error_msg, "", 1);
			return 0;
		} else {
			return 1;
		}
	}

	// for adding the info into the media_information's review media dialog 
	function fetchFileData(files, data) {
		media_information_modal.show?.();
		let media_details = files.length ? '<form id="media_details">' : '';

		for (let index = 0; index < files.length; index++) {
			let image_name = '';
			let ext = files[index].name.substr(files[index].name.lastIndexOf('.') + 1, files[index].name.length);

			if (media_array[ext] == undefined) {
				image_name = media_array['other'];
			} else {
				image_name = media_array[ext];
			}

			media_details += `<div class="accordion" id="media_details_${index}">
            <div class="card mb-2 border-bottom rounded">
                <div class="card-header py-1">
                    <span class="my-0 this_header">
                        <button tabindex="0" title="Media Name: ${files[index].name}" class="btn font18 font-weight-bold text-dark text-decoration-none text-left w-100" type="button" data-bs-toggle="collapse" data-target="#collapse_${index}" aria-expanded="true" aria-controls="collapseOne">
                            <span>Media Name: ${files[index].name}</span>
                            <i class="float-right s4 mt-1 text-dark icomoon-new-24px-arrow-down-2"></i>
                        </button>
                    </span>
                </div>
                <div id="collapse_${index}" class="collapse ${index == 0 ? `show` : ``}" data-parent="#media_details_${index}">
                    <div class="card-body mx-3 px-0 my-2 py-0">
                        <div class="col-md-4 m-b-lg p-lg-0 p-md-2 pull-left px-0">
                            <center>
                                ${files[index].type.match('image')
			? `<img width="245" title="${files[index].name}" alt="${files[index].name}" id="image_file${index}" data-file="${index}" src="${thumbnail_data[index]}" /><input type="hidden"  data-index="${index}" data-key="dimension"  data-dimension="${index}"/>`
			: files[index].type.match('video')
				? `<img width="100"  title="${files[index].name}" alt="${files[index].name}" data-file="${index}" src="${MEDIA_URL}loading_000b6Q.gif" /><input type="hidden" data-key="thumbnail" data-index="${index}" data-thumbnail="${index}"/>`
				: `<img width="245" src="${MEDIA_URL + image_name}"  title="${files[index].name}" alt="${files[index].name}"/>`}
                            </center>
                        </div>
                        <div class="col-md-8 px-0 m-b-lg pull-left">
                            <div class="col-md-12 px-0 pull-left pb-3">
                                <label for="alt_text${index}" class="control-label float-left pr-4"><span class="mendatory_label float-left">Short Desctiption</span></label>
                                <input type="text" require="1" title="Short Desctiption" class="col-md-12 float-left form-control height32 m-b-sm" data-key="alt"  data-index="${index}" placeholder="Short Desctiption" name="alt_text${index}" id="alt_text${index}" />
                            </div>
                            <div class="col-md-12 px-0 pull-left pb-3">
                                <label for="related_tags${index}" class="control-label float-left pr-4"><span class="mendatory_label float-left">Tags</span></label>
                                <input type="text" require="1" title="Add multiple tags by pressing Enter key" class="col-md-12 float-left form-control height32 m-b-sm" data-key="tags" data-role="tagsinput" data-index="${index}" placeholder="Add multiple tags by pressing Enter key" name="related_tags${index}" id="related_tags${index}" />
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>`;
		}

		media_details += files.length ? '</form>' : '';
		window.files = files;
		AH.select('.media_information_container').innerHTML = media_details;

		//$("input[data-role=tagsinput]").tagsinput();
		AH.setAttr('.bootstrap-tagsinput input', {
			'title': 'Add multiple tags by pressing Space key',
			'tabindex': 0,
			'size': '39'
		});

		AH.enableTagView({ separator: " " });
	}

	// for reading the files and getting the thumbnail
	function handleFileSelect(event, files) {
		if (window.File && window.FileList && window.FileReader) {
			let selected_files = files || (event.target.files || event.originalEvent.dataTransfer.files);
			media_variable.first_time_msg = 1;
			media_variable.video_count = 0;
			media_variable.ajax_count = 0;

			for (let index = 0; index < selected_files.length; index++) {
				let file = selected_files[index];

				if (file.type.match('image')) {
					let thumbnail_creater = new FileReader();
					thumbnail_creater.addEventListener("load", imageLoad.bind(this, index));
					thumbnail_creater.readAsDataURL(file);
				} else if (file.type.match('video')) {
					let video_thumbnail_creater = new FileReader();
					video_thumbnail_creater.onload = videoLoad.bind(this, index, file, video_thumbnail_creater);
					video_thumbnail_creater.readAsArrayBuffer(file);
				}
			}
		} else {
			console.log("Your browser does not support File API");
		}
	}

	// save the data into the thumbnail arary
	function imageLoad(index, event) {
		thumbnail_data[index] = event.target.result;
	}

	// for extracting the thumbnail of video
	function videoLoad(index, file, video_thumbnail_creater) {
		let blob = new Blob([video_thumbnail_creater.result], { type: file.type });
		let url = URL.createObjectURL(blob);
		media_variable.video_count++;
		let video = document.createElement('video');

		var timeupdate = function () {
			if (snapImage() || AH.select('#media_information').hidden) {
				video.removeEventListener('timeupdate', timeupdate);
				video.pause();
			}
		};

		video.addEventListener('loadeddata', function () {
			if (snapImage() || AH.select('#media_information').hidden) {
				video.removeEventListener('timeupdate', timeupdate);
			}
		});

		var snapImage = function () {
			AH.select('.media_info_submit').setAttribute('disabled', true);
			let canvas = document.createElement('canvas');
			canvas.width = video.videoWidth;
			canvas.height = video.videoHeight;
			canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
			let image = canvas.toDataURL();
			let success = image.length > 100000;

			if (success) {
				thumbnail_data[index] = image;
				AH.setAttr('[data-file="' + index + '"]', { 'src': image, 'width': '245' });
				AH.activate(2);

				if (media_variable.first_time_msg == 1) {
					showmsg('Processing Video File!', "", 1);
					media_variable.first_time_msg = 0;
				}

				AH.ajax({
					url: baseUrl + "forms.php?func=upload_screen_shots&ajax=1&source=paste&index=0",
					data: { type: "data", image }
				}).then(data => {
					let s3Url = JSON.parse(data);
					AH.select('[data-thumbnail ="' + index + '"]').value = s3Url.url[0]['server'];
					media_variable.ajax_count++;

					if (media_variable.ajax_count < media_variable.video_count) {
						AH.showmsg(media_variable.ajax_count + ' File is processed!', "", 1);
					}

					if (media_variable.video_count == media_variable.ajax_count) {
						AH.select('.media_info_submit').disabled = false;
						AH.showmsg('Processing of file is done!', "", 1);
						AH.activate(0);
					}

					URL.revokeObjectURL(url);
				}).catch(e => {
					AH.activate(0);
					showmsg('File is not processed successfully, Please upload all the files again!');
					media_information_modal.hide();
				});
			}

			return success;
		};

		video.addEventListener('timeupdate', timeupdate);
		video.preload = 'metadata';
		video.src = url;

		// Load video in Safari / IE11
		video.muted = true;

		video.playsInline = true;
		video.playbackRate = 4.0;
		video.play();
	}

	// for uploading the files
	function uploadFiles(_files) {
		media_variable.upload_ajax_count = _files.length;
		let config = default_media_configuration;
		AH.select('.upload_video_msg').innerHTML = '';

		Array.prototype.forEach.call(_files, _f => {
			var form_data = new FormData();
			form_data.append('Filedata', _f);

			// add data only when the data is needed
			if (default_media_configuration.review_media_dialog) {
				form_data.append('alt', _f.alt);
				form_data.append('tags', _f.tags);

				if (_f.thumbnail != undefined) {
					form_data.append('thumbnail', _f.thumbnail);
				} else {
					form_data.append('thumbnail', '');
				}

				if (_f.dimension != undefined) {
					form_data.append('dimension', _f.dimension);
				} else {
					form_data.append('dimension', '');
				}
			}

			if (config.complete_data && config.complete_data.func == "download_resources") {
				// for educator upload
				educatorUpload(_files, form_data, key, config);
			} else if (config.complete_data && config.complete_data.func == "annotated_listing") {
				// for annotater upload                    
				createTableFromImage(form_data, _files);
			} else if (config.is_epub) {
				// in case of epub
				form_data.append('upload_type', AH.select('.modal-body a[data-bs-toggle="tab"].active').getAttribute('href'));

				form_data.append('folder', AH.select('#folder_name').value);
				epubUpload(_files, form_data, key);
			} else {
				// for editor and author/?func=media uploading
				form_data.append('from_editor', is_react);

				mediaUpload(_files, form_data, "key", config);
			}
		});
	}

	// for library files or dependencies
	function getLibraryFiles() {
		if (default_media_configuration.is_editor) {
			// mergingScript('svelte_items/script/media_merge.min.js'); 
			return true;
		}

		// for the file uploading 
		// mergingScript('ux/media_modal_box/js/vendor/jquery.ui.widget.js');
		// mergingScript('media_modal_box/blueimp/js/tmpl.min.js');
		// mergingScript('ux/media_modal_box/js/jquery.fileupload.js');
		// mergingScript('ux/media_modal_box/js/main.js');
		// for the gallery script
		if (default_media_configuration.image_annotation) {
			mergingScript('media_modal_box/imageAnnotation.min.js');
		}

		if (!default_media_configuration.is_author) {
			mergingScript('media_modal_box/blueimp/js/blueimp-gallery.js');
			mergingScript('media_modal_box/blueimp/js/blueimp-gallery-fullscreen.js');
			mergingScript('media_modal_box/blueimp/js/blueimp-gallery-indicator.js');
			mergingScript('media_modal_box/blueimp/js/jquery.blueimp-gallery.js');
		}
	}

	// for handling the educator upload
	function educatorUpload(files, form_data, key, config) {
		let educator_url;

		if (for_instructor == 1) {
			educator_url = baseUrl + 'lib/upload.php?func=download_resources&course_code=' + config.complete_data.course_code + '&for_instructor=1';

			if (config.complete_data.from_myproject == 1) {
				educator_url = baseUrl + 'lib/upload.php?func=download_resources&course_code=' + config.complete_data.course_code + '&for_instructor=1&from_myproject=1';
			}
		} else {
			// only this url is in use @TODO:- Discuss it with pete sir
			educator_url = baseUrl + 'lib/upload.php?func=download_resources&course_code=' + config.complete_data.course_code + '&class_code=' + config.complete_data.class_code;

			if (config.complete_data.from_myproject == 1) {
				educator_url = baseUrl + 'lib/upload.php?func=download_resources&course_code=' + config.complete_data.course_code + '&class_code=' + config.complete_data.class_code + '&from_myproject=1';
			}
		}

		AH.activate(2);

		AH.ajax({
			url: educator_url, // point to server-side PHP script 
			dataType: 'text', // what to expect back from the PHP script, if anything
			cache: false,
			contentType: false,
			processData: false,
			data: form_data
		}).then(res => {
			media_variable.upload_success_ajax_count++;

			if (media_variable.upload_success_ajax_count == media_variable.upload_ajax_count) {
				media_variable.upload_success_ajax_count = 0;
				media_variable.upload_ajax_count = 0;
				media_information_modal.hide();
				window.location.reload();
				AH.activate(0);
			}
		});
	}

	// for handling the normal media upload
	function mediaUpload(_files, form_data, key, config) {
		AH.activate(2);
		form_data.forEach(e => console.log(e));
		AH.setCss("#mceu_17", { 'z-index': 'unset' });
		AH.setCss("#modal-media-upload", { 'z-index': '1' });

		AH.ajax({
			url: baseUrl + 'lib/upload.php', // point to server-side PHP script 
			dataType: 'text', // what to expect back from the PHP script, if anything
			formData: true,
			contentType: false,
			processData: false,
			data: form_data
		}).then((file, data, response) => {
			AH.activate(0);
			media_variable.upload_success_ajax_count++;
			file = file.replace(/\s+/g, ' ').trim();
			var from_media = config.from_media;
			AH.showmsg(`${file} uploaded successfully!`);

			if (from_media != 1) {
				AH.setCss("#mceu_17", { 'z-index': '1050' });
				AH.setCss("#mce-modal-block", { 'z-index': '1049' });

				if (config.set_name) {
					uploaded_file += file + ',';
					uploaded_file_mceu += MEDIA_URL + file + ',';
				}
			}

			if (media_variable.upload_success_ajax_count == media_variable.upload_ajax_count) {
				media_variable.upload_success_ajax_count = 0;
				media_variable.upload_ajax_count = 0;

				if (from_media == 1) {
					media_information_modal.hide();
					window.location.reload();
				} else {
					if (config.set_name) {
						uploaded_file = uploaded_file.slice(uploaded_file, -1);
						uploaded_file_mceu = uploaded_file_mceu.slice(uploaded_file_mceu, -1);

						try {
							if (window.parent.setImage) {
								window.parent.setImage(0, uploaded_file);
							} else {
								setImage(0, uploaded_file);
							}
						} catch(e) {
							
						}

						var fieldnme = AH.select('.mce-imageUploadField').value;

						if (AH.selectAll("." + fieldnme).length && fieldnme != undefined) {
							AH.select('.' + fieldnme + ' .mce-textbox').value = uploaded_file_mceu;
						} else {
							AH.selectAll(manual_item_id, 'value', uploaded_file);
						}

						media_upload_modal.hide();
						uploaded_file = '';
						uploaded_file_mceu = '';
					}

					AH.remove('#media_list .main_div');
					getMedia(0, _files.length);
					media_information_modal.hide();
				}

				AH.activate(2);
			}
		});
	}

	// for epub uploading
	function epubUpload(files, form_data, key, config) {
		AH.activate(2);
	} // AH.ajax({
	//     url: baseUrl + 'author/epub/index.php', // point to server-side PHP script 

	// function for fetching the file name
	window.imageUploadFromGallery = function (file_name, is_multiple = 0) {
		try {
			let field_name = AH.select('.mce-imageUploadField').value;

			if (field_name != undefined && AH.selectAll("." + field_name).length && is_multiple != 1) {
				AH.select('.' + field_name + ' .mce-textbox').value = MEDIA_URL + file_name;
			} else {
				AH.selectAll(manual_item_id, 'value', file_name);

				setTimeout(
					() => {
						if (window.parent.setImage) {
							window.parent.setImage(0, file_name);
						} else {
							setImage(0, file_name);
						}
					},
					500
				);
			}

			media_upload_modal.hide();
		} catch(msg) {
			console.log({ error: msg });
		}
	};

	// function for copy the s3 url
	window.copyUrl = function (event_id) {
		let text = document.getElementById(event_id).value;
		let input_box = document.createElement('input');
		input_box.value = text;
		document.body.appendChild(input_box);
		input_box.select();
		document.execCommand("copy");
		document.body.removeChild(input_box);
	};

	// for geting the media list
	function getMedia(is_refresh, recent_files = 0) {
		if (is_refresh) {
			recent_files = AH.selectAll('.new_media').length;
		}

		let url = baseUrl + "media_modal_box/index.php?func=getMedia&find=" + AH.select('#find').value + "&start_date=" + AH.select('#start_date').value + "&end_date=" + AH.select('#end_date').value + "&recent_files=" + recent_files;
		AH.activate(2);

		AH.ajax({
			url,
			cache: false,
			data: default_media_configuration
		}).then(data => {
			AH.select('#media_list').innerHTML = data;
			is_refresh ? AH.showmsg('Media List Refresh!', 1) : '';
			AH.activate(0);
		});
	}

	//     file_name += $(this).val() + ',';
	//     $(this).prop('checked', false);
	// });
	// file_name = file_name.slice(file_name, -1);
	// $('.checkbox_container').addClass('d-none');
	// enableOptions();
	// imageUploadFromGallery(file_name, 1);
	function navigateGallary(seq) {
		let currentImg = AH.select(".showSlide");
		AH.select(currentImg, 'removeClass', 'showSlide');

		if (seq == 1) {
			AH.select(currentImg.nextElementSibling, 'addClass', 'showSlide');
		} else {
			AH.select(currentImg.previousElementSibling, 'addClass', 'showSlide');
		}
	}

	function showGallary(_curr) {
		let allImage = AH.selectAll('.gridViewImg');
		let slideHtml = '';

		allImage.forEach((_img, index) => {
			let mGuid = _img.parentElement.getAttribute('media_guid');
			let isSame = _img.isSameNode(_curr);

			slideHtml += `
                <div seq="${index}" class="lightBoxSlides ${isSame ? 'showSlide' : ''}" mGuid="${mGuid}">
                    <div class="numbertext">
                        ${_img.id} 
                    </div>
                    ${_img.outerHTML}
                </div>
            `;
		});

		AH.getBS("#lightBoxModal", 'Modal').show();
		AH.select("#lighBoxSlider").innerHTML = slideHtml;
		return false;
	}

	const writable_props = ['default_media_configuration'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$9.warn(`<Media> was created with unknown prop '${key}'`);
	});

	function input_change_handler() {
		files = this.files;
		$$invalidate(1, files);
	}

	function input_change_handler_1() {
		files = this.files;
		$$invalidate(1, files);
	}

	$$self.$$set = $$props => {
		if ('default_media_configuration' in $$props) $$invalidate(0, default_media_configuration = $$props.default_media_configuration);
	};

	$$self.$capture_state = () => ({
		onMount,
		AH,
		default_media_configuration,
		is_react,
		upload_field_id,
		MEDIA_URL,
		thumbnail_data,
		uploaded_file,
		uploaded_file_mceu,
		manual_item_id,
		media_array,
		html,
		files,
		mediaData,
		media_variable,
		media_information_modal,
		media_upload_modal,
		setConfiguration,
		init,
		mergingScript,
		refresh,
		setImage,
		bindUpEvents,
		onCancelMediaInfo,
		mediaInfoSubmit,
		onUploadMedia,
		validateConfig,
		fetchFileData,
		handleFileSelect,
		imageLoad,
		videoLoad,
		uploadFiles,
		getLibraryFiles,
		compareArray,
		educatorUpload,
		mediaUpload,
		epubUpload,
		uniqueData,
		getMedia,
		selectMedias,
		enableOptions,
		useSelectedMedia,
		navigateGallary,
		showGallary
	});

	$$self.$inject_state = $$props => {
		if ('default_media_configuration' in $$props) $$invalidate(0, default_media_configuration = $$props.default_media_configuration);
		if ('is_react' in $$props) is_react = $$props.is_react;
		if ('upload_field_id' in $$props) upload_field_id = $$props.upload_field_id;
		if ('thumbnail_data' in $$props) thumbnail_data = $$props.thumbnail_data;
		if ('uploaded_file' in $$props) uploaded_file = $$props.uploaded_file;
		if ('uploaded_file_mceu' in $$props) uploaded_file_mceu = $$props.uploaded_file_mceu;
		if ('manual_item_id' in $$props) manual_item_id = $$props.manual_item_id;
		if ('html' in $$props) html = $$props.html;
		if ('files' in $$props) $$invalidate(1, files = $$props.files);
		if ('mediaData' in $$props) mediaData = $$props.mediaData;
		if ('media_variable' in $$props) media_variable = $$props.media_variable;
		if ('media_information_modal' in $$props) media_information_modal = $$props.media_information_modal;
		if ('media_upload_modal' in $$props) media_upload_modal = $$props.media_upload_modal;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		default_media_configuration,
		files,
		onCancelMediaInfo,
		mediaInfoSubmit,
		onUploadMedia,
		getMedia,
		navigateGallary,
		setImage,
		input_change_handler,
		input_change_handler_1
	];
}

class Media extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$n,
			create_fragment$n,
			safe_not_equal,
			{
				default_media_configuration: 0,
				setImage: 7
			},
			add_css$h,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Media",
			options,
			id: create_fragment$n.name
		});
	}

	get default_media_configuration() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set default_media_configuration(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setImage() {
		return this.$$.ctx[7];
	}

	set setImage(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var sweetalert_min = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,function(){return function(t){function e(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return t[o].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,o){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:o});},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=8)}([function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o="swal-button";e.CLASS_NAMES={MODAL:"swal-modal",OVERLAY:"swal-overlay",SHOW_MODAL:"swal-overlay--show-modal",MODAL_TITLE:"swal-title",MODAL_TEXT:"swal-text",ICON:"swal-icon",ICON_CUSTOM:"swal-icon--custom",CONTENT:"swal-content",FOOTER:"swal-footer",BUTTON_CONTAINER:"swal-button-container",BUTTON:o,CONFIRM_BUTTON:o+"--confirm",CANCEL_BUTTON:o+"--cancel",DANGER_BUTTON:o+"--danger",BUTTON_LOADING:o+"--loading",BUTTON_LOADER:o+"__loader"},e.default=e.CLASS_NAMES;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0}),e.getNode=function(t){var e="."+t;return document.querySelector(e)},e.stringToNode=function(t){var e=document.createElement("div");return e.innerHTML=t.trim(),e.firstChild},e.insertAfter=function(t,e){var n=e.nextSibling;e.parentNode.insertBefore(t,n);},e.removeNode=function(t){t.parentElement.removeChild(t);},e.throwErr=function(t){throw t=t.replace(/ +(?= )/g,""),"SweetAlert: "+(t=t.trim())},e.isPlainObject=function(t){if("[object Object]"!==Object.prototype.toString.call(t))return !1;var e=Object.getPrototypeOf(t);return null===e||e===Object.prototype},e.ordinalSuffixOf=function(t){var e=t%10,n=t%100;return 1===e&&11!==n?t+"st":2===e&&12!==n?t+"nd":3===e&&13!==n?t+"rd":t+"th"};},function(t,e,n){function o(t){for(var n in t)e.hasOwnProperty(n)||(e[n]=t[n]);}Object.defineProperty(e,"__esModule",{value:!0}),o(n(25));var r=n(26);e.overlayMarkup=r.default,o(n(27)),o(n(28)),o(n(29));var i=n(0),a=i.default.MODAL_TITLE,s=i.default.MODAL_TEXT,c=i.default.ICON,l=i.default.FOOTER;e.iconMarkup='\n  <div class="'+c+'"></div>',e.titleMarkup='\n  <div class="'+a+'"></div>\n',e.textMarkup='\n  <div class="'+s+'"></div>',e.footerMarkup='\n  <div class="'+l+'"></div>\n';},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1);e.CONFIRM_KEY="confirm",e.CANCEL_KEY="cancel";var r={visible:!0,text:null,value:null,className:"",closeModal:!0},i=Object.assign({},r,{visible:!1,text:"Cancel",value:null}),a=Object.assign({},r,{text:"OK",value:!0});e.defaultButtonList={cancel:i,confirm:a};var s=function(t){switch(t){case e.CONFIRM_KEY:return a;case e.CANCEL_KEY:return i;default:var n=t.charAt(0).toUpperCase()+t.slice(1);return Object.assign({},r,{text:n,value:t})}},c=function(t,e){var n=s(t);return !0===e?Object.assign({},n,{visible:!0}):"string"==typeof e?Object.assign({},n,{visible:!0,text:e}):o.isPlainObject(e)?Object.assign({visible:!0},n,e):Object.assign({},n,{visible:!1})},l=function(t){for(var e={},n=0,o=Object.keys(t);n<o.length;n++){var r=o[n],a=t[r],s=c(r,a);e[r]=s;}return e.cancel||(e.cancel=i),e},u=function(t){var n={};switch(t.length){case 1:n[e.CANCEL_KEY]=Object.assign({},i,{visible:!1});break;case 2:n[e.CANCEL_KEY]=c(e.CANCEL_KEY,t[0]),n[e.CONFIRM_KEY]=c(e.CONFIRM_KEY,t[1]);break;default:o.throwErr("Invalid number of 'buttons' in array ("+t.length+").\n      If you want more than 2 buttons, you need to use an object!");}return n};e.getButtonListOpts=function(t){var n=e.defaultButtonList;return "string"==typeof t?n[e.CONFIRM_KEY]=c(e.CONFIRM_KEY,t):Array.isArray(t)?n=u(t):o.isPlainObject(t)?n=l(t):!0===t?n=u([!0,!0]):!1===t?n=u([!1,!1]):void 0===t&&(n=e.defaultButtonList),n};},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(2),i=n(0),a=i.default.MODAL,s=i.default.OVERLAY,c=n(30),l=n(31),u=n(32),f=n(33);e.injectElIntoModal=function(t){var e=o.getNode(a),n=o.stringToNode(t);return e.appendChild(n),n};var d=function(t){t.className=a,t.textContent="";},p=function(t,e){d(t);var n=e.className;n&&t.classList.add(n);};e.initModalContent=function(t){var e=o.getNode(a);p(e,t),c.default(t.icon),l.initTitle(t.title),l.initText(t.text),f.default(t.content),u.default(t.buttons,t.dangerMode);};var m=function(){var t=o.getNode(s),e=o.stringToNode(r.modalMarkup);t.appendChild(e);};e.default=m;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(3),r={isOpen:!1,promise:null,actions:{},timer:null},i=Object.assign({},r);e.resetState=function(){i=Object.assign({},r);},e.setActionValue=function(t){if("string"==typeof t)return a(o.CONFIRM_KEY,t);for(var e in t)a(e,t[e]);};var a=function(t,e){i.actions[t]||(i.actions[t]={}),Object.assign(i.actions[t],{value:e});};e.setActionOptionsFor=function(t,e){var n=(void 0===e?{}:e).closeModal,o=void 0===n||n;Object.assign(i.actions[t],{closeModal:o});},e.default=i;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(3),i=n(0),a=i.default.OVERLAY,s=i.default.SHOW_MODAL,c=i.default.BUTTON,l=i.default.BUTTON_LOADING,u=n(5);e.openModal=function(){o.getNode(a).classList.add(s),u.default.isOpen=!0;};var f=function(){o.getNode(a).classList.remove(s),u.default.isOpen=!1;};e.onAction=function(t){void 0===t&&(t=r.CANCEL_KEY);var e=u.default.actions[t],n=e.value;if(!1===e.closeModal){var i=c+"--"+t;o.getNode(i).classList.add(l);}else f();u.default.promise.resolve(n);},e.getState=function(){var t=Object.assign({},u.default);return delete t.promise,delete t.timer,t},e.stopLoading=function(){for(var t=document.querySelectorAll("."+c),e=0;e<t.length;e++){t[e].classList.remove(l);}};},function(t,e){var n;n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this");}catch(t){"object"==typeof window&&(n=window);}t.exports=n;},function(t,e,n){(function(e){t.exports=e.sweetAlert=n(9);}).call(e,n(7));},function(t,e,n){(function(e){t.exports=e.swal=n(10);}).call(e,n(7));},function(t,e,n){"undefined"!=typeof window&&n(11),n(16);var o=n(23).default;t.exports=o;},function(t,e,n){var o=n(12);"string"==typeof o&&(o=[[t.i,o,""]]);var r={insertAt:"top"};r.transform=void 0;n(14)(o,r);o.locals&&(t.exports=o.locals);},function(t,e,n){e=t.exports=n(13)(void 0),e.push([t.i,'.swal-icon--error{border-color:#f27474;-webkit-animation:animateErrorIcon .5s;animation:animateErrorIcon .5s}.swal-icon--error__x-mark{position:relative;display:block;-webkit-animation:animateXMark .5s;animation:animateXMark .5s}.swal-icon--error__line{position:absolute;height:5px;width:47px;background-color:#f27474;display:block;top:37px;border-radius:2px}.swal-icon--error__line--left{-webkit-transform:rotate(45deg);transform:rotate(45deg);left:17px}.swal-icon--error__line--right{-webkit-transform:rotate(-45deg);transform:rotate(-45deg);right:16px}@-webkit-keyframes animateErrorIcon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}to{-webkit-transform:rotateX(0deg);transform:rotateX(0deg);opacity:1}}@keyframes animateErrorIcon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}to{-webkit-transform:rotateX(0deg);transform:rotateX(0deg);opacity:1}}@-webkit-keyframes animateXMark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}to{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}@keyframes animateXMark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}to{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}.swal-icon--warning{border-color:#f8bb86;-webkit-animation:pulseWarning .75s infinite alternate;animation:pulseWarning .75s infinite alternate}.swal-icon--warning__body{width:5px;height:47px;top:10px;border-radius:2px;margin-left:-2px}.swal-icon--warning__body,.swal-icon--warning__dot{position:absolute;left:50%;background-color:#f8bb86}.swal-icon--warning__dot{width:7px;height:7px;border-radius:50%;margin-left:-4px;bottom:-11px}@-webkit-keyframes pulseWarning{0%{border-color:#f8d486}to{border-color:#f8bb86}}@keyframes pulseWarning{0%{border-color:#f8d486}to{border-color:#f8bb86}}.swal-icon--success{border-color:#a5dc86}.swal-icon--success:after,.swal-icon--success:before{content:"";border-radius:50%;position:absolute;width:60px;height:120px;background:#fff;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.swal-icon--success:before{border-radius:120px 0 0 120px;top:-7px;left:-33px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:60px 60px;transform-origin:60px 60px}.swal-icon--success:after{border-radius:0 120px 120px 0;top:-11px;left:30px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:0 60px;transform-origin:0 60px;-webkit-animation:rotatePlaceholder 4.25s ease-in;animation:rotatePlaceholder 4.25s ease-in}.swal-icon--success__ring{width:80px;height:80px;border:4px solid hsla(98,55%,69%,.2);border-radius:50%;box-sizing:content-box;position:absolute;left:-4px;top:-4px;z-index:2}.swal-icon--success__hide-corners{width:5px;height:90px;background-color:#fff;padding:1px;position:absolute;left:28px;top:8px;z-index:1;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.swal-icon--success__line{height:5px;background-color:#a5dc86;display:block;border-radius:2px;position:absolute;z-index:2}.swal-icon--success__line--tip{width:25px;left:14px;top:46px;-webkit-transform:rotate(45deg);transform:rotate(45deg);-webkit-animation:animateSuccessTip .75s;animation:animateSuccessTip .75s}.swal-icon--success__line--long{width:47px;right:8px;top:38px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-animation:animateSuccessLong .75s;animation:animateSuccessLong .75s}@-webkit-keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}to{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}to{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@-webkit-keyframes animateSuccessTip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}to{width:25px;left:14px;top:45px}}@keyframes animateSuccessTip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}to{width:25px;left:14px;top:45px}}@-webkit-keyframes animateSuccessLong{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}to{width:47px;right:8px;top:38px}}@keyframes animateSuccessLong{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}to{width:47px;right:8px;top:38px}}.swal-icon--info{border-color:#c9dae1}.swal-icon--info:before{width:5px;height:29px;bottom:17px;border-radius:2px;margin-left:-2px}.swal-icon--info:after,.swal-icon--info:before{content:"";position:absolute;left:50%;background-color:#c9dae1}.swal-icon--info:after{width:7px;height:7px;border-radius:50%;margin-left:-3px;top:19px}.swal-icon{width:80px;height:80px;border-width:4px;border-style:solid;border-radius:50%;padding:0;position:relative;box-sizing:content-box;margin:20px auto}.swal-icon:first-child{margin-top:32px}.swal-icon--custom{width:auto;height:auto;max-width:100%;border:none;border-radius:0}.swal-icon img{max-width:100%;max-height:100%}.swal-title{color:rgba(0,0,0,.65);font-weight:600;text-transform:none;position:relative;display:block;padding:13px 16px;font-size:27px;line-height:normal;text-align:center;margin-bottom:0}.swal-title:first-child{margin-top:26px}.swal-title:not(:first-child){padding-bottom:0}.swal-title:not(:last-child){margin-bottom:13px}.swal-text{font-size:16px;position:relative;float:none;line-height:normal;vertical-align:top;text-align:left;display:inline-block;margin:0;padding:0 10px;font-weight:400;color:rgba(0,0,0,.64);max-width:calc(100% - 20px);overflow-wrap:break-word;box-sizing:border-box}.swal-text:first-child{margin-top:45px}.swal-text:last-child{margin-bottom:45px}.swal-footer{text-align:right;padding-top:13px;margin-top:13px;padding:13px 16px;border-radius:inherit;border-top-left-radius:0;border-top-right-radius:0}.swal-button-container{margin:5px;display:inline-block;position:relative}.swal-button{background-color:#7cd1f9;color:#fff;border:none;box-shadow:none;border-radius:5px;font-weight:600;font-size:14px;padding:10px 24px;margin:0;cursor:pointer}.swal-button:not([disabled]):hover{background-color:#78cbf2}.swal-button:active{background-color:#70bce0}.swal-button:focus{outline:none;box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(43,114,165,.29)}.swal-button[disabled]{opacity:.5;cursor:default}.swal-button::-moz-focus-inner{border:0}.swal-button--cancel{color:#555;background-color:#efefef}.swal-button--cancel:not([disabled]):hover{background-color:#e8e8e8}.swal-button--cancel:active{background-color:#d7d7d7}.swal-button--cancel:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(116,136,150,.29)}.swal-button--danger{background-color:#e64942}.swal-button--danger:not([disabled]):hover{background-color:#df4740}.swal-button--danger:active{background-color:#cf423b}.swal-button--danger:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(165,43,43,.29)}.swal-content{padding:0 20px;margin-top:20px;font-size:medium}.swal-content:last-child{margin-bottom:20px}.swal-content__input,.swal-content__textarea{-webkit-appearance:none;background-color:#fff;border:none;font-size:14px;display:block;box-sizing:border-box;width:100%;border:1px solid rgba(0,0,0,.14);padding:10px 13px;border-radius:2px;transition:border-color .2s}.swal-content__input:focus,.swal-content__textarea:focus{outline:none;border-color:#6db8ff}.swal-content__textarea{resize:vertical}.swal-button--loading{color:transparent}.swal-button--loading~.swal-button__loader{opacity:1}.swal-button__loader{position:absolute;height:auto;width:43px;z-index:2;left:50%;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);text-align:center;pointer-events:none;opacity:0}.swal-button__loader div{display:inline-block;float:none;vertical-align:baseline;width:9px;height:9px;padding:0;border:none;margin:2px;opacity:.4;border-radius:7px;background-color:hsla(0,0%,100%,.9);transition:background .2s;-webkit-animation:swal-loading-anim 1s infinite;animation:swal-loading-anim 1s infinite}.swal-button__loader div:nth-child(3n+2){-webkit-animation-delay:.15s;animation-delay:.15s}.swal-button__loader div:nth-child(3n+3){-webkit-animation-delay:.3s;animation-delay:.3s}@-webkit-keyframes swal-loading-anim{0%{opacity:.4}20%{opacity:.4}50%{opacity:1}to{opacity:.4}}@keyframes swal-loading-anim{0%{opacity:.4}20%{opacity:.4}50%{opacity:1}to{opacity:.4}}.swal-overlay{position:fixed;top:0;bottom:0;left:0;right:0;text-align:center;font-size:0;overflow-y:auto;background-color:rgba(0,0,0,.4);z-index:10000;pointer-events:none;opacity:0;transition:opacity .3s}.swal-overlay:before{content:" ";display:inline-block;vertical-align:middle;height:100%}.swal-overlay--show-modal{opacity:1;pointer-events:auto}.swal-overlay--show-modal .swal-modal{opacity:1;pointer-events:auto;box-sizing:border-box;-webkit-animation:showSweetAlert .3s;animation:showSweetAlert .3s;will-change:transform}.swal-modal{width:478px;opacity:0;pointer-events:none;background-color:#fff;text-align:center;border-radius:5px;position:static;margin:20px auto;display:inline-block;vertical-align:middle;-webkit-transform:scale(1);transform:scale(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;z-index:10001;transition:opacity .2s,-webkit-transform .3s;transition:transform .3s,opacity .2s;transition:transform .3s,opacity .2s,-webkit-transform .3s}@media (max-width:500px){.swal-modal{width:calc(100% - 20px)}}@-webkit-keyframes showSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1)}1%{-webkit-transform:scale(.5);transform:scale(.5)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}to{-webkit-transform:scale(1);transform:scale(1)}}@keyframes showSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1)}1%{-webkit-transform:scale(.5);transform:scale(.5)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}to{-webkit-transform:scale(1);transform:scale(1)}}',""]);},function(t,e){function n(t,e){var n=t[1]||"",r=t[3];if(!r)return n;if(e&&"function"==typeof btoa){var i=o(r);return [n].concat(r.sources.map(function(t){return "/*# sourceURL="+r.sourceRoot+t+" */"})).concat([i]).join("\n")}return [n].join("\n")}function o(t){return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(t))))+" */"}t.exports=function(t){var e=[];return e.toString=function(){return this.map(function(e){var o=n(e,t);return e[2]?"@media "+e[2]+"{"+o+"}":o}).join("")},e.i=function(t,n){"string"==typeof t&&(t=[[null,t,""]]);for(var o={},r=0;r<this.length;r++){var i=this[r][0];"number"==typeof i&&(o[i]=!0);}for(r=0;r<t.length;r++){var a=t[r];"number"==typeof a[0]&&o[a[0]]||(n&&!a[2]?a[2]=n:n&&(a[2]="("+a[2]+") and ("+n+")"),e.push(a));}},e};},function(t,e,n){function o(t,e){for(var n=0;n<t.length;n++){var o=t[n],r=m[o.id];if(r){r.refs++;for(var i=0;i<r.parts.length;i++)r.parts[i](o.parts[i]);for(;i<o.parts.length;i++)r.parts.push(u(o.parts[i],e));}else {for(var a=[],i=0;i<o.parts.length;i++)a.push(u(o.parts[i],e));m[o.id]={id:o.id,refs:1,parts:a};}}}function r(t,e){for(var n=[],o={},r=0;r<t.length;r++){var i=t[r],a=e.base?i[0]+e.base:i[0],s=i[1],c=i[2],l=i[3],u={css:s,media:c,sourceMap:l};o[a]?o[a].parts.push(u):n.push(o[a]={id:a,parts:[u]});}return n}function i(t,e){var n=v(t.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var o=w[w.length-1];if("top"===t.insertAt)o?o.nextSibling?n.insertBefore(e,o.nextSibling):n.appendChild(e):n.insertBefore(e,n.firstChild),w.push(e);else {if("bottom"!==t.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(e);}}function a(t){if(null===t.parentNode)return !1;t.parentNode.removeChild(t);var e=w.indexOf(t);e>=0&&w.splice(e,1);}function s(t){var e=document.createElement("style");return t.attrs.type="text/css",l(e,t.attrs),i(t,e),e}function c(t){var e=document.createElement("link");return t.attrs.type="text/css",t.attrs.rel="stylesheet",l(e,t.attrs),i(t,e),e}function l(t,e){Object.keys(e).forEach(function(n){t.setAttribute(n,e[n]);});}function u(t,e){var n,o,r,i;if(e.transform&&t.css){if(!(i=e.transform(t.css)))return function(){};t.css=i;}if(e.singleton){var l=h++;n=g||(g=s(e)),o=f.bind(null,n,l,!1),r=f.bind(null,n,l,!0);}else t.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(n=c(e),o=p.bind(null,n,e),r=function(){a(n),n.href&&URL.revokeObjectURL(n.href);}):(n=s(e),o=d.bind(null,n),r=function(){a(n);});return o(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap)return;o(t=e);}else r();}}function f(t,e,n,o){var r=n?"":o.css;if(t.styleSheet)t.styleSheet.cssText=x(e,r);else {var i=document.createTextNode(r),a=t.childNodes;a[e]&&t.removeChild(a[e]),a.length?t.insertBefore(i,a[e]):t.appendChild(i);}}function d(t,e){var n=e.css,o=e.media;if(o&&t.setAttribute("media",o),t.styleSheet)t.styleSheet.cssText=n;else {for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n));}}function p(t,e,n){var o=n.css,r=n.sourceMap,i=void 0===e.convertToAbsoluteUrls&&r;(e.convertToAbsoluteUrls||i)&&(o=y(o)),r&&(o+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var a=new Blob([o],{type:"text/css"}),s=t.href;t.href=URL.createObjectURL(a),s&&URL.revokeObjectURL(s);}var m={},b=function(t){var e;return function(){return void 0===e&&(e=t.apply(this,arguments)),e}}(function(){return window&&document&&document.all&&!window.atob}),v=function(t){var e={};return function(n){return void 0===e[n]&&(e[n]=t.call(this,n)),e[n]}}(function(t){return document.querySelector(t)}),g=null,h=0,w=[],y=n(15);t.exports=function(t,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");e=e||{},e.attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||(e.singleton=b()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var n=r(t,e);return o(n,e),function(t){for(var i=[],a=0;a<n.length;a++){var s=n[a],c=m[s.id];c.refs--,i.push(c);}if(t){o(r(t,e),e);}for(var a=0;a<i.length;a++){var c=i[a];if(0===c.refs){for(var l=0;l<c.parts.length;l++)c.parts[l]();delete m[c.id];}}}};var x=function(){var t=[];return function(e,n){return t[e]=n,t.filter(Boolean).join("\n")}}();},function(t,e){t.exports=function(t){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!t||"string"!=typeof t)return t;var n=e.protocol+"//"+e.host,o=n+e.pathname.replace(/\/[^\/]*$/,"/");return t.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(t,e){var r=e.trim().replace(/^"(.*)"$/,function(t,e){return e}).replace(/^'(.*)'$/,function(t,e){return e});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(r))return t;var i;return i=0===r.indexOf("//")?r:0===r.indexOf("/")?n+r:o+r.replace(/^\.\//,""),"url("+JSON.stringify(i)+")"})};},function(t,e,n){var o=n(17);"undefined"==typeof window||window.Promise||(window.Promise=o),n(21),String.prototype.includes||(String.prototype.includes=function(t,e){return "number"!=typeof e&&(e=0),!(e+t.length>this.length)&&-1!==this.indexOf(t,e)}),Array.prototype.includes||Object.defineProperty(Array.prototype,"includes",{value:function(t,e){if(null==this)throw new TypeError('"this" is null or not defined');var n=Object(this),o=n.length>>>0;if(0===o)return !1;for(var r=0|e,i=Math.max(r>=0?r:o-Math.abs(r),0);i<o;){if(function(t,e){return t===e||"number"==typeof t&&"number"==typeof e&&isNaN(t)&&isNaN(e)}(n[i],t))return !0;i++;}return !1}}),"undefined"!=typeof window&&function(t){t.forEach(function(t){t.hasOwnProperty("remove")||Object.defineProperty(t,"remove",{configurable:!0,enumerable:!0,writable:!0,value:function(){this.parentNode.removeChild(this);}});});}([Element.prototype,CharacterData.prototype,DocumentType.prototype]);},function(t,e,n){(function(e){!function(n){function o(){}function r(t,e){return function(){t.apply(e,arguments);}}function i(t){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],f(t,this);}function a(t,e){for(;3===t._state;)t=t._value;if(0===t._state)return void t._deferreds.push(e);t._handled=!0,i._immediateFn(function(){var n=1===t._state?e.onFulfilled:e.onRejected;if(null===n)return void(1===t._state?s:c)(e.promise,t._value);var o;try{o=n(t._value);}catch(t){return void c(e.promise,t)}s(e.promise,o);});}function s(t,e){try{if(e===t)throw new TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var n=e.then;if(e instanceof i)return t._state=3,t._value=e,void l(t);if("function"==typeof n)return void f(r(n,e),t)}t._state=1,t._value=e,l(t);}catch(e){c(t,e);}}function c(t,e){t._state=2,t._value=e,l(t);}function l(t){2===t._state&&0===t._deferreds.length&&i._immediateFn(function(){t._handled||i._unhandledRejectionFn(t._value);});for(var e=0,n=t._deferreds.length;e<n;e++)a(t,t._deferreds[e]);t._deferreds=null;}function u(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n;}function f(t,e){var n=!1;try{t(function(t){n||(n=!0,s(e,t));},function(t){n||(n=!0,c(e,t));});}catch(t){if(n)return;n=!0,c(e,t);}}var d=setTimeout;i.prototype.catch=function(t){return this.then(null,t)},i.prototype.then=function(t,e){var n=new this.constructor(o);return a(this,new u(t,e,n)),n},i.all=function(t){var e=Array.prototype.slice.call(t);return new i(function(t,n){function o(i,a){try{if(a&&("object"==typeof a||"function"==typeof a)){var s=a.then;if("function"==typeof s)return void s.call(a,function(t){o(i,t);},n)}e[i]=a,0==--r&&t(e);}catch(t){n(t);}}if(0===e.length)return t([]);for(var r=e.length,i=0;i<e.length;i++)o(i,e[i]);})},i.resolve=function(t){return t&&"object"==typeof t&&t.constructor===i?t:new i(function(e){e(t);})},i.reject=function(t){return new i(function(e,n){n(t);})},i.race=function(t){return new i(function(e,n){for(var o=0,r=t.length;o<r;o++)t[o].then(e,n);})},i._immediateFn="function"==typeof e&&function(t){e(t);}||function(t){d(t,0);},i._unhandledRejectionFn=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t);},i._setImmediateFn=function(t){i._immediateFn=t;},i._setUnhandledRejectionFn=function(t){i._unhandledRejectionFn=t;},void 0!==t&&t.exports?t.exports=i:n.Promise||(n.Promise=i);}(this);}).call(e,n(18).setImmediate);},function(t,e,n){function o(t,e){this._id=t,this._clearFn=e;}var r=Function.prototype.apply;e.setTimeout=function(){return new o(r.call(setTimeout,window,arguments),clearTimeout)},e.setInterval=function(){return new o(r.call(setInterval,window,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close();},o.prototype.unref=o.prototype.ref=function(){},o.prototype.close=function(){this._clearFn.call(window,this._id);},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e;},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1;},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout(function(){t._onTimeout&&t._onTimeout();},e));},n(19),e.setImmediate=setImmediate,e.clearImmediate=clearImmediate;},function(t,e,n){(function(t,e){!function(t,n){function o(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),n=0;n<e.length;n++)e[n]=arguments[n+1];var o={callback:t,args:e};return l[c]=o,s(c),c++}function r(t){delete l[t];}function i(t){var e=t.callback,o=t.args;switch(o.length){case 0:e();break;case 1:e(o[0]);break;case 2:e(o[0],o[1]);break;case 3:e(o[0],o[1],o[2]);break;default:e.apply(n,o);}}function a(t){if(u)setTimeout(a,0,t);else {var e=l[t];if(e){u=!0;try{i(e);}finally{r(t),u=!1;}}}}if(!t.setImmediate){var s,c=1,l={},u=!1,f=t.document,d=Object.getPrototypeOf&&Object.getPrototypeOf(t);d=d&&d.setTimeout?d:t,"[object process]"==={}.toString.call(t.process)?function(){s=function(t){e.nextTick(function(){a(t);});};}():function(){if(t.postMessage&&!t.importScripts){var e=!0,n=t.onmessage;return t.onmessage=function(){e=!1;},t.postMessage("","*"),t.onmessage=n,e}}()?function(){var e="setImmediate$"+Math.random()+"$",n=function(n){n.source===t&&"string"==typeof n.data&&0===n.data.indexOf(e)&&a(+n.data.slice(e.length));};t.addEventListener?t.addEventListener("message",n,!1):t.attachEvent("onmessage",n),s=function(n){t.postMessage(e+n,"*");};}():t.MessageChannel?function(){var t=new MessageChannel;t.port1.onmessage=function(t){a(t.data);},s=function(e){t.port2.postMessage(e);};}():f&&"onreadystatechange"in f.createElement("script")?function(){var t=f.documentElement;s=function(e){var n=f.createElement("script");n.onreadystatechange=function(){a(e),n.onreadystatechange=null,t.removeChild(n),n=null;},t.appendChild(n);};}():function(){s=function(t){setTimeout(a,0,t);};}(),d.setImmediate=o,d.clearImmediate=r;}}("undefined"==typeof self?void 0===t?this:t:self);}).call(e,n(7),n(20));},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function r(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function i(t){if(f===clearTimeout)return clearTimeout(t);if((f===o||!f)&&clearTimeout)return f=clearTimeout,clearTimeout(t);try{return f(t)}catch(e){try{return f.call(null,t)}catch(e){return f.call(this,t)}}}function a(){b&&p&&(b=!1,p.length?m=p.concat(m):v=-1,m.length&&s());}function s(){if(!b){var t=r(a);b=!0;for(var e=m.length;e;){for(p=m,m=[];++v<e;)p&&p[v].run();v=-1,e=m.length;}p=null,b=!1,i(t);}}function c(t,e){this.fun=t,this.array=e;}function l(){}var u,f,d=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n;}catch(t){u=n;}try{f="function"==typeof clearTimeout?clearTimeout:o;}catch(t){f=o;}}();var p,m=[],b=!1,v=-1;d.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];m.push(new c(t,e)),1!==m.length||b||r(s);},c.prototype.run=function(){this.fun.apply(null,this.array);},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=l,d.addListener=l,d.once=l,d.off=l,d.removeListener=l,d.removeAllListeners=l,d.emit=l,d.prependListener=l,d.prependOnceListener=l,d.listeners=function(t){return []},d.binding=function(t){throw new Error("process.binding is not supported")},d.cwd=function(){return "/"},d.chdir=function(t){throw new Error("process.chdir is not supported")},d.umask=function(){return 0};},function(t,e,n){n(22).polyfill();},function(t,e,n){function o(t,e){if(void 0===t||null===t)throw new TypeError("Cannot convert first argument to object");for(var n=Object(t),o=1;o<arguments.length;o++){var r=arguments[o];if(void 0!==r&&null!==r)for(var i=Object.keys(Object(r)),a=0,s=i.length;a<s;a++){var c=i[a],l=Object.getOwnPropertyDescriptor(r,c);void 0!==l&&l.enumerable&&(n[c]=r[c]);}}return n}function r(){Object.assign||Object.defineProperty(Object,"assign",{enumerable:!1,configurable:!0,writable:!0,value:o});}t.exports={assign:o,polyfill:r};},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(24),r=n(6),i=n(5),a=n(36),s=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];if("undefined"!=typeof window){var n=a.getOpts.apply(void 0,t);return new Promise(function(t,e){i.default.promise={resolve:t,reject:e},o.default(n),setTimeout(function(){r.openModal();});})}};s.close=r.onAction,s.getState=r.getState,s.setActionValue=i.setActionValue,s.stopLoading=r.stopLoading,s.setDefaults=a.setDefaults,e.default=s;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(0),i=r.default.MODAL,a=n(4),s=n(34),c=n(35),l=n(1);e.init=function(t){o.getNode(i)||(document.body||l.throwErr("You can only use SweetAlert AFTER the DOM has loaded!"),s.default(),a.default()),a.initModalContent(t),c.default(t);},e.default=e.init;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.MODAL;e.modalMarkup='\n  <div class="'+r+'" role="dialog" aria-modal="true"></div>',e.default=e.modalMarkup;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.OVERLAY,i='<div \n    class="'+r+'"\n    tabIndex="-1">\n  </div>';e.default=i;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.ICON;e.errorIconMarkup=function(){var t=r+"--error",e=t+"__line";return '\n    <div class="'+t+'__x-mark">\n      <span class="'+e+" "+e+'--left"></span>\n      <span class="'+e+" "+e+'--right"></span>\n    </div>\n  '},e.warningIconMarkup=function(){var t=r+"--warning";return '\n    <span class="'+t+'__body">\n      <span class="'+t+'__dot"></span>\n    </span>\n  '},e.successIconMarkup=function(){var t=r+"--success";return '\n    <span class="'+t+"__line "+t+'__line--long"></span>\n    <span class="'+t+"__line "+t+'__line--tip"></span>\n\n    <div class="'+t+'__ring"></div>\n    <div class="'+t+'__hide-corners"></div>\n  '};},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.CONTENT;e.contentMarkup='\n  <div class="'+r+'">\n\n  </div>\n';},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.BUTTON_CONTAINER,i=o.default.BUTTON,a=o.default.BUTTON_LOADER;e.buttonMarkup='\n  <div class="'+r+'">\n\n    <button\n      class="'+i+'"\n    ></button>\n\n    <div class="'+a+'">\n      <div></div>\n      <div></div>\n      <div></div>\n    </div>\n\n  </div>\n';},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(4),r=n(2),i=n(0),a=i.default.ICON,s=i.default.ICON_CUSTOM,c=["error","warning","success","info"],l={error:r.errorIconMarkup(),warning:r.warningIconMarkup(),success:r.successIconMarkup()},u=function(t,e){var n=a+"--"+t;e.classList.add(n);var o=l[t];o&&(e.innerHTML=o);},f=function(t,e){e.classList.add(s);var n=document.createElement("img");n.src=t,e.appendChild(n);},d=function(t){if(t){var e=o.injectElIntoModal(r.iconMarkup);c.includes(t)?u(t,e):f(t,e);}};e.default=d;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(2),r=n(4),i=function(t){navigator.userAgent.includes("AppleWebKit")&&(t.style.display="none",t.offsetHeight,t.style.display="");};e.initTitle=function(t){if(t){var e=r.injectElIntoModal(o.titleMarkup);e.textContent=t,i(e);}},e.initText=function(t){if(t){var e=document.createDocumentFragment();t.split("\n").forEach(function(t,n,o){e.appendChild(document.createTextNode(t)),n<o.length-1&&e.appendChild(document.createElement("br"));});var n=r.injectElIntoModal(o.textMarkup);n.appendChild(e),i(n);}};},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(4),i=n(0),a=i.default.BUTTON,s=i.default.DANGER_BUTTON,c=n(3),l=n(2),u=n(6),f=n(5),d=function(t,e,n){var r=e.text,i=e.value,d=e.className,p=e.closeModal,m=o.stringToNode(l.buttonMarkup),b=m.querySelector("."+a),v=a+"--"+t;if(b.classList.add(v),d){(Array.isArray(d)?d:d.split(" ")).filter(function(t){return t.length>0}).forEach(function(t){b.classList.add(t);});}n&&t===c.CONFIRM_KEY&&b.classList.add(s),b.textContent=r;var g={};return g[t]=i,f.setActionValue(g),f.setActionOptionsFor(t,{closeModal:p}),b.addEventListener("click",function(){return u.onAction(t)}),m},p=function(t,e){var n=r.injectElIntoModal(l.footerMarkup);for(var o in t){var i=t[o],a=d(o,i,e);i.visible&&n.appendChild(a);}0===n.children.length&&n.remove();};e.default=p;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(3),r=n(4),i=n(2),a=n(5),s=n(6),c=n(0),l=c.default.CONTENT,u=function(t){t.addEventListener("input",function(t){var e=t.target,n=e.value;a.setActionValue(n);}),t.addEventListener("keyup",function(t){if("Enter"===t.key)return s.onAction(o.CONFIRM_KEY)}),setTimeout(function(){t.focus(),a.setActionValue("");},0);},f=function(t,e,n){var o=document.createElement(e),r=l+"__"+e;o.classList.add(r);for(var i in n){var a=n[i];o[i]=a;}"input"===e&&u(o),t.appendChild(o);},d=function(t){if(t){var e=r.injectElIntoModal(i.contentMarkup),n=t.element,o=t.attributes;"string"==typeof n?f(e,n,o):e.appendChild(n);}};e.default=d;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(2),i=function(){var t=o.stringToNode(r.overlayMarkup);document.body.appendChild(t);};e.default=i;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(5),r=n(6),i=n(1),a=n(3),s=n(0),c=s.default.MODAL,l=s.default.BUTTON,u=s.default.OVERLAY,f=function(t){t.preventDefault(),v();},d=function(t){t.preventDefault(),g();},p=function(t){if(o.default.isOpen)switch(t.key){case"Escape":return r.onAction(a.CANCEL_KEY)}},m=function(t){if(o.default.isOpen)switch(t.key){case"Tab":return f(t)}},b=function(t){if(o.default.isOpen)return "Tab"===t.key&&t.shiftKey?d(t):void 0},v=function(){var t=i.getNode(l);t&&(t.tabIndex=0,t.focus());},g=function(){var t=i.getNode(c),e=t.querySelectorAll("."+l),n=e.length-1,o=e[n];o&&o.focus();},h=function(t){t[t.length-1].addEventListener("keydown",m);},w=function(t){t[0].addEventListener("keydown",b);},y=function(){var t=i.getNode(c),e=t.querySelectorAll("."+l);e.length&&(h(e),w(e));},x=function(t){if(i.getNode(u)===t.target)return r.onAction(a.CANCEL_KEY)},_=function(t){var e=i.getNode(u);e.removeEventListener("click",x),t&&e.addEventListener("click",x);},k=function(t){o.default.timer&&clearTimeout(o.default.timer),t&&(o.default.timer=window.setTimeout(function(){return r.onAction(a.CANCEL_KEY)},t));},O=function(t){t.closeOnEsc?document.addEventListener("keyup",p):document.removeEventListener("keyup",p),t.dangerMode?v():g(),y(),_(t.closeOnClickOutside),k(t.timer);};e.default=O;},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(3),i=n(37),a=n(38),s={title:null,text:null,icon:null,buttons:r.defaultButtonList,content:null,className:null,closeOnClickOutside:!0,closeOnEsc:!0,dangerMode:!1,timer:null},c=Object.assign({},s);e.setDefaults=function(t){c=Object.assign({},s,t);};var l=function(t){var e=t&&t.button,n=t&&t.buttons;return void 0!==e&&void 0!==n&&o.throwErr("Cannot set both 'button' and 'buttons' options!"),void 0!==e?{confirm:e}:n},u=function(t){return o.ordinalSuffixOf(t+1)},f=function(t,e){o.throwErr(u(e)+" argument ('"+t+"') is invalid");},d=function(t,e){var n=t+1,r=e[n];o.isPlainObject(r)||void 0===r||o.throwErr("Expected "+u(n)+" argument ('"+r+"') to be a plain object");},p=function(t,e){var n=t+1,r=e[n];void 0!==r&&o.throwErr("Unexpected "+u(n)+" argument ("+r+")");},m=function(t,e,n,r){var i=typeof e,a="string"===i,s=e instanceof Element;if(a){if(0===n)return {text:e};if(1===n)return {text:e,title:r[0]};if(2===n)return d(n,r),{icon:e};f(e,n);}else {if(s&&0===n)return d(n,r),{content:e};if(o.isPlainObject(e))return p(n,r),e;f(e,n);}};e.getOpts=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];var n={};t.forEach(function(e,o){var r=m(0,e,o,t);Object.assign(n,r);});var o=l(n);n.buttons=r.getButtonListOpts(o),delete n.button,n.content=i.getContentOpts(n.content);var u=Object.assign({},s,c,n);return Object.keys(u).forEach(function(t){a.DEPRECATED_OPTS[t]&&a.logDeprecation(t);}),u};},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r={element:"input",attributes:{placeholder:""}};e.getContentOpts=function(t){var e={};return o.isPlainObject(t)?Object.assign(e,t):t instanceof Element?{element:t}:"input"===t?r:null};},function(t,e,n){Object.defineProperty(e,"__esModule",{value:!0}),e.logDeprecation=function(t){var n=e.DEPRECATED_OPTS[t],o=n.onlyRename,r=n.replacement,i=n.subOption,a=n.link,s=o?"renamed":"deprecated",c='SweetAlert warning: "'+t+'" option has been '+s+".";if(r){c+=" Please use"+(i?' "'+i+'" in ':" ")+'"'+r+'" instead.';}var l="https://sweetalert.js.org";c+=a?" More details: "+l+a:" More details: "+l+"/guides/#upgrading-from-1x",console.warn(c);},e.DEPRECATED_OPTS={type:{replacement:"icon",link:"/docs/#icon"},imageUrl:{replacement:"icon",link:"/docs/#icon"},customClass:{replacement:"className",onlyRename:!0,link:"/docs/#classname"},imageSize:{},showCancelButton:{replacement:"buttons",link:"/docs/#buttons"},showConfirmButton:{replacement:"button",link:"/docs/#button"},confirmButtonText:{replacement:"button",link:"/docs/#button"},confirmButtonColor:{},cancelButtonText:{replacement:"buttons",link:"/docs/#buttons"},closeOnConfirm:{replacement:"button",subOption:"closeModal",link:"/docs/#button"},closeOnCancel:{replacement:"buttons",subOption:"closeModal",link:"/docs/#buttons"},showLoaderOnConfirm:{replacement:"buttons"},animation:{},inputType:{replacement:"content",link:"/docs/#content"},inputValue:{replacement:"content",link:"/docs/#content"},inputPlaceholder:{replacement:"content",link:"/docs/#content"},html:{replacement:"content",link:"/docs/#content"},allowEscapeKey:{replacement:"closeOnEsc",onlyRename:!0,link:"/docs/#closeonesc"},allowClickOutside:{replacement:"closeOnClickOutside",onlyRename:!0,link:"/docs/#closeonclickoutside"}};}])});
});

var swal = /*@__PURE__*/getDefaultExportFromCjs(sweetalert_min);

/** 
 *  File-name  : ImageAnnotation.js
 *  Created at : 20/02/2021
 *  @author    : Pradeep Yadav <pradeepdv45@gmail.com>
 *  @version   : 2.0
 *  @package   : svelte
 *  @detail    : All image annotation function
 *  Last updated by : Pradeep Yadav <pradeep.yadav@ucertify.com>
 *  Last updated : 11/05/2021
 */
const JS$1 = new JUI();
class ImageAnnotation {
    constructor(options) {
        this.MEDIA_URL = '//s3.amazonaws.com/jigyaasa_content_static/';
        this.marker_icon = ['', 'icomoon-plus', 'icomoon-checkmark-3', 'icomoon-close', 'icomoon-earth', 'icomoon-notification', 'icomoon-radio-checked2', 'icomoon-minus'];
        this.marker_name = ['Number Marker', 'Plus Marker', 'Checkmark Marker', 'Cross Marker', 'Earth Marker', 'Notification Marker', 'Radio Marker', 'Minus Marker'];

        this.annotate = {
            selector: '#authoringDiv .an_svg',
            auth_parent_selector: '#authoringDiv .an_p',
            mark_delete_selector: '#authoringDiv .an_num_p',
            description_selector: 'div[img-anno-desc="d"]',
        };
        this.modal_modal_open = 0;
        this.modalDetails = this.getModalDetails();
        this.init();
    }
    // check the current state variable
    currentState () {
        if (window.annotate != undefined) {
            this.annotate = window.annotate;
        }
        let state = {
            selector: this.annotate.selector,
            auth_parent_selector: this.annotate.auth_parent_selector,
            mark_delete_selector: this.annotate.mark_delete_selector,
            description_selector: this.annotate.description_selector,
            uc_annotation_container: '.an_c',
            uc_preview_container: '#preview div[sub_type="image-annotation"][h_over="1"] .an_c',
            uc_previewnum_container: '#preview div[sub_type="image-annotation"][h_over="1"] .an_num_p',
            uc_annotate_resize: 'an_num_p',
            uc_annotate_marker: '.an_num_p',
            desc_pre_block: 'an_d',
            annotate_number: 'an_num',
            list_container: 'an_li',
            setting: 'an_s', // if changing then change in modalDetails too
            parent_selector: '.an_p',
            figcaption: '.an_f',
            radius: 14,
            circle_color: '#e84848',
            cur_parent: '',
        };
        return state;
    }

    // initialte the image annotation library
    init () {
        console.log('Image Annotate plugin added!');
        this.state = this.currentState();
        this.bindUpEvent();
    }

    // contains the modal html which is appended in body once the library is initialized
    getModalDetails() {
        return({
            image_details: {
                'html': `<div class="modal" id="annotate_image_details">
                    <div class="modal-dialog modal-dialog-centered modal-xl overflow-hide">
                        <div class="modal-content min_height_500 shadow border border-dark">
                            <div class="modal-header">
                                <h4 class="modal-title">${l$1.edit_image}</h4>
                                <button type="button" class="close" data-bs-dismiss="modal" title="${l$1.close}" aria-label="${l$1.close}"><span aria-hidden="true">×</span></button>
                            </div>
                            <div class="modal-body">
                                <div class="annotate_information_container">
                                    <div class="clearfix">
                                        <div class="col-12 float-left">
                                            <div class="form-group pl-0 row anootate_error_msg text-b-red h"><div class="col-12 msg"></div></div>
                                            <div class="form-group pl-0 row">
                                                <label for="annotate_source_image" class="col-md-3 control-label col-form-label form-control-label text-left font-weight-normal mb-0"><span class="mendatory_label float-left">Source</span></label>
                                                <div class="col-9 col-md-6 col-sm-10 pr-2">
                                                    <input type="text" name="annotate_source_image" id="annotate_source_image" annotate_field="1" class="form-control form-control-sm" title="${l$1.image_url}" placeholder="${l$1.image_url}" value="" disabled="disabled">
                                                </div>
                                                <div class="col-3 col-sm-2 pl-0 col-md-3">
                                                    <button type="button" name="annotate_upload_image" id="annotate_upload_image" title="${l$1.browse}" class="btn btn-primary btn-sm col-12">${l$1.browse}</button>
                                                </div>
                                            </div>
                                            <div class="form-group pl-0 row">
                                                <label for="annotate_image_alt" class="col-md-3 control-label col-form-label form-control-label text-left font-weight-normal mb-0"><span class="mendatory_label float-left">${l$1.image_alt}</span></label>
                                                <div class="col-md-9">
                                                    <textarea name="annotate_image_alt" id="annotate_image_alt" annotate_field="1" class="form-control form-control-sm relative index1 min_height_38 max_height_200" title="${l$1.image_alt}" placeholder="${l$1.image_alt}" rows="1"></textarea>
                                                </div>
                                            </div>
                                            <div class="form-group pl-0 row">
                                                <label for="annotate_image_caption" class="col-md-3 control-label col-form-label form-control-label text-left font-weight-normal mb-0"><span class="mendatory_label float-left">${l$1.image_caption}</span></label>
                                                <div class="col-md-9">
                                                    <textarea name="annotate_image_caption" id="annotate_image_caption" annotate_field="1" class="form-control form-control-sm relative index1 min_height_38 max_height_200" title="${l$1.image_caption}" placeholder="${l$1.image_caption}" rows="1"></textarea>
                                                </div>
                                            </div>
                                            <div class="form-group pl-0 row">
                                                <label for="annotate_image_width" class="col-md-3 control-label col-form-label form-control-label text-left font-weight-normal mb-0"><span class="mendatory_label float-left">${l$1.image_width}</span></label>
                                                <div class="col-md-9">
                                                    <input type="number" min="400" max="600" step="20" annotate_field="1" name="annotate_image_width" id="annotate_image_width" class="num form-control form-control-sm" title="${l$1.image_width}" placeholder="${l$1.image_width}" value="">
                                                </div>
                                            </div>
                                            <div class="form-group pl-0 row">
                                                <label for="annotate_image_color" class="col-md-3 control-label col-form-label form-control-label text-left font-weight-normal mb-0">${l$1.marker_color}</label>
                                                <div class="col-md-9">
                                                    <select name="annotate_image_color" title="${l$1.marker_color}" id="annotate_image_color" class="form-select form-select-sm">
                                                        <option value="0">${l$1.red_color}</option>
                                                        <option value="1">${l$1.blue_color}</option>
                                                    </select>
                                                </div>
                                            </div>
                                            <div class="form-group pl-0 row">
                                                <label for="annotate_image_align" class="col-md-3 control-label col-form-label form-control-label text-left font-weight-normal mb-0">${l$1.text_align}</label>
                                                <div class="col-md-9">
                                                    <select name="annotate_image_align" title="${l$1.text_align}" id="annotate_image_align" class="form-control form-control-sm">
                                                        <option value="0">${l$1.right}</option>
                                                        <option value="1">${l$1.bottom}</option>
                                                        <option value="2">${l$1.on_click}</option>
                                                    </select>
                                                </div>
                                            </div>
                                            <div class="form-group pl-0 row">
                                                <label for="annotate_symbol" class="col-md-3 control-label col-form-label form-control-label text-left font-weight-normal mb-0">${l$1.mark_symbol}</label>
                                                <div class="col-md-9">
                                                    <select name="annotate_symbol" id="annotate_symbol" title="${l$1.mark_symbol}" class="form-control form-control-sm">
                                                        <option value="0">${l$1.number_marker}</option>
                                                        <option value="1">${l$1.plus_marker}</option>
                                                        <option value="2">${l$1.checkmark_marker}</option>
                                                        <option value="3">${l$1.cross_marker}</option>
                                                        <option value="4">${l$1.earth_marker}</option>
                                                        <option value="5">${l$1.notification_marker}</option>
                                                        <option value="6">${l$1.radio_marker}</option>
                                                        <option value="7">${l$1.minus_marker}</option>
                                                    </select>
                                                </div>
                                            </div>
                                            <div class="form-group pl-0 row mb-0">
                                                <div class="col-6 pr-0">
                                                    <input type="checkbox" name="annotate_border" id="annotate_border" title="${l$1.border}" class="checkbox-inline margin-top-2">
                                                    <label for="annotate_border" class="col-form-label control-label font-weight-normal form-control-label mb-0 ml-1 text-left">${l$1.border}</label>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-light btn-md annotate_image_cancel" data-bs-dismiss="modal" title="${l$1.cancel}" aria-label="${l$1.cancel}" tabindex="0" type="button">${l$1.cancel}</button>
                                <button class="btn btn-light btn-md annotate_image_reset" title="${l$1.reset}" aria-label="${l$1.reset}" tabindex="0" type="button">${l$1.reset}</button>
                                <button class="btn btn-primary btn-md annotate_image_submit" title="${l$1.submit}" aria-label="${l$1.submit}" tabindex="0" type="button">${l$1.submit}</button>
                            </div>
                        </div>
                    </div>
                </div>`
            },
            node_html: `<div class="btn-group position-absolute annotate_mark_tools h" style="top: -26px;z-index: 117;left: 24px;width: 48px;float: right;"><button type="button" class="btn btn-light p-sm float-left deletePoints" title="${l$1.delete_points}"><i class="icomoon-delete-sm"></i></button><button type="button" class="btn btn-light copyPoints float-left p-sm" title="${l$1.copy}"><i class="icomoon-copy"></i></button></div>`,
            node_setting: `<div class='an_s h' style='z-index:9;'><div><button class="btn btn-light p-0 pointer rounded-0 annotation_edit" title="${l$1.setting}" style="width: 22px;"><i class="icomoon-24px-settings-1"></i></button></div></div>`,
        });
    }

    // for setting the mouse current coordinates
    setMouseCoordinates (event, current_selector) {
        // contains the size of element having id 'authoringSvg' and its position relative to the viewport
        let boundary = current_selector.getBoundingClientRect();
        // sets the x position of the mouse co-ordinate
        let x_pos = event.clientX - boundary.left;
        // sets the y position of the mouse co-ordinate
        let y_pos = event.clientY - boundary.top;

        return {
            x: x_pos,
            y: y_pos
        };
    }

    // for creatinng the mark points
    createNode (number, position, type, icon) {
        var html = `<div class="${this.state.uc_annotate_resize}" style="left: ${position.x - this.state.radius}px; top: ${position.y - this.state.radius}px;">${(type == 0) ? `<span num="${number}" class="${this.state.annotate_number}">${number}</span>`: `<span d-m="${type}" class="${this.state.annotate_number} ${icon} s_m"></span>`}</div>`;
        return html;
    }

    // for allowing the draggable for the mark points
    allowDraggable (object) {
        if (this.dnd ) return false;
        let dragConfig = {
            // Z-index for the helper while being dragged.
            zIndex: 1,
            // Constrains dragging to within the bounds of the specified element or region
            containment: 'parent',
            // the element will snap to all other draggable elements
            snap: true,
            // The distance in pixels from the snap element edges at which snapping should occur
            snapTolerance: 5,
            // Triggered while the mouse is moved during the dragging, immediately before the current move happens
            onDrag: (e, ui)=> {
                // for custom containment
                let image_element = JS$1.find(JS$1.parent(e.target), 'img');
                let extra_height = (image_element.classList.contains('img-bordered')) ? 8 : 0;
                if (ui.position.top >= (Number(image_element.clientHeight + extra_height) - 2 * this.state.radius)) {
                    ui.position.top = (Number(image_element.clientHeight + extra_height) - 2 * this.state.radius);
                }
                if (ui.position.left >= (Number(image_element.clientWidth + extra_height) - 2 * this.state.radius)) {
                    ui.position.left = (Number(image_element.clientWidth + extra_height) - 2 * this.state.radius);
                }
                JS$1.find(JS$1.parent(this.state.uc_annotation_container), '.' + this.state.list_container, {action: 'attr', actionData: {x: ui.style.top}});
            },
        };
        this.dnd = new Draggable(dragConfig);
    }

    // for restoring the points i.e., it make sure the mark no is in proper order
    restorePoints (annotate_element, annotate_number, desc_selector, from_delete = 0) {
        let length = 0;
        if (annotate_number.length != 0) {
            let total_markers = [];
            annotate_number.forEach((_this)=> {
                if (!_this.classList.contains('s_m')) {
                    total_markers.push(_this.textContent);
                }
            });

            if (total_markers.length != 0) {
                total_markers = total_markers.reduce((acc, curr)=> {
                    if (typeof acc[curr] == 'undefined') {
                        acc[curr] = 1;
                    } else {
                        acc[curr] += 1;
                    }
                    return acc;
                }, {});
                let total_marker_keys = Number(Object.keys(total_markers)[Object.keys(total_markers).length - 1]);
                for (let index = 1; index < total_marker_keys; index++) {
                    if (JS$1.find(annotate_element, '[num="' + index + '"]', 'all').length == 0) {
                        JS$1.find(annotate_element, '[num="' + (index + 1) + '"]', {action: 'text', actionData: index});
                        JS$1.find(annotate_element, '[num="' + (index + 1) + '"]', {action: 'attr', actionData: {num: index}});
                    }
                    if (JS$1.find(desc_selector, '[num="' + index + '"]', 'all').length == 0) {
                        JS$1.find(desc_selector, '[num="' + (index + 1) + '"]', {action: 'text', actionData: index});
                        JS$1.find(desc_selector, '[num="' + (index + 1) + '"]', {action: 'attr', actionData: {num: index}});
                    }
                }
                length = total_marker_keys - from_delete;
            }
        }
        annotate_element.setAttribute('d-n', length);
    }

    // for repositioning the points when width or image changed
    reallocatePoints (current_object, data) {
        let extra_padding = JS$1.find(current_object, 'img').classList.contains('img-bordered') ? 8 : 0;
        let cur_width = JS$1.find(current_object, 'img').clientWidth + extra_padding;
        let cur_height = JS$1.find(current_object, 'img').clientHeight + extra_padding;
        let annotate_markers = JS$1.find(current_object, '.an_num_p', 'all');
        let percentage_width = ((cur_width - Number(data.width)) / cur_width) * 100;
        let percentage_height = ((cur_height - Number(data.height)) / cur_height) * 100;
        annotate_markers.forEach((_this)=> {
            let left = parseInt(_this.style.left);
            let top = parseInt(_this.style.top);
            left += (percentage_width / 100) * left;
            top += (percentage_height / 100) * top;
            JS$1.select(_this, 'css', {
                top: `${top}px`,
                left: `${left}px`
            });
        });
    }

    // bindup the events which is neccessary for imageAnnotation to work
    bindUpEvent () {
        let current_object;
        // appending the modal in body
        JS$1.insert('body', this.modalDetails.image_details.html, 'beforeend');
        
        JS$1.listen("body", 'shown.bs.modal', '#annotate_image_details', ()=> {
            JS$1.selectAll('.anootate_error_msg', 'addClass', 'h');
            JS$1.selectAll('[annotate_field="1"]', 'removeClass', 'border-danger');
            var focus_timer = setTimeout(()=> {
                JS$1.select('#annotate_upload_image').focus();
                clearTimeout(focus_timer);
            } ,100);
        });
        // for event on the main selector
        JS$1.listen('body', 'click', this.state.selector, (_this, event)=> {
            this.state.curdata = this.getData(JS$1.parent(_this));
            let position = this.setMouseCoordinates(event, _this);
            let number, marker_index, from_copied = 1;

            // in case of copy
            if (_this.closest(this.state.auth_parent_selector).dataset['c'] == 1) {
                number = _this.closest(this.state.auth_parent_selector).dataset['n'];
                from_copied = 0;
                marker_index = _this.closest(this.state.auth_parent_selector).dataset['m'];
                JS$1.setData(_this.closest(this.state.auth_parent_selector), {
                    'c': 0,
                    'n': '',
                    'm': '',
                });
            } else {
                if (this.state.curdata.marker == "0") {
                    number = Number(_this.closest(this.state.uc_annotation_container).getAttribute('d-n')) + 1;
                    _this.closest(this.state.uc_annotation_container).setAttribute('d-n', number);
                }
                marker_index = Number(this.state.curdata.marker);
            }

            /** This code is for adding list by default  - worked in case of right view**/
            let selector = JS$1.find(_this.closest(this.state.uc_annotation_container).parentElement, this.state.description_selector);
            if (JS$1.find(selector, '.' + this.state.desc_pre_block, 'all').length == 0) {
                JS$1.select(_this.closest(this.state.uc_annotation_container).parentElement, 'removeClass', 'd-flex');
                if (this.state.curdata.view == "0") {
                    _this.closest(this.state.uc_annotation_container).setAttribute('hv', 1);
                    selector.innerHTML = (`<div class="pre-block ${this.state.desc_pre_block} ${this.state.curdata.color == "1" ? 'bl' : 'rl'}" style='overflow:scroll;height:auto;min-height:${JS$1.find(_this.parentElement, 'img').clientHeight + (JS$1.find(_this.parentElement, 'img').classList.contains('img-bordered') ? 8 : 0)}px;margin-bottom:${_this.parentElement.outerHeight(true) - (JS$1.find(_this.parentElement, 'img').clientHeight + (JS$1.find(_this.parentElement, 'img').classList.contains('img-bordered') ? 8 : 0))}px'><div class="${this.state.list_container}"><div class="an_divp" d-m="${marker_index}">${marker_index == 0 ? `<div class="an_div" num="${number}">${number}</div>` : `<div class="an_div ${this.marker_icon[marker_index]}"></div>`}<div a_c='1'><b>Heading</b>: Sample Text</div></div></div></div>`);
                } else {
                    selector.innerHTML = (`<br><div class="pre-block ${this.state.desc_pre_block} ${this.state.curdata.color == "1" ? 'bl' : 'rl'}"><div class="${this.state.list_container}"><div class="an_divp" d-m="${marker_index}">${marker_index == 0 ? `<div class="an_div" num="${number}">${number}</div>` : `<div class="an_div ${this.marker_icon[marker_index]}"></div>`}<div a_c='1'><b>Heading</b>: Sample Text</div></div></div></div>`);
                }
            } else {
                if ((marker_index == 0 && from_copied == 1) || (marker_index != 0 && JS$1.find(selector, '.an_div.' + this.marker_icon[marker_index], 'all').length == 0)) {
                    JS$1.insert(JS$1.find(selector, '.' + this.state.list_container, 'all')[0], `<div class="an_divp" d-m="${marker_index}">${marker_index == 0 ? `<div class="an_div" num="${number}">${number}</div>` : `<div class="an_div ${marker_icon[marker_index]}"></div>`}<div a_c='1'><b>Heading</b>: Sample Text</div></div>`, 'beforeend');
                }
            }

            /** End of code : adding list by default**/
            JS$1.insert(_this.parentElement, this.createNode(number, position, marker_index, this.marker_icon[marker_index]), 'beforeend');
            JS$1.find(JS$1.parent(this.state.uc_annotation_container), '.' + this.state.list_container, 'all', {action: 'attr', actionData: {x:  Math.floor(Math.random() * 1000) } });
            this.setHover(_this.parentElement);
        });

        // To show preview click
        JS$1.listen('body', 'click', this.state.uc_previewnum_container , (_this)=> {
            window.tp = _this.parentElement;
            if (JS$1.find(_this.parentElement, _this.getAttribute('data-id'))?.classList.contains('imageannotation_display_block')) {
                JS$1.find(_this.parentElement, _this.getAttribute('data-id'), {action: 'removeClass', actionData: 'imageannotation_display_block'});
                JS$1.select(_this, 'removeClass', 'focus');
            } else {
                JS$1.find(_this.parentElement, '.imageannotation_popup_div', {action: 'removeClass', actionData: 'imageannotation_display_block'});
                JS$1.find(_this.parentElement, this.state.uc_annotate_marker, {action: 'removeClass', actionData: 'focus'});
                JS$1.find(_this.parentElement, _this.getAttribute('data-id'), {actiond: 'addClass', actionData: 'imageannotation_display_block'});
                JS$1.select(_this, 'addClass', 'focus');
            }
        });

        // mouseover event on the mark points
        JS$1.listen('body', 'mouseover', this.state.mark_delete_selector, (_this)=> {
           //this.allowDraggable(_this);
        });

        JS$1.listen('body', 'keyup', this.state.description_selector, (_this, event)=> {
            this.state.curdata = this.getData(JS$1.find(_this.parentElement, this.state.parent_selector));
            this.setHover(JS$1.find(_this.parentElement, this.state.parent_selector), event.keyCode);
            this.listSetup(_this, Number(JS$1.find(_this.parentElement, this.state.uc_annotation_container).getAttribute('d-n')), event.keyCode);
        });

        window.onscroll = ()=> {
            if (JS$1.selectAll('.annotate_mark_tools').length > 0 && this.state.cur_parent == '') {
                JS$1.selectAll('.annotate_mark_tools', 'remove');
            }
            if (JS$1.selectAll('.' + this.state.setting).length > 0) {
                JS$1.selectAll('.' + this.state.setting, 'remove');
            }
        };
        // used to fill the data in annotate information dialog and open it
        JS$1.listen('body', 'click', '.annotation_edit', (_this)=> {
            current_object = _this.closest(this.state.auth_parent_selector);
            this.state.curdata = this.getData(_this.closest(this.state.auth_parent_selector));
            this.state.curdata.height = JS$1.find(current_object, 'img').clientHeight + (JS$1.find(current_object, 'img').classList.contains('img-bordered') ? 8 : 0);
            let currrent_figure = JS$1.find(current_object, '.uc-figure');
            JS$1.select('#annotate_source_image', 'value', JS$1.findChild(currrent_figure, 'img').getAttribute('src').split(this.MEDIA_URL)[1]);
            JS$1.select('#annotate_image_alt', 'value', JS$1.findChild(currrent_figure, 'img').getAttribute('alt'));
            JS$1.select('#annotate_image_caption', 'value', JS$1.findChild(currrent_figure, 'figcaption').textContent);
            JS$1.select('#annotate_image_width', 'value', this.state.curdata.width);
            JS$1.select('#annotate_image_color', 'value', this.state.curdata.color);
            JS$1.select('#annotate_border').checked = ((JS$1.findChild(currrent_figure, 'img').classList.contains('img-bordered')) ? true : false);
            JS$1.select('#annotate_image_align', 'value', this.state.curdata.view);
            JS$1.select('#annotate_symbol', 'value', this.state.curdata.marker);
            JS$1.getBS('#annotate_image_details', 'Modal').show();
        });

        // calls in case of verification
        JS$1.listen('body', 'keyup', '[annotate_field="1"]', (_elm)=> {
            JS$1.selectAll('[annotate_field="1"]').forEach((_this)=> {
                if (_this.value.trim() == '' || (_this.classList.contains('num') && !(!isNaN(_this.value) && (Number(_this.value) >= 400 && Number(_this.value) <= 600)))) {
                    _this.classList.add('border-danger');
                    JS$1.selectAll('.anootate_error_msg', 'removeClass', 'h');
                    JS$1.selectAll('.anootate_error_msg .msg', 'text', l$1.image_err);
                } else {
                    _this.classList.remove('border-danger');
                    JS$1.selectAll('.anootate_error_msg', 'addClass', 'h');
                }
            });
        });

        // calls when annotate information submit btn is clicked
        JS$1.listen('body', 'click', '.annotate_image_submit', (_elm)=> {
            let is_error = 0;
            let msg = '';
            JS$1.selectAll('[annotate_field="1"]').forEach((_this)=> {
                if (_this.classList.contains('num') && !(!isNaN(_this.value) && (Number(_this.value) >= 400 && Number(_this.value) <= 600))) {
                    is_error = 1;
                    msg += l$1.image_width_range;
                    JS$1.select(_this, 'addClass', 'border-danger');
                } else if (_this.value.trim() == '') {
                    is_error = 1;
                    msg = l$1.fill_required_field;
                    _this.classList.add('border-danger');
                }
            });
            if (is_error == 0) {
                JS$1.selectAll('.anootate_error_msg', 'addClass', 'h');
                JS$1.selectAll('[annotate_field="1"]', 'removeClass', 'border-danger');
                let desc_selector = JS$1.find(current_object.closest(this.state.uc_annotation_container).parentElement, this.state.description_selector);
                JS$1.find(current_object, this.state.figcaption, {action: 'text', actionData: JS$1.select('#annotate_image_caption').value});
                let _backImg = JS$1.find(current_object, 'img');
                _backImg.onload = ()=> {
                    let extra_height = (JS$1.select('#annotate_border').checked) ? 8 : 0;
                    JS$1.find(current_object, 'svg', {action: 'attr', actionData: {height: _backImg.clientHeight + extra_height} });
                    if (Number(this.state.curdata.width) != JS$1.select('#annotate_image_width').value || (this.state.curdata.img != JS$1.select('#annotate_source_image').value)) {
                        swal({
                            title: l$1.change_image,
                            type: "warning",
                            showCancelButton: true,
                            closeOnConfirm: false,
                            confirmButtonText: l$1.reposition,
                            cancelButtonText: l$1.reset
                        }).then((result)=> {
                            if (result) {
                                this.reallocatePoints(current_object, this.state.curdata);
                            } else {
                                JS$1.find(current_object, '.' + this.state.uc_annotate_resize, {action: 'remove'});
                                current_object.closest(this.state.uc_annotation_container).setAttribute('d-n', '0');
                                JS$1.select(current_object.closest(this.state.uc_annotation_container), 'css', {width: JS$1.select('#annotate_image_width').value + 'px;'});
                                desc_selector.innerHTML = '';
                                if (JS$1.select('#annotate_image_align').value == "0") {
                                    current_object.closest(this.state.uc_annotation_container).removeAttribute('hv');
                                }
                            }
                            JS$1.getBS('#annotate_image_details', 'Modal').hide();
                            //swal.close();
                        });
                    } else {
                        JS$1.getBS('#annotate_image_details', 'Modal').hide();
                    }
                };
                _backImg.onerror = ()=> {
                    JS$1.getBS('#annotate_image_details', 'Modal').hide();
                };
                JS$1.select(_backImg, 'attr', {
                    "src": this.MEDIA_URL + JS$1.select('#annotate_source_image').value,
                    "data-mce-src": this.MEDIA_URL + JS$1.select('#annotate_source_image').value,
                    "alt": JS$1.select('#annotate_image_alt').value,
                    "width": JS$1.select('#annotate_image_width').value,
                    "class": JS$1.select('#annotate_border').checked ? "img-bordered" : '',
                });
                JS$1.select(current_object, 'attr', {
                    "d-i": JS$1.select('#annotate_source_image').value,
                    "d-w": JS$1.select('#annotate_image_width').value,
                    "d-c": JS$1.select('#annotate_image_color').value,
                    "d-v": JS$1.select('#annotate_image_align').value,
                    "d-m": JS$1.select('#annotate_symbol').value,
                });
                current_object.closest('[sub_type="image-annotation"]').removeAttribute('h_over');
                switch (Number(JS$1.select('#annotate_image_align').value)) {
                    case 0:
                        JS$1.select(JS$1.parent(current_object),'css', {width: JS$1.select('#annotate_image_width').value + "px"});
                        current_object.closest(this.state.uc_annotation_container).setAttribute('hv', 1);
                        let height = JS$1.find(current_object, 'img').clientHeight + (JS$1.find(current_object.parentElement, 'img').classList.contains('img-bordered') ? 8 : 0);
                        JS$1.find(current_object.closest(this.state.uc_annotation_container).parentElement, '.' + this.state.desc_pre_block, {action: 'css', actionData: {
                            overflow: 'scroll',
                            minHeight: height + 'px',
                            height: 'auto',
                            marginBottom: (current_object.clientHeight - height) + 'px'
                        } })[0].removeAttribute('data-mce-style');
                        JS$1.find(desc_selector, 'br', 'all')[0]?.remove();
                        if (desc_selector.innerHTML == '') {
                            current_object.closest(this.state.uc_annotation_container).removeAttribute('hv');
                        }
                        break;
                    case 1:
                    case 2:
                        JS$1.select(current_object.closest(this.state.uc_annotation_container), 'removeAttr', 'hv');
                        JS$1.select(current_object.parentElement, 'css', {width: JS$1.select('#annotate_image_width').value + "px"});
                        JS$1.find(current_object.closest(this.state.uc_annotation_container).parentElement, '.' + this.state.desc_pre_block, {action: 'removeAttr', actionData: 'style data-mce-style'});
                        if (JS$1.find(desc_selector, 'br', 'all')[0]?.length == 0) {
                            desc_selector.prepend('<br>');
                        }
                        if (JS$1.select('#annotate_image_align').value == "2") {
                            this.setHover(current_object);
                        }
                        current_object.closest('[sub_type="image-annotation"]').setAttribute('h_over', 1);
                        break;
                }

                JS$1.find(current_object.closest(this.state.uc_annotation_container).parentElement, '.' + this.state.desc_pre_block, {action: JS$1.select('#annotate_image_color').value == "1" ? 'addClass' : 'removeClass', actionData: 'bl'});
            } else {
                JS$1.selectAll('.anootate_error_msg', 'removeClass', 'h');
                JS$1.selectAll('.anootate_error_msg .msg', 'text', l$1.image_err);
                JS$1.showmsg(msg);
            }
            JS$1.find(current_object.closest(this.state.uc_annotation_container).parentElement, '.' + this.state.list_container, {action: 'attr', actionData: {x: Math.floor(Math.random() * 1000)} });
            JS$1.trigger(current_object.closest(this.state.uc_annotation_container), 'click');
        });

        // for initializing the media uplaod
        JS$1.listen('body', 'click', '#annotate_upload_image', ()=> {
            if (typeof(media) != undefined) {
                this.modal_modal_open = 1;
                //JS.getBS('#annotate_image_details', 'Modal').hide();
                setImage('annotate_source_image');
            }
        });

        // called on closing the media modal and if previosly annotation information is visible then to show it again
        JS$1.listen("body", "hidden.bs.modal", '#modal-media-upload', ()=> {
            console.log("modal hide");
            if (this.modal_modal_open == 1) {
                this.modal_modal_open = 0;
                JS$1.getBS('#annotate_image_details', 'Modal').show();
                var focus_timer = setTimeout(()=> {
                    JS$1.select('#annotate_upload_image').focus();
                    clearTimeout(focus_timer);
                } ,100);
            } else {
                JS$1.activate(0);
            }
        });

        // for the copy of markers
        JS$1.listen('body', 'click', '.copyPoints', (_this)=> {
            let current_number = _this.closest(this.state.mark_delete_selector).querySelector('.' + this.state.annotate_number);
            let current_marker = 0;
            if (current_number.textContent == '') {
                current_marker = Number(current_number.getAttribute('d-m'));
            }
            JS$1.setData(_this.closest(this.state.auth_parent_selector), {
                'c': 1,
                'n': current_number.textContent,
                'm': current_marker,
            });
            swal({
                title: ((current_marker != 0) ? this.marker_name[current_marker] : l$1.point + " " + current_number.textContent) + l$1.copid_paste,
                type: "success",
            });
        });

        JS$1.listen('body', 'click', '.annotate_image_reset', (_this)=> {
            swal({
                title: l$1.reset_data,
                type: "warning",
                showCancelButton: true,
                closeOnConfirm: true,
                confirmButtonText: l$1.yes_label,
                cancelButtonText: l$1.no_label
            }).then((result)=> {
                if (result) {
                    JS$1.select('#annotate_image_alt', 'value', l$1.image_alt_text);
                    JS$1.select('#annotate_image_caption','value', l$1.image_caption);
                    JS$1.select('#annotate_image_color','value', 0);
                    JS$1.select('#annotate_border').checked = true;
                    JS$1.select('#annotate_image_align','value', 1);
                    JS$1.select('#annotate_symbol','value', 0);
                    JS$1.select('[annotate_field="1"]', 'value', "world_000OVa.png");
                }
                //swal.close();
            });
        });

        // call when delete btn is pressed
        JS$1.listen('body', 'click', '.deletePoints', (_this)=> {
            this.state.cur_parent = _this.closest(this.state.mark_delete_selector);
            let cur_number = JS$1.find(this.state.cur_parent, '.' + this.state.annotate_number);
            let cur_element = '',
                cur_mode = 0;
            if (cur_number.textContent == '') {
                cur_element = 'span[d-m="' + cur_number.getAttribute('d-m') + '"]';
                cur_mode = cur_number.getAttribute('d-m');
            } else {
                cur_element = 'span[num="' + cur_number.textContent + '"]';
            }
            // Need to change it as we don't have link all the content
            if (JS$1.find(_this.closest(this.state.uc_annotation_container), cur_element, 'all').length > 1) {
                this.deletePoints(0, cur_number, cur_mode);
            } else {
                swal({
                    title: l$1.delete_confirmation,
                    type: "warning",
                    showCancelButton: true,
                    closeOnConfirm: false,
                    confirmButtonText: l$1.yes_label,
                    cancelButtonText: l$1.no_label
                }).then((result)=> {
                    if (result) {
                        this.deletePoints(1, cur_number, cur_mode);
                    }
                });
            }
        });
    }

    //Bind multievents
    bindMulti() {
        /*
         * Mouse over and mouse leave event on the parent selector for showing and hiding the setting btn
         */
        JS$1.listenAll(this.state.auth_parent_selector, 'mouseenter', (event)=> {
            let _this = event.target;
            console.log(_this);
            JS$1.find(_this.closest(this.state.uc_annotation_container).parentElement, this.state.description_selector).focus();
            JS$1.selectAll('div[sub_type="image-annotation"] .an_c, #authoringDiv div[sub_type="image-annotation"] .an_c *', 'removeAttr', 'data-mce-style');
            this.state.curdata = this.getData(_this);
            if (_this.querySelectorAll('.' + this.state.setting).length == 0) {
                JS$1.insert(_this, this.modalDetails.node_setting, 'beforeend');
            }
            if (_this.querySelectorAll('svg').length == 0) {
                JS$1.insert(_this, `<svg class="an_svg h" width="100%" height="${JS$1.find(_this, 'img').clientHeight + (JS$1.find(_this.parentElement, 'img').classList.contains('img-bordered') ? 8 : 0)}"></svg>`, 'beforeend');
            }
            this.restorePoints(_this.closest(this.state.uc_annotation_container), JS$1.find(_this, '.' + this.state.annotate_number, 'all'), JS$1.find(_this.closest(this.state.uc_annotation_container).parentElement, this.state.description_selector));
            this.listSetup(JS$1.find(_this.closest(this.state.uc_annotation_container).parentElement, this.state.description_selector), Number(_this.closest(this.state.uc_annotation_container).getAttribute('d-n')));
        });

        JS$1.listenAll(this.state.auth_parent_selector, 'mouseleave', (event)=> {
            let _this = event.target;
            JS$1.trigger(_this, 'click');
            JS$1.find(_this, `.annotate_mark_tools,.${this.state.setting}`, {action: 'remove'});
        });

        JS$1.listenAll(this.state.mark_delete_selector, 'mouseenter', (event)=> {
            let _this = event.target;
            // used to shows the delete icon when mouseenter inside added point area
            if (JS$1.find(_this, '.annotate_mark_tools', 'all').length == 0) {
                JS$1.insert(_this, this.modalDetails.node_html, 'beforeend');
            }
            JS$1.find(_this, '.annotate_mark_tools', {action: 'show', actionData: 'inline-flex'});
            _this.style.zIndex = '11';
        });
        JS$1.listenAll(this.state.mark_delete_selector,'mouseleave', (event)=> {
            let _this = event.target;
            // used to hides the delete icon when mouseenter inside added point area
            //_this.find('>.annotate_mark_tools').fadeOut('fast');
            JS$1.find(_this, '.annotate_mark_tools', {action: 'hide'});
            _this.style.zIndex = '10';
        });
    }

    // call in case of onclick functionality
    setHover (current_object, key) {
        let key_list = [37, 38, 39, 40];
        if (!JS$1.findInArray(key, key_list)) {
            return;
        }
        let markers = JS$1.find(current_object, '.an_num_p', 'all');
        let desc_selector = JS$1.find(JS$1.parent(current_object.parentElement), this.state.description_selector);
        let hover_array = [];
        markers.forEach((_this, index)=> {
            let is_number = (JS$1.find(_this, '.an_num').getAttribute('num') == undefined) ? 0 : 1;
            let html = '';
            if (is_number) {
                html = JS$1.find(JS$1.find(desc_selector, '[num="' + JS$1.find(_this, '.an_num').getAttribute('num') + '"]').parentElement, '[a_c="1"]').innerHTML;
            } else {
                html = JS$1.find(JS$1.find(desc_selector, '[d-m="' + JS$1.find(_this, '.an_num').getAttribute('d-m') + '"]'), '[a_c="1"]').innerHTML;
            }
            let doc = new DOMParser().parseFromString(html, 'text/html');
            hover_array[index] = {};
            if (doc.querySelector('b') != null) {
                let heading = doc.querySelector('b').textContent;
                hover_array[index]['content'] = html.replace(`<b>${heading}</b>`, '').replace(/:/, '').trim();
                hover_array[index]['heading'] = heading.replace(/:/, '').trim();
            } else {
                hover_array[index]['heading'] = '';
                hover_array[index]['content'] = html.trim();
            }
        });
        if (JS$1.find(current_object, '[json]', 'all').length == 0) {
            JS$1.insert(current_object, '<div json class="h-imp"></div>', 'beforeend');
        }
        JS$1.find(current_object, '[json]', {action: 'attr', actionData: {'json':  JSON.stringify(hover_array) }});
    }

    // responsible for the list setup
    listSetup (object, min_list, key) {
        let key_list = [37, 38, 39, 40];
        let symbol = {};
        let cur_symbol = {};
        let to_be_made = [];
        let error_type = 0;
        if (JS$1.find(object.parentElement, '.' + this.state.annotate_number, 'all').length == 0 || !JS$1.findInArray(key, key_list)) {
            return;
        }
        let desc_selector = JS$1.find(object, '.' + this.state.list_container);
        if (desc_selector.length != 0 && JS$1.findChild(desc_selector, '.an_divp').length != 0) {
            let current_value = -1;
            JS$1.find(object, '.an_divp', 'all').forEach((_this)=> {
                if (JS$1.findChild(_this, 'div', 'all').length < 2) {
                    _this.remove();
                } else if (JS$1.find(_this, '.an_div[num]', 'all').length > 0) {
                    current_value++;
                    JS$1.find(_this, '[a_c="1"]').textContent == '' ? JS$1.find(_this, '[a_c="1"]', {action: 'text', actionData: ' '}) : null;
                    JS$1.find(_this, '.an_div[num]', {action: 'attr', actionData: {num: current_value + 1} }).textContent = current_value + 1;
                } else {
                    JS$1.find(_this, '[a_c="1"]').textContent == '' ? JS$1.find(_this, '[a_c="1"]', {action: 'text', actionData: ' '}) : null;
                }
            });
        } else {
            if (desc_selector.length == 0 && object.find('.' + this.state.desc_pre_block).length == 0) {
                JS$1.select(object.parentElement, 'removeClass', 'd-flex');
                if (this.state.curdata.view == "0") {
                    object.innerHTML = (`<div class="pre-block ${this.state.desc_pre_block} ${this.state.curdata.color == "1" ? 'bl' : 'rl'}" style='overflow:scroll;height:auto;min-height:${object.parent().find('img').height() + (object.parent().find('img').hasClass('img-bordered') ? 8 : 0)}px;margin-bottom:${object.parent().find(this.state.uc_annotation_container).outerHeight(true) - (object.parent().find('img').height() + (object.parent().find('img').hasClass('img-bordered') ? 8 : 0))}px;'><div class="${this.state.list_container}"></div></div>`);
                } else {
                    object.innerHTML = (`<br><div class="pre-block ${this.state.desc_pre_block} ${this.state.curdata.color == "1" ? 'bl' : 'rl'}"><div class="${this.state.list_container}"></div></div>`);
                }
            }
        }

        let numList = JS$1.find(JS$1.find(object, '.'+this.state.list_container), '[num]', 'all');
        if (numList.length < min_list) {
            error_type = 1;
            let lengthCounter = numList.length;
            let diff = min_list - numList.length;
            for (let index = 0; index < diff; index++) {
                JS$1.insert(JS$1.find(object, '.' + this.state.list_container), `<div class="an_divp" d-m="0"><div class="an_div" num="${numList.length + 1}">${numList.length + 1}</div><div a_c='1'><b>Heading</b>: Sample Text</div></div>`, 'beforeend');
                lengthCounter++;
            }
        }

        JS$1.find(JS$1.find(object.parentElement, this.state.uc_annotation_container), '.s_m[d-m]', 'all').forEach((_this)=> {
            symbol[_this.getAttribute('d-m')] = (symbol[_this.getAttribute('d-m')] == undefined) ? 1 : Number(symbol[_this.getAttribute('d-m')]) + 1;
        });

        JS$1.find(object, '[d-m]:not([d-m="0"])', 'all').forEach((_this)=> {
            cur_symbol[_this.getAttribute('d-m')] = (cur_symbol[_this.getAttribute('d-m')] == undefined) ? 1 : Number(cur_symbol[_this.getAttribute('d-m')]) + 1;
        });

        if (Object.keys(symbol).length != 0) {
            Object.keys(symbol).forEach((index)=> {
                if (symbol[index] > 0 && cur_symbol[index] != 1) {
                    to_be_made.push(this.marker_icon[index]);
                }
            });

            if (to_be_made.length > 0) {
                error_type = 1;
                for (let symbol_index = 0; symbol_index < to_be_made.length; symbol_index++) {
                    JS$1.insert(JS$1.find(object, '.' + this.state.list_container, 'all')[0], `<div class="an_divp" d-m="${this.marker_icon.indexOf(to_be_made[symbol_index])}"><div class="an_div ${to_be_made[symbol_index]}"></div><div a_c='1'><b>Heading</b>: Sample Text</div></div>`, 'beforeend');
                }
            }
        }

        if (error_type > 0) {
            swal({
                title: l$1.delete_no_of_points,
                type: 'error',
            });
        }
    }

    // for deleting the points
    deletePoints (is_multiple, cur_number, cur_mode) {
        JS$1.find(this.state.cur_parent, '.' + this.state.annotate_number, {action: 'hide'});
        var desc_selector = JS$1.find(this.state.cur_parent.closest(this.state.uc_annotation_container).parentElement, this.state.description_selector);
        (is_multiple) ? this.restorelist(cur_number, desc_selector): null;
        var annotation_element = this.state.cur_parent.closest(this.state.uc_annotation_container);
        var annotation_number = JS$1.find(this.state.cur_parent.closest(this.state.auth_parent_selector), '.' + this.state.annotate_number,'visible');
        this.state.cur_parent.remove(); 
        this.restorePoints(annotation_element, annotation_number, desc_selector, is_multiple);
        this.state.cur_parent = '';
        JS$1.selectAll('.annotate_mark_tools', 'remove');
        JS$1.find(JS$1.select(this.state.uc_annotation_container).parentElement, '.' + this.state.list_container, {action: 'attr', actionData: {x: Math.floor(Math.random() * 1000)}});
        swal({
            title: ((cur_mode == 0) ? l$1.point + " " + cur_number.textContent : this.marker_name[cur_mode]) + l$1.deleted_text,
            type: "success",
        });
    }

    // call in case of restoring the list
    restorelist (number_element, desc_element) {
        if (JS$1.find(desc_element, '[d-m]', 'all').length > 1) {
            if (number_element.getAttribute('d-m') == undefined) {
                JS$1.find(desc_element, '[num="' + number_element.textContent + '"]').parentElement.remove();
            } else {
                JS$1.find(desc_element, '[d-m="' + number_element.getAttribute('d-m') + '"]').remove();
            }
        } else {
            desc_element.innerHTML = ('');
            if (this.state.curdata.view == "0") {
                JS$1.find(desc_element.parentElement, this.state.uc_annotation_container).removeAttribute('hv');
            }
        }
    }

    // for getting the current data
    getData (object) {
        return {
            width: object.getAttribute('d-w'),
            img: object.getAttribute('d-i'),
            color: object.getAttribute('d-c'),
            view: object.getAttribute('d-v'),
            marker: object.getAttribute('d-m')
        };
    }
}

// check if uc_image_annotate is available in window or not
// if (typeof(window.uc_image_annotate) == "undefined") {
//     var uc_image_annotate = new imageAnnotate();
//     window.uc_image_annotate = uc_image_annotate;
//     uc_image_annotate.init();
// } else {
//     console.log('Image Annotate already added!');
// }

/* src\components\EditorPopoverModal.svelte generated by Svelte v3.40.2 */
const file$o = "src\\components\\EditorPopoverModal.svelte";

function add_css$i(target) {
	append_styles(target, "svelte-1g6i3nv", "#modal_editor.svelte-1g6i3nv.svelte-1g6i3nv.svelte-1g6i3nv{margin-top:-1px;overflow:hidden;z-index:9999 !important}.no-top-pd.svelte-1g6i3nv.svelte-1g6i3nv.svelte-1g6i3nv{padding:0!important;margin:0!important}#modal_editor.svelte-1g6i3nv>.modal-dialog.svelte-1g6i3nv>.modal-content.svelte-1g6i3nv{box-shadow:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdG9yUG9wb3Zlck1vZGFsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtQ0EsYUFBYSw2Q0FBQyxDQUFDLEFBQ1gsV0FBVyxJQUFJLENBQ2YsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLElBQUksQ0FBQyxVQUFVLEFBQzVCLENBQUMsQUFRRCxVQUFVLDZDQUFDLENBQUMsQUFDUixPQUFPLENBQUUsQ0FBQyxVQUFVLENBQ3BCLE1BQU0sQ0FBRSxDQUFDLFVBQVUsQUFDdkIsQ0FBQyxBQUNELDRCQUFhLENBQUMsNEJBQWEsQ0FBQyxjQUFjLGVBQUMsQ0FBQyxBQUN4QyxXQUFXLElBQUksQUFDbkIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJFZGl0b3JQb3BvdmVyTW9kYWwuc3ZlbHRlIl19 */");
}

function create_fragment$o(ctx) {
	let div4;
	let div3;
	let div2;
	let div1;
	let div0;
	let t;
	let button;

	const block = {
		c: function create() {
			div4 = element("div");
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t = space();
			button = element("button");
			attr_dev(div0, "id", "frame_container");
			attr_dev(div0, "class", "h-100");
			add_location(div0, file$o, 28, 16, 1168);
			attr_dev(button, "class", "h");
			attr_dev(button, "id", "editor_close_btn");
			attr_dev(button, "data-bs-dismiss", "modal");
			add_location(button, file$o, 29, 16, 1232);
			attr_dev(div1, "class", "modal-body mh-100 overflow-hide no-pd no-top-pd h-100 svelte-1g6i3nv");
			add_location(div1, file$o, 27, 12, 1083);
			attr_dev(div2, "class", "modal-content h-100 mw-100 svelte-1g6i3nv");
			add_location(div2, file$o, 26, 8, 1029);
			attr_dev(div3, "class", "modal-dialog modal-dialog-centered no-top-pd h-100 svelte-1g6i3nv");
			add_location(div3, file$o, 25, 4, 955);
			attr_dev(div4, "id", "modal_editor");
			attr_dev(div4, "class", "modal white-bg p-0 modal_editor svelte-1g6i3nv");
			attr_dev(div4, "role", "dialog");
			attr_dev(div4, "tabindex", "-1");
			add_location(div4, file$o, 24, 0, 858);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div3);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div1, t);
			append_dev(div1, button);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditorPopoverModal', slots, []);

	AH.select('#modal_editor', 'shown.bs.modal', function () {
		setTimeout(function () {
			AH.select('.modal-backdrop', 'addClass', ['modal-backdrop-custom']);
			AH.select('.modal-backdrop.show', 'addClass', ['modal-backdrop-custom.show']);
		});
	});

	AH.select('#modal_editor', 'hidden.modal', function () {
		setTimeout(function () {
			AH.select('.modal-backdrop', 'removeClass', ['modal-backdrop-custom']);
			AH.select('.modal-backdrop.show', 'removeClass', ['modal-backdrop-custom.show']);
		});
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorPopoverModal> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ AH });
	return [];
}

class EditorPopoverModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$o, safe_not_equal, {}, add_css$i);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditorPopoverModal",
			options,
			id: create_fragment$o.name
		});
	}
}

/* src\components\PeGlossaryContentLink.svelte generated by Svelte v3.40.2 */

function create_fragment$p(ctx) {
	const block = {
		c: noop,
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PeGlossaryContentLink', slots, []);

	onMount(() => {
		var requestedGuid = "";
		var isInPreview = false;

		AH.listen('body', 'click', 'span.link', function (_this) {
			if (_this.parentElement.classList.contains("tinymce-editor") || _this.closest(".tinymce-editor")) {
				//@Remove click from editor Authoring
				return false;
			}

			if (_this.getAttribute("guid").indexOf("new") != -1) {
				AH.showmsg("Please save the content before preview", 4, 1);
				return false;
			}

			var guid = typeof _this.getAttribute("guid") != "undefined"
			? _this.getAttribute("guid")
			: "";

			var style = typeof _this.getAttribute("embed") != "undefined"
			? _this.getAttribute("embed")
			: "";

			var url = "";

			if (guid != "") {
				isInPreview = guid.startsWith('new-');
				url += `${baseUrl}preview.php?content_guid=${guid}&change_links_target=1`;
			}

			if (url != "") {
				switch (style.toLowerCase()) {
					case "new":
						window.open(url + "&action=new", "_blank");
						break;
					case "inline":
						if (AH.nextElm(_this).classList.contains('span-inline')) {
							AH.slideToggle(AH.nextElm(_this));

							if (AH.select(_this).hasAttribute('toggle_link')) {
								var txt = AH.select(_this)?.getAttribute('toggle_link');
								AH.select(_this).setAttribute('toggle_link', AH.select(_this).textContent);
								AH.select(_this).textContent = txt;
							}
						} else {
							if (requestedGuid != guid) {
								requestedGuid = guid;
								AH.activate(1);
								var no_space = '';

								if (AH.select(".prettyprint.linenums").length > 0) {
									AH.select('.prettyprint.linenums', 'addClass', ['handel_prettyprint']);
									AH.select('.prettyprint.linenums', 'removeClass', ['linenums']);
								} else {
									no_space = 'white_space_imp py-2';
								}

								AH.ajax({ type: "POST", url }).then(data => {
									requestedGuid = "";

									if (data) {
										data = data.replace(/sec_button/g, "");
									}

									AH.insert(_this, '<div linkedGuid= "' + guid + '"class="span-inline span-inline well bg-lighter-blue blue_border mt-2 py-0 mt-2 py-0 ' + no_space + '" style="display:none;"><span class="close mt-2 font28 pointer">&times;</span><div class="d-flex section_' + guid + '">' + data + '</div></div>', 'afterend');
									AH.addClass(AH.find('.section_' + guid, '#preview-content-in-span'), 'overflow');

									if (no_space != '') {
										AH.addClass(AH.find('.section_' + guid, '#preview-content-in-span'), 'pt-3');
									}

									if (typeof ajaxContentUpdate != 'undefined') {
										let data = AH.nextAll(_this);

										AH.findAll(data, '.uc-figure', {
											action: 'addClass',
											actionData: 'spanlink_container'
										});

										ajaxContentUpdate({
											imgAltText: 1,
											container: ['.spanlink_container']
										});
									}

									AH.slideDown(AH.nextElm(_this), '500');
									AH.activate(0);
								});
							}
						}
						break;
					case "factlink":
						var _tId = "factbodydiv" + guid;
						_tId = document.getElementById(_tId) ? guid : _tId;
						if (AH.select('#' + _tId).closest('.base').style.display != 'block') {
							_srcGuid = AH.select('#' + _tId).closest('.base').getAttribute('g');
							AH.toggleDom(`[g = "${_srcGuid}"]`, 'show');
							_tGuid = _this.closest('.base').getAttribute('g');
							AH.toggleDom('[g = "' + _tGuid + '"]', 'hide');
						}
						var scrollHeight = getScrollTop() > 115 ? 50 : 95;
						var _px = AH.offset('#' + _tId).top - 50;
						scrollnow(_px);
						break;
					default:
						var cl = function (obj) {
							obj.parentElement.classList.add('fact-dialog');
							obj.parentElement.querySelector('.f-title').remove();

							if (obj.clientHeight < 89) {
								var p = obj.querySelector('>p');
								p.style.marginTop = (80 - p.clientHeight) / 2;
							}

							obj.parentElement.querySelector('.ui-dialog-titlebar').classList.add('title-sep');
							AH.insert(obj.parentElement.querySelector('.ui-dialog-titlebar'), '<span class="float-left modal_side_options"><span id="backward_link" class="icomoon-arrow-left s2 spanlink_nav disabled link link_shift"></span><span id="forward_link" class="icomoon-arrow-right-2 s2 spanlink_nav disabled link"></span><span>', 'afterend');
							obj.dialog("option", "position", "center");

							imgLoaded(obj).then(function () {
								var foundImg = obj.parentElement.querySelectorAll('img');

								//@pradeep: if image is greater than this number then will resized the object.: Yes
								if (foundImg.length == 1 && foundImg.get(0).naturalWidth > 100 && foundImg.get(0).naturalHeight > 100) {
									var overflow_css = 'hidden';
									var dwidth = foundImg.get(0).naturalWidth;
									var dheight = foundImg.get(0).naturalHeight;
									var cheight1 = obj.clientHeight;
									var cwidth = obj.clientWidth;
									var cheight = cheight1 + AH.siblings(obj, ".ui-dialog-titlebar")[0].clientHeight + dheight;
									var get_window_height = window.innerHeight - (AH.find(document.body, "header").clientHeight + AH.find(document.body, "footer").clientHeight);

									if (cheight > get_window_height) {
										overflow_css = "auto";
									}

									dwidth = dwidth > obj.parentElement.clientWidth
									? dwidth + 120
									: obj.parentElement.clientWidth;

									if (dwidth + 160 > cwidth) {
										// we are adding 160 beacuse left and right adding 80 px so we are calculating the width
										dwidth = "auto";
									}

									AH.setCss(obj.parentElement, {
										width: dwidth,
										height: dheight + 100,
										'max-height': window.innerHeight,
										'max-width': window.innerWidth,
										overflow: overflow_css
									});

									var obj_maxHeight = obj.parentElement.outerHeight - AH.find(obj.parentElement, 'ui-dialog-titlebar').outerHeight - 15;
									obj_maxHeight = dheight + 50 > obj_maxHeight ? obj_maxHeight : "";

									AH.setCss(AH.find(obj.parentElement, '.factlink-content'), {
										'height': obj.parentElement.clientHeight - AH.find(obj.parentElement, '.ui-dialog-titlebar').clientHeight - 35,
										'max-height': obj_maxHeight
									});

									var top_calc = (window.innerHeight - AH.select('.fact-dialog').clientHeight) / 2;
									var left_calc = (window.innerWidth - AH.select('.fact-dialog').clientWidth) / 2;

									setTimeout(
										function () {
											obj.dialog("option", "position", "center");
										},
										5
									);

									if (AH.select(".external-module-body", "visible").length > 0) {
										AH.setCss(obj.parentElement, { 'top': top_calc, 'left': left_calc });
									}
								} else {
									obj.dialog("option", "position", "center");
								}
							});
						};
						var wd = _this.getAttribute('width');
						var ht = _this.getAttribute('height');
						if (_this.classList.contains("auto_resize")) wd = 'auto';
						if (ht === undefined) ht = 'auto';
						if (isInPreview) {
							var __inline = AH.nextElm('[name="' + guid + '"]', '.content_type_f');
							var inline_data = __inline.querySelector('.collapse_content').innerHTML;
							var inline_title = '<div class="f-title">' + __inline.querySelector('.f').innerHTML + '</div>';
							inline_data = '<div>' + inline_title + '<div>' + inline_data + '</div></div>';

							bindDialog(
								{
									click: _this,
									wd: typeof wd != "undefined" ? wd : 450,
									ht,
									trep: ".f-title b",
									data: inline_data,
									rz: 1,
									dgtype: "factlink",
									diologGuid: guid
								},
								cl
							);
						} else {
							if (typeof jQuery.ui != 'undefined') {
								bindAjaxDialog(
									{
										url,
										click: _this,
										wd: typeof wd != "undefined" ? wd : 450,
										ht,
										trep: ".f-title b",
										rz: 1,
										dgtype: "factlink",
										diologGuid: guid
									},
									cl
								);
							} else {
								window.parent.bindAjaxDialog(
									{
										url,
										click: _this,
										wd: typeof wd != "undefined" ? wd : 450,
										ht,
										trep: ".f-title b",
										rz: 1,
										dgtype: "factlink",
										diologGuid: guid
									},
									cl
								);
							}
						}
				}
			}
		});

		AH.listen(document.body, "click", '.span-inline .close', function (_this) {
			AH.slideUp(_this.parentElement, 500);
		});

		AH.listen(document.body, 'click', '.weblink-fullscreen, .exhibit-fullscreen', function (_this) {
			var object = _this.parentElement.parentElement;

			if (_this.querySelector('span').classList.contains('fa-expand')) {
				weblink_width = object.clientWidth;
				weblink_height = object.clientHeight;
				weblink_top = object.position().top;
				weblink_left = object.position().left;
				_this.setAttribute("title", "Revert");
				AH.find(_this, '.fa-expand').classList.remove("fa-expand");
				AH.find(_this, '.fa-expand').classList.add("fa-compress");

				AH.setCss(object, {
					top: '0',
					left: '0',
					width: window.innerWidth,
					height: window.innerHeight
				});

				AH.setCss(AH.select('.weblink-fullscreen,.exhibit-fullscreen').parentElement.nextElementSibling, {
					width: window.innerWidth - 16,
					height: window.innerHeight - 47
				});

				AH.setCss(AH.select(".exhibit-fullscreen").parentElement.nextElementSibling, {
					'max-width': '1412px',
					'max-height': '695px'
				});

				AH.select(".exhibit-fullscreen").parentElement.parentElement.style.overflow = hidden;
			} else {
				_this.setAttribute("title", "Full Screen");
				_this.querySelector('.fa-compress').classList.remove("fa-compress");
				_this.querySelector('.fa-compress').classList.add("fa-expand");

				AH.setCss(AH.select('.weblink-fullscreen').parentElement.nextElementSibling, {
					width: weblink_width - 16,
					height: weblink_height - 47
				});

				AH.setCss(AH.select(".exhibit-fullscreen").parentElement.nextElementSibling, {
					'max-width': '740px',
					'max-height': '420px',
					'width': 'auto'
				});

				window.scrollnow(weblink_top);

				if (_this.classList.contains('exhibit-fullscreen')) {
					AH.setCss(object, {
						'top': weblink_top,
						'left': weblink_left,
						width: weblink_width,
						height: weblink_height
					});
				} else {
					AH.setCss(object, {
						'top': weblink_top + 44,
						'left': weblink_left,
						width: weblink_width,
						height: weblink_height
					});
				}
			}
		});
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PeGlossaryContentLink> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ onMount, AH });
	return [];
}

class PeGlossaryContentLink extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PeGlossaryContentLink",
			options,
			id: create_fragment$p.name
		});
	}
}

/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */

var jquery$1 = createCommonjsModule(function (module) {
( function( global, factory ) {

	{

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );
});

/* src\components\AnalyzeEbook.svelte generated by Svelte v3.40.2 */

const { Object: Object_1$5 } = globals;
const file$p = "src\\components\\AnalyzeEbook.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[21] = i;
	return child_ctx;
}

// (138:4) {:else}
function create_else_block$6(ctx) {
	let h4;
	let div1;
	let div0;
	let t1;
	let div3;
	let div2;
	let p;
	let t2;
	let span;
	let t3;
	let t4;
	let t5;
	let div3_class_value;
	let t6;
	let div4;
	let button0;
	let t7;
	let button1;
	let current;
	let if_block = /*analyzedItemsCount*/ ctx[2] > 0 && create_if_block_1$6(ctx);

	button0 = new Button({
			props: {
				unelevated: true,
				outlined: true,
				variant: "contained",
				color: "#ccc",
				$$slots: { default: [create_default_slot_2$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler_2*/ ctx[14]);

	button1 = new Button({
			props: {
				unelevated: true,
				outlined: true,
				color: "#ccc",
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", function () {
		if (is_function(/*changeAnalyzeMenuProp*/ ctx[0])) /*changeAnalyzeMenuProp*/ ctx[0].apply(this, arguments);
	});

	const block = {
		c: function create() {
			h4 = element("h4");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = `${l$1.analyze_content}`;
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			p = element("p");
			t2 = text("There are ");
			span = element("span");
			t3 = text(/*analyzedItemsCount*/ ctx[2]);
			t4 = text(" elements which can be converted in ebook item.");
			t5 = space();
			if (if_block) if_block.c();
			t6 = space();
			div4 = element("div");
			create_component(button0.$$.fragment);
			t7 = space();
			create_component(button1.$$.fragment);
			add_location(div0, file$p, 140, 16, 4909);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file$p, 139, 12, 4847);
			attr_dev(h4, "class", "mb-5 font21");
			add_location(h4, file$p, 138, 8, 4809);
			attr_dev(span, "id", "analyzeditemscount");
			add_location(span, file$p, 145, 42, 5139);
			attr_dev(p, "class", "mb-0");
			add_location(p, file$p, 145, 16, 5113);
			attr_dev(div2, "class", "alert alert-info alert-dismissible");
			add_location(div2, file$p, 144, 12, 5047);
			attr_dev(div3, "class", div3_class_value = /*showActivator*/ ctx[3] == false ? "" : "h");
			add_location(div3, file$p, 143, 8, 4984);
			attr_dev(div4, "class", "svelteFooter");
			add_location(div4, file$p, 187, 8, 7732);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, div1);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, p);
			append_dev(p, t2);
			append_dev(p, span);
			append_dev(span, t3);
			append_dev(p, t4);
			append_dev(div3, t5);
			if (if_block) if_block.m(div3, null);
			insert_dev(target, t6, anchor);
			insert_dev(target, div4, anchor);
			mount_component(button0, div4, null);
			append_dev(div4, t7);
			mount_component(button1, div4, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (!current || dirty & /*analyzedItemsCount*/ 4) set_data_dev(t3, /*analyzedItemsCount*/ ctx[2]);

			if (/*analyzedItemsCount*/ ctx[2] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(div3, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*showActivator*/ 8 && div3_class_value !== (div3_class_value = /*showActivator*/ ctx[3] == false ? "" : "h")) {
				attr_dev(div3, "class", div3_class_value);
			}

			const button0_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div3);
			if (if_block) if_block.d();
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(div4);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(138:4) {:else}",
		ctx
	});

	return block;
}

// (134:1) {#if analyzeEbookContent}
function create_if_block$j(ctx) {
	let div;
	let loader;
	let current;

	loader = new Loader({
			props: { size: 50, msg: "Please wait Analyzing" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			attr_dev(div, "class", "editor_modal_content overflow-hidden");
			add_location(div, file$p, 134, 8, 4657);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$j.name,
		type: "if",
		source: "(134:1) {#if analyzeEbookContent}",
		ctx
	});

	return block;
}

// (149:12) {#if analyzedItemsCount > 0}
function create_if_block_1$6(ctx) {
	let div1;
	let table;
	let thead;
	let tr;
	let th0;
	let label;
	let input;
	let t0;
	let div0;
	let t1;
	let th1;
	let t3;
	let th2;
	let t5;
	let tbody;
	let each_value = /*analyzedItems*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th0 = element("th");
			label = element("label");
			input = element("input");
			t0 = space();
			div0 = element("div");
			t1 = space();
			th1 = element("th");
			th1.textContent = `${l$1.element_name}`;
			t3 = space();
			th2 = element("th");
			th2.textContent = `${l$1.detail}`;
			t5 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(input, "type", "checkbox");
			attr_dev(input, "rel", "chk_1");
			attr_dev(input, "class", "uc_checkbox");
			add_location(input, file$p, 154, 36, 5610);
			attr_dev(div0, "class", "check_mark_custom");
			add_location(div0, file$p, 155, 36, 5705);
			attr_dev(label, "class", "custom_checkbox_new float-left");
			add_location(label, file$p, 153, 50, 5526);
			attr_dev(th0, "class", "h-imp");
			add_location(th0, file$p, 153, 32, 5508);
			attr_dev(th1, "class", "text-dark text-nowrap");
			add_location(th1, file$p, 157, 32, 5823);
			attr_dev(th2, "class", "text-dark");
			add_location(th2, file$p, 158, 32, 5912);
			add_location(tr, file$p, 152, 28, 5470);
			add_location(thead, file$p, 151, 24, 5433);
			add_location(tbody, file$p, 161, 24, 6044);
			attr_dev(table, "class", "table table-bordered table-striped");
			add_location(table, file$p, 150, 20, 5357);
			add_location(div1, file$p, 149, 16, 5330);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th0);
			append_dev(th0, label);
			append_dev(label, input);
			append_dev(label, t0);
			append_dev(label, div0);
			append_dev(tr, t1);
			append_dev(tr, th1);
			append_dev(tr, t3);
			append_dev(tr, th2);
			append_dev(table, t5);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*analyzedItems, convertToHTML, showLess, showMore*/ 226) {
				each_value = /*analyzedItems*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(149:12) {#if analyzedItemsCount > 0}",
		ctx
	});

	return block;
}

// (174:40) {:else}
function create_else_block_1$2(ctx) {
	let span0;
	let t0_value = /*item*/ ctx[19][2].slice(0, 100) + "";
	let t0;
	let t1;
	let span0_class_value;
	let t2;
	let span1;
	let t3_value = /*item*/ ctx[19][2] + "";
	let t3;
	let span1_class_value;
	let t4;
	let span2;
	let span2_class_value;
	let t6;
	let span3;
	let span3_class_value;
	let mounted;
	let dispose;
	let if_block = /*item*/ ctx[19][2].length > 100 && create_if_block_3$3(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[12](/*i*/ ctx[21]);
	}

	function click_handler_1() {
		return /*click_handler_1*/ ctx[13](/*i*/ ctx[21]);
	}

	const block = {
		c: function create() {
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			t4 = space();
			span2 = element("span");
			span2.textContent = "Show more >";
			t6 = space();
			span3 = element("span");
			span3.textContent = "Show less";
			attr_dev(span0, "class", span0_class_value = "part-text-" + /*i*/ ctx[21]);
			add_location(span0, file$p, 174, 44, 6924);
			attr_dev(span1, "class", span1_class_value = "whole-text-" + /*i*/ ctx[21] + " d-none");
			add_location(span1, file$p, 175, 44, 7061);
			attr_dev(span2, "class", span2_class_value = "text-danger show-more-btn-" + /*i*/ ctx[21]);
			attr_dev(span2, "role", "button");
			attr_dev(span2, "tabindex", "0");
			add_location(span2, file$p, 176, 44, 7159);
			attr_dev(span3, "class", span3_class_value = "text-danger show-less-btn-" + /*i*/ ctx[21] + " d-none");
			attr_dev(span3, "role", "button");
			add_location(span3, file$p, 177, 44, 7323);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span0, anchor);
			append_dev(span0, t0);
			append_dev(span0, t1);
			if (if_block) if_block.m(span0, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, span2, anchor);
			insert_dev(target, t6, anchor);
			insert_dev(target, span3, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(span2, "click", click_handler, false, false, false),
					listen_dev(span3, "click", click_handler_1, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*analyzedItems*/ 2 && t0_value !== (t0_value = /*item*/ ctx[19][2].slice(0, 100) + "")) set_data_dev(t0, t0_value);

			if (/*item*/ ctx[19][2].length > 100) {
				if (if_block) ; else {
					if_block = create_if_block_3$3(ctx);
					if_block.c();
					if_block.m(span0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*analyzedItems*/ 2 && t3_value !== (t3_value = /*item*/ ctx[19][2] + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			if (if_block) if_block.d();
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(span1);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(span2);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(span3);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(174:40) {:else}",
		ctx
	});

	return block;
}

// (172:40) {#if convertToHTML}
function create_if_block_2$5(ctx) {
	let html_tag;
	let raw_value = /*item*/ ctx[19][2] + "";
	let html_anchor;

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*analyzedItems*/ 2 && raw_value !== (raw_value = /*item*/ ctx[19][2] + "")) html_tag.p(raw_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(172:40) {#if convertToHTML}",
		ctx
	});

	return block;
}

// (175:96) {#if item[2].length>100}
function create_if_block_3$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("...");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(175:96) {#if item[2].length>100}",
		ctx
	});

	return block;
}

// (163:28) {#each analyzedItems as item, i}
function create_each_block$5(ctx) {
	let tr;
	let td0;
	let label;
	let input;
	let input_data_id_value;
	let input_data_itemtype_value;
	let t0;
	let div;
	let t1;
	let td1;
	let t2;
	let t3_value = /*item*/ ctx[19][1] + "";
	let t3;
	let t4;
	let t5;
	let td2;
	let t6;
	let tr_key_value;
	let tr_class_value;

	function select_block_type_1(ctx, dirty) {
		if (/*convertToHTML*/ ctx[5]) return create_if_block_2$5;
		return create_else_block_1$2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			label = element("label");
			input = element("input");
			t0 = space();
			div = element("div");
			t1 = space();
			td1 = element("td");
			t2 = text("\"");
			t3 = text(t3_value);
			t4 = text("\"");
			t5 = space();
			td2 = element("td");
			if_block.c();
			t6 = space();
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "parent", "chk_1");
			attr_dev(input, "class", "uc_checkbox");
			attr_dev(input, "data-id", input_data_id_value = /*i*/ ctx[21]);
			attr_dev(input, "data-itemtype", input_data_itemtype_value = /*item*/ ctx[19][0]);
			add_location(input, file$p, 166, 40, 6348);
			attr_dev(div, "class", "check_mark_custom");
			add_location(div, file$p, 167, 40, 6490);
			attr_dev(label, "class", "custom_checkbox_new");
			add_location(label, file$p, 165, 36, 6271);
			attr_dev(td0, "class", "h-imp");
			add_location(td0, file$p, 164, 36, 6215);
			add_location(td1, file$p, 169, 36, 6616);
			attr_dev(td2, "class", "text-break text-wrap");
			add_location(td2, file$p, 170, 36, 6674);
			attr_dev(tr, "key", tr_key_value = /*i*/ ctx[21]);
			attr_dev(tr, "class", tr_class_value = "row-" + /*i*/ ctx[21]);
			add_location(tr, file$p, 163, 32, 6147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, label);
			append_dev(label, input);
			append_dev(label, t0);
			append_dev(label, div);
			append_dev(tr, t1);
			append_dev(tr, td1);
			append_dev(td1, t2);
			append_dev(td1, t3);
			append_dev(td1, t4);
			append_dev(tr, t5);
			append_dev(tr, td2);
			if_block.m(td2, null);
			append_dev(tr, t6);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*analyzedItems*/ 2 && input_data_itemtype_value !== (input_data_itemtype_value = /*item*/ ctx[19][0])) {
				attr_dev(input, "data-itemtype", input_data_itemtype_value);
			}

			if (dirty & /*analyzedItems*/ 2 && t3_value !== (t3_value = /*item*/ ctx[19][1] + "")) set_data_dev(t3, t3_value);

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(td2, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(163:28) {#each analyzedItems as item, i}",
		ctx
	});

	return block;
}

// (189:12) <Button                  unelevated={true}                  outlined={true}                  variant="contained"                  on:click={() => convertToHTML = !convertToHTML}                  color="#ccc"              >
function create_default_slot_2$6(ctx) {
	let t_value = l$1.convert + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$6.name,
		type: "slot",
		source: "(189:12) <Button                  unelevated={true}                  outlined={true}                  variant=\\\"contained\\\"                  on:click={() => convertToHTML = !convertToHTML}                  color=\\\"#ccc\\\"              >",
		ctx
	});

	return block;
}

// (198:12) <Button                  unelevated={true}                  outlined={true}                  on:click={changeAnalyzeMenuProp}                  color="#ccc"              >
function create_default_slot_1$7(ctx) {
	let t_value = l$1.cancel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$7.name,
		type: "slot",
		source: "(198:12) <Button                  unelevated={true}                  outlined={true}                  on:click={changeAnalyzeMenuProp}                  color=\\\"#ccc\\\"              >",
		ctx
	});

	return block;
}

// (133:0) <Dialog width="700" visible={true} style="background-color:#fff; border-radius: 5px;">
function create_default_slot$9(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$j, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*analyzeEbookContent*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(133:0) <Dialog width=\\\"700\\\" visible={true} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

function create_fragment$q(ctx) {
	let dialog;
	let current;

	dialog = new Dialog({
			props: {
				width: "700",
				visible: true,
				style: "background-color:#fff; border-radius: 5px;",
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(dialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(dialog, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dialog_changes = {};

			if (dirty & /*$$scope, analyzeEbookContent, changeAnalyzeMenuProp, convertToHTML, showActivator, analyzedItems, analyzedItemsCount*/ 4194367) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(dialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	let analyzeEbookContent;
	let convertToHTML;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AnalyzeEbook', slots, []);
	let { analyzeEbookMenu } = $$props;
	let { oldStemData } = $$props;
	let { controls } = $$props;
	let { addItemButton } = $$props;
	let { changeAnalyzeMenuProp } = $$props;
	let analyzedItems = {};
	let analyzedItemsCount = 0;
	let showActivator = true;
	let processedItemsCount = 0;
	let oldStemData2 = "";

	const convertObject = obj => {
		for (let ele of obj) {
			ele['outerHTML2'] = ele['nodeName'] == '#text'
			? ele['textContent']
			: ele['outerHTML'];
		}

		let newobj = {};
		let j = 0;
		let flag = 1;
		let validBlocks = ["UL", "DIV", "DL", "TABLE", "UC:SYNTAX"];

		for (let ele of obj) {
			let elem = ele['nodeName'];

			if (validBlocks.indexOf(elem) >= 0) {
				newobj[j] = ele;
				j = parseInt(j) + 1;
				flag = 1;
			} else {
				if (flag == 1) {
					if ((elem == 'CENTER' || elem == 'UC:CAPTION') && ele['outerHTML2'].indexOf("uc:caption") >= 0) {
						let outerhtmlnew = ele['outerHTML2'];

						if (outerhtmlnew != undefined) {
							let lastkey = Object.keys(newobj)[Object.keys(newobj).length - 1];
							newobj[lastkey]['outerHTML2'] = newobj[lastkey]['outerHTML2'] + outerhtmlnew;
							newobj[lastkey]['className'] = 'old_table_format';
						}
					} else {
						newobj[j] = ele;
						j = parseInt(j) + 1;
						flag = 0;
					}
				} else {
					var outerhtmlnew = ele['outerHTML2'];

					if (outerhtmlnew != undefined) {
						var lastkey = Object.keys(newobj)[Object.keys(newobj).length - 1];
						newobj[lastkey]['outerHTML2'] = newobj[lastkey]['outerHTML2'] + outerhtmlnew;
					}
				}
			}
		}

		return newobj;
	};

	const analyzeEbookDialog = () => {
		let analyzedItemsCount2 = 0;
		const parser = new DOMParser();
		const doc = parser.parseFromString(oldStemData, 'text/html');
		let temphtml = convertObject(doc.body.childNodes);
		oldStemData2 = temphtml;
		let analyzedItems2 = [];

		for (let i in temphtml) {
			const htmlcontent = temphtml[i]['outerHTML2'];

			if (htmlcontent != '') {
				analyzedItemsCount2 += 1;
				let type;

				let itemTypeJSON = {
					'#text': 'text',
					'UL': 'list',
					'box': 'box'
				};

				if (temphtml[i].nodeName == 'DIV') {
					if (temphtml[i].className != "") {
						if (temphtml[i].className.indexOf('box') >= 0) {
							type = 'box';
						}
					}
				} else {
					type = temphtml[i].nodeName;
				}

				let itemType = itemTypeJSON[type];
				analyzedItems2.push([itemType, temphtml[i].nodeName, htmlcontent]);
			}
		}

		$$invalidate(2, analyzedItemsCount = analyzedItemsCount2);
		$$invalidate(1, analyzedItems = analyzedItems2);

		setTimeout(
			() => {
				$$invalidate(4, analyzeEbookContent = false);
			},
			1000
		);
	};

	onMount(() => {
		analyzeEbookDialog();
		$$invalidate(3, showActivator = false);
	});

	const showMore = index => {
		const ele = document.querySelector(`.row-${index}`);

		if (ele) {
			ele.querySelector(`.part-text-${index}`).classList.add('d-none');
			ele.querySelector(`.whole-text-${index}`).classList.remove('d-none');
			ele.querySelector(`.show-more-btn-${index}`).classList.add('d-none');
			ele.querySelector(`.show-less-btn-${index}`).classList.remove('d-none');
		}
	};

	const showLess = index => {
		const ele = document.querySelector(`.row-${index}`);

		if (ele) {
			ele.querySelector(`.part-text-${index}`).classList.remove('d-none');
			ele.querySelector(`.whole-text-${index}`).classList.add('d-none');
			ele.querySelector(`.show-more-btn-${index}`).classList.remove('d-none');
			ele.querySelector(`.show-less-btn-${index}`).classList.add('d-none');
		}
	};

	const writable_props = [
		'analyzeEbookMenu',
		'oldStemData',
		'controls',
		'addItemButton',
		'changeAnalyzeMenuProp'
	];

	Object_1$5.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AnalyzeEbook> was created with unknown prop '${key}'`);
	});

	const click_handler = i => showMore(i);
	const click_handler_1 = i => showLess(i);
	const click_handler_2 = () => $$invalidate(5, convertToHTML = !convertToHTML);

	$$self.$$set = $$props => {
		if ('analyzeEbookMenu' in $$props) $$invalidate(8, analyzeEbookMenu = $$props.analyzeEbookMenu);
		if ('oldStemData' in $$props) $$invalidate(9, oldStemData = $$props.oldStemData);
		if ('controls' in $$props) $$invalidate(10, controls = $$props.controls);
		if ('addItemButton' in $$props) $$invalidate(11, addItemButton = $$props.addItemButton);
		if ('changeAnalyzeMenuProp' in $$props) $$invalidate(0, changeAnalyzeMenuProp = $$props.changeAnalyzeMenuProp);
	};

	$$self.$capture_state = () => ({
		onMount,
		Button,
		Dialog,
		Checkbox,
		Snackbar,
		Loader,
		l: l$1,
		jquery: jquery$1,
		analyzeEbookMenu,
		oldStemData,
		controls,
		addItemButton,
		changeAnalyzeMenuProp,
		analyzedItems,
		analyzedItemsCount,
		showActivator,
		processedItemsCount,
		oldStemData2,
		convertObject,
		analyzeEbookDialog,
		showMore,
		showLess,
		analyzeEbookContent,
		convertToHTML
	});

	$$self.$inject_state = $$props => {
		if ('analyzeEbookMenu' in $$props) $$invalidate(8, analyzeEbookMenu = $$props.analyzeEbookMenu);
		if ('oldStemData' in $$props) $$invalidate(9, oldStemData = $$props.oldStemData);
		if ('controls' in $$props) $$invalidate(10, controls = $$props.controls);
		if ('addItemButton' in $$props) $$invalidate(11, addItemButton = $$props.addItemButton);
		if ('changeAnalyzeMenuProp' in $$props) $$invalidate(0, changeAnalyzeMenuProp = $$props.changeAnalyzeMenuProp);
		if ('analyzedItems' in $$props) $$invalidate(1, analyzedItems = $$props.analyzedItems);
		if ('analyzedItemsCount' in $$props) $$invalidate(2, analyzedItemsCount = $$props.analyzedItemsCount);
		if ('showActivator' in $$props) $$invalidate(3, showActivator = $$props.showActivator);
		if ('processedItemsCount' in $$props) processedItemsCount = $$props.processedItemsCount;
		if ('oldStemData2' in $$props) oldStemData2 = $$props.oldStemData2;
		if ('analyzeEbookContent' in $$props) $$invalidate(4, analyzeEbookContent = $$props.analyzeEbookContent);
		if ('convertToHTML' in $$props) $$invalidate(5, convertToHTML = $$props.convertToHTML);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	 $$invalidate(4, analyzeEbookContent = true);
	 $$invalidate(5, convertToHTML = false);

	return [
		changeAnalyzeMenuProp,
		analyzedItems,
		analyzedItemsCount,
		showActivator,
		analyzeEbookContent,
		convertToHTML,
		showMore,
		showLess,
		analyzeEbookMenu,
		oldStemData,
		controls,
		addItemButton,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class AnalyzeEbook extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
			analyzeEbookMenu: 8,
			oldStemData: 9,
			controls: 10,
			addItemButton: 11,
			changeAnalyzeMenuProp: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AnalyzeEbook",
			options,
			id: create_fragment$q.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*analyzeEbookMenu*/ ctx[8] === undefined && !('analyzeEbookMenu' in props)) {
			console.warn("<AnalyzeEbook> was created without expected prop 'analyzeEbookMenu'");
		}

		if (/*oldStemData*/ ctx[9] === undefined && !('oldStemData' in props)) {
			console.warn("<AnalyzeEbook> was created without expected prop 'oldStemData'");
		}

		if (/*controls*/ ctx[10] === undefined && !('controls' in props)) {
			console.warn("<AnalyzeEbook> was created without expected prop 'controls'");
		}

		if (/*addItemButton*/ ctx[11] === undefined && !('addItemButton' in props)) {
			console.warn("<AnalyzeEbook> was created without expected prop 'addItemButton'");
		}

		if (/*changeAnalyzeMenuProp*/ ctx[0] === undefined && !('changeAnalyzeMenuProp' in props)) {
			console.warn("<AnalyzeEbook> was created without expected prop 'changeAnalyzeMenuProp'");
		}
	}

	get analyzeEbookMenu() {
		throw new Error("<AnalyzeEbook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set analyzeEbookMenu(value) {
		throw new Error("<AnalyzeEbook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get oldStemData() {
		throw new Error("<AnalyzeEbook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set oldStemData(value) {
		throw new Error("<AnalyzeEbook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get controls() {
		throw new Error("<AnalyzeEbook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set controls(value) {
		throw new Error("<AnalyzeEbook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addItemButton() {
		throw new Error("<AnalyzeEbook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set addItemButton(value) {
		throw new Error("<AnalyzeEbook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get changeAnalyzeMenuProp() {
		throw new Error("<AnalyzeEbook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set changeAnalyzeMenuProp(value) {
		throw new Error("<AnalyzeEbook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\Editor.svelte generated by Svelte v3.40.2 */

const { Object: Object_1$6, console: console_1$a, window: window_1$3 } = globals;
const file$q = "src\\Editor.svelte";

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[142] = list[i];
	return child_ctx;
}

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (2740:24) {#if state.viewConfig.title}
function create_if_block_21$1(ctx) {
	let html_tag;
	let raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.title.label) + "";
	let t0;
	let t1;
	let div;
	let div_class_value;
	let div_contenteditable_value;
	let div_data_placeholder_value;
	let mounted;
	let dispose;
	let if_block = /*state*/ ctx[4].editorView == 'authoring' && create_if_block_22$1(ctx);

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div = element("div");
			html_tag.a = t0;
			attr_dev(div, "class", div_class_value = /*editorClass*/ ctx[25]());
			attr_dev(div, "contenteditable", div_contenteditable_value = true);
			attr_dev(div, "id", "title");
			attr_dev(div, "data-text", "Title");
			attr_dev(div, "data-placeholder", div_data_placeholder_value = /*state*/ ctx[4].viewConfig.title.placeHolder);
			set_style(div, "borderBottom", "2px solid #e7e7e7");
			set_style(div, "margin", "0 0 5px 0");
			add_location(div, file$q, 2744, 7, 104748);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);

			if (!mounted) {
				dispose = listen_dev(div, "keyup", /*keyup_handler*/ ctx[51], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && raw_value !== (raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.title.label) + "")) html_tag.p(raw_value);

			if (/*state*/ ctx[4].editorView == 'authoring') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_22$1(ctx);
					if_block.c();
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*state*/ 16 && div_data_placeholder_value !== (div_data_placeholder_value = /*state*/ ctx[4].viewConfig.title.placeHolder)) {
				attr_dev(div, "data-placeholder", div_data_placeholder_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) html_tag.d();
			if (detaching) detach_dev(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_21$1.name,
		type: "if",
		source: "(2740:24) {#if state.viewConfig.title}",
		ctx
	});

	return block;
}

// (2742:7) {#if state.editorView == 'authoring'}
function create_if_block_22$1(ctx) {
	let div;
	let t_value = /*state*/ ctx[4].viewConfig.title.placeHolder + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "class", "editor_placeholder full_mode_hide");
			add_location(div, file$q, 2742, 8, 104615);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && t_value !== (t_value = /*state*/ ctx[4].viewConfig.title.placeHolder + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_22$1.name,
		type: "if",
		source: "(2742:7) {#if state.editorView == 'authoring'}",
		ctx
	});

	return block;
}

// (2755:24) {#if state.viewConfig.stem}
function create_if_block_19$1(ctx) {
	let html_tag;
	let raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.stem.label) + "";
	let t0;
	let t1;
	let div;
	let div_class_value;
	let div_data_text_value;
	let t2;
	let br;
	let mounted;
	let dispose;
	let if_block = /*state*/ ctx[4].editorView == 'authoring' && create_if_block_20$1(ctx);

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div = element("div");
			t2 = space();
			br = element("br");
			html_tag.a = t0;
			attr_dev(div, "class", div_class_value = /*editorClass*/ ctx[25]());
			attr_dev(div, "id", "stem");
			attr_dev(div, "readonly", "readonly");
			attr_dev(div, "data-text", div_data_text_value = "Stem");
			set_style(div, "border-bottom", "1px solid #e7e7e7");
			set_style(div, "margin", "5px 0 5px 0");
			set_style(div, "padding-top", "10px");
			set_style(div, "margin-top", "-18px");
			add_location(div, file$q, 2759, 7, 105602);
			add_location(br, file$q, 2772, 28, 106238);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, br, anchor);

			if (!mounted) {
				dispose = listen_dev(div, "Keyup", /*Keyup_handler*/ ctx[52], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && raw_value !== (raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.stem.label) + "")) html_tag.p(raw_value);

			if (/*state*/ ctx[4].editorView == 'authoring') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_20$1(ctx);
					if_block.c();
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) html_tag.d();
			if (detaching) detach_dev(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(br);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_19$1.name,
		type: "if",
		source: "(2755:24) {#if state.viewConfig.stem}",
		ctx
	});

	return block;
}

// (2757:7) {#if state.editorView == 'authoring'}
function create_if_block_20$1(ctx) {
	let div;
	let t_value = /*state*/ ctx[4].viewConfig.stem.placeHolder + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "class", "editor_placeholder full_mode_hide");
			add_location(div, file$q, 2757, 8, 105470);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && t_value !== (t_value = /*state*/ ctx[4].viewConfig.stem.placeHolder + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_20$1.name,
		type: "if",
		source: "(2757:7) {#if state.editorView == 'authoring'}",
		ctx
	});

	return block;
}

// (2775:6) {#if state.viewConfig.content}
function create_if_block_17$1(ctx) {
	let html_tag;
	let raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.content.label) + "";
	let t0;
	let t1;
	let div;
	let div_data_text_value;
	let mounted;
	let dispose;
	let if_block = /*state*/ ctx[4].editorView == 'authoring' && create_if_block_18$1(ctx);

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div = element("div");
			html_tag.a = t0;
			attr_dev(div, "class", "tinymce-editor auth-editor");
			attr_dev(div, "id", "content");
			attr_dev(div, "readonly", "readonly");
			attr_dev(div, "data-text", div_data_text_value = "Content");
			set_style(div, "border-bottom", "1px solid #e7e7e7");
			set_style(div, "margin", "5px 0 5px 0");
			set_style(div, "white-space", "pre-line");
			set_style(div, "clear", "both");
			set_style(div, "min-height", "125px");
			set_style(div, "padding-top", "10px");
			set_style(div, "margin-top", "-18px");
			add_location(div, file$q, 2779, 7, 106528);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);

			if (!mounted) {
				dispose = listen_dev(div, "keyup", /*keyup_handler_1*/ ctx[53], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && raw_value !== (raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.content.label) + "")) html_tag.p(raw_value);

			if (/*state*/ ctx[4].editorView == 'authoring') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_18$1(ctx);
					if_block.c();
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) html_tag.d();
			if (detaching) detach_dev(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_17$1.name,
		type: "if",
		source: "(2775:6) {#if state.viewConfig.content}",
		ctx
	});

	return block;
}

// (2777:7) {#if state.editorView == 'authoring'}
function create_if_block_18$1(ctx) {
	let div;
	let t_value = /*state*/ ctx[4].viewConfig.content.placeHolder + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "class", "editor_placeholder full_mode_hide");
			add_location(div, file$q, 2777, 8, 106414);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && t_value !== (t_value = /*state*/ ctx[4].viewConfig.content.placeHolder + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_18$1.name,
		type: "if",
		source: "(2777:7) {#if state.editorView == 'authoring'}",
		ctx
	});

	return block;
}

// (2798:6) {#if state.viewConfig.itemModule}
function create_if_block_16$1(ctx) {
	let div;
	let switch_instance;
	let updating_editorState;
	let div_style_value;
	let current;

	function switch_instance_editorState_binding(value) {
		/*switch_instance_editorState_binding*/ ctx[54](value);
	}

	var switch_value = /*Items*/ ctx[11].auth;

	function switch_props(ctx) {
		let switch_instance_props = {
			xml: /*state*/ ctx[4].xml,
			inEditor: 1,
			subtype: /*state*/ ctx[4].item,
			itemIcons: editorConfig.getItemDetails()['q'],
			isReview: /*state*/ ctx[4].remediationToggle,
			getChildXml: /*updateChildXml*/ ctx[33],
			ucEditor,
			getLabel: addPlaceHolder,
			didMount: /*didMount*/ ctx[19],
			showAns: /*showAns*/ ctx[16],
			smValidate: /*smValidate*/ ctx[26],
			l: l$1,
			user: /*_user*/ ctx[1],
			setInlineEditor: /*setInlineEditor*/ ctx[24],
			toggleMode: /*state*/ ctx[4].toggleMode,
			updateCSV: /*updateAlignMatch*/ ctx[39],
			changed_advance_xml: /*advanceXml*/ ctx[0]
		};

		if (/*state*/ ctx[4] !== void 0) {
			switch_instance_props.editorState = /*state*/ ctx[4];
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		binding_callbacks.push(() => bind(switch_instance, 'editorState', switch_instance_editorState_binding));
	}

	const block = {
		c: function create() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr_dev(div, "id", "authoringLoadComponent");
			attr_dev(div, "style", div_style_value = /*state*/ ctx[4].viewConfig.itemModule.style);
			add_location(div, file$q, 2798, 7, 107039);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty[0] & /*state*/ 16) switch_instance_changes.xml = /*state*/ ctx[4].xml;
			if (dirty[0] & /*state*/ 16) switch_instance_changes.subtype = /*state*/ ctx[4].item;
			if (dirty[0] & /*state*/ 16) switch_instance_changes.isReview = /*state*/ ctx[4].remediationToggle;
			if (dirty[0] & /*_user*/ 2) switch_instance_changes.user = /*_user*/ ctx[1];
			if (dirty[0] & /*state*/ 16) switch_instance_changes.toggleMode = /*state*/ ctx[4].toggleMode;
			if (dirty[0] & /*advanceXml*/ 1) switch_instance_changes.changed_advance_xml = /*advanceXml*/ ctx[0];

			if (!updating_editorState && dirty[0] & /*state*/ 16) {
				updating_editorState = true;
				switch_instance_changes.editorState = /*state*/ ctx[4];
				add_flush_callback(() => updating_editorState = false);
			}

			if (switch_value !== (switch_value = /*Items*/ ctx[11].auth)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					binding_callbacks.push(() => bind(switch_instance, 'editorState', switch_instance_editorState_binding));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty[0] & /*state*/ 16 && div_style_value !== (div_style_value = /*state*/ ctx[4].viewConfig.itemModule.style)) {
				attr_dev(div, "style", div_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (switch_instance) destroy_component(switch_instance);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16$1.name,
		type: "if",
		source: "(2798:6) {#if state.viewConfig.itemModule}",
		ctx
	});

	return block;
}

// (2823:6) {#if state.viewConfig.remediation}
function create_if_block_14$1(ctx) {
	let html_tag;
	let raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.remediation.label, "br") + "";
	let t0;
	let t1;
	let div;
	let div_class_value;
	let mounted;
	let dispose;
	let if_block = /*state*/ ctx[4].editorView == 'authoring' && create_if_block_15$1(ctx);

	const block = {
		c: function create() {
			html_tag = new HtmlTag();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			div = element("div");
			html_tag.a = t0;
			attr_dev(div, "class", div_class_value = /*editorClass*/ ctx[25]());
			attr_dev(div, "id", "remediation");
			attr_dev(div, "readonly", "readonly");
			attr_dev(div, "data-text", "Remediation");
			set_style(div, "border-bottom", "1px solid #e7e7e7");
			set_style(div, "margin", "5px 0 5px 0");
			set_style(div, "white-space", "pre-line");
			set_style(div, "clear", "both");
			set_style(div, "padding-top", "10px");
			set_style(div, "margin-top", "-18px");
			add_location(div, file$q, 2827, 7, 108129);
		},
		m: function mount(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);

			if (!mounted) {
				dispose = listen_dev(div, "keyup", /*keyup_handler_2*/ ctx[55], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && raw_value !== (raw_value = addPlaceHolder(/*state*/ ctx[4].viewConfig.remediation.label, "br") + "")) html_tag.p(raw_value);

			if (/*state*/ ctx[4].editorView == 'authoring') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_15$1(ctx);
					if_block.c();
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) html_tag.d();
			if (detaching) detach_dev(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14$1.name,
		type: "if",
		source: "(2823:6) {#if state.viewConfig.remediation}",
		ctx
	});

	return block;
}

// (2825:7) {#if state.editorView == 'authoring'}
function create_if_block_15$1(ctx) {
	let div;
	let t_value = /*state*/ ctx[4].viewConfig.remediation.placeHolder + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "class", "editor_placeholder full_mode_hide");
			add_location(div, file$q, 2825, 8, 108011);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && t_value !== (t_value = /*state*/ ctx[4].viewConfig.remediation.placeHolder + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15$1.name,
		type: "if",
		source: "(2825:7) {#if state.editorView == 'authoring'}",
		ctx
	});

	return block;
}

// (2879:9) {#if state.viewConfig.title}
function create_if_block_13$1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "id", "title_show");
			set_style(div, "white-space", "pre-line");
			set_style(div, "word-wrap", "break-word");
			set_style(div, "font-weight", "bold");
			set_style(div, "font-size", "17px");
			add_location(div, file$q, 2879, 10, 110011);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13$1.name,
		type: "if",
		source: "(2879:9) {#if state.viewConfig.title}",
		ctx
	});

	return block;
}

// (2885:9) {#if state.viewConfig.stem}
function create_if_block_12$1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "id", "stem_show");
			attr_dev(div, "class", "base");
			set_style(div, "padding", "10px 0 10px 0");
			set_style(div, "white-space", "pre-line");
			set_style(div, "word-wrap", "break-word");
			set_style(div, "font-size", "14px");
			add_location(div, file$q, 2885, 10, 110231);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12$1.name,
		type: "if",
		source: "(2885:9) {#if state.viewConfig.stem}",
		ctx
	});

	return block;
}

// (2892:9) {#if state.viewConfig.content}
function create_if_block_11$1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "id", "content_show");
			set_style(div, "padding", "10px 0 10px 0");
			set_style(div, "white-space", "pre-wrap word-wrap: break-word");
			set_style(div, "font-size", "14px");
			add_location(div, file$q, 2892, 10, 110481);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11$1.name,
		type: "if",
		source: "(2892:9) {#if state.viewConfig.content}",
		ctx
	});

	return block;
}

// (2898:9) {#if state.viewConfig.itemModule}
function create_if_block_10$2(ctx) {
	let div;
	let switch_instance;
	let div_aria_label_value;
	let current;
	var switch_value = /*Items*/ ctx[11].preview;

	function switch_props(ctx) {
		return {
			props: {
				editorState: /*state*/ ctx[4],
				xml: /*state*/ ctx[4].xml,
				setInlineEditor: /*setInlineEditor*/ ctx[24],
				isReview: /*state*/ ctx[4].remediationToggle,
				showAns: /*showAns*/ ctx[16],
				smValidate: /*smValidate*/ ctx[26],
				ucEditor,
				showAnswer: /*showAns*/ ctx[16].bind(this),
				toggleMode: true,
				user: /*_user*/ ctx[1],
				didMount: /*func*/ ctx[56]
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr_dev(div, "id", "xml_show");
			attr_dev(div, "class", "overflow");
			attr_dev(div, "role", "application");
			attr_dev(div, "tabindex", "0");
			attr_dev(div, "aria-label", div_aria_label_value = "application. " + l$1['itemtype_' + /*subtype*/ ctx[2]]);
			add_location(div, file$q, 2898, 10, 110713);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty[0] & /*state*/ 16) switch_instance_changes.editorState = /*state*/ ctx[4];
			if (dirty[0] & /*state*/ 16) switch_instance_changes.xml = /*state*/ ctx[4].xml;
			if (dirty[0] & /*state*/ 16) switch_instance_changes.isReview = /*state*/ ctx[4].remediationToggle;
			if (dirty[0] & /*_user*/ 2) switch_instance_changes.user = /*_user*/ ctx[1];

			if (switch_value !== (switch_value = /*Items*/ ctx[11].preview)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty[0] & /*subtype*/ 4 && div_aria_label_value !== (div_aria_label_value = "application. " + l$1['itemtype_' + /*subtype*/ ctx[2]])) {
				attr_dev(div, "aria-label", div_aria_label_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (switch_instance) destroy_component(switch_instance);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10$2.name,
		type: "if",
		source: "(2898:9) {#if state.viewConfig.itemModule}",
		ctx
	});

	return block;
}

// (2917:9) {#if state.viewConfig.remediation}
function create_if_block_9$2(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "id", "remediation_show");
			attr_dev(div, "class", "mt-4");
			set_style(div, "word-wrap", "break-word");
			set_style(div, "font-size", "14px");
			add_location(div, file$q, 2917, 10, 111438);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9$2.name,
		type: "if",
		source: "(2917:9) {#if state.viewConfig.remediation}",
		ctx
	});

	return block;
}

// (2936:0) {#if state.playerState}
function create_if_block_8$2(ctx) {
	let player;
	let updating_editorState;
	let current;

	function player_editorState_binding(value) {
		/*player_editorState_binding*/ ctx[57](value);
	}

	let player_props = {
		playerBookmark: /*state*/ ctx[4].playerBookmark,
		visible: /*state*/ ctx[4].playerPopup,
		value: /*state*/ ctx[4].playerArr,
		content_type: /*state*/ ctx[4].content_type,
		content_subtype: /*state*/ ctx[4].item,
		renderPlayerFunc: /*renderPlayer*/ ctx[20]
	};

	if (/*state*/ ctx[4] !== void 0) {
		player_props.editorState = /*state*/ ctx[4];
	}

	player = new Player({ props: player_props, $$inline: true });
	binding_callbacks.push(() => bind(player, 'editorState', player_editorState_binding));

	const block = {
		c: function create() {
			create_component(player.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(player, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const player_changes = {};
			if (dirty[0] & /*state*/ 16) player_changes.playerBookmark = /*state*/ ctx[4].playerBookmark;
			if (dirty[0] & /*state*/ 16) player_changes.visible = /*state*/ ctx[4].playerPopup;
			if (dirty[0] & /*state*/ 16) player_changes.value = /*state*/ ctx[4].playerArr;
			if (dirty[0] & /*state*/ 16) player_changes.content_type = /*state*/ ctx[4].content_type;
			if (dirty[0] & /*state*/ 16) player_changes.content_subtype = /*state*/ ctx[4].item;

			if (!updating_editorState && dirty[0] & /*state*/ 16) {
				updating_editorState = true;
				player_changes.editorState = /*state*/ ctx[4];
				add_flush_callback(() => updating_editorState = false);
			}

			player.$set(player_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(player.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(player.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(player, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$2.name,
		type: "if",
		source: "(2936:0) {#if state.playerState}",
		ctx
	});

	return block;
}

// (2963:2) {#if state.course_list}
function create_if_block_7$2(ctx) {
	let div;
	let span;
	let t1;
	let table;
	let thead;
	let tr;
	let th0;
	let input;
	let t2;
	let th1;
	let t4;
	let tbody;
	let each_value_1 = /*state*/ ctx[4].course_list;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			span.textContent = "This content have published in these courses, Select to replace course content";
			t1 = space();
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th0 = element("th");
			input = element("input");
			t2 = space();
			th1 = element("th");
			th1.textContent = "Course Name";
			t4 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(span, "class", "text-danger");
			add_location(span, file$q, 2964, 4, 112729);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "name", "publish_chbox_all");
			attr_dev(input, "id", "publish_chbox_all");
			add_location(input, file$q, 2968, 27, 112951);
			attr_dev(th0, "class", "width33");
			add_location(th0, file$q, 2968, 7, 112931);
			add_location(th1, file$q, 2969, 7, 113038);
			add_location(tr, file$q, 2967, 6, 112918);
			add_location(thead, file$q, 2966, 5, 112903);
			attr_dev(tbody, "class", "course_list_action");
			add_location(tbody, file$q, 2972, 5, 113093);
			attr_dev(table, "class", "table table-bordered table-striped");
			add_location(table, file$q, 2965, 4, 112846);
			add_location(div, file$q, 2963, 3, 112718);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(div, t1);
			append_dev(div, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th0);
			append_dev(th0, input);
			append_dev(tr, t2);
			append_dev(tr, th1);
			append_dev(table, t4);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16) {
				each_value_1 = /*state*/ ctx[4].course_list;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$2.name,
		type: "if",
		source: "(2963:2) {#if state.course_list}",
		ctx
	});

	return block;
}

// (2974:6) {#each state.course_list as data}
function create_each_block_1$3(ctx) {
	let tr;
	let td0;
	let input;
	let t0;
	let td1;
	let t1;
	let t2_value = /*data*/ ctx[142].crn + "";
	let t2;
	let t3;
	let t4_value = /*data*/ ctx[142].course_name + "";
	let t4;
	let t5;
	let tr_course_code_value;
	let tr_key_value;

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			input = element("input");
			t0 = space();
			td1 = element("td");
			t1 = text("[");
			t2 = text(t2_value);
			t3 = text("]-");
			t4 = text(t4_value);
			t5 = space();
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "name", "publish_chbox");
			attr_dev(input, "id", "publish_chbox");
			add_location(input, file$q, 2975, 12, 113249);
			add_location(td0, file$q, 2975, 8, 113245);
			add_location(td1, file$q, 2976, 8, 113329);
			attr_dev(tr, "course_code", tr_course_code_value = /*data*/ ctx[142].course_code);
			attr_dev(tr, "key", tr_key_value = /*data*/ ctx[142].course_code);
			add_location(tr, file$q, 2974, 7, 113177);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, input);
			append_dev(tr, t0);
			append_dev(tr, td1);
			append_dev(td1, t1);
			append_dev(td1, t2);
			append_dev(td1, t3);
			append_dev(td1, t4);
			append_dev(tr, t5);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && t2_value !== (t2_value = /*data*/ ctx[142].crn + "")) set_data_dev(t2, t2_value);
			if (dirty[0] & /*state*/ 16 && t4_value !== (t4_value = /*data*/ ctx[142].course_name + "")) set_data_dev(t4, t4_value);

			if (dirty[0] & /*state*/ 16 && tr_course_code_value !== (tr_course_code_value = /*data*/ ctx[142].course_code)) {
				attr_dev(tr, "course_code", tr_course_code_value);
			}

			if (dirty[0] & /*state*/ 16 && tr_key_value !== (tr_key_value = /*data*/ ctx[142].course_code)) {
				attr_dev(tr, "key", tr_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$3.name,
		type: "each",
		source: "(2974:6) {#each state.course_list as data}",
		ctx
	});

	return block;
}

// (2996:2) <Checkbox      id="saveCheckbox"     bind:checked={saveCheckbox}     value="Save any unsaved changes"     color="primary"     name="saveCheckbox"     ripple={false}     style="background-color: none;margin-left:-11px;"     title={"Check to save changes"}    >
function create_default_slot_8$2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Save any unsaved changes";
			add_location(span, file$q, 3005, 3, 114059);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$2.name,
		type: "slot",
		source: "(2996:2) <Checkbox      id=\\\"saveCheckbox\\\"     bind:checked={saveCheckbox}     value=\\\"Save any unsaved changes\\\"     color=\\\"primary\\\"     name=\\\"saveCheckbox\\\"     ripple={false}     style=\\\"background-color: none;margin-left:-11px;\\\"     title={\\\"Check to save changes\\\"}    >",
		ctx
	});

	return block;
}

// (2952:0) <Dialog bind:visible={state.saveDialog} width="575" style="background-color:#fff; border-radius: 5px;">
function create_default_slot_7$3(ctx) {
	let center;
	let div0;
	let t1;
	let loader;
	let t2;
	let div1;
	let t3_value = (/*state*/ ctx[4].open_doc ? l$1.open_doc : "") + "";
	let t3;
	let t4;
	let h4;
	let t6;
	let t7_value = /*state*/ ctx[4].netMsg + "";
	let t7;
	let t8;
	let div2;
	let t9;
	let div5;
	let div3;
	let textarea;
	let t10;
	let checkbox;
	let updating_checked;
	let t11;
	let br;
	let t12;
	let div4;
	let b;
	let t13_value = "Current Stage: " + "";
	let t13;
	let span;
	let t14_value = editorConfig.stage(AH.get('stage')) + "";
	let t14;
	let span_class_value;
	let current;
	let mounted;
	let dispose;
	loader = new Loader({ props: { size: 50 }, $$inline: true });
	let if_block = /*state*/ ctx[4].course_list && create_if_block_7$2(ctx);

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[62](value);
	}

	let checkbox_props = {
		id: "saveCheckbox",
		value: "Save any unsaved changes",
		color: "primary",
		name: "saveCheckbox",
		ripple: false,
		style: "background-color: none;margin-left:-11px;",
		title: "Check to save changes",
		$$slots: { default: [create_default_slot_8$2] },
		$$scope: { ctx }
	};

	if (/*saveCheckbox*/ ctx[7] !== void 0) {
		checkbox_props.checked = /*saveCheckbox*/ ctx[7];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, 'checked', checkbox_checked_binding));

	const block = {
		c: function create() {
			center = element("center");
			div0 = element("div");
			div0.textContent = `${l$1.save_process}`;
			t1 = space();
			create_component(loader.$$.fragment);
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			h4 = element("h4");
			h4.textContent = `${"Confirmation"}`;
			t6 = space();
			t7 = text(t7_value);
			t8 = space();
			div2 = element("div");
			if (if_block) if_block.c();
			t9 = space();
			div5 = element("div");
			div3 = element("div");
			textarea = element("textarea");
			t10 = space();
			create_component(checkbox.$$.fragment);
			t11 = space();
			br = element("br");
			t12 = space();
			div4 = element("div");
			b = element("b");
			t13 = text(t13_value);
			span = element("span");
			t14 = text(t14_value);
			add_location(div0, file$q, 2953, 2, 112461);
			attr_dev(center, "id", "saveProcess");
			set_style(center, "display", "none");
			set_style(center, "width", "100%");
			set_style(center, "height", "120px");
			set_style(center, "padding-top", "40px");
			add_location(center, file$q, 2952, 1, 112362);
			add_location(h4, file$q, 2958, 2, 112596);
			attr_dev(div1, "id", "savingContent");
			add_location(div1, file$q, 2956, 1, 112527);
			attr_dev(div2, "id", "publishContent");
			attr_dev(div2, "class", "h");
			add_location(div2, file$q, 2961, 1, 112651);
			attr_dev(textarea, "name", "stage_comment");
			attr_dev(textarea, "rows", "3");
			attr_dev(textarea, "class", "form-controls");
			attr_dev(textarea, "id", "stage_comment");
			attr_dev(textarea, "placeholder", "Enter comments here.");
			set_style(textarea, "width", "100%");
			set_style(textarea, "resize", "none");
			add_location(textarea, file$q, 2986, 3, 113553);
			attr_dev(div3, "class", "stage_comment_box");
			add_location(div3, file$q, 2985, 2, 113517);
			add_location(br, file$q, 3007, 2, 114115);
			attr_dev(span, "class", span_class_value = AH.get('stage') > 2 ? "text-success" : "text-danger");
			add_location(span, file$q, 3009, 25, 114206);
			add_location(b, file$q, 3009, 3, 114184);
			attr_dev(div4, "class", "contentStage");
			set_style(div4, "margin-bottom", "-25px");
			add_location(div4, file$q, 3008, 2, 114124);
			attr_dev(div5, "class", "status_box");
			set_style(div5, "padding-bottom", "15px");
			add_location(div5, file$q, 2984, 1, 113459);
		},
		m: function mount(target, anchor) {
			insert_dev(target, center, anchor);
			append_dev(center, div0);
			append_dev(center, t1);
			mount_component(loader, center, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, t3);
			append_dev(div1, t4);
			append_dev(div1, h4);
			append_dev(div1, t6);
			append_dev(div1, t7);
			insert_dev(target, t8, anchor);
			insert_dev(target, div2, anchor);
			if (if_block) if_block.m(div2, null);
			insert_dev(target, t9, anchor);
			insert_dev(target, div5, anchor);
			append_dev(div5, div3);
			append_dev(div3, textarea);
			set_input_value(textarea, /*stageComment*/ ctx[5]);
			append_dev(div5, t10);
			mount_component(checkbox, div5, null);
			append_dev(div5, t11);
			append_dev(div5, br);
			append_dev(div5, t12);
			append_dev(div5, div4);
			append_dev(div4, b);
			append_dev(b, t13);
			append_dev(b, span);
			append_dev(span, t14);
			current = true;

			if (!mounted) {
				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[61]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*state*/ 16) && t3_value !== (t3_value = (/*state*/ ctx[4].open_doc ? l$1.open_doc : "") + "")) set_data_dev(t3, t3_value);
			if ((!current || dirty[0] & /*state*/ 16) && t7_value !== (t7_value = /*state*/ ctx[4].netMsg + "")) set_data_dev(t7, t7_value);

			if (/*state*/ ctx[4].course_list) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7$2(ctx);
					if_block.c();
					if_block.m(div2, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*stageComment*/ 32) {
				set_input_value(textarea, /*stageComment*/ ctx[5]);
			}

			const checkbox_changes = {};

			if (dirty[4] & /*$$scope*/ 2097152) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked && dirty[0] & /*saveCheckbox*/ 128) {
				updating_checked = true;
				checkbox_changes.checked = /*saveCheckbox*/ ctx[7];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(center);
			destroy_component(loader);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t8);
			if (detaching) detach_dev(div2);
			if (if_block) if_block.d();
			if (detaching) detach_dev(t9);
			if (detaching) detach_dev(div5);
			destroy_component(checkbox);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$3.name,
		type: "slot",
		source: "(2952:0) <Dialog bind:visible={state.saveDialog} width=\\\"575\\\" style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (3015:3) {#if item.permission}
function create_if_block_6$2(ctx) {
	let button;
	let current;

	function click_handler(...args) {
		return /*click_handler*/ ctx[60](/*item*/ ctx[3], ...args);
	}

	button = new Button({
			props: {
				id: /*item*/ ctx[3].type,
				style: "margin-right: 10px;",
				title: /*item*/ ctx[3].tooltip,
				color: /*item*/ ctx[3].func ? "primary" : "#ccc",
				unelevated: true,
				outlined: true,
				$$slots: { default: [create_default_slot_6$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", click_handler);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};

			if (dirty[4] & /*$$scope*/ 2097152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$2.name,
		type: "if",
		source: "(3015:3) {#if item.permission}",
		ctx
	});

	return block;
}

// (3016:4) <Button       id={item.type}       style="margin-right: 10px;"       title={item.tooltip}       color={item.func  ? "primary" : "#ccc"}       unelevated={true}                outlined={true}       on:click={(event)=> item.func ? saveAction(event, 'save', item.type) : saveAction(event, "cancel", item.type)}      >
function create_default_slot_6$3(ctx) {
	let t0_value = /*item*/ ctx[3].label + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$3.name,
		type: "slot",
		source: "(3016:4) <Button       id={item.type}       style=\\\"margin-right: 10px;\\\"       title={item.tooltip}       color={item.func  ? \\\"primary\\\" : \\\"#ccc\\\"}       unelevated={true}                outlined={true}       on:click={(event)=> item.func ? saveAction(event, 'save', item.type) : saveAction(event, \\\"cancel\\\", item.type)}      >",
		ctx
	});

	return block;
}

// (3014:2) {#each editorConfig.status() as item }
function create_each_block$6(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*item*/ ctx[3].permission && create_if_block_6$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*item*/ ctx[3].permission) if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(3014:2) {#each editorConfig.status() as item }",
		ctx
	});

	return block;
}

// (3013:1) 
function create_footer_slot_1$2(ctx) {
	let div;
	let div_key_value;
	let current;
	let each_value = editorConfig.status();
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "save_buttons svelteFooter");
			attr_dev(div, "key", div_key_value = "actionSaveEditor");
			attr_dev(div, "slot", "footer");
			add_location(div, file$q, 3012, 1, 114344);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[1] & /*saveAction*/ 8) {
				each_value = editorConfig.status();
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot_1$2.name,
		type: "slot",
		source: "(3013:1) ",
		ctx
	});

	return block;
}

// (3031:0) <Dialog bind:visible={state.activator} style="background-color:#fff; border-radius: 5px;">
function create_default_slot_5$3(ctx) {
	let div;
	let loader;
	let current;

	loader = new Loader({
			props: {
				size: 50,
				msg: "Please wait editor is working."
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			attr_dev(div, "class", "editor_modal_content overflow-hidden");
			add_location(div, file$q, 3031, 1, 114981);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$3.name,
		type: "slot",
		source: "(3031:0) <Dialog bind:visible={state.activator} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (3037:0) <Dialog width="700" bind:visible={state.xmlDialog} style="background-color:#fff; border-radius: 5px;">
function create_default_slot_4$3(ctx) {
	let h4;
	let div1;
	let div0;
	let t1;
	let button;
	let t2;
	let div2;
	let textarea;
	let textarea_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			h4 = element("h4");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = `${l$1.xml}`;
			t1 = space();
			button = element("button");
			t2 = space();
			div2 = element("div");
			textarea = element("textarea");
			add_location(div0, file$q, 3039, 3, 115323);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "icomoon-incorrect-sm xml_smbtn");
			set_style(button, "float", "right");
			set_style(button, "cursor", "pointer");
			add_location(button, file$q, 3040, 3, 115346);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file$q, 3038, 2, 115274);
			attr_dev(h4, "class", "mt-0 font21");
			add_location(h4, file$q, 3037, 1, 115246);
			attr_dev(textarea, "class", "font15");
			attr_dev(textarea, "id", "xml_Dialog");
			set_style(textarea, "width", "100%");
			set_style(textarea, "margin", "3px 0");
			set_style(textarea, "min-height", (window.in_frame == 1 ? '200' : '340') + "px");
			set_style(textarea, "border", "0px");
			set_style(textarea, "resize", "none");
			set_style(textarea, "outline", "none");
			set_style(textarea, "box-shadow", "none");
			set_style(textarea, "background-color", "transparent");
			textarea.value = textarea_value_value = /*formatXmlRef*/ ctx[21](/*state*/ ctx[4].xml, /*state*/ ctx[4].item);
			add_location(textarea, file$q, 3044, 2, 115526);
			add_location(div2, file$q, 3043, 1, 115517);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, div1);
			append_dev(div1, div0);
			append_dev(div1, t1);
			append_dev(div1, button);
			insert_dev(target, t2, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, textarea);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[66], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && textarea_value_value !== (textarea_value_value = /*formatXmlRef*/ ctx[21](/*state*/ ctx[4].xml, /*state*/ ctx[4].item))) {
				prop_dev(textarea, "value", textarea_value_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div2);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$3.name,
		type: "slot",
		source: "(3037:0) <Dialog width=\\\"700\\\" bind:visible={state.xmlDialog} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (3061:2) <Button     unelevated={true}              outlined={true}     on:click={() => state.xmlDialog = false}     color="#ccc"    >
function create_default_slot_3$4(ctx) {
	let t_value = l$1.cancel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$4.name,
		type: "slot",
		source: "(3061:2) <Button     unelevated={true}              outlined={true}     on:click={() => state.xmlDialog = false}     color=\\\"#ccc\\\"    >",
		ctx
	});

	return block;
}

// (3069:2) <Button     id="xmlDone"     unelevated={true}              outlined={true}     on:click={updateXml}     color="primary"    >
function create_default_slot_2$7(ctx) {
	let t_value = l$1.done + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$7.name,
		type: "slot",
		source: "(3069:2) <Button     id=\\\"xmlDone\\\"     unelevated={true}              outlined={true}     on:click={updateXml}     color=\\\"primary\\\"    >",
		ctx
	});

	return block;
}

// (3060:1) 
function create_footer_slot$6(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				unelevated: true,
				outlined: true,
				color: "#ccc",
				$$slots: { default: [create_default_slot_3$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler_1*/ ctx[65]);

	button1 = new Button({
			props: {
				id: "xmlDone",
				unelevated: true,
				outlined: true,
				color: "primary",
				$$slots: { default: [create_default_slot_2$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*updateXml*/ ctx[28]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file$q, 3059, 1, 115870);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[4] & /*$$scope*/ 2097152) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[4] & /*$$scope*/ 2097152) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot$6.name,
		type: "slot",
		source: "(3060:1) ",
		ctx
	});

	return block;
}

// (3083:1) {:else}
function create_else_block$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Some Error occured during this process.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(3083:1) {:else}",
		ctx
	});

	return block;
}

// (3081:1) {#if state.message}
function create_if_block_5$3(ctx) {
	let t_value = /*state*/ ctx[4].message + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 16 && t_value !== (t_value = /*state*/ ctx[4].message + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$3.name,
		type: "if",
		source: "(3081:1) {#if state.message}",
		ctx
	});

	return block;
}

// (3080:0) <Snackbar bind:visible={state.snackback} bg="#333" bottom={true}  timeout={10} style="position:fixed; bottom:50px">
function create_default_slot_1$8(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*state*/ ctx[4].message) return create_if_block_5$3;
		return create_else_block$7;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$8.name,
		type: "slot",
		source: "(3080:0) <Snackbar bind:visible={state.snackback} bg=\\\"#333\\\" bottom={true}  timeout={10} style=\\\"position:fixed; bottom:50px\\\">",
		ctx
	});

	return block;
}

// (3087:2) <Button color="#ff0" class="fs-3 pb-1" on:click={() => (state.snackback = false)}>
function create_default_slot$a(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("×");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(3087:2) <Button color=\\\"#ff0\\\" class=\\\"fs-3 pb-1\\\" on:click={() => (state.snackback = false)}>",
		ctx
	});

	return block;
}

// (3086:1) 
function create_action_slot(ctx) {
	let span;
	let button;
	let current;

	button = new Button({
			props: {
				color: "#ff0",
				class: "fs-3 pb-1",
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler_3*/ ctx[68]);

	const block = {
		c: function create() {
			span = element("span");
			create_component(button.$$.fragment);
			attr_dev(span, "slot", "action");
			add_location(span, file$q, 3085, 1, 116465);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(button, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[4] & /*$$scope*/ 2097152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_action_slot.name,
		type: "slot",
		source: "(3086:1) ",
		ctx
	});

	return block;
}

// (3090:0) {#if (window.is_domain && state.viewConfig.domain)}
function create_if_block_4$3(ctx) {
	let domain;
	let updating_editorState;
	let current;

	function domain_editorState_binding(value) {
		/*domain_editorState_binding*/ ctx[73](value);
	}

	let domain_props = {
		selectedObjective: /*selectedObjective*/ ctx[35],
		setCourse: /*func_1*/ ctx[70],
		saveDomain: /*saveDomain*/ ctx[36],
		domainToggle: /*state*/ ctx[4].domainToggle,
		isNew: /*state*/ ctx[4].is_new,
		closeDomainDialog: /*exam_objective_mapping_state*/ ctx[38],
		selectedDomain: /*onDomainSelect*/ ctx[37],
		selectedCoverage: /*func_2*/ ctx[71],
		selectedTest: /*func_3*/ ctx[72],
		guid: /*state*/ ctx[4].guid,
		smdata: /*state*/ ctx[4],
		caseid_val: /*state*/ ctx[4].caseid_val,
		updateModule: /*updateModuleState*/ ctx[17]
	};

	if (/*state*/ ctx[4] !== void 0) {
		domain_props.editorState = /*state*/ ctx[4];
	}

	domain = new Domain({ props: domain_props, $$inline: true });
	binding_callbacks.push(() => bind(domain, 'editorState', domain_editorState_binding));

	const block = {
		c: function create() {
			create_component(domain.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(domain, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const domain_changes = {};
			if (dirty[0] & /*state*/ 16) domain_changes.setCourse = /*func_1*/ ctx[70];
			if (dirty[0] & /*state*/ 16) domain_changes.domainToggle = /*state*/ ctx[4].domainToggle;
			if (dirty[0] & /*state*/ 16) domain_changes.isNew = /*state*/ ctx[4].is_new;
			if (dirty[0] & /*state*/ 16) domain_changes.selectedCoverage = /*func_2*/ ctx[71];
			if (dirty[0] & /*state*/ 16) domain_changes.selectedTest = /*func_3*/ ctx[72];
			if (dirty[0] & /*state*/ 16) domain_changes.guid = /*state*/ ctx[4].guid;
			if (dirty[0] & /*state*/ 16) domain_changes.smdata = /*state*/ ctx[4];
			if (dirty[0] & /*state*/ 16) domain_changes.caseid_val = /*state*/ ctx[4].caseid_val;

			if (!updating_editorState && dirty[0] & /*state*/ 16) {
				updating_editorState = true;
				domain_changes.editorState = /*state*/ ctx[4];
				add_flush_callback(() => updating_editorState = false);
			}

			domain.$set(domain_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(domain.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(domain.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(domain, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$3.name,
		type: "if",
		source: "(3090:0) {#if (window.is_domain && state.viewConfig.domain)}",
		ctx
	});

	return block;
}

// (3108:0) {#if (window.content_for_newEditor)}
function create_if_block_3$4(ctx) {
	let versioncontrol;
	let current;

	versioncontrol = new VersionControl({
			props: {
				versionToggle: /*state*/ ctx[4].versionToggle,
				closeVersionDialog: /*versionControl*/ ctx[15],
				guid: /*state*/ ctx[4].guid,
				l: l$1
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(versioncontrol.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(versioncontrol, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const versioncontrol_changes = {};
			if (dirty[0] & /*state*/ 16) versioncontrol_changes.versionToggle = /*state*/ ctx[4].versionToggle;
			if (dirty[0] & /*state*/ 16) versioncontrol_changes.guid = /*state*/ ctx[4].guid;
			versioncontrol.$set(versioncontrol_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(versioncontrol.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(versioncontrol.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(versioncontrol, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$4.name,
		type: "if",
		source: "(3108:0) {#if (window.content_for_newEditor)}",
		ctx
	});

	return block;
}

// (3116:0) {#if state.viewConfig.webPageList}
function create_if_block_2$6(ctx) {
	let webpagelist;
	let updating_editorState;
	let current;

	function webpagelist_editorState_binding(value) {
		/*webpagelist_editorState_binding*/ ctx[74](value);
	}

	let webpagelist_props = {
		domainToggle: /*state*/ ctx[4].domainToggle,
		selectedDomain: /*onDomainSelect*/ ctx[37]
	};

	if (/*state*/ ctx[4] !== void 0) {
		webpagelist_props.editorState = /*state*/ ctx[4];
	}

	webpagelist = new WebpageList({ props: webpagelist_props, $$inline: true });
	binding_callbacks.push(() => bind(webpagelist, 'editorState', webpagelist_editorState_binding));

	const block = {
		c: function create() {
			create_component(webpagelist.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(webpagelist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const webpagelist_changes = {};
			if (dirty[0] & /*state*/ 16) webpagelist_changes.domainToggle = /*state*/ ctx[4].domainToggle;

			if (!updating_editorState && dirty[0] & /*state*/ 16) {
				updating_editorState = true;
				webpagelist_changes.editorState = /*state*/ ctx[4];
				add_flush_callback(() => updating_editorState = false);
			}

			webpagelist.$set(webpagelist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(webpagelist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(webpagelist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(webpagelist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$6.name,
		type: "if",
		source: "(3116:0) {#if state.viewConfig.webPageList}",
		ctx
	});

	return block;
}

// (3134:0) {#if state.guid && window.from_myproject == 1}
function create_if_block_1$7(ctx) {
	let commentmodal;
	let current;

	let commentmodal_props = {
		user_guid: /*_user*/ ctx[1].user_guid,
		user: /*_user*/ ctx[1],
		questionGuid: /*state*/ ctx[4].guid,
		l: l$1
	};

	commentmodal = new CommentModal({
			props: commentmodal_props,
			$$inline: true
		});

	/*commentmodal_binding*/ ctx[77](commentmodal);

	const block = {
		c: function create() {
			create_component(commentmodal.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(commentmodal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const commentmodal_changes = {};
			if (dirty[0] & /*_user*/ 2) commentmodal_changes.user_guid = /*_user*/ ctx[1].user_guid;
			if (dirty[0] & /*_user*/ 2) commentmodal_changes.user = /*_user*/ ctx[1];
			if (dirty[0] & /*state*/ 16) commentmodal_changes.questionGuid = /*state*/ ctx[4].guid;
			commentmodal.$set(commentmodal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(commentmodal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(commentmodal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*commentmodal_binding*/ ctx[77](null);
			destroy_component(commentmodal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(3134:0) {#if state.guid && window.from_myproject == 1}",
		ctx
	});

	return block;
}

// (3155:0) {#if state?.AnalyzeEbookMenu}
function create_if_block$k(ctx) {
	let analyzeebook;
	let current;

	analyzeebook = new AnalyzeEbook({
			props: {
				analyzeEbookMenu: /*state*/ ctx[4].AnalyzeEbookMenu,
				oldStemData: /*state*/ ctx[4].oldStemData,
				controls: editorConfig.controls,
				addItemButton: editorConfig.add_item_button,
				changeAnalyzeMenuProp: /*func_4*/ ctx[79]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(analyzeebook.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(analyzeebook, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const analyzeebook_changes = {};
			if (dirty[0] & /*state*/ 16) analyzeebook_changes.analyzeEbookMenu = /*state*/ ctx[4].AnalyzeEbookMenu;
			if (dirty[0] & /*state*/ 16) analyzeebook_changes.oldStemData = /*state*/ ctx[4].oldStemData;
			if (dirty[0] & /*state*/ 16) analyzeebook_changes.changeAnalyzeMenuProp = /*func_4*/ ctx[79];
			analyzeebook.$set(analyzeebook_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(analyzeebook.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(analyzeebook.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(analyzeebook, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$k.name,
		type: "if",
		source: "(3155:0) {#if state?.AnalyzeEbookMenu}",
		ctx
	});

	return block;
}

function create_fragment$r(ctx) {
	let main;
	let editorheader;
	let updating_editorState;
	let t0;
	let div14;
	let ul;
	let li0;
	let a0;
	let t2;
	let li1;
	let a1;
	let t3_value = "Preview" + "";
	let t3;
	let a1_href_value;
	let t4;
	let div13;
	let div3;
	let div0;
	let t5;
	let div2;
	let div1;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let br0;
	let t11;
	let br1;
	let t12;
	let div12;
	let div11;
	let div10;
	let div9;
	let div8;
	let div6;
	let div4;
	let t13;
	let div5;
	let t14;
	let div7;
	let t15;
	let t16;
	let t17;
	let t18;
	let div8_annotation_id_value;
	let div8_data_parent_guid_value;
	let t19;
	let br2;
	let t20;
	let br3;
	let div12_is_editor_value;
	let t21;
	let t22;
	let editormodal;
	let updating_modal;
	let updating_visible;
	let t23;
	let dialog0;
	let updating_visible_1;
	let t24;
	let dialog1;
	let updating_visible_2;
	let t25;
	let dialog2;
	let updating_visible_3;
	let t26;
	let snackbar;
	let updating_visible_4;
	let t27;
	let t28;
	let t29;
	let t30;
	let createvariable;
	let updating_editorState_1;
	let t31;
	let t32;
	let media;
	let t33;
	let t34;
	let interactiveitem;
	let t35;
	let editorpopovermodal;
	let t36;
	let peglossarycontentlink;
	let current;
	let mounted;
	let dispose;

	function editorheader_editorState_binding(value) {
		/*editorheader_editorState_binding*/ ctx[50](value);
	}

	let editorheader_props = {
		updateEditorModule: /*updateModuleState*/ ctx[17],
		handleModal: /*handleModal*/ ctx[18],
		toolMenu: editorConfig.createToolMenu(/*state*/ ctx[4], l$1),
		solveVariable: /*solveVariable*/ ctx[29],
		analyzeVariable: /*analyzeVariable*/ ctx[30],
		handleCheckbox: /*handleCheckbox*/ ctx[31],
		editAlgo: /*editAlgo*/ ctx[32],
		itemHelper: /*Items*/ ctx[11],
		toggleRemediation: /*toggleRemediation*/ ctx[40],
		l: l$1
	};

	if (/*state*/ ctx[4] !== void 0) {
		editorheader_props.editorState = /*state*/ ctx[4];
	}

	editorheader = new EditorHeader({
			props: editorheader_props,
			$$inline: true
		});

	/*editorheader_binding*/ ctx[49](editorheader);
	binding_callbacks.push(() => bind(editorheader, 'editorState', editorheader_editorState_binding));
	let if_block0 = /*state*/ ctx[4].viewConfig.title && create_if_block_21$1(ctx);
	let if_block1 = /*state*/ ctx[4].viewConfig.stem && create_if_block_19$1(ctx);
	let if_block2 = /*state*/ ctx[4].viewConfig.content && create_if_block_17$1(ctx);
	let if_block3 = /*state*/ ctx[4].viewConfig.itemModule && create_if_block_16$1(ctx);
	let if_block4 = /*state*/ ctx[4].viewConfig.remediation && create_if_block_14$1(ctx);
	let if_block5 = /*state*/ ctx[4].viewConfig.title && create_if_block_13$1(ctx);
	let if_block6 = /*state*/ ctx[4].viewConfig.stem && create_if_block_12$1(ctx);
	let if_block7 = /*state*/ ctx[4].viewConfig.content && create_if_block_11$1(ctx);
	let if_block8 = /*state*/ ctx[4].viewConfig.itemModule && create_if_block_10$2(ctx);
	let if_block9 = /*state*/ ctx[4].viewConfig.remediation && create_if_block_9$2(ctx);
	let if_block10 = /*state*/ ctx[4].playerState && create_if_block_8$2(ctx);

	function editormodal_modal_binding(value) {
		/*editormodal_modal_binding*/ ctx[58](value);
	}

	function editormodal_visible_binding(value) {
		/*editormodal_visible_binding*/ ctx[59](value);
	}

	let editormodal_props = {
		updateEditorModule: /*updateModuleState*/ ctx[17]
	};

	if (/*modal*/ ctx[10] !== void 0) {
		editormodal_props.modal = /*modal*/ ctx[10];
	}

	if (/*modalVisible*/ ctx[9] !== void 0) {
		editormodal_props.visible = /*modalVisible*/ ctx[9];
	}

	editormodal = new EditorModal({ props: editormodal_props, $$inline: true });
	binding_callbacks.push(() => bind(editormodal, 'modal', editormodal_modal_binding));
	binding_callbacks.push(() => bind(editormodal, 'visible', editormodal_visible_binding));

	function dialog0_visible_binding(value) {
		/*dialog0_visible_binding*/ ctx[63](value);
	}

	let dialog0_props = {
		width: "575",
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot_1$2],
			default: [create_default_slot_7$3]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].saveDialog !== void 0) {
		dialog0_props.visible = /*state*/ ctx[4].saveDialog;
	}

	dialog0 = new Dialog({ props: dialog0_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog0, 'visible', dialog0_visible_binding));

	function dialog1_visible_binding(value) {
		/*dialog1_visible_binding*/ ctx[64](value);
	}

	let dialog1_props = {
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: { default: [create_default_slot_5$3] },
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].activator !== void 0) {
		dialog1_props.visible = /*state*/ ctx[4].activator;
	}

	dialog1 = new Dialog({ props: dialog1_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog1, 'visible', dialog1_visible_binding));

	function dialog2_visible_binding(value) {
		/*dialog2_visible_binding*/ ctx[67](value);
	}

	let dialog2_props = {
		width: "700",
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot$6],
			default: [create_default_slot_4$3]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].xmlDialog !== void 0) {
		dialog2_props.visible = /*state*/ ctx[4].xmlDialog;
	}

	dialog2 = new Dialog({ props: dialog2_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog2, 'visible', dialog2_visible_binding));

	function snackbar_visible_binding(value) {
		/*snackbar_visible_binding*/ ctx[69](value);
	}

	let snackbar_props = {
		bg: "#333",
		bottom: true,
		timeout: 10,
		style: "position:fixed; bottom:50px",
		$$slots: {
			action: [create_action_slot],
			default: [create_default_slot_1$8]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[4].snackback !== void 0) {
		snackbar_props.visible = /*state*/ ctx[4].snackback;
	}

	snackbar = new Snackbar({ props: snackbar_props, $$inline: true });
	binding_callbacks.push(() => bind(snackbar, 'visible', snackbar_visible_binding));
	let if_block11 = window.is_domain && /*state*/ ctx[4].viewConfig.domain && create_if_block_4$3(ctx);
	let if_block12 = window.content_for_newEditor && create_if_block_3$4(ctx);
	let if_block13 = /*state*/ ctx[4].viewConfig.webPageList && create_if_block_2$6(ctx);

	function createvariable_editorState_binding(value) {
		/*createvariable_editorState_binding*/ ctx[75](value);
	}

	let createvariable_props = {
		handleAlgoState: /*handleCheckbox*/ ctx[31],
		algo_qxml: /*state*/ ctx[4].algo_qxml,
		labelview: "none",
		view: /*state*/ ctx[4].variable_button,
		single_variables: /*state*/ ctx[4].single_variables,
		l: l$1
	};

	if (/*state*/ ctx[4] !== void 0) {
		createvariable_props.editorState = /*state*/ ctx[4];
	}

	createvariable = new CreateVariable({
			props: createvariable_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(createvariable, 'editorState', createvariable_editorState_binding));
	/*createvariable_binding*/ ctx[76](createvariable);
	let if_block14 = /*state*/ ctx[4].guid && window.from_myproject == 1 && create_if_block_1$7(ctx);

	let media_props = {
		default_media_configuration: {
			file_type: 'image/*',
			file_ext: 'png,gif,jpg,jpeg,svg',
			max_file_allowed: 1,
			set_name: true,
			is_editor: 1,
			image_annotation: 1
		}
	};

	media = new Media({ props: media_props, $$inline: true });
	/*media_binding*/ ctx[78](media);
	let if_block15 = /*state*/ ctx[4]?.AnalyzeEbookMenu && create_if_block$k(ctx);
	let interactiveitem_props = {};

	interactiveitem = new InteractiveItem({
			props: interactiveitem_props,
			$$inline: true
		});

	/*interactiveitem_binding*/ ctx[80](interactiveitem);
	editorpopovermodal = new EditorPopoverModal({ $$inline: true });
	peglossarycontentlink = new PeGlossaryContentLink({ $$inline: true });

	const block = {
		c: function create() {
			main = element("main");
			create_component(editorheader.$$.fragment);
			t0 = space();
			div14 = element("div");
			ul = element("ul");
			li0 = element("li");
			a0 = element("a");
			a0.textContent = `${"Authoring"}`;
			t2 = space();
			li1 = element("li");
			a1 = element("a");
			t3 = text(t3_value);
			t4 = space();
			div13 = element("div");
			div3 = element("div");
			div0 = element("div");
			t5 = space();
			div2 = element("div");
			div1 = element("div");
			if (if_block0) if_block0.c();
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			if (if_block2) if_block2.c();
			t8 = space();
			if (if_block3) if_block3.c();
			t9 = space();
			if (if_block4) if_block4.c();
			t10 = space();
			br0 = element("br");
			t11 = space();
			br1 = element("br");
			t12 = space();
			div12 = element("div");
			div11 = element("div");
			div10 = element("div");
			div9 = element("div");
			div8 = element("div");
			div6 = element("div");
			div4 = element("div");
			t13 = space();
			div5 = element("div");
			t14 = space();
			div7 = element("div");
			if (if_block5) if_block5.c();
			t15 = space();
			if (if_block6) if_block6.c();
			t16 = space();
			if (if_block7) if_block7.c();
			t17 = space();
			if (if_block8) if_block8.c();
			t18 = space();
			if (if_block9) if_block9.c();
			t19 = space();
			br2 = element("br");
			t20 = space();
			br3 = element("br");
			t21 = space();
			if (if_block10) if_block10.c();
			t22 = space();
			create_component(editormodal.$$.fragment);
			t23 = space();
			create_component(dialog0.$$.fragment);
			t24 = space();
			create_component(dialog1.$$.fragment);
			t25 = space();
			create_component(dialog2.$$.fragment);
			t26 = space();
			create_component(snackbar.$$.fragment);
			t27 = space();
			if (if_block11) if_block11.c();
			t28 = space();
			if (if_block12) if_block12.c();
			t29 = space();
			if (if_block13) if_block13.c();
			t30 = space();
			create_component(createvariable.$$.fragment);
			t31 = space();
			if (if_block14) if_block14.c();
			t32 = space();
			create_component(media.$$.fragment);
			t33 = space();
			if (if_block15) if_block15.c();
			t34 = space();
			create_component(interactiveitem.$$.fragment);
			t35 = space();
			create_component(editorpopovermodal.$$.fragment);
			t36 = space();
			create_component(peglossarycontentlink.$$.fragment);
			attr_dev(a0, "data-bs-toggle", "tab");
			attr_dev(a0, "href", "#authoringDiv");
			attr_dev(a0, "class", "active");
			add_location(a0, file$q, 2720, 16, 103465);
			add_location(li0, file$q, 2720, 12, 103461);
			attr_dev(a1, "data-bs-toggle", "tab");

			attr_dev(a1, "href", a1_href_value = /*state*/ ctx[4].viewConfig.isFullMode
			? "#fullMode_custom_columnize"
			: "#custom_columnize");

			add_location(a1, file$q, 2721, 16, 103565);
			add_location(li1, file$q, 2721, 12, 103561);
			attr_dev(ul, "class", "nav nav-tabs editorTabs");
			attr_dev(ul, "id", "edi_tabs");
			add_location(ul, file$q, 2719, 8, 103397);
			attr_dev(div0, "id", "overlayAuthoring");
			set_style(div0, "position", "absolute");
			set_style(div0, "width", "0");
			add_location(div0, file$q, 2736, 16, 104246);
			attr_dev(div1, "id", "columnize");
			add_location(div1, file$q, 2738, 20, 104403);
			attr_dev(div2, "id", "authoringSection");
			attr_dev(div2, "class", "ignoreMath");
			add_location(div2, file$q, 2737, 16, 104335);
			add_location(br0, file$q, 2846, 16, 108628);
			add_location(br1, file$q, 2847, 16, 108651);
			attr_dev(div3, "id", "authoringDiv");
			attr_dev(div3, "class", "tab-pane fade in active");
			set_style(div3, "margin-bottom", "5px");
			set_style(div3, "width", (/*state*/ ctx[4].verticalView == true ? '100' : '50') + "%");
			set_style(div3, "float", "left");

			set_style(div3, "position", /*state*/ ctx[4].verticalView == true
			? "relative"
			: "absolute");

			set_style(div3, "left", "0px");
			set_style(div3, "top", "0px");
			add_location(div3, file$q, 2724, 12, 103778);
			attr_dev(div4, "id", "todo_table");
			add_location(div4, file$q, 2874, 36, 109823);
			attr_dev(div5, "id", "todo_obj");
			add_location(div5, file$q, 2875, 36, 109888);
			attr_dev(div6, "id", "todo_preview");
			set_style(div6, "display", "none");
			add_location(div6, file$q, 2873, 32, 109739);
			attr_dev(div7, "id", "layoutMode");
			add_location(div7, file$q, 2877, 8, 109939);
			attr_dev(div8, "id", "previewSection");
			attr_dev(div8, "class", "px-2 base");
			attr_dev(div8, "annotation_id", div8_annotation_id_value = /*state*/ ctx[4].guid);
			attr_dev(div8, "data-parent-guid", div8_data_parent_guid_value = /*state*/ ctx[4].guid);
			set_style(div8, "overflow-X", "auto");
			set_style(div8, "padding-bottom", "15px");
			add_location(div8, file$q, 2866, 28, 109359);
			add_location(br2, file$q, 2925, 28, 111680);
			add_location(br3, file$q, 2926, 28, 111716);
			attr_dev(div9, "id", "columnize");
			add_location(div9, file$q, 2865, 24, 109309);
			attr_dev(div10, "id", "ebook_container");
			add_location(div10, file$q, 2864, 20, 109257);
			attr_dev(div11, "id", "preview");
			set_style(div11, "width", /*state*/ ctx[4].verticalView == true ? '100%' : '50%');
			set_style(div11, "float", "right");

			set_style(div11, "position", /*state*/ ctx[4].verticalView == true
			? 'relative'
			: 'absolute');

			set_style(div11, "right", "0px");
			set_style(div11, "top", "0px");
			add_location(div11, file$q, 2854, 16, 108841);
			attr_dev(div12, "id", "custom_columnize");
			attr_dev(div12, "class", "tab-pane fade");
			attr_dev(div12, "is_editor", div12_is_editor_value = 1);
			add_location(div12, file$q, 2849, 12, 108690);
			attr_dev(div13, "class", "tab-content editorTabContent");
			add_location(div13, file$q, 2723, 8, 103722);
			attr_dev(div14, "id", "editorViewPane");
			attr_dev(div14, "class", "col-lg-11 mx-auto");
			attr_dev(div14, "key", "1");
			attr_dev(div14, "tabindex", "0");
			add_location(div14, file$q, 2713, 4, 103278);
			attr_dev(main, "role", "main");
			attr_dev(main, "tabindex", "0");
			add_location(main, file$q, 2698, 0, 102838);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(editorheader, main, null);
			append_dev(main, t0);
			append_dev(main, div14);
			append_dev(div14, ul);
			append_dev(ul, li0);
			append_dev(li0, a0);
			append_dev(ul, t2);
			append_dev(ul, li1);
			append_dev(li1, a1);
			append_dev(a1, t3);
			append_dev(div14, t4);
			append_dev(div14, div13);
			append_dev(div13, div3);
			append_dev(div3, div0);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t7);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t8);
			if (if_block3) if_block3.m(div1, null);
			append_dev(div1, t9);
			if (if_block4) if_block4.m(div1, null);
			append_dev(div3, t10);
			append_dev(div3, br0);
			append_dev(div3, t11);
			append_dev(div3, br1);
			append_dev(div13, t12);
			append_dev(div13, div12);
			append_dev(div12, div11);
			append_dev(div11, div10);
			append_dev(div10, div9);
			append_dev(div9, div8);
			append_dev(div8, div6);
			append_dev(div6, div4);
			append_dev(div6, t13);
			append_dev(div6, div5);
			append_dev(div8, t14);
			append_dev(div8, div7);
			if (if_block5) if_block5.m(div7, null);
			append_dev(div7, t15);
			if (if_block6) if_block6.m(div7, null);
			append_dev(div7, t16);
			if (if_block7) if_block7.m(div7, null);
			append_dev(div7, t17);
			if (if_block8) if_block8.m(div7, null);
			append_dev(div7, t18);
			if (if_block9) if_block9.m(div7, null);
			append_dev(div9, t19);
			append_dev(div9, br2);
			append_dev(div9, t20);
			append_dev(div9, br3);
			insert_dev(target, t21, anchor);
			if (if_block10) if_block10.m(target, anchor);
			insert_dev(target, t22, anchor);
			mount_component(editormodal, target, anchor);
			insert_dev(target, t23, anchor);
			mount_component(dialog0, target, anchor);
			insert_dev(target, t24, anchor);
			mount_component(dialog1, target, anchor);
			insert_dev(target, t25, anchor);
			mount_component(dialog2, target, anchor);
			insert_dev(target, t26, anchor);
			mount_component(snackbar, target, anchor);
			insert_dev(target, t27, anchor);
			if (if_block11) if_block11.m(target, anchor);
			insert_dev(target, t28, anchor);
			if (if_block12) if_block12.m(target, anchor);
			insert_dev(target, t29, anchor);
			if (if_block13) if_block13.m(target, anchor);
			insert_dev(target, t30, anchor);
			mount_component(createvariable, target, anchor);
			insert_dev(target, t31, anchor);
			if (if_block14) if_block14.m(target, anchor);
			insert_dev(target, t32, anchor);
			mount_component(media, target, anchor);
			insert_dev(target, t33, anchor);
			if (if_block15) if_block15.m(target, anchor);
			insert_dev(target, t34, anchor);
			mount_component(interactiveitem, target, anchor);
			insert_dev(target, t35, anchor);
			mount_component(editorpopovermodal, target, anchor);
			insert_dev(target, t36, anchor);
			mount_component(peglossarycontentlink, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window_1$3, "keyup", /*handleKeyup*/ ctx[23], false, false, false),
					listen_dev(window_1$3, "keydown", /*handleKeydown*/ ctx[22], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const editorheader_changes = {};
			if (dirty[0] & /*state*/ 16) editorheader_changes.toolMenu = editorConfig.createToolMenu(/*state*/ ctx[4], l$1);
			if (dirty[0] & /*Items*/ 2048) editorheader_changes.itemHelper = /*Items*/ ctx[11];

			if (!updating_editorState && dirty[0] & /*state*/ 16) {
				updating_editorState = true;
				editorheader_changes.editorState = /*state*/ ctx[4];
				add_flush_callback(() => updating_editorState = false);
			}

			editorheader.$set(editorheader_changes);

			if (!current || dirty[0] & /*state*/ 16 && a1_href_value !== (a1_href_value = /*state*/ ctx[4].viewConfig.isFullMode
			? "#fullMode_custom_columnize"
			: "#custom_columnize")) {
				attr_dev(a1, "href", a1_href_value);
			}

			if (/*state*/ ctx[4].viewConfig.title) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_21$1(ctx);
					if_block0.c();
					if_block0.m(div1, t6);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*state*/ ctx[4].viewConfig.stem) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_19$1(ctx);
					if_block1.c();
					if_block1.m(div1, t7);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*state*/ ctx[4].viewConfig.content) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_17$1(ctx);
					if_block2.c();
					if_block2.m(div1, t8);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*state*/ ctx[4].viewConfig.itemModule) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*state*/ 16) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_16$1(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, t9);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[4].viewConfig.remediation) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_14$1(ctx);
					if_block4.c();
					if_block4.m(div1, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (!current || dirty[0] & /*state*/ 16) {
				set_style(div3, "width", (/*state*/ ctx[4].verticalView == true ? '100' : '50') + "%");
			}

			if (!current || dirty[0] & /*state*/ 16) {
				set_style(div3, "position", /*state*/ ctx[4].verticalView == true
				? "relative"
				: "absolute");
			}

			if (/*state*/ ctx[4].viewConfig.title) {
				if (if_block5) ; else {
					if_block5 = create_if_block_13$1(ctx);
					if_block5.c();
					if_block5.m(div7, t15);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*state*/ ctx[4].viewConfig.stem) {
				if (if_block6) ; else {
					if_block6 = create_if_block_12$1(ctx);
					if_block6.c();
					if_block6.m(div7, t16);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*state*/ ctx[4].viewConfig.content) {
				if (if_block7) ; else {
					if_block7 = create_if_block_11$1(ctx);
					if_block7.c();
					if_block7.m(div7, t17);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (/*state*/ ctx[4].viewConfig.itemModule) {
				if (if_block8) {
					if_block8.p(ctx, dirty);

					if (dirty[0] & /*state*/ 16) {
						transition_in(if_block8, 1);
					}
				} else {
					if_block8 = create_if_block_10$2(ctx);
					if_block8.c();
					transition_in(if_block8, 1);
					if_block8.m(div7, t18);
				}
			} else if (if_block8) {
				group_outros();

				transition_out(if_block8, 1, 1, () => {
					if_block8 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[4].viewConfig.remediation) {
				if (if_block9) ; else {
					if_block9 = create_if_block_9$2(ctx);
					if_block9.c();
					if_block9.m(div7, null);
				}
			} else if (if_block9) {
				if_block9.d(1);
				if_block9 = null;
			}

			if (!current || dirty[0] & /*state*/ 16 && div8_annotation_id_value !== (div8_annotation_id_value = /*state*/ ctx[4].guid)) {
				attr_dev(div8, "annotation_id", div8_annotation_id_value);
			}

			if (!current || dirty[0] & /*state*/ 16 && div8_data_parent_guid_value !== (div8_data_parent_guid_value = /*state*/ ctx[4].guid)) {
				attr_dev(div8, "data-parent-guid", div8_data_parent_guid_value);
			}

			if (!current || dirty[0] & /*state*/ 16) {
				set_style(div11, "width", /*state*/ ctx[4].verticalView == true ? '100%' : '50%');
			}

			if (!current || dirty[0] & /*state*/ 16) {
				set_style(div11, "position", /*state*/ ctx[4].verticalView == true
				? 'relative'
				: 'absolute');
			}

			if (/*state*/ ctx[4].playerState) {
				if (if_block10) {
					if_block10.p(ctx, dirty);

					if (dirty[0] & /*state*/ 16) {
						transition_in(if_block10, 1);
					}
				} else {
					if_block10 = create_if_block_8$2(ctx);
					if_block10.c();
					transition_in(if_block10, 1);
					if_block10.m(t22.parentNode, t22);
				}
			} else if (if_block10) {
				group_outros();

				transition_out(if_block10, 1, 1, () => {
					if_block10 = null;
				});

				check_outros();
			}

			const editormodal_changes = {};

			if (!updating_modal && dirty[0] & /*modal*/ 1024) {
				updating_modal = true;
				editormodal_changes.modal = /*modal*/ ctx[10];
				add_flush_callback(() => updating_modal = false);
			}

			if (!updating_visible && dirty[0] & /*modalVisible*/ 512) {
				updating_visible = true;
				editormodal_changes.visible = /*modalVisible*/ ctx[9];
				add_flush_callback(() => updating_visible = false);
			}

			editormodal.$set(editormodal_changes);
			const dialog0_changes = {};

			if (dirty[0] & /*saveCheckbox, stageComment, state*/ 176 | dirty[4] & /*$$scope*/ 2097152) {
				dialog0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_1 && dirty[0] & /*state*/ 16) {
				updating_visible_1 = true;
				dialog0_changes.visible = /*state*/ ctx[4].saveDialog;
				add_flush_callback(() => updating_visible_1 = false);
			}

			dialog0.$set(dialog0_changes);
			const dialog1_changes = {};

			if (dirty[4] & /*$$scope*/ 2097152) {
				dialog1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_2 && dirty[0] & /*state*/ 16) {
				updating_visible_2 = true;
				dialog1_changes.visible = /*state*/ ctx[4].activator;
				add_flush_callback(() => updating_visible_2 = false);
			}

			dialog1.$set(dialog1_changes);
			const dialog2_changes = {};

			if (dirty[0] & /*state*/ 16 | dirty[4] & /*$$scope*/ 2097152) {
				dialog2_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_3 && dirty[0] & /*state*/ 16) {
				updating_visible_3 = true;
				dialog2_changes.visible = /*state*/ ctx[4].xmlDialog;
				add_flush_callback(() => updating_visible_3 = false);
			}

			dialog2.$set(dialog2_changes);
			const snackbar_changes = {};

			if (dirty[0] & /*state*/ 16 | dirty[4] & /*$$scope*/ 2097152) {
				snackbar_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_4 && dirty[0] & /*state*/ 16) {
				updating_visible_4 = true;
				snackbar_changes.visible = /*state*/ ctx[4].snackback;
				add_flush_callback(() => updating_visible_4 = false);
			}

			snackbar.$set(snackbar_changes);

			if (window.is_domain && /*state*/ ctx[4].viewConfig.domain) {
				if (if_block11) {
					if_block11.p(ctx, dirty);

					if (dirty[0] & /*state*/ 16) {
						transition_in(if_block11, 1);
					}
				} else {
					if_block11 = create_if_block_4$3(ctx);
					if_block11.c();
					transition_in(if_block11, 1);
					if_block11.m(t28.parentNode, t28);
				}
			} else if (if_block11) {
				group_outros();

				transition_out(if_block11, 1, 1, () => {
					if_block11 = null;
				});

				check_outros();
			}

			if (window.content_for_newEditor) if_block12.p(ctx, dirty);

			if (/*state*/ ctx[4].viewConfig.webPageList) {
				if (if_block13) {
					if_block13.p(ctx, dirty);

					if (dirty[0] & /*state*/ 16) {
						transition_in(if_block13, 1);
					}
				} else {
					if_block13 = create_if_block_2$6(ctx);
					if_block13.c();
					transition_in(if_block13, 1);
					if_block13.m(t30.parentNode, t30);
				}
			} else if (if_block13) {
				group_outros();

				transition_out(if_block13, 1, 1, () => {
					if_block13 = null;
				});

				check_outros();
			}

			const createvariable_changes = {};
			if (dirty[0] & /*state*/ 16) createvariable_changes.algo_qxml = /*state*/ ctx[4].algo_qxml;
			if (dirty[0] & /*state*/ 16) createvariable_changes.view = /*state*/ ctx[4].variable_button;
			if (dirty[0] & /*state*/ 16) createvariable_changes.single_variables = /*state*/ ctx[4].single_variables;

			if (!updating_editorState_1 && dirty[0] & /*state*/ 16) {
				updating_editorState_1 = true;
				createvariable_changes.editorState = /*state*/ ctx[4];
				add_flush_callback(() => updating_editorState_1 = false);
			}

			createvariable.$set(createvariable_changes);

			if (/*state*/ ctx[4].guid && window.from_myproject == 1) {
				if (if_block14) {
					if_block14.p(ctx, dirty);

					if (dirty[0] & /*state*/ 16) {
						transition_in(if_block14, 1);
					}
				} else {
					if_block14 = create_if_block_1$7(ctx);
					if_block14.c();
					transition_in(if_block14, 1);
					if_block14.m(t32.parentNode, t32);
				}
			} else if (if_block14) {
				group_outros();

				transition_out(if_block14, 1, 1, () => {
					if_block14 = null;
				});

				check_outros();
			}

			const media_changes = {};
			media.$set(media_changes);

			if (/*state*/ ctx[4]?.AnalyzeEbookMenu) {
				if (if_block15) {
					if_block15.p(ctx, dirty);

					if (dirty[0] & /*state*/ 16) {
						transition_in(if_block15, 1);
					}
				} else {
					if_block15 = create_if_block$k(ctx);
					if_block15.c();
					transition_in(if_block15, 1);
					if_block15.m(t34.parentNode, t34);
				}
			} else if (if_block15) {
				group_outros();

				transition_out(if_block15, 1, 1, () => {
					if_block15 = null;
				});

				check_outros();
			}

			const interactiveitem_changes = {};
			interactiveitem.$set(interactiveitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editorheader.$$.fragment, local);
			transition_in(if_block3);
			transition_in(if_block8);
			transition_in(if_block10);
			transition_in(editormodal.$$.fragment, local);
			transition_in(dialog0.$$.fragment, local);
			transition_in(dialog1.$$.fragment, local);
			transition_in(dialog2.$$.fragment, local);
			transition_in(snackbar.$$.fragment, local);
			transition_in(if_block11);
			transition_in(if_block12);
			transition_in(if_block13);
			transition_in(createvariable.$$.fragment, local);
			transition_in(if_block14);
			transition_in(media.$$.fragment, local);
			transition_in(if_block15);
			transition_in(interactiveitem.$$.fragment, local);
			transition_in(editorpopovermodal.$$.fragment, local);
			transition_in(peglossarycontentlink.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editorheader.$$.fragment, local);
			transition_out(if_block3);
			transition_out(if_block8);
			transition_out(if_block10);
			transition_out(editormodal.$$.fragment, local);
			transition_out(dialog0.$$.fragment, local);
			transition_out(dialog1.$$.fragment, local);
			transition_out(dialog2.$$.fragment, local);
			transition_out(snackbar.$$.fragment, local);
			transition_out(if_block11);
			transition_out(if_block12);
			transition_out(if_block13);
			transition_out(createvariable.$$.fragment, local);
			transition_out(if_block14);
			transition_out(media.$$.fragment, local);
			transition_out(if_block15);
			transition_out(interactiveitem.$$.fragment, local);
			transition_out(editorpopovermodal.$$.fragment, local);
			transition_out(peglossarycontentlink.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			/*editorheader_binding*/ ctx[49](null);
			destroy_component(editorheader);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			if (if_block8) if_block8.d();
			if (if_block9) if_block9.d();
			if (detaching) detach_dev(t21);
			if (if_block10) if_block10.d(detaching);
			if (detaching) detach_dev(t22);
			destroy_component(editormodal, detaching);
			if (detaching) detach_dev(t23);
			destroy_component(dialog0, detaching);
			if (detaching) detach_dev(t24);
			destroy_component(dialog1, detaching);
			if (detaching) detach_dev(t25);
			destroy_component(dialog2, detaching);
			if (detaching) detach_dev(t26);
			destroy_component(snackbar, detaching);
			if (detaching) detach_dev(t27);
			if (if_block11) if_block11.d(detaching);
			if (detaching) detach_dev(t28);
			if (if_block12) if_block12.d(detaching);
			if (detaching) detach_dev(t29);
			if (if_block13) if_block13.d(detaching);
			if (detaching) detach_dev(t30);
			/*createvariable_binding*/ ctx[76](null);
			destroy_component(createvariable, detaching);
			if (detaching) detach_dev(t31);
			if (if_block14) if_block14.d(detaching);
			if (detaching) detach_dev(t32);
			/*media_binding*/ ctx[78](null);
			destroy_component(media, detaching);
			if (detaching) detach_dev(t33);
			if (if_block15) if_block15.d(detaching);
			if (detaching) detach_dev(t34);
			/*interactiveitem_binding*/ ctx[80](null);
			destroy_component(interactiveitem, detaching);
			if (detaching) detach_dev(t35);
			destroy_component(editorpopovermodal, detaching);
			if (detaching) detach_dev(t36);
			destroy_component(peglossarycontentlink, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const ucStepContolPanel = '<main data-remove="true" contenteditable="false" class="controls_panel_button" style="height:1px;outline:none;float:right;margin-top:8px"><div class="panel-controls" style="opacity:1;position:relative;"><div class="panel-controls__container"><div class="panel-controls__bar"><div style="border-radius: 2.3rem;border: 1px solid rgba(49,53,55,.2);background:#FFF8DC;padding:6px 0" class="panel-controls__tools"><div><a class="panel-controls__duplicate" data-bs-toggle="tooltip" title="Copy"><i class="icomoon-copy-2"></i></a></div><div><a class="panel-controls__remove" data-bs-toggle="tooltip" title="Remove"><i class="icomoon-24px-delete-1"></i></a></div></div></div></div></div></main>';

// Add place holder for editor sections
function addPlaceHolder(placeholder, addOn) {
	let domKey = "placeHolder" + placeholder;

	if (addOn) {
		// eslint-disable-next-line react/jsx-key
		return `<br /><div style="background:#e9ecef; z-index: 100"><b key="${domKey}" class="text-muted" id="${domKey}">${placeholder}</b></div>`;
	} else {
		return `<div style="background:#e9ecef; z-index: 100"><b key="${domKey}" class="text-muted" id="${domKey}">${placeholder}</b></div>`;
	}
}

function instance$r($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Editor', slots, []);
	let { actionData } = $$props;
	let { advanceXml } = $$props;
	let { item } = $$props;
	let { itemXML } = $$props;
	let { moduleType } = $$props;
	let { content_icon } = $$props;
	let { content_guid } = $$props;
	let { inline_item } = $$props;
	let { is_algo } = $$props;
	let { ajaxData = "" } = $$props;
	let { _user } = $$props;
	let { subtype } = $$props;

	if (window.origin.includes('https://') && location.host != "localhost") {
		window.baseUrl = window.baseUrl.replace('http://', 'https://');
	}

	let snt_detail_array = {};
	let stageComment = "";
	let editorHeaderRef; // refrence of editorHeader
	let editCount = 1;
	let saveCheckbox; // handle check of saving check box
	let createVariableCallback = {}; // refrence of createAlgo
	let modalVisible = false; // handle Modal instance
	let player_parent = ""; // check palyer tag

	// Modal props for dynamic data
	let modal = {
		header: [],
		body: [],
		footer: [],
		width: 300
	};

	let editorBuffer = {}; // Buffer storage for editor
	let typeChangePosition = ""; // Current content change position
	let Items = {}; // Instance of item comonenets
	let changedKeys = []; // track which section is changing
	let cursorPosition = ""; // Cursor's current position
	let _interactiveItem = ""; // hold all intractive layouts
	let _commentModal; // refrence of commentModal
	let state = {};
	let preview_edit;

	let hdd = writable({
		title: "",
		stem: "",
		remediation: "",
		remediationToggle: false,
		verticalView: true,
		item: "",
		xml: "",
		itemXML: false,
		itemListFilter: "",
		content: "",
		open: false,
		xmlDialog: false,
		saveDialog: false,
		analyzeebookcontent: false,
		errMessage: "",
		snackback: false,
		playerPopup: false,
		vtt: "",
		info: "",
		guid: "",
		content_type: "",
		content_icon: "",
		webPageData: "",
		sntTags: {},
		strForRender: "",
		myComponent: "SM",
		toggleMode: false,
		activator: false,
		versionToggle: false,
		domain: "",
		domainToggle: false,
		course_list: false,
		save_publish: false,
		webpageArray: [],
		skipValidation: false,
		coverage_guid: "",
		open_doc: false,
		testObj: false,
		inline_item: "",
		is_algo: "",
		playerBookmark: false,
		exam_objective: false,
		examToggle: false,
		algo_qxml: "",
		single_variables: [],
		variable_button: false,
		draft: 0,
		netMsg: '',
		anchorEl: null,
		stopAuthoringUpdate: false,
		stopPreviewUpdate: false,
		answerStr: "",
		oldStemData: "",
		AnalyzeEbookMenu: false,
		caseid_val: "",
		noTitle: false,
		todoState: "Show Todo",
		db_changed: false,
		player_render: true,
		saveVal: "test",
		isCSV: false,
		ajaxData: {},
		propsAjaxData: {},
		editorModalHandle: false,
		radioValue: "plain",
		stausRadioValue: "",
		exam_objective_mapping_save: 0,
		mcqAjaxData: {},
		viewConfig: { view: "" },
		render: 0,
		editorView: "authoring",
		playerState: false,
		playerArr: {},
		prevPlayerValue: { category: "knowledge_check" },
		prevPlayerState: {},
		links: false,
		message: "",
		previewXml: "", // In case of solve Variable we need to keep the preview and auth seperately.
		authXml: "", // In case of solve Variable we need to keep the preview and auth seperately.
		
	});

	let dxml = '';
	let _media;
	let _editorBuffer = {};

	const unsubscribe = hdd.subscribe(items => {
		$$invalidate(4, state = items);
	});

	onMount(async () => {
		AH.activate(2);
		ucEditor.setConfig(editorConfig); // Setting config for tinymce
		editorConfig.setParent(updateModuleState, handleModal); // Setting updator for external files
		let tempAjaxData = AH.validateAjaxData(ajaxData, item); // checking ajaxData
		$$invalidate(4, state.item = item, state);
		$$invalidate(4, state.content_type = moduleType, state);
		$$invalidate(4, state.content_icon = content_icon, state);
		$$invalidate(4, state.inline_item = inline_item, state);
		$$invalidate(4, state.is_algo = is_algo, state);
		$$invalidate(4, state.ajaxData = tempAjaxData, state);

		$$invalidate(
			4,
			state.mcqAjaxData = item == 0 || item == 8
			? JSON.parse(JSON.stringify(tempAjaxData))
			: tempAjaxData,
			state
		);

		$$invalidate(4, state.propsAjaxData = ajaxData, state);
		$$invalidate(4, state.guid = content_guid ? content_guid : "", state);
		$$invalidate(4, state.itemXML = itemXML, state);
		AH.set('is_proposed', getQueryString('is_proposed'));
		AH.set('save', true);
		AH.set('draft', ajaxData && ajaxData.is_draft ? ajaxData.is_draft : 0);

		if (content_guid) {
			initComments(content_guid, _user.user_guid);
		}

		interactive_item = editorConfig.createIteractive(); // Getting Intractive items layout
		AH.setCss("#editor", { background: '#e9ecef' });
		$$invalidate(4, state.viewConfig = editorConfig.getConfig(state), state); // Getting editor config
		editorConfig.checkStage(state); // Getting stage of current guid
		$$invalidate(11, Items = await getItems(item, state)); // Getting Item compoenents

		if (ajaxData) {
			let xml = '', type = '';

			if (state.viewConfig.isQuestion) {
				xml = ajaxData.content_text.special_module_xml;
				type = ajaxData.content_subtype;

				// Getting Default XML
				if (!AH.isValid(xml)) {
					if (type === "26" && xml === "") {
						// If xml blank in case of multigrid then will execute if condition
						xml = Items?.default.getDefaultXMl("editor_item_75.xml");

						xml = formatXmlRef(xml, item);
					} else {
						xml = Items?.default.getDefaultXMl("sample");
						xml = formatXmlRef(xml, item);
					}
				}

				if (ajaxData.content_text.algo_qxml) {
					$$invalidate(4, state.algo_qxml = ajaxData.content_text.algo_qxml, state);
				}

				if (ajaxData.content_text.case_id) {
					$$invalidate(4, state.caseid_val = ajaxData.content_text.case_id, state);
				}

				// Checking item wise maniulations
				if (Items?.UI?.cleanItemWise) {
					({ type, xml } = Items.UI.cleanItemWise(ajaxData, type, xml));
				}

				// Setting state for data
				$$invalidate(4, state.title = ajaxData.content_text.title, state);

				$$invalidate(4, state.stem = formatData(ajaxData.content_text.question, 'convertUcSyntax'), state);
				$$invalidate(4, state.remediation = formatData(ajaxData.content_text.explanation, 'convertUcSyntax'), state);
			} else {
				// set state and fillter content and formatting
				$$invalidate(4, state.content = replacePreTag(formatData(ajaxData.content_text.content), editorConfig.preTagTypes), state);

				$$invalidate(4, state.title = ajaxData?.content_text.title, state);
				$$invalidate(4, state.info = ajaxData?.content_text.info || '', state);
				$$invalidate(4, state.vtt = ajaxData?.content_text.vtt || '', state);
			}

			$$invalidate(4, state.content_icon = ajaxData.content_icon, state);
			$$invalidate(4, state.draft = ajaxData.is_draft, state);
			setModule(xml); // Update xml for items
		} else {
			//@Pradeep: require default xml from ModuleQtype and use here.
			if (itemXML) {
				dxml = Items.default.getDefaultXMl(itemXML);
				dxml = formatXmlRef(dxml, item);
				AH.set("error", AH.isValid(dxml) ? false : "XML is not found.");
			}

			setModule(dxml); // Updating xml for items
		}

		// For debugging
		AH.set("setEditor", updateModuleState);

		AH.set('getEditor', getState);
	});

	afterUpdate(() => {
		if (typeof state != 'undefined' && 'guid' in state && state.guid) {
			initComments(state.guid, _user.user_guid);
		}
	});

	// get State
	function getState(name) {
		if (name) return state[name];
		return state;
	}

	//show version history dialogs
	function versionControl(flag) {
		$$invalidate(4, state.versionToggle = flag, state);
	}

	// Show Items status in snackback
	function showAns(msg) {
		if (_editorBuffer['snack_timer']) clearTimeout(_editorBuffer['snack_timer']);

		_editorBuffer['snack_timer'] = setTimeout(
			() => {
				$$invalidate(4, state.message = msg, state);
				$$invalidate(4, state.snackback = true, state);
			},
			500
		);
	}

	function initComments(guid, user_guid) {
		if (from_myproject == 1 && document.querySelector("#editor_comment_modal_btn:not([hidden])")) {
			AH.set('current_guid', guid);

			let type = AH.isValid(AH.get('comments_type'))
			? AH.get('comments_type')
			: -2;

			AH.ajax({
				url: `${baseUrl}educator/project/index.php?func=get_comments&content_guid=${guid}&user_guid=${user_guid}&tags=${type}`,
				withUrl: true
			}).then(function (res) {
				document.querySelector('#comment_modal_body').innerHTML = res;
				AH.initDropdown();
				document.querySelector("#editor_comment_modal_btn").style.display = "block";
				_commentModal.init?.();
			});
		}
	}

	// Function to handle state from outside
	function updateModuleState(key, value, action = "") {
		switch (action) {
			case 'renderPlayer':
				renderPlayer();
				break;
			case 'getXml':
				getXml();
				break;
			case 'addNew':
				$$invalidate(41, actionData.loaditem = 'Default', actionData);
				break;
			case 'message':
				$$invalidate(4, state.message = value, state);
				break;
			default:
				$$invalidate(4, state[key] = value, state);
				break;
		}
	}

	// Method to take modal layout
	function handleModal(modalData) {
		if (modalData) {
			$$invalidate(10, modal = modalData);
			$$invalidate(9, modalVisible = true);
		} else {
			$$invalidate(9, modalVisible = false);
		}
	}

	// action which called after first paint 
	function didMount(node, action) {
		if (editorBuffer['didMount']) clearTimeout(editorBuffer['didMount']);

		editorBuffer['didMount'] = setTimeout(
			() => {
				let urlVars = AH.getUrlVars();

				if (preview_edit == 1) {
					showPreviewOnly();
				} else {
					interactiveEditor();
					ucTimelineEditor(ucEditor);
					initEditorListeners();

					//update locally content
					addUpdateDataBase(state, updateModuleState);

					// for backup when net is not avialbale
					if (urlVars['load_backup'] == 1) {
						loadBackup(state, updateModuleState);
					}
				}

				if (ajaxData) {
					if (state.viewConfig.isQuestion) {
						setBasicData(state.title, state.stem, state.remediation, "skip_state_set");
						initAddFeature(state.title, editorConfig.maintainAlignments(state.stem), editorConfig.maintainAlignments(state.remediation));
					} else {
						let contentText = state.propsAjaxData?.content.replace(/\n/g, "<br>") || state.content;

						contentText = AH.isValid(contentText)
						? replaceUnwantedTags(contentText)
						: contentText;

						contentText = editorConfig.replaceUnwantedEntity(contentText, 'only_self_close');
						let tempContent = editorConfig.replaceUnwantedEntity(state.content, 'onlyEntity');
						AH.select("#content").innerHTML = editorConfig.maintainAlignments(tempContent);
						AH.select('#content_show').innerHTML = editorConfig.maintainAlignments(get_ucsyntax(contentText));
						AH.select("#title, #title_show").innerHTML = editorConfig.replaceUnwantedEntity(state.title, 'onlyEntity');
						AH.select("#info, #info_show").innerHTML = state.info;

						AH.isValid(state.vtt)
						? AH.select("#vtt, #vtt_show").innerHTML = state.vtt.replace(/&nbsp;/g, " ").replace(/  /g, " &nbsp;")
						: tempContent;

						initAddFeature(false, false, false, tempContent || " ");
					}
				}

				AH.toggleDom('#savePublish', state.guid.length == '5' && from_myproject == 1
				? 'show'
				: 'hide');

				updateEbookContent();
				setupEditor(urlVars);
			},
			200
		);

		// check if uc_image_annotate is available in window or not
		if (typeof window.uc_image_annotate == "undefined") {
			window.uc_image_annotate = new ImageAnnotation();
		}
	}

	function showPreviewOnly() {
		//self.fullScreen();
		//$("#editor").hide();
		AH.select('#editor', 'css', { display: 'none' });

		setTimeout(
			function () {
				//self.setState({ verticalView: true }, function () {
				$$invalidate(4, state.verticalView = true, state); //});
				//});

				//$("#editor").show();
				AH.select('#editor', 'css', { display: 'block' });

				//$('[href="#authoringDiv"]').addClass('disabled');
				AH.select('[href="#authoringDiv"]', 'addClass', 'disabled');

				let checkView = Items[state.item] && Items[state.item].UI.verticalView;

				if (!checkView) {
					//$("#authoringDiv").hide();
					AH.select("#authoringDiv", 'css', { display: 'none' });

					//$('[href="#custom_columnize"]').tab('show');
					AH.select('[href="#custom_columnize"]').click();
				}

				//$("#player_render_top, #back_editor_button").hide();
				AH.select("#player_render_top", 'css', { dispaly: 'none' });

				AH.select("#back_editor_button", 'css', { display: 'none' });

				//$('#preview_editor_new').css('pointer-events', 'none');
				AH.select('#preview_editor_new', 'css', { pointerEvents: 'none' });

				//$(document).ready(function () {
				//$("#authoring_boxe, #device_btn").hide();
				AH.select("#authoring_boxe, #device_btn", 'css', { display: 'none' });

				ajaxContentUpdate$1({
					imgAltText: 1,
					container: ['#previewSection']
				});

				if (checkView) {
					setTimeout(
						function () {
							//$('main[data-remove="true"]').hide();
							AH.select('main[data-remove="true"]', 'css', { display: none });

							externalToggle();

							//$("#remedToggle").addClass("h-imp");
							AH.select("#remedToggle", 'addClass', 'h-imp');
						},
						500
					);
				}
			},
			200
		); //});
		//});
	}

	// Set initially content for editor
	function setBasicData(title, stem, remediation, skip = false) {
		if (!skip) {
			$$invalidate(4, state.title = title, state);
			$$invalidate(4, state.stem = stem, state);
			$$invalidate(4, state.remediation = remediation, state);
		}

		AH.select("#title").innerHTML = title;
		AH.select("#title_show").innerHTML = title;
		stem = editorConfig.replaceUnwantedEntity(stem, 'cleanHiddenEnity');
		AH.select("#stem").innerHTML = stem;
		AH.select('#stem_show').innerHTML = editorConfig.maintainAlignments(get_ucsyntax(stem));
		remediation = editorConfig.replaceUnwantedEntity(remediation, 'cleanHiddenEnity');
		AH.select("#remediation").innerHTML = remediation;
		AH.select("#remediation_show").innerHTML = editorConfig.maintainAlignments(get_ucsyntax(remediation));
	}

	// Update Player tag content
	function renderPlayer() {
		let previewDom = document.getElementById('preview');

		document.querySelectorAll('#previewSection img[data-bigimage]').forEach(function (_this) {
			let bigimagesrc = _this.getAttribute('data-bigimage');

			if (bigimagesrc != '' && bigimagesrc != undefined) {
				AH.wrap(_this, "<figure class='fs-img uc-figure fullscreen'></figure>");
				AH.insert(_this.parentElement, `<img target="_blank" src="${bigimagesrc}"/>`, 'afterend');
			}
		});

		var fullscreenTimer = setTimeout(
			function () {
				document.querySelectorAll("#previewSection .fullscreen").forEach(function (_this, index) {
					let figureid = 'fullId' + index;
					_this.setAttribute('id', figureid);
				});

				clearTimeout(fullscreenTimer);
			},
			1000
		);

		let checkPlayground = 0;

		// Update on player tag change.
		previewDom.querySelectorAll('player').forEach(_this => {
			if (_this.getAttribute('type') == 'playground') {
				checkPlayground = 1;
			}

			if (_this.getAttribute('type') != 'exhibit' && _this.getAttribute('type') != 'playground') {
				_this.innerHTML = "";
			}
		});

		if (state.player_render) {
			tag_player(previewDom);
			$$invalidate(4, state.player_render = false, state);
		}

		//Show player tag with full width for UI improvement when the player is rendering
		previewDom.querySelectorAll('player').forEach(function (_elm) {
			_elm.innerHTML != ''
			? _elm.classList.add('w-100')
			: _elm.classList.remove('w-100');
		});

		//working of ebook interactive items
		// initEbookInteractivity();
		//listStyleChange("list2", "list3", "list4", "list5", "list6");
		if (player_parent) {
			setContent(player_parent);
		}

		let checkSideshow = 1;

		previewDom.querySelectorAll('div').forEach(function (_tagElm) {
			if (_tagElm.getAttribute('id') == 'myCarousel') {
				checkSideshow = 0;
			}
		});

		if (checkSideshow) {
			initEbookInteractivity();
		}

		if (checkPlayground) {
			prettyPrint();
		}

		//commented due to get hidden when click submit on player tag
		try {
			document.querySelectorAll('#editor img').forEach(function (_this) {
				let imgSrc = _this.getAttribute('src');

				if (!_this.getAttribute('header-logo') && imgSrc.indexOf('vimeocdn') == -1 && !imgSrc.match(/\/\/s3.amazonaws.com\/jigyaasa_content_static|jigyaasa.net|ucertify.com|localhost\/pe-gold3|http:\/\/|https:\/\//gm)) {
					_this.setAttribute('src', '//s3.amazonaws.com/jigyaasa_content_static/' + imgSrc);
				}
			});
		} catch(e) {
			console.log({ Error: e, line: 2372 });
		}

		$$invalidate(4, state.strForRender = "", state);
		editorConfig.getSnt(state.stem, state, state.strForRender);
		editorConfig.getSnt(state.content, state, state.strForRender);
		editorConfig.getSnt(state.remediation, state, state.strForRender);
		let snt_content_guid = Object.keys(state.sntTags).toString();

		if (snt_content_guid && snt_detail_array[snt_content_guid] == undefined) {
			$$invalidate(4, state.activator = true, state);

			editorBuffer['ajaxTimer'] = setTimeout(
				function () {
					AH.ajax({
						url: baseUrl + 'editor/index.php', // point to server-side PHP script
						data: {
							ajax: "1",
							content_guid: snt_content_guid,
							str_content: state.strForRender,
							func: 'react_get_snt',
							action: 'react_get_snt'
						}
					}).then(response => {
						// If the new snt details comes from server then add the new details in array.
						snt_detail_array = {};

						snt_detail_array[snt_content_guid] = response;
						$$invalidate(4, state.activator = false, state);
						setSntDetails(response, state, previewSnt);

						ajaxContentUpdate$1({
							imgAltText: 1,
							container: ['#previewSection']
						});
					});

					clearTimeout(editorBuffer['ajaxTimer']);
				},
				500
			);
		} else {
			let response = snt_detail_array[snt_content_guid];
			setSntDetails(response, state, previewSnt);
		}

		//self.handleMenuClose();
		ucStepImplement();

		if (!previewDom.querySelector('hotspot')) {
			ajaxContentUpdate$1({
				imgAltText: 1,
				container: ['#previewSection']
			});
		}
	}

	/**
 * Function to set the snt detials into preview, stem and remediation, 
*/
	function setSntDetails(response, state, previewSnt) {
		editorConfig.setSnt('#content_show', response, state, previewSnt);
		editorConfig.setSnt('#stem_show', response, state, previewSnt);
		editorConfig.setSnt('#remediation_show', response, state, previewSnt);
		editorConfig.setSnt('#remediationShow', response, state, previewSnt);
		editorConfig.setSnt('#stemShow', response, state, previewSnt);
	}

	/**
 * UcFeatures releated functions
 * Moved from Smeditor
 */
	function ucStepImplement() {
		AH.selectAll('#previewSection .uc_answer_hint, #previewSection .uc_step_explanation').forEach(function (_this, i) {
			let exp_steps = _this.classList.contains('uc_step_explanation');

			if (exp_steps) {
				AH.selectAll(AH.find(_this, '.uc_step', 'all'), 'css', { 'display': 'none' });
				AH.select(AH.find(_this, '.uc_step', 'all')[0], 'css', { 'display': 'block' });

				AH.find(_this, '.uc_step', 'all').forEach(function (elm) {
					if (_this.innerHTML.trim().match(/^<br/g) == null) {
						AH.insert(elm, "<br/>", 'beforebegin');
					}
				});

				let btnCaption = _this.getAttribute('data-btnnme') != undefined && _this.getAttribute('data-btnnme') != ""
				? _this.getAttribute('data-btnnme')
				: 'Next';

				let btnhtml = '<button type="button" onclick="showUcExpStep(this)" class="exp_next_btn btn btn-sm btn-outline-primary bg-white imgcenter text-primary" style="width: 15%; font-size: 15px; margin-top: 15px;">' + btnCaption + '</button>';
				AH.find(_this, '.exp_next_btn', { action: 'remove' });
				AH.find(_this, '.addnext_caption', { action: 'remove' });
				AH.insert(_this, btnhtml, 'beforeend');
			} else {
				// for hint 
				let head_caption = "Hint";

				let step_caption = "hint";

				if (_this.querySelectorAll('.uc_hint_section').length > 0) {
					AH.select(_this, 'removeClass', 'list2');
					AH.find(_this, '.uc_hint_section', { action: 'remove' });

					_this.querySelectorAll('li').forEach(function (elm) {
						elm.style.display = '';
					});
				}

				if (_this.hasAttribute("head_caption")) {
					head_caption = _this.getAttribute("head_caption");
				}

				if (_this.hasAttribute("step_caption")) {
					step_caption = _this.getAttribute("step_caption");
				}

				let msg = "<b>" + head_caption + ": </b> <span class='li_count'>" + _this.querySelectorAll('li').length + "</span> " + step_caption + "(s) are available.";
				let _btn = '<button type="button" style="margin-top:-8px" onclick="showHints(this)" class="hint_show btn btn-primary float-right">Show</button>';
				let pre_block = "<section id='uc_hint_" + i + "' class='mt uc_hint_section white-bg alert text_lightBlack m-b-md alert-info'>" + _btn + msg + "</section>";
				_this.innerHTML = pre_block + _this.innerHTML;
				_this.classList.add("list2");
			}
		});
	}

	// function listStyleChange(...list) {
	// 	let authSection = document.getElementById('authoringSection');
	// 	for (let arg of list) {
	// 		if (document.querySelector("." + arg) && document.querySelector("." + arg).getAttribute("id") == "interactive_list") {
	// 			authSection.querySelectorAll('.' + arg + ' li').each(function (_this) {
	// 				_this.innerHTML = _this.innerHTML.replace(/<br data-mce-bogus="1">/g, "");
	// 			});
	// 			authSection.querySelector('.' + arg + ' li').contents().wrap('<div></div>');
	// 			if (AH.nextElm(authSection.querySelector('.' + arg + ' li'), 'ul')) {
	// 				authSection.querySelector('.' + arg + ' li + ul').appendTo(authSection.find('.' + arg + ' li + ul').prev());
	// 			}
	// 			if (authSection.find('.' + arg + ' li').next('ol').length > 0) {
	// 				authSection.find('.' + arg + ' li + ol').appendTo(authSection.find('.' + arg + ' li + ol').prev());
	// 			}
	// 			authSection.find("." + arg).removeClass(arg).addClass(arg + "_new");
	// 			if (authSection.find("." + arg + "_new").parents(".auth-editor").getAttribute("id")) {
	// 				setContent(authSection.find("." + arg + "_new").parents(".auth-editor").getAttribute("id"));
	// 			}
	// 		}
	// 	}
	// }
	// Panel switching 
	function swapPanel(type) {
		let parent_tinymce_id = AH.parent(type, ".tinymce-editor");
		let active_node = type.closest('section[nd="1"]');
		AH.insertAfter(active_node, AH.nextElm(active_node));
		setContent(parent_tinymce_id.getAttribute("id"));
	}

	//Bind Event for editor controls
	function interactiveEvents() {
		AH.listen(document, 'mouseover', '.block-controls', function (_this) {
			AH.setCss(_this, {
				"opacity": 1,
				"transition": "opacity .45s,transform .3s,-webkit-transform .3s"
			});
		});

		AH.listen(document, 'mouseout', '.block-controls', function (_this) {
			AH.setCss(_this, { "opacity": 0 });
		});

		AH.listen(document, 'mouseover', '#authoringSection div[data-section]', function (_this) {
			let closest_control = AH.find(_this.previousElementSibling, ".block-controls");

			AH.setCss(closest_control, {
				"opacity": 1,
				"transition": "opacity .45s,transform .3s,-webkit-transform .3s"
			});
		});

		AH.listen(document, 'mouseout', '#authoringSection div[data-section]', function (_this) {
			let closest_control = AH.find(_this.previousElementSibling, ".block-controls");
			AH.setCss(closest_control, { "opacity": 0 });
		});

		AH.listen(document, 'click', '.block-controls__move-up', function (_this) {
			let currentControl = AH.parent(_this, ".controls_button");
			let currentSection = currentControl.nextElementSibling;
			let preSection = currentControl?.previousElementSibling?.previousElementSibling || false;

			if (preSection) {
				AH.insert(preSection, currentControl.outerHTML + currentSection.cloneNode(true).outerHTML, 'beforebegin');
				let currentAuthEditorId = AH.parent(_this, ".auth-editor").getAttribute("id");
				setContent(currentAuthEditorId);
				currentControl.remove?.();
				currentSection.remove?.();

				setTimeout(
					() => {
						setContent(currentAuthEditorId);
						ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
					},
					500
				);

				AH.toggleDom('.tooltip', 'hide');
				AH.enableBsAll("[data-bs-toggle='tooltip']", 'Tooltip', { container: 'body' });
			} else {
				AH.alert("This is the Start of the content.");
			}
		});

		AH.listen(document, 'click', '.block-controls__move-down', function (_this) {
			let currentControl = AH.parent(_this, ".controls_button");
			let currentSection = currentControl.nextElementSibling;
			let nextSection = currentSection.nextElementSibling;
			nextSection = nextSection?.nextElementSibling || false;

			if (nextSection) {
				AH.insert(nextSection, currentControl.outerHTML + currentSection.cloneNode(true).outerHTML, 'afterend');
				let currentAuthEditorId = AH.parent(_this, ".auth-editor").getAttribute("id");
				setContent(currentAuthEditorId);
				currentControl.remove();
				currentSection.remove();

				setTimeout(
					() => {
						setContent(currentAuthEditorId);
						ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
					},
					500
				);

				AH.toggleDom('.tooltip', 'hide');
				AH.enableBsAll("[data-bs-toggle='tooltip']", 'Tooltip', { container: 'body' });
			} else {
				AH.alert("This is the end of the content.");
			}
		});

		AH.listen(document, 'click', '.block-controls__remove', function (_this) {
			window.curr = AH.parent(_this, ".auth-editor");
			let parent_tinymce_id = AH.parent(_this, ".auth-editor").getAttribute("id");
			var totalChild = document.querySelectorAll('#' + parent_tinymce_id + ' div[data-section]').length;

			if (totalChild > 1) {
				let _this_section = AH.parent(_this, ".controls_button").nextElementSibling;
				_this_section?.previousElementSibling.remove();
				_this_section.remove?.();
				setContent(parent_tinymce_id);
				AH.toggleDom('.tooltip', 'hide');
				toggleSave(1);
			} else {
				AH.alert("You can not delete Stem.");
			}
		});

		AH.listen(document, 'click', '.block-controls__add', function (_this) {
			cursorPosition = AH.parent(_this, ".controls_button").nextElementSibling;
			AH.set('filter_item', false);
			openItems();
		});

		AH.listen(document, 'click', '.block-controls__change-type', function (_this) {
			AH.select('#advance_id', 'addClass', 'h-imp');
			AH.select(".nested_items", 'html', ' ');
			let currentControl = AH.parent(_this, ".controls_button");
			window.curr = currentControl;
			let currentSection = currentControl.nextElementSibling;
			typeChangePosition = "";
			let sub_type = currentSection.getAttribute("sub_type");

			//let sec_bttn = currentSection.querySelector('#interactive_list');
			if (interactive_item[0][sub_type]['config'] && interactive_item[0][sub_type]['config']['editing_type_1']) {
				let type_list = interactive_item[0][sub_type]['config']['editing_type_1'].split(",");
				let sub_elm_type = interactive_item[0][sub_type]['config']['editing_change_type'];
				let elm_selector = document.getElementById("type_change");
				AH.getBS(elm_selector, 'Modal').show();
				elm_selector.querySelector(".sub_type").innerHTML = '';

				for (let i in type_list) {
					let a = type_list[i].split("|");
					let a4_html = "";

					let htmlPart = a[4] != 'default'
					? `style="max-width:100%;height:130px;background-image:url(${interactive_item[0][sub_type][a[0]]['default_image']});background-size:contain;background-position:center;background-repeat:no-repeat;overflow:hidden;" data-html="${interactive_item[0][sub_type][a[0]]['html']}"><div class="item_labelClass">${interactive_item[0][sub_type][a[0]]['label']}</div></li>`
					: `data-default="${a[4]}">${a[0]}</li>${a4_html}`;

					let newHtml = `<li id="${a[0]}" data-value="${a[1]}" data-type="${a[3]}" data-elm_type="${sub_elm_type}" data-selector="${a[2]}" class="${a[4] == 'default'
					? 'type_list uc_float_left'
					: 'type_list item_int thumbnail btn col-sm-5'}" data-sub_type="${sub_type}" ${htmlPart}`;

					AH.insert(elm_selector.querySelector(".sub_type"), newHtml, 'beforeend');
				}

				typeChangePosition = currentSection;

				if (currentControl.nextElementSibling.querySelector("[hidelinenums]") != null) {
					AH.select('#uc_checkbox_0').checked = true;
				} else {
					AH.select('#uc_checkbox_0').checked = false;
				}
			} else {
				AH.alert("This is the single type of the content.");
			}
		});

		AH.listen(document, 'click', '#type_change .type_list', function (currentTarget) {
			let _this_selector = currentTarget.getAttribute("data-selector");
			let _this_value = currentTarget.getAttribute("data-value");
			let _this_type = currentTarget.getAttribute("data-type");
			let _sub_type = currentTarget.getAttribute("data-sub_type");
			let _this_id = currentTarget.getAttribute("id");

			if (_this_type != 'undefined') {
				if (currentTarget.getAttribute('data-default') != 'default') {
					if (_this_selector == "uc\\:syntax") {
						AH.removeDomAttr(typeChangePosition.querySelector(_this_selector), ['console', 'command', 'white']);
					}

					AH.find(typeChangePosition, _this_selector, {
						action: 'attr',
						actionData: { [_this_type]: _this_value }
					});

					ucTimeline.ucInit();
				}
			} else {
				if (_this_value == "CUSTOM") {
					let customDOM = editorConfig.getSectionDef(interactive_item[0][_this_selector][_this_id]['html'], _sub_type);

					//customDOM = AH.clone(customDOM);
					// typeChangePosition.find(".ebook_item_text").each(function (i) {
					// 	if (currentTarget.getAttribute("data-update") != "true") {
					// 		//jQuery(customDOM).find(".ebook_item_text")[i].innerHTML = currentTarget.html();
					// 	}
					// });
					AH.insert(typeChangePosition, customDOM, 'afterend');

					typeChangePosition.remove();
				} else {
					let data_html = AH.parseDom(currentTarget.getAttribute("data-html"));
					let data_elm_type = currentTarget.getAttribute("data-elm_type");
					data_html = data_html.querySelector(_this_selector).cloneNode(true);

					AH.find(typeChangePosition, _this_selector, {
						action: 'attr',
						actionData: { "class": _this_value }
					});

					if (data_elm_type && data_elm_type != "undefined") {
						if (data_elm_type == 2) {
							AH.insert(typeChangePosition.querySelector('.' + _this_value), data_html.outerHTML, 'afterend');
							AH.find(typeChangePosition, '.' + _this_value, { action: 'remove' });
						} else {
							AH.find(typeChangePosition, _this_selector, {
								action: 'html',
								actionData: data_html.outerHTML
							});
						}
					}
				}
			}

			AH.getBS("#type_change", 'Modal').hide();
			setContent(AH.parent(typeChangePosition, ".auth-editor")?.getAttribute("id"));

			if (_this_value == "CUSTOM" || _sub_type == 'Timeline') {
				setTimeout(
					function () {
						ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
					},
					500
				);
			}
		});

		AH.listen(document, 'click', '#uc_checkbox_0', function (_this) {
			let _this_selector = _this.parentElement.previousElementSibling.getAttribute("data-selector");
			let _this_value = _this.parentElement.previousElementSibling.getAttribute("data-value");
			let _this_type = _this.parentElement.previousElementSibling.getAttribute("data-type");

			if (document.getElementById('uc_checkbox_0').checked) {
				document.getElementById('uc_checkbox_0').setAttribute("checked", true);

				AH.find(typeChangePosition, _this_selector, {
					action: 'attr',
					actionData: { [_this_type]: _this_value }
				});

				ucTimeline.ucInit();
			} else {
				document.getElementById('uc_checkbox_0').setAttribute("checked", false);

				AH.find(typeChangePosition, _this_selector, {
					action: 'removeAttr',
					actionData: 'hidelinenums'
				});
			}

			setContent('content');
		});
	}

	function ucTimelineEditor(ucEditor) {
		AH.getBS('#authoringSection', 'Tooltip', {
			selector: '[data-bs-toggle="tooltip"]',
			container: 'body'
		});

		AH.selectAll('.slide_data, #slide').forEach(elm => elm.setAttribute("contenteditable", "true"));

		AH.listen(document, 'click', '#Timeline, div[data-type="Timeline"] section:not(.listing_section), [data-type="Timeline"], [data-sub_type="Timeline"]', function () {
			let sections = document.querySelectorAll('#authoringSection li[data-parent="parent_element"], #authoringSection div[data-type="timeline"] section, #authoringSection .dot[data-parent="parent_element"]');

			for (let i = 0; i < sections.length; i++) {
				sections[i].setAttribute("id", i + 1);
			}
		});

		AH.listen(document, 'click', '.removeData', function (_this) {
			_this.closest('section:not(.listing_section), li[data-parent="parent_element"], .dot[data-parent="parent_element"]').remove();
		});

		AH.listen(document, 'click', '.copyData', function (_this) {
			//let element = _this.closest('section:not(.listing_section), li[data-parent="parent_element"], .dot[data-parent="parent_element"]').cloneNode(true);
			let element = AH.closest(_this, 'section:not(.listing_section), [data-parent="parent_element"]');

			AH.find(element, '.ebook_item_text', { action: 'attr', actionData: { id: '' } });

			if (AH.find(_this.parentElement, ".verticle_timeline2", 'all').length > 0) {
				AH.find(element, ".timeline_controls", { action: 'remove' });
			}

			element.after(element.cloneNode(true));
			AH.find(element.nextSibling, ".remove_me", { action: 'remove' });
			let sections = AH.selectAll('#authoringSection div[type="timeline"] section, #authoringSection div[type="slideshow"] section, #authoringSection li[data-parent="parent_element"],  #authoringSection li[data-parent="parent_element"]');

			for (let i = 0; i < sections.length; i++) {
				sections[i].setAttribute("id", i + 1);
			}

			setTimeout(
				() => {
					ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
				},
				300
			);
		});

		AH.listen(document, 'click', '.swapData', function (_this) {
			let currentControls = _this.parentElement;
			let currentElm = AH.parent(currentControls, 'section:not(.listing_section), li[data-parent="parent_element"], .dot[data-parent="parent_element"]');

			if (currentElm?.previousElementSibling.getAttribute("id") != undefined) {
				let previousData = currentElm.previousElementSibling;
				AH.find(previousData, '.ebook_item_text', { action: 'attr', actionData: { id: "" } });
				AH.find(currentElm, '.ebook_item_text', { action: 'attr', actionData: { id: "" } });
				let currentData = currentElm.innerHTML;
				previousData = previousData.innerHTML;

				// let getPreviousData = currentElm.previousElementSibling.getAttribute("id");
				// let getCurrentData = currentElm.getAttribute("id");
				if (AH.selectAll(currentControls, ".verticle_timeline2").length > 0) {
					previousData = previousData.replace(/<main[\s\S]*<\/main>/gm, '');
					currentData = currentData.replace(/<main[\s\S]*<\/main>/gm, '');
				}

				AH.select(currentElm, 'html', '');
				AH.select(currentElm, 'html', previousData);
				AH.select(currentElm.previousElementSibling, 'html', currentData);

				setTimeout(
					() => {
						ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
					},
					300
				);
			} else {
				AH.alert("It's first element", 4, true);
			}

			AH.select('.remove_me').remove?.();
		});

		AH.listen(document, 'click', '.downData', function (currentTarget) {
			let currentControl = currentTarget.parentElement;
			let currentSection = AH.parent(currentControl, 'section:not(.listing_section), li[data-parent="parent_element"], .dot[data-parent="parent_element"]');

			if (currentSection && currentSection.nextElementSibling.getAttribute("id") != undefined) {
				let previousData = currentSection.nextElementSibling;
				AH.find(previousData, '.ebook_item_text', { action: 'attr', actionData: { id: "" } });
				AH.find(currentSection, '.ebook_item_text', { action: 'attr', actionData: { id: "" } });
				previousData = previousData.innerHTML;
				let currentData = currentSection.innerHTML;

				//let getPreviousData = currentSection.nextElementSibling.getAttribute("id");
				//let getCurrentData = currentSection.getAttribute("id");
				if (AH.find(currentControl, ".verticle_timeline2", 'all').length > 0) {
					previousData = previousData.replace(/<main[\s\S]*<\/main>/gm, '');
					currentData = currentData.replace(/<main[\s\S]*<\/main>/gm, '');
				}

				AH.select(currentSection, 'html', '');
				AH.select(currentSection, 'html', previousData);
				AH.select(currentSection.nextElementSibling, 'html', currentData);
				AH.select('.remove_me').remove?.();

				setTimeout(
					() => {
						ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
					},
					300
				);
			} else {
				AH.alert?.("It's last element", 4, true);
			}
		});

		AH.listen(document, 'click', '.Timeline', function () {
			let divSlide = document.querySelectorAll('#slide, .slide_data');
			let slideNo = 1;

			AH.listen(document, 'click', '.prev', function (_this) {
				let select = _this.parentElement;
				let totChild = select.getElementsByTagName("section");

				for (let i = 0; i < totChild.length; i++) {
					if (totChild[i].getAttribute('class').indexOf('active') != -1) {
						slideNo = i + 1;
					}

					totChild[i].querySelector('br').remove();
				}

				let current = select.querySelector('.active');
				let prevEl = current.previousElementSibling.getElementsByTagName('section');

				if (slideNo === totChild.length || slideNo > 1) {
					AH.toggleDom(select.querySelector(".next"), 'show');

					if (prevEl.length == 1) {
						prevEl = current.parentElement;
						current.classList.remove('active');
						current.classList.add('hideClass');
						prevEl.classList.add('active');
						prevEl.classList.add('animated');
						prevEl.classList.add('fadeInLeft');
						prevEl.classList.remove('hideClass');
					}
				} else {
					AH.toggleDom(select.querySelector(".prev"), 'hide');
				}
			});

			AH.listen(document, 'click', '.next', function (_this) {
				let select = _this.parentElement;
				let totChild = select.getElementsByTagName("section");

				for (let i = 0; i < totChild.length; i++) {
					if (totChild[i].getAttribute('class').indexOf('active') != -1) {
						slideNo = i + 1;
					}

					totChild[i].querySelector('br').remove?.();
				}

				//totChild.children('br').remove();
				let current = AH.findChild(select, '.active');

				let prevEl = AH.nextElm(current, 'section');

				if (slideNo === 1 || slideNo < totChild.length) {
					select.children(".prev").show();

					if (prevEl.length == 1) {
						prevEl = current.next();
						current.classList.remove('active');
						current.classList.add('hideClass');
						prevEl.classList.add('animated');
						prevEl.classList.add('fadeInRight');
						prevEl.classList.add('active');
						prevEl.classList.remove('hideClass');
					}
				} else {
					AH.findChild(select, ".next").hide();
				}
			});
		});
	}

	// Bind events for content
	function initEditorListeners() {
		AH.listen('body', 'shown.bs.tab', '.specialPaste a[data-bs-toggle="tab"]', switchSpecialPaste.bind(this));

		AH.bind('#show_guid', 'click', event => {
			let range = document.createRange();
			range.selectNode(document.getElementById("show_guid"));
			window.getSelection().removeAllRanges(); // clear current selection
			window.getSelection().addRange(range); // to select text
			document.execCommand("copy");
			window.getSelection().removeAllRanges();
			event.target.setAttribute("data-bs-original-title", "ID Copied");
			AH.getBS(event.target, 'Tooltip', { container: 'body' }).show();
		});

		document.body.addEventListener('click', e => {
			AH.selectAll('.image_popover[data-bs-toggle="popover"]').forEach(_this => {
				if (!_this.isSameNode(e.target) && _this.contains(e.target) && AH.hasInall('.popover', e.target).length === 0) {
					AH.getBS(_this, 'Popover').hide();
				}
			});
		});

		AH.listen("#stem", 'keyup', 'div[data-section*="sec_button"],div[data-section*="sec_button_new"]', _this => {
			if (_this.querySelectorAll('.addnext_caption').length > 0) {
				let val = _this.querySelector('.addnext_caption').textContent.trim() == ''
				? 'Next'
				: _this.querySelector('.addnext_caption').textContent.trim();

				AH.find(_this, '.uc_step_explanation', {
					action: 'attr',
					actionData: { 'data-btnnme': val }
				});
			}
		});

		AH.listen("#content", 'keyup', 'div[data-section*="sec_button"],div[data-section*="sec_button_new"]', _this => {
			if (_this.querySelectorAll('.addnext_caption').length > 0) {
				let val = _this.querySelector('.addnext_caption').textContent.trim() == ''
				? 'Next'
				: _this.querySelector('.addnext_caption').textContent.trim();

				AH.find(_this, '.uc_step_explanation', {
					action: 'attr',
					actionData: { 'data-btnnme': val }
				});
			}
		});

		AH.listen('body', "click", '#publish_chbox_all', _this => {
			AH.select('.course_list_action input[type="checkbox"]').checked = _this.checked;
		});

		AH.listen('body', 'click', '#authoringDiv player,#authoringDiv snt,#authoringDiv seq,#authoringDiv .link', function (_this) {
			try {
				player_parent = AH.parent(_this, ".auth-editor").getAttribute("id");

				if (_this.classList.contains('hidecontent') || _this.closest("#stemShow, #remediationShow")) {
					return false;
				}

				if (_this.parentElement.getAttribute('id') != 'authoringArea') {
					$$invalidate(4, state.playebrArr = [], state);
					let bookmark = tinyMCE.activeEditor.selection.getBookmark(2, true);

					Array.prototype.forEach.call(_this.attributes, playerAttr => {
						if (playerAttr && playerAttr.specified) {
							$$invalidate(4, state.playerArr[playerAttr.name] = playerAttr.value, state);
						}
					});

					if (_this.getAttribute('type') == 'playground' || _this.classList.contains('link')) {
						$$invalidate(4, state.playerArr['playground'] = _this.textContent, state);
					}

					$$invalidate(4, state.playerArr['obj'] = _this, state);
					$$invalidate(4, state.playerArr['bookmark'] = bookmark, state);
					$$invalidate(4, state.playerState = true, state);
					$$invalidate(4, state.playerPopup = true, state);
				}
			} catch(err) {
				console.log("Error in Player update", err);
			}
		});

		AH.listen(document, 'click', '.panel-controls__change-type', _this => {
			swapPanel(_this);
		});

		AH.listen(document, 'click', '#preview player', _this => {
			if (_this.getAttribute('type') != 'exhibit') {
				renderPlayer();
			}
		});

		AH.listen(document, 'click', '.panel-controls__duplicate', _this => {
			let _this_section = _this.closest('.uc_step');
			let cloned_this_section = _this_section.cloneNode(true);
			AH.find(cloned_this_section, '.controls_button', { action: 'remove' });
			AH.insertAfter(cloned_this_section, _this_section);

			AH.bind(cloned_this_section, 'mouseenter', event => {
				const _this = event.target;
				let control_panel = ucStepContolPanel;

				if (AH.find(_this, '.controls_panel_button', 'all').length == 0) {
					AH.insert(_this.closest('.uc_step'), control_panel, 'afterbegin');
				}
			});

			AH.bind(cloned_this_section, 'mouseleave', event => {
				//element that has gained focus while enterting the edit buttons group
				const _this = event.target;

				if (!_this.closest('.uc_step').querySelector('.controls_panel_button')) {
					return;
				}

				AH.selectAll('.controls_panel_button', 'remove');
			});
		});

		AH.listen(document, 'click', '.panel-controls__remove', _this => {
			let parent_tinymce_id = AH.parent(_this, ".tinymce-editor");

			if (_this.closest('.uc_step_explanation').querySelectorAll('.uc_step').length != 1) {
				_this.closest('.uc_step').remove();
				setContent(parent_tinymce_id.getAttribute("id"));
			}
		});

		AH.bind('#authoringLoadComponent', 'click', () => {
			if (!AH.get('save_item')) {
				AH.set('save_item', editor.save == 1 ? true : false);
			}
		});
	}

	function refreshEvents() {
		if (uc_image_annotate) {
			uc_image_annotate.bindMulti();
		}

		AH.listenAll('#authoringSection .uc_step', 'mouseenter', event => {
			const _this = event.target;
			let control_panel = ucStepContolPanel;

			if (AH.find(_this, '.controls_panel_button', 'all').length == 0) {
				AH.insert(_this.closest('.uc_step'), control_panel, 'afterbegin');
			}
		});

		AH.listenAll('#authoringSection .uc_step', 'mouseleave', event => {
			//element that has gained focus while enterting the edit buttons group
			const _this = event.target;

			if (!_this.closest('.uc_step').querySelector('.controls_panel_button')) {
				return;
			}

			AH.selectAll('.controls_panel_button', 'remove');
		});

		AH.bind('#show_guid', 'mouseenter', event => {
			AH.setCss(event.target, { cursor: 'pointer' });
			event.target.setAttribute("data-bs-original-title", "Tap to copy");
			AH.getBS(event.target, 'Tooltip', { container: 'body' }).show();
		});

		AH.listenAll('.controls_panel_button', 'mouseleave', event => {
			event.target.remove();
			AH.toggleDom('.tooltip', 'hide');
		});

		// For accordion controls-----
		AH.listenAll('#authoringSection section[nd="1"] header', 'mouseenter', event => {
			let _this = event.target;
			var control_panel = '<main data-remove="true" contenteditable="false" class="controls_panel_button" style="height:1px;outline:none;float:right;margin-top:8px"><div class="panel-controls" style="opacity:1;position:relative;"><div class="panel-controls__container"><div class="panel-controls__bar"><div style="border-radius: 2.3rem;border: 1px solid rgba(49,53,55,.2);background:#FFF8DC;padding:6px 0" class="panel-controls__tools"><div><a class="panel-controls__duplicate" data-bs-toggle="tooltip" title="Add"><i class="icomoon-file-plus-2"></i></a></div><div><a class="panel-controls__change-type" data-bs-toggle="tooltip" title="Swap"><i class="icomoon-tab"></i></a></div><div><a class="panel-controls__remove" data-bs-toggle="tooltip" title="Remove"><i class="icomoon-24px-delete-1"></i></a></div></div></div></div></div></main>';

			// let e = event.relatedTarget || event.toElement;
			let controlsAcc = AH.find(_this.closest('section[nd="1"]'), '.controls_panel_button', 'all');

			if (controlsAcc.length == 0) {
				AH.insert(_this.closest('section[nd="1"]'), control_panel, 'afterbegin');

				AH.listen(document, 'click', '.panel-controls__duplicate', function (_this2) {
					let _this_section = _this2.closest('section[nd="1"]');
					AH.find(_this_section, ".ebook_item_text", { action: 'attr', actionData: { id: "" } });
					let cloned_this_section = AH.clone(_this_section);
					if (cloned_this_section.querySelector('.controls_button')) cloned_this_section.querySelector('.controls_button').remove();
					cloned_this_section.querySelector('article').removeAttribute('style');
					AH.insertAfter(cloned_this_section, _this_section);
					initEbookInteractivity();
					setContent(AH.parent(_this2, ".tinymce-editor").getAttribute("id"), 'refresh');
					ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
				});

				AH.listen(document, 'click', '.panel-controls__remove', function (_this3) {
					let parent_tinymce_id = AH.parent(_this3, ".tinymce-editor");

					if (_this3.closest('.drop_list').querySelectorAll('section[nd="1"]').length != 1) {
						_this3.closest('section[nd="1"]').remove();
						setContent(parent_tinymce_id.getAttribute("id"));
					}
				});
			}
		});

		AH.listenAll('#authoringSection section[nd="1"] header', 'mouseleave', event => {
			let _this = event.target;
			let e = event.relatedTarget || event.toElement;
			let removeON = ['SECTION', 'ARTICLE'];

			//element that has gained focus while enterting the edit buttons group
			if (removeON.includes(e?.tagName)) {
				AH.selectAll('.controls_panel_button', 'remove');
			}
		});

		// --- end accordion contorl ----//
		// leve on timelines
		AH.listenAll('#authoringSection div[type="timeline"] section, #authoringSection div[type="slideshow"] section, #authoringSection [data-parent="parent_element"]', 'mouseleave', event => {
			AH.find(event.target, ".remove_me", { action: 'remove' });
			AH.selectAll('.copyData, .removeData, .downData, .swapData', 'css', { outline: 'none' });
			AH.toggleDom('.tooltip', 'hide');
		});

		// Enter on timelines
		AH.listenAll('#authoringSection div[type="timeline"] section, #authoringSection div[type="slideshow"] section,  #authoringSection [data-parent="parent_element"]', 'mouseenter', event => {
			let data;
			let currentTarget = event.target;

			if (AH.find(currentTarget, ".remove_me", 'all').length > 0) {
				AH.find(currentTarget, ".remove_me", { action: 'show' });
			} else {
				let right_pos = `right: ${currentTarget.getAttribute("data-right")}px;`;

				if (currentTarget.parentElement.querySelectorAll(".verticle_timeline2").length > 0) {
					right_pos = AH.domIndex(currentTarget) % 2 != 0
					? "right: " + currentTarget.getAttribute("data-right") + "px;"
					: "left: " + currentTarget.getAttribute("data-right") + "px;";
				}

				data = `<main data-remove='true' class='timeline_controls remove_me text-center' style='outline: none; position: ${currentTarget.getAttribute("data-position")}; top: ${currentTarget.getAttribute("data-top")}px;bottom: ${currentTarget.getAttribute("data-bottom")}px; ${right_pos}; float: ${currentTarget.getAttribute("data-float")}; left: ${currentTarget.getAttribute("data-left")}px;height: 32px; width: 155px;' contenteditable='false' class='buttonOpacity main_cont'><div contenteditable='false' class='swapData text-center rounded-circle bg-warning position absolute' style='left: 4px;' data-bs-toggle='tooltip' data-bs-original-title="${currentTarget.getAttribute('data-arrow') == '2'
				? 'MoveLeft'
				: 'MoveUp'}">${currentTarget.getAttribute('data-arrow') == '2'
				? '&#x2190'
				: '&#x2191'}</div><div contenteditable='false' class='downData text-center rounded-circle bg-warning position absolute' style='left: 42px;' data-bs-toggle='tooltip' data-bs-original-title="${currentTarget.getAttribute('data-arrow') == '2'
				? 'MoveRight'
				: 'MoveDown'}">${currentTarget.getAttribute('data-arrow') == '2'
				? '&#x2192'
				: '&#x2193'}</div><div contenteditable='false' class='copyData text-center rounded-circle bg-warning position absolute' style='left: 80px; ' data-bs-toggle='tooltip' data-bs-original-title='Add'>&#10010</div><div contenteditable='false'  class='removeData text-center rounded-circle bg-warning position width30 absolute' style='left: 119px;' data-bs-toggle='tooltip' data-bs-original-title='Delete'>&#10006</div></main>`;

				switch (currentTarget.getAttribute("ctrl-container")) {
					case 'child_prep':
						{
							AH.insert(AH.find(currentTarget, "[data-child='child_element']"), data, 'beforeend');
							break;
						}
					case 'child_app':
						{
							AH.insert(currentTarget.querySelector("[data-child='child_element']"), data, 'beforeend');
							break;
						}
					default:
						{
							AH.insert(currentTarget, data, 'afterbegin');
						}
				}
			}
		});

		activateEditor(200);
	}

	// XMl formatting
	function formatXmlRef(xml, type) {
		if (Items && Items.UI.doNotformatXml) {
			return typeof Items.UI.doNotformatXml == "function"
			? Items.UI.doNotformatXml(type, xml)
			: xml;
		} else {
			return formatXml(xml);
		}
	}

	//Method to manage keydown events
	function handleKeydown(e) {
		if (e.ctrlKey && e.altKey && e.keyCode == 40) {
			cursorPosition = e.target.closest('div[data-section]');

			if (!cursorPosition[0]) {
				cursorPosition = e.target.closest('section[data-section]');
			}
		}
	}

	// Method to handle add new section
	function openItems() {
		AH.getBS('#interactive_items', 'Modal').show();
		_interactiveItem.createItems();

		AH.listen(document, "click", ".modal-backdrop", function () {
			AH.getBS('#interactive_items', 'Modal').hide();
		});

		AH.listen(document, "click", ".left_second", function (_this, e) {
			if (_this.classList.contains("modal-content") || _this.classList.contains("modal_items")) {
				return;
			}

			AH.getBS('#interactive_items', 'Modal').hide();
		});
	}

	// Mehtod to handle keyup events
	function handleKeyup(e) {
		if (preview_edit != 1 && e.ctrlKey && e.altKey) {
			switch (e.keyCode) {
				case 83:
					//Save case
					console.warn("Save Action");
					$$invalidate(4, state.saveDialog = true, state);
					break;
				case 84:
					switchTabs();
					break;
				case 80:
					//Previous case
					editorHeaderRef.checkNavigation(false);
					break;
				case 78:
					//Next case
					editorHeaderRef.checkNavigation(1);
					break;
				case 76:
					//List case
					editorHeaderRef.onItemListButton();
					break;
				case 187:
					AH.set('filter_item', false);
					openItems();
					break;
				case 67:
					//ctrl+alt+c , format in code tag
					try {
						tinymce.activeEditor.formatter.register('codeformat', {
							inline: 'code',
							remove: 'all',
							styles: { display: "inline" }
						});

						tinymce.activeEditor.execCommand("mceToggleFormat", false, "codeformat");
					} catch(e) {
						console.warn("It Seems you have not selected any text to wrap into code tag.");
					}
					break;
				case 86:
					//ctrl+alt+v , show paste special dialog box
					try {
						handlePasteSpecial();
					} catch(e) {
						console.warn("Something went wrong during paste", e);
					}
					break;
				case 72:
					//ctrl+alt+h , show help/keyboard dialog box
					try {
						$$invalidate(10, modal = {
							header: {
								body: l$1.keyboard_shortcut,
								class: "editor_modal_title"
							},
							body: {
								body: editorConfig.keyboardShortcutLayout(),
								class: "editor_modal_content",
								style: "height: 300px;"
							},
							footer: { body: [], class: "editor_modal_action" },
							width: 500
						});

						handleModal(modal);
					} catch(e) {
						console.warn("Failed to open keyboard shortcut dialog", e);
					}
					break;
			}
		}
	}

	// Switching in special paste dialog
	function switchSpecialPaste(event) {
		$$invalidate(4, state.radioValue = event.getAttribute('action') || 'plain', state);
	}

	// Mange special paste dilaog 
	function handlePasteSpecial() {
		$$invalidate(4, state.radioValue = 'plain', state);

		$$invalidate(10, modal = {
			header: {
				body: "Paste with Formatting",
				class: "editor_modal_title"
			},
			body: {
				body: `<div>
					<ul class="nav nav-tabs editorTabs specialPaste">
						<li><a data-bs-toggle="tab" href="#plain" class="active" action="plain">Plain</a></li>
						<li><a data-bs-toggle="tab" href="#formatted" action="formatted">Formatted</a></li>
					</ul>
					<div class="tab-content editorTabContent">
						<div id="plain" class="tab-pane fade in active">
							<textarea class="w-100 border border-dark" style="resize: none;" id="plainText" rows="9" cols="100"></textarea>
						</div>
						<div id="formatted" class="tab-pane fade">
							<div class="w-100 overflow-auto border border-dark" style="height: 200px;background: #fff;" id="formattedText" contenteditable="true"></div>
						</div>
					</div>
				</div>`,
				class: "editor_modal_content"
			},
			footer: {
				body: [{ label: 'Ok', onAction: pasteSpecialFunc }],
				class: "editor_modal_action"
			},
			width: 500
		});

		handleModal(modal);
	}

	// Handle paste action
	function pasteSpecialFunc() {
		try {
			handleModal();
			let data = "";
			let filterAttr = ['class', 'id', 'style'];

			if (state.radioValue == 'plain') {
				data = AH.select('#plainText').value;
				data = "" + data.replace(/\</g, "&lt;").replace(/\>/g, "&gt;").replace(/ /g, "&#160;").replace(/\n/g, "<br>") + "";
			} else if (state.radioValue == 'formatted') {
				data = document.getElementById('formattedText').innerHTML;

				filterAttr.forEach(function (attr) {
					let regx = new RegExp(` ${attr}="([^"]*?)"`, 'gi');
					data = data.replace(regx, '');
				});
			}

			ucEditor.insertContent(data, 'raw');
		} catch(e) {
			console.log({
				Error: e.name,
				Line: 4003,
				File: "smeditor.js"
			});
		}
	}

	// Mange SaveXMl dialog
	function saveXML() {
		//doesConnectionExist();
		$$invalidate(4, state.saveDialog = true, state);

		if (state.domain.length != 5) {
			AH.toggleDom('#saveAs', 'hide');
		}
	}

	// CHeck stem is required
	function doNotShowStem() {
		if (state.inline_item == "1") {
			AH.toggleDom("#stem, #remediation, #remedToggle", 'hide');
		}
	}

	// Update Item xml and init algo
	async function setModule(DXML) {
		doNotShowStem();

		if (state.viewConfig.isQuestion) {
			$$invalidate(4, state.xml = DXML, state);
		}

		await initializeAlgo();
		didMount();
	}

	// Algo Initializtion
	function initializeAlgo() {
		return new Promise(resolve => {
				var algo_qxml = state.algo_qxml;

				if (algo_qxml == '') {
					let algo_str = 'var1=algo_randInt(6,10)\nvar2=5\nvar3=algo_current("var1")+2\nvar4=algo_randInt(1,10)\nvar5=algo_randInt(2,20)';
					let algo = algo_str.split('\n');
					$$invalidate(4, state.single_variables = algo, state);
				} else {
					algo_qxml = algo_qxml.replace(/<br \/>/g, "");

					setTimeout(
						() => {
							$$invalidate(4, state.algo_qxml = algo_qxml, state);
						},
						500
					);

					algo_qxml = algo_qxml.replace("<algostatic>", "");
					algo_qxml = algo_qxml.replace("</algostatic>", "");
					let algo = algo_qxml.split('\n');

					//algo.pop();
					$$invalidate(4, state.variable_button = true, state);

					$$invalidate(4, state.single_variables = algo, state);
				}

				resolve(true);
			});
	}

	// Hnadle External Review mode
	function externalToggle() {
		setTimeout(
			function () {
				renderPlayer();
				const fullModeHide = AH.find('body', '.controls_button, .full_mode_hide', 'all');

				if (fullModeHide && fullModeHide.length > 0) {
					fullModeHide.forEach(ele => {
						const nextEle = ele.nextElementSibling;

						if (nextEle.querySelectorAll("player").length == 0 && nextEle.textContent.trim() == "Edit" || nextEle.textContent.trim() == "") {
							ele.style.visibility = 'visible';
						}
					});
				}
			},
			500
		);

		if (state.item == '32' && document.getElementById("authoringFrame").getAttribute('data-authoring') == '1') {
			try {
				document.getElementById("authoringFrame").contentWindow.getData();

				if (document.getElementById("authoringFrame").contentWindow.returnFalse == 1) {
					return;
				} else {
					$$invalidate(4, state.toggleMode = !state.toggleMode, state);
				}
			} catch(e) {
				
			}
		} else {
			$$invalidate(4, state.toggleMode = !state.toggleMode, state);
		}
	}

	// Manage tab switching of editor
	function editorPaneShow(event) {
		{
			externalToggle();
		}

		if (event.target.getAttribute('href') == "#authoringDiv") {
			$$invalidate(4, state.remediationToggle = false, state);
			AH.toggleDom("#device_btn", 'hide');
			$$invalidate(4, state.editorView = 'authoring', state);
		} else {
			AH.toggleDom("#device_btn", 'show');
			let currentRefreshFunc = AH.get(state.content_type + "_refresh");

			if (currentRefreshFunc) {
				currentRefreshFunc();
			}

			// Render equation
			activateMathMl(state.stem + state.remediation + state.content, state.variable_button, mathMLRender);

			$$invalidate(4, state.editorView = 'preview', state);
		}
	}

	// Setup tinymce controls config and data init
	function setupEditor(urlVars) {
		window.parent.edit_content = 0; // For editor
		AH.set('save_item', false);
		window.mm = mathMLRender;

		//document.querySelector('a[data-bs-toggle="tab"]').addEventListener('shown.bs.tab', editorPaneShow.bind(this));
		AH.listenAll('#edi_tabs a[data-bs-toggle="tab"]', 'shown.bs.tab', editorPaneShow.bind(this));

		if (in_frame && new_title != '' && new_guid != '') {
			editorConfig.setParentData(new_guid, urlVars['content_subtype']);
		}

		AH.toggleDom(".activator, .footerstr, .tooltip", 'hide');
		let tinymce_editor = document.querySelector(".tinymce-editor");

		if (tinymce_editor) {
			tinymce_editor.addEventListener("click", function () {
				tinyMCE.activeEditor.focus();

				if (!AH.get('editorActivated')) {
					activateEditor(100, true);
				}
			});
		}

		if (in_frame == 1 && (state.guid || ("s,f").includes(state.content_type))) {
			AH.toggleDom(AH.select('.backBtn').parentElement, 'hide');
		}

		if (from_coverage_edit) {
			AH.toggleDom(".editor_close", 'hide');
		}

		if (preview_edit != 1) {
			if (in_frame != 1 && document.getElementById('authoringDiv').clientWidth > 360) {
				AH.setCss(document.getElementById("toolbar_container"), { visibility: "visible" });
			}

			tinyMCE.PluginManager.add('addnewsection', function (editorPlugin) {
				editorPlugin.addMenuItem('addnew', {
					icon: 'mytextwithicon',
					text: 'Add New',
					context: "tools",
					onClick() {
						cursorPosition = document.querySelector(`#${tinymce.activeEditor.id}`);
						AH.set('filter_item', false);

						if (cursorPosition.getAttribute('id').startsWith('option')) {
							cursorPosition = false;
							AH.set('filter_item', 'code-block');
						} else if (!cursorPosition.getAttribute('data-section')) {
							cursorPosition = cursorPosition.closest('div[data-section]');

							if (!cursorPosition[0]) {
								cursorPosition = cursorPosition.closest('section[data-section]');
							}
						}

						openItems();
					}
				});
			});

			tinyMCE.PluginManager.add('placeholder', function (editor) {
				editor.on('init', function () {
					let elem = editor.getElement();
					if (!elem) return;

					let wrapper = AH.parent(elem, ".tinymce-editor")
					? AH.parent(elem, ".tinymce-editor")
					: elem;

					let placeHolder = wrapper.previousElementSibling;

					if (placeHolder && wrapper.querySelectorAll("player").length == 0 && (wrapper.textContent == "" || wrapper.textContent == "Edit")) {
						AH.setCss(placeHolder, { visibility: 'visible' });
					}
				});

				editor.on('focus', function () {
					let childDom = editor.getElement();

					if (childDom && childDom.getAttribute('id') != 'title') {
						childDom = AH.parent(childDom, ".tinymce-editor");
					}

					if (!childDom) return;
					let placeHolder = childDom.previousElementSibling;

					if (childDom.textContent.trim() != "" || childDom.textContent != "Edit") {
						AH.setCss(placeHolder, { visibility: 'hidden' });
					}
				});

				editor.on('blur', function () {
					let childDom = editor.getElement();

					if (childDom && childDom.getAttribute('id') != 'title') {
						childDom = AH.parent(childDom, ".tinymce-editor");
					}

					if (!childDom) return;
					let placeHolder = childDom.previousElementSibling;

					if (childDom.querySelectorAll("player").length == 0 && childDom.textContent.trim() == "Edit" || childDom.textContent.trim() == "") {
						placeHolder.style.visibility = 'visible';
					}
				});
			});

			tinyMCE.PluginManager.add('playertag', function (editorPlugin) {
				editorPlugin.addMenuItem('player', {
					text: "Embed",
					icon: 'mytextwithicon',
					context: "tools",
					onclick() {
						$$invalidate(4, state.playerArr = {}, state);
						let bookmark = tinyMCE.activeEditor.selection.getBookmark(2, true);
						$$invalidate(4, state.playerState = true, state);
						$$invalidate(4, state.playerBookmark = bookmark, state);
						$$invalidate(4, state.playerPopup = true, state);
					}
				});

				editorPlugin.on('keydown', function (e) {
					let currentNode = document.getElementById(e.target.id);

					if (currentNode.textContent.length < 2 && e.keyCode == 8) {
						e.preventDefault();
						e.stopPropagation();
						currentNode.innerHTML = '&nbsp;';
						return false;
					}
				});

				editorPlugin.on('change', function (e) {
					let currentNode = document.getElementById(e.target.id);

					if (currentNode) {
						if (currentNode.classList.contains("auth-editor")) {
							setContent(tinymce.activeEditor.id);
						} else {
							let authId = AH.parent(currentNode, ".auth-editor").getAttribute("id");
							setContent(authId);
						}

						toggleSave(editor.save);
					}
				});

				editorPlugin.on('click', function () {
					let authSection = document.getElementById('authoringSection');

					if (authSection.querySelectorAll(".list6_new").length > 0 || authSection.querySelectorAll(".list5_new").length > 0 || authSection.querySelectorAll(".list4_new").length > 0 || authSection.querySelectorAll(".list3_new").length > 0 || authSection.querySelectorAll(".list2_new").length > 0) {
						tinyMCE.activeEditor.undoManager.undo();
					}
				});
			});

			tinymce.EditorManager.editors = [];
			ucEditor.initEditor();
		}

		let tempHeight = from_myproject == "1"
		? window.parent.document.body.clientHeight
		: window.innerHeight;

		let calculatedHeight = tempHeight - tempHeight * 0.08 + 'px';

		AH.setCss("#editorViewPane", {
			minHeight: calculatedHeight,
			height: calculatedHeight
		});

		if (preview_edit != 1) {
			editorConfig.findMathError();
			checkSection();

			if (getQueryString('switch_preview') == 1) {
				if (AH.getBS('[href="#custom_columnize"]', 'Tab').hasOwnProperty('show')) {
					AH.getBS('[href="#custom_columnize"]', 'Tab').show();
				}
			}
		}

		activateMathMl(state.stem + state.remediation + state.content, state.variable_button, mathMLRender);

		AH.selectAll("#stem, #content, #remediation").forEach(_elm => {
			AH.watchDom(_elm, changes => {
				console.warn(changes);
				if (_editorBuffer['watchDom']) clearTimeout(_editorBuffer['watchDom']);
				_editorBuffer['watchDom'] = setTimeout(refreshEvents, 500);
			});
		});

		activateEditor(200, true);
	}

	// Section validation on edit
	async function checkSection() {
		console.warn("Section being Removing.");
		let sections = document.querySelectorAll('#authoringSection .sec_button, #authoringSection .sec_button_new');
		console.warn("Section Found = ", sections.length);

		if (sections.length > 0) {
			for (let item of sections) {
				await removeSection(item);
			}

			document.querySelectorAll('#authoringSection .sec_button, #authoringSection .sec_button_new').forEach(elm => elm.remove());
		}

		console.warn("Section checked...");
		AH.enableBsAll("[data-bs-toggle='tooltip']", 'Tooltip', { container: 'body' });
		await tick();
	}

	// Init tinymce plugin
	function activateEditor(timer = 100, ignore = false) {
		if (AH.get('editorActivated')) return true;
		if (editorBuffer['activateEditor']) clearTimeout(editorBuffer['activateEditor']);

		editorBuffer['activateEditor'] = setTimeout(
			() => {
				ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
				AH.remove('br[data-mce-bogus="1"]');
				AH.activate(0);
				editorConfig.mathMl('add', "", state);

				//jQuery('.load_data', window.parent.document).hide();
				AH.toggleDom(window.parent.document.querySelector(".load_data"), 'hide');

				if (!ignore) AH.set("editorActivated", true);
				console.warn("activated...");
			},
			timer
		);
	}

	// Create content contorls
	function setInitialButton() {
		return editorConfig.controls('text') + `<div data-section="sec_button" type='ebook-item' sub_type='text' class='ebook_item_text'></div>`;
	}

	// analyze content to add wrapper
	function keepAnalyzeData(content) {
		if (document.getElementById('content section')) {
			content = document.querySelector('#content section .ebook_item_text').innerHTML;
		}

		if (content) {
			content = content.replace('<node>', '').replace('</node>', '');
		}

		$$invalidate(4, state.oldStemData = content, state);
	}

	// check whole content to add controls and missed wrapper
	function initAddFeature(title, stem, remediation, content) {
		let sectionList = editorConfig.initAddFeatureSelector(stem, remediation, content);
		let filter = content ? "#content" : "#stem,#remediation";

		//console.warn(filter, "initAddFeature called");
		//Future code for automatic init
		for (let key in sectionList) {
			//console.warn({[key]:filter.includes(key)});
			if (filter.includes(key)) {
				let container = `#authoringSection ${key}`;

				let innerSelector = (document.querySelector(container)?.querySelector(editorConfig.eBookItemTypeOld))
				? editorConfig.eBookItemTypeOld
				: editorConfig.eBookItemType;

				let sectionData = sectionList[key];
				let findSection = `${innerSelector} .ebook_item_text`;

				if (AH.find(container, findSection, 'all').length == 0 || editorConfig.shouldWrap(container)) {
					//console.warn("Warapping");
					content ? keepAnalyzeData(content) : "";

					if (sectionData.data) {
						let wrapped = editorConfig.getSection(sectionData.data, sectionData.inline, key);

						//sectionData.store[sectionData.holder] = wrapped;
						$$invalidate(4, state[sectionData.holder] = wrapped, state);

						if (sectionData.copyInto) $$invalidate(4, state[sectionData.copyInto] = sectionData.data, state);

						//self.setState(sectionData.store);
						AH.select(key).innerHTML = wrapped;
					} else {
						AH.select(key).innerHTML = setInitialButton(sectionData.holder);
					}
				} else {
					content ? keepAnalyzeData(sectionData.data) : "";
				}

				if (AH.find(container, innerSelector).length > 0) {
					//console.warn("Adding Controls");
					document.querySelector(container).querySelectorAll(innerSelector).forEach(function (_this, index) {
						AH.insert(_this, editorConfig.controls(_this.getAttribute('sub_type')), 'beforebegin');

						if (index == 0 && sectionData.inline && !_this.classList.contains(sectionData.inline)) {
							_this.classList.add(sectionData.inline);
						}
					});

					callInlineEditor(key);
				}
			}
		}
	}

	// check whether init editor needed
	function callInlineEditor(where) {
		if (document.querySelector("#authoringSection " + where + " .ebook_item_text").classList.contains("mce-content-body")) {
			editCount++;
		} else {
			if (editCount < 100) {
				setTimeout(
					function () {
						editCount++;
						setInlineEditor(where);
						callInlineEditor(where);
					},
					200
				);
			}
		}
	}

	// Enabale editor if anything not editable
	function setInlineEditor(where) {
		document.querySelectorAll("#authoringSection " + where + " .ebook_item_text").forEach(function (item) {
			item.setAttribute("id", "");
		});

		ucEditor.initEditor(false, "#authoringSection " + where + " .ebook_item_text");
	}

	// Update if ebook content coming from parent side
	function updateEbookContent() {
		if (in_frame && new_title != '') {
			$$invalidate(4, state.title = new_title, state);
			document.querySelector("#title, #title_show").innerHTML = new_title;
		}

		if (ebook_flashTitle != '' || ebook_flashContent != '') {
			//setTimeout(function () {
			$$invalidate(4, state.title = ebook_flashTitle, state);

			$$invalidate(4, state.content = ebook_flashContent, state);
			AH.selectAll("#title, #title_show", 'html', ebook_flashTitle);
			AH.selectAll("#content, #content_show", 'html', editorConfig.getSection(ebook_flashContent, '#content'));

			setTimeout(
				function () {
					ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
				},
				200
			);
		} //}, 1000);
	}

	// select suitable class for sections
	function editorClass() {
		if (Items.UI && Items.UI.isHideForContentIcon && Items.UI.isHideForContentIcon == +state.content_icon) {
			return "h";
		} else {
			return "tinymce-editor auth-editor";
		}
	}

	// Check snt and preview
	function previewSnt(content) {
		let sntTag = content ? content.match(/<snt(.*?)<\/snt>/gmi) : "";

		if (sntTag) {
			for (let i in sntTag) {
				let refid = sntTag[i].match(/refid="(.*?)"/gmi);
				refid = refid[0] ? refid[0].replace(/refid=|"/gmi, '') : "";

				if (state.sntTags[refid]) {
					content = content.replace(sntTag[i], state.sntTags[refid] + "</div><div style=background-Color:#fff>");
				}
			}
		}

		return content;
	}

	// Adding event for intractive layouts
	function interactiveEditor() {
		AH.listen(document, 'click', '.save_xml_btn', function (_this, event) {
			if (_this.getAttribute('action') == "none") return;
			var isOnOpenSave = Items && Items.UI.onOpenSave;

			if (isOnOpenSave && Items.UI.onOpenSave(state)) {
				$$invalidate(10, modal = {
					header: {
						body: 'Warning',
						class: "editor_modal_title"
					},
					body: {
						body: "You haven't changed the database name, do you wish to continue?",
						class: "editor_modal_content"
					},
					footer: {
						class: "editor_modal_action",
						body: [
							{
								'label': 'Yes',
								onAction: () => {
									handleModal();
									updateModuleState('db_changed', true);
									saveXML();
								}
							}
						]
					},
					width: 300
				});

				handleModal(modal);
				return 1;
			}

			AH.set('save', true);

			if (_this.getAttribute('action')) {
				saveAction(event, _this.getAttribute('action'), "skip");
			} else {
				saveXML();
			}
		});

		if (!AH.get('isAjax')) {
			AH.selectAll("#content, #stem, #remediation", 'html', setInitialButton());
		}

		AH.listen(document, 'click', '.modal_items .item_int', function (_this) {
			//@pradeep: this event will call when we select anyting from sidepane.
			AH.getBS("#items_list", 'Modal').hide();

			let insertHtml = editorConfig.controls(_this.getAttribute('data-type')) + editorConfig.getSection(_this);

			if (cursorPosition) {
				AH.insert(cursorPosition, insertHtml, 'afterend');
				setContent(AH.parent(cursorPosition, ".auth-editor").getAttribute("id"));
			} else {
				ucEditor.insertContent(insertHtml);
			}

			initEbookInteractivity();
			AH.getBS("#interactive_items", 'Modal').hide();
			ucEditor.initEditor(false, "#authoringSection .ebook_item_text");

			if (!AH.get('save_item')) {
				AH.set('save_item', editor.save == 1 ? true : false);
			}

			AH.enableBsAll("[data-bs-toggle='tooltip']", 'Tooltip', { container: 'body' });
		});

		interactiveEvents();
	}

	function editorModalUpdate(status) {
		$$invalidate(4, state.editorModalHandle = status, state);
	}

	function smValidate(_this) {
		if (state.skipValidation == false) {
			if (_this && _this.error == true) {
				//self.setState({errMessage:_this.message});
				$$invalidate(4, state.errMessage = _this.message, state);

				$$invalidate(10, modal = {
					header: {
						body: "Warning",
						class: "editor_modal_title .bg-light"
					},
					body: {
						body: "More than 6 options may cause this item to not render properly on a smartphone",
						class: "editor_modal_content",
						style: { height: '300' }
					},
					footer: {
						class: "editor_modal_action",
						body: [
							{
								'label': 'Do not show again',
								onAction: () => {
									handleModal();
									editorModalUpdate(false);
									updateModuleState('skipValidation', true);
								}
							}
						]
					},
					maxWidth: 'sm'
				});

				editorModalUpdate(true);
				handleModal(modal);
			} else {
				console.log("Error in module on calling of smValidate", _this);
			}
		}
	}

	//reflect changes in preview
	function setContent(type, isRefresh) {
		player_parent && (player_parent = "");

		editorBuffer['lastAction']
		? clearTimeout(editorBuffer['lastAction'])
		: "";

		editorBuffer['lastAction'] = setTimeout(
			function () {
				let content = ucEditor.getContent(type, 'raw');

				if (AH.isValid(content)) {
					!changedKeys.includes(type) && changedKeys.push(type);
					content = replaceUnwantedTags(content, type);

					if (content.indexOf('contenteditable') > -1) {
						$$invalidate(4, state.message = "Something went wrong, your data may be in inaccurate while saving", state);
						$$invalidate(4, state.activate = true, state);
					}

					let typeSelector = document.querySelector(`#${type}_show`);
					if (typeSelector) typeSelector.innerHTML = previewSnt(get_ucsyntax(content));
					let previewSec = document.getElementById("previewSection");

					//@saquib added this line due to multiple rendering of prettyprint
					AH.removeClass(previewSec.querySelectorAll(".prettyprintReplica"), ["prettyprint", "linenums"]);

					content.match(/<uc:syntax/gm) ? prettyPrint() : '';
					AH.addClass(AH.find(previewSec, ".prettyprint", 'all'), "prettyprintReplica");
					AH.addClass(AH.find(previewSec, ".prettyprintReplica", "all"), ["prettyprint", "linenums"]);
					$$invalidate(4, state[type] = ucEditor.getContent(type, 'raw'), state);
					$$invalidate(4, state.player_render = true, state);
					editorConfig.mathMl('reset');
					editorConfig.mathMl('set');
				}

				if (isRefresh) {
					editorBuffer['isRefresh'] && clearTimeout(editorBuffer['isRefresh']);
					editorBuffer['isRefresh'] = setTimeout(refreshEvents, 500);
				}
			},
			200
		);
	}

	// method to get xml from frame based compoenents
	function getXml(forSave = 0) {
		try {
			let authFrame = document.getElementById("authoringFrame");

			if (authFrame && authFrame.getAttribute('data-authoring') == '1') {
				let frameNode = authFrame.contentWindow;
				$$invalidate(4, state.activator = true, state);

				editorBuffer['iframe'] = setTimeout(
					function () {
						if (Items.UI.getXmlFunc) {
							$$invalidate(4, state.xml = frameNode[Items.UI.getXmlFunc](), state);
						} else {
							$$invalidate(4, state.xml = Items.UI.getXml(frameNode, state.xml, state.item), state);
						}

						$$invalidate(4, state.activator = false, state);
					},
					100
				);
			}
		} catch(e) {
			console.log(e);
		}

		if (forSave != 1) {
			setTimeout(
				function () {
					$$invalidate(4, state.xmlDialog = true, state);
				},
				100
			);
		}
	}

	// Update framebased and item xmls
	function updateXml(e, moduleXMl = document.getElementById("xml_Dialog").value) {
		$$invalidate(4, state.xmlDialog = false, state);
		var newXml = XMLToJSON(moduleXMl);

		if (!newXml) {
			newXml = {
				"smxml": {
					"_type": AH.parseHtml(moduleXMl).getAttribute('type')
				}
			};
		}

		if (moduleXMl != state.xml) {
			AH.set('save_item', true);
		}

		($$invalidate(4, state.item = parseInt(newXml.smxml._type), state), $$invalidate(4, state.xml = moduleXMl, state));
	}

	// avoid re-updating
	function updateContent(id) {
		return new Promise((resolve, reject) => {
				try {
					setContent(id);

					var upConTimer = setTimeout(
						function () {
							clearTimeout(upConTimer);
							resolve(true);
						},
						400
					);
				} catch(error) {
					cosole.log({ error, func: '@3281' });
					reject(error);
				}
			});
	}

	// Solve algo varraibles
	async function solveVariable() {
		AH.activate(2);
		await updateContent("stem");
		await updateContent("remediation");

		//@TOOD: @abhishek we should also evaluate all the answers
		updateChildXml(state.xml + " ");

		$$invalidate(4, state.authXml = state.xml, state);

		setTimeout(
			function () {
				var data = {};
				data['question'] = document.getElementById("stem_show").innerHTML;
				data['special_module_xml'] = state.authXml;
				data['answers'] = state.ajaxData ? state.ajaxData.answers : "";
				data['explanation'] = state.remediation;
				data['algo_qxml'] = state.algo_qxml;

				AH.ajax({
					url: baseUrl + 'editor/index.php',
					cache: false,
					data: {
						ajax: "1",
						action: 'parse_algo',
						content_text: JSON.stringify(data)
					},
					type: 'post'
				}).then(response => {
					let res = JSON.parse(response);

					// used for get algo data in List Item module
					AH && AH.set('algo_var_data', res.algo_qxml);

					//@TOOD: @abhishek we got data from #stem but putting data in #stem_show also what about remdiateion and answers and xml
					document.getElementById("stem_show").innerHTML = res.question;

					document.getElementById("remediation_show").innerHTML = res.explanation;
					$$invalidate(4, state.stopAuthoringUpdate = true, state);
					state.mcqAjaxData && $$invalidate(4, state.mcqAjaxData.answers = res.answers, state);
					$$invalidate(4, state.xml = res.special_module_xml, state);
					$$invalidate(4, state.previewXml = state.xml, state);
					$$invalidate(4, state.stopAuthoringUpdate = false, state);
					$$invalidate(4, state.stopPreviewUpdate = true, state);
					typeof mathMLRender == "function" && mathMLRender("previewSection", true);

					//tempRemed = res.explanation;
					//state.xml = tempXml;
					AH.activate(0);
				});
			},
			200
		);
	}

	// Show analyzed algo varriable's data
	function analyzeVariable() {
		AH.activate(2);

		AH.ajax({
			url: baseUrl + 'editor/index.php',
			cache: false,
			data: {
				ajax: "1",
				action: 'parse_algo',
				get_variables: 1,
				algo_qxml: state.algo_qxml
			}
		}).then(response => {
			let res = JSON.parse(response);
			createVariableCallback.analyzeValues(res);
			AH.activate(0);
		});
	}

	// Handle algo change
	function handleCheckbox() {
		//state.variable_button = state.variable_button ? false : true;
		//if (state.variable_button) {
		// show algo task pane
		createVariableCallback.showPane();
	} //}

	// show editor dialog for algo
	function editAlgo() {
		createVariableCallback.showPane();
	}

	// Method for item side communication
	function updateChildXml(childXml, action = "") {
		if (action == "mcqType") {
			//state.ajaxData = childXml.ajaxData;
			$$invalidate(4, state.mcqAjaxData = JSON.parse(JSON.stringify(childXml.ajaxData)), state);
		} else if (action == "deepUpdate") {
			updateXml("", childXml);
		} else {
			$$invalidate(4, state.stopPreviewUpdate = false, state);
			$$invalidate(4, state.xml = childXml, state);
			window.QXML = state.xml;
		}
	}

	//check saving of content
	function saveAction(event, customAction, saveType) {
		var action = customAction ? customAction : event.target.value;
		AH.set('saveType', saveType);
		document.querySelectorAll(".save_buttons button").forEach(elm => elm.style.pointerEvents = 'none');

		switch (action) {
			case 'cancel':
				console.warn("cancel action");
				$$invalidate(4, state.saveDialog = false, state);
				editorHeaderRef.callPendingAction();
				break;
			case 'save':
				console.warn("Save action");
				if (AH.get('save')) {
					if (from_myproject == 1 && state.guid.length == 5 && state.course_list) {
						publishSelected();
					} else {
						saveData('0');
					}
				} else {
					updateStage();
					AH.alert("Item is not saved.");
				}
				break;
			case 'save_as':
				$$invalidate(10, modal = {
					header: {
						body: "Save As",
						class: "editor_modal_title"
					},
					body: {
						body: "Do you want to save current changes as new item?",
						class: "editor_modal_content"
					},
					footer: {
						body: [
							{
								label: 'Yes',
								onAction: saveData.bind(this, '1')
							}
						],
						class: "editor_modal_action"
					}
				});
				handleModal(modal);
				break;
			case 'reject':
				console.warn("Reject As action");
				changeStatusOnly(-1);
				break;
			default:
				console.log({
					Error: "Action not defined",
					action,
					func: "saveAction@3612"
				});
				break;
		}
	}

	// gather content and send to server for save
	function saveData(is_new, coverageCourses = false, saveCoverage = false) {
		//jQuery("span[data-mce-bogus]").contents().unwrap();
		AH.unwrap("[data-mce-bogus='1']");

		changedKeys.map(type => {
			$$invalidate(4, state[type] = ucEditor.getContent(type, 'raw'), state);
		});

		if (is_owner != 1 && is_viewer == 1) {
			$$invalidate(4, state.message = JSL.viewer_error_msg_js, state);
			$$invalidate(4, state.snackback = true, state);
			$$invalidate(4, state.saveDialog = false, state);
			return false;
		}

		if (is_domain == 1 && state.domain.length != 5 && (state.viewConfig.isQuestion || getQueryString("is_flashcard") == 1)) {
			if (from_coverage == "" && is_new != 1 && in_frame == "1") {
				$$invalidate(4, state.message = "Please select a domain.", state);
				$$invalidate(4, state.snackback = true, state);
				$$invalidate(4, state.domainToggle = true, state);
				$$invalidate(4, state.saveDialog = false, state);
				return;
			}
		}

		let reject = editorConfig.checkBlank(state, Items, updateModuleState);

		if (reject) {
			return;
		}

		if (state.viewConfig.isQuestion && Items && Items.UI.checkBeforeSave) {
			let check = Items.UI.checkBeforeSave(state, updateModuleState);

			if (check) {
				AH.activate(0);
				return;
			}
		}

		if (is_new == "1" && from_coverage == "1" && !saveCoverage) {
			$$invalidate(4, state.domainToggle = true, state);
			$$invalidate(4, state.saveDialog = false, state);
			return;
		}

		let temp_content_guid = is_new == '1' ? '' : state.guid;

		if ((is_new == 1 || temp_content_guid == "") && !editor.course) {
			$$invalidate(4, state.message = "Please select a course.", state);
			$$invalidate(4, state.is_new = "1", state);
			$$invalidate(4, state.snackback = true, state);
			$$invalidate(4, state.domainToggle = true, state);
			$$invalidate(4, state.saveDialog = false, state);
			return true;
		} else {
			$$invalidate(4, state.is_new = "0", state);
		}

		if (is_new == 2) {
			$$invalidate(4, state.is_new = "1", state);
		}

		if (!AH.isValid(state.courses)) {
			$$invalidate(4, state.courses = editor.course, state);
		}

		if (editor.course || temp_content_guid.length == 5 || state.viewConfig.typeAllowedSave) {
			AH.selectAll('#savingContent, #saveAs, #saveButton, #cancelButton, #publish_selected, #publishContent, #savePublish', 'hide');
			AH.toggleDom('#saveProcess', 'show');
			AH.toggleDom('.saveDropDown', 'hide');
			getXml(1);

			if (('03j6z,03j71,03j74,03j77').split(',').includes(temp_content_guid)) {
				//Sample Data for Coverage
				editorConfig.setParentData(temp_content_guid, state.item);

				temp_content_guid = '';
			}

			setTimeout(
				function () {
					let data = state.viewConfig.isQuestion
					? saveTypeQ(temp_content_guid)
					: saveTypeOther(temp_content_guid);

					data['draft'] = from_myproject == 1 && temp_content_guid.length != 5 || user_current_permission < 3 && from_myproject == 1 || is_new == 1
					? 1
					: state.draft;

					data['status'] = 1;
					data['from_myproject'] = from_myproject;
					data['user_current_permission'] = user_current_permission;
					data['is_owner'] = is_owner;

					if (coverageCourses && coverageCourses.toString() != "[object Object]") {
						data['coverage_courses'] = coverageCourses;
						data['old_content_guid'] = state.guid;
					}

					if (getQueryString("from_temp_id")) {
						data['from_temp_id'] = getQueryString("from_temp_id");
					}

					if (getQueryString("from_myproject") == 1) {
						window.parent.content_info = {
							"p1": data['domain'],
							"p2": data['add_coverage'],
							"test_obj": data['test_obj'],
							data
						};
					}

					data = removeBogus(data, 'filterData');
					window.parent.is_new_content = temp_content_guid.length == 5 ? 0 : 1; //For in_editor

					if (is_new == 1) {
						AH.activate(2);
					}

					if (AH.get('stop')) {
						console.warn("Saving is paused -");
						return;
					}

					console.log('baseUrl', baseUrl);

					AH.ajax({
						url: baseUrl + 'editor/index.php', // point to server-side PHP script
						datatype: 'json',
						data,
						type: 'POST',
						longUrl: true
					}).then(save_response => {
						AH.set('save_response', save_response);
						let isContinue = 0;
						localStorageData(data, 'remove');
						let json_response = save_response;
						AH.selectAll('#savingContent, #saveAs, #saveButton,#cancelButton, #savePublish', 'show');
						AH.toggleDom('#saveProcess', 'hide');
						handleModal(''); // to hide the modal

						if (state.viewConfig.showOtherType) {
							showOtherType(save_response);
							$$invalidate(4, state.message = l$1.save_success, state);
							$$invalidate(4, state.snackback = true, state);
						} else {
							save_response = JSON.parse(save_response);

							if (!save_response['error'] || save_response['error'].length == 0) {
								if (state.guid != '') {
									checkNewGuid(save_response['content_guid'], state.guid);
								}

								if (from_myproject == 1) {
									if (user_current_permission == 3 || is_owner == 1) {
										$$invalidate(4, state.message = l$1.save_success, state);
									} else {
										$$invalidate(4, state.message = l$1.save_success_owner, state);
									}
								} else {
									$$invalidate(4, state.message = l$1.save_success, state);
								}

								AH.set('save_item', false);
								AH.set('current_guid', save_response['content_guid']);
								$$invalidate(4, state.guid = save_response['content_guid'], state);
								$$invalidate(4, state.save_publish = false, state);
								$$invalidate(4, state.draft = save_response['draft'], state);
								window.parent.editor_guid = save_response['content_guid'];
								window.parent.edit_content = 1;

								if (state.is_new != 1) {
									if (window.in_full_preview == 1 && state.exam_objective_mapping_save != 1) {
										window.parent.saveFromEditor(json_response, window.parent.is_new_content);
										AH.toggleDom(document.querySelector('.backBtn').parentElement, 'hide');
									}
								}

								if (AH.isValid(state.exam_objective)) {
									AH.ajax({
										url: `${baseUrl}?func=assign_exam_objective&course_code=${editor.course}&content_guid=${save_response['content_guid']}&tag_guid=${state.exam_objective}&save=1&from_myproject=1`
									}).then(data => {
										if (data) {
											AH.activate(0);
											$$invalidate(4, state.snackback = true, state);
										}
									});
								} else {
									isContinue = 1;
								}

								// if (getQueryString("refer_content") == 1) {
								// 	//Do not remove previous item id when creating a new item
								// 	let item_id = window.parent.document.querySelector("#asset, #refid, #no").value.trim();
								// 	item_id = (item_id != '') ? item_id + ',' + save_response['content_guid'] : item_id;
								// 	window.parent.document.querySelectorAll("#asset, #refid, #no").forEach((elm)=> elm.value = item_id);
								// 	window.parent.editorClose();
								// }
								if (getQueryString("from_temp_id")) {
									window.parent.from_temp_id = 1;
									window.parent.editorClose(1);
								}

								if (getQueryString("content_type") == 's' || getQueryString("content_type") == 'f') {
									window.parent.addButtonsOnAction && window.parent.addButtonsOnAction();
								}
							} else {
								$$invalidate(4, state.message = save_response['error'].toString(), state);

								if (state.message == "You Must Specify title for the content.") {
									$$invalidate(10, modal = {
										header: {
											body: "No Title",
											class: "editor_modal_title"
										},
										body: {
											body: "Do you want to save without title ?",
											class: "editor_modal_content",
											style: { height: '300' }
										},
										footer: {
											body: [{ 'label': "Yes", onAction: setNoTitle }],
											class: "editor_modal_action"
										}
									});

									handleModal(modal);
								}

								if (window.in_full_preview == 1) {
									$$invalidate(4, state.saveDialog = false, state);
									window.parent.showErrorMessage(state.message, window.frameElement);
									AH.toggleDom(document.querySelector('.backBtn').parentElement, 'hide');
								}

								$$invalidate(4, state.snackback = true, state);
							}
						}

						updateStage();
						$$invalidate(4, state.saveDialog = false, state);

						if (isContinue == 1) {
							$$invalidate(4, state.snackback = true, state);
							AH.activate(0);
						}

						is_new == 1 ? AH.activate(0) : "";
					}).catch(error => {
						console.log(error); //self.editorModalUpdate(false);

						if (window.in_full_preview == 1) {
							$$invalidate(4, state.saveDialog = false, state);
							window.parent.showErrorMessage("Failed to save", window.frameElement);
						}

						localStorageData(data, 'save');
						AH.toggleDom('#saveProcess', 'hide');
						$$invalidate(4, state.message = "Data stored in Local Storage", state);
						$$invalidate(4, state.snackback = true, state);
						$$invalidate(4, state.saveDialog = false, state);
						AH.activate(0);
					});
				},
				200
			);
		} else {
			$$invalidate(4, state.saveDialog = false, state);
			$$invalidate(4, state.message = l$1.save_error, state);
			$$invalidate(4, state.snackback = true, state);

			if (window.in_full_preview == 1) {
				window.parent.showErrorMessage(l$1.save_error, window.frameElement);
			}
		}
	}

	// Stage update for current guid
	function updateStage() {
		if (AH.isValid(stageComment) && state.guid) {
			let _data = {
				'user_guid_r': user_guid,
				'content_guid': state.guid,
				'text': stageComment,
				'annotation_type': 3,
				'tags': -2
			};

			AH.ajax({
				url: baseUrl + "educator/project/index.php?func=new_comment",
				method: "POST",
				data: _data
			}).then(data => {
				
			}); //comment update
		}

		switch (AH.get('saveType')) {
			case 'approve':
				// eslint-disable-next-line no-case-declarations
				let stageConfig = editorConfig.status();
				if (stageConfig[3].stage < AH.get('stageLimit')) {
					changeStatusOnly(stageConfig[3].stage, true);
				} else {
					console.warn("No Need to update status here.");
					editorHeaderRef.callPendingAction();
				}
				break;
			case 'rework':
				if (AH.get('stage')) {
					changeStatusOnly(-1);
				}
				break;
			case 'skip':
				console.warn("Skipped stage update by user.");
				editorHeaderRef.callPendingAction();
				break;
		}

		$$invalidate(4, state.saveDialog = false, state);
	}

	// Status update for current guid
	function changeStatusOnly(newStatus = false, isDraft) {
		AH.selectAll('.save_buttons, #savingContent', 'hide');
		AH.toggleDom(document.getElementById('saveProcess'), 'hide');
		let status = 2;
		status = user_current_permission > 1 ? 3 : 2;

		status = newStatus.toString() != "[object Object]"
		? newStatus
		: status;

		AH.ajax({
			url: baseUrl + 'editor/index.php',
			cache: false,
			data: {
				ajax: "1",
				content_guid: state.guid,
				func: 'update_status_only',
				action: 'update_status_only',
				status,
				newStage: newStatus,
				user_current_permission,
				is_owner,
				isDraft: isDraft ? 1 : 0
			}
		}).then(response => {
			AH.toggleDom(document.getElementById('saveProcess'), 'hide');
			AH.selectAll('.save_buttons, #savingContent', 'show');
			$$invalidate(4, state.message = "Status has been changed successfully", state);

			try {
				response = JSON.parse(response);

				if (response.stage && AH.get('stage') != response.stage) {
					AH.set('stage', response.stage);
				} else if (response.content && response.content[state.guid] == "Content status chagned. Draft") {
					AH.set('stage', -1);
				}
			} catch(error) {
				console.log(response);
			}

			$$invalidate(4, state.snackback = true, state);
			$$invalidate(4, state.saveDialog = false, state);
			editorHeaderRef.callPendingAction();
		});
	}

	// check whether not required title
	function setNoTitle() {
		AH.selectAll("#title,#title_show", 'html', "<notitle></notitle>");
		setContent('title');
		$$invalidate(4, state.noTitle = false, state);

		setTimeout(
			function () {
				AH.trigger("#save_xml", "click"); //self.editorModalUpdate(false);
				AH.trigger("#saveButton", "click");
			},
			200
		); //self.editorModalUpdate(false);
	}

	// Future use and it store data if net is lost
	function localStorageData(data, type) {
		let localdata = JSON.parse(localStorage.getItem('storedata'));
		let counter = 1;
		let userGuid = window.user_guid;
		let flag = 0;

		if (type == 'save') {
			let d = new Date();
			data['datetime'] = d.toString().replace(/GMT.*/g, "");

			if (localdata == null) {
				localdata = {};
				localdata[userGuid] = {};
			}

			let tempvar2 = Object.assign({}, data);
			tempvar2['datetime'] = '';

			for (var i in localdata[userGuid]) {
				let tempvar1 = Object.assign({}, localdata[userGuid][i]);
				tempvar1['datetime'] = '';

				if (JSON.stringify(tempvar2) == JSON.stringify(tempvar1)) {
					flag = 1;
					break;
				}
			}

			if (data.content_guid == "") {
				for (let i in localdata[userGuid]) {
					if (i.length != 5) {
						counter++;
					}
				}

				if (flag != 1) {
					localdata[userGuid] && (localdata[userGuid]["n" + counter] = data);
					localStorage.setItem('storedata', JSON.stringify(localdata));
				} else {
					console.warn("Data Duplication in Localstorage");
				}
			} else {
				localdata[userGuid][data.content_guid] = data;
				localStorage.setItem('storedata', JSON.stringify(localdata));
			}
		} else if (type == 'remove') {
			if (AH.isValid(localdata) && AH.isValid(userGuid) && AH.isValid(localdata[userGuid])) {
				delete localdata[userGuid][data.content_guid];
				localStorage.setItem('storedata', JSON.stringify(localdata));
			}
		}
	}

	// check removalable eneity before save
	function removeBogus(data, action) {
		if (AH.isValid(data)) {
			if (action == "filterData") {
				data['question'] = editorConfig.replaceUnwantedEntity(data['question'], "revert");
				data['explanation'] = editorConfig.replaceUnwantedEntity(data['explanation'], "revert");
				data['content'] = editorConfig.replaceUnwantedEntity(data['content'], 'revert');
			} else {
				data = data.replace(/<span data-mce-bogus[^>]*>/g, '');

				data = data.replace(/<span anscounter[^>]*>(.*?)<\/span>/g, (p1, p2) => {
					return p2;
				});
			} //content = content.replace(/<\/?g[^>]*>/g, ""); // remove gramerly
		}

		return data;
	}

	// Filter save data before saving
	function filterContent() {
		let filterData = {};
		filterData['question'] = replaceUnwantedTags(seqTag(state.stem), "stem");
		filterData['explanation'] = replaceUnwantedTags(seqTag(state.remediation, "remed"), "remediation");
		filterData['title'] = seqTag(state.title);
		filterData['is_new'] = state.is_new;
		filterData['course_code'] = state.is_new ? state.courses : editor.course;
		filterData['answerArray'] = [{ answer: true, id: '01', is_correct: '1' }];
		return filterData;
	}

	// Check qtype save data
	function saveTypeQ(content_guid) {
		var response = filterContent();

		//@todo: @abhishek we already hae funciton removeBogus to remove this <br data-mce-bogus="1">
		if (state.testObj) {
			response['test_obj'] = state.testObj ? state.testObj : null;

			try {
				coverage_data = JSON.parse(coverage_data);
				response['chapter_name'] = coverage_data[state.domain]['snippet'];
			} catch(e) {
				console.log(e);
			}
		}

		if (Items.UI.isManualGrade && Items.UI.isManualGrade(state.xml)) {
			response['manual_grade'] = '0';
		}

		var data = {
			action: 'save',
			react_content: 'react',
			correct_answers: '1',
			total_answers: '1',
			answers: response['answerArray'],
			is_new: response['is_new'],
			title: response['title'],
			course_code: response['course_code'],
			domain: state.domain.length == 5 ? state.domain : null,
			question: response['question'],
			explanation: response['explanation'],
			content_type: state.content_type,
			content_subtype: state.item,
			content_guid: response['is_new'] == 1 ? "" : content_guid,
			content_icon: state.content_icon ? state.content_icon : 0,
			add_coverage: state.coverage_guid.length == 5 && add_coverage
			? state.coverage_guid
			: null,
			test_obj: response['test_obj'],
			chapter_name: response['chapter_name'],
			algo_qxml: state.variable_button ? state.algo_qxml : ""
		};

		if (state.caseid_val || state.caseid_val == '') {
			data["case_id"] = state.caseid_val;
		}

		//@todo: @abhishek why we need this?: done,I moved into item package
		if (Items.UI.checkDataOnSave) {
			data = Items.UI.checkDataOnSave(data, state.item, state, updateModuleState);
		}

		if (!Items.UI.donNotSendXMl) {
			data['special_module_xml'] = state.xml;
		}

		response['manual_grade'] == '0' || response['manual_grade'] == '1'
		? data.manual_grade = response['manual_grade']
		: "";

		return data;
	}

	// check content type save data
	function saveTypeOther(content_guid) {
		var response = {};
		response['content'] = replaceUnwantedTags(seqTag(state.content), "content");
		response['title'] = seqTag(state.title);
		response['is_new'] = state.is_new;

		//@TODO:? @abhishek why there is two way of setting coruse code
		response['course_code'] = response['is_new'] ? state.courses : editor.course;

		//@TODO:? @abhishek are we keeping complete coverage here: It is guid of coverage
		if (state.viewConfig.loadWebPages) {
			return state.webPageData;
		}

		let data = {
			action: 'save',
			react_content: 'react',
			content_type: state.content_type,
			content_subtype: state.item,
			content_icon: 0,
			course_code: response['course_code'],
			title: getEditable(response['title']),
			content: response['content'],
			content_guid: response['is_new'] == 1 ? "" : content_guid,
			author_area
		};

		if (state.viewConfig.save_content_text) {
			data['content_text'] = state.ajaxData.content_text;
		} else if (state.viewConfig.save_vtt_info) {
			let vtt = getEditable(state.vtt);

			vtt = vtt
			? vtt.replace(/<br>|<br\/>|<br \/>/gim, "\n").replace(/<span>|<\/span>/gim, '')
			: "";

			data['vtt'] = vtt ? vtt.replace(/ \n|\n |\n/g, "\n") : "";
			data['info'] = getEditable(state.info);
		} else {
			data['author_area'] = author_area;

			if (state.coverage_guid.length == 5 && add_coverage) {
				data.add_coverage = state.coverage_guid;
			}
		}

		if (state.caseid_val || state.caseid_val == '') {
			data["case_id"] = state.caseid_val;
		}

		return data;
	}

	// mange domain objective
	function selectedObjective(guid, examObjecitveChange = false) {
		if (guid != false) {
			$$invalidate(4, state.exam_objective = guid, state);
		} else {
			//@pradeep: when guid not found. 
			// ("not_assigned" replaced by "undefined")
			// becuase on pe-gold3/index.php tag_guid chekcing undefined only.
			examObjecitveChange = AH.get('exma_obj_changed') ? true : false;

			$$invalidate(4, state.exam_objective = examObjecitveChange ? "deleted" : "undefined", state);
		}
	}

	// manage domain state
	function saveDomain(is_new) {
		if (is_new == 1) {
			saveData("1", false, true);
		} else if (is_new == 2) {
			saveData("2");
		} else {
			saveData("0");
		}
	}

	function onDomainSelect(domainID) {
		if (domainID && domainID.match(/[0-9]/)) {
			$$invalidate(4, state.domain = domainID, state);
		}
	}

	// manage exam objective state
	function exam_objective_mapping_state() {
		$$invalidate(4, state.exam_objective_mapping_save = 0, state);
		toggleDomain();
	}

	// show domain dialog
	function toggleDomain(flag) {
		$$invalidate(4, state.domainToggle = flag, state);
	}

	function updateAlignMatch(action, type) {
		if (action == 'csv') {
			$$invalidate(4, state.isCSV = type, state);
		}
	}

	// show review dialog for items only
	function toggleRemediation(event) {
		if (state.viewConfig.isFullMode) {
			externalToggle();
			return;
		}

		$$invalidate(4, state.remediationToggle = !state.remediationToggle, state);

		if (state.remediationToggle == true) {
			renderPlayer();
		}
	}

	// handle switch tab for shortcuts
	function switchTabs() {
		if (preview_edit != 1) {
			if (state.editorView == "authoring") {
				if (state.viewConfig.isFullMode) {
					AH.trigger('[href="fullMode_custom_columnize"]', 'click');
				} else {
					AH.getBS('[href="#custom_columnize"]', 'Tab').show();
				}

				let currentRefreshFunc = AH.get(state.content_type + "_refresh");

				if (currentRefreshFunc) {
					currentRefreshFunc();
				}

				$$invalidate(4, state.editorView = 'preview', state);
			} else {
				if (state.viewConfig.isFullMode) {
					AH.trigger('[href="#authoringDiv"]', 'click');
				} else {
					AH.getBS('[href="#authoringDiv"]', 'Tab').show();
				}

				$$invalidate(4, state.remediationToggle = false, state);
				$$invalidate(4, state.editorView = 'authoring', state);
			}
		}
	}

	const writable_props = [
		'actionData',
		'advanceXml',
		'item',
		'itemXML',
		'moduleType',
		'content_icon',
		'content_guid',
		'inline_item',
		'is_algo',
		'ajaxData',
		'_user',
		'subtype'
	];

	Object_1$6.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$a.warn(`<Editor> was created with unknown prop '${key}'`);
	});

	function editorheader_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			editorHeaderRef = $$value;
			$$invalidate(6, editorHeaderRef);
		});
	}

	function editorheader_editorState_binding(value) {
		state = value;
		$$invalidate(4, state);
	}

	const keyup_handler = () => setContent('title');
	const Keyup_handler = () => setContent('stem');
	const keyup_handler_1 = () => setContent('content');

	function switch_instance_editorState_binding(value) {
		state = value;
		$$invalidate(4, state);
	}

	const keyup_handler_2 = () => setContent('remediation');
	const func = () => console.warn("Did mounted");

	function player_editorState_binding(value) {
		state = value;
		$$invalidate(4, state);
	}

	function editormodal_modal_binding(value) {
		modal = value;
		$$invalidate(10, modal);
	}

	function editormodal_visible_binding(value) {
		modalVisible = value;
		$$invalidate(9, modalVisible);
	}

	const click_handler = (item, event) => item.func
	? saveAction(event, 'save', item.type)
	: saveAction(event, "cancel", item.type);

	function textarea_input_handler() {
		stageComment = this.value;
		$$invalidate(5, stageComment);
	}

	function checkbox_checked_binding(value) {
		saveCheckbox = value;
		$$invalidate(7, saveCheckbox);
	}

	function dialog0_visible_binding(value) {
		if ($$self.$$.not_equal(state.saveDialog, value)) {
			state.saveDialog = value;
			$$invalidate(4, state);
		}
	}

	function dialog1_visible_binding(value) {
		if ($$self.$$.not_equal(state.activator, value)) {
			state.activator = value;
			$$invalidate(4, state);
		}
	}

	const click_handler_1 = () => $$invalidate(4, state.xmlDialog = false, state);
	const click_handler_2 = () => $$invalidate(4, state.xmlDialog = false, state);

	function dialog2_visible_binding(value) {
		if ($$self.$$.not_equal(state.xmlDialog, value)) {
			state.xmlDialog = value;
			$$invalidate(4, state);
		}
	}

	const click_handler_3 = () => $$invalidate(4, state.snackback = false, state);

	function snackbar_visible_binding(value) {
		if ($$self.$$.not_equal(state.snackback, value)) {
			state.snackback = value;
			$$invalidate(4, state);
		}
	}

	const func_1 = course => $$invalidate(4, state.courses = course, state);
	const func_2 = guid => $$invalidate(4, state.coverage_guid = guid, state);
	const func_3 = testObj => $$invalidate(4, state.testObj = testObj, state);

	function domain_editorState_binding(value) {
		state = value;
		$$invalidate(4, state);
	}

	function webpagelist_editorState_binding(value) {
		state = value;
		$$invalidate(4, state);
	}

	function createvariable_editorState_binding(value) {
		state = value;
		$$invalidate(4, state);
	}

	function createvariable_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			createVariableCallback = $$value;
			$$invalidate(8, createVariableCallback);
		});
	}

	function commentmodal_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			_commentModal = $$value;
			$$invalidate(13, _commentModal);
		});
	}

	function media_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			_media = $$value;
			$$invalidate(14, _media);
		});
	}

	const func_4 = () => $$invalidate(4, state.AnalyzeEbookMenu = false, state);

	function interactiveitem_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			_interactiveItem = $$value;
			$$invalidate(12, _interactiveItem);
		});
	}

	$$self.$$set = $$props => {
		if ('actionData' in $$props) $$invalidate(41, actionData = $$props.actionData);
		if ('advanceXml' in $$props) $$invalidate(0, advanceXml = $$props.advanceXml);
		if ('item' in $$props) $$invalidate(3, item = $$props.item);
		if ('itemXML' in $$props) $$invalidate(42, itemXML = $$props.itemXML);
		if ('moduleType' in $$props) $$invalidate(43, moduleType = $$props.moduleType);
		if ('content_icon' in $$props) $$invalidate(44, content_icon = $$props.content_icon);
		if ('content_guid' in $$props) $$invalidate(45, content_guid = $$props.content_guid);
		if ('inline_item' in $$props) $$invalidate(46, inline_item = $$props.inline_item);
		if ('is_algo' in $$props) $$invalidate(47, is_algo = $$props.is_algo);
		if ('ajaxData' in $$props) $$invalidate(48, ajaxData = $$props.ajaxData);
		if ('_user' in $$props) $$invalidate(1, _user = $$props._user);
		if ('subtype' in $$props) $$invalidate(2, subtype = $$props.subtype);
	};

	$$self.$capture_state = () => ({
		onMount,
		tick,
		afterUpdate,
		Button,
		Dialog,
		Checkbox,
		Snackbar,
		writable,
		AH,
		XMLToJSON,
		editorConfig,
		ucEditor,
		EditorHeader,
		getItems,
		EditorModal,
		Player,
		Domain,
		VersionControl,
		WebpageList,
		Loader,
		CreateVariable,
		InteractiveItem,
		CommentModal,
		tag_player,
		initEbookInteractivity,
		ajaxContentUpdate: ajaxContentUpdate$1,
		mathMLRender,
		ucTimeline,
		Media,
		l: l$1,
		ImageAnnotation,
		EditorPopoverModal,
		PeGlossaryContentLink,
		AnalyzeEbook,
		actionData,
		advanceXml,
		item,
		itemXML,
		moduleType,
		content_icon,
		content_guid,
		inline_item,
		is_algo,
		ajaxData,
		_user,
		subtype,
		snt_detail_array,
		stageComment,
		editorHeaderRef,
		editCount,
		saveCheckbox,
		createVariableCallback,
		modalVisible,
		player_parent,
		modal,
		editorBuffer,
		typeChangePosition,
		Items,
		changedKeys,
		cursorPosition,
		_interactiveItem,
		_commentModal,
		state,
		preview_edit,
		hdd,
		dxml,
		_media,
		_editorBuffer,
		unsubscribe,
		ucStepContolPanel,
		url_string,
		url,
		getState,
		versionControl,
		showAns,
		initComments,
		updateModuleState,
		handleModal,
		didMount,
		showPreviewOnly,
		setBasicData,
		renderPlayer,
		setSntDetails,
		ucStepImplement,
		swapPanel,
		interactiveEvents,
		ucTimelineEditor,
		initEditorListeners,
		refreshEvents,
		formatXmlRef,
		handleKeydown,
		openItems,
		handleKeyup,
		switchSpecialPaste,
		handlePasteSpecial,
		pasteSpecialFunc,
		saveXML,
		doNotShowStem,
		setModule,
		initializeAlgo,
		externalToggle,
		editorPaneShow,
		setupEditor,
		checkSection,
		activateEditor,
		setInitialButton,
		keepAnalyzeData,
		initAddFeature,
		callInlineEditor,
		setInlineEditor,
		updateEbookContent,
		addPlaceHolder,
		editorClass,
		previewSnt,
		interactiveEditor,
		editorModalUpdate,
		smValidate,
		setContent,
		getXml,
		updateXml,
		updateContent,
		solveVariable,
		analyzeVariable,
		handleCheckbox,
		editAlgo,
		updateChildXml,
		saveAction,
		saveData,
		updateStage,
		changeStatusOnly,
		setNoTitle,
		localStorageData,
		removeBogus,
		filterContent,
		saveTypeQ,
		saveTypeOther,
		selectedObjective,
		saveDomain,
		onDomainSelect,
		exam_objective_mapping_state,
		toggleDomain,
		updateAlignMatch,
		toggleRemediation,
		switchTabs
	});

	$$self.$inject_state = $$props => {
		if ('actionData' in $$props) $$invalidate(41, actionData = $$props.actionData);
		if ('advanceXml' in $$props) $$invalidate(0, advanceXml = $$props.advanceXml);
		if ('item' in $$props) $$invalidate(3, item = $$props.item);
		if ('itemXML' in $$props) $$invalidate(42, itemXML = $$props.itemXML);
		if ('moduleType' in $$props) $$invalidate(43, moduleType = $$props.moduleType);
		if ('content_icon' in $$props) $$invalidate(44, content_icon = $$props.content_icon);
		if ('content_guid' in $$props) $$invalidate(45, content_guid = $$props.content_guid);
		if ('inline_item' in $$props) $$invalidate(46, inline_item = $$props.inline_item);
		if ('is_algo' in $$props) $$invalidate(47, is_algo = $$props.is_algo);
		if ('ajaxData' in $$props) $$invalidate(48, ajaxData = $$props.ajaxData);
		if ('_user' in $$props) $$invalidate(1, _user = $$props._user);
		if ('subtype' in $$props) $$invalidate(2, subtype = $$props.subtype);
		if ('snt_detail_array' in $$props) snt_detail_array = $$props.snt_detail_array;
		if ('stageComment' in $$props) $$invalidate(5, stageComment = $$props.stageComment);
		if ('editorHeaderRef' in $$props) $$invalidate(6, editorHeaderRef = $$props.editorHeaderRef);
		if ('editCount' in $$props) editCount = $$props.editCount;
		if ('saveCheckbox' in $$props) $$invalidate(7, saveCheckbox = $$props.saveCheckbox);
		if ('createVariableCallback' in $$props) $$invalidate(8, createVariableCallback = $$props.createVariableCallback);
		if ('modalVisible' in $$props) $$invalidate(9, modalVisible = $$props.modalVisible);
		if ('player_parent' in $$props) player_parent = $$props.player_parent;
		if ('modal' in $$props) $$invalidate(10, modal = $$props.modal);
		if ('editorBuffer' in $$props) editorBuffer = $$props.editorBuffer;
		if ('typeChangePosition' in $$props) typeChangePosition = $$props.typeChangePosition;
		if ('Items' in $$props) $$invalidate(11, Items = $$props.Items);
		if ('changedKeys' in $$props) changedKeys = $$props.changedKeys;
		if ('cursorPosition' in $$props) cursorPosition = $$props.cursorPosition;
		if ('_interactiveItem' in $$props) $$invalidate(12, _interactiveItem = $$props._interactiveItem);
		if ('_commentModal' in $$props) $$invalidate(13, _commentModal = $$props._commentModal);
		if ('state' in $$props) $$invalidate(4, state = $$props.state);
		if ('preview_edit' in $$props) preview_edit = $$props.preview_edit;
		if ('hdd' in $$props) hdd = $$props.hdd;
		if ('dxml' in $$props) dxml = $$props.dxml;
		if ('_media' in $$props) $$invalidate(14, _media = $$props._media);
		if ('_editorBuffer' in $$props) _editorBuffer = $$props._editorBuffer;
		if ('url_string' in $$props) $$invalidate(93, url_string = $$props.url_string);
		if ('url' in $$props) $$invalidate(94, url = $$props.url);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*state*/ 16) {
			//@Prabhat: If the solve variable option clicked and authoring and preview tab switching then need to take the auth and preview xml.
			 if (state.editorView == 'preview' && state.previewXml) {
				$$invalidate(4, state.xml = state.previewXml, state);
			} else if (state.authXml) {
				$$invalidate(4, state.xml = state.authXml, state);
			}
		}
	};

	 {
		var url_string = window.location;
		var url = new URL(url_string);

		preview_edit = url.searchParams.get("item") == 'listItem'
		? url.searchParams.get("preview_only")
		: '';
	}

	return [
		advanceXml,
		_user,
		subtype,
		item,
		state,
		stageComment,
		editorHeaderRef,
		saveCheckbox,
		createVariableCallback,
		modalVisible,
		modal,
		Items,
		_interactiveItem,
		_commentModal,
		_media,
		versionControl,
		showAns,
		updateModuleState,
		handleModal,
		didMount,
		renderPlayer,
		formatXmlRef,
		handleKeydown,
		handleKeyup,
		setInlineEditor,
		editorClass,
		smValidate,
		setContent,
		updateXml,
		solveVariable,
		analyzeVariable,
		handleCheckbox,
		editAlgo,
		updateChildXml,
		saveAction,
		selectedObjective,
		saveDomain,
		onDomainSelect,
		exam_objective_mapping_state,
		updateAlignMatch,
		toggleRemediation,
		actionData,
		itemXML,
		moduleType,
		content_icon,
		content_guid,
		inline_item,
		is_algo,
		ajaxData,
		editorheader_binding,
		editorheader_editorState_binding,
		keyup_handler,
		Keyup_handler,
		keyup_handler_1,
		switch_instance_editorState_binding,
		keyup_handler_2,
		func,
		player_editorState_binding,
		editormodal_modal_binding,
		editormodal_visible_binding,
		click_handler,
		textarea_input_handler,
		checkbox_checked_binding,
		dialog0_visible_binding,
		dialog1_visible_binding,
		click_handler_1,
		click_handler_2,
		dialog2_visible_binding,
		click_handler_3,
		snackbar_visible_binding,
		func_1,
		func_2,
		func_3,
		domain_editorState_binding,
		webpagelist_editorState_binding,
		createvariable_editorState_binding,
		createvariable_binding,
		commentmodal_binding,
		media_binding,
		func_4,
		interactiveitem_binding
	];
}

class Editor extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$r,
			create_fragment$r,
			safe_not_equal,
			{
				actionData: 41,
				advanceXml: 0,
				item: 3,
				itemXML: 42,
				moduleType: 43,
				content_icon: 44,
				content_guid: 45,
				inline_item: 46,
				is_algo: 47,
				ajaxData: 48,
				_user: 1,
				subtype: 2
			},
			null,
			[-1, -1, -1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Editor",
			options,
			id: create_fragment$r.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*actionData*/ ctx[41] === undefined && !('actionData' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'actionData'");
		}

		if (/*advanceXml*/ ctx[0] === undefined && !('advanceXml' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'advanceXml'");
		}

		if (/*item*/ ctx[3] === undefined && !('item' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'item'");
		}

		if (/*itemXML*/ ctx[42] === undefined && !('itemXML' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'itemXML'");
		}

		if (/*moduleType*/ ctx[43] === undefined && !('moduleType' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'moduleType'");
		}

		if (/*content_icon*/ ctx[44] === undefined && !('content_icon' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'content_icon'");
		}

		if (/*content_guid*/ ctx[45] === undefined && !('content_guid' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'content_guid'");
		}

		if (/*inline_item*/ ctx[46] === undefined && !('inline_item' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'inline_item'");
		}

		if (/*is_algo*/ ctx[47] === undefined && !('is_algo' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'is_algo'");
		}

		if (/*_user*/ ctx[1] === undefined && !('_user' in props)) {
			console_1$a.warn("<Editor> was created without expected prop '_user'");
		}

		if (/*subtype*/ ctx[2] === undefined && !('subtype' in props)) {
			console_1$a.warn("<Editor> was created without expected prop 'subtype'");
		}
	}

	get actionData() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set actionData(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get advanceXml() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set advanceXml(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get item() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set item(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemXML() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemXML(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get moduleType() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set moduleType(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content_icon() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content_icon(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content_guid() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content_guid(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inline_item() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inline_item(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get is_algo() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is_algo(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ajaxData() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ajaxData(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get _user() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set _user(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtype() {
		throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtype(value) {
		throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function flip(node, animation, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const scaleX = animation.from.width / node.clientWidth;
    const scaleY = animation.from.height / node.clientHeight;
    const dx = (animation.from.left - animation.to.left) / scaleX;
    const dy = (animation.from.top - animation.to.top) / scaleY;
    const d = Math.sqrt(dx * dx + dy * dy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(d) : duration,
        easing,
        css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
    };
}

/* src\EditorModules.svelte generated by Svelte v3.40.2 */
const file$r = "src\\EditorModules.svelte";

function add_css$j(target) {
	append_styles(target, "svelte-zjpjfe", ".padNull.svelte-zjpjfe{cursor:pointer;width:280px;margin:15px;background-color:#fff;border-radius:3px;border:2px solid #000;box-shadow:rgb(76, 76, 76) 1px 6px 10px}.groupList.svelte-zjpjfe{text-align:center;cursor:pointer;padding-top:16px;height:54px;border:1px solid #ccc;border-top:none}.side-panel{width:295px !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdG9yTW9kdWxlcy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc1lDLFFBQVEsY0FBQyxDQUFDLEFBQ0gsTUFBTSxDQUFFLE9BQU8sQ0FDZixLQUFLLENBQUUsS0FBSyxDQUNaLE1BQU0sQ0FBRSxJQUFJLENBQ1osZ0JBQWdCLENBQUUsSUFBSSxDQUN0QixhQUFhLENBQUUsR0FBRyxDQUNsQixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQ3RCLFVBQVUsQ0FBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxBQUM1QyxDQUFDLEFBQ0QsVUFBVSxjQUFDLENBQUMsQUFDUixVQUFVLENBQUUsTUFBTSxDQUNsQixNQUFNLENBQUUsT0FBTyxDQUNmLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLE1BQU0sQ0FBRSxJQUFJLENBQ1osTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN0QixVQUFVLENBQUUsSUFBSSxBQUNwQixDQUFDLEFBQ08sV0FBVyxBQUFFLENBQUMsQUFDbEIsS0FBSyxDQUFFLEtBQUssQ0FBQyxVQUFVLEFBQzNCLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRWRpdG9yTW9kdWxlcy5zdmVsdGUiXX0= */");
}

function get_each_context_1$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[32] = i;
	return child_ctx;
}

function get_each_context_2$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[32] = i;
	return child_ctx;
}

function get_each_context_3$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[32] = i;
	return child_ctx;
}

// (185:8) {#if enableClose == '1'}
function create_if_block_4$4(ctx) {
	let button;
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			span.textContent = "×";
			attr_dev(span, "aria-hidden", "true");
			add_location(span, file$r, 196, 12, 5373);
			attr_dev(button, "class", "close");
			set_style(button, "position", "absolute");
			set_style(button, "z-index", "999");
			set_style(button, "right", "0");
			set_style(button, "margin", "12px");
			set_style(button, "font-weight", "400");
			set_style(button, "font-size", "42px");
			add_location(button, file$r, 185, 8, 5050);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[18], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$4.name,
		type: "if",
		source: "(185:8) {#if enableClose == '1'}",
		ctx
	});

	return block;
}

// (201:12) {#each editorItems as data, i (data.id)}
function create_each_block_3$2(key_1, ctx) {
	let div3;
	let div2;
	let div0;
	let t0_value = /*data*/ ctx[30].title + "";
	let t0;
	let t1;
	let div1;
	let span;
	let span_class_value;
	let t2;
	let div3_key_value;
	let div3_class_value;
	let div3_data_cy_value;
	let div3_data_category_value;
	let div3_data_type_value;
	let div3_data_subtype_value;
	let div3_data_group_value;
	let div3_data_keywords_value;
	let rect;
	let stop_animation = noop;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[19](/*data*/ ctx[30]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			span = element("span");
			t2 = space();
			attr_dev(div0, "id", "itemTitle");
			attr_dev(div0, "class", "pull-left");
			set_style(div0, "font-size", "17px");
			set_style(div0, "color", "#4c4c4c");
			set_style(div0, "width", "48%");
			set_style(div0, "font-weight", "100");
			set_style(div0, "textAlign", "center");
			set_style(div0, "position", "absolute");
			set_style(div0, "top", "50%");
			set_style(div0, "transform", "translateY(-50%)");
			add_location(div0, file$r, 216, 24, 6292);
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*data*/ ctx[30].icon) + " svelte-zjpjfe"));
			set_style(span, "font-size", "67px");
			set_style(span, "color", "#4c4c4c");
			add_location(span, file$r, 243, 28, 7470);
			attr_dev(div1, "id", "itemLogo");
			attr_dev(div1, "class", "text-center pull-right pl-2");
			set_style(div1, "width", "50%");
			set_style(div1, "position", "absolute");
			set_style(div1, "top", "50%");
			set_style(div1, "right", "0");
			set_style(div1, "transform", "translateY(-50%)");
			add_location(div1, file$r, 232, 24, 6987);
			add_location(div2, file$r, 215, 20, 6261);
			attr_dev(div3, "key", div3_key_value = /*i*/ ctx[32]);
			attr_dev(div3, "class", div3_class_value = "" + (null_to_empty(`${/*data*/ ctx[30].group} col-lg-4 grid-item padNull`) + " svelte-zjpjfe"));
			set_style(div3, "height", /*actionData*/ ctx[1].embed ? '130px' : '175px');
			attr_dev(div3, "id", "allEditorItem");
			attr_dev(div3, "data-cy", div3_data_cy_value = 'item' + /*i*/ ctx[32]);
			attr_dev(div3, "data-category", div3_data_category_value = /*data*/ ctx[30].group);
			attr_dev(div3, "data-type", div3_data_type_value = /*data*/ ctx[30].type);
			attr_dev(div3, "data-subtype", div3_data_subtype_value = /*data*/ ctx[30].subtype);
			attr_dev(div3, "data-group", div3_data_group_value = /*data*/ ctx[30].grp_seq);
			attr_dev(div3, "data-keywords", div3_data_keywords_value = /*data*/ ctx[30].keywords);
			add_location(div3, file$r, 201, 16, 5600);
			this.first = div3;
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, span);
			append_dev(div3, t2);

			if (!mounted) {
				dispose = listen_dev(div3, "click", click_handler_1, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*editorItems*/ 8 && t0_value !== (t0_value = /*data*/ ctx[30].title + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*editorItems*/ 8 && span_class_value !== (span_class_value = "" + (null_to_empty(/*data*/ ctx[30].icon) + " svelte-zjpjfe"))) {
				attr_dev(span, "class", span_class_value);
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_key_value !== (div3_key_value = /*i*/ ctx[32])) {
				attr_dev(div3, "key", div3_key_value);
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_class_value !== (div3_class_value = "" + (null_to_empty(`${/*data*/ ctx[30].group} col-lg-4 grid-item padNull`) + " svelte-zjpjfe"))) {
				attr_dev(div3, "class", div3_class_value);
			}

			if (dirty[0] & /*actionData*/ 2) {
				set_style(div3, "height", /*actionData*/ ctx[1].embed ? '130px' : '175px');
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_data_cy_value !== (div3_data_cy_value = 'item' + /*i*/ ctx[32])) {
				attr_dev(div3, "data-cy", div3_data_cy_value);
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_data_category_value !== (div3_data_category_value = /*data*/ ctx[30].group)) {
				attr_dev(div3, "data-category", div3_data_category_value);
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_data_type_value !== (div3_data_type_value = /*data*/ ctx[30].type)) {
				attr_dev(div3, "data-type", div3_data_type_value);
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_data_subtype_value !== (div3_data_subtype_value = /*data*/ ctx[30].subtype)) {
				attr_dev(div3, "data-subtype", div3_data_subtype_value);
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_data_group_value !== (div3_data_group_value = /*data*/ ctx[30].grp_seq)) {
				attr_dev(div3, "data-group", div3_data_group_value);
			}

			if (dirty[0] & /*editorItems*/ 8 && div3_data_keywords_value !== (div3_data_keywords_value = /*data*/ ctx[30].keywords)) {
				attr_dev(div3, "data-keywords", div3_data_keywords_value);
			}
		},
		r: function measure() {
			rect = div3.getBoundingClientRect();
		},
		f: function fix() {
			fix_position(div3);
			stop_animation();
		},
		a: function animate() {
			stop_animation();
			stop_animation = create_animation(div3, rect, flip, {});
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$2.name,
		type: "each",
		source: "(201:12) {#each editorItems as data, i (data.id)}",
		ctx
	});

	return block;
}

// (252:0) {#if openDrawer}
function create_if_block_2$7(ctx) {
	let drawer;
	let current;

	drawer = new Drawer({
			props: {
				width: 59,
				backdrop: false,
				closeByEsc: false,
				$$slots: { content: [create_content_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	drawer.$on("close", /*close_handler*/ ctx[20]);

	const block = {
		c: function create() {
			create_component(drawer.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(drawer, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const drawer_changes = {};

			if (dirty[0] & /*newGroupList*/ 16 | dirty[1] & /*$$scope*/ 128) {
				drawer_changes.$$scope = { dirty, ctx };
			}

			drawer.$set(drawer_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(drawer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(drawer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(drawer, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$7.name,
		type: "if",
		source: "(252:0) {#if openDrawer}",
		ctx
	});

	return block;
}

// (276:20) {#if (i <= 8) }
function create_if_block_3$5(ctx) {
	let li;
	let span;
	let span_class_value;
	let li_id_value;
	let li_title_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*data*/ ctx[30].icon) + " svelte-zjpjfe"));
			set_style(span, "margin", "auto");
			set_style(span, "font-size", "20px");
			add_location(span, file$r, 284, 28, 8888);
			attr_dev(li, "id", li_id_value = /*data*/ ctx[30].name);
			attr_dev(li, "class", "shortList groupList svelte-zjpjfe");
			attr_dev(li, "data-bs-toggle", "tooltip");
			attr_dev(li, "title", li_title_value = /*data*/ ctx[30].title);
			attr_dev(li, "data-bs-placement", "right");
			add_location(li, file$r, 276, 24, 8495);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);

			if (!mounted) {
				dispose = listen_dev(
					li,
					"click",
					function () {
						if (is_function(/*filterGroup*/ ctx[9].bind(this, /*data*/ ctx[30].name))) /*filterGroup*/ ctx[9].bind(this, /*data*/ ctx[30].name).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*newGroupList*/ 16 && span_class_value !== (span_class_value = "" + (null_to_empty(/*data*/ ctx[30].icon) + " svelte-zjpjfe"))) {
				attr_dev(span, "class", span_class_value);
			}

			if (dirty[0] & /*newGroupList*/ 16 && li_id_value !== (li_id_value = /*data*/ ctx[30].name)) {
				attr_dev(li, "id", li_id_value);
			}

			if (dirty[0] & /*newGroupList*/ 16 && li_title_value !== (li_title_value = /*data*/ ctx[30].title)) {
				attr_dev(li, "title", li_title_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$5.name,
		type: "if",
		source: "(276:20) {#if (i <= 8) }",
		ctx
	});

	return block;
}

// (275:16) {#each newGroupList as data, i (data.name)}
function create_each_block_2$2(key_1, ctx) {
	let first;
	let if_block_anchor;
	let if_block = /*i*/ ctx[32] <= 8 && create_if_block_3$5(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*i*/ ctx[32] <= 8) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$2.name,
		type: "each",
		source: "(275:16) {#each newGroupList as data, i (data.name)}",
		ctx
	});

	return block;
}

// (259:8) 
function create_content_slot(ctx) {
	let div1;
	let div0;
	let t0;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t1;
	let li;
	let span;
	let mounted;
	let dispose;
	let each_value_2 = /*newGroupList*/ ctx[4];
	validate_each_argument(each_value_2);
	const get_key = ctx => /*data*/ ctx[30].name;
	validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$2(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2$2(key, child_ctx));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			li = element("li");
			span = element("span");
			attr_dev(div0, "class", "icomoon-search-2 text-center ");
			set_style(div0, "cursor", "pointer");
			set_style(div0, "font-size", "20px");
			set_style(div0, "padding-top", "16px");
			set_style(div0, "height", "51px");
			set_style(div0, "min-height", "51px");
			set_style(div0, "background-color", "#4c4c4c");
			set_style(div0, "color", "#fff");
			add_location(div0, file$r, 259, 12, 7882);
			attr_dev(span, "class", "icomoon-grid-2");
			add_location(span, file$r, 295, 20, 9315);
			attr_dev(li, "class", "groupList svelte-zjpjfe");
			attr_dev(li, "data-bs-toggle", "tooltip");
			attr_dev(li, "title", "More");
			attr_dev(li, "data-bs-placement", "right");
			add_location(li, file$r, 288, 16, 9060);
			set_style(ul, "padding", "0");
			add_location(ul, file$r, 273, 12, 8347);
			attr_dev(div1, "slot", "content");
			add_location(div1, file$r, 258, 8, 7848);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div1, t0);
			append_dev(div1, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(ul, t1);
			append_dev(ul, li);
			append_dev(li, span);

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*openFullMenu*/ ctx[8], false, false, false),
					listen_dev(li, "click", /*openFullMenu*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*newGroupList, filterGroup*/ 528) {
				each_value_2 = /*newGroupList*/ ctx[4];
				validate_each_argument(each_value_2);
				validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, ul, destroy_block, create_each_block_2$2, t1, get_each_context_2$2);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot.name,
		type: "slot",
		source: "(259:8) ",
		ctx
	});

	return block;
}

// (371:54) 
function create_if_block_1$8(ctx) {
	let each_1_anchor;
	let each_value_1 = /*newKeywordsList*/ ctx[5];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*filterAdvance, newKeywordsList*/ 1056) {
				each_value_1 = /*newKeywordsList*/ ctx[5];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(371:54) ",
		ctx
	});

	return block;
}

// (358:12) {#if actionData.menuView == "main" }
function create_if_block$l(ctx) {
	let each_1_anchor;
	let each_value = /*newGroupList*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*filterGroup, newGroupList*/ 528) {
				each_value = /*newGroupList*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$l.name,
		type: "if",
		source: "(358:12) {#if actionData.menuView == \\\"main\\\" }",
		ctx
	});

	return block;
}

// (372:16) {#each newKeywordsList as data2, j }
function create_each_block_1$4(ctx) {
	let div;
	let li;
	let span0;
	let span0_class_value;
	let t0;
	let span1;
	let t1_value = /*data2*/ ctx[33].title.replace("_", " ") + "";
	let t1;
	let t2;
	let hr;
	let t3;
	let div_key_value;
	let mounted;
	let dispose;

	function click_handler_5() {
		return /*click_handler_5*/ ctx[24](/*data2*/ ctx[33]);
	}

	const block = {
		c: function create() {
			div = element("div");
			li = element("li");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = text(t1_value);
			t2 = space();
			hr = element("hr");
			t3 = space();
			set_style(span0, "padding-right", "15px");
			set_style(span0, "font-size", "20px");
			attr_dev(span0, "class", span0_class_value = "" + (null_to_empty(/*data2*/ ctx[33].icon) + " svelte-zjpjfe"));
			add_location(span0, file$r, 377, 28, 12554);
			add_location(span1, file$r, 378, 28, 12662);
			set_style(li, "cursor", "pointer");
			set_style(li, "textTransform", "capitalize");
			set_style(li, "padding", "15px 19px");
			add_location(li, file$r, 373, 24, 12322);
			set_style(hr, "margin", "0");
			add_location(hr, file$r, 380, 24, 12763);
			attr_dev(div, "class", "listHover");
			attr_dev(div, "key", div_key_value = /*j*/ ctx[35]);
			add_location(div, file$r, 372, 20, 12265);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, li);
			append_dev(li, span0);
			append_dev(li, t0);
			append_dev(li, span1);
			append_dev(span1, t1);
			append_dev(div, t2);
			append_dev(div, hr);
			append_dev(div, t3);

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler_5, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*newKeywordsList*/ 32 && span0_class_value !== (span0_class_value = "" + (null_to_empty(/*data2*/ ctx[33].icon) + " svelte-zjpjfe"))) {
				attr_dev(span0, "class", span0_class_value);
			}

			if (dirty[0] & /*newKeywordsList*/ 32 && t1_value !== (t1_value = /*data2*/ ctx[33].title.replace("_", " ") + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$4.name,
		type: "each",
		source: "(372:16) {#each newKeywordsList as data2, j }",
		ctx
	});

	return block;
}

// (359:16) {#each newGroupList as data, i }
function create_each_block$7(ctx) {
	let div;
	let li;
	let span0;
	let span0_class_value;
	let t0;
	let span1;
	let t1_value = /*data*/ ctx[30].title + "";
	let t1;
	let t2;
	let hr;
	let t3;
	let div_key_value;
	let mounted;
	let dispose;

	function click_handler_4() {
		return /*click_handler_4*/ ctx[23](/*data*/ ctx[30]);
	}

	const block = {
		c: function create() {
			div = element("div");
			li = element("li");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = text(t1_value);
			t2 = space();
			hr = element("hr");
			t3 = space();
			set_style(span0, "padding-right", "15px");
			set_style(span0, "font-size", "20px");
			attr_dev(span0, "class", span0_class_value = "" + (null_to_empty(/*data*/ ctx[30].icon) + " svelte-zjpjfe"));
			add_location(span0, file$r, 364, 28, 11868);
			add_location(span1, file$r, 365, 28, 11975);
			set_style(li, "cursor", "pointer");
			set_style(li, "text-align", "left");
			set_style(li, "padding", "15px 10px");
			add_location(li, file$r, 360, 24, 11649);
			set_style(hr, "margin", "0");
			add_location(hr, file$r, 367, 24, 12057);
			attr_dev(div, "class", "listHover");
			attr_dev(div, "key", div_key_value = /*i*/ ctx[32]);
			add_location(div, file$r, 359, 20, 11592);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, li);
			append_dev(li, span0);
			append_dev(li, t0);
			append_dev(li, span1);
			append_dev(span1, t1);
			append_dev(div, t2);
			append_dev(div, hr);
			append_dev(div, t3);

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler_4, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*newGroupList*/ 16 && span0_class_value !== (span0_class_value = "" + (null_to_empty(/*data*/ ctx[30].icon) + " svelte-zjpjfe"))) {
				attr_dev(span0, "class", span0_class_value);
			}

			if (dirty[0] & /*newGroupList*/ 16 && t1_value !== (t1_value = /*data*/ ctx[30].title + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(359:16) {#each newGroupList as data, i }",
		ctx
	});

	return block;
}

// (302:0) <Sidepanel left bind:visible={actionData.fullMenu}>
function create_default_slot$b(ctx) {
	let div3;
	let div0;
	let span;
	let t0;
	let input;
	let input_placeholder_value;
	let t1;
	let ul;
	let li;
	let div1;
	let t2;
	let t3;
	let div2;
	let t4;
	let t5;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*actionData*/ ctx[1].menuView == "main") return create_if_block$l;
		if (/*actionData*/ ctx[1].menuView == "asset") return create_if_block_1$8;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = space();
			input = element("input");
			t1 = space();
			ul = element("ul");
			li = element("li");
			div1 = element("div");
			t2 = text("Item");
			t3 = space();
			div2 = element("div");
			t4 = text("Asset");
			t5 = space();
			if (if_block) if_block.c();
			attr_dev(span, "class", "icomoon-arrow-left-4");
			set_style(span, "text-align", "left");
			set_style(span, "color", "#fff");
			set_style(span, "font-size", "24px");
			set_style(span, "position", "relative");
			set_style(span, "top", "14px");
			set_style(span, "padding-right", "9px");
			add_location(span, file$r, 312, 12, 9747);
			attr_dev(input, "type", "text");
			attr_dev(input, "placeholder", input_placeholder_value = "Search Here");
			set_style(input, "width", "236px");
			set_style(input, "height", "49px");
			set_style(input, "float", "right");
			set_style(input, "margin-top", "1px");
			set_style(input, "border", "0");
			set_style(input, "font-size", "17px");
			set_style(input, "outline", "0");
			set_style(input, "padding", "7px");
			add_location(input, file$r, 324, 12, 10145);
			set_style(div0, "font-size", "20px");
			set_style(div0, "padding-left", "16px");
			set_style(div0, "height", "51px");
			set_style(div0, "background-color", "#4c4c4c");
			set_style(div0, "width", "285px");
			add_location(div0, file$r, 303, 8, 9505);
			attr_dev(div1, "class", "float-left col-6 text-center py-2 border border-right border-top-0 border-left-0 border-bottom-0");
			set_style(div1, "background-color", /*actionData*/ ctx[1].mainBackColor);
			set_style(div1, "color", /*actionData*/ ctx[1].assetBackColor);
			add_location(div1, file$r, 342, 16, 10758);
			attr_dev(div2, "class", "float-right col-6 text-center py-2");
			set_style(div2, "background-color", /*actionData*/ ctx[1].assetBackColor);
			set_style(div2, "color", /*actionData*/ ctx[1].mainBackColor);
			add_location(div2, file$r, 349, 16, 11144);
			attr_dev(li, "class", "text-light p-0");
			set_style(li, "height", "37px");
			add_location(li, file$r, 341, 12, 10691);
			set_style(ul, "list-style-type", "none");
			set_style(ul, "padding", "0px");
			add_location(ul, file$r, 340, 8, 10629);
			add_location(div3, file$r, 302, 4, 9490);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div0, span);
			append_dev(div0, t0);
			append_dev(div0, input);
			append_dev(div3, t1);
			append_dev(div3, ul);
			append_dev(ul, li);
			append_dev(li, div1);
			append_dev(div1, t2);
			append_dev(li, t3);
			append_dev(li, div2);
			append_dev(div2, t4);
			append_dev(ul, t5);
			if (if_block) if_block.m(ul, null);

			if (!mounted) {
				dispose = [
					listen_dev(span, "click", /*closeFullMenu*/ ctx[11], false, false, false),
					listen_dev(input, "input", /*doSearch*/ ctx[12], false, false, false),
					listen_dev(div1, "click", /*click_handler_2*/ ctx[21], false, false, false),
					listen_dev(div2, "click", /*click_handler_3*/ ctx[22], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*actionData*/ 2) {
				set_style(div1, "background-color", /*actionData*/ ctx[1].mainBackColor);
			}

			if (dirty[0] & /*actionData*/ 2) {
				set_style(div1, "color", /*actionData*/ ctx[1].assetBackColor);
			}

			if (dirty[0] & /*actionData*/ 2) {
				set_style(div2, "background-color", /*actionData*/ ctx[1].assetBackColor);
			}

			if (dirty[0] & /*actionData*/ 2) {
				set_style(div2, "color", /*actionData*/ ctx[1].mainBackColor);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(ul, null);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);

			if (if_block) {
				if_block.d();
			}

			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$b.name,
		type: "slot",
		source: "(302:0) <Sidepanel left bind:visible={actionData.fullMenu}>",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let div3;
	let div2;
	let div0;
	let t1;
	let t2;
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t3;
	let t4;
	let sidepanel;
	let updating_visible;
	let current;
	let if_block0 = enableClose == '1' && create_if_block_4$4(ctx);
	let each_value_3 = /*editorItems*/ ctx[3];
	validate_each_argument(each_value_3);
	const get_key = ctx => /*data*/ ctx[30].id;
	validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key);

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3$2(ctx, each_value_3, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_3$2(key, child_ctx));
	}

	let if_block1 = /*openDrawer*/ ctx[0] && create_if_block_2$7(ctx);

	function sidepanel_visible_binding(value) {
		/*sidepanel_visible_binding*/ ctx[25](value);
	}

	let sidepanel_props = {
		left: true,
		$$slots: { default: [create_default_slot$b] },
		$$scope: { ctx }
	};

	if (/*actionData*/ ctx[1].fullMenu !== void 0) {
		sidepanel_props.visible = /*actionData*/ ctx[1].fullMenu;
	}

	sidepanel = new Sidepanel({ props: sidepanel_props, $$inline: true });
	binding_callbacks.push(() => bind(sidepanel, 'visible', sidepanel_visible_binding));

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			div0.textContent = "V2.0";
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			create_component(sidepanel.$$.fragment);
			attr_dev(div0, "class", "badge badge-primary font-weight-normal pt-1 pull-right");
			attr_dev(div0, "id", "item_status");
			set_style(div0, "font-size", "12px");
			set_style(div0, "letter-spacing", "1px");
			set_style(div0, "width", "38px");
			set_style(div0, "display", "inline");
			set_style(div0, "height", "18px");
			set_style(div0, "font-family", "'PT Sans Caption', sans-serif");
			set_style(div0, "margin-top", "4px");
			add_location(div0, file$r, 171, 8, 4577);
			attr_dev(div1, "class", "mainArea isotope grid");
			set_style(div1, "overflow", "auto");
			set_style(div1, "height", "379px");
			add_location(div1, file$r, 199, 8, 5451);
			attr_dev(div2, "class", "col-lg-12 pr-1");
			add_location(div2, file$r, 170, 4, 4539);
			set_style(div3, "background-color", "#FFF");
			set_style(div3, "margin-left", "56px");
			set_style(div3, "position", "relative");
			set_style(div3, "bottom", "14px");
			set_style(div3, "overflow-x", "hidden");
			set_style(div3, "padding-top", "14px");
			add_location(div3, file$r, 160, 0, 4337);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div0);
			append_dev(div2, t1);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t2);
			append_dev(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			insert_dev(target, t3, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(sidepanel, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (enableClose == '1') if_block0.p(ctx, dirty);

			if (dirty[0] & /*editorItems, actionData, isAjax, handleItemAjax, handleItem*/ 206) {
				each_value_3 = /*editorItems*/ ctx[3];
				validate_each_argument(each_value_3);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_3, each_1_lookup, div1, fix_and_destroy_block, create_each_block_3$2, null, get_each_context_3$2);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
			}

			if (/*openDrawer*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*openDrawer*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t4.parentNode, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const sidepanel_changes = {};

			if (dirty[0] & /*newGroupList, actionData, newKeywordsList*/ 50 | dirty[1] & /*$$scope*/ 128) {
				sidepanel_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*actionData*/ 2) {
				updating_visible = true;
				sidepanel_changes.visible = /*actionData*/ ctx[1].fullMenu;
				add_flush_callback(() => updating_visible = false);
			}

			sidepanel.$set(sidepanel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(sidepanel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			transition_out(sidepanel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (if_block0) if_block0.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach_dev(t3);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t4);
			destroy_component(sidepanel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditorModules', slots, []);
	let { isAjax } = $$props;
	let { onClose = false } = $$props;
	let { openDrawer = false } = $$props;
	let { goback } = $$props;
	let { editorItems } = $$props;
	let { actionData } = $$props;
	let { newGroupList } = $$props;
	let { newKeywordsList } = $$props;
	let { ajaxData } = $$props;
	let grid;
	let filters = [];

	onMount(async () => {
		initIsotope();
		AH.enableBsAll("[data-bs-toggle='tooltip']", 'Tooltip', { container: 'body' });
	});

	function initIsotope() {
		setTimeout(
			function () {
				grid = new Isotope(document.querySelector('.grid'),
				{
						itemSelector: '.grid-item',
						layoutMode: 'fitRows',
						getSortData: {
							subtype: "[data-subtype]",
							group: "[data-group] parseInt"
						}
					});

				grid.arrange({ sortBy: 'group', sortAscending: true });
			},
			100
		);
	}

	function handleItem(data, isReload) {
		if (from_myproject != 1) {
			AH.updateEditorUrl(data);
		}

		$$invalidate(15, ajaxData = "");
		AI.set("editorActivated", false);
		$$invalidate(1, actionData.content_icon = data.content_icon, actionData);
		$$invalidate(1, actionData.type = data.type, actionData);
		$$invalidate(1, actionData.loaditem = data.subtype, actionData);
		$$invalidate(1, actionData.itemXML = data.xml, actionData);
		$$invalidate(1, actionData.inline_item = data.inline_item, actionData);
		$$invalidate(1, actionData.is_algo = data.is_algo, actionData);
		$$invalidate(1, actionData.editorKey += 1, actionData);
	}

	function handleItemAjax(data, isReload) {
		if (isReload) {
			if (data.action == "new") {
				if (from_myproject != 1) {
					AH.updateEditorUrl(data);
				}

				content_guid = "";
				$$invalidate(15, ajaxData = "");
				AI.set('isAjax', false);
			}
		}

		AI.set("editorActivated", false);
		$$invalidate(1, actionData.content_icon = data.content_icon, actionData);
		$$invalidate(1, actionData.moduleType = data.type, actionData);
		$$invalidate(1, actionData.type = data.type, actionData);
		$$invalidate(1, actionData.loaditem = data.subtype, actionData);
		$$invalidate(1, actionData.itemXML = data.xml, actionData);
		$$invalidate(1, actionData.inline_item = data.inline_item, actionData);
		$$invalidate(1, actionData.is_algo = data.is_algo, actionData);
		$$invalidate(1, actionData.editorKey += 1, actionData);
		$$invalidate(1, actionData.drawerBox = false, actionData);
	}

	async function openFullMenu() {
		$$invalidate(1, actionData.menuView = "main", actionData);
		$$invalidate(1, actionData.assetBackColor = "#dddddd", actionData);
		$$invalidate(1, actionData.mainBackColor = "#4c4c4c", actionData);
		($$invalidate(1, actionData.fullMenu = true, actionData), $$invalidate(1, actionData.sidePane = false, actionData));
		await tick();
	}

	function filterGroup(group) {
		AH.selectAll(".shortList", 'css', { backgroundColor: "#fff" });
		AH.select("#" + group, 'css', { backgroundColor: "#f3f3f3" });

		grid.arrange({
			filter: group == "all_item" ? "*" : "." + group
		});

		closeFullMenu();
	}

	function filterAdvance(e) {
		grid.arrange({
			filter(_this) {
				if (e == "all") return true;

				if (_this.getAttribute("data-keywords")) {
					let keywords = _this.getAttribute("data-keywords").split(",");

					for (let i = 0; i < keywords.length; i++) {
						if (keywords[i].trim() == e) {
							return true;
						}
					}
				}

				return false;
			}
		});

		closeFullMenu();
	}

	function closeFullMenu() {
		$$invalidate(1, actionData.sidePane = true, actionData);
		$$invalidate(1, actionData.fullMenu = false, actionData);
	}

	function doSearch(e) {
		filters[0] = e.target.value;
		runFilter(filters[0]);
	}

	function runFilter(filters) {
		grid.arrange({
			filter(_this) {
				if (filters) {
					var qsRegex = new RegExp(filters, 'gi');

					if (!_this.querySelector('#itemTitle').textContent.match(qsRegex)) {
						return false;
					}
				}

				return true;
			}
		});
	}

	function menuView(view) {
		if (view == "main") {
			$$invalidate(1, actionData.menuView = "main", actionData);
			$$invalidate(1, actionData.mainBackColor = "#4c4c4c", actionData);
			$$invalidate(1, actionData.assetBackColor = "#dddddd", actionData);
		} else if (view == "asset") {
			$$invalidate(1, actionData.menuView = "asset", actionData);
			$$invalidate(1, actionData.mainBackColor = "#dddddd", actionData);
			$$invalidate(1, actionData.assetBackColor = "#4c4c4c", actionData);
		}
	}

	function onCloseBtn(enableClose, onClose) {
		if (enableClose) {
			onClose
			? onClose(false)
			: $$invalidate(1, actionData.editorModalHandle = false, actionData);
		} else {
			author_area
			? window.parent.close_frame_modal()
			: window.parent.editorClose();
		}
	}

	const writable_props = [
		'isAjax',
		'onClose',
		'openDrawer',
		'goback',
		'editorItems',
		'actionData',
		'newGroupList',
		'newKeywordsList',
		'ajaxData'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditorModules> was created with unknown prop '${key}'`);
	});

	const click_handler = () => onCloseBtn();
	const click_handler_1 = data => isAjax ? handleItemAjax(data) : handleItem(data);
	const close_handler = () => $$invalidate(0, openDrawer = false);
	const click_handler_2 = () => menuView("main");
	const click_handler_3 = () => menuView("asset");
	const click_handler_4 = data => filterGroup(data.name);
	const click_handler_5 = data2 => filterAdvance(data2.name);

	function sidepanel_visible_binding(value) {
		if ($$self.$$.not_equal(actionData.fullMenu, value)) {
			actionData.fullMenu = value;
			$$invalidate(1, actionData);
		}
	}

	$$self.$$set = $$props => {
		if ('isAjax' in $$props) $$invalidate(2, isAjax = $$props.isAjax);
		if ('onClose' in $$props) $$invalidate(16, onClose = $$props.onClose);
		if ('openDrawer' in $$props) $$invalidate(0, openDrawer = $$props.openDrawer);
		if ('goback' in $$props) $$invalidate(17, goback = $$props.goback);
		if ('editorItems' in $$props) $$invalidate(3, editorItems = $$props.editorItems);
		if ('actionData' in $$props) $$invalidate(1, actionData = $$props.actionData);
		if ('newGroupList' in $$props) $$invalidate(4, newGroupList = $$props.newGroupList);
		if ('newKeywordsList' in $$props) $$invalidate(5, newKeywordsList = $$props.newKeywordsList);
		if ('ajaxData' in $$props) $$invalidate(15, ajaxData = $$props.ajaxData);
	};

	$$self.$capture_state = () => ({
		Drawer,
		Sidepanel,
		AH,
		flip,
		onMount,
		tick,
		isAjax,
		onClose,
		openDrawer,
		goback,
		editorItems,
		actionData,
		newGroupList,
		newKeywordsList,
		ajaxData,
		grid,
		filters,
		initIsotope,
		handleItem,
		handleItemAjax,
		openFullMenu,
		filterGroup,
		filterAdvance,
		closeFullMenu,
		doSearch,
		runFilter,
		menuView,
		onCloseBtn
	});

	$$self.$inject_state = $$props => {
		if ('isAjax' in $$props) $$invalidate(2, isAjax = $$props.isAjax);
		if ('onClose' in $$props) $$invalidate(16, onClose = $$props.onClose);
		if ('openDrawer' in $$props) $$invalidate(0, openDrawer = $$props.openDrawer);
		if ('goback' in $$props) $$invalidate(17, goback = $$props.goback);
		if ('editorItems' in $$props) $$invalidate(3, editorItems = $$props.editorItems);
		if ('actionData' in $$props) $$invalidate(1, actionData = $$props.actionData);
		if ('newGroupList' in $$props) $$invalidate(4, newGroupList = $$props.newGroupList);
		if ('newKeywordsList' in $$props) $$invalidate(5, newKeywordsList = $$props.newKeywordsList);
		if ('ajaxData' in $$props) $$invalidate(15, ajaxData = $$props.ajaxData);
		if ('grid' in $$props) grid = $$props.grid;
		if ('filters' in $$props) filters = $$props.filters;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		openDrawer,
		actionData,
		isAjax,
		editorItems,
		newGroupList,
		newKeywordsList,
		handleItem,
		handleItemAjax,
		openFullMenu,
		filterGroup,
		filterAdvance,
		closeFullMenu,
		doSearch,
		menuView,
		onCloseBtn,
		ajaxData,
		onClose,
		goback,
		click_handler,
		click_handler_1,
		close_handler,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		sidepanel_visible_binding
	];
}

class EditorModules extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$s,
			create_fragment$s,
			safe_not_equal,
			{
				isAjax: 2,
				onClose: 16,
				openDrawer: 0,
				goback: 17,
				editorItems: 3,
				actionData: 1,
				newGroupList: 4,
				newKeywordsList: 5,
				ajaxData: 15
			},
			add_css$j,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditorModules",
			options,
			id: create_fragment$s.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isAjax*/ ctx[2] === undefined && !('isAjax' in props)) {
			console.warn("<EditorModules> was created without expected prop 'isAjax'");
		}

		if (/*goback*/ ctx[17] === undefined && !('goback' in props)) {
			console.warn("<EditorModules> was created without expected prop 'goback'");
		}

		if (/*editorItems*/ ctx[3] === undefined && !('editorItems' in props)) {
			console.warn("<EditorModules> was created without expected prop 'editorItems'");
		}

		if (/*actionData*/ ctx[1] === undefined && !('actionData' in props)) {
			console.warn("<EditorModules> was created without expected prop 'actionData'");
		}

		if (/*newGroupList*/ ctx[4] === undefined && !('newGroupList' in props)) {
			console.warn("<EditorModules> was created without expected prop 'newGroupList'");
		}

		if (/*newKeywordsList*/ ctx[5] === undefined && !('newKeywordsList' in props)) {
			console.warn("<EditorModules> was created without expected prop 'newKeywordsList'");
		}

		if (/*ajaxData*/ ctx[15] === undefined && !('ajaxData' in props)) {
			console.warn("<EditorModules> was created without expected prop 'ajaxData'");
		}
	}

	get isAjax() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isAjax(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onClose() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onClose(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get openDrawer() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set openDrawer(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get goback() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set goback(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorItems() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorItems(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get actionData() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set actionData(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get newGroupList() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set newGroupList(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get newKeywordsList() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set newKeywordsList(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ajaxData() {
		throw new Error("<EditorModules>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ajaxData(value) {
		throw new Error("<EditorModules>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\App.svelte generated by Svelte v3.40.2 */

const { Object: Object_1$7, console: console_1$b } = globals;
const file$s = "src\\App.svelte";

// (312:2) {:else}
function create_else_block_1$3(ctx) {
	let editormodules;
	let updating_actionData;
	let updating_ajaxData;
	let current;

	function editormodules_actionData_binding(value) {
		/*editormodules_actionData_binding*/ ctx[8](value);
	}

	function editormodules_ajaxData_binding(value) {
		/*editormodules_ajaxData_binding*/ ctx[9](value);
	}

	let editormodules_props = {
		editorItems: /*editorItems*/ ctx[4],
		newKeywordsList: /*newKeywordsList*/ ctx[2],
		newGroupList: /*newGroupList*/ ctx[1],
		openDrawer: true
	};

	if (/*state*/ ctx[3] !== void 0) {
		editormodules_props.actionData = /*state*/ ctx[3];
	}

	if (/*ajaxData*/ ctx[0] !== void 0) {
		editormodules_props.ajaxData = /*ajaxData*/ ctx[0];
	}

	editormodules = new EditorModules({
			props: editormodules_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(editormodules, 'actionData', editormodules_actionData_binding));
	binding_callbacks.push(() => bind(editormodules, 'ajaxData', editormodules_ajaxData_binding));

	const block = {
		c: function create() {
			create_component(editormodules.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(editormodules, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editormodules_changes = {};
			if (dirty & /*newKeywordsList*/ 4) editormodules_changes.newKeywordsList = /*newKeywordsList*/ ctx[2];
			if (dirty & /*newGroupList*/ 2) editormodules_changes.newGroupList = /*newGroupList*/ ctx[1];

			if (!updating_actionData && dirty & /*state*/ 8) {
				updating_actionData = true;
				editormodules_changes.actionData = /*state*/ ctx[3];
				add_flush_callback(() => updating_actionData = false);
			}

			if (!updating_ajaxData && dirty & /*ajaxData*/ 1) {
				updating_ajaxData = true;
				editormodules_changes.ajaxData = /*ajaxData*/ ctx[0];
				add_flush_callback(() => updating_ajaxData = false);
			}

			editormodules.$set(editormodules_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editormodules.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editormodules.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editormodules, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$3.name,
		type: "else",
		source: "(312:2) {:else}",
		ctx
	});

	return block;
}

// (310:2) {#if editorItems.length == 0}
function create_if_block_3$6(ctx) {
	let center;
	let loader;
	let current;
	loader = new Loader({ props: { size: 100 }, $$inline: true });

	const block = {
		c: function create() {
			center = element("center");
			create_component(loader.$$.fragment);
			set_style(center, "position", "relative");
			set_style(center, "top", window.innerHeight * .4 + "px");
			add_location(center, file$s, 310, 3, 9787);
		},
		m: function mount(target, anchor) {
			insert_dev(target, center, anchor);
			mount_component(loader, center, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(center);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$6.name,
		type: "if",
		source: "(310:2) {#if editorItems.length == 0}",
		ctx
	});

	return block;
}

// (289:1) {#if state.loaditem != 'Default'}
function create_if_block_1$9(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$8, create_else_block$8];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*state*/ ctx[3].loaditem == "Blank") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(289:1) {#if state.loaditem != 'Default'}",
		ctx
	});

	return block;
}

// (292:2) {:else}
function create_else_block$8(ctx) {
	let editor;
	let updating_actionData;
	let current;

	function editor_actionData_binding(value) {
		/*editor_actionData_binding*/ ctx[7](value);
	}

	let editor_props = {
		key: /*state*/ ctx[3].editorKey,
		ajaxData: /*ajaxData*/ ctx[0],
		content_guid: /*state*/ ctx[3].content_guid,
		item: /*state*/ ctx[3].loaditem,
		itemXML: /*state*/ ctx[3].itemXML,
		moduleType: /*state*/ ctx[3].type,
		subtype: /*state*/ ctx[3].loaditem,
		content_icon: /*state*/ ctx[3].content_icon,
		inline_item: /*state*/ ctx[3].inline_item,
		is_algo: /*state*/ ctx[3].is_algo,
		_user: /*state*/ ctx[3]._user,
		advanceXml: /*advanceXml*/ ctx[5]
	};

	if (/*state*/ ctx[3] !== void 0) {
		editor_props.actionData = /*state*/ ctx[3];
	}

	editor = new Editor({ props: editor_props, $$inline: true });
	binding_callbacks.push(() => bind(editor, 'actionData', editor_actionData_binding));

	const block = {
		c: function create() {
			create_component(editor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(editor, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editor_changes = {};
			if (dirty & /*state*/ 8) editor_changes.key = /*state*/ ctx[3].editorKey;
			if (dirty & /*ajaxData*/ 1) editor_changes.ajaxData = /*ajaxData*/ ctx[0];
			if (dirty & /*state*/ 8) editor_changes.content_guid = /*state*/ ctx[3].content_guid;
			if (dirty & /*state*/ 8) editor_changes.item = /*state*/ ctx[3].loaditem;
			if (dirty & /*state*/ 8) editor_changes.itemXML = /*state*/ ctx[3].itemXML;
			if (dirty & /*state*/ 8) editor_changes.moduleType = /*state*/ ctx[3].type;
			if (dirty & /*state*/ 8) editor_changes.subtype = /*state*/ ctx[3].loaditem;
			if (dirty & /*state*/ 8) editor_changes.content_icon = /*state*/ ctx[3].content_icon;
			if (dirty & /*state*/ 8) editor_changes.inline_item = /*state*/ ctx[3].inline_item;
			if (dirty & /*state*/ 8) editor_changes.is_algo = /*state*/ ctx[3].is_algo;
			if (dirty & /*state*/ 8) editor_changes._user = /*state*/ ctx[3]._user;

			if (!updating_actionData && dirty & /*state*/ 8) {
				updating_actionData = true;
				editor_changes.actionData = /*state*/ ctx[3];
				add_flush_callback(() => updating_actionData = false);
			}

			editor.$set(editor_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$8.name,
		type: "else",
		source: "(292:2) {:else}",
		ctx
	});

	return block;
}

// (290:2) {#if state.loaditem == "Blank"}
function create_if_block_2$8(ctx) {
	let center;
	let t;

	const block = {
		c: function create() {
			center = element("center");
			t = text("Checking Module...");
			set_style(center, "position", "relative");
			set_style(center, "top", window.innerHeight * .4 + "px");
			add_location(center, file$s, 290, 3, 9207);
		},
		m: function mount(target, anchor) {
			insert_dev(target, center, anchor);
			append_dev(center, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(center);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$8.name,
		type: "if",
		source: "(290:2) {#if state.loaditem == \\\"Blank\\\"}",
		ctx
	});

	return block;
}

// (323:1) {#if state.drawerBox}
function create_if_block$m(ctx) {
	let drawer;
	let current;

	drawer = new Drawer({
			props: {
				width: 700,
				$$slots: {
					content: [create_content_slot$1],
					header: [create_header_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	drawer.$on("close", /*close_handler*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(drawer.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(drawer, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const drawer_changes = {};

			if (dirty & /*$$scope, newKeywordsList, newGroupList, state*/ 33554446) {
				drawer_changes.$$scope = { dirty, ctx };
			}

			drawer.$set(drawer_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(drawer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(drawer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(drawer, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$m.name,
		type: "if",
		source: "(323:1) {#if state.drawerBox}",
		ctx
	});

	return block;
}

// (328:3) 
function create_header_slot(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			div.textContent = "Pradeep";
			attr_dev(div, "slot", "header");
			add_location(div, file$s, 327, 3, 10240);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_header_slot.name,
		type: "slot",
		source: "(328:3) ",
		ctx
	});

	return block;
}

// (329:3) 
function create_content_slot$1(ctx) {
	let div;
	let editormodules;
	let updating_actionData;
	let current;

	function editormodules_actionData_binding_1(value) {
		/*editormodules_actionData_binding_1*/ ctx[10](value);
	}

	let editormodules_props = {
		editorItems: /*editorItems*/ ctx[4],
		newKeywordsList: /*newKeywordsList*/ ctx[2],
		newGroupList: /*newGroupList*/ ctx[1],
		openDrawer: true,
		isAjax: true
	};

	if (/*state*/ ctx[3] !== void 0) {
		editormodules_props.actionData = /*state*/ ctx[3];
	}

	editormodules = new EditorModules({
			props: editormodules_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(editormodules, 'actionData', editormodules_actionData_binding_1));

	const block = {
		c: function create() {
			div = element("div");
			create_component(editormodules.$$.fragment);
			attr_dev(div, "slot", "content");
			add_location(div, file$s, 328, 3, 10277);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(editormodules, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editormodules_changes = {};
			if (dirty & /*newKeywordsList*/ 4) editormodules_changes.newKeywordsList = /*newKeywordsList*/ ctx[2];
			if (dirty & /*newGroupList*/ 2) editormodules_changes.newGroupList = /*newGroupList*/ ctx[1];

			if (!updating_actionData && dirty & /*state*/ 8) {
				updating_actionData = true;
				editormodules_changes.actionData = /*state*/ ctx[3];
				add_flush_callback(() => updating_actionData = false);
			}

			editormodules.$set(editormodules_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editormodules.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editormodules.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(editormodules);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_content_slot$1.name,
		type: "slot",
		source: "(329:3) ",
		ctx
	});

	return block;
}

function create_fragment$t(ctx) {
	let main;
	let current_block_type_index;
	let if_block0;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$9, create_if_block_3$6, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*state*/ ctx[3].loaditem != 'Default') return 0;
		if (/*editorItems*/ ctx[4].length == 0) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*state*/ ctx[3].drawerBox && create_if_block$m(ctx);

	const block = {
		c: function create() {
			main = element("main");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr_dev(main, "class", "p-0");
			add_location(main, file$s, 272, 0, 8689);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			if_blocks[current_block_type_index].m(main, null);
			append_dev(main, t);
			if (if_block1) if_block1.m(main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(main, t);
			}

			if (/*state*/ ctx[3].drawerBox) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*state*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$m(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(main, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('App', slots, []);
	let { ajaxData } = $$props;
	let { subtype } = $$props;
	let allItem = [];
	let groupList = [];
	let keywordsList = [];
	let newGroupList = [];
	let newKeywordsList = [];
	let editorItems = [];
	let editorUrl = new URLSearchParams(window.location.search);
	let ajaxRes = "";
	let apiData = {};
	let server = window.baseUrl + "/editor/svelteEditor.php";
	let state = {};

	let hdd = writable({
		loaditem: "Default",
		_user: {},
		_course: "",
		drawerBox: false,
		itemXML: "",
		sidePane: true,
		type: "",
		content_icon: "",
		fullMenu: false,
		ajaxData: '',
		inline_item: "",
		is_algo: "",
		allItemTemp: "",
		menuView: "main",
		mainBackColor: "#4c4c4c",
		assetBackColor: "#dddddd",
		editorKey: 1,
		editorModalHandle: false,
		embed: false
	});

	const unsubscribe = hdd.subscribe(items => {
		$$invalidate(3, state = items);
	});

	beforeUpdate(() => {
		if (!window.AI) window.AI = AH;
	});

	onMount(async () => {
		let appPass = SSD.get('apiAccessToken')
		? {
				status: 'Success',
				access_token: SSD.get('apiAccessToken')
			}
		: await AH.validateApp(false);

		if (appPass.status == 'Success') {
			console.warn("Access key set successfull.");
			window.ssd = SSD;

			if (SSD.get('apiAccessToken') !== appPass.access_token) {
				console.warn("Access key not found in storage.");
				SSD.set('apiAccessToken', appPass.access_token);
			}

			AH.setApiKey(appPass.access_token);

			let where = {
				content_guid: editorUrl.get('content_guid'),
				columns: 'content_text,content_guid,content_type,content_subtype,content_icon,snippet,content_id',
				full_data: 3
			};

			let searchQuery = {};

			for (const [key, value] of editorUrl.entries()) {
				if (window.hasOwnProperty(key)) {
					window[key] = value;
				}

				searchQuery[key] = value;
			}

			if (editorUrl.get('content_guid')) {
				AH.getAPIDataJ('cat2.item_content_draft_get', where, async res => {
					apiData = await checkRevision(res);
					apiData = apiData[editorUrl.get('content_guid')];
					searchQuery['content'] = JSON.stringify(apiData);
					ajaxRes = await AI.ajax({ url: server, data: searchQuery });
					onDataGet();
				});
			} else {
				ajaxRes = await AH.ajax({ url: server, data: searchQuery });
				onDataGet();
			}
		}
	});

	// To find revision of content guid
	function checkRevision(res) {
		return new Promise((resolve, reject) => {
				if (editorUrl.get('get-diff')) {
					let where = {
						version_date: editorUrl.get('version_date'),
						content_guid: editorUrl.get('content_guid')
					};

					if (editorUrl.get('from_draft') != '') {
						where.isDraft = editorUrl.get('from_draft');
					}

					AH.getAPIDataJ('cat2.deliveryengine_get_previous_content', where, result => {
						res[where.content_guid]['content_text'] = result['content_text'];
						resolve(res);
					});
				} else {
					resolve(res);
				}
			});
	}

	// To get data of guid and set params for edit.
	function onDataGet() {
		if (AH.isValid(ajaxRes)) {
			ajaxRes = JSON.parse(ajaxRes);

			Object.keys(ajaxRes).forEach(key => {
				if (window.hasOwnProperty(key)) window[key] = ajaxRes[key];
			});

			if (ajaxRes['userArray']) {
				window.userArray = ajaxRes['userArray'];
				let response = JSON.parse(ajaxRes['userArray']);
				window.editor.save = response.save;
				window.editor.course = response.course;
				window.user_guid = response.user_guid;

				$$invalidate(
					3,
					state._user = {
						first_name: response.first_name,
						last_name: response.last_name,
						user_guid: response.user_guid
					},
					state
				);

				if (window.origin.includes('https://') && location.host != "localhost") {
					response.siteurl = response.siteurl.replace('http://', 'https://');
				}

				baseUrl = response.siteurl;
				window.editor.baseUrlTheme = response.siteurl + "layout/themes/bootstrap4/";

				/* Grouping of All Editor Item */
				$$invalidate(1, newGroupList = []);

				$$invalidate(2, newKeywordsList = []);
				groupList = response.editor_item_group_detail;
				keywordsList = response.editor_item_type_keywords;

				for (let i in keywordsList) {
					newKeywordsList.push({
						icon: keywordsList[i].icon,
						title: keywordsList[i].title,
						name: i
					});
				}

				newGroupList.push({
					name: "all_item",
					icon: "icomoon-stack-3",
					title: l$1.all_item
				});

				let count_grp = 0;

				for (let i in groupList) {
					newGroupList.push({
						name: i,
						icon: groupList[i].icon,
						title: groupList[i].heading,
						group_seq: count_grp + "_" + i
					});

					count_grp++;
				}

				/* END */
				/* Listing of All Editor Item */
				let alphabet = ("a,c,e,f,p,q,s").split(',');

				let getUrlVarsData = AH.getUrlVars();

				if (getUrlVarsData['group_type'] && getUrlVarsData['group_type'] != 0) {
					//Code for Show 1 group of items
					alphabet.length = 0;

					if (getUrlVarsData['group_type'] == 's') {
						alphabet = ['s', 'f'];
					} else if (getUrlVarsData['group_type'].indexOf(",")) {
						alphabet = getUrlVarsData['group_type'].split(',');
					} else {
						alphabet[0] = getUrlVarsData['group_type'];
					}
				}

				allItem = response.editor_item_type_details;
				$$invalidate(3, state.allItemTemp = allItem, state);
				allItem = JSON.stringify(allItem);
				allItem = JSON.parse(allItem);

				alphabet.forEach(letter => {
					createEditorArray(allItem[letter], editorItems, letter);
				});

				/* END */
				if (editorUrl.get('content_subtype') && editorUrl.get('content_type')) {
					$$invalidate(3, state.type = editorUrl.get('content_type'), state);
					$$invalidate(3, state.content_icon = editorUrl.get('content_icon'), state);

					editorItems.forEach(n => {
						if (editorUrl.get('content_type') == n.type && editorUrl.get('content_subtype') == n.subtype && editorUrl.get('content_icon') == n.content_icon) {
							$$invalidate(3, state.itemXML = n.xml, state);
							$$invalidate(3, state.inline_item = n.inline_item, state);
							$$invalidate(3, state.is_algo = n.is_algo, state);
						}
					});

					$$invalidate(3, state.loaditem = parseInt(editorUrl.get('content_subtype')), state);
				}
			}

			if (ajaxRes['domains'] && editorUrl.get('from_myproject') == "1") {
				window.is_domain = Object.keys(ajaxRes['domains']).length > 0 ? 1 : 0;
			}

			//if (ajaxRes['user']) state._user = ajaxRes['user'];
			if (editorUrl.get('content_guid')) {
				content_for_newEditor = ajaxRes['content_for_newEditor']
				? JSON.parse(ajaxRes['content_for_newEditor'])
				: "";

				$$invalidate(0, ajaxData = content_for_newEditor);
				$$invalidate(3, state.content_guid = ajaxData.content_guid, state);
				$$invalidate(3, state.type = ajaxData.content_type, state);
				$$invalidate(6, subtype = parseInt(ajaxData.content_subtype));
				$$invalidate(3, state.content_icon = ajaxData.content_icon, state);
				$$invalidate(3, state.loaditem = parseInt(ajaxData.content_subtype), state);
			}
		}
	}

	function createEditorArray(allItem, editorItems, content_type) {
		let getUrlVarsData = AH.getUrlVars();
		let id = 0;

		for (let subtype in allItem) {
			for (let icon in allItem[subtype]) {
				let currentItem = allItem[subtype][icon];

				if (getUrlVarsData['is_flashcard'] == '1' && content_type == "f" && currentItem.is_flashcard != 1) {
					continue;
				}

				if (is_external == "1") {
					if (currentItem.visible < 1) {
						continue;
					} // Hiding selected item for External users.
				}

				editorItems.push({
					id: content_type + "_" + id,
					title: currentItem.title,
					icon: currentItem.icon,
					type: currentItem.type,
					subtype: currentItem.subtype,
					content_icon: currentItem.content_icon,
					grading: currentItem.grading,
					category: currentItem.category,
					xml: currentItem.xml,
					group: currentItem.group,
					visible: currentItem.visible,
					inline_item: currentItem.inline_item ? currentItem.inline_item : "0",
					is_algo: currentItem.algo ? currentItem.algo : "0",
					grp_seq: setGrpSeq(currentItem.group),
					keywords: currentItem.keywords ? currentItem.keywords : ""
				});

				id++;
			}
		}

		return editorItems;
	}

	function setGrpSeq(grp) {
		for (let g in newGroupList) {
			if (newGroupList[g].name == grp) {
				return newGroupList[g].group_seq;
			}
		}
	}

	function advanceXml(newXMl, subtype) {
		$$invalidate(3, state.loaditem = "Blank", state);

		setTimeout(
			() => {
				$$invalidate(3, state.loaditem = parseInt(subtype), state);
			},
			100
		);
	}

	const writable_props = ['ajaxData', 'subtype'];

	Object_1$7.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$b.warn(`<App> was created with unknown prop '${key}'`);
	});

	function editor_actionData_binding(value) {
		state = value;
		$$invalidate(3, state);
	}

	function editormodules_actionData_binding(value) {
		state = value;
		$$invalidate(3, state);
	}

	function editormodules_ajaxData_binding(value) {
		ajaxData = value;
		$$invalidate(0, ajaxData);
	}

	function editormodules_actionData_binding_1(value) {
		state = value;
		$$invalidate(3, state);
	}

	const close_handler = () => $$invalidate(3, state.drawerBox = false, state);

	$$self.$$set = $$props => {
		if ('ajaxData' in $$props) $$invalidate(0, ajaxData = $$props.ajaxData);
		if ('subtype' in $$props) $$invalidate(6, subtype = $$props.subtype);
	};

	$$self.$capture_state = () => ({
		onMount,
		beforeUpdate,
		tick,
		writable,
		Drawer,
		AH,
		SSD,
		Loader,
		Editor,
		EditorModules,
		l: l$1,
		Button,
		ajaxData,
		subtype,
		allItem,
		groupList,
		keywordsList,
		newGroupList,
		newKeywordsList,
		editorItems,
		editorUrl,
		ajaxRes,
		apiData,
		server,
		state,
		hdd,
		unsubscribe,
		checkRevision,
		onDataGet,
		createEditorArray,
		setGrpSeq,
		advanceXml
	});

	$$self.$inject_state = $$props => {
		if ('ajaxData' in $$props) $$invalidate(0, ajaxData = $$props.ajaxData);
		if ('subtype' in $$props) $$invalidate(6, subtype = $$props.subtype);
		if ('allItem' in $$props) allItem = $$props.allItem;
		if ('groupList' in $$props) groupList = $$props.groupList;
		if ('keywordsList' in $$props) keywordsList = $$props.keywordsList;
		if ('newGroupList' in $$props) $$invalidate(1, newGroupList = $$props.newGroupList);
		if ('newKeywordsList' in $$props) $$invalidate(2, newKeywordsList = $$props.newKeywordsList);
		if ('editorItems' in $$props) $$invalidate(4, editorItems = $$props.editorItems);
		if ('editorUrl' in $$props) editorUrl = $$props.editorUrl;
		if ('ajaxRes' in $$props) ajaxRes = $$props.ajaxRes;
		if ('apiData' in $$props) apiData = $$props.apiData;
		if ('server' in $$props) server = $$props.server;
		if ('state' in $$props) $$invalidate(3, state = $$props.state);
		if ('hdd' in $$props) hdd = $$props.hdd;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		ajaxData,
		newGroupList,
		newKeywordsList,
		state,
		editorItems,
		advanceXml,
		subtype,
		editor_actionData_binding,
		editormodules_actionData_binding,
		editormodules_ajaxData_binding,
		editormodules_actionData_binding_1,
		close_handler
	];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$t, create_fragment$t, safe_not_equal, { ajaxData: 0, subtype: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment$t.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*ajaxData*/ ctx[0] === undefined && !('ajaxData' in props)) {
			console_1$b.warn("<App> was created without expected prop 'ajaxData'");
		}

		if (/*subtype*/ ctx[6] === undefined && !('subtype' in props)) {
			console_1$b.warn("<App> was created without expected prop 'subtype'");
		}
	}

	get ajaxData() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ajaxData(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtype() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtype(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const app = new App({
	target: document.getElementById("editor"),
	props: {}
});

export { add_flush_callback as $, AH as A, noop as B, validate_each_argument as C, validate_each_keys as D, is_function as E, set_data_dev as F, prop_dev as G, run_all as H, update_keyed_each as I, destroy_block as J, destroy_each as K, beforeUpdate as L, append_styles as M, JSONToXML as N, JUI as O, Dialog as P, binding_callbacks as Q, bind as R, SvelteComponentDev as S, Snackbar as T, Draggable as U, Button as V, Checkbox as W, XMLToJSON as X, src_url_equal as Y, stop_propagation as Z, prevent_default as _, transition_out as a, select_value as a0, add_render_callback as a1, set_input_value as a2, select_option as a3, tick as a4, onUserAnsChange as a5, null_to_empty as a6, createEventDispatcher as a7, toggle_class as a8, HtmlTag as a9, onDestroy as aa, swal as ab, add_resize_listener as ac, afterUpdate as ad, Loader as ae, to_number as af, createCommonjsModule as ag, commonjsGlobal as ah, tag_player as ai, Textfield as aj, jquery as ak, svg_element as al, action_destroyer as am, editorConfig as an, app as ao, destroy_component as b, create_component as c, dispatch_dev as d, element as e, space as f, globals as g, text as h, init as i, attr_dev as j, add_location as k, set_style as l, mount_component as m, insert_dev as n, onMount as o, append_dev as p, listen_dev as q, group_outros as r, safe_not_equal as s, transition_in as t, check_outros as u, validate_slots as v, writable as w, detach_dev as x, l$1 as y, empty as z };
//# sourceMappingURL=main-ac8251c7.js.map
