
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, v as validate_slots, L as beforeUpdate, a9 as afterUpdate, o as onMount, X as XMLToJSON, A as AH, _ as onUserAnsChange, w as writable, C as validate_each_argument, z as empty, n as insert_dev, K as destroy_each, x as detach_dev, h as text, j as attr_dev, l as set_style, k as add_location, F as set_data_dev, f as space, c as create_component, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, q as listen_dev, G as prop_dev } from './main-6ec656b8.js';
import { I as ItemHelper } from './ItemHelper-ef05730e.js';
import { p as parseCSV } from './parseCSV-b8df5647.js';

/* clsSMChoiceMatrix\ChoiceMatrixPreview.svelte generated by Svelte v3.29.0 */

const { document: document_1 } = globals;
const file = "clsSMChoiceMatrix\\ChoiceMatrixPreview.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-qkuer1-style";
	style.textContent = ".fa-check{color:#46A546;position:relative;left:50px}.fa-close{color:#A80000;left:50px}.fa-close,.fa-check{margin-left:-26px;font-size:18px;position:relative;bottom:10px}.fa-close,.fa-check,.middle_align{vertical-align:middle!important}.middle_align{width:164px;min-width:164px}.topic_input{min-width:257px}.preview_header{font-size:16pt;font-weight:bold;vertical-align:middle}.adjust_width{width:10%;text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hvaWNlTWF0cml4UHJldmlldy5zdmVsdGUiLCJzb3VyY2VzIjpbIkNob2ljZU1hdHJpeFByZXZpZXcuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cclxuICogICBGaWxlIE5hbWUgICA6IENob2ljZU1hdHJpeFByZXZpZXcuc3ZlbHRlXHJcbiAqICAgRGVzY3JpcHRpb24gOiBDaG9pY2UgTWF0cml4IG1vZHVsZVxyXG4gKiAgIEF1dGhvciAgICAgIDogU3VuZGFyYW0gVHJpcGF0aGkgKHVjLXNkdClcclxuICogICBQYWNrYWdlICAgICA6IHN2ZWx0ZV9pdGVtc1xyXG4gKiAgIExhc3QgdXBkYXRlIDogMDUtTWF5LTIwMjFcclxuICogICBMYXN0IFVwZGF0ZSBCeSA6IFByYWRlZXAgWWFkYXZcclxuIC0tPlxyXG4gPHNjcmlwdD5cclxuICAgIGltcG9ydCBsaWIgZnJvbSAnLi9wYXJzZUNTVi5qcyc7IFxyXG4gICAgaW1wb3J0IHsgb25Nb3VudCxiZWZvcmVVcGRhdGUsYWZ0ZXJVcGRhdGUgfSBmcm9tIFwic3ZlbHRlXCI7XHJcbiAgICBpbXBvcnQge0FILFhNTFRvSlNPTiwgb25Vc2VyQW5zQ2hhbmdlIH0gZnJvbSBcIi4uL2hlbHBlci9IZWxwZXJBSS5zdmVsdGVcIjtcclxuICAgIGltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xyXG4gICAgaW1wb3J0IEl0ZW1IZWxwZXIgZnJvbSAnLi4vaGVscGVyL0l0ZW1IZWxwZXIuc3ZlbHRlJztcclxuICAgIGV4cG9ydCBsZXQgc2hvd0FucztcclxuICAgIGV4cG9ydCBsZXQgZWRpdG9yU3RhdGU7XHJcbiAgICBleHBvcnQgbGV0IHhtbDsgXHJcbiAgICBleHBvcnQgbGV0IHV4bWw7XHJcbiAgICBleHBvcnQgbGV0IGlzUmV2aWV3O1xyXG4gICAgbGV0IHVzZXJhbnNOZXc7XHJcblxyXG4gICAgbGV0IGNtID0geyBjZGF0YTpcIlwiIH07XHJcbiAgICBsZXQgaXNJRTtcclxuICAgIGxldCBtYWluSWQgPSBcIlwiOyBcclxuICAgIGxldCBzdGF0ZSA9IHt9O1xyXG4gICAgbGV0IHN0YXRlRGF0YSA9IHdyaXRhYmxlKHtcclxuICAgICAgICBjZGF0YTogXCJcIixcclxuICAgICAgICBzdGVtOiBcIlwiLFxyXG4gICAgICAgIHhtbDogXCJcIixcclxuICAgICAgICB0aGVtZTpcIlwiLFxyXG4gICAgICAgIGZvbnQ6XCJcIixcclxuICAgICAgICBtYXhXaWR0aDpcIlwiLFxyXG4gICAgICAgIHRvdGFsY29ycmVjdGFuczpcIlwiIFxyXG4gICAgfSlcclxuICAgIGxldCB0aGVtZV9jb2xvciA9IHtcclxuXHRcdHRoZW1lMTogJyM1QjlCRDUnLFxyXG5cdFx0dGhlbWUyOiAnIzNCNjdCQycsXHJcblx0XHR0aGVtZTM6ICcjRjZDM0EyJyxcclxuXHRcdHRoZW1lNDogJyM3MEFENDcnLFxyXG5cdFx0dGhlbWU1OiAnIzc0NTk5OCdcclxuXHR9XHJcblx0bGV0IHRoZW1lX2NvbG9yX3Rlcm1zID0ge1xyXG5cdFx0dGhlbWUxOiAnI0RFRUFGNicsXHJcblx0XHR0aGVtZTI6ICcjRDRERUYxJyxcclxuXHRcdHRoZW1lMzogJyNGQUUwQ0YnLFxyXG5cdFx0dGhlbWU0OiAnI0UyRUZEOScsXHJcblx0XHR0aGVtZTU6ICcjRTFEQUU5JyxcclxuXHR9XHJcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0YXRlRGF0YS5zdWJzY3JpYmUoKGl0ZW1zKSA9PiB7IFxyXG4gICAgICAgIHN0YXRlID0gaXRlbXM7XHJcbiAgICB9KVxyXG5cclxuICAgICQ6IGlmIChpc1Jldmlldykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGNvbmRpdGlvbiB3aWxsIHRydWUgaW4gdGVzdCBhcmVhXHJcbiAgICAgICAgICAgIG1vZGVPbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHByZXZpZXdVc2VyQW5zKCk7XHJcbiAgICAgICAgICAgIG1vZGVPZmYoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgLy8vLy8vLyAgWE1MIGNoYW5nZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVsb2FkIGNvZGUgLy8vLy8vLy8vLy8vLy8vXHJcbiAgICBiZWZvcmVVcGRhdGUoKCk9PiB7XHJcbiAgICAgICAgaWYgKHhtbCAhPSBzdGF0ZS54bWwpIHtcclxuICAgICAgICAgICAgc3RhdGUueG1sID0geG1sIDtcclxuICAgICAgICAgICAgbG9hZE1vZHVsZSh4bWwsIHV4bWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICB9KTsgIFxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIGZvciBjaGVja2luZyB0aGUgZm9jdXNcclxuLyogICAgZnVuY3Rpb24gY2hlY2tGb2N1cyhsaXN0KXtcclxuICAgICAgICBsZXQgaXNfZm9jdXMgPSBmYWxzZTtcclxuICAgICAgICBqUXVlcnkoXCIuY2hvaWNlTWF0cml4UmVuZGVyXCIpLmZpbmQoXCIuXCIrbGlzdCkuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYoalF1ZXJ5KHRoaXMpLmlzKFwiOmZvY3VzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBpc19mb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXNfZm9jdXM7XHJcbiAgICB9ICAqL1xyXG5cclxuICAgIGFmdGVyVXBkYXRlKCgpPT4ge1xyXG4gICAgICAgIGlmKCFpc1JldmlldykgaGlkZUNvckluY29ySWNvbigpO1xyXG4gICAgfSlcclxuICAgIFxyXG4gICAgb25Nb3VudCgoKT0+IHtcclxuICAgICAgICAvLyBDaGVjayB0aGUgcmFkaW8gd2hlbiBwcmVzcyB0aGUgRW50ZXIgS2V5IEFEQVxyXG4gICAgICAgIEFJLmxpc3RlbignYm9keScsICdrZXlkb3duJywnLmxhYmVsX2Nob2ljZScsIGZ1bmN0aW9uKF90aGlzLGUpIHtcclxuICAgICAgICAgICAgaWYoZS53aGljaCA9PT0gMTMpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldFJldmlldygpIHtcclxuICAgICAgICBtb2RlT24oKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1blNldFJldmlldygpIHtcclxuICAgICAgICBwcmV2aWV3VXNlckFucygpO1xyXG4gICAgICAgIG1vZGVPZmYoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8gTG9kaW5nIHRoZSB4bWwgYW5kIHVhWE1MIC8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIGZ1bmN0aW9uIGxvYWRNb2R1bGUobG9hZFhtbCx1YVhNTCkge1xyXG4gICAgICAgIGxvYWRYbWwgPSBYTUxUb0pTT04obG9hZFhtbCk7XHJcbiAgICAgICAgcGFyc2VYTUxQcmV2aWV3KGxvYWRYbWwsdWFYTUwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLy8vLy8vLyBGVW5jdGlvbiBwYXJzaW5nIHRoZSB4bWwgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICBmdW5jdGlvbiBwYXJzZVhNTFByZXZpZXcoTVlYTUwsdWFYTUwpIHtcclxuICAgICAgICAvLyBzZXR0aW5nIHN0YXRlIG9mIHRoZW1lLCBmb250LCBtYXh3aWR0aFxyXG4gICAgICAgIHN0YXRlLnRoZW1lPU1ZWE1MLnNteG1sLl90aGVtZTtcclxuICAgICAgICBzdGF0ZS5mb250PU1ZWE1MLnNteG1sLl9mb250O1xyXG4gICAgICAgIHN0YXRlLm1heFdpZHRoID0gKChNWVhNTC5zbXhtbC5fbWF4d2lkdGgpP01ZWE1MLnNteG1sLl9tYXh3aWR0aDogODAwICk7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIGxldCBmb3JtYXR0ZWREYXRhID0gbGliLnBhcnNlQ1NWRm9ybWF0KE1ZWE1MLnNteG1sLl9fY2RhdGEpO1xyXG4gICAgICAgIGxldCBjZGF0YSA9IGZvcm1hdHRlZERhdGE7XHJcbiAgICAgICAgbGV0IHJhd0RhdGEgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gY29weSBjZGF0YSBpbnRvIHJhd0RhdGEvLy8vLy8gXHJcblxyXG4gICAgICAgIC8qIGpRdWVyeS5tYXAoY2RhdGEsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgcmF3RGF0YVtpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICB9KTsgICBSZXBsYWNlZCAgICAgKi9cclxuXHJcbiAgICAgICAgcmF3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2RhdGEpKTtcclxuXHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIHN0YXRlLmNkYXRhID0gcmF3RGF0YTsgXHJcbiAgICAgICAgc3RhdGUuc3RlbSA9IHJhd0RhdGEuc3RlbTtcclxuICAgICAgICBjbS5jZGF0YSA9IHJhd0RhdGE7XHJcbiAgICAgICAgbGV0IGxlbiA9IGNtLmNkYXRhLnRlcm0ubGVuZ3RoO1xyXG4gICAgICAgIHN0YXRlLnRvdGFsY29ycmVjdGFucyA9IGxlbiA7XHJcbiAgICAgICAgbW9kZU9mZigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVzZXIgYW5zZXIgY2hlY2tpbmcvLy8vLy8vLy9cclxuICAgICAgICBpZiAodWFYTUwpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIHBhcnNpbmcgdGhlIGpzb24gZGF0YVxyXG4gICAgICAgICAgICAgICAgdWFYTUwgPSBKU09OLnBhcnNlKHVhWE1MKTtcclxuICAgICAgICAgICAgICAgIGxldCByYXdVYVhNTCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmluZyB1YVhNTCBpbiByYXdVYVhNTCBhbmQgc3RvcmluZyBpdHMgdmFsdWVcclxuICAgICAgICAgICAgLyogICAgalF1ZXJ5Lm1hcCh1YVhNTCwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd1VhWE1MW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7IHJlcGxhY2VkICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICByYXdVYVhNTCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodWFYTUwpKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyAgICBzZXR0aW5nIHRoZSBkYXRhLXVzZXJhbnMgb24gdGhlIGJhc2lzIG9mIGFuc1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd1VhWE1MLmFucy5tYXAoZnVuY3Rpb24oZGF0YSxpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxlcnQoXCIjXCIrZGF0YS51c2VyQW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9qUXVlcnkoXCIudGVzdF9hcmVhXCIpLmZpbmQoXCIjXCIrZGF0YS51c2VyQW5zKS5hdHRyKFwiZGF0YS11c2VyYW5zXCIsZGF0YS51c2VyQW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQUguc2VsZWN0QWxsKFwiLnRlc3RfYXJlYVwiK1wiICNcIitkYXRhLnVzZXJBbnMsJ2F0dHInLHtcImRhdGEtdXNlcmFuc1wiOmRhdGEudXNlckFuc30pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlld1VzZXJBbnMoKTtcclxuICAgICAgICAgICAgICAgIH0sMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gbGV0IGRhdGF1c2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJhd1VhWE1MLmFucy5tYXAoZnVuY3Rpb24oZGF0YSxpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCB0ZXN0X2FyZWFfbGVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndGVzdF9hcmVhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGZvcihsZXQgaiA9IDA7IGogPCB0ZXN0X2FyZWFfbGVuLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHRlc3RfYXJlYV9maW5kID0gQUguZmluZCh0ZXN0X2FyZWFfbGVuW2pdLCBcIiNcIitkYXRhLnVzZXJBbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYodGVzdF9hcmVhX2ZpbmQpIHRlc3RfYXJlYV9maW5kLnNldEF0dHJpYnV0ZShcImRhdGEtdXNlcmFuc1wiLGRhdGEudXNlckFucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHNob3dpbmcgdGhlIHVzZXJhbnMgLCB0aGF0IGlzIHRoZSBhbnN3ZXIgd2hpY2ggaXMgbWFya2VkIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy91YVhNTCA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiBpcyBub3QgdXNlciBhbnMgdGhlbiB1bmNoZWNrZWQgYWxsIHRoZSByYWRpbyBidG5cclxuICAgICAgICAgICAgLyogICAgalF1ZXJ5KFwiLnRlc3RfcmFkaW9cIikuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpWzBdLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuYXR0cignZGF0YS11c2VyYW5zJyxcIlwiKTtcclxuICAgICAgICAgICAgICAgIH0pICAqL1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlc3RfcmFkaW9fbGVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndGVzdF9yYWRpbycpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRlc3RfcmFkaW9fbGVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdF9yYWRpb19sZW5baV0uY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RfcmFkaW9fbGVuW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS11c2VyYW5zJyxcIlwiKTsgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vLy8vLy8vLy8gIFN0b3JpbmcgdGhlIHVzZXIgYW5zd2VyIHdoZW5ldmVyIGNsaWNrZWQvLy8vLy8vLy8vLy8vLy8vXHJcbiAgICBmdW5jdGlvbiBzZXRVc2VyQW5zKGUpIHtcclxuICAgICAgICBsZXQgaWQgPSBlLnRhcmdldC5pZDtcclxuICAgICAgICBsZXQgbmFtZSA9IGUudGFyZ2V0Lm5hbWU7XHJcbiAgICAgICAgLy8gc2V0IHRoZSB1c2VyIGFucyBibGFua1xyXG4gICAgLy8gICAgalF1ZXJ5KG1haW5JZCtcIiAudGVzdF9hcmVhIGlucHV0W25hbWU9XCIgKyBuYW1lICsgXCJdXCIpLmF0dHIoXCJkYXRhLXVzZXJhbnNcIiwgXCJcIik7IFJlcGxhY2VkXHJcblxyXG4gICAgICAgIGxldCB0ZXN0X2FyZWFfaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG1haW5JZCtcIiAudGVzdF9hcmVhIGlucHV0W25hbWU9XCIgKyBuYW1lICsgXCJdXCIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdF9hcmVhX2lucHV0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICB0ZXN0X2FyZWFfaW5wdXRbaV0uc2V0QXR0cmlidXRlKFwiZGF0YS11c2VyYW5zXCIsXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8gc2V0dGluZyB0aGUgZGF0YS11c2VyYW5zIG9uIHdoaWNoIHVzZXIgaXMgY2xpY2tlZFxyXG4gICAgICAgIC8valF1ZXJ5KG1haW5JZCtcIiAudGVzdF9hcmVhXCIpLmZpbmQoXCIjXCIgKyBpZCArIFwiXCIpLmF0dHIoXCJkYXRhLXVzZXJhbnNcIiwgaWQpOy8vIFJlcGxhY2VkXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKG1haW5JZCtcIiAudGVzdF9hcmVhXCIgKyBcIiAjXCIgKyBpZCArIFwiXCIsJ2F0dHInLHtcImRhdGEtdXNlcmFuc1wiOmlkfSk7XHJcbiAgICAgICBcclxuICAgICAgICBsZXQgdXNlcmFucyA9IHsgXCJ0eXBlXCI6IFwiMzRcIiwgXCJhbnNcIjogW10gfTtcclxuXHJcbiAgICAgICAgLy8vLy8vLy8vLy8gdXBkYXRpbmcgdGhlIHVzZXIgYW5zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgICAgICAvKiBqUXVlcnkobWFpbklkK1wiIC50ZXN0X3JhZGlvXCIpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoalF1ZXJ5KHRoaXMpWzBdLmNoZWNrZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdXNlcmFucy5hbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGpRdWVyeSh0aGlzKS5hdHRyKFwiZGF0YS10ZXJtaWRcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlckFuczogalF1ZXJ5KHRoaXMpLmF0dHIoXCJpZFwiKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTsqL1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCB0ZXN0X3JhZGlvID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndGVzdF9yYWRpbycpO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGk8dGVzdF9yYWRpby5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgaWYgKHRlc3RfcmFkaW9baV0uY2hlY2tlZCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VyYW5zLmFucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdGVzdF9yYWRpb1tpXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlcm1pZFwiKSxcclxuICAgICAgICAgICAgICAgICAgICB1c2VyQW5zOiB0ZXN0X3JhZGlvW2ldLmdldEF0dHJpYnV0ZShcImlkXCIpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSAgXHJcbiAgICBcclxuICAgICAgICAvLyBmb3IgYXV0b2dyYWRpbmdcclxuICAgICAgICBcclxuICAgICAgICAvLyB1cGRhaW5nIHRoZSB2YWx1ZSBpbiB0aGUgdGV4dGFyZWEgXHJcbiAgICAgICAgLy9qUXVlcnkoXCIjc3BlY2lhbF9tb2R1bGVfdXNlcl94bWxcIikudmFsKEpTT04uc3RyaW5naWZ5KHVzZXJhbnMpKTsgLy8gUmVwbGFjZWQ7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vQUgoJ3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sJykudmFsdWUgPSBKU09OLnN0cmluZ2lmeSh1c2VyYW5zKTtcclxuXHJcbiAgICAgICAgdXNlcmFuc05ldyA9IEpTT04uc3RyaW5naWZ5KHVzZXJhbnMpO1xyXG5cclxuICAgICAgICBkaXNwbGF5QW5zd2VyKCk7ICBcclxuICAgIH1cclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIFRoaXMgZnVuY3Rpb24gZGlzcGxheSBhbnN3ZXIgd2V0aGVyIHRoZSBmdW5jdGlvbiBpcyBjb3JyZWN0IG9yIGluY29ycmVjdC8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIGZ1bmN0aW9uIGRpc3BsYXlBbnN3ZXIoKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgdGhlIGFuc1xyXG4gICAgICAgIGxldCBhbnMgPSBjaGVja0FucygpO1xyXG4gICAgICAgIC8vIG1hcmsgdGhlIGFuc3dlciBjb3JyZWN0IG9yIGluY29ycmVjdCB4XHJcbiAgICAgICAgYW5zID0gKGFucyA9PSAxKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICBpZiAodXhtbCkgIHtcclxuICAgICAgICAgICAgQUguc2VsZWN0KFwiI2Fuc3dlclwiKS5jaGVja2VkID0gYW5zOyBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZWRpdG9yU3RhdGUpIHNob3dBbnMoKGFucykgPyBcIkNvcnJlY3RcIiA6IFwiSW5jb3JyZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvblVzZXJBbnNDaGFuZ2Uoe3VYbWw6IHVzZXJhbnNOZXcsIGFuczogYW5zfSlcclxuICAgIH0gXHJcblxyXG4gICAgLy8gZnVuY3Rpb24gY2hlY2sgdGhlIGFuc3dlclxyXG4gICAgZnVuY3Rpb24gY2hlY2tBbnMoKSB7XHJcbiAgICAgICAgbGV0IGlzX2NvcnJlY3QgPSAwO1xyXG4gICAgICAgIGxldCB0ZW1wID0gMDsgIFxyXG4gICAgICAgIGxldCB0ZXN0X3JhZGlvX2FucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Rlc3RfcmFkaW8nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0wOyBpIDwgdGVzdF9yYWRpb19hbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRlc3RfcmFkaW9fYW5zW2ldLmdldEF0dHJpYnV0ZSgndmFsdWUnKSA9PSB0ZXN0X3JhZGlvX2Fuc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29ycmVjdCcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdF9yYWRpb19hbnNbaV0uY2hlY2tlZCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdF9yYWRpb19hbnNbaV0uc2V0QXR0cmlidXRlKCdhcycsMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNfY29ycmVjdCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzX2NvcnJlY3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RfcmFkaW9fYW5zW2ldLnNldEF0dHJpYnV0ZSgnYXMnLDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZm9yIGNhbGN1bGF0aW5nIHRoZSBwb2ludFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdF9yYWRpb19hbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRlc3RfcmFkaW9fYW5zW2ldLmdldEF0dHJpYnV0ZSgndmFsdWUnKSA9PSB0ZXN0X3JhZGlvX2Fuc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29ycmVjdCcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdF9yYWRpb19hbnNbaV0uY2hlY2tlZCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsY3VsYXRlUG9pbnQgIT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlUG9pbnQoc3RhdGUudG90YWxjb3JyZWN0YW5zLCB0ZW1wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNfY29ycmVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgdXNlciBhc3dlciB0YWJcclxuICAgIGZ1bmN0aW9uIHlvdXJBbnN3ZXIoKSB7XHJcbiAgICAgICAgcHJldmlld1VzZXJBbnMoKTtcclxuICAgICAgICAvLyBmb3Igc2hvd2luZyB0aGUgY29ycmVjdC9pbmNvcnJlY3QgaWNvblxyXG4gICAgICAgIHNob3dDb3JJbmNvckljb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8vLy8vLy8gIFByZXZpZXcgdGhlIHVzZXIgYW5zd2VyIC8vLy8vLy8vLy8vLy8vL1xyXG4gICAgZnVuY3Rpb24gcHJldmlld1VzZXJBbnMoKSB7XHJcbiAgICAgICAgbGV0IHRlc3RfcmFkaW9fbGVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndGVzdF9yYWRpbycpO1xyXG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHRlc3RfcmFkaW9fbGVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKHRlc3RfcmFkaW9fbGVuW2ldLmdldEF0dHJpYnV0ZSgnaWQnKT09dGVzdF9yYWRpb19sZW5baV0uZ2V0QXR0cmlidXRlKCdkYXRhLXVzZXJhbnMnKSkge1xyXG4gICAgICAgICAgICAgICAgdGVzdF9yYWRpb19sZW5baV0uY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0X3JhZGlvX2xlbltpXS5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29ycmVjdCBhbnN3ZXIgdGFiXHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0QW5zd2VyKCkge1xyXG4gICAgICAgIHByZXZpZXdDb3JyZWN0QW5zKCk7XHJcbiAgICAgICAgLy8gZm9yIHNob3dpbmcgdGhlIGNvcnJlY3QvaW5jb3JyZWN0IGljb25cclxuICAgICAgICBoaWRlQ29ySW5jb3JJY29uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9yIHNob3dpbmcgY29ycmVjdCBhbnN3ZXJcclxuICAgIGZ1bmN0aW9uIHByZXZpZXdDb3JyZWN0QW5zKCkge1xyXG4gICAgLyogICAgalF1ZXJ5KG1haW5JZCtcIiAudGVzdF9yYWRpb1wiKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGpRdWVyeSh0aGlzKS5hdHRyKCd2YWx1ZScpID09IGpRdWVyeSh0aGlzKS5hdHRyKCdkYXRhLWNvcnJlY3QnKSkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpWzBdLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpWzBdLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pOyAgIC8vUmVwbGFjZWQgICAgICovIFxyXG5cclxuICAgICAgICBsZXQgdGVzdF9yYWRpbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKG1haW5JZCtcIiAudGVzdF9yYWRpb1wiKSk7XHJcbiAgICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCB0ZXN0X3JhZGlvLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICBpZih0ZXN0X3JhZGlvW2ldLmdldEF0dHJpYnV0ZSgndmFsdWUnKSA9PSB0ZXN0X3JhZGlvW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3JyZWN0JykpIHtcclxuICAgICAgICAgICAgICAgIHRlc3RfcmFkaW9baV0uY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0X3JhZGlvW2ldLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvLy8vLy8vIFRoaXMgZnVuY3Rpb24gc2V0UmV2aWV3IG1vZGUgLy8vLy8vLy8vLy8vLy8gXHJcbiAgICBmdW5jdGlvbiBtb2RlT24oKSB7XHJcbiAgICAgICAgaXNSZXZpZXcgPSB0cnVlO1x0XHJcbiAgICAgICAgLy9qUXVlcnkobWFpbklkK1wiIC50ZXN0X3JhZGlvXCIpLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7IC8vIFJlcGxhY2VkXHJcbiAgICAgICAgbGV0IHRlc3RfcmFkaW8gPSBBSC5zZWxlY3RBbGwobWFpbklkICsgXCIgLnRlc3RfcmFkaW9cIik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0X3JhZGlvLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRlc3RfcmFkaW9baV0uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5b3VyQW5zd2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vLy8vLyBUaGlzIGZ1bmN0aW9uIHVuc2V0UmV2aWV3IG1vZGUgLy8vLy8vLy8vLy8vLy8gIFxyXG4gICAgZnVuY3Rpb24gbW9kZU9mZigpIHtcclxuICAgICAgICBpc1JldmlldyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB0ZXN0UmFkaW9zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndGVzdF9yYWRpbycpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdFJhZGlvcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0ZXN0UmFkaW9zW2ldLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaGlkZUNvckluY29ySWNvbigpOyAgXHJcbiAgICAgICAgLy9qUXVlcnkoXCIuZGJnLXN1Y2Nlc3MgaW5wdXQ6Y2hlY2tlZFwiKS5zaWJsaW5ncyhcIi5sYWJlbF9jaG9pY2VcIikuYXR0cihcInRpdGxlXCIsXCJcIik7IC8vIFJlcGxhY2VkXHJcblxyXG4gICAgICAgIC8vIEFILnNlbGVjdChcIi5kYmctc3VjY2VzcyBpbnB1dFwiLFwiY2hlY2tlZFwiKS5mb3JFYWNoKChfZWxtKT0+e1xyXG4gICAgICAgIC8vICAgICBBSC5zaWJsaW5ncyhfZWxtLFwiLmxhYmVsX2Nob2ljZVwiKS5mb3JFYWNoKChfZSk9PntcclxuICAgICAgICAvLyAgICAgICAgIF9lLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsXCJcIikgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIC8vICAgICB9KVxyXG4gICAgICAgIC8vIH0pOyBGaXhcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICAvL2pRdWVyeShcIi5kYmctZGFuZ2VyIGlucHV0OmNoZWNrZWRcIikuc2libGluZ3MoXCIubGFiZWxfY2hvaWNlXCIpLmF0dHIoXCJ0aXRsZVwiLCBcIlwiKTsgLy8gUmVwbGFjZWRcclxuXHJcbiAgICAgICAgLy8gQUguc2VsZWN0KFwiLmRiZy1kYW5nZXIgaW5wdXQ6Y2hlY2tlZFwiKS5mb3JFYWNoKChfZWxtKT0+e1xyXG4gICAgICAgIC8vICAgICBBSC5zaWJsaW5ncyhfZWxtLFwiLmxhYmVsX2Nob2ljZVwiKS5mb3JFYWNoKChfZSk9PntcclxuICAgICAgICAvLyAgICAgICAgIF9lLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsXCJcIikgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIC8vICAgICB9KVxyXG4gICAgICAgIC8vIH0pOyBGaXhcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHNob3dpbmcgY29ycmVjdCBvciBpbmNvcnJlY3QgaWNvbi8vLy8vLy8vLy8vLy8vLy9cclxuICAgIGZ1bmN0aW9uIHNob3dDb3JJbmNvckljb24oKSB7ICAgICBcclxuICAgICAgICAvL2pRdWVyeShcIi5kYmctc3VjY2VzcyBpbnB1dDpjaGVja2VkXCIpLnNpYmxpbmdzKFwiLmZhLWNoZWNrXCIpLmNzcyh7IFwiZGlzcGxheVwiOiBcImlubGluZS1mbGV4XCIgfSk7IC8vIFJlcGxhY2VkXHJcbiAgICAgICAgLy8gZGVidWdnZXI7XHJcbiAgICAgICAgQUguc2VsZWN0KFwiLmRiZy1zdWNjZXNzIGlucHV0XCIsIFwiY2hlY2tlZFwiKS5mb3JFYWNoKChfZWxtKT0+e1xyXG4gICAgICAgICAgICBBSC5zaWJsaW5ncyhfZWxtLCcuZmEtY2hlY2snKS5mb3JFYWNoKChfZSk9PntcclxuICAgICAgICAgICAgICAgIF9lLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1mbGV4XCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9qUXVlcnkoXCIuZGJnLWRhbmdlciBpbnB1dDpjaGVja2VkXCIpLnNpYmxpbmdzKFwiLmZhLWNsb3NlXCIpLmNzcyh7IFwiZGlzcGxheVwiOiBcImlubGluZS1mbGV4XCIgfSk7XHJcblxyXG4gICAgICAgIEFILnNlbGVjdChcIi5kYmctZGFuZ2VyIGlucHV0XCIsIFwiY2hlY2tlZFwiKS5mb3JFYWNoKChfZWxtKT0+e1xyXG4gICAgICAgICAgICBBSC5zaWJsaW5ncyhfZWxtLCcuZmEtY2xvc2UnKS5mb3JFYWNoKChfZSk9PntcclxuICAgICAgICAgICAgICAgIF9lLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1mbGV4XCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcblxyXG5cclxuICAgICAgICBBSC5zZWxlY3RBbGwoJy5kYmctc3VjY2VzcyBpbnB1dCwgLmRiZy1kYW5nZXIgaW5wdXQnLCAncmVtb3ZlQXR0cicsICdhcycpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8valF1ZXJ5KFwiLmRiZy1zdWNjZXNzIGlucHV0OmNoZWNrZWRcIikuYXR0cihcImFzXCIsMSk7IC8vIFJlbW92ZWRcclxuICAgICAgICBBSC5zZWxlY3QoXCIuZGJnLXN1Y2Nlc3MgaW5wdXRcIiwgXCJjaGVja2VkXCIpLmZvckVhY2goKF9zdWNjUmVtKT0+IHtcclxuICAgICAgICAgICAgX3N1Y2NSZW0uc2V0QXR0cmlidXRlKFwiYXNcIiwgMSk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy9qUXVlcnkoXCIuZGJnLWRhbmdlciBpbnB1dDpjaGVja2VkXCIpLmF0dHIoXCJhc1wiLCAwKTsgLy8gUmVtb3ZlZFxyXG4gICAgICAgIFxyXG4gICAgICAgIEFILnNlbGVjdChcIi5kYmctc3VjY2VzcyBpbnB1dFwiLCBcImNoZWNrZWRcIikuZm9yRWFjaCgoX2RhbmdSZW0pPT4ge1xyXG4gICAgICAgICAgICBfZGFuZ1JlbS5zZXRBdHRyaWJ1dGUoXCJhc1wiLCAwKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9qUXVlcnkoXCIuZGJnLXN1Y2Nlc3MgaW5wdXQ6Y2hlY2tlZFwiKS5zaWJsaW5ncyhcIi5sYWJlbF9jaG9pY2VcIikuYXR0cihcInRpdGxlXCIsXCJpcyBtYXJrZWQgYXMgY29ycmVjdFwiKTtcclxuICAgICAgICBBSC5zZWxlY3QoXCIuZGJnLXN1Y2Nlc3MgaW5wdXRcIixcImNoZWNrZWRcIikuZm9yRWFjaCgoX2VsbSk9PiB7XHJcbiAgICAgICAgICAgIEFILnNpYmxpbmdzKF9lbG0sJy5sYWJlbF9jaG9pY2UnKS5mb3JFYWNoKChfZSk9PiB7XHJcbiAgICAgICAgICAgICAgICBfZS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLFwiaXMgbWFya2VkIGFzIGNvcnJlY3RcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8valF1ZXJ5KFwiLmRiZy1kYW5nZXIgaW5wdXQ6Y2hlY2tlZFwiKS5zaWJsaW5ncyhcIi5sYWJlbF9jaG9pY2VcIikuYXR0cihcInRpdGxlXCIsIFwiaXMgbWFya2VkIGFzIGluY29ycmVjdFwiKTtcclxuICAgICAgICBBSC5zZWxlY3QoXCIuZGJnLWRhbmdlciBpbnB1dFwiLFwiY2hlY2tlZFwiKS5mb3JFYWNoKChfZWxtKT0+e1xyXG4gICAgICAgICAgICBBSC5zaWJsaW5ncyhfZWxtLCcubGFiZWxfY2hvaWNlJykuZm9yRWFjaCgoX2UpPT57XHJcbiAgICAgICAgICAgICAgICBfZS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLFwiaXMgbWFya2VkIGFzIGluY29ycmVjdFwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLy8vLy8vIEhpZGluZyBjb3JyZWN0IG9yIGluY29ycmVjdCBhbnN3ZXIgLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgZnVuY3Rpb24gaGlkZUNvckluY29ySWNvbigpIHtcclxuICAgICAgICBcclxuICAgICAgICAvL2pRdWVyeShcIi5mYS1jaGVja1wiKTsgLy8gUmVwbGFjZWRcclxuICAgICAgICAgICAgLy9qUXVlcnkoXCIuZmEtY2xvc2VcIikuaGlkZSgpOyAvLyBSZXBsYWNlZFxyXG4gICAgICAgIGxldCBoaWRlX2ljb25fbGVuZ3RoID0gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ZhLWNoZWNrJyk7XHJcbiAgICAgICAgbGV0IGhpZGVfaWNvbl9sZW5ndGgxID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZmEtY2xvc2UnKTtcclxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8aGlkZV9pY29uX2xlbmd0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBoaWRlX2ljb25fbGVuZ3RoW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIGhpZGVfaWNvbl9sZW5ndGgxW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvciBzZXR0aW5nIHRoZSBpY29uIHN0eWxlXHJcbiAgICBmdW5jdGlvbiBzZXRJY29uU3R5bGUoaWUpIHtcclxuICAgICAgICBpZiAoaWUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4oe1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcxNHB4JyxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtZmxleCcsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4oe1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6XCIxNXB4XCIsXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xyXG4gICAgICAgICAgICB9KTsgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvL1RvIGhhbmRsZSByZXZpZXcgdG9nZ2xlXHJcblx0ZnVuY3Rpb24gaGFuZGxlUmV2aWV3KG1vZGUsIGV2ZW50KSB7XHJcblx0XHRpZiAobW9kZSA9PSAnYycpIHtcclxuXHRcdFx0Y29ycmVjdEFuc3dlcihldmVudClcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHlvdXJBbnN3ZXIoZXZlbnQpO1xyXG5cdFx0fVxyXG5cdH1cclxuPC9zY3JpcHQ+XHJcbjxtYWluPlxyXG4gICAgPGRpdiBpZCA9IFwiY2hvaWNlbWFpblwiIHN0eWxlID0geydtYXJnaW4tYm90dG9tOjIwcHgnfT5cclxuICAgICAgICA8SXRlbUhlbHBlclxyXG4gICAgICAgICAgICBvbjpzZXRSZXZpZXcgPSB7c2V0UmV2aWV3fVxyXG4gICAgICAgICAgICBvbjp1bnNldFJldmlldyA9IHt1blNldFJldmlld31cclxuICAgICAgICAgICAgaGFuZGxlUmV2aWV3Q2xpY2s9e2hhbmRsZVJldmlld31cclxuICAgICAgICAgICAgcmV2aWV3TW9kZT17aXNSZXZpZXd9XHJcbiAgICAgICAgLz5cclxuICAgICAgICA8Y2VudGVyPlxyXG4gICAgICAgICAgICA8dGFibGUgY2xhc3MgPSB7XCJ0YWJsZSB0YWJsZS1ib3JkZXJlZCB0ZXN0bW9kZV90YWJsZSBcIn0gaWQ9XCJ0ZXN0X3RhYmxlXCIgc3R5bGU9XCJ7J3Bvc2l0aW9uOnJlbGF0aXZlOyBtYXJnaW4tdG9wOjIwcHg7d2lkdGg6JytzdGF0ZS5tYXhXaWR0aCtcInB4XCJ9O2ZvbnQtZmFtaWx5OiBHZW9yZ2lhO1wiPlxyXG4gICAgICAgICAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcyA9IFwidGFibGUtaGVhZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzID0ge1wicHJldmlld19oZWFkZXIgXCIgKyAoKHN0YXRlLnRoZW1lICE9PSBcInRoZW1lM1wiKSA/IFwidGV4dC1jZW50ZXIgdGV4dC13aGl0ZVwiIDogXCJ0ZXh0LWNlbnRlclwiKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmluZGV4ID0gezB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjp7dGhlbWVfY29sb3Jbc3RhdGUudGhlbWVdfSFpbXBvcnRhbnQ7XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+e3N0YXRlLnN0ZW0ucmVwbGFjZSgvXFxuL2dtLCBcIjwvYnI+XCIpLnJlcGxhY2UoLyNjbS9nbSxcIixcIil9PC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5jZGF0YX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCBzdGF0ZS5jZGF0YS5vcHRpb24gYXMgZGF0YSwgaX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHtpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IHtcInByZXZpZXdfaGVhZGVyIGFkanVzdF93aWR0aCBcIiArICgoc3RhdGUudGhlbWUgIT09IFwidGhlbWUzXCIpID8gZGF0YS5pZCArIFwidGV4dC1jZW50ZXIgdGV4dC13aGl0ZVwiIDogZGF0YS5pZCArIFwidGV4dC1jZW50ZXJcIil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmluZGV4ID0gezB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gXCJiYWNrZ3JvdW5kLWNvbG9yOnt0aGVtZV9jb2xvcltzdGF0ZS50aGVtZV19IWltcG9ydGFudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPntkYXRhLnRleHQucmVwbGFjZSgvXFxuL2dtLCBcIjwvYnI+XCIpLnJlcGxhY2UoLyNjbS9nbSxcIixcIil9PC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPiBcclxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgeyNpZiBjbS5jZGF0YX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIGNtLmNkYXRhLnRlcm0gYXMgZGF0YSxpfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBrZXkgPSB7aX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzID0ge2RhdGEuaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmluZGV4ID0gezB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gXCJiYWNrZ3JvdW5kLWNvbG9yOnsoKChpICUgMikgPT0gMCk/KHRoZW1lX2NvbG9yX3Rlcm1zW3N0YXRlLnRoZW1lXSk6IFwiI0ZGRlwiKX0haW1wb3J0YW50O2ZvbnQtc2l6ZToxNHB0O3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtmb250LWZhbWlseTp7c3RhdGUuZm9udH1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID57ZGF0YS50ZXh0LnJlcGxhY2UoL1xcbi9nbSwgXCI8L2JyPlwiKS5yZXBsYWNlKC8jY20vZ20sXCIsXCIpfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIGNtLmNkYXRhLm9wdGlvbiBhcyBkYXRhMiwgan0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHtqfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHsndGInICsgKGkpICsgKGopfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSB7XCJ0ZXh0LWNlbnRlciB0ZXN0X2FyZWEgXCIgKyAoKGRhdGEyLmlkID09IGRhdGEuY29ycmVjdCkgPyBcImRiZy1zdWNjZXNzXCIgOiBcImRiZy1kYW5nZXJcIil9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjp7KCgoaSAlIDIpID09IDApPyh0aGVtZV9jb2xvcl90ZXJtc1tzdGF0ZS50aGVtZV0pOiBcIiNGRkZcIil9XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiZmEgZmEtY2hlY2tcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1oaWRkZW4gPSBcInRydWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7c2V0SWNvblN0eWxlKGlzSUUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pPiAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiZmEgZmEtY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1oaWRkZW4gPSBcInRydWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7c2V0SWNvblN0eWxlKGlzSUUpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcInJhZGlvXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzID0gXCJ0ZXN0X3JhZGlvIENNUmFkXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geyd2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7J31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge2RhdGEyLmlkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHtcInRtXCIgKyAoaSArIDEpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB7J3QnICsgKGkpICsgKGopfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10ZXJtaWQgPSB7ZGF0YS5pZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtY29ycmVjdCA9IHtkYXRhLmNvcnJlY3R9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXVzZXJhbnMgPSBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljayA9IHtzZXRVc2VyQW5zfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1yb2xlID0gXCJub25lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmluZGV4ID0gey0xfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJpbmRleCA9IHswfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzID0gXCJsYWJlbF9jaG9pY2UgY3VzdG9tUmFkQ00geygoaiAlIDIgPT0gMCkgPyAndHVyZWl0ZW1Db2xvckNNJyA6ICdmYWxzZWl0ZW1Db2xvckNNJyl9XCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3I9eyd0JyArIChpKSArIChqKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvY2VudGVyPiAgICAgICAgICAgICAgIFxyXG4gICAgPC9kaXY+XHJcbjwvbWFpbj5cclxuICAgIFxyXG48c3R5bGU+XHJcbiAgICA6Z2xvYmFsKC5mYS1jaGVjaykge1xyXG4gICAgICAgIGNvbG9yOiAjNDZBNTQ2O1xyXG4gICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xyXG4gICAgICAgIGxlZnQ6NTBweDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5mYS1jbG9zZSkge1xyXG4gICAgICAgIGNvbG9yOiAjQTgwMDAwOyBcclxuICAgICAgICBsZWZ0OjUwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZmEtY2xvc2UsLmZhLWNoZWNrKSB7XHJcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC0yNnB4OyBcclxuICAgICAgICBmb250LXNpemU6IDE4cHg7IFxyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICBib3R0b206IDEwcHg7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguZmEtY2xvc2UsLmZhLWNoZWNrLC5taWRkbGVfYWxpZ24pIHtcclxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlIWltcG9ydGFudDtcclxuICAgIH1cclxuXHJcbiAgICA6Z2xvYmFsKC5taWRkbGVfYWxpZ24pIHtcclxuICAgICAgICB3aWR0aDogMTY0cHg7XHJcbiAgICAgICAgbWluLXdpZHRoOiAxNjRweDtcclxuICAgIH0gXHJcblxyXG4gICAgOmdsb2JhbCgudG9waWNfaW5wdXQpIHtcclxuICAgICAgICBtaW4td2lkdGg6IDI1N3B4O1xyXG4gICAgfVxyXG5cclxuICAgIDpnbG9iYWwoLnByZXZpZXdfaGVhZGVyKSB7XHJcbiAgICAgICAgZm9udC1zaXplOiAxNnB0O1xyXG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XHJcbiAgICB9XHJcblxyXG4gICAgOmdsb2JhbCguYWRqdXN0X3dpZHRoKSB7XHJcbiAgICAgICAgd2lkdGg6IDEwJTtcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB9XHJcblxyXG48L3N0eWxlPiAgICJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFvakJZLFNBQVMsQUFBRSxDQUFDLEFBQ2hCLEtBQUssQ0FBRSxPQUFPLENBQ2QsU0FBUyxRQUFRLENBQ2pCLEtBQUssSUFBSSxBQUNiLENBQUMsQUFFTyxTQUFTLEFBQUUsQ0FBQyxBQUNoQixLQUFLLENBQUUsT0FBTyxDQUNkLEtBQUssSUFBSSxBQUNiLENBQUMsQUFFTyxtQkFBbUIsQUFBRSxDQUFDLEFBQzFCLFdBQVcsQ0FBRSxLQUFLLENBQ2xCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVPLGlDQUFpQyxBQUFFLENBQUMsQUFDeEMsY0FBYyxDQUFFLE1BQU0sVUFBVSxBQUNwQyxDQUFDLEFBRU8sYUFBYSxBQUFFLENBQUMsQUFDcEIsS0FBSyxDQUFFLEtBQUssQ0FDWixTQUFTLENBQUUsS0FBSyxBQUNwQixDQUFDLEFBRU8sWUFBWSxBQUFFLENBQUMsQUFDbkIsU0FBUyxDQUFFLEtBQUssQUFDcEIsQ0FBQyxBQUVPLGVBQWUsQUFBRSxDQUFDLEFBQ3RCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLElBQUksQ0FDakIsY0FBYyxDQUFFLE1BQU0sQUFDMUIsQ0FBQyxBQUVPLGFBQWEsQUFBRSxDQUFDLEFBQ3BCLEtBQUssQ0FBRSxHQUFHLENBQ1YsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyJ9 */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	child_ctx[33] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

// (493:24) {#if state.cdata}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value_2 = /*state*/ ctx[2].cdata.option;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, theme_color*/ 20) {
				each_value_2 = /*state*/ ctx[2].cdata.option;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(493:24) {#if state.cdata}",
		ctx
	});

	return block;
}

// (494:28) {#each state.cdata.option as data, i}
function create_each_block_2(ctx) {
	let th;
	let t_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t;
	let th_key_value;
	let th_class_value;
	let th_tabindex_value;

	const block = {
		c: function create() {
			th = element("th");
			t = text(t_value);
			attr_dev(th, "key", th_key_value = /*i*/ ctx[30]);

			attr_dev(th, "class", th_class_value = "preview_header adjust_width " + (/*state*/ ctx[2].theme !== "theme3"
			? /*data*/ ctx[28].id + "text-center text-white"
			: /*data*/ ctx[28].id + "text-center"));

			attr_dev(th, "tabindex", th_tabindex_value = 0);
			set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			add_location(th, file, 494, 32, 17424);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4 && t_value !== (t_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*state*/ 4 && th_class_value !== (th_class_value = "preview_header adjust_width " + (/*state*/ ctx[2].theme !== "theme3"
			? /*data*/ ctx[28].id + "text-center text-white"
			: /*data*/ ctx[28].id + "text-center"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(494:28) {#each state.cdata.option as data, i}",
		ctx
	});

	return block;
}

// (506:20) {#if cm.cdata}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*cm*/ ctx[1].cdata.term;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm, theme_color_terms, state, setUserAns, isIE*/ 302) {
				each_value = /*cm*/ ctx[1].cdata.term;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(506:20) {#if cm.cdata}",
		ctx
	});

	return block;
}

// (515:32) {#each cm.cdata.option as data2, j}
function create_each_block_1(ctx) {
	let td;
	let i0;
	let i0_style_value;
	let t0;
	let i1;
	let i1_style_value;
	let t1;
	let input;
	let input_style_value;
	let input_value_value;
	let input_name_value;
	let input_id_value;
	let input_data_termid_value;
	let input_data_correct_value;
	let input_tabindex_value;
	let t2;
	let label;
	let label_tabindex_value;
	let label_class_value;
	let label_for_value;
	let td_key_value;
	let td_id_value;
	let td_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			i0 = element("i");
			t0 = space();
			i1 = element("i");
			t1 = space();
			input = element("input");
			t2 = space();
			label = element("label");
			attr_dev(i0, "class", "fa fa-check");
			attr_dev(i0, "aria-hidden", "true");
			attr_dev(i0, "style", i0_style_value = setIconStyle(/*isIE*/ ctx[3]));
			add_location(i0, file, 522, 36, 19237);
			attr_dev(i1, "class", "fa fa-close");
			attr_dev(i1, "aria-hidden", "true");
			attr_dev(i1, "style", i1_style_value = setIconStyle(/*isIE*/ ctx[3]));
			add_location(i1, file, 527, 36, 19517);
			attr_dev(input, "type", "radio");
			attr_dev(input, "class", "test_radio CMRad");
			attr_dev(input, "style", input_style_value = "vertical-align:middle;");
			input.value = input_value_value = /*data2*/ ctx[31].id;
			attr_dev(input, "name", input_name_value = "tm" + (/*i*/ ctx[30] + 1));
			attr_dev(input, "id", input_id_value = "t" + /*i*/ ctx[30] + /*j*/ ctx[33]);
			attr_dev(input, "data-termid", input_data_termid_value = /*data*/ ctx[28].id);
			attr_dev(input, "data-correct", input_data_correct_value = /*data*/ ctx[28].correct);
			attr_dev(input, "data-userans", "");
			attr_dev(input, "data-role", "none");
			attr_dev(input, "tabindex", input_tabindex_value = -1);
			add_location(input, file, 532, 36, 19795);
			attr_dev(label, "tabindex", label_tabindex_value = 0);

			attr_dev(label, "class", label_class_value = "label_choice customRadCM " + (/*j*/ ctx[33] % 2 == 0
			? "tureitemColorCM"
			: "falseitemColorCM"));

			attr_dev(label, "for", label_for_value = "t" + /*i*/ ctx[30] + /*j*/ ctx[33]);
			add_location(label, file, 546, 36, 20645);
			attr_dev(td, "key", td_key_value = /*j*/ ctx[33]);
			attr_dev(td, "id", td_id_value = "tb" + /*i*/ ctx[30] + /*j*/ ctx[33]);

			attr_dev(td, "class", td_class_value = "text-center test_area " + (/*data2*/ ctx[31].id == /*data*/ ctx[28].correct
			? "dbg-success"
			: "dbg-danger"));

			set_style(td, "background-color", /*i*/ ctx[30] % 2 == 0
			? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
			: "#FFF");

			add_location(td, file, 515, 32, 18756);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, i0);
			append_dev(td, t0);
			append_dev(td, i1);
			append_dev(td, t1);
			append_dev(td, input);
			append_dev(td, t2);
			append_dev(td, label);

			if (!mounted) {
				dispose = listen_dev(input, "click", /*setUserAns*/ ctx[8], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm*/ 2 && input_value_value !== (input_value_value = /*data2*/ ctx[31].id)) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*cm*/ 2 && input_data_termid_value !== (input_data_termid_value = /*data*/ ctx[28].id)) {
				attr_dev(input, "data-termid", input_data_termid_value);
			}

			if (dirty[0] & /*cm*/ 2 && input_data_correct_value !== (input_data_correct_value = /*data*/ ctx[28].correct)) {
				attr_dev(input, "data-correct", input_data_correct_value);
			}

			if (dirty[0] & /*cm*/ 2 && td_class_value !== (td_class_value = "text-center test_area " + (/*data2*/ ctx[31].id == /*data*/ ctx[28].correct
			? "dbg-success"
			: "dbg-danger"))) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(td, "background-color", /*i*/ ctx[30] % 2 == 0
				? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
				: "#FFF");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(515:32) {#each cm.cdata.option as data2, j}",
		ctx
	});

	return block;
}

// (507:24) {#each cm.cdata.term as data,i}
function create_each_block(ctx) {
	let tr;
	let td;
	let t0_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t0;
	let td_class_value;
	let td_tabindex_value;
	let t1;
	let t2;
	let tr_key_value;
	let each_value_1 = /*cm*/ ctx[1].cdata.option;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");
			td = element("td");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			attr_dev(td, "class", td_class_value = /*data*/ ctx[28].id);
			attr_dev(td, "tabindex", td_tabindex_value = 0);

			set_style(
				td,
				"background-color",
				/*i*/ ctx[30] % 2 == 0
				? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
				: "#FFF",
				1
			);

			set_style(td, "font-size", "14pt");
			set_style(td, "vertical-align", "middle");
			set_style(td, "font-family", /*state*/ ctx[2].font);
			add_location(td, file, 508, 32, 18215);
			attr_dev(tr, "key", tr_key_value = /*i*/ ctx[30]);
			add_location(tr, file, 507, 28, 18167);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			append_dev(td, t0);
			append_dev(tr, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm*/ 2 && t0_value !== (t0_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*cm*/ 2 && td_class_value !== (td_class_value = /*data*/ ctx[28].id)) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(
					td,
					"background-color",
					/*i*/ ctx[30] % 2 == 0
					? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
					: "#FFF",
					1
				);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(td, "font-family", /*state*/ ctx[2].font);
			}

			if (dirty[0] & /*cm, theme_color_terms, state, setUserAns, isIE*/ 302) {
				each_value_1 = /*cm*/ ctx[1].cdata.option;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(507:24) {#each cm.cdata.term as data,i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div;
	let itemhelper;
	let t0;
	let center;
	let table;
	let thead;
	let tr;
	let th;
	let t1_value = /*state*/ ctx[2].stem.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t1;
	let th_class_value;
	let th_tabindex_value;
	let t2;
	let t3;
	let tbody;
	let table_class_value;
	let table_style_value;
	let div_style_value;
	let current;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[9],
				reviewMode: /*isReview*/ ctx[0]
			},
			$$inline: true
		});

	itemhelper.$on("setReview", /*setReview*/ ctx[6]);
	itemhelper.$on("unsetReview", /*unSetReview*/ ctx[7]);
	let if_block0 = /*state*/ ctx[2].cdata && create_if_block_1(ctx);
	let if_block1 = /*cm*/ ctx[1].cdata && create_if_block(ctx);

	const block = {
		c: function create() {
			main = element("main");
			div = element("div");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			center = element("center");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th = element("th");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			tbody = element("tbody");
			if (if_block1) if_block1.c();

			attr_dev(th, "class", th_class_value = "preview_header " + (/*state*/ ctx[2].theme !== "theme3"
			? "text-center text-white"
			: "text-center"));

			attr_dev(th, "tabindex", th_tabindex_value = 0);
			set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			add_location(th, file, 486, 24, 16887);
			attr_dev(tr, "class", "table-head");
			add_location(tr, file, 485, 20, 16836);
			add_location(thead, file, 484, 16, 16807);
			add_location(tbody, file, 504, 16, 18036);
			attr_dev(table, "class", table_class_value = "table table-bordered testmode_table ");
			attr_dev(table, "id", "test_table");
			attr_dev(table, "style", table_style_value = "" + ("position:relative; margin-top:20px;width:" + /*state*/ ctx[2].maxWidth + "px" + ";font-family: Georgia;"));
			add_location(table, file, 483, 12, 16621);
			add_location(center, file, 482, 8, 16599);
			attr_dev(div, "id", "choicemain");
			attr_dev(div, "style", div_style_value = "margin-bottom:20px");
			add_location(div, file, 475, 4, 16337);
			add_location(main, file, 474, 0, 16325);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div);
			mount_component(itemhelper, div, null);
			append_dev(div, t0);
			append_dev(div, center);
			append_dev(center, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th);
			append_dev(th, t1);
			append_dev(tr, t2);
			if (if_block0) if_block0.m(tr, null);
			append_dev(table, t3);
			append_dev(table, tbody);
			if (if_block1) if_block1.m(tbody, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);
			if ((!current || dirty[0] & /*state*/ 4) && t1_value !== (t1_value = /*state*/ ctx[2].stem.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t1, t1_value);

			if (!current || dirty[0] & /*state*/ 4 && th_class_value !== (th_class_value = "preview_header " + (/*state*/ ctx[2].theme !== "theme3"
			? "text-center text-white"
			: "text-center"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (!current || dirty[0] & /*state*/ 4) {
				set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			}

			if (/*state*/ ctx[2].cdata) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(tr, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*cm*/ ctx[1].cdata) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(tbody, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty[0] & /*state*/ 4 && table_style_value !== (table_style_value = "" + ("position:relative; margin-top:20px;width:" + /*state*/ ctx[2].maxWidth + "px" + ";font-family: Georgia;"))) {
				attr_dev(table, "style", table_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(itemhelper);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function previewUserAns() {
	let test_radio_len = document.getElementsByClassName("test_radio");

	for (let i = 0; i < test_radio_len.length; i++) {
		if (test_radio_len[i].getAttribute("id") == test_radio_len[i].getAttribute("data-userans")) {
			test_radio_len[i].checked = true;
		} else {
			test_radio_len[i].checked = false;
		}
	}
}

/////// Hiding correct or incorrect answer ////////////////
function hideCorIncorIcon() {
	//jQuery(".fa-check"); // Replaced
	//jQuery(".fa-close").hide(); // Replaced
	let hide_icon_length = document.getElementsByClassName("fa-check");

	let hide_icon_length1 = document.getElementsByClassName("fa-close");

	for (let i = 0; i < hide_icon_length.length; i++) {
		hide_icon_length[i].style.display = "none";
		hide_icon_length1[i].style.display = "none";
	}
}

// for setting the icon style
function setIconStyle(ie) {
	if (ie == true) {
		return {
			paddingLeft: "14px",
			display: "inline-flex",
			position: "absolute"
		};
	} else {
		return {
			paddingLeft: "15px",
			display: "none",
			position: "absolute"
		};
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ChoiceMatrixPreview", slots, []);
	let { showAns } = $$props;
	let { editorState } = $$props;
	let { xml } = $$props;
	let { uxml } = $$props;
	let { isReview } = $$props;
	let useransNew;
	let cm = { cdata: "" };
	let isIE;
	let mainId = "";
	let state = {};

	let stateData = writable({
		cdata: "",
		stem: "",
		xml: "",
		theme: "",
		font: "",
		maxWidth: "",
		totalcorrectans: ""
	});

	let theme_color = {
		theme1: "#5B9BD5",
		theme2: "#3B67BC",
		theme3: "#F6C3A2",
		theme4: "#70AD47",
		theme5: "#745998"
	};

	let theme_color_terms = {
		theme1: "#DEEAF6",
		theme2: "#D4DEF1",
		theme3: "#FAE0CF",
		theme4: "#E2EFD9",
		theme5: "#E1DAE9"
	};

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(2, state = items);
	});

	///////  XML change then automatically reload code ///////////////
	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(2, state.xml = xml, state);
			loadModule(xml, uxml);
		}
	});

	// function for checking the focus
	/*    function checkFocus(list){
        let is_focus = false;
        jQuery(".choiceMatrixRender").find("."+list).each(function() {
            if(jQuery(this).is(":focus")) {
                is_focus = true;
                return false;
            }
        });
        return is_focus;
    }  */
	afterUpdate(() => {
		if (!isReview) hideCorIncorIcon();
	});

	onMount(() => {
		// Check the radio when press the Enter Key ADA
		AI.listen("body", "keydown", ".label_choice", function (_this, e) {
			if (e.which === 13) {
				_this.click();
			}
		});
	});

	function setReview() {
		modeOn();
	}

	function unSetReview() {
		previewUserAns();
		modeOff();
	}

	/////////////// Loding the xml and uaXML ///////////////////
	function loadModule(loadXml, uaXML) {
		loadXml = XMLToJSON(loadXml);
		parseXMLPreview(loadXml, uaXML);
	}

	///////// FUnction parsing the xml ////////////////////////
	function parseXMLPreview(MYXML, uaXML) {
		// setting state of theme, font, maxwidth
		$$invalidate(2, state.theme = MYXML.smxml._theme, state);

		$$invalidate(2, state.font = MYXML.smxml._font, state);
		$$invalidate(2, state.maxWidth = MYXML.smxml._maxwidth ? MYXML.smxml._maxwidth : 800, state);
		let formattedData = parseCSV.parseCSVFormat(MYXML.smxml.__cdata);
		let cdata = formattedData;
		let rawData = [];

		// copy cdata into rawData////// 
		/* jQuery.map(cdata, function (value, index) {
    rawData[index] = value;
});   Replaced     */
		rawData = JSON.parse(JSON.stringify(cdata));

		$$invalidate(2, state.cdata = rawData, state);
		$$invalidate(2, state.stem = rawData.stem, state);
		$$invalidate(1, cm.cdata = rawData, cm);
		let len = cm.cdata.term.length;
		$$invalidate(2, state.totalcorrectans = len, state);
		modeOff();

		// User anser checking/////////
		if (uaXML) {
			try {
				// parsing the json data
				uaXML = JSON.parse(uaXML);

				let rawUaXML = [];

				// storing uaXML in rawUaXML and storing its value
				/*    jQuery.map(uaXML, function (value, index) {
        rawUaXML[index] = value;
    }); replaced   */
				rawUaXML = JSON.parse(JSON.stringify(uaXML));

				//    setting the data-userans on the basis of ans
				setTimeout(
					function () {
						rawUaXML.ans.map(function (data, i) {
							//alert("#"+data.userAns);
							//jQuery(".test_area").find("#"+data.userAns).attr("data-userans",data.userAns);
							AH.selectAll(".test_area" + " #" + data.userAns, "attr", { "data-userans": data.userAns });
						});

						previewUserAns();
					},
					100
				);
			} catch(e) {
				
			} // let datauser;
			//uaXML = "";
		} else {
			// if is not user ans then unchecked all the radio btn
			/*    jQuery(".test_radio").each(function () {
        jQuery(this)[0].checked = false;
        jQuery(this).attr('data-userans',"");
    })  */
			let test_radio_len = document.getElementsByClassName("test_radio");

			for (let i = 0; i < test_radio_len.length; i++) {
				test_radio_len[i].checked = false;
				test_radio_len[i].setAttribute("data-userans", "");
			}
		}
	}

	///////////  Storing the user answer whenever clicked////////////////
	function setUserAns(e) {
		let id = e.target.id;
		let name = e.target.name;

		// set the user ans blank
		//    jQuery(mainId+" .test_area input[name=" + name + "]").attr("data-userans", ""); Replaced
		let test_area_input = document.querySelectorAll(mainId + " .test_area input[name=" + name + "]");

		for (let i = 0; i < test_area_input.length; i++) {
			test_area_input[i].setAttribute("data-userans", "");
		}

		// setting the data-userans on which user is clicked
		//jQuery(mainId+" .test_area").find("#" + id + "").attr("data-userans", id);// Replaced
		AH.selectAll(mainId + " .test_area" + " #" + id + "", "attr", { "data-userans": id });

		let userans = { "type": "34", "ans": [] };

		/////////// updating the user ans /////////////////////////
		/* jQuery(mainId+" .test_radio").each(function () {
    if (jQuery(this)[0].checked == true) {
        userans.ans.push({
            id: jQuery(this).attr("data-termid"),
            userAns: jQuery(this).attr("id")
        });
    }
});*/
		let test_radio = document.getElementsByClassName("test_radio");

		for (let i = 0; i < test_radio.length; i++) {
			if (test_radio[i].checked == true) {
				userans.ans.push({
					id: test_radio[i].getAttribute("data-termid"),
					userAns: test_radio[i].getAttribute("id")
				});
			}
		}

		// for autograding
		// updaing the value in the textarea 
		//jQuery("#special_module_user_xml").val(JSON.stringify(userans)); // Replaced;
		//AH('special_module_user_xml').value = JSON.stringify(userans);
		useransNew = JSON.stringify(userans);

		displayAnswer();
	}

	///////////////////////// This function display answer wether the function is correct or incorrect///////////////////
	function displayAnswer() {
		// check the ans
		let ans = checkAns();

		// mark the answer correct or incorrect x
		ans = ans == 1 ? true : false;

		if (uxml) {
			AH.select("#answer").checked = ans;
		} else {
			if (editorState) showAns(ans ? "Correct" : "Incorrect");
		}

		onUserAnsChange({ uXml: useransNew, ans });
	}

	// function check the answer
	function checkAns() {
		let is_correct = 0;
		let temp = 0;
		let test_radio_ans = document.getElementsByClassName("test_radio");

		for (let i = 0; i < test_radio_ans.length; i++) {
			if (test_radio_ans[i].getAttribute("value") == test_radio_ans[i].getAttribute("data-correct")) {
				if (test_radio_ans[i].checked == true) {
					test_radio_ans[i].setAttribute("as", 1);
					is_correct = 1;
				} else {
					is_correct = 0;
					test_radio_ans[i].setAttribute("as", 0);
					return false;
				}
			}
		}

		// for calculating the point
		for (let i = 0; i < test_radio_ans.length; i++) {
			if (test_radio_ans[i].getAttribute("value") == test_radio_ans[i].getAttribute("data-correct")) {
				if (test_radio_ans[i].checked == true) {
					temp++;
				}
			}

			if (typeof calculatePoint != "undefined") {
				calculatePoint(state.totalcorrectans, temp);
			}
		}

		return is_correct;
	}

	// for user aswer tab
	function yourAnswer() {
		previewUserAns();

		// for showing the correct/incorrect icon
		showCorIncorIcon();
	}

	// correct answer tab
	function correctAnswer() {
		previewCorrectAns();

		// for showing the correct/incorrect icon
		hideCorIncorIcon();
	}

	// for showing correct answer
	function previewCorrectAns() {
		/*jQuery(mainId+" .test_radio").each(function () {
        if (jQuery(this).attr('value') == jQuery(this).attr('data-correct')) {
            jQuery(this)[0].checked = true;
        } else {
            jQuery(this)[0].checked = false;
        }
    });   //Replaced     */
		let test_radio = document.querySelectorAll(mainId + " .test_radio");

		for (let i = 0; i < test_radio.length; i++) {
			if (test_radio[i].getAttribute("value") == test_radio[i].getAttribute("data-correct")) {
				test_radio[i].checked = true;
			} else {
				test_radio[i].checked = false;
			}
		}
	}

	/////// This function setReview mode ////////////// 
	function modeOn() {
		$$invalidate(0, isReview = true);

		//jQuery(mainId+" .test_radio").attr('disabled', true); // Replaced
		let test_radio = AH.selectAll(mainId + " .test_radio");

		for (let i = 0; i < test_radio.length; i++) {
			test_radio[i].disabled = true;
		}

		yourAnswer();
	}

	/////// This function unsetReview mode //////////////  
	function modeOff() {
		$$invalidate(0, isReview = false);
		let testRadios = document.getElementsByClassName("test_radio");

		for (let i = 0; i < testRadios.length; i++) {
			testRadios[i].disabled = false;
		}

		hideCorIncorIcon();
	} //jQuery(".dbg-success input:checked").siblings(".label_choice").attr("title",""); // Replaced
	// AH.select(".dbg-success input","checked").forEach((_elm)=>{

	//     AH.siblings(_elm,".label_choice").forEach((_e)=>{
	//         _e.setAttribute("title","")                    
	//     })
	// }); Fix
	//jQuery(".dbg-danger input:checked").siblings(".label_choice").attr("title", ""); // Replaced
	// AH.select(".dbg-danger input:checked").forEach((_elm)=>{
	//     AH.siblings(_elm,".label_choice").forEach((_e)=>{
	//         _e.setAttribute("title","")                    
	//     })
	// }); Fix
	// This function showing correct or incorrect icon////////////////
	function showCorIncorIcon() {
		//jQuery(".dbg-success input:checked").siblings(".fa-check").css({ "display": "inline-flex" }); // Replaced
		// debugger;
		AH.select(".dbg-success input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".fa-check").forEach(_e => {
				_e.style.display = "inline-flex";
			});
		});

		//jQuery(".dbg-danger input:checked").siblings(".fa-close").css({ "display": "inline-flex" });
		AH.select(".dbg-danger input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".fa-close").forEach(_e => {
				_e.style.display = "inline-flex";
			});
		});

		AH.selectAll(".dbg-success input, .dbg-danger input", "removeAttr", "as");

		//jQuery(".dbg-success input:checked").attr("as",1); // Removed
		AH.select(".dbg-success input", "checked").forEach(_succRem => {
			_succRem.setAttribute("as", 1);
		});

		//jQuery(".dbg-danger input:checked").attr("as", 0); // Removed
		AH.select(".dbg-success input", "checked").forEach(_dangRem => {
			_dangRem.setAttribute("as", 0);
		});

		//jQuery(".dbg-success input:checked").siblings(".label_choice").attr("title","is marked as correct");
		AH.select(".dbg-success input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".label_choice").forEach(_e => {
				_e.setAttribute("title", "is marked as correct");
			});
		});

		//jQuery(".dbg-danger input:checked").siblings(".label_choice").attr("title", "is marked as incorrect");
		AH.select(".dbg-danger input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".label_choice").forEach(_e => {
				_e.setAttribute("title", "is marked as incorrect");
			});
		});
	}

	//To handle review toggle
	function handleReview(mode, event) {
		if (mode == "c") {
			correctAnswer();
		} else {
			yourAnswer();
		}
	}

	const writable_props = ["showAns", "editorState", "xml", "uxml", "isReview"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChoiceMatrixPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("showAns" in $$props) $$invalidate(10, showAns = $$props.showAns);
		if ("editorState" in $$props) $$invalidate(11, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(12, xml = $$props.xml);
		if ("uxml" in $$props) $$invalidate(13, uxml = $$props.uxml);
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
	};

	$$self.$capture_state = () => ({
		lib: parseCSV,
		onMount,
		beforeUpdate,
		afterUpdate,
		AH,
		XMLToJSON,
		onUserAnsChange,
		writable,
		ItemHelper,
		showAns,
		editorState,
		xml,
		uxml,
		isReview,
		useransNew,
		cm,
		isIE,
		mainId,
		state,
		stateData,
		theme_color,
		theme_color_terms,
		unsubscribe,
		setReview,
		unSetReview,
		loadModule,
		parseXMLPreview,
		setUserAns,
		displayAnswer,
		checkAns,
		yourAnswer,
		previewUserAns,
		correctAnswer,
		previewCorrectAns,
		modeOn,
		modeOff,
		showCorIncorIcon,
		hideCorIncorIcon,
		setIconStyle,
		handleReview
	});

	$$self.$inject_state = $$props => {
		if ("showAns" in $$props) $$invalidate(10, showAns = $$props.showAns);
		if ("editorState" in $$props) $$invalidate(11, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(12, xml = $$props.xml);
		if ("uxml" in $$props) $$invalidate(13, uxml = $$props.uxml);
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("useransNew" in $$props) useransNew = $$props.useransNew;
		if ("cm" in $$props) $$invalidate(1, cm = $$props.cm);
		if ("isIE" in $$props) $$invalidate(3, isIE = $$props.isIE);
		if ("mainId" in $$props) mainId = $$props.mainId;
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("theme_color" in $$props) $$invalidate(4, theme_color = $$props.theme_color);
		if ("theme_color_terms" in $$props) $$invalidate(5, theme_color_terms = $$props.theme_color_terms);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isReview*/ 1) {
			 if (isReview) {
				// this condition will true in test area
				modeOn();
			} else {
				previewUserAns();
				modeOff();
			}
		}
	};

	return [
		isReview,
		cm,
		state,
		isIE,
		theme_color,
		theme_color_terms,
		setReview,
		unSetReview,
		setUserAns,
		handleReview,
		showAns,
		editorState,
		xml,
		uxml
	];
}

class ChoiceMatrixPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-qkuer1-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				showAns: 10,
				editorState: 11,
				xml: 12,
				uxml: 13,
				isReview: 0
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChoiceMatrixPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*showAns*/ ctx[10] === undefined && !("showAns" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'showAns'");
		}

		if (/*editorState*/ ctx[11] === undefined && !("editorState" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'editorState'");
		}

		if (/*xml*/ ctx[12] === undefined && !("xml" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'xml'");
		}

		if (/*uxml*/ ctx[13] === undefined && !("uxml" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'uxml'");
		}

		if (/*isReview*/ ctx[0] === undefined && !("isReview" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'isReview'");
		}
	}

	get showAns() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isReview() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ChoiceMatrixPreview;
//# sourceMappingURL=ChoiceMatrixPreview-791df211.js.map
