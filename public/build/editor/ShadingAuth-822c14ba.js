
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, a4 as createEventDispatcher, y as l, z as empty, n as insert_dev, B as noop, x as detach_dev, e as element, f as space, h as text, j as attr_dev, k as add_location, p as append_dev, E as set_data_dev, q as listen_dev, F as prop_dev, G as run_all, C as validate_each_argument, H as destroy_each, l as set_style, g as globals, o as onMount, X as XMLToJSON, A as AH, K as JSONToXML, aa as afterUpdate, I as beforeUpdate, c as create_component, m as mount_component, a0 as select_option, t as transition_in, a as transition_out, b as destroy_component } from './main-b06d0f55.js';

/* clsSMShadedGrid\inputField.svelte generated by Svelte v3.40.2 */
const file = "clsSMShadedGrid\\inputField.svelte";

// (22:0) {:else}
function create_else_block(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let div1;
	let input;
	let t2;
	let mounted;
	let dispose;
	let if_block = /*shwmsg*/ ctx[7] == 1 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(/*labelname*/ ctx[0]);
			t1 = space();
			div1 = element("div");
			input = element("input");
			t2 = space();
			if (if_block) if_block.c();
			attr_dev(div0, "class", "font-weight-bold mb-2");
			add_location(div0, file, 23, 8, 760);
			attr_dev(input, "type", "number");
			attr_dev(input, "min", "1");
			attr_dev(input, "max", /*max*/ ctx[4]);
			attr_dev(input, "name", /*name*/ ctx[2]);
			attr_dev(input, "id", /*id*/ ctx[3]);
			attr_dev(input, "class", "form-control width100 inline-block inputChange");
			attr_dev(input, "data-label", /*datalabel*/ ctx[1]);
			input.value = /*value*/ ctx[5];
			add_location(input, file, 25, 12, 841);
			add_location(div1, file, 24, 8, 822);
			attr_dev(div2, "class", "col-sm-6 inline-block");
			add_location(div2, file, 22, 4, 715);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, input);
			append_dev(div2, t2);
			if (if_block) if_block.m(div2, null);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*change_handler_1*/ ctx[12], false, false, false),
					listen_dev(input, "blur", /*blur_handler_1*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*labelname*/ 1) set_data_dev(t0, /*labelname*/ ctx[0]);

			if (dirty & /*max*/ 16) {
				attr_dev(input, "max", /*max*/ ctx[4]);
			}

			if (dirty & /*name*/ 4) {
				attr_dev(input, "name", /*name*/ ctx[2]);
			}

			if (dirty & /*id*/ 8) {
				attr_dev(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*datalabel*/ 2) {
				attr_dev(input, "data-label", /*datalabel*/ ctx[1]);
			}

			if (dirty & /*value*/ 32) {
				prop_dev(input, "value", /*value*/ ctx[5]);
			}

			if (/*shwmsg*/ ctx[7] == 1) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(div2, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(22:0) {:else}",
		ctx
	});

	return block;
}

// (9:0) {#if set_corr_ans == 1}
function create_if_block(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "number");
			attr_dev(input, "min", "1");
			attr_dev(input, "max", /*max*/ ctx[4]);
			attr_dev(input, "class", "form-control inputChange");
			attr_dev(input, "id", "methodCount");
			attr_dev(input, "name", "methodCount");
			attr_dev(input, "data-label", "Number of correct");
			input.value = /*value*/ ctx[5];
			add_location(input, file, 9, 4, 328);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*change_handler*/ ctx[10], false, false, false),
					listen_dev(input, "blur", /*blur_handler*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*max*/ 16) {
				attr_dev(input, "max", /*max*/ ctx[4]);
			}

			if (dirty & /*value*/ 32) {
				prop_dev(input, "value", /*value*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(9:0) {#if set_corr_ans == 1}",
		ctx
	});

	return block;
}

// (29:8) {#if shwmsg == 1}
function create_if_block_1(ctx) {
	let div;
	let span1;
	let span0;
	let t0;
	let t1_value = l.multiple_of + "";
	let t1;
	let t2;
	let t3;
	let t4;

	const block = {
		c: function create() {
			div = element("div");
			span1 = element("span");
			span0 = element("span");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			t3 = text(/*msgdetail*/ ctx[6]);
			t4 = text("px");
			attr_dev(span0, "class", "icomoon-24px-info-5 pr-1");
			add_location(span0, file, 31, 20, 1280);
			attr_dev(span1, "class", "font13 text-danger");
			add_location(span1, file, 30, 16, 1225);
			attr_dev(div, "class", "mt-1");
			add_location(div, file, 29, 12, 1189);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span1);
			append_dev(span1, span0);
			append_dev(span1, t0);
			append_dev(span1, t1);
			append_dev(span1, t2);
			append_dev(span1, t3);
			append_dev(span1, t4);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*msgdetail*/ 64) set_data_dev(t3, /*msgdetail*/ ctx[6]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(29:8) {#if shwmsg == 1}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*set_corr_ans*/ ctx[8] == 1) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('InputField', slots, []);
	let { labelname } = $$props;
	let { datalabel } = $$props;

	let { name } = $$props,
		{ id } = $$props,
		{ max } = $$props,
		{ value } = $$props,
		{ msgdetail } = $$props,
		{ shwmsg } = $$props,
		{ set_corr_ans } = $$props;

	const dispatch = createEventDispatcher();

	const writable_props = [
		'labelname',
		'datalabel',
		'name',
		'id',
		'max',
		'value',
		'msgdetail',
		'shwmsg',
		'set_corr_ans'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InputField> was created with unknown prop '${key}'`);
	});

	const change_handler = e => dispatch('handleChange', { value: e });
	const blur_handler = e => dispatch('inputChangeBlur', { value: e });
	const change_handler_1 = e => dispatch('handleChange', { value: e });
	const blur_handler_1 = e => dispatch('inputChangeBlur', { value: e });

	$$self.$$set = $$props => {
		if ('labelname' in $$props) $$invalidate(0, labelname = $$props.labelname);
		if ('datalabel' in $$props) $$invalidate(1, datalabel = $$props.datalabel);
		if ('name' in $$props) $$invalidate(2, name = $$props.name);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('value' in $$props) $$invalidate(5, value = $$props.value);
		if ('msgdetail' in $$props) $$invalidate(6, msgdetail = $$props.msgdetail);
		if ('shwmsg' in $$props) $$invalidate(7, shwmsg = $$props.shwmsg);
		if ('set_corr_ans' in $$props) $$invalidate(8, set_corr_ans = $$props.set_corr_ans);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		l,
		labelname,
		datalabel,
		name,
		id,
		max,
		value,
		msgdetail,
		shwmsg,
		set_corr_ans,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ('labelname' in $$props) $$invalidate(0, labelname = $$props.labelname);
		if ('datalabel' in $$props) $$invalidate(1, datalabel = $$props.datalabel);
		if ('name' in $$props) $$invalidate(2, name = $$props.name);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('value' in $$props) $$invalidate(5, value = $$props.value);
		if ('msgdetail' in $$props) $$invalidate(6, msgdetail = $$props.msgdetail);
		if ('shwmsg' in $$props) $$invalidate(7, shwmsg = $$props.shwmsg);
		if ('set_corr_ans' in $$props) $$invalidate(8, set_corr_ans = $$props.set_corr_ans);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		labelname,
		datalabel,
		name,
		id,
		max,
		value,
		msgdetail,
		shwmsg,
		set_corr_ans,
		dispatch,
		change_handler,
		blur_handler,
		change_handler_1,
		blur_handler_1
	];
}

class InputField extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			labelname: 0,
			datalabel: 1,
			name: 2,
			id: 3,
			max: 4,
			value: 5,
			msgdetail: 6,
			shwmsg: 7,
			set_corr_ans: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InputField",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*labelname*/ ctx[0] === undefined && !('labelname' in props)) {
			console.warn("<InputField> was created without expected prop 'labelname'");
		}

		if (/*datalabel*/ ctx[1] === undefined && !('datalabel' in props)) {
			console.warn("<InputField> was created without expected prop 'datalabel'");
		}

		if (/*name*/ ctx[2] === undefined && !('name' in props)) {
			console.warn("<InputField> was created without expected prop 'name'");
		}

		if (/*id*/ ctx[3] === undefined && !('id' in props)) {
			console.warn("<InputField> was created without expected prop 'id'");
		}

		if (/*max*/ ctx[4] === undefined && !('max' in props)) {
			console.warn("<InputField> was created without expected prop 'max'");
		}

		if (/*value*/ ctx[5] === undefined && !('value' in props)) {
			console.warn("<InputField> was created without expected prop 'value'");
		}

		if (/*msgdetail*/ ctx[6] === undefined && !('msgdetail' in props)) {
			console.warn("<InputField> was created without expected prop 'msgdetail'");
		}

		if (/*shwmsg*/ ctx[7] === undefined && !('shwmsg' in props)) {
			console.warn("<InputField> was created without expected prop 'shwmsg'");
		}

		if (/*set_corr_ans*/ ctx[8] === undefined && !('set_corr_ans' in props)) {
			console.warn("<InputField> was created without expected prop 'set_corr_ans'");
		}
	}

	get labelname() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelname(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get datalabel() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set datalabel(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get msgdetail() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set msgdetail(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shwmsg() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shwmsg(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get set_corr_ans() {
		throw new Error("<InputField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set set_corr_ans(value) {
		throw new Error("<InputField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMShadedGrid\shadedGridTable.svelte generated by Svelte v3.40.2 */
const file$1 = "clsSMShadedGrid\\shadedGridTable.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[9] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (8:8) {#if total_row_count && total_row_count.length > 0}
function create_if_block$1(ctx) {
	let each_1_anchor;
	let each_value = /*total_row_count*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*total_row_count, table_value, dispatch*/ 28) {
				each_value = /*total_row_count*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(8:8) {#if total_row_count && total_row_count.length > 0}",
		ctx
	});

	return block;
}

// (11:20) {#if table_value && table_value.length > 0}
function create_if_block_1$1(ctx) {
	let each_1_anchor;
	let each_value_1 = /*table_value*/ ctx[3];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*table_value, dispatch*/ 24) {
				each_value_1 = /*table_value*/ ctx[3];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(11:20) {#if table_value && table_value.length > 0}",
		ctx
	});

	return block;
}

// (13:28) {#if i == value.rowno}
function create_if_block_2(ctx) {
	let td;
	let td_id_value;
	let td_data_id_value;
	let td_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			attr_dev(td, "id", td_id_value = /*value*/ ctx[10].id);
			attr_dev(td, "data-hidden", "no");
			attr_dev(td, "tabindex", "0");
			attr_dev(td, "data-grid", "no");
			attr_dev(td, "data-id", td_data_id_value = /*value*/ ctx[10].dataid);
			attr_dev(td, "class", td_class_value = `${/*value*/ ctx[10].class} gridColor pointer`);
			set_style(td, "width", /*value*/ ctx[10].width);
			set_style(td, "height", /*value*/ ctx[10].height);
			add_location(td, file$1, 13, 32, 593);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(td, "click", /*click_handler*/ ctx[5], false, false, false),
					listen_dev(td, "keyup", /*keyup_handler*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*table_value*/ 8 && td_id_value !== (td_id_value = /*value*/ ctx[10].id)) {
				attr_dev(td, "id", td_id_value);
			}

			if (dirty & /*table_value*/ 8 && td_data_id_value !== (td_data_id_value = /*value*/ ctx[10].dataid)) {
				attr_dev(td, "data-id", td_data_id_value);
			}

			if (dirty & /*table_value*/ 8 && td_class_value !== (td_class_value = `${/*value*/ ctx[10].class} gridColor pointer`)) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty & /*table_value*/ 8) {
				set_style(td, "width", /*value*/ ctx[10].width);
			}

			if (dirty & /*table_value*/ 8) {
				set_style(td, "height", /*value*/ ctx[10].height);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(13:28) {#if i == value.rowno}",
		ctx
	});

	return block;
}

// (12:24) {#each table_value as value}
function create_each_block_1(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[9] == /*value*/ ctx[10].rowno && create_if_block_2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*i*/ ctx[9] == /*value*/ ctx[10].rowno) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(12:24) {#each table_value as value}",
		ctx
	});

	return block;
}

// (9:12) {#each total_row_count as data, i}
function create_each_block(ctx) {
	let tr;
	let t;
	let tr_id_value;
	let if_block = /*table_value*/ ctx[3] && /*table_value*/ ctx[3].length > 0 && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			tr = element("tr");
			if (if_block) if_block.c();
			t = space();
			attr_dev(tr, "id", tr_id_value = /*data*/ ctx[7].id);
			add_location(tr, file$1, 9, 16, 371);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			if (if_block) if_block.m(tr, null);
			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (/*table_value*/ ctx[3] && /*table_value*/ ctx[3].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(tr, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*total_row_count*/ 4 && tr_id_value !== (tr_id_value = /*data*/ ctx[7].id)) {
				attr_dev(tr, "id", tr_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(9:12) {#each total_row_count as data, i}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let table;
	let tbody;
	let if_block = /*total_row_count*/ ctx[2] && /*total_row_count*/ ctx[2].length > 0 && create_if_block$1(ctx);

	const block = {
		c: function create() {
			table = element("table");
			tbody = element("tbody");
			if (if_block) if_block.c();
			add_location(tbody, file$1, 6, 4, 237);
			attr_dev(table, "id", /*table_id*/ ctx[0]);
			attr_dev(table, "class", /*table_class*/ ctx[1]);
			add_location(table, file$1, 5, 0, 190);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, table, anchor);
			append_dev(table, tbody);
			if (if_block) if_block.m(tbody, null);
		},
		p: function update(ctx, [dirty]) {
			if (/*total_row_count*/ ctx[2] && /*total_row_count*/ ctx[2].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(tbody, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*table_id*/ 1) {
				attr_dev(table, "id", /*table_id*/ ctx[0]);
			}

			if (dirty & /*table_class*/ 2) {
				attr_dev(table, "class", /*table_class*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(table);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ShadedGridTable', slots, []);

	let { table_id } = $$props,
		{ table_class } = $$props,
		{ total_row_count } = $$props,
		{ table_value } = $$props;

	const dispatch = createEventDispatcher();
	const writable_props = ['table_id', 'table_class', 'total_row_count', 'table_value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShadedGridTable> was created with unknown prop '${key}'`);
	});

	const click_handler = e => dispatch('gridClick', { value: e });
	const keyup_handler = e => dispatch('adaKeyupClick', { value: e });

	$$self.$$set = $$props => {
		if ('table_id' in $$props) $$invalidate(0, table_id = $$props.table_id);
		if ('table_class' in $$props) $$invalidate(1, table_class = $$props.table_class);
		if ('total_row_count' in $$props) $$invalidate(2, total_row_count = $$props.total_row_count);
		if ('table_value' in $$props) $$invalidate(3, table_value = $$props.table_value);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		table_id,
		table_class,
		total_row_count,
		table_value,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ('table_id' in $$props) $$invalidate(0, table_id = $$props.table_id);
		if ('table_class' in $$props) $$invalidate(1, table_class = $$props.table_class);
		if ('total_row_count' in $$props) $$invalidate(2, total_row_count = $$props.total_row_count);
		if ('table_value' in $$props) $$invalidate(3, table_value = $$props.table_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		table_id,
		table_class,
		total_row_count,
		table_value,
		dispatch,
		click_handler,
		keyup_handler
	];
}

class ShadedGridTable extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			table_id: 0,
			table_class: 1,
			total_row_count: 2,
			table_value: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ShadedGridTable",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*table_id*/ ctx[0] === undefined && !('table_id' in props)) {
			console.warn("<ShadedGridTable> was created without expected prop 'table_id'");
		}

		if (/*table_class*/ ctx[1] === undefined && !('table_class' in props)) {
			console.warn("<ShadedGridTable> was created without expected prop 'table_class'");
		}

		if (/*total_row_count*/ ctx[2] === undefined && !('total_row_count' in props)) {
			console.warn("<ShadedGridTable> was created without expected prop 'total_row_count'");
		}

		if (/*table_value*/ ctx[3] === undefined && !('table_value' in props)) {
			console.warn("<ShadedGridTable> was created without expected prop 'table_value'");
		}
	}

	get table_id() {
		throw new Error("<ShadedGridTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set table_id(value) {
		throw new Error("<ShadedGridTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get table_class() {
		throw new Error("<ShadedGridTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set table_class(value) {
		throw new Error("<ShadedGridTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get total_row_count() {
		throw new Error("<ShadedGridTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set total_row_count(value) {
		throw new Error("<ShadedGridTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get table_value() {
		throw new Error("<ShadedGridTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set table_value(value) {
		throw new Error("<ShadedGridTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMShadedGrid\ShadingAuth.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file$2 = "clsSMShadedGrid\\ShadingAuth.svelte";

function create_fragment$2(ctx) {
	let div14;
	let div0;
	let t1;
	let div3;
	let div1;
	let inputfield0;
	let t2;
	let inputfield1;
	let t3;
	let div2;
	let inputfield2;
	let t4;
	let inputfield3;
	let t5;
	let div4;
	let t7;
	let div5;
	let shadedgridtable0;
	let t8;
	let div8;
	let div7;
	let label0;
	let input;
	let input_value_value;
	let t9;
	let div6;
	let t10;
	let label1;
	let t12;
	let hr;
	let t13;
	let div9;
	let t15;
	let div10;
	let t17;
	let div12;
	let select;
	let option0;
	let option1;
	let select_value_value;
	let t20;
	let div11;
	let inputfield4;
	let t21;
	let div13;
	let shadedgridtable1;
	let current;
	let mounted;
	let dispose;

	inputfield0 = new InputField({
			props: {
				labelname: l.row_count,
				max: "10",
				name: "rowCount",
				id: "rowCount",
				datalabel: "Number of rows",
				value: /*state*/ ctx[0].rowCount
			},
			$$inline: true
		});

	inputfield0.$on("handleChange", /*handleChange*/ ctx[7]);
	inputfield0.$on("inputChangeBlur", /*inputChangeBlur*/ ctx[8]);

	inputfield1 = new InputField({
			props: {
				labelname: l.col_count,
				max: "10",
				name: "colCount",
				id: "colCount",
				datalabel: "Number of column",
				value: /*state*/ ctx[0].colCount
			},
			$$inline: true
		});

	inputfield1.$on("handleChange", /*handleChange*/ ctx[7]);
	inputfield1.$on("inputChangeBlur", /*inputChangeBlur*/ ctx[8]);

	inputfield2 = new InputField({
			props: {
				labelname: l.cell_width,
				max: "5",
				name: "cellWidth",
				id: "cellWidth",
				datalabel: "Width Value",
				value: /*state*/ ctx[0].cellWidth,
				shwmsg: "1",
				msgdetail: /*sizeMultipleIndex*/ ctx[4]
			},
			$$inline: true
		});

	inputfield2.$on("handleChange", /*handleChange*/ ctx[7]);
	inputfield2.$on("inputChangeBlur", /*inputChangeBlur*/ ctx[8]);

	inputfield3 = new InputField({
			props: {
				labelname: l.cell_height,
				max: "5",
				name: "cellHeight",
				id: "cellHeight",
				datalabel: "Height Value",
				value: /*state*/ ctx[0].cellHeight,
				shwmsg: "1",
				msgdetail: /*sizeMultipleIndex*/ ctx[4]
			},
			$$inline: true
		});

	inputfield3.$on("handleChange", /*handleChange*/ ctx[7]);
	inputfield3.$on("inputChangeBlur", /*inputChangeBlur*/ ctx[8]);

	shadedgridtable0 = new ShadedGridTable({
			props: {
				table_id: "shadingtable",
				table_class: "shadingTable authShadeTable",
				total_row_count: /*total_row_count*/ ctx[2],
				table_value: /*table_value*/ ctx[1]
			},
			$$inline: true
		});

	shadedgridtable0.$on("gridClick", /*authorClick*/ ctx[5]);
	shadedgridtable0.$on("adaKeyupClick", /*adaKeyupAuthorClick*/ ctx[13]);

	inputfield4 = new InputField({
			props: {
				max: /*state*/ ctx[0].rowCount * /*state*/ ctx[0].colCount,
				value: /*state*/ ctx[0].methodCount,
				set_corr_ans: "1"
			},
			$$inline: true
		});

	inputfield4.$on("handleChange", /*handleChange*/ ctx[7]);
	inputfield4.$on("inputChangeBlur", /*inputChangeBlur*/ ctx[8]);

	shadedgridtable1 = new ShadedGridTable({
			props: {
				table_id: "authoringMethod_table",
				table_class: "shadingTable authMethodTable",
				total_row_count: /*total_row_count*/ ctx[2],
				table_value: /*table_corr_value*/ ctx[3]
			},
			$$inline: true
		});

	shadedgridtable1.$on("gridClick", /*boxClick*/ ctx[6]);
	shadedgridtable1.$on("adaKeyupClick", /*adaKeyupBoxClick*/ ctx[12]);

	const block = {
		c: function create() {
			div14 = element("div");
			div0 = element("div");
			div0.textContent = `${l.canvas_options}`;
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			create_component(inputfield0.$$.fragment);
			t2 = space();
			create_component(inputfield1.$$.fragment);
			t3 = space();
			div2 = element("div");
			create_component(inputfield2.$$.fragment);
			t4 = space();
			create_component(inputfield3.$$.fragment);
			t5 = space();
			div4 = element("div");
			div4.textContent = `${l.author_shaded}`;
			t7 = space();
			div5 = element("div");
			create_component(shadedgridtable0.$$.fragment);
			t8 = space();
			div8 = element("div");
			div7 = element("div");
			label0 = element("label");
			input = element("input");
			t9 = space();
			div6 = element("div");
			t10 = space();
			label1 = element("label");
			label1.textContent = `${l.lock_shaded_cells}`;
			t12 = space();
			hr = element("hr");
			t13 = space();
			div9 = element("div");
			div9.textContent = `${l.set_corr_ans}`;
			t15 = space();
			div10 = element("div");
			div10.textContent = `${l.method}`;
			t17 = space();
			div12 = element("div");
			select = element("select");
			option0 = element("option");
			option0.textContent = `${l.set_corr_loc}`;
			option1 = element("option");
			option1.textContent = `${l.set_corr_count}`;
			t20 = space();
			div11 = element("div");
			create_component(inputfield4.$$.fragment);
			t21 = space();
			div13 = element("div");
			create_component(shadedgridtable1.$$.fragment);
			attr_dev(div0, "class", "col-sm-12 mb-4 font-weight-bold font15");
			add_location(div0, file$2, 328, 4, 12910);
			attr_dev(div1, "class", "row mx-0 px-3 mb-4");
			add_location(div1, file$2, 330, 8, 13030);
			attr_dev(div2, "class", "row mx-0 px-3");
			add_location(div2, file$2, 352, 8, 13824);
			attr_dev(div3, "class", "row form-group");
			add_location(div3, file$2, 329, 4, 12992);
			attr_dev(div4, "class", "col-sm-12 mb-4 font-weight-bold font15");
			add_location(div4, file$2, 379, 4, 14774);
			attr_dev(div5, "class", "col-sm-12 mb-4");
			add_location(div5, file$2, 380, 4, 14855);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "id", "lock_author_cell");
			input.value = input_value_value = /*state*/ ctx[0].cellLocked;
			attr_dev(input, "aria-label", "Lock Author checkbox");
			add_location(input, file$2, 393, 16, 15384);
			attr_dev(div6, "class", "check_mark_custom pt-sm1");
			add_location(div6, file$2, 401, 16, 15713);
			attr_dev(label0, "for", "lock_author_cell");
			attr_dev(label0, "class", "custom_checkbox_new float-left mr-1");
			add_location(label0, file$2, 392, 12, 15292);
			attr_dev(label1, "for", "lock_author_cell");
			add_location(label1, file$2, 403, 12, 15793);
			attr_dev(div7, "class", "input-check");
			add_location(div7, file$2, 391, 8, 15253);
			attr_dev(div8, "class", "col-sm-12 mb-5");
			add_location(div8, file$2, 390, 4, 15215);
			attr_dev(hr, "class", "border-dashed-top");
			add_location(hr, file$2, 406, 4, 15886);
			attr_dev(div9, "class", "col-sm-12 mb-4 font-weight-bold font15");
			add_location(div9, file$2, 407, 4, 15924);
			attr_dev(div10, "class", "col-sm-12 mb-4 font-weight-bold font15");
			add_location(div10, file$2, 408, 4, 16004);
			option0.__value = "byLocation";
			option0.value = option0.__value;
			attr_dev(option0, "id", "byLoc_sel");
			attr_dev(option0, "data-show", "locationMethod");
			attr_dev(option0, "data-hide", "countMethod");
			option0.selected = "selected";
			add_location(option0, file$2, 417, 12, 16396);
			option1.__value = "byCount";
			option1.value = option1.__value;
			attr_dev(option1, "id", "bycount_sel");
			attr_dev(option1, "data-show", "countMethod");
			attr_dev(option1, "data-hide", "locationMethod");
			add_location(option1, file$2, 418, 12, 16548);
			attr_dev(select, "name", "authorMethod");
			attr_dev(select, "class", "bg-gray-hover form-select width-authoring d-inline-block");
			attr_dev(select, "id", "set");
			add_location(select, file$2, 410, 8, 16140);
			attr_dev(div11, "class", "mb-4 ml-3 width-authoring countMethod h");
			add_location(div11, file$2, 420, 8, 16696);
			attr_dev(div12, "class", "col-sm-12 mb-4 font-weight-bold font15");
			add_location(div12, file$2, 409, 4, 16078);
			attr_dev(div13, "class", "col-sm-12 mb-4 locationMethod h d-inline-block");
			add_location(div13, file$2, 430, 4, 17063);
			attr_dev(div14, "class", "shadingAuth");
			add_location(div14, file$2, 327, 0, 12879);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div14, anchor);
			append_dev(div14, div0);
			append_dev(div14, t1);
			append_dev(div14, div3);
			append_dev(div3, div1);
			mount_component(inputfield0, div1, null);
			append_dev(div1, t2);
			mount_component(inputfield1, div1, null);
			append_dev(div3, t3);
			append_dev(div3, div2);
			mount_component(inputfield2, div2, null);
			append_dev(div2, t4);
			mount_component(inputfield3, div2, null);
			append_dev(div14, t5);
			append_dev(div14, div4);
			append_dev(div14, t7);
			append_dev(div14, div5);
			mount_component(shadedgridtable0, div5, null);
			append_dev(div14, t8);
			append_dev(div14, div8);
			append_dev(div8, div7);
			append_dev(div7, label0);
			append_dev(label0, input);
			append_dev(label0, t9);
			append_dev(label0, div6);
			append_dev(div7, t10);
			append_dev(div7, label1);
			append_dev(div14, t12);
			append_dev(div14, hr);
			append_dev(div14, t13);
			append_dev(div14, div9);
			append_dev(div14, t15);
			append_dev(div14, div10);
			append_dev(div14, t17);
			append_dev(div14, div12);
			append_dev(div12, select);
			append_dev(select, option0);
			append_dev(select, option1);
			select_option(select, /*state*/ ctx[0].authorMethod);
			append_dev(div12, t20);
			append_dev(div12, div11);
			mount_component(inputfield4, div11, null);
			append_dev(div14, t21);
			append_dev(div14, div13);
			mount_component(shadedgridtable1, div13, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "click", /*checkboxHandler*/ ctx[9], false, false, false),
					listen_dev(input, "keyup", /*adaKeyupCheckbox*/ ctx[11], false, false, false),
					listen_dev(select, "change", /*handleAuthoringMethod*/ ctx[10], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const inputfield0_changes = {};
			if (dirty & /*state*/ 1) inputfield0_changes.value = /*state*/ ctx[0].rowCount;
			inputfield0.$set(inputfield0_changes);
			const inputfield1_changes = {};
			if (dirty & /*state*/ 1) inputfield1_changes.value = /*state*/ ctx[0].colCount;
			inputfield1.$set(inputfield1_changes);
			const inputfield2_changes = {};
			if (dirty & /*state*/ 1) inputfield2_changes.value = /*state*/ ctx[0].cellWidth;
			inputfield2.$set(inputfield2_changes);
			const inputfield3_changes = {};
			if (dirty & /*state*/ 1) inputfield3_changes.value = /*state*/ ctx[0].cellHeight;
			inputfield3.$set(inputfield3_changes);
			const shadedgridtable0_changes = {};
			if (dirty & /*total_row_count*/ 4) shadedgridtable0_changes.total_row_count = /*total_row_count*/ ctx[2];
			if (dirty & /*table_value*/ 2) shadedgridtable0_changes.table_value = /*table_value*/ ctx[1];
			shadedgridtable0.$set(shadedgridtable0_changes);

			if (!current || dirty & /*state*/ 1 && input_value_value !== (input_value_value = /*state*/ ctx[0].cellLocked)) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty & /*state*/ 1 && select_value_value !== (select_value_value = /*state*/ ctx[0].authorMethod)) {
				select_option(select, /*state*/ ctx[0].authorMethod);
			}

			const inputfield4_changes = {};
			if (dirty & /*state*/ 1) inputfield4_changes.max = /*state*/ ctx[0].rowCount * /*state*/ ctx[0].colCount;
			if (dirty & /*state*/ 1) inputfield4_changes.value = /*state*/ ctx[0].methodCount;
			inputfield4.$set(inputfield4_changes);
			const shadedgridtable1_changes = {};
			if (dirty & /*total_row_count*/ 4) shadedgridtable1_changes.total_row_count = /*total_row_count*/ ctx[2];
			if (dirty & /*table_corr_value*/ 8) shadedgridtable1_changes.table_value = /*table_corr_value*/ ctx[3];
			shadedgridtable1.$set(shadedgridtable1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(inputfield0.$$.fragment, local);
			transition_in(inputfield1.$$.fragment, local);
			transition_in(inputfield2.$$.fragment, local);
			transition_in(inputfield3.$$.fragment, local);
			transition_in(shadedgridtable0.$$.fragment, local);
			transition_in(inputfield4.$$.fragment, local);
			transition_in(shadedgridtable1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(inputfield0.$$.fragment, local);
			transition_out(inputfield1.$$.fragment, local);
			transition_out(inputfield2.$$.fragment, local);
			transition_out(inputfield3.$$.fragment, local);
			transition_out(shadedgridtable0.$$.fragment, local);
			transition_out(inputfield4.$$.fragment, local);
			transition_out(shadedgridtable1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div14);
			destroy_component(inputfield0);
			destroy_component(inputfield1);
			destroy_component(inputfield2);
			destroy_component(inputfield3);
			destroy_component(shadedgridtable0);
			destroy_component(inputfield4);
			destroy_component(shadedgridtable1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ShadingAuth', slots, []);
	let { getChildXml } = $$props;
	let { xml } = $$props;

	let state = {
		xml: '',
		gridWidth: "",
		gridHeight: "",
		rowCount: "1",
		colCount: "4",
		cellWidth: "2",
		cellHeight: "2",
		correctAns: [],
		correctCount: 1,
		shadedCell: [],
		cellLocked: 'false',
		hiddenCell: [],
		authorMethod: "byLocation",
		methodCount: "",
		lockedCellValue: ""
	};

	let cellShaded;
	let showSelectedAns = "";
	let sizeMultipleIndex = 40;
	let table_value, total_row_count, table_corr_value;

	onMount(() => {
		$$invalidate(0, state.xml = xml, state);
		const e = new Event("change");
		const element = document.querySelector('#set');
		element.dispatchEvent(e);
		loadModule(xml);
	});

	// loads the module and update the xml
	function loadModule(loadXml) {
		// contains the json data of xml
		loadXml = XMLToJSON(loadXml);

		// parses the xml and updates the sliders elements value
		parseXMLAuthoring(loadXml);
	}

	// parses the xml and updates the values of sliders elements
	function parseXMLAuthoring(MYXML) {
		try {
			$$invalidate(
				0,
				state.correctAns = MYXML.smxml._correctAns.trim()
				? MYXML.smxml._correctAns.split(",")
				: [],
				state
			);

			$$invalidate(0, state.authorMethod = MYXML.smxml._correctCount ? 'byCount' : 'byLocation', state);

			$$invalidate(
				0,
				state.shadedCell = MYXML.smxml._shadedCell.trim()
				? MYXML.smxml._shadedCell.split(",")
				: [],
				state
			);

			$$invalidate(0, state.rowCount = MYXML.smxml._rowCount, state);
			$$invalidate(0, state.colCount = MYXML.smxml._colCount, state);
			$$invalidate(0, state.gridWidth = parseInt(MYXML.smxml._cellWidth) * sizeMultipleIndex, state);
			$$invalidate(0, state.gridHeight = parseInt(MYXML.smxml._cellHeight) * sizeMultipleIndex, state);
			$$invalidate(0, state.cellWidth = MYXML.smxml._cellWidth, state);
			$$invalidate(0, state.cellHeight = MYXML.smxml._cellHeight, state);
			$$invalidate(0, state.cellLocked = MYXML.smxml._lockedCell, state);
			$$invalidate(0, state.lockedCellValue = MYXML.smxml._lockedCellValue, state);

			if (state.cellLocked == 'true') {
				AH.select('#lock_author_cell').checked = true;
			} else {
				AH.select('#lock_author_cell').checked = false;
			}

			// update the xml after converting json xml into xml
			getChildXml(JSONToXML(MYXML));
		} catch(events) {
			console.warn({
				'error': events.message,
				'function name': 'parseXMLAuthoring',
				'File name': 'ShadingAuth.svelte'
			});
		}
	}

	//it manages the click event on grid
	function authorClick(e) {
		let cell = e.detail.value.target.id;
		let selectedGrid;
		let index;
		selectedGrid = AH.select(".shadingAuth #" + cell).getAttribute("data-id");

		if (!AH.select(".shadingAuth #" + cell).classList.contains("lockedGrid")) {
			if (AH.select(".shadingAuth #" + cell).getAttribute("data-grid") == "no") {
				AH.selectAll(".shadingAuth #" + cell, 'addClass', 'gridSelected');
				AH.select(".shadingAuth #" + cell).setAttribute("data-grid", "selected");

				if (!state.shadedCell.includes(selectedGrid)) {
					state.shadedCell.push(selectedGrid);
				}
			} else {
				index = state.shadedCell.indexOf(selectedGrid);
				state.shadedCell.splice(index, 1);
				AH.selectAll(".shadingAuth #" + cell, 'removeClass', 'gridSelected');
				AH.select(".shadingAuth #" + cell).setAttribute("data-grid", "no");
			}
		}

		// updates the xml when the value of any elements changed
		updateXml();
	}

	// to handle click event of correct answer grid
	function boxClick(e) {
		let selectedGrid;
		let index;
		let targetId = e.detail.value.target.id;
		selectedGrid = AH.select(".shadingAuth #" + targetId).getAttribute("data-id");

		if (!AH.select(".shadingAuth #" + targetId).classList.contains("lockedGrid")) {
			if (AH.select(".shadingAuth #" + targetId).getAttribute("data-grid") == "no") {
				AH.select(".shadingAuth #" + targetId).setAttribute("data-grid", "selected");
				AH.selectAll(".shadingAuth #" + targetId, 'addClass', 'gridSelected');

				if (!state.correctAns.includes(selectedGrid)) {
					state.correctAns.push(selectedGrid);
				}
			} else {
				index = state.correctAns.indexOf(selectedGrid);
				state.correctAns.splice(index, 1);
				AH.selectAll(".shadingAuth #" + targetId, 'removeClass', 'gridSelected');
				AH.select(".shadingAuth #" + targetId).setAttribute("data-grid", "no");
			}
		}

		// updates the xml when the value of any elements changed
		updateXml();
	}

	// updates the xml when the value of any elements changed
	function updateXml() {
		setTimeout(
			function () {
				let updatedXml = '<smxml type="44" name="Shading" rowCount="' + state.rowCount + '" colCount="' + state.colCount + '" cellWidth="' + state.cellWidth + '" cellHeight="' + state.cellHeight + '" correctAns="' + state.correctAns + '" correctCount="' + state.methodCount + '" shadedCell="' + state.shadedCell + '" lockedCell="' + state.cellLocked + '" HiddenCell="' + state.hiddenCell + '" lockedCellValue="' + state.lockedCellValue + '"><!--[CDATA[]]--></smxml>';
				getChildXml(updatedXml);
			},
			100
		);
	}

	// to handle on change event of input fields
	function handleChange(eve) {
		let cur_elem = eve.detail.value.target;
		let cellWidthVal = AH.select('#cellWidth').value;
		let cellHeightVal = AH.select('#cellHeight').value;
		let rowCountVal = AH.select('#rowCount').value;
		let colCountVal = AH.select('#colCount').value;
		let methodCountVal = AH.select('#methodCount').value;
		let elementVal = cur_elem.value;
		let min = cur_elem.min;
		let element_id = cur_elem.id;
		let max = cur_elem.max;
		$$invalidate(0, state[cur_elem.name] = cur_elem.value, state);
		$$invalidate(0, state.gridWidth = parseInt(cellWidthVal) * sizeMultipleIndex, state);
		$$invalidate(0, state.gridHeight = cellHeightVal * sizeMultipleIndex, state);
		$$invalidate(0, state.rowCount = rowCountVal, state);
		$$invalidate(0, state.colCount = colCountVal, state);
		$$invalidate(0, state.methodCount = methodCountVal, state);

		if (element_id != "methodCount" && AH.select('#methodCount').value != "") {
			$$invalidate(0, state.methodCount = AH.select('#methodCount').getAttribute('min'), state);
		}

		// For handeling input's min and max value on Keyup 
		if (elementVal != "") {
			let labelText = AH.select("#" + cur_elem.id).getAttribute("data-label");

			if (parseInt(elementVal) < parseInt(min)) {
				AH.alert(labelText + " can be between \n" + min + " to " + max);
				$$invalidate(0, state[cur_elem.name] = min, state);
			} else if (parseInt(elementVal) > parseInt(max)) {
				AH.alert(labelText + " can be between \n" + min + " to " + max);
				$$invalidate(0, state[cur_elem.name] = max, state);
			}
		}

		resetValues();
		updateXml();
	}

	// to reset the shaded grid and correct answer grid
	function resetValues() {
		AH.selectAll("#authoringMethod_table .gridColor,.authShadeTable .gridColor", 'removeClass', 'lockedGrid');

		AH.selectAll("#authoringMethod_table .gridColor,.authShadeTable .gridColor").forEach(gridVal => {
			gridVal.setAttribute("data-grid", "no");
		});

		$$invalidate(0, state.correctAns = [], state);
		$$invalidate(0, state.shadedCell = [], state);
		$$invalidate(0, state.cellLocked = 'false', state);
		$$invalidate(0, state.lockedCellValue = '', state);
	}

	// to handle on blur event of input fields
	function inputChangeBlur(eve) {
		let cur_elem_blur = eve.detail.value.target;

		if (cur_elem_blur.value == '') {
			AH.alert(l.empty_field);
			$$invalidate(0, state[cur_elem_blur.name] = cur_elem_blur.min, state);
			resetValues();
			updateXml();
		}
	}

	// to lock the shaded grid if it is part of corrct answer. done by checkbox
	function checkboxHandler(e) {
		let lockCell = 0;

		state.shadedCell.map(function (data, i) {
			state.correctAns.map(function (data2, j) {
				if (data == data2) {
					lockCell = lockCell + 1;
				}
			});
		});

		if (state.shadedCell.length == 0) {
			AH.alert("Please shade the cells");
			e.preventDefault();
		} else {
			if (lockCell == state.shadedCell.length || state.methodCount != '') {
				$$invalidate(0, state.cellLocked = state.cellLocked == 'true' ? 'false' : 'true', state);
				let auth_id = '';

				AH.selectAll(".authShadeTable td.gridSelected").forEach(value => {
					auth_id += value.getAttribute('data-id') + ',';
				});

				auth_id = auth_id.substr(auth_id, auth_id.length - 1);

				if (state.cellLocked == 'true') {
					AH.selectAll(".authShadeTable td.gridSelected, .authMethodTable #grid_a" + auth_id.split(',').join(',.authMethodTable #grid_a'), 'addClass', 'lockedGrid');
					$$invalidate(0, state.lockedCellValue = auth_id, state);
				} else {
					AH.selectAll(".authShadeTable td.gridSelected, .authMethodTable #grid_a" + auth_id.split(',').join(',.authMethodTable #grid_a'), 'removeClass', 'lockedGrid');
					$$invalidate(0, state.lockedCellValue = '', state);
				}

				updateXml();
			} else {
				AH.alert(l.lock_author_cell);
				e.preventDefault();
			}
		}
	}

	// to handle change event of select field to specify the correct answer method
	function handleAuthoringMethod(event) {
		$$invalidate(0, state.authorMethod = event.target.value, state);
		let _this = AH.select("[name=" + event.target.name + "]");
		AH.selectAll('.' + _this.options[_this.selectedIndex].getAttribute('data-show'), 'addClass', 'd-inline-block');
		AH.selectAll('.' + _this.options[_this.selectedIndex].getAttribute('data-hide'), 'removeClass', 'd-inline-block');

		if (AH.select("[name='" + event.target.name + "']").value == "byCount") {
			$$invalidate(0, state.correctAns = "", state);
			$$invalidate(0, state.methodCount = 1, state);
		} else {
			$$invalidate(0, state.methodCount = "", state);
		}

		resetValues();
		updateXml();
	}

	// for ada checkbox
	function adaKeyupCheckbox(e) {
		if (e.keyCode == 13) {
			checkboxHandler(e);
		}
	}

	// for ada correct ans grid
	function adaKeyupBoxClick(e) {
		if (e.detail.value.keyCode == 13) {
			boxClick(e);
		}
	}

	// for ada shaded grid
	function adaKeyupAuthorClick(e) {
		if (e.detail.value.keyCode == 13) {
			authorClick(e);
		}
	}

	const writable_props = ['getChildXml', 'xml'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<ShadingAuth> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('getChildXml' in $$props) $$invalidate(14, getChildXml = $$props.getChildXml);
		if ('xml' in $$props) $$invalidate(15, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		beforeUpdate,
		XMLToJSON,
		AH,
		JSONToXML,
		l,
		InputField,
		ShadedGridTable,
		getChildXml,
		xml,
		state,
		cellShaded,
		showSelectedAns,
		sizeMultipleIndex,
		table_value,
		total_row_count,
		table_corr_value,
		loadModule,
		parseXMLAuthoring,
		authorClick,
		boxClick,
		updateXml,
		handleChange,
		resetValues,
		inputChangeBlur,
		checkboxHandler,
		handleAuthoringMethod,
		adaKeyupCheckbox,
		adaKeyupBoxClick,
		adaKeyupAuthorClick
	});

	$$self.$inject_state = $$props => {
		if ('getChildXml' in $$props) $$invalidate(14, getChildXml = $$props.getChildXml);
		if ('xml' in $$props) $$invalidate(15, xml = $$props.xml);
		if ('state' in $$props) $$invalidate(0, state = $$props.state);
		if ('cellShaded' in $$props) $$invalidate(16, cellShaded = $$props.cellShaded);
		if ('showSelectedAns' in $$props) $$invalidate(17, showSelectedAns = $$props.showSelectedAns);
		if ('sizeMultipleIndex' in $$props) $$invalidate(4, sizeMultipleIndex = $$props.sizeMultipleIndex);
		if ('table_value' in $$props) $$invalidate(1, table_value = $$props.table_value);
		if ('total_row_count' in $$props) $$invalidate(2, total_row_count = $$props.total_row_count);
		if ('table_corr_value' in $$props) $$invalidate(3, table_corr_value = $$props.table_corr_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*state, total_row_count, table_value, cellShaded, table_corr_value, showSelectedAns, xml*/ 229391) {
			 {
				let index, showAnsIndex;
				($$invalidate(1, table_value = []), $$invalidate(2, total_row_count = []), $$invalidate(3, table_corr_value = []));

				// to create grids
				for (let i = 0; i < state.rowCount; i++) {
					$$invalidate(2, total_row_count = [...total_row_count, { id: 'gridRow_' + i }]);

					for (let j = 0; j < state.colCount; j++) {
						index = state.shadedCell.indexOf(i + "_" + j);
						$$invalidate(16, cellShaded = index != -1 ? "gridSelected" : "");

						// To check for correct answer cells
						showAnsIndex = state.correctAns.indexOf(i + "_" + j);

						if (state.correctAns != "") {
							$$invalidate(17, showSelectedAns = showAnsIndex != -1 ? "gridSelected" : "");
						} else {
							$$invalidate(17, showSelectedAns = "");
						}

						$$invalidate(1, table_value = [
							...table_value,
							{
								id: "grid" + i + "_" + j,
								dataid: i + "_" + j,
								class: cellShaded,
								width: parseInt(state.gridWidth) + 'px',
								height: parseInt(state.gridHeight) + 'px',
								rowno: i
							}
						]);

						$$invalidate(3, table_corr_value = [
							...table_corr_value,
							{
								id: "grid_a" + i + "_" + j,
								dataid: i + "_" + j,
								class: showSelectedAns,
								width: parseInt(state.gridWidth) + 'px',
								height: parseInt(state.gridHeight) + 'px',
								rowno: i
							}
						]);
					}
				}

				if (xml != state.xml) {
					$$invalidate(0, state.xml = xml, state);
					loadModule(xml);
				}
			}
		}
	};

	return [
		state,
		table_value,
		total_row_count,
		table_corr_value,
		sizeMultipleIndex,
		authorClick,
		boxClick,
		handleChange,
		inputChangeBlur,
		checkboxHandler,
		handleAuthoringMethod,
		adaKeyupCheckbox,
		adaKeyupBoxClick,
		adaKeyupAuthorClick,
		getChildXml,
		xml,
		cellShaded,
		showSelectedAns
	];
}

class ShadingAuth extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { getChildXml: 14, xml: 15 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ShadingAuth",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[14] === undefined && !('getChildXml' in props)) {
			console_1.warn("<ShadingAuth> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[15] === undefined && !('xml' in props)) {
			console_1.warn("<ShadingAuth> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<ShadingAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ShadingAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<ShadingAuth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ShadingAuth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ShadingAuth;
//# sourceMappingURL=ShadingAuth-822c14ba.js.map
