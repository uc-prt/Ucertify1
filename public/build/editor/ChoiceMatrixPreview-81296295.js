
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, v as validate_slots, L as beforeUpdate, a7 as afterUpdate, o as onMount, X as XMLToJSON, A as AH, _ as onUserAnsChange, w as writable, C as validate_each_argument, z as empty, n as insert_dev, K as destroy_each, x as detach_dev, h as text, j as attr_dev, l as set_style, k as add_location, F as set_data_dev, f as space, c as create_component, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, q as listen_dev, G as prop_dev } from './main-d98b8a5f.js';
import { I as ItemHelper } from './ItemHelper-5f3cad21.js';
import { p as parseCSV } from './parseCSV-8e31ad8a.js';

/* clsSMChoiceMatrix/ChoiceMatrixPreview.svelte generated by Svelte v3.29.0 */

const { document: document_1 } = globals;
const file = "clsSMChoiceMatrix/ChoiceMatrixPreview.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-qkuer1-style";
	style.textContent = ".fa-check{color:#46A546;position:relative;left:50px}.fa-close{color:#A80000;left:50px}.fa-close,.fa-check{margin-left:-26px;font-size:18px;position:relative;bottom:10px}.fa-close,.fa-check,.middle_align{vertical-align:middle!important}.middle_align{width:164px;min-width:164px}.topic_input{min-width:257px}.preview_header{font-size:16pt;font-weight:bold;vertical-align:middle}.adjust_width{width:10%;text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hvaWNlTWF0cml4UHJldmlldy5zdmVsdGUiLCJzb3VyY2VzIjpbIkNob2ljZU1hdHJpeFByZXZpZXcuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cbiAqICAgRmlsZSBOYW1lICAgOiBDaG9pY2VNYXRyaXhQcmV2aWV3LnN2ZWx0ZVxuICogICBEZXNjcmlwdGlvbiA6IENob2ljZSBNYXRyaXggbW9kdWxlXG4gKiAgIEF1dGhvciAgICAgIDogU3VuZGFyYW0gVHJpcGF0aGkgKHVjLXNkdClcbiAqICAgUGFja2FnZSAgICAgOiBwZS1pdGVtc1xuICogICBMYXN0IHVwZGF0ZSA6IDA1LU1heS0yMDIxXG4gKiAgIExhc3QgVXBkYXRlIEJ5IDogUHJhZGVlcCBZYWRhdlxuIC0tPlxuIDxzY3JpcHQ+XG4gICAgaW1wb3J0IGxpYiBmcm9tICcuL3BhcnNlQ1NWLmpzJzsgXG4gICAgaW1wb3J0IHsgb25Nb3VudCxiZWZvcmVVcGRhdGUsYWZ0ZXJVcGRhdGUgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHtBSCxYTUxUb0pTT04sIG9uVXNlckFuc0NoYW5nZSB9IGZyb20gXCIuLi9oZWxwZXIvSGVscGVyQUkuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG4gICAgaW1wb3J0IEl0ZW1IZWxwZXIgZnJvbSAnLi4vaGVscGVyL0l0ZW1IZWxwZXIuc3ZlbHRlJztcbiAgICBleHBvcnQgbGV0IHNob3dBbnM7XG4gICAgZXhwb3J0IGxldCBlZGl0b3JTdGF0ZTtcbiAgICBleHBvcnQgbGV0IHhtbDsgXG4gICAgZXhwb3J0IGxldCB1eG1sO1xuICAgIGV4cG9ydCBsZXQgaXNSZXZpZXc7XG4gICAgbGV0IHVzZXJhbnNOZXc7XG5cbiAgICBsZXQgY20gPSB7IGNkYXRhOlwiXCIgfTtcbiAgICBsZXQgaXNJRTtcbiAgICBsZXQgbWFpbklkID0gXCJcIjsgXG4gICAgbGV0IHN0YXRlID0ge307XG4gICAgbGV0IHN0YXRlRGF0YSA9IHdyaXRhYmxlKHtcbiAgICAgICAgY2RhdGE6IFwiXCIsXG4gICAgICAgIHN0ZW06IFwiXCIsXG4gICAgICAgIHhtbDogXCJcIixcbiAgICAgICAgdGhlbWU6XCJcIixcbiAgICAgICAgZm9udDpcIlwiLFxuICAgICAgICBtYXhXaWR0aDpcIlwiLFxuICAgICAgICB0b3RhbGNvcnJlY3RhbnM6XCJcIiBcbiAgICB9KVxuICAgIGxldCB0aGVtZV9jb2xvciA9IHtcblx0XHR0aGVtZTE6ICcjNUI5QkQ1Jyxcblx0XHR0aGVtZTI6ICcjM0I2N0JDJyxcblx0XHR0aGVtZTM6ICcjRjZDM0EyJyxcblx0XHR0aGVtZTQ6ICcjNzBBRDQ3Jyxcblx0XHR0aGVtZTU6ICcjNzQ1OTk4J1xuXHR9XG5cdGxldCB0aGVtZV9jb2xvcl90ZXJtcyA9IHtcblx0XHR0aGVtZTE6ICcjREVFQUY2Jyxcblx0XHR0aGVtZTI6ICcjRDRERUYxJyxcblx0XHR0aGVtZTM6ICcjRkFFMENGJyxcblx0XHR0aGVtZTQ6ICcjRTJFRkQ5Jyxcblx0XHR0aGVtZTU6ICcjRTFEQUU5Jyxcblx0fVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RhdGVEYXRhLnN1YnNjcmliZSgoaXRlbXMpID0+IHsgXG4gICAgICAgIHN0YXRlID0gaXRlbXM7XG4gICAgfSlcblxuICAgICQ6IGlmIChpc1Jldmlldykge1xuICAgICAgICAgICAgLy8gdGhpcyBjb25kaXRpb24gd2lsbCB0cnVlIGluIHRlc3QgYXJlYVxuICAgICAgICAgICAgbW9kZU9uKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcHJldmlld1VzZXJBbnMoKTtcbiAgICAgICAgICAgIG1vZGVPZmYoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICBcbiAgICAvLy8vLy8vICBYTUwgY2hhbmdlIHRoZW4gYXV0b21hdGljYWxseSByZWxvYWQgY29kZSAvLy8vLy8vLy8vLy8vLy9cbiAgICBiZWZvcmVVcGRhdGUoKCk9PiB7XG4gICAgICAgIGlmICh4bWwgIT0gc3RhdGUueG1sKSB7XG4gICAgICAgICAgICBzdGF0ZS54bWwgPSB4bWwgO1xuICAgICAgICAgICAgbG9hZE1vZHVsZSh4bWwsIHV4bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgfSk7ICBcblxuICAgIC8vIGZ1bmN0aW9uIGZvciBjaGVja2luZyB0aGUgZm9jdXNcbi8qICAgIGZ1bmN0aW9uIGNoZWNrRm9jdXMobGlzdCl7XG4gICAgICAgIGxldCBpc19mb2N1cyA9IGZhbHNlO1xuICAgICAgICBqUXVlcnkoXCIuY2hvaWNlTWF0cml4UmVuZGVyXCIpLmZpbmQoXCIuXCIrbGlzdCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKGpRdWVyeSh0aGlzKS5pcyhcIjpmb2N1c1wiKSkge1xuICAgICAgICAgICAgICAgIGlzX2ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXNfZm9jdXM7XG4gICAgfSAgKi9cblxuICAgIGFmdGVyVXBkYXRlKCgpPT4ge1xuICAgICAgICBpZighaXNSZXZpZXcpIGhpZGVDb3JJbmNvckljb24oKTtcbiAgICB9KVxuICAgIFxuICAgIG9uTW91bnQoKCk9PiB7XG4gICAgICAgIC8vIENoZWNrIHRoZSByYWRpbyB3aGVuIHByZXNzIHRoZSBFbnRlciBLZXkgQURBXG4gICAgICAgIEFJLmxpc3RlbignYm9keScsICdrZXlkb3duJywnLmxhYmVsX2Nob2ljZScsIGZ1bmN0aW9uKF90aGlzLGUpIHtcbiAgICAgICAgICAgIGlmKGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzZXRSZXZpZXcoKSB7XG4gICAgICAgIG1vZGVPbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuU2V0UmV2aWV3KCkge1xuICAgICAgICBwcmV2aWV3VXNlckFucygpO1xuICAgICAgICBtb2RlT2ZmKCk7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vIExvZGluZyB0aGUgeG1sIGFuZCB1YVhNTCAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgZnVuY3Rpb24gbG9hZE1vZHVsZShsb2FkWG1sLHVhWE1MKSB7XG4gICAgICAgIGxvYWRYbWwgPSBYTUxUb0pTT04obG9hZFhtbCk7XG4gICAgICAgIHBhcnNlWE1MUHJldmlldyhsb2FkWG1sLHVhWE1MKTtcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8gRlVuY3Rpb24gcGFyc2luZyB0aGUgeG1sIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGZ1bmN0aW9uIHBhcnNlWE1MUHJldmlldyhNWVhNTCx1YVhNTCkge1xuICAgICAgICAvLyBzZXR0aW5nIHN0YXRlIG9mIHRoZW1lLCBmb250LCBtYXh3aWR0aFxuICAgICAgICBzdGF0ZS50aGVtZT1NWVhNTC5zbXhtbC5fdGhlbWU7XG4gICAgICAgIHN0YXRlLmZvbnQ9TVlYTUwuc214bWwuX2ZvbnQ7XG4gICAgICAgIHN0YXRlLm1heFdpZHRoID0gKChNWVhNTC5zbXhtbC5fbWF4d2lkdGgpP01ZWE1MLnNteG1sLl9tYXh3aWR0aDogODAwICk7XG4gICAgICAgIFxuXG4gICAgICAgIGxldCBmb3JtYXR0ZWREYXRhID0gbGliLnBhcnNlQ1NWRm9ybWF0KE1ZWE1MLnNteG1sLl9fY2RhdGEpO1xuICAgICAgICBsZXQgY2RhdGEgPSBmb3JtYXR0ZWREYXRhO1xuICAgICAgICBsZXQgcmF3RGF0YSA9IFtdO1xuXG4gICAgICAgIC8vIGNvcHkgY2RhdGEgaW50byByYXdEYXRhLy8vLy8vIFxuXG4gICAgICAgIC8qIGpRdWVyeS5tYXAoY2RhdGEsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJhd0RhdGFbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH0pOyAgIFJlcGxhY2VkICAgICAqL1xuXG4gICAgICAgIHJhd0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNkYXRhKSk7XG5cblxuICAgICAgICBcbiAgICAgICAgc3RhdGUuY2RhdGEgPSByYXdEYXRhOyBcbiAgICAgICAgc3RhdGUuc3RlbSA9IHJhd0RhdGEuc3RlbTtcbiAgICAgICAgY20uY2RhdGEgPSByYXdEYXRhO1xuICAgICAgICBsZXQgbGVuID0gY20uY2RhdGEudGVybS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLnRvdGFsY29ycmVjdGFucyA9IGxlbiA7XG4gICAgICAgIG1vZGVPZmYoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZXIgYW5zZXIgY2hlY2tpbmcvLy8vLy8vLy9cbiAgICAgICAgaWYgKHVhWE1MKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNpbmcgdGhlIGpzb24gZGF0YVxuICAgICAgICAgICAgICAgIHVhWE1MID0gSlNPTi5wYXJzZSh1YVhNTCk7XG4gICAgICAgICAgICAgICAgbGV0IHJhd1VhWE1MID0gW107XG4gICAgICAgICAgICAgICAgLy8gc3RvcmluZyB1YVhNTCBpbiByYXdVYVhNTCBhbmQgc3RvcmluZyBpdHMgdmFsdWVcbiAgICAgICAgICAgIC8qICAgIGpRdWVyeS5tYXAodWFYTUwsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3VWFYTUxbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7IHJlcGxhY2VkICAgKi9cblxuICAgICAgICAgICAgICAgIHJhd1VhWE1MID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh1YVhNTCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vICAgIHNldHRpbmcgdGhlIGRhdGEtdXNlcmFucyBvbiB0aGUgYmFzaXMgb2YgYW5zXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByYXdVYVhNTC5hbnMubWFwKGZ1bmN0aW9uKGRhdGEsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9hbGVydChcIiNcIitkYXRhLnVzZXJBbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9qUXVlcnkoXCIudGVzdF9hcmVhXCIpLmZpbmQoXCIjXCIrZGF0YS51c2VyQW5zKS5hdHRyKFwiZGF0YS11c2VyYW5zXCIsZGF0YS51c2VyQW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbChcIi50ZXN0X2FyZWFcIitcIiAjXCIrZGF0YS51c2VyQW5zLCdhdHRyJyx7XCJkYXRhLXVzZXJhbnNcIjpkYXRhLnVzZXJBbnN9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlld1VzZXJBbnMoKTtcbiAgICAgICAgICAgICAgICB9LDEwMClcbiAgICAgICAgICAgICAgICAgICBcblxuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gbGV0IGRhdGF1c2VyO1xuICAgICAgICAgICAgICAgICAgICAvLyByYXdVYVhNTC5hbnMubWFwKGZ1bmN0aW9uKGRhdGEsaSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IHRlc3RfYXJlYV9sZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0ZXN0X2FyZWEnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGZvcihsZXQgaiA9IDA7IGogPCB0ZXN0X2FyZWFfbGVuLmxlbmd0aDsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCB0ZXN0X2FyZWFfZmluZCA9IEFILmZpbmQodGVzdF9hcmVhX2xlbltqXSwgXCIjXCIrZGF0YS51c2VyQW5zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBpZih0ZXN0X2FyZWFfZmluZCkgdGVzdF9hcmVhX2ZpbmQuc2V0QXR0cmlidXRlKFwiZGF0YS11c2VyYW5zXCIsZGF0YS51c2VyQW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgLy8gfSlcblxuICAgICAgICAgICAgICAgICAgICBcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBzaG93aW5nIHRoZSB1c2VyYW5zICwgdGhhdCBpcyB0aGUgYW5zd2VyIHdoaWNoIGlzIG1hcmtlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvL3VhWE1MID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGlzIG5vdCB1c2VyIGFucyB0aGVuIHVuY2hlY2tlZCBhbGwgdGhlIHJhZGlvIGJ0blxuICAgICAgICAgICAgLyogICAgalF1ZXJ5KFwiLnRlc3RfcmFkaW9cIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKVswXS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5hdHRyKCdkYXRhLXVzZXJhbnMnLFwiXCIpO1xuICAgICAgICAgICAgICAgIH0pICAqL1xuICAgICAgICAgICAgICAgIGxldCB0ZXN0X3JhZGlvX2xlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Rlc3RfcmFkaW8nKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGVzdF9yYWRpb19sZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdF9yYWRpb19sZW5baV0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0X3JhZGlvX2xlbltpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdXNlcmFucycsXCJcIik7ICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8gIFN0b3JpbmcgdGhlIHVzZXIgYW5zd2VyIHdoZW5ldmVyIGNsaWNrZWQvLy8vLy8vLy8vLy8vLy8vXG4gICAgZnVuY3Rpb24gc2V0VXNlckFucyhlKSB7XG4gICAgICAgIGxldCBpZCA9IGUudGFyZ2V0LmlkO1xuICAgICAgICBsZXQgbmFtZSA9IGUudGFyZ2V0Lm5hbWU7XG4gICAgICAgIC8vIHNldCB0aGUgdXNlciBhbnMgYmxhbmtcbiAgICAvLyAgICBqUXVlcnkobWFpbklkK1wiIC50ZXN0X2FyZWEgaW5wdXRbbmFtZT1cIiArIG5hbWUgKyBcIl1cIikuYXR0cihcImRhdGEtdXNlcmFuc1wiLCBcIlwiKTsgUmVwbGFjZWRcblxuICAgICAgICBsZXQgdGVzdF9hcmVhX2lucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChtYWluSWQrXCIgLnRlc3RfYXJlYSBpbnB1dFtuYW1lPVwiICsgbmFtZSArIFwiXVwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0X2FyZWFfaW5wdXQubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB0ZXN0X2FyZWFfaW5wdXRbaV0uc2V0QXR0cmlidXRlKFwiZGF0YS11c2VyYW5zXCIsXCJcIik7XG4gICAgICAgIH1cbiAgICBcblxuXG5cbiAgICAgICAgLy8gc2V0dGluZyB0aGUgZGF0YS11c2VyYW5zIG9uIHdoaWNoIHVzZXIgaXMgY2xpY2tlZFxuICAgICAgICAvL2pRdWVyeShtYWluSWQrXCIgLnRlc3RfYXJlYVwiKS5maW5kKFwiI1wiICsgaWQgKyBcIlwiKS5hdHRyKFwiZGF0YS11c2VyYW5zXCIsIGlkKTsvLyBSZXBsYWNlZFxuICAgICAgICBBSC5zZWxlY3RBbGwobWFpbklkK1wiIC50ZXN0X2FyZWFcIiArIFwiICNcIiArIGlkICsgXCJcIiwnYXR0cicse1wiZGF0YS11c2VyYW5zXCI6aWR9KTtcbiAgICAgICBcbiAgICAgICAgbGV0IHVzZXJhbnMgPSB7IFwidHlwZVwiOiBcIjM0XCIsIFwiYW5zXCI6IFtdIH07XG5cbiAgICAgICAgLy8vLy8vLy8vLy8gdXBkYXRpbmcgdGhlIHVzZXIgYW5zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLyogalF1ZXJ5KG1haW5JZCtcIiAudGVzdF9yYWRpb1wiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkodGhpcylbMF0uY2hlY2tlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdXNlcmFucy5hbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBqUXVlcnkodGhpcykuYXR0cihcImRhdGEtdGVybWlkXCIpLFxuICAgICAgICAgICAgICAgICAgICB1c2VyQW5zOiBqUXVlcnkodGhpcykuYXR0cihcImlkXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pOyovXG4gICAgICAgIFxuICAgICAgICBsZXQgdGVzdF9yYWRpbyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Rlc3RfcmFkaW8nKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaTx0ZXN0X3JhZGlvLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKHRlc3RfcmFkaW9baV0uY2hlY2tlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdXNlcmFucy5hbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB0ZXN0X3JhZGlvW2ldLmdldEF0dHJpYnV0ZShcImRhdGEtdGVybWlkXCIpLFxuICAgICAgICAgICAgICAgICAgICB1c2VyQW5zOiB0ZXN0X3JhZGlvW2ldLmdldEF0dHJpYnV0ZShcImlkXCIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAgXG4gICAgXG4gICAgICAgIC8vIGZvciBhdXRvZ3JhZGluZ1xuICAgICAgICBcbiAgICAgICAgLy8gdXBkYWluZyB0aGUgdmFsdWUgaW4gdGhlIHRleHRhcmVhIFxuICAgICAgICAvL2pRdWVyeShcIiNzcGVjaWFsX21vZHVsZV91c2VyX3htbFwiKS52YWwoSlNPTi5zdHJpbmdpZnkodXNlcmFucykpOyAvLyBSZXBsYWNlZDtcblxuICAgICAgICBcbiAgICAgICAgLy9BSCgnc3BlY2lhbF9tb2R1bGVfdXNlcl94bWwnKS52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHVzZXJhbnMpO1xuXG4gICAgICAgIHVzZXJhbnNOZXcgPSBKU09OLnN0cmluZ2lmeSh1c2VyYW5zKTtcblxuICAgICAgICBkaXNwbGF5QW5zd2VyKCk7ICBcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIFRoaXMgZnVuY3Rpb24gZGlzcGxheSBhbnN3ZXIgd2V0aGVyIHRoZSBmdW5jdGlvbiBpcyBjb3JyZWN0IG9yIGluY29ycmVjdC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBmdW5jdGlvbiBkaXNwbGF5QW5zd2VyKCkge1xuICAgICAgICAvLyBjaGVjayB0aGUgYW5zXG4gICAgICAgIGxldCBhbnMgPSBjaGVja0FucygpO1xuICAgICAgICAvLyBtYXJrIHRoZSBhbnN3ZXIgY29ycmVjdCBvciBpbmNvcnJlY3QgeFxuICAgICAgICBhbnMgPSAoYW5zID09IDEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBpZiAodXhtbCkgIHtcbiAgICAgICAgICAgIEFILnNlbGVjdChcIiNhbnN3ZXJcIikuY2hlY2tlZCA9IGFuczsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yU3RhdGUpIHNob3dBbnMoKGFucykgPyBcIkNvcnJlY3RcIiA6IFwiSW5jb3JyZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIG9uVXNlckFuc0NoYW5nZSh7dVhtbDogdXNlcmFuc05ldywgYW5zOiBhbnN9KVxuICAgIH0gXG5cbiAgICAvLyBmdW5jdGlvbiBjaGVjayB0aGUgYW5zd2VyXG4gICAgZnVuY3Rpb24gY2hlY2tBbnMoKSB7XG4gICAgICAgIGxldCBpc19jb3JyZWN0ID0gMDtcbiAgICAgICAgbGV0IHRlbXAgPSAwOyAgXG4gICAgICAgIGxldCB0ZXN0X3JhZGlvX2FucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Rlc3RfcmFkaW8nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9MDsgaSA8IHRlc3RfcmFkaW9fYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVzdF9yYWRpb19hbnNbaV0uZ2V0QXR0cmlidXRlKCd2YWx1ZScpID09IHRlc3RfcmFkaW9fYW5zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3JyZWN0JykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdF9yYWRpb19hbnNbaV0uY2hlY2tlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RfcmFkaW9fYW5zW2ldLnNldEF0dHJpYnV0ZSgnYXMnLDEpO1xuICAgICAgICAgICAgICAgICAgICBpc19jb3JyZWN0ID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc19jb3JyZWN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGVzdF9yYWRpb19hbnNbaV0uc2V0QXR0cmlidXRlKCdhcycsMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgY2FsY3VsYXRpbmcgdGhlIHBvaW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdF9yYWRpb19hbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZXN0X3JhZGlvX2Fuc1tpXS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgPT0gdGVzdF9yYWRpb19hbnNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLWNvcnJlY3QnKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0X3JhZGlvX2Fuc1tpXS5jaGVja2VkID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsY3VsYXRlUG9pbnQgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBvaW50KHN0YXRlLnRvdGFsY29ycmVjdGFucywgdGVtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzX2NvcnJlY3Q7XG4gICAgfVxuXG4gICAgLy8gZm9yIHVzZXIgYXN3ZXIgdGFiXG4gICAgZnVuY3Rpb24geW91ckFuc3dlcigpIHtcbiAgICAgICAgcHJldmlld1VzZXJBbnMoKTtcbiAgICAgICAgLy8gZm9yIHNob3dpbmcgdGhlIGNvcnJlY3QvaW5jb3JyZWN0IGljb25cbiAgICAgICAgc2hvd0NvckluY29ySWNvbigpO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLyAgUHJldmlldyB0aGUgdXNlciBhbnN3ZXIgLy8vLy8vLy8vLy8vLy8vXG4gICAgZnVuY3Rpb24gcHJldmlld1VzZXJBbnMoKSB7XG4gICAgICAgIGxldCB0ZXN0X3JhZGlvX2xlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Rlc3RfcmFkaW8nKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgdGVzdF9yYWRpb19sZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHRlc3RfcmFkaW9fbGVuW2ldLmdldEF0dHJpYnV0ZSgnaWQnKT09dGVzdF9yYWRpb19sZW5baV0uZ2V0QXR0cmlidXRlKCdkYXRhLXVzZXJhbnMnKSkge1xuICAgICAgICAgICAgICAgIHRlc3RfcmFkaW9fbGVuW2ldLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXN0X3JhZGlvX2xlbltpXS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb3JyZWN0IGFuc3dlciB0YWJcbiAgICBmdW5jdGlvbiBjb3JyZWN0QW5zd2VyKCkge1xuICAgICAgICBwcmV2aWV3Q29ycmVjdEFucygpO1xuICAgICAgICAvLyBmb3Igc2hvd2luZyB0aGUgY29ycmVjdC9pbmNvcnJlY3QgaWNvblxuICAgICAgICBoaWRlQ29ySW5jb3JJY29uKCk7XG4gICAgfVxuXG4gICAgLy8gZm9yIHNob3dpbmcgY29ycmVjdCBhbnN3ZXJcbiAgICBmdW5jdGlvbiBwcmV2aWV3Q29ycmVjdEFucygpIHtcbiAgICAvKiAgICBqUXVlcnkobWFpbklkK1wiIC50ZXN0X3JhZGlvXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeSh0aGlzKS5hdHRyKCd2YWx1ZScpID09IGpRdWVyeSh0aGlzKS5hdHRyKCdkYXRhLWNvcnJlY3QnKSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKVswXS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpWzBdLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7ICAgLy9SZXBsYWNlZCAgICAgKi8gXG5cbiAgICAgICAgbGV0IHRlc3RfcmFkaW8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKChtYWluSWQrXCIgLnRlc3RfcmFkaW9cIikpO1xuICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHRlc3RfcmFkaW8ubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZih0ZXN0X3JhZGlvW2ldLmdldEF0dHJpYnV0ZSgndmFsdWUnKSA9PSB0ZXN0X3JhZGlvW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3JyZWN0JykpIHtcbiAgICAgICAgICAgICAgICB0ZXN0X3JhZGlvW2ldLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXN0X3JhZGlvW2ldLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICAvLy8vLy8vIFRoaXMgZnVuY3Rpb24gc2V0UmV2aWV3IG1vZGUgLy8vLy8vLy8vLy8vLy8gXG4gICAgZnVuY3Rpb24gbW9kZU9uKCkge1xuICAgICAgICBpc1JldmlldyA9IHRydWU7XHRcbiAgICAgICAgLy9qUXVlcnkobWFpbklkK1wiIC50ZXN0X3JhZGlvXCIpLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7IC8vIFJlcGxhY2VkXG4gICAgICAgIGxldCB0ZXN0X3JhZGlvID0gQUguc2VsZWN0QWxsKG1haW5JZCArIFwiIC50ZXN0X3JhZGlvXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RfcmFkaW8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlc3RfcmFkaW9baV0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHlvdXJBbnN3ZXIoKTtcbiAgICB9XG5cbiAgICAvLy8vLy8vIFRoaXMgZnVuY3Rpb24gdW5zZXRSZXZpZXcgbW9kZSAvLy8vLy8vLy8vLy8vLyAgXG4gICAgZnVuY3Rpb24gbW9kZU9mZigpIHtcbiAgICAgICAgaXNSZXZpZXcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRlc3RSYWRpb3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0ZXN0X3JhZGlvJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdFJhZGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVzdFJhZGlvc1tpXS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGhpZGVDb3JJbmNvckljb24oKTsgIFxuICAgICAgICAvL2pRdWVyeShcIi5kYmctc3VjY2VzcyBpbnB1dDpjaGVja2VkXCIpLnNpYmxpbmdzKFwiLmxhYmVsX2Nob2ljZVwiKS5hdHRyKFwidGl0bGVcIixcIlwiKTsgLy8gUmVwbGFjZWRcblxuICAgICAgICAvLyBBSC5zZWxlY3QoXCIuZGJnLXN1Y2Nlc3MgaW5wdXRcIixcImNoZWNrZWRcIikuZm9yRWFjaCgoX2VsbSk9PntcbiAgICAgICAgLy8gICAgIEFILnNpYmxpbmdzKF9lbG0sXCIubGFiZWxfY2hvaWNlXCIpLmZvckVhY2goKF9lKT0+e1xuICAgICAgICAvLyAgICAgICAgIF9lLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsXCJcIikgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gfSk7IEZpeFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8valF1ZXJ5KFwiLmRiZy1kYW5nZXIgaW5wdXQ6Y2hlY2tlZFwiKS5zaWJsaW5ncyhcIi5sYWJlbF9jaG9pY2VcIikuYXR0cihcInRpdGxlXCIsIFwiXCIpOyAvLyBSZXBsYWNlZFxuXG4gICAgICAgIC8vIEFILnNlbGVjdChcIi5kYmctZGFuZ2VyIGlucHV0OmNoZWNrZWRcIikuZm9yRWFjaCgoX2VsbSk9PntcbiAgICAgICAgLy8gICAgIEFILnNpYmxpbmdzKF9lbG0sXCIubGFiZWxfY2hvaWNlXCIpLmZvckVhY2goKF9lKT0+e1xuICAgICAgICAvLyAgICAgICAgIF9lLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsXCJcIikgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gfSk7IEZpeFxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gc2hvd2luZyBjb3JyZWN0IG9yIGluY29ycmVjdCBpY29uLy8vLy8vLy8vLy8vLy8vL1xuICAgIGZ1bmN0aW9uIHNob3dDb3JJbmNvckljb24oKSB7ICAgICBcbiAgICAgICAgLy9qUXVlcnkoXCIuZGJnLXN1Y2Nlc3MgaW5wdXQ6Y2hlY2tlZFwiKS5zaWJsaW5ncyhcIi5mYS1jaGVja1wiKS5jc3MoeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtZmxleFwiIH0pOyAvLyBSZXBsYWNlZFxuICAgICAgICAvLyBkZWJ1Z2dlcjtcbiAgICAgICAgQUguc2VsZWN0KFwiLmRiZy1zdWNjZXNzIGlucHV0XCIsIFwiY2hlY2tlZFwiKS5mb3JFYWNoKChfZWxtKT0+e1xuICAgICAgICAgICAgQUguc2libGluZ3MoX2VsbSwnLmZhLWNoZWNrJykuZm9yRWFjaCgoX2UpPT57XG4gICAgICAgICAgICAgICAgX2Uuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWZsZXhcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8valF1ZXJ5KFwiLmRiZy1kYW5nZXIgaW5wdXQ6Y2hlY2tlZFwiKS5zaWJsaW5ncyhcIi5mYS1jbG9zZVwiKS5jc3MoeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtZmxleFwiIH0pO1xuXG4gICAgICAgIEFILnNlbGVjdChcIi5kYmctZGFuZ2VyIGlucHV0XCIsIFwiY2hlY2tlZFwiKS5mb3JFYWNoKChfZWxtKT0+e1xuICAgICAgICAgICAgQUguc2libGluZ3MoX2VsbSwnLmZhLWNsb3NlJykuZm9yRWFjaCgoX2UpPT57XG4gICAgICAgICAgICAgICAgX2Uuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWZsZXhcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuXG5cbiAgICAgICAgQUguc2VsZWN0QWxsKCcuZGJnLXN1Y2Nlc3MgaW5wdXQsIC5kYmctZGFuZ2VyIGlucHV0JywgJ3JlbW92ZUF0dHInLCAnYXMnKTtcbiAgICAgICAgXG4gICAgICAgIC8valF1ZXJ5KFwiLmRiZy1zdWNjZXNzIGlucHV0OmNoZWNrZWRcIikuYXR0cihcImFzXCIsMSk7IC8vIFJlbW92ZWRcbiAgICAgICAgQUguc2VsZWN0KFwiLmRiZy1zdWNjZXNzIGlucHV0XCIsIFwiY2hlY2tlZFwiKS5mb3JFYWNoKChfc3VjY1JlbSk9PiB7XG4gICAgICAgICAgICBfc3VjY1JlbS5zZXRBdHRyaWJ1dGUoXCJhc1wiLCAxKTtcbiAgICAgICAgfSlcblxuICAgICAgICAvL2pRdWVyeShcIi5kYmctZGFuZ2VyIGlucHV0OmNoZWNrZWRcIikuYXR0cihcImFzXCIsIDApOyAvLyBSZW1vdmVkXG4gICAgICAgIFxuICAgICAgICBBSC5zZWxlY3QoXCIuZGJnLXN1Y2Nlc3MgaW5wdXRcIiwgXCJjaGVja2VkXCIpLmZvckVhY2goKF9kYW5nUmVtKT0+IHtcbiAgICAgICAgICAgIF9kYW5nUmVtLnNldEF0dHJpYnV0ZShcImFzXCIsIDApO1xuICAgICAgICB9KVxuXG4gICAgICAgICAgICAvL2pRdWVyeShcIi5kYmctc3VjY2VzcyBpbnB1dDpjaGVja2VkXCIpLnNpYmxpbmdzKFwiLmxhYmVsX2Nob2ljZVwiKS5hdHRyKFwidGl0bGVcIixcImlzIG1hcmtlZCBhcyBjb3JyZWN0XCIpO1xuICAgICAgICBBSC5zZWxlY3QoXCIuZGJnLXN1Y2Nlc3MgaW5wdXRcIixcImNoZWNrZWRcIikuZm9yRWFjaCgoX2VsbSk9PiB7XG4gICAgICAgICAgICBBSC5zaWJsaW5ncyhfZWxtLCcubGFiZWxfY2hvaWNlJykuZm9yRWFjaCgoX2UpPT4ge1xuICAgICAgICAgICAgICAgIF9lLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsXCJpcyBtYXJrZWQgYXMgY29ycmVjdFwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuXG4gICAgICAgIC8valF1ZXJ5KFwiLmRiZy1kYW5nZXIgaW5wdXQ6Y2hlY2tlZFwiKS5zaWJsaW5ncyhcIi5sYWJlbF9jaG9pY2VcIikuYXR0cihcInRpdGxlXCIsIFwiaXMgbWFya2VkIGFzIGluY29ycmVjdFwiKTtcbiAgICAgICAgQUguc2VsZWN0KFwiLmRiZy1kYW5nZXIgaW5wdXRcIixcImNoZWNrZWRcIikuZm9yRWFjaCgoX2VsbSk9PntcbiAgICAgICAgICAgIEFILnNpYmxpbmdzKF9lbG0sJy5sYWJlbF9jaG9pY2UnKS5mb3JFYWNoKChfZSk9PntcbiAgICAgICAgICAgICAgICBfZS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLFwiaXMgbWFya2VkIGFzIGluY29ycmVjdFwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vLy8vLy8gSGlkaW5nIGNvcnJlY3Qgb3IgaW5jb3JyZWN0IGFuc3dlciAvLy8vLy8vLy8vLy8vLy8vXG4gICAgZnVuY3Rpb24gaGlkZUNvckluY29ySWNvbigpIHtcbiAgICAgICAgXG4gICAgICAgIC8valF1ZXJ5KFwiLmZhLWNoZWNrXCIpOyAvLyBSZXBsYWNlZFxuICAgICAgICAgICAgLy9qUXVlcnkoXCIuZmEtY2xvc2VcIikuaGlkZSgpOyAvLyBSZXBsYWNlZFxuICAgICAgICBsZXQgaGlkZV9pY29uX2xlbmd0aCA9ICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmYS1jaGVjaycpO1xuICAgICAgICBsZXQgaGlkZV9pY29uX2xlbmd0aDEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmYS1jbG9zZScpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8aGlkZV9pY29uX2xlbmd0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaGlkZV9pY29uX2xlbmd0aFtpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgaGlkZV9pY29uX2xlbmd0aDFbaV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvciBzZXR0aW5nIHRoZSBpY29uIHN0eWxlXG4gICAgZnVuY3Rpb24gc2V0SWNvblN0eWxlKGllKSB7XG4gICAgICAgIGlmIChpZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4oe1xuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMTRweCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4oe1xuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OlwiMTVweFwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSk7IFxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vVG8gaGFuZGxlIHJldmlldyB0b2dnbGVcblx0ZnVuY3Rpb24gaGFuZGxlUmV2aWV3KG1vZGUsIGV2ZW50KSB7XG5cdFx0aWYgKG1vZGUgPT0gJ2MnKSB7XG5cdFx0XHRjb3JyZWN0QW5zd2VyKGV2ZW50KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR5b3VyQW5zd2VyKGV2ZW50KTtcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuPG1haW4+XG4gICAgPGRpdiBpZCA9IFwiY2hvaWNlbWFpblwiIHN0eWxlID0geydtYXJnaW4tYm90dG9tOjIwcHgnfT5cbiAgICAgICAgPEl0ZW1IZWxwZXJcbiAgICAgICAgICAgIG9uOnNldFJldmlldyA9IHtzZXRSZXZpZXd9XG4gICAgICAgICAgICBvbjp1bnNldFJldmlldyA9IHt1blNldFJldmlld31cbiAgICAgICAgICAgIGhhbmRsZVJldmlld0NsaWNrPXtoYW5kbGVSZXZpZXd9XG4gICAgICAgICAgICByZXZpZXdNb2RlPXtpc1Jldmlld31cbiAgICAgICAgLz5cbiAgICAgICAgPGNlbnRlcj5cbiAgICAgICAgICAgIDx0YWJsZSBjbGFzcyA9IHtcInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRlc3Rtb2RlX3RhYmxlIFwifSBpZD1cInRlc3RfdGFibGVcIiBzdHlsZT1cInsncG9zaXRpb246cmVsYXRpdmUsIG1hcmdpbi10b3A6MjBweCx3aWR0aDonK3N0YXRlLm1heFdpZHRoK1wicHhcIn19O2ZvbnQtZmFtaWx5OiBHZW9yZ2lhO1wiPlxuICAgICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzID0gXCJ0YWJsZS1oZWFkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IHtcInByZXZpZXdfaGVhZGVyIFwiICsgKChzdGF0ZS50aGVtZSAhPT0gXCJ0aGVtZTNcIikgPyBcInRleHQtY2VudGVyIHRleHQtd2hpdGVcIiA6IFwidGV4dC1jZW50ZXJcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXggPSB7MH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjp7dGhlbWVfY29sb3Jbc3RhdGUudGhlbWVdfSFpbXBvcnRhbnQ7XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgID57c3RhdGUuc3RlbS5yZXBsYWNlKC9cXG4vZ20sIFwiPC9icj5cIikucmVwbGFjZSgvI2NtL2dtLFwiLFwiKX08L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5jZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggc3RhdGUuY2RhdGEub3B0aW9uIGFzIGRhdGEsIGl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHtpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSB7XCJwcmV2aWV3X2hlYWRlciBhZGp1c3Rfd2lkdGggXCIgKyAoKHN0YXRlLnRoZW1lICE9PSBcInRoZW1lM1wiKSA/IGRhdGEuaWQgKyBcInRleHQtY2VudGVyIHRleHQtd2hpdGVcIiA6IGRhdGEuaWQgKyBcInRleHQtY2VudGVyXCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXggPSB7MH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gXCJiYWNrZ3JvdW5kLWNvbG9yOnt0aGVtZV9jb2xvcltzdGF0ZS50aGVtZV19IWltcG9ydGFudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID57ZGF0YS50ZXh0LnJlcGxhY2UoL1xcbi9nbSwgXCI8L2JyPlwiKS5yZXBsYWNlKC8jY20vZ20sXCIsXCIpfTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC90cj4gXG4gICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgY20uY2RhdGF9XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggY20uY2RhdGEudGVybSBhcyBkYXRhLGl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBrZXkgPSB7aX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSB7ZGF0YS5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmluZGV4ID0gezB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjp7KCgoaSAlIDIpID09IDApPyh0aGVtZV9jb2xvcl90ZXJtc1tzdGF0ZS50aGVtZV0pOiBcIiNGRkZcIil9IWltcG9ydGFudDtmb250LXNpemU6MTRwdDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Zm9udC1mYW1pbHk6e3N0YXRlLmZvbnR9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPntkYXRhLnRleHQucmVwbGFjZSgvXFxuL2dtLCBcIjwvYnI+XCIpLnJlcGxhY2UoLyNjbS9nbSxcIixcIil9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCBjbS5jZGF0YS5vcHRpb24gYXMgZGF0YTIsIGp9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHtqfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB7J3RiJyArIChpKSArIChqKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSB7XCJ0ZXh0LWNlbnRlciB0ZXN0X2FyZWEgXCIgKyAoKGRhdGEyLmlkID09IGRhdGEuY29ycmVjdCkgPyBcImRiZy1zdWNjZXNzXCIgOiBcImRiZy1kYW5nZXJcIil9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBcImJhY2tncm91bmQtY29sb3I6eygoKGkgJSAyKSA9PSAwKT8odGhlbWVfY29sb3JfdGVybXNbc3RhdGUudGhlbWVdKTogXCIjRkZGXCIpfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZhIGZhLWNoZWNrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbiA9IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7c2V0SWNvblN0eWxlKGlzSUUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaT4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiZmEgZmEtY2xvc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuID0gXCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHtzZXRJY29uU3R5bGUoaXNJRSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwicmFkaW9cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzID0gXCJ0ZXN0X3JhZGlvIENNUmFkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsndmVydGljYWwtYWxpZ246bWlkZGxlOyd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7ZGF0YTIuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHtcInRtXCIgKyAoaSArIDEpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0geyd0JyArIChpKSArIChqKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXRlcm1pZCA9IHtkYXRhLmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtY29ycmVjdCA9IHtkYXRhLmNvcnJlY3R9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS11c2VyYW5zID0gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0ge3NldFVzZXJBbnN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1yb2xlID0gXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJpbmRleCA9IHstMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXggPSB7MH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImxhYmVsX2Nob2ljZSBjdXN0b21SYWRDTSB7KChqICUgMiA9PSAwKSA/ICd0dXJlaXRlbUNvbG9yQ00nIDogJ2ZhbHNlaXRlbUNvbG9yQ00nKX1cIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3I9eyd0JyArIChpKSArIChqKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L2NlbnRlcj4gICAgICAgICAgICAgICBcbiAgICA8L2Rpdj5cbjwvbWFpbj5cbiAgICBcbjxzdHlsZT5cbiAgICA6Z2xvYmFsKC5mYS1jaGVjaykge1xuICAgICAgICBjb2xvcjogIzQ2QTU0NjtcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XG4gICAgICAgIGxlZnQ6NTBweDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5mYS1jbG9zZSkge1xuICAgICAgICBjb2xvcjogI0E4MDAwMDsgXG4gICAgICAgIGxlZnQ6NTBweDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5mYS1jbG9zZSwuZmEtY2hlY2spIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC0yNnB4OyBcbiAgICAgICAgZm9udC1zaXplOiAxOHB4OyBcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBib3R0b206IDEwcHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZmEtY2xvc2UsLmZhLWNoZWNrLC5taWRkbGVfYWxpZ24pIHtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZSFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgOmdsb2JhbCgubWlkZGxlX2FsaWduKSB7XG4gICAgICAgIHdpZHRoOiAxNjRweDtcbiAgICAgICAgbWluLXdpZHRoOiAxNjRweDtcbiAgICB9IFxuXG4gICAgOmdsb2JhbCgudG9waWNfaW5wdXQpIHtcbiAgICAgICAgbWluLXdpZHRoOiAyNTdweDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5wcmV2aWV3X2hlYWRlcikge1xuICAgICAgICBmb250LXNpemU6IDE2cHQ7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmFkanVzdF93aWR0aCkge1xuICAgICAgICB3aWR0aDogMTAlO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuXG48L3N0eWxlPiAgICJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFvakJZLFNBQVMsQUFBRSxDQUFDLEFBQ2hCLEtBQUssQ0FBRSxPQUFPLENBQ2QsU0FBUyxRQUFRLENBQ2pCLEtBQUssSUFBSSxBQUNiLENBQUMsQUFFTyxTQUFTLEFBQUUsQ0FBQyxBQUNoQixLQUFLLENBQUUsT0FBTyxDQUNkLEtBQUssSUFBSSxBQUNiLENBQUMsQUFFTyxtQkFBbUIsQUFBRSxDQUFDLEFBQzFCLFdBQVcsQ0FBRSxLQUFLLENBQ2xCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVPLGlDQUFpQyxBQUFFLENBQUMsQUFDeEMsY0FBYyxDQUFFLE1BQU0sVUFBVSxBQUNwQyxDQUFDLEFBRU8sYUFBYSxBQUFFLENBQUMsQUFDcEIsS0FBSyxDQUFFLEtBQUssQ0FDWixTQUFTLENBQUUsS0FBSyxBQUNwQixDQUFDLEFBRU8sWUFBWSxBQUFFLENBQUMsQUFDbkIsU0FBUyxDQUFFLEtBQUssQUFDcEIsQ0FBQyxBQUVPLGVBQWUsQUFBRSxDQUFDLEFBQ3RCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLElBQUksQ0FDakIsY0FBYyxDQUFFLE1BQU0sQUFDMUIsQ0FBQyxBQUVPLGFBQWEsQUFBRSxDQUFDLEFBQ3BCLEtBQUssQ0FBRSxHQUFHLENBQ1YsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyJ9 */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	child_ctx[33] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

// (493:24) {#if state.cdata}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value_2 = /*state*/ ctx[2].cdata.option;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, theme_color*/ 20) {
				each_value_2 = /*state*/ ctx[2].cdata.option;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(493:24) {#if state.cdata}",
		ctx
	});

	return block;
}

// (494:28) {#each state.cdata.option as data, i}
function create_each_block_2(ctx) {
	let th;
	let t_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t;
	let th_key_value;
	let th_class_value;
	let th_tabindex_value;

	const block = {
		c: function create() {
			th = element("th");
			t = text(t_value);
			attr_dev(th, "key", th_key_value = /*i*/ ctx[30]);

			attr_dev(th, "class", th_class_value = "preview_header adjust_width " + (/*state*/ ctx[2].theme !== "theme3"
			? /*data*/ ctx[28].id + "text-center text-white"
			: /*data*/ ctx[28].id + "text-center"));

			attr_dev(th, "tabindex", th_tabindex_value = 0);
			set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			add_location(th, file, 494, 32, 16927);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4 && t_value !== (t_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*state*/ 4 && th_class_value !== (th_class_value = "preview_header adjust_width " + (/*state*/ ctx[2].theme !== "theme3"
			? /*data*/ ctx[28].id + "text-center text-white"
			: /*data*/ ctx[28].id + "text-center"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(494:28) {#each state.cdata.option as data, i}",
		ctx
	});

	return block;
}

// (506:20) {#if cm.cdata}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*cm*/ ctx[1].cdata.term;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm, theme_color_terms, state, setUserAns, isIE*/ 302) {
				each_value = /*cm*/ ctx[1].cdata.term;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(506:20) {#if cm.cdata}",
		ctx
	});

	return block;
}

// (515:32) {#each cm.cdata.option as data2, j}
function create_each_block_1(ctx) {
	let td;
	let i0;
	let i0_style_value;
	let t0;
	let i1;
	let i1_style_value;
	let t1;
	let input;
	let input_style_value;
	let input_value_value;
	let input_name_value;
	let input_id_value;
	let input_data_termid_value;
	let input_data_correct_value;
	let input_tabindex_value;
	let t2;
	let label;
	let label_tabindex_value;
	let label_class_value;
	let label_for_value;
	let td_key_value;
	let td_id_value;
	let td_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			i0 = element("i");
			t0 = space();
			i1 = element("i");
			t1 = space();
			input = element("input");
			t2 = space();
			label = element("label");
			attr_dev(i0, "class", "fa fa-check");
			attr_dev(i0, "aria-hidden", "true");
			attr_dev(i0, "style", i0_style_value = setIconStyle(/*isIE*/ ctx[3]));
			add_location(i0, file, 522, 36, 18712);
			attr_dev(i1, "class", "fa fa-close");
			attr_dev(i1, "aria-hidden", "true");
			attr_dev(i1, "style", i1_style_value = setIconStyle(/*isIE*/ ctx[3]));
			add_location(i1, file, 527, 36, 18987);
			attr_dev(input, "type", "radio");
			attr_dev(input, "class", "test_radio CMRad");
			attr_dev(input, "style", input_style_value = "vertical-align:middle;");
			input.value = input_value_value = /*data2*/ ctx[31].id;
			attr_dev(input, "name", input_name_value = "tm" + (/*i*/ ctx[30] + 1));
			attr_dev(input, "id", input_id_value = "t" + /*i*/ ctx[30] + /*j*/ ctx[33]);
			attr_dev(input, "data-termid", input_data_termid_value = /*data*/ ctx[28].id);
			attr_dev(input, "data-correct", input_data_correct_value = /*data*/ ctx[28].correct);
			attr_dev(input, "data-userans", "");
			attr_dev(input, "data-role", "none");
			attr_dev(input, "tabindex", input_tabindex_value = -1);
			add_location(input, file, 532, 36, 19260);
			attr_dev(label, "tabindex", label_tabindex_value = 0);

			attr_dev(label, "class", label_class_value = "label_choice customRadCM " + (/*j*/ ctx[33] % 2 == 0
			? "tureitemColorCM"
			: "falseitemColorCM"));

			attr_dev(label, "for", label_for_value = "t" + /*i*/ ctx[30] + /*j*/ ctx[33]);
			add_location(label, file, 546, 36, 20096);
			attr_dev(td, "key", td_key_value = /*j*/ ctx[33]);
			attr_dev(td, "id", td_id_value = "tb" + /*i*/ ctx[30] + /*j*/ ctx[33]);

			attr_dev(td, "class", td_class_value = "text-center test_area " + (/*data2*/ ctx[31].id == /*data*/ ctx[28].correct
			? "dbg-success"
			: "dbg-danger"));

			set_style(td, "background-color", /*i*/ ctx[30] % 2 == 0
			? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
			: "#FFF");

			add_location(td, file, 515, 32, 18238);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, i0);
			append_dev(td, t0);
			append_dev(td, i1);
			append_dev(td, t1);
			append_dev(td, input);
			append_dev(td, t2);
			append_dev(td, label);

			if (!mounted) {
				dispose = listen_dev(input, "click", /*setUserAns*/ ctx[8], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm*/ 2 && input_value_value !== (input_value_value = /*data2*/ ctx[31].id)) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*cm*/ 2 && input_data_termid_value !== (input_data_termid_value = /*data*/ ctx[28].id)) {
				attr_dev(input, "data-termid", input_data_termid_value);
			}

			if (dirty[0] & /*cm*/ 2 && input_data_correct_value !== (input_data_correct_value = /*data*/ ctx[28].correct)) {
				attr_dev(input, "data-correct", input_data_correct_value);
			}

			if (dirty[0] & /*cm*/ 2 && td_class_value !== (td_class_value = "text-center test_area " + (/*data2*/ ctx[31].id == /*data*/ ctx[28].correct
			? "dbg-success"
			: "dbg-danger"))) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(td, "background-color", /*i*/ ctx[30] % 2 == 0
				? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
				: "#FFF");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(515:32) {#each cm.cdata.option as data2, j}",
		ctx
	});

	return block;
}

// (507:24) {#each cm.cdata.term as data,i}
function create_each_block(ctx) {
	let tr;
	let td;
	let t0_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t0;
	let td_class_value;
	let td_tabindex_value;
	let t1;
	let t2;
	let tr_key_value;
	let each_value_1 = /*cm*/ ctx[1].cdata.option;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");
			td = element("td");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			attr_dev(td, "class", td_class_value = /*data*/ ctx[28].id);
			attr_dev(td, "tabindex", td_tabindex_value = 0);

			set_style(
				td,
				"background-color",
				/*i*/ ctx[30] % 2 == 0
				? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
				: "#FFF",
				1
			);

			set_style(td, "font-size", "14pt");
			set_style(td, "vertical-align", "middle");
			set_style(td, "font-family", /*state*/ ctx[2].font);
			add_location(td, file, 508, 32, 17704);
			attr_dev(tr, "key", tr_key_value = /*i*/ ctx[30]);
			add_location(tr, file, 507, 28, 17657);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			append_dev(td, t0);
			append_dev(tr, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm*/ 2 && t0_value !== (t0_value = /*data*/ ctx[28].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*cm*/ 2 && td_class_value !== (td_class_value = /*data*/ ctx[28].id)) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(
					td,
					"background-color",
					/*i*/ ctx[30] % 2 == 0
					? /*theme_color_terms*/ ctx[5][/*state*/ ctx[2].theme]
					: "#FFF",
					1
				);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(td, "font-family", /*state*/ ctx[2].font);
			}

			if (dirty[0] & /*cm, theme_color_terms, state, setUserAns, isIE*/ 302) {
				each_value_1 = /*cm*/ ctx[1].cdata.option;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(507:24) {#each cm.cdata.term as data,i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div;
	let itemhelper;
	let t0;
	let center;
	let table;
	let thead;
	let tr;
	let th;
	let t1_value = /*state*/ ctx[2].stem.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t1;
	let th_class_value;
	let th_tabindex_value;
	let t2;
	let t3;
	let tbody;
	let table_class_value;
	let table_style_value;
	let div_style_value;
	let current;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[9],
				reviewMode: /*isReview*/ ctx[0]
			},
			$$inline: true
		});

	itemhelper.$on("setReview", /*setReview*/ ctx[6]);
	itemhelper.$on("unsetReview", /*unSetReview*/ ctx[7]);
	let if_block0 = /*state*/ ctx[2].cdata && create_if_block_1(ctx);
	let if_block1 = /*cm*/ ctx[1].cdata && create_if_block(ctx);

	const block = {
		c: function create() {
			main = element("main");
			div = element("div");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			center = element("center");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th = element("th");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			tbody = element("tbody");
			if (if_block1) if_block1.c();

			attr_dev(th, "class", th_class_value = "preview_header " + (/*state*/ ctx[2].theme !== "theme3"
			? "text-center text-white"
			: "text-center"));

			attr_dev(th, "tabindex", th_tabindex_value = 0);
			set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			add_location(th, file, 486, 24, 16398);
			attr_dev(tr, "class", "table-head");
			add_location(tr, file, 485, 20, 16348);
			add_location(thead, file, 484, 16, 16320);
			add_location(tbody, file, 504, 16, 17529);
			attr_dev(table, "class", table_class_value = "table table-bordered testmode_table ");
			attr_dev(table, "id", "test_table");
			attr_dev(table, "style", table_style_value = "" + ("position:relative, margin-top:20px,width:" + /*state*/ ctx[2].maxWidth + "px" + "};font-family: Georgia;"));
			add_location(table, file, 483, 12, 16134);
			add_location(center, file, 482, 8, 16113);
			attr_dev(div, "id", "choicemain");
			attr_dev(div, "style", div_style_value = "margin-bottom:20px");
			add_location(div, file, 475, 4, 15858);
			add_location(main, file, 474, 0, 15847);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div);
			mount_component(itemhelper, div, null);
			append_dev(div, t0);
			append_dev(div, center);
			append_dev(center, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th);
			append_dev(th, t1);
			append_dev(tr, t2);
			if (if_block0) if_block0.m(tr, null);
			append_dev(table, t3);
			append_dev(table, tbody);
			if (if_block1) if_block1.m(tbody, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);
			if ((!current || dirty[0] & /*state*/ 4) && t1_value !== (t1_value = /*state*/ ctx[2].stem.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t1, t1_value);

			if (!current || dirty[0] & /*state*/ 4 && th_class_value !== (th_class_value = "preview_header " + (/*state*/ ctx[2].theme !== "theme3"
			? "text-center text-white"
			: "text-center"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (!current || dirty[0] & /*state*/ 4) {
				set_style(th, "background-color", /*theme_color*/ ctx[4][/*state*/ ctx[2].theme], 1);
			}

			if (/*state*/ ctx[2].cdata) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(tr, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*cm*/ ctx[1].cdata) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(tbody, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty[0] & /*state*/ 4 && table_style_value !== (table_style_value = "" + ("position:relative, margin-top:20px,width:" + /*state*/ ctx[2].maxWidth + "px" + "};font-family: Georgia;"))) {
				attr_dev(table, "style", table_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(itemhelper);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function previewUserAns() {
	let test_radio_len = document.getElementsByClassName("test_radio");

	for (let i = 0; i < test_radio_len.length; i++) {
		if (test_radio_len[i].getAttribute("id") == test_radio_len[i].getAttribute("data-userans")) {
			test_radio_len[i].checked = true;
		} else {
			test_radio_len[i].checked = false;
		}
	}
}

/////// Hiding correct or incorrect answer ////////////////
function hideCorIncorIcon() {
	//jQuery(".fa-check"); // Replaced
	//jQuery(".fa-close").hide(); // Replaced
	let hide_icon_length = document.getElementsByClassName("fa-check");

	let hide_icon_length1 = document.getElementsByClassName("fa-close");

	for (let i = 0; i < hide_icon_length.length; i++) {
		hide_icon_length[i].style.display = "none";
		hide_icon_length1[i].style.display = "none";
	}
}

// for setting the icon style
function setIconStyle(ie) {
	if (ie == true) {
		return {
			paddingLeft: "14px",
			display: "inline-flex",
			position: "absolute"
		};
	} else {
		return {
			paddingLeft: "15px",
			display: "none",
			position: "absolute"
		};
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ChoiceMatrixPreview", slots, []);
	let { showAns } = $$props;
	let { editorState } = $$props;
	let { xml } = $$props;
	let { uxml } = $$props;
	let { isReview } = $$props;
	let useransNew;
	let cm = { cdata: "" };
	let isIE;
	let mainId = "";
	let state = {};

	let stateData = writable({
		cdata: "",
		stem: "",
		xml: "",
		theme: "",
		font: "",
		maxWidth: "",
		totalcorrectans: ""
	});

	let theme_color = {
		theme1: "#5B9BD5",
		theme2: "#3B67BC",
		theme3: "#F6C3A2",
		theme4: "#70AD47",
		theme5: "#745998"
	};

	let theme_color_terms = {
		theme1: "#DEEAF6",
		theme2: "#D4DEF1",
		theme3: "#FAE0CF",
		theme4: "#E2EFD9",
		theme5: "#E1DAE9"
	};

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(2, state = items);
	});

	///////  XML change then automatically reload code ///////////////
	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(2, state.xml = xml, state);
			loadModule(xml, uxml);
		}
	});

	// function for checking the focus
	/*    function checkFocus(list){
        let is_focus = false;
        jQuery(".choiceMatrixRender").find("."+list).each(function() {
            if(jQuery(this).is(":focus")) {
                is_focus = true;
                return false;
            }
        });
        return is_focus;
    }  */
	afterUpdate(() => {
		if (!isReview) hideCorIncorIcon();
	});

	onMount(() => {
		// Check the radio when press the Enter Key ADA
		AI.listen("body", "keydown", ".label_choice", function (_this, e) {
			if (e.which === 13) {
				_this.click();
			}
		});
	});

	function setReview() {
		modeOn();
	}

	function unSetReview() {
		previewUserAns();
		modeOff();
	}

	/////////////// Loding the xml and uaXML ///////////////////
	function loadModule(loadXml, uaXML) {
		loadXml = XMLToJSON(loadXml);
		parseXMLPreview(loadXml, uaXML);
	}

	///////// FUnction parsing the xml ////////////////////////
	function parseXMLPreview(MYXML, uaXML) {
		// setting state of theme, font, maxwidth
		$$invalidate(2, state.theme = MYXML.smxml._theme, state);

		$$invalidate(2, state.font = MYXML.smxml._font, state);
		$$invalidate(2, state.maxWidth = MYXML.smxml._maxwidth ? MYXML.smxml._maxwidth : 800, state);
		let formattedData = parseCSV.parseCSVFormat(MYXML.smxml.__cdata);
		let cdata = formattedData;
		let rawData = [];

		// copy cdata into rawData////// 
		/* jQuery.map(cdata, function (value, index) {
    rawData[index] = value;
});   Replaced     */
		rawData = JSON.parse(JSON.stringify(cdata));

		$$invalidate(2, state.cdata = rawData, state);
		$$invalidate(2, state.stem = rawData.stem, state);
		$$invalidate(1, cm.cdata = rawData, cm);
		let len = cm.cdata.term.length;
		$$invalidate(2, state.totalcorrectans = len, state);
		modeOff();

		// User anser checking/////////
		if (uaXML) {
			try {
				// parsing the json data
				uaXML = JSON.parse(uaXML);

				let rawUaXML = [];

				// storing uaXML in rawUaXML and storing its value
				/*    jQuery.map(uaXML, function (value, index) {
        rawUaXML[index] = value;
    }); replaced   */
				rawUaXML = JSON.parse(JSON.stringify(uaXML));

				//    setting the data-userans on the basis of ans
				setTimeout(
					function () {
						rawUaXML.ans.map(function (data, i) {
							//alert("#"+data.userAns);
							//jQuery(".test_area").find("#"+data.userAns).attr("data-userans",data.userAns);
							AH.selectAll(".test_area" + " #" + data.userAns, "attr", { "data-userans": data.userAns });
						});

						previewUserAns();
					},
					100
				);
			} catch(e) {
				
			} // let datauser;
			//uaXML = "";
		} else {
			// if is not user ans then unchecked all the radio btn
			/*    jQuery(".test_radio").each(function () {
        jQuery(this)[0].checked = false;
        jQuery(this).attr('data-userans',"");
    })  */
			let test_radio_len = document.getElementsByClassName("test_radio");

			for (let i = 0; i < test_radio_len.length; i++) {
				test_radio_len[i].checked = false;
				test_radio_len[i].setAttribute("data-userans", "");
			}
		}
	}

	///////////  Storing the user answer whenever clicked////////////////
	function setUserAns(e) {
		let id = e.target.id;
		let name = e.target.name;

		// set the user ans blank
		//    jQuery(mainId+" .test_area input[name=" + name + "]").attr("data-userans", ""); Replaced
		let test_area_input = document.querySelectorAll(mainId + " .test_area input[name=" + name + "]");

		for (let i = 0; i < test_area_input.length; i++) {
			test_area_input[i].setAttribute("data-userans", "");
		}

		// setting the data-userans on which user is clicked
		//jQuery(mainId+" .test_area").find("#" + id + "").attr("data-userans", id);// Replaced
		AH.selectAll(mainId + " .test_area" + " #" + id + "", "attr", { "data-userans": id });

		let userans = { "type": "34", "ans": [] };

		/////////// updating the user ans /////////////////////////
		/* jQuery(mainId+" .test_radio").each(function () {
    if (jQuery(this)[0].checked == true) {
        userans.ans.push({
            id: jQuery(this).attr("data-termid"),
            userAns: jQuery(this).attr("id")
        });
    }
});*/
		let test_radio = document.getElementsByClassName("test_radio");

		for (let i = 0; i < test_radio.length; i++) {
			if (test_radio[i].checked == true) {
				userans.ans.push({
					id: test_radio[i].getAttribute("data-termid"),
					userAns: test_radio[i].getAttribute("id")
				});
			}
		}

		// for autograding
		// updaing the value in the textarea 
		//jQuery("#special_module_user_xml").val(JSON.stringify(userans)); // Replaced;
		//AH('special_module_user_xml').value = JSON.stringify(userans);
		useransNew = JSON.stringify(userans);

		displayAnswer();
	}

	///////////////////////// This function display answer wether the function is correct or incorrect///////////////////
	function displayAnswer() {
		// check the ans
		let ans = checkAns();

		// mark the answer correct or incorrect x
		ans = ans == 1 ? true : false;

		if (uxml) {
			AH.select("#answer").checked = ans;
		} else {
			if (editorState) showAns(ans ? "Correct" : "Incorrect");
		}

		onUserAnsChange({ uXml: useransNew, ans });
	}

	// function check the answer
	function checkAns() {
		let is_correct = 0;
		let temp = 0;
		let test_radio_ans = document.getElementsByClassName("test_radio");

		for (let i = 0; i < test_radio_ans.length; i++) {
			if (test_radio_ans[i].getAttribute("value") == test_radio_ans[i].getAttribute("data-correct")) {
				if (test_radio_ans[i].checked == true) {
					test_radio_ans[i].setAttribute("as", 1);
					is_correct = 1;
				} else {
					is_correct = 0;
					test_radio_ans[i].setAttribute("as", 0);
					return false;
				}
			}
		}

		// for calculating the point
		for (let i = 0; i < test_radio_ans.length; i++) {
			if (test_radio_ans[i].getAttribute("value") == test_radio_ans[i].getAttribute("data-correct")) {
				if (test_radio_ans[i].checked == true) {
					temp++;
				}
			}

			if (typeof calculatePoint != "undefined") {
				calculatePoint(state.totalcorrectans, temp);
			}
		}

		return is_correct;
	}

	// for user aswer tab
	function yourAnswer() {
		previewUserAns();

		// for showing the correct/incorrect icon
		showCorIncorIcon();
	}

	// correct answer tab
	function correctAnswer() {
		previewCorrectAns();

		// for showing the correct/incorrect icon
		hideCorIncorIcon();
	}

	// for showing correct answer
	function previewCorrectAns() {
		/*jQuery(mainId+" .test_radio").each(function () {
        if (jQuery(this).attr('value') == jQuery(this).attr('data-correct')) {
            jQuery(this)[0].checked = true;
        } else {
            jQuery(this)[0].checked = false;
        }
    });   //Replaced     */
		let test_radio = document.querySelectorAll(mainId + " .test_radio");

		for (let i = 0; i < test_radio.length; i++) {
			if (test_radio[i].getAttribute("value") == test_radio[i].getAttribute("data-correct")) {
				test_radio[i].checked = true;
			} else {
				test_radio[i].checked = false;
			}
		}
	}

	/////// This function setReview mode ////////////// 
	function modeOn() {
		$$invalidate(0, isReview = true);

		//jQuery(mainId+" .test_radio").attr('disabled', true); // Replaced
		let test_radio = AH.selectAll(mainId + " .test_radio");

		for (let i = 0; i < test_radio.length; i++) {
			test_radio[i].disabled = true;
		}

		yourAnswer();
	}

	/////// This function unsetReview mode //////////////  
	function modeOff() {
		$$invalidate(0, isReview = false);
		let testRadios = document.getElementsByClassName("test_radio");

		for (let i = 0; i < testRadios.length; i++) {
			testRadios[i].disabled = false;
		}

		hideCorIncorIcon();
	} //jQuery(".dbg-success input:checked").siblings(".label_choice").attr("title",""); // Replaced
	// AH.select(".dbg-success input","checked").forEach((_elm)=>{

	//     AH.siblings(_elm,".label_choice").forEach((_e)=>{
	//         _e.setAttribute("title","")                    
	//     })
	// }); Fix
	//jQuery(".dbg-danger input:checked").siblings(".label_choice").attr("title", ""); // Replaced
	// AH.select(".dbg-danger input:checked").forEach((_elm)=>{
	//     AH.siblings(_elm,".label_choice").forEach((_e)=>{
	//         _e.setAttribute("title","")                    
	//     })
	// }); Fix
	// This function showing correct or incorrect icon////////////////
	function showCorIncorIcon() {
		//jQuery(".dbg-success input:checked").siblings(".fa-check").css({ "display": "inline-flex" }); // Replaced
		// debugger;
		AH.select(".dbg-success input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".fa-check").forEach(_e => {
				_e.style.display = "inline-flex";
			});
		});

		//jQuery(".dbg-danger input:checked").siblings(".fa-close").css({ "display": "inline-flex" });
		AH.select(".dbg-danger input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".fa-close").forEach(_e => {
				_e.style.display = "inline-flex";
			});
		});

		AH.selectAll(".dbg-success input, .dbg-danger input", "removeAttr", "as");

		//jQuery(".dbg-success input:checked").attr("as",1); // Removed
		AH.select(".dbg-success input", "checked").forEach(_succRem => {
			_succRem.setAttribute("as", 1);
		});

		//jQuery(".dbg-danger input:checked").attr("as", 0); // Removed
		AH.select(".dbg-success input", "checked").forEach(_dangRem => {
			_dangRem.setAttribute("as", 0);
		});

		//jQuery(".dbg-success input:checked").siblings(".label_choice").attr("title","is marked as correct");
		AH.select(".dbg-success input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".label_choice").forEach(_e => {
				_e.setAttribute("title", "is marked as correct");
			});
		});

		//jQuery(".dbg-danger input:checked").siblings(".label_choice").attr("title", "is marked as incorrect");
		AH.select(".dbg-danger input", "checked").forEach(_elm => {
			AH.siblings(_elm, ".label_choice").forEach(_e => {
				_e.setAttribute("title", "is marked as incorrect");
			});
		});
	}

	//To handle review toggle
	function handleReview(mode, event) {
		if (mode == "c") {
			correctAnswer();
		} else {
			yourAnswer();
		}
	}

	const writable_props = ["showAns", "editorState", "xml", "uxml", "isReview"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChoiceMatrixPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("showAns" in $$props) $$invalidate(10, showAns = $$props.showAns);
		if ("editorState" in $$props) $$invalidate(11, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(12, xml = $$props.xml);
		if ("uxml" in $$props) $$invalidate(13, uxml = $$props.uxml);
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
	};

	$$self.$capture_state = () => ({
		lib: parseCSV,
		onMount,
		beforeUpdate,
		afterUpdate,
		AH,
		XMLToJSON,
		onUserAnsChange,
		writable,
		ItemHelper,
		showAns,
		editorState,
		xml,
		uxml,
		isReview,
		useransNew,
		cm,
		isIE,
		mainId,
		state,
		stateData,
		theme_color,
		theme_color_terms,
		unsubscribe,
		setReview,
		unSetReview,
		loadModule,
		parseXMLPreview,
		setUserAns,
		displayAnswer,
		checkAns,
		yourAnswer,
		previewUserAns,
		correctAnswer,
		previewCorrectAns,
		modeOn,
		modeOff,
		showCorIncorIcon,
		hideCorIncorIcon,
		setIconStyle,
		handleReview
	});

	$$self.$inject_state = $$props => {
		if ("showAns" in $$props) $$invalidate(10, showAns = $$props.showAns);
		if ("editorState" in $$props) $$invalidate(11, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(12, xml = $$props.xml);
		if ("uxml" in $$props) $$invalidate(13, uxml = $$props.uxml);
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("useransNew" in $$props) useransNew = $$props.useransNew;
		if ("cm" in $$props) $$invalidate(1, cm = $$props.cm);
		if ("isIE" in $$props) $$invalidate(3, isIE = $$props.isIE);
		if ("mainId" in $$props) mainId = $$props.mainId;
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("theme_color" in $$props) $$invalidate(4, theme_color = $$props.theme_color);
		if ("theme_color_terms" in $$props) $$invalidate(5, theme_color_terms = $$props.theme_color_terms);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isReview*/ 1) {
			 if (isReview) {
				// this condition will true in test area
				modeOn();
			} else {
				previewUserAns();
				modeOff();
			}
		}
	};

	return [
		isReview,
		cm,
		state,
		isIE,
		theme_color,
		theme_color_terms,
		setReview,
		unSetReview,
		setUserAns,
		handleReview,
		showAns,
		editorState,
		xml,
		uxml
	];
}

class ChoiceMatrixPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-qkuer1-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				showAns: 10,
				editorState: 11,
				xml: 12,
				uxml: 13,
				isReview: 0
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChoiceMatrixPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*showAns*/ ctx[10] === undefined && !("showAns" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'showAns'");
		}

		if (/*editorState*/ ctx[11] === undefined && !("editorState" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'editorState'");
		}

		if (/*xml*/ ctx[12] === undefined && !("xml" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'xml'");
		}

		if (/*uxml*/ ctx[13] === undefined && !("uxml" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'uxml'");
		}

		if (/*isReview*/ ctx[0] === undefined && !("isReview" in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'isReview'");
		}
	}

	get showAns() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isReview() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ChoiceMatrixPreview;
//# sourceMappingURL=ChoiceMatrixPreview-81296295.js.map
