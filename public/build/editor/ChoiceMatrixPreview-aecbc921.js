
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, J as append_styles, v as validate_slots, I as beforeUpdate, a8 as afterUpdate, o as onMount, X as XMLToJSON, A as AH, a2 as onUserAnsChange, w as writable, C as validate_each_argument, z as empty, n as insert_dev, H as destroy_each, x as detach_dev, e as element, h as text, j as attr_dev, a3 as null_to_empty, k as add_location, p as append_dev, E as set_data_dev, f as space, l as set_style, c as create_component, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, q as listen_dev, F as prop_dev } from './main-f02a5770.js';
import { I as ItemHelper } from './ItemHelper-27ff9c2b.js';
import { l as lib } from './parseCSV-66f989c1.js';

/* clsSMChoiceMatrix\ChoiceMatrixPreview.svelte generated by Svelte v3.40.2 */
const file = "clsSMChoiceMatrix\\ChoiceMatrixPreview.svelte";

function add_css(target) {
	append_styles(target, "svelte-xi3muu", ".fa-close{margin-left:20px;font-size:18px;position:absolute;top:10px;color:#A80000}.fa-check{margin-left:20px;font-size:18px;position:absolute;top:10px;color:#46A546}.fa-close,.fa-check.svelte-xi3muu.svelte-xi3muu,.middle_align.svelte-xi3muu.svelte-xi3muu{vertical-align:middle!important}.middle_align{width:164px;min-width:164px}.topic_input{min-width:257px}.preview_header{font-size:16pt;font-weight:bold;vertical-align:middle}.adjust_width{width:10%;text-align:center}.table.svelte-xi3muu>.svelte-xi3muu:not(:first-child){border-top:1px solid}.theme_color_theme1.svelte-xi3muu.svelte-xi3muu{background-color:#5B9BD5!important}.theme_color_theme2.svelte-xi3muu.svelte-xi3muu{background-color:#3B67BC!important}.theme_color_theme3.svelte-xi3muu.svelte-xi3muu{background-color:#F6C3A2!important}.theme_color_theme4.svelte-xi3muu.svelte-xi3muu{background-color:#70AD47!important}.theme_color_theme5.svelte-xi3muu.svelte-xi3muu{background-color:#745998!important}.theme_color_terms_theme1.svelte-xi3muu.svelte-xi3muu{background-color:#DEEAF6}.theme_color_terms_theme2.svelte-xi3muu.svelte-xi3muu{background-color:#D4DEF1}.theme_color_terms_theme3.svelte-xi3muu.svelte-xi3muu{background-color:#FAE0CF}.theme_color_terms_theme4.svelte-xi3muu.svelte-xi3muu{background-color:#E2EFD9}.theme_color_terms_theme5.svelte-xi3muu.svelte-xi3muu{background-color:#E1DAE9}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hvaWNlTWF0cml4UHJldmlldy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK2NZLFNBQVMsQUFBRSxDQUFDLEFBQ2hCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLElBQUksQ0FDVCxLQUFLLENBQUUsT0FBTyxBQUNsQixDQUFDLEFBQ08sU0FBUyxBQUFFLENBQUMsQUFDaEIsV0FBVyxDQUFFLElBQUksQ0FDakIsU0FBUyxDQUFFLElBQUksQ0FDZixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsSUFBSSxDQUNULEtBQUssQ0FBRSxPQUFPLEFBQ2xCLENBQUMsQUFDTyxTQUFTLEFBQUMsQ0FBRSxxQ0FBUyxDQUFDLGFBQWEsNEJBQUMsQ0FBQyxBQUN6QyxjQUFjLENBQUUsTUFBTSxVQUFVLEFBQ3BDLENBQUMsQUFDTyxhQUFhLEFBQUUsQ0FBQyxBQUNwQixLQUFLLENBQUUsS0FBSyxDQUNaLFNBQVMsQ0FBRSxLQUFLLEFBQ3BCLENBQUMsQUFDTyxZQUFZLEFBQUUsQ0FBQyxBQUNuQixTQUFTLENBQUUsS0FBSyxBQUNwQixDQUFDLEFBQ08sZUFBZSxBQUFFLENBQUMsQUFDdEIsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsSUFBSSxDQUNqQixjQUFjLENBQUUsTUFBTSxBQUMxQixDQUFDLEFBQ08sYUFBYSxBQUFFLENBQUMsQUFDcEIsS0FBSyxDQUFFLEdBQUcsQ0FDVixVQUFVLENBQUUsTUFBTSxBQUN0QixDQUFDLEFBRUQsb0JBQU0sZUFBQyxLQUFLLFlBQVksQ0FBQyxBQUFDLENBQUMsQUFDdkIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLEFBQ3pCLENBQUMsQUFDRCxtQkFBbUIsNEJBQUMsQ0FBQyxBQUNqQixnQkFBZ0IsQ0FBRSxPQUFPLFVBQVUsQUFDdkMsQ0FBQyxBQUNELG1CQUFtQiw0QkFBQyxDQUFDLEFBQ2pCLGdCQUFnQixDQUFFLE9BQU8sVUFBVSxBQUN2QyxDQUFDLEFBQ0QsbUJBQW1CLDRCQUFDLENBQUMsQUFDakIsZ0JBQWdCLENBQUUsT0FBTyxVQUFVLEFBQ3ZDLENBQUMsQUFDRCxtQkFBbUIsNEJBQUMsQ0FBQyxBQUNqQixnQkFBZ0IsQ0FBRSxPQUFPLFVBQVUsQUFDdkMsQ0FBQyxBQUNELG1CQUFtQiw0QkFBQyxDQUFDLEFBQ2pCLGdCQUFnQixDQUFFLE9BQU8sVUFBVSxBQUN2QyxDQUFDLEFBQ0QseUJBQXlCLDRCQUFDLENBQUMsQUFDdkIsZ0JBQWdCLENBQUUsT0FBTyxBQUM3QixDQUFDLEFBQ0QseUJBQXlCLDRCQUFDLENBQUMsQUFDdkIsZ0JBQWdCLENBQUUsT0FBTyxBQUM3QixDQUFDLEFBQ0QseUJBQXlCLDRCQUFDLENBQUMsQUFDdkIsZ0JBQWdCLENBQUUsT0FBTyxBQUM3QixDQUFDLEFBQ0QseUJBQXlCLDRCQUFDLENBQUMsQUFDdkIsZ0JBQWdCLENBQUUsT0FBTyxBQUM3QixDQUFDLEFBQ0QseUJBQXlCLDRCQUFDLENBQUMsQUFDdkIsZ0JBQWdCLENBQUUsT0FBTyxBQUM3QixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNob2ljZU1hdHJpeFByZXZpZXcuc3ZlbHRlIl19 */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[36] = list[i];
	child_ctx[38] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

// (394:20) {#if state.cdata}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value_2 = /*state*/ ctx[2].cdata.option;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*theme_color, state*/ 36) {
				each_value_2 = /*state*/ ctx[2].cdata.option;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(394:20) {#if state.cdata}",
		ctx
	});

	return block;
}

// (395:24) {#each state.cdata.option as data, i}
function create_each_block_2(ctx) {
	let th;
	let t_value = /*data*/ ctx[33].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t;
	let th_key_value;
	let th_class_value;
	let th_tabindex_value;

	const block = {
		c: function create() {
			th = element("th");
			t = text(t_value);
			attr_dev(th, "key", th_key_value = /*i*/ ctx[35]);

			attr_dev(th, "class", th_class_value = "" + (null_to_empty((/*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#5B9BD5'
			? 'theme_color_theme1'
			: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#3B67BC'
				? 'theme_color_theme2'
				: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#F6C3A2'
					? 'theme_color_theme3'
					: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#70AD47'
						? 'theme_color_theme4'
						: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#745998'
							? 'theme_color_theme5'
							: '') + " preview_header adjust_width " + (/*state*/ ctx[2].theme !== "theme3"
			? /*data*/ ctx[33].id + "text-center text-white"
			: /*data*/ ctx[33].id + "text-center")) + " svelte-xi3muu"));

			attr_dev(th, "tabindex", th_tabindex_value = 0);
			add_location(th, file, 395, 28, 14036);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4 && t_value !== (t_value = /*data*/ ctx[33].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*state*/ 4 && th_class_value !== (th_class_value = "" + (null_to_empty((/*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#5B9BD5'
			? 'theme_color_theme1'
			: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#3B67BC'
				? 'theme_color_theme2'
				: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#F6C3A2'
					? 'theme_color_theme3'
					: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#70AD47'
						? 'theme_color_theme4'
						: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#745998'
							? 'theme_color_theme5'
							: '') + " preview_header adjust_width " + (/*state*/ ctx[2].theme !== "theme3"
			? /*data*/ ctx[33].id + "text-center text-white"
			: /*data*/ ctx[33].id + "text-center")) + " svelte-xi3muu"))) {
				attr_dev(th, "class", th_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(395:24) {#each state.cdata.option as data, i}",
		ctx
	});

	return block;
}

// (406:16) {#if cm.cdata}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*cm*/ ctx[1].cdata.term;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm, theme_color_terms, state, setUserAns, isIE*/ 598) {
				each_value = /*cm*/ ctx[1].cdata.term;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(406:16) {#if cm.cdata}",
		ctx
	});

	return block;
}

// (416:28) {#each cm.cdata.option as data2, j}
function create_each_block_1(ctx) {
	let td;
	let i0;
	let i0_style_value;
	let t0;
	let i1;
	let i1_style_value;
	let t1;
	let input;
	let input_style_value;
	let input_value_value;
	let input_name_value;
	let input_id_value;
	let input_data_termid_value;
	let input_data_correct_value;
	let input_tabindex_value;
	let t2;
	let label;
	let label_tabindex_value;
	let label_class_value;
	let label_for_value;
	let td_key_value;
	let td_id_value;
	let td_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			i0 = element("i");
			t0 = space();
			i1 = element("i");
			t1 = space();
			input = element("input");
			t2 = space();
			label = element("label");
			attr_dev(i0, "class", "fa fa-check svelte-xi3muu");
			attr_dev(i0, "aria-hidden", "true");
			attr_dev(i0, "style", i0_style_value = setIconStyle(/*isIE*/ ctx[4]));
			add_location(i0, file, 423, 32, 16777);
			attr_dev(i1, "class", "fa fa-close svelte-xi3muu");
			attr_dev(i1, "aria-hidden", "true");
			attr_dev(i1, "style", i1_style_value = setIconStyle(/*isIE*/ ctx[4]));
			add_location(i1, file, 428, 32, 17037);
			attr_dev(input, "type", "radio");
			attr_dev(input, "class", "test_radio CMRad svelte-xi3muu");
			attr_dev(input, "style", input_style_value = 'vertical-align:middle;');
			input.value = input_value_value = /*data2*/ ctx[36].id;
			attr_dev(input, "name", input_name_value = "tm" + (/*i*/ ctx[35] + 1));
			attr_dev(input, "id", input_id_value = 't' + /*i*/ ctx[35] + /*j*/ ctx[38]);
			attr_dev(input, "data-termid", input_data_termid_value = /*data*/ ctx[33].id);
			attr_dev(input, "data-correct", input_data_correct_value = /*data*/ ctx[33].correct);
			attr_dev(input, "data-userans", "");
			attr_dev(input, "data-role", "none");
			attr_dev(input, "tabindex", input_tabindex_value = -1);
			add_location(input, file, 433, 32, 17295);
			attr_dev(label, "tabindex", label_tabindex_value = 0);

			attr_dev(label, "class", label_class_value = "label_choice customRadCM " + (/*j*/ ctx[38] % 2 == 0
			? 'tureitemColorCM'
			: 'falseitemColorCM') + " svelte-xi3muu");

			attr_dev(label, "for", label_for_value = 't' + /*i*/ ctx[35] + /*j*/ ctx[38]);
			add_location(label, file, 447, 32, 18089);
			attr_dev(td, "key", td_key_value = /*j*/ ctx[38]);
			attr_dev(td, "id", td_id_value = 'tb' + /*i*/ ctx[35] + /*j*/ ctx[38]);

			attr_dev(td, "class", td_class_value = "" + (null_to_empty((/*i*/ ctx[35] % 2 == 0
			? /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#DEEAF6'
				? 'theme_color_terms_theme1'
				: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#D4DEF1'
					? 'theme_color_terms_theme2'
					: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#FAE0CF'
						? 'theme_color_terms_theme3'
						: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E2EFD9'
							? 'theme_color_terms_theme4'
							: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E1DAE9'
								? 'theme_color_terms_theme5'
								: '#FFF'
			: '#FFF') + " " + "text-center test_area" + (/*data2*/ ctx[36].id == /*data*/ ctx[33].correct
			? ' dbg-success'
			: ' dbg-danger') + ' position-relative') + " svelte-xi3muu"));

			add_location(td, file, 416, 28, 15944);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, i0);
			append_dev(td, t0);
			append_dev(td, i1);
			append_dev(td, t1);
			append_dev(td, input);
			append_dev(td, t2);
			append_dev(td, label);

			if (!mounted) {
				dispose = listen_dev(input, "click", /*setUserAns*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm*/ 2 && input_value_value !== (input_value_value = /*data2*/ ctx[36].id)) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*cm*/ 2 && input_data_termid_value !== (input_data_termid_value = /*data*/ ctx[33].id)) {
				attr_dev(input, "data-termid", input_data_termid_value);
			}

			if (dirty[0] & /*cm*/ 2 && input_data_correct_value !== (input_data_correct_value = /*data*/ ctx[33].correct)) {
				attr_dev(input, "data-correct", input_data_correct_value);
			}

			if (dirty[0] & /*state, cm*/ 6 && td_class_value !== (td_class_value = "" + (null_to_empty((/*i*/ ctx[35] % 2 == 0
			? /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#DEEAF6'
				? 'theme_color_terms_theme1'
				: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#D4DEF1'
					? 'theme_color_terms_theme2'
					: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#FAE0CF'
						? 'theme_color_terms_theme3'
						: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E2EFD9'
							? 'theme_color_terms_theme4'
							: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E1DAE9'
								? 'theme_color_terms_theme5'
								: '#FFF'
			: '#FFF') + " " + "text-center test_area" + (/*data2*/ ctx[36].id == /*data*/ ctx[33].correct
			? ' dbg-success'
			: ' dbg-danger') + ' position-relative') + " svelte-xi3muu"))) {
				attr_dev(td, "class", td_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(416:28) {#each cm.cdata.option as data2, j}",
		ctx
	});

	return block;
}

// (407:20) {#each cm.cdata.term as data,i}
function create_each_block(ctx) {
	let tr;
	let td;
	let raw_value = /*data*/ ctx[33].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let td_class_value;
	let td_tabindex_value;
	let t0;
	let t1;
	let tr_key_value;
	let each_value_1 = /*cm*/ ctx[1].cdata.option;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");
			td = element("td");
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();

			attr_dev(td, "class", td_class_value = "" + (null_to_empty((/*i*/ ctx[35] % 2 == 0
			? /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#DEEAF6'
				? 'theme_color_terms_theme1'
				: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#D4DEF1'
					? 'theme_color_terms_theme2'
					: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#FAE0CF'
						? 'theme_color_terms_theme3'
						: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E2EFD9'
							? 'theme_color_terms_theme4'
							: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E1DAE9'
								? 'theme_color_terms_theme5'
								: '#FFF'
			: '#FFF') + " " + /*data*/ ctx[33].id + " position-relative") + " svelte-xi3muu"));

			attr_dev(td, "tabindex", td_tabindex_value = 0);
			set_style(td, "font-size", "14pt");
			set_style(td, "vertical-align", "middle");
			set_style(td, "font-family", /*state*/ ctx[2].font);
			add_location(td, file, 408, 28, 15018);
			attr_dev(tr, "key", tr_key_value = /*i*/ ctx[35]);
			add_location(tr, file, 407, 24, 14974);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			td.innerHTML = raw_value;
			append_dev(tr, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*cm*/ 2 && raw_value !== (raw_value = /*data*/ ctx[33].text.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) td.innerHTML = raw_value;
			if (dirty[0] & /*state, cm*/ 6 && td_class_value !== (td_class_value = "" + (null_to_empty((/*i*/ ctx[35] % 2 == 0
			? /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#DEEAF6'
				? 'theme_color_terms_theme1'
				: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#D4DEF1'
					? 'theme_color_terms_theme2'
					: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#FAE0CF'
						? 'theme_color_terms_theme3'
						: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E2EFD9'
							? 'theme_color_terms_theme4'
							: /*theme_color_terms*/ ctx[6][/*state*/ ctx[2].theme] == '#E1DAE9'
								? 'theme_color_terms_theme5'
								: '#FFF'
			: '#FFF') + " " + /*data*/ ctx[33].id + " position-relative") + " svelte-xi3muu"))) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 4) {
				set_style(td, "font-family", /*state*/ ctx[2].font);
			}

			if (dirty[0] & /*theme_color_terms, state, cm, setUserAns, isIE*/ 598) {
				each_value_1 = /*cm*/ ctx[1].cdata.option;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t1);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(407:20) {#each cm.cdata.term as data,i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let itemhelper;
	let t0;
	let center;
	let table;
	let thead;
	let tr;
	let th;
	let t1_value = /*state*/ ctx[2].stem.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "";
	let t1;
	let th_class_value;
	let th_tabindex_value;
	let t2;
	let t3;
	let tbody;
	let table_class_value;
	let table_style_value;
	let div_style_value;
	let current;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[10],
				reviewMode: /*isReview*/ ctx[0],
				customReviewMode: /*customIsReview*/ ctx[3]
			},
			$$inline: true
		});

	itemhelper.$on("setReview", /*setReview*/ ctx[7]);
	itemhelper.$on("unsetReview", /*unSetReview*/ ctx[8]);
	let if_block0 = /*state*/ ctx[2].cdata && create_if_block_1(ctx);
	let if_block1 = /*cm*/ ctx[1].cdata && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			center = element("center");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th = element("th");
			t1 = text(t1_value);
			t2 = space();
			if (if_block0) if_block0.c();
			t3 = space();
			tbody = element("tbody");
			if (if_block1) if_block1.c();

			attr_dev(th, "class", th_class_value = "" + (null_to_empty((/*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#5B9BD5'
			? 'theme_color_theme1'
			: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#3B67BC'
				? 'theme_color_theme2'
				: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#F6C3A2'
					? 'theme_color_theme3'
					: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#70AD47'
						? 'theme_color_theme4'
						: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#745998'
							? 'theme_color_theme5'
							: '') + " preview_header " + (/*state*/ ctx[2].theme !== "theme3"
			? "text-center text-white"
			: " text-center")) + " svelte-xi3muu"));

			attr_dev(th, "tabindex", th_tabindex_value = 0);
			add_location(th, file, 388, 20, 13279);
			attr_dev(tr, "class", "table-head");
			add_location(tr, file, 387, 16, 13232);
			attr_dev(thead, "class", "svelte-xi3muu");
			add_location(thead, file, 386, 12, 13207);
			attr_dev(tbody, "class", "svelte-xi3muu");
			add_location(tbody, file, 404, 12, 14855);
			attr_dev(table, "class", table_class_value = "" + (null_to_empty("table testmode_table ") + " svelte-xi3muu"));
			attr_dev(table, "id", "test_table");
			attr_dev(table, "style", table_style_value = "" + ('position:relative; margin-top:20px;width:' + /*state*/ ctx[2].maxWidth + "px" + ";font-family: Georgia;"));
			add_location(table, file, 385, 8, 13040);
			add_location(center, file, 384, 4, 13022);
			attr_dev(div, "class", "mainAdaArea");
			attr_dev(div, "id", "choicemain");
			attr_dev(div, "style", div_style_value = 'margin-bottom:20px');
			add_location(div, file, 376, 0, 12727);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(itemhelper, div, null);
			append_dev(div, t0);
			append_dev(div, center);
			append_dev(center, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th);
			append_dev(th, t1);
			append_dev(tr, t2);
			if (if_block0) if_block0.m(tr, null);
			append_dev(table, t3);
			append_dev(table, tbody);
			if (if_block1) if_block1.m(tbody, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);
			if ((!current || dirty[0] & /*state*/ 4) && t1_value !== (t1_value = /*state*/ ctx[2].stem.replace(/\n/gm, "</br>").replace(/#cm/gm, ",") + "")) set_data_dev(t1, t1_value);

			if (!current || dirty[0] & /*state*/ 4 && th_class_value !== (th_class_value = "" + (null_to_empty((/*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#5B9BD5'
			? 'theme_color_theme1'
			: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#3B67BC'
				? 'theme_color_theme2'
				: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#F6C3A2'
					? 'theme_color_theme3'
					: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#70AD47'
						? 'theme_color_theme4'
						: /*theme_color*/ ctx[5][/*state*/ ctx[2].theme] == '#745998'
							? 'theme_color_theme5'
							: '') + " preview_header " + (/*state*/ ctx[2].theme !== "theme3"
			? "text-center text-white"
			: " text-center")) + " svelte-xi3muu"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (/*state*/ ctx[2].cdata) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(tr, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*cm*/ ctx[1].cdata) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(tbody, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty[0] & /*state*/ 4 && table_style_value !== (table_style_value = "" + ('position:relative; margin-top:20px;width:' + /*state*/ ctx[2].maxWidth + "px" + ";font-family: Georgia;"))) {
				attr_dev(table, "style", table_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(itemhelper);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function previewUserAns() {
	let test_radio_len = document.getElementsByClassName('test_radio');

	for (let i = 0; i < test_radio_len.length; i++) {
		if (test_radio_len[i].getAttribute('id') == test_radio_len[i].getAttribute('data-userans')) {
			test_radio_len[i].checked = true;
		} else {
			test_radio_len[i].checked = false;
		}
	}
}

/////// Hiding correct or incorrect answer ////////////////
function hideCorIncorIcon() {
	let hide_icon_length = document.getElementsByClassName('fa-check');
	let hide_icon_length1 = document.getElementsByClassName('fa-close');

	for (let i = 0; i < hide_icon_length.length; i++) {
		hide_icon_length[i].style.display = 'none';
		hide_icon_length1[i].style.display = 'none';
	}
}

// for setting the icon style
function setIconStyle(ie) {
	if (ie == true) {
		return {
			paddingLeft: '14px',
			display: 'inline-flex',
			position: 'absolute'
		};
	} else {
		return {
			paddingLeft: "15px",
			display: 'none',
			position: 'absolute'
		};
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChoiceMatrixPreview', slots, []);
	let { showAns } = $$props;
	let { editorState } = $$props;
	let { xml } = $$props;
	let { uxml } = $$props;
	let { isReview } = $$props;
	let { CM } = $$props;
	let useransNew;
	let customIsReview = isReview;
	let preReview = isReview;
	let cm = { cdata: "" };
	let isIE;
	let mainId = "";
	let state = {};
	let ansDisable = 0;

	let stateData = writable({
		cdata: "",
		stem: "",
		xml: "",
		theme: "",
		font: "",
		maxWidth: "",
		totalcorrectans: ""
	});

	let theme_color = {
		theme1: '#5B9BD5',
		theme2: '#3B67BC',
		theme3: '#F6C3A2',
		theme4: '#70AD47',
		theme5: '#745998'
	};

	let theme_color_terms = {
		theme1: '#DEEAF6',
		theme2: '#D4DEF1',
		theme3: '#FAE0CF',
		theme4: '#E2EFD9',
		theme5: '#E1DAE9'
	};

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(2, state = items);
	});

	///////  XML change then automatically reload code ///////////////
	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(2, state.xml = xml, state);
			loadModule(xml, uxml);
		}
	});

	afterUpdate(() => {
		disableItem(customIsReview);

		if (!isReview) {
			hideCorIncorIcon();
		}

		if (customIsReview) {
			setTimeout(
				function () {
					showCorIncorIcon();
				},
				300
			);
		}
	});

	onMount(() => {
		// Check the radio when press the Enter Key ADA
		AI.listen('body', 'keydown', '.label_choice', function (_this, e) {
			if (e.which === 13) {
				_this.click();
			}
		});
	});

	function setReview() {
		modeOn();
	}

	function unSetReview() {
		previewUserAns();
		modeOff();
	}

	/////////////// Loding the xml and uaXML ///////////////////
	function loadModule(loadXml, uaXML) {
		loadXml = XMLToJSON(loadXml);
		parseXMLPreview(loadXml, uaXML);
	}

	///////// FUnction parsing the xml ////////////////////////
	function parseXMLPreview(MYXML, uaXML) {
		// setting state of theme, font, maxwidth
		$$invalidate(2, state.theme = MYXML.smxml._theme, state);

		$$invalidate(2, state.font = MYXML.smxml._font, state);
		$$invalidate(2, state.maxWidth = MYXML.smxml._maxwidth ? MYXML.smxml._maxwidth : 800, state);
		let formattedData = lib.parseCSVFormat(MYXML.smxml.__cdata);
		let cdata = formattedData;
		let rawData = [];
		rawData = JSON.parse(JSON.stringify(cdata));
		$$invalidate(2, state.cdata = rawData, state);
		$$invalidate(2, state.stem = rawData.stem, state);
		$$invalidate(1, cm.cdata = rawData, cm);
		let len = cm.cdata.term.length;
		$$invalidate(2, state.totalcorrectans = len, state);
		modeOff();

		// User anser checking/////////
		if (uaXML) {
			try {
				// parsing the json data
				uaXML = JSON.parse(uaXML);

				let rawUaXML = [];

				// storing uaXML in rawUaXML and storing its value
				rawUaXML = JSON.parse(JSON.stringify(uaXML));

				//    setting the data-userans on the basis of ans
				setTimeout(
					function () {
						rawUaXML.ans.map(function (data, i) {
							AH.selectAll(".test_area" + " #" + data.userAns, 'attr', { "data-userans": data.userAns });
						});

						previewUserAns();
					},
					100
				);
			} catch(e) {
				
			} // for showing the userans , that is the answer which is marked by the user
			//uaXML = "";
		} else {
			// if is not user ans then unchecked all the radio btn
			let test_radio_len = document.getElementsByClassName('test_radio');

			for (let i = 0; i < test_radio_len.length; i++) {
				test_radio_len[i].checked = false;
				test_radio_len[i].setAttribute('data-userans', "");
			}
		}
	}

	///////////  Storing the user answer whenever clicked////////////////
	function setUserAns(e) {
		let id = e.target.id;
		let name = e.target.name;

		// set the user ans blank
		let test_area_input = document.querySelectorAll(mainId + " .test_area input[name=" + name + "]");

		for (let i = 0; i < test_area_input.length; i++) {
			test_area_input[i].setAttribute("data-userans", "");
		}

		// setting the data-userans on which user is clicked
		AH.selectAll(mainId + " .test_area" + " #" + id + "", 'attr', { "data-userans": id });

		let userans = { "type": "34", "ans": [] };

		/////////// updating the user ans /////////////////////////
		let test_radio = document.getElementsByClassName('test_radio');

		for (let i = 0; i < test_radio.length; i++) {
			if (test_radio[i].checked == true) {
				userans.ans.push({
					id: test_radio[i].getAttribute("data-termid"),
					userAns: test_radio[i].getAttribute("id")
				});
			}
		}

		useransNew = JSON.stringify(userans);
		displayAnswer();
	}

	///////////////////////// This function display answer wether the function is correct or incorrect///////////////////
	function displayAnswer() {
		// check the ans
		let ans = checkAns();

		// mark the answer correct or incorrect x
		ans = ans == 1 ? true : false;

		if (uxml) {
			AH.select("#answer").checked = ans;
		} else {
			if (editorState) showAns(ans ? "Correct" : "Incorrect");
		}

		onUserAnsChange({ uXml: useransNew, ans });
	}

	// function check the answer
	function checkAns() {
		let is_correct = 0;
		let temp = 0;
		let test_radio_ans = document.getElementsByClassName('test_radio');

		for (let i = 0; i < test_radio_ans.length; i++) {
			if (test_radio_ans[i].getAttribute('value') == test_radio_ans[i].getAttribute('data-correct')) {
				if (test_radio_ans[i].checked == true) {
					test_radio_ans[i].setAttribute('as', 1);
					is_correct = 1;
				} else {
					is_correct = 0;
					test_radio_ans[i].setAttribute('as', 0);
					return false;
				}
			}
		}

		// for calculating the point
		for (let i = 0; i < test_radio_ans.length; i++) {
			if (test_radio_ans[i].getAttribute('value') == test_radio_ans[i].getAttribute('data-correct')) {
				if (test_radio_ans[i].checked == true) {
					temp++;
				}
			}

			if (typeof calculatePoint != "undefined") {
				calculatePoint(state.totalcorrectans, temp);
			}
		}

		return is_correct;
	}

	// for user aswer tab
	function yourAnswer() {
		previewUserAns();

		// for showing the correct/incorrect icon
		showCorIncorIcon();
	}

	// correct answer tab
	function correctAnswer() {
		previewCorrectAns();

		// for showing the correct/incorrect icon
		hideCorIncorIcon();
	}

	// for showing correct answer
	function previewCorrectAns() {
		let test_radio = document.querySelectorAll(mainId + " .test_radio");

		for (let i = 0; i < test_radio.length; i++) {
			if (test_radio[i].getAttribute('value') == test_radio[i].getAttribute('data-correct')) {
				test_radio[i].checked = true;
			} else {
				test_radio[i].checked = false;
			}
		}
	}

	/////// This function setReview mode ////////////// 
	function modeOn() {
		$$invalidate(0, isReview = true);
		disableItem(isReview);
		yourAnswer();
	}

	/////// This function unsetReview mode //////////////  
	function modeOff() {
		$$invalidate(0, isReview = false);
		let testRadios = document.getElementsByClassName('test_radio');

		for (let i = 0; i < testRadios.length; i++) {
			testRadios[i].disabled = false;
		}

		hideCorIncorIcon();
	}

	// Function to disable the item in case of review Mode: on click submit button, or from review mode lab opened.
	function disableItem(is_review) {
		if (is_review) {
			let mainID = '#main-' + CM;
			let test_radio = AH.selectAll(mainID + " .test_radio");

			for (let i = 0; i < test_radio.length; i++) {
				test_radio[i].disabled = true;
			}
		}
	}

	// This function showing correct or incorrect icon////////////////
	function showCorIncorIcon() {
		AH.select(".dbg-success input", "checked").forEach(_elm => {
			AH.siblings(_elm, '.fa-check').forEach(_e => {
				_e.style.display = "inline-flex";
			});
		});

		AH.select(".dbg-danger input", "checked").forEach(_elm => {
			AH.siblings(_elm, '.fa-close').forEach(_e => {
				_e.style.display = "inline-flex";
			});
		});

		AH.selectAll('.dbg-success input, .dbg-danger input', 'removeAttr', 'as');

		AH.select(".dbg-success input", "checked").forEach(_succRem => {
			_succRem.setAttribute("as", 1);
		});

		AH.select(".dbg-success input", "checked").forEach(_dangRem => {
			_dangRem.setAttribute("as", 0);
		});

		AH.select(".dbg-success input", "checked").forEach(_elm => {
			AH.siblings(_elm, '.label_choice').forEach(_e => {
				_e.setAttribute("title", "is marked as correct");
			});
		});

		AH.select(".dbg-danger input", "checked").forEach(_elm => {
			AH.siblings(_elm, '.label_choice').forEach(_e => {
				_e.setAttribute("title", "is marked as incorrect");
			});
		});
	}

	//To handle review toggle
	function handleReview(mode, event) {
		if (mode == 'c') {
			correctAnswer();
		} else {
			yourAnswer();
		}
	}

	const writable_props = ['showAns', 'editorState', 'xml', 'uxml', 'isReview', 'CM'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChoiceMatrixPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('showAns' in $$props) $$invalidate(11, showAns = $$props.showAns);
		if ('editorState' in $$props) $$invalidate(12, editorState = $$props.editorState);
		if ('xml' in $$props) $$invalidate(13, xml = $$props.xml);
		if ('uxml' in $$props) $$invalidate(14, uxml = $$props.uxml);
		if ('isReview' in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ('CM' in $$props) $$invalidate(15, CM = $$props.CM);
	};

	$$self.$capture_state = () => ({
		lib,
		onMount,
		beforeUpdate,
		afterUpdate,
		AH,
		XMLToJSON,
		onUserAnsChange,
		writable,
		ItemHelper,
		showAns,
		editorState,
		xml,
		uxml,
		isReview,
		CM,
		useransNew,
		customIsReview,
		preReview,
		cm,
		isIE,
		mainId,
		state,
		ansDisable,
		stateData,
		theme_color,
		theme_color_terms,
		unsubscribe,
		setReview,
		unSetReview,
		loadModule,
		parseXMLPreview,
		setUserAns,
		displayAnswer,
		checkAns,
		yourAnswer,
		previewUserAns,
		correctAnswer,
		previewCorrectAns,
		modeOn,
		modeOff,
		disableItem,
		showCorIncorIcon,
		hideCorIncorIcon,
		setIconStyle,
		handleReview
	});

	$$self.$inject_state = $$props => {
		if ('showAns' in $$props) $$invalidate(11, showAns = $$props.showAns);
		if ('editorState' in $$props) $$invalidate(12, editorState = $$props.editorState);
		if ('xml' in $$props) $$invalidate(13, xml = $$props.xml);
		if ('uxml' in $$props) $$invalidate(14, uxml = $$props.uxml);
		if ('isReview' in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ('CM' in $$props) $$invalidate(15, CM = $$props.CM);
		if ('useransNew' in $$props) useransNew = $$props.useransNew;
		if ('customIsReview' in $$props) $$invalidate(3, customIsReview = $$props.customIsReview);
		if ('preReview' in $$props) $$invalidate(16, preReview = $$props.preReview);
		if ('cm' in $$props) $$invalidate(1, cm = $$props.cm);
		if ('isIE' in $$props) $$invalidate(4, isIE = $$props.isIE);
		if ('mainId' in $$props) mainId = $$props.mainId;
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
		if ('ansDisable' in $$props) $$invalidate(17, ansDisable = $$props.ansDisable);
		if ('stateData' in $$props) stateData = $$props.stateData;
		if ('theme_color' in $$props) $$invalidate(5, theme_color = $$props.theme_color);
		if ('theme_color_terms' in $$props) $$invalidate(6, theme_color_terms = $$props.theme_color_terms);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*preReview, isReview, editorState, ansDisable*/ 200705) {
			 {
				if (preReview != isReview) {
					if (isReview) {
						// this condition will true in test area
						modeOn();

						if (editorState && ansDisable == 0) {
							$$invalidate(17, ansDisable = 1);
							displayAnswer();
						}
					} else {
						$$invalidate(17, ansDisable = 0);
						previewUserAns();
						modeOff();
					}

					$$invalidate(16, preReview = isReview);
				}
			}
		}
	};

	return [
		isReview,
		cm,
		state,
		customIsReview,
		isIE,
		theme_color,
		theme_color_terms,
		setReview,
		unSetReview,
		setUserAns,
		handleReview,
		showAns,
		editorState,
		xml,
		uxml,
		CM,
		preReview,
		ansDisable
	];
}

class ChoiceMatrixPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				showAns: 11,
				editorState: 12,
				xml: 13,
				uxml: 14,
				isReview: 0,
				CM: 15
			},
			add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChoiceMatrixPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*showAns*/ ctx[11] === undefined && !('showAns' in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'showAns'");
		}

		if (/*editorState*/ ctx[12] === undefined && !('editorState' in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'editorState'");
		}

		if (/*xml*/ ctx[13] === undefined && !('xml' in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'xml'");
		}

		if (/*uxml*/ ctx[14] === undefined && !('uxml' in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'uxml'");
		}

		if (/*isReview*/ ctx[0] === undefined && !('isReview' in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'isReview'");
		}

		if (/*CM*/ ctx[15] === undefined && !('CM' in props)) {
			console.warn("<ChoiceMatrixPreview> was created without expected prop 'CM'");
		}
	}

	get showAns() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isReview() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get CM() {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set CM(value) {
		throw new Error("<ChoiceMatrixPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ChoiceMatrixPreview;
//# sourceMappingURL=ChoiceMatrixPreview-aecbc921.js.map
