
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, V as Checkbox, C as validate_each_argument, U as Button, O as Dialog, P as binding_callbacks, Q as bind, v as validate_slots, o as onMount, X as XMLToJSON, A as AH, L as beforeUpdate, w as writable, y as language, M as JSONToXML, h as text, f as space, j as attr_dev, k as add_location, n as insert_dev, q as listen_dev, G as prop_dev, r as group_outros, a as transition_out, u as check_outros, t as transition_in, x as detach_dev, H as run_all, c as create_component, m as mount_component, W as add_flush_callback, b as destroy_component, K as destroy_each, B as noop, $ as null_to_empty } from './main-b83e0690.js';

/* clsSMStepAlgo\StepAlgo.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMStepAlgo\\StepAlgo.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-smsdwz-style";
	style.textContent = ".font18.svelte-smsdwz{font-size:16px}.fwidth.svelte-smsdwz{width:100%}.light-cyan-bg.svelte-smsdwz{background-color:#d4e4ff;color:#333}.top2.svelte-smsdwz{top:2px}.right5.svelte-smsdwz{right:5px}.right35.svelte-smsdwz{right:35px}.step_checkbox.svelte-smsdwz{width:22%;border:1px solid black;margin-left:10px;position:relative;bottom:1px;cursor:pointer;padding:3px 2px 0}.fixed_ans.svelte-smsdwz{top:10px;position:relative;float:right;border:1px solid #e0e0e0;background-color:#f5f5f5;border-radius:4px;padding:5px;font-size:15px;font-weight:700}.check_box.svelte-smsdwz{right:24px;position:relative;width:40px}.inner_inputs.svelte-smsdwz{margin:0 12px!important}.pointer.svelte-smsdwz{cursor:pointer !important}.width100.svelte-smsdwz{width:100px}[id^=\"fillmain\"]{overflow:hidden;text-align:left}[id^=\"fillmain\"] pre{background:none;border:none;font-size:14px!important}[id^=\"fillmain\"] .string{min-height:50px;margin-top:10px;margin-right:10px}[id^=\"fillmain\"] .footerstr{position:relative;margin-top:10px;background-color:#ccc;padding:15px;min-height:60px}[id^=\"fillmain\"] .footerstr .arrow-up{position:absolute;top:-10px;right:50%;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:10px solid #ccc}[id^=\"fillmain\"] .fill-row{padding:6px}[id^=\"fillmain\"] .fillelement, [id^=\"fillmain\"] .drag-resize{height:30px;display:inline-block;position:relative;min-height:30px;margin:1px}[id^=\"fillmain\"] input[type=\"text\"], [id^=\"fillmain\"] select{height:99%!important;resize:none;font-size:12px;color:#000;max-width:800px}[id^=\"fillmain\"] .drag-resize{vertical-align:middle;border:1px solid #31B731;text-align:center;padding:3px;font-size:14px}[id^=\"fillmain\"] .drag-resize.ui-draggable{cursor:move}[id^=\"fillmain\"] .drop-hover{border:1px dashed red!important;box-shadow:0 0 0 2px yellow inset;outline:1px solid blue}[id^=\"fillmain\"] .fillcheck ul{width:220px}[id^=\"fillmain\"] .fillcheck li.selected{background-color:#E5E5E5}.fillcheck .selected .icomoon-checkmark-3:before{float:left;color:blue;padding:3px;position:relative;right:14px}.fillcheck .icomoon-close-2:before{float:left;color:blue;position:relative;right:14px;font-size:20px}.MathJax_Display{display:inline!important}[id^=\"fillmain\"] .select{font-size:15px}[id^=\"fillmain\"] .textarea{vertical-align:middle;border-radius:3px;background:#ffe;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.ui-draggable-disabled{cursor:no-drop!important;opacity:0.5!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RlcEFsZ28uc3ZlbHRlIiwic291cmNlcyI6WyJTdGVwQWxnby5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbjwhLS0gXHJcbiogIEZpbGUgTmFtZSAgIDogU3RlcEFsZ28uc3ZlbHRlXHJcbiogIERlc2NyaXB0aW9uIDogU2F2aW5nIGFuc3dlciB0b29sIGFuZCBxdWVzdGlvbiBtb2RlbCBib3hlc1xyXG4qICBBdXRob3IgICAgICA6IFN1bmRhcmFtIFRyaXBhdGhpXHJcbiogIFZlcnNpb24gICAgIDogMS4wXHJcbiogIFBhY2thZ2UgICAgIDogc3ZlbHRlX2l0ZW1zXHJcbiogIExhc3QgdXBkYXRlIDogIC0tPlxyXG48c2NyaXB0PlxyXG4gICAgaW1wb3J0IHt3cml0YWJsZX0gZnJvbSAnc3ZlbHRlL3N0b3JlJztcclxuICAgIGltcG9ydCB7IEJ1dHRvbiwgRGlhbG9nLCBDaGVja2JveCB9IGZyb20gJ3N2ZWx0ZS1tdWkvc3JjJztcclxuICAgIGltcG9ydCBsIGZyb20gJy4uL3NyYy9saWJzL2VkaXRvckxpYi9sYW5ndWFnZS5qcyc7XHJcbiAgICBpbXBvcnQgeyBiZWZvcmVVcGRhdGUsb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XHJcbiAgICBpbXBvcnQge0FILFhNTFRvSlNPTixKU09OVG9YTUx9IGZyb20gXCIuLi9oZWxwZXIvSGVscGVyQUkuc3ZlbHRlXCI7XHJcblxyXG4gICAgIHdpbmRvdy5zcGFuQ291bnRlciA9IDA7XHJcbiAgICAvLyB3aW5kb3cuY3VycmVudElkID0gXCJcIjtcclxuICAgIC8vIHdpbmRvdy5jdXJyZW50SW5wID0gXCJcIjtcclxuICAgIGxldCBzdGF0ZSA9IHt9O1xyXG4gICAgbGV0IG5ld194bWwgPSB7fVxyXG4gICAgdmFyIGFsbF9zdGVwcyA9IFtdO1xyXG4gICAgZXhwb3J0IGxldCBzdG9wQXV0aG9yaW5nVXBkYXRlO1xyXG4gICAgZXhwb3J0IGxldCB4bWw7XHJcbiAgICBleHBvcnQgbGV0IGVkaXRvclN0YXRlO1xyXG4gICAgZXhwb3J0IGxldCBnZXRDaGlsZFhtbDtcclxuXHJcbiAgICBcclxuICAgIFxyXG4gICAgbGV0IHN0YXRlRGF0YSA9IHdyaXRhYmxlKHtcclxuICAgICAgICB4bWwgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJywgICAgICAgICBcclxuICAgICAgICBmaWxsSW5UaGVCbGFua3NDaG9pY2UgICAgICAgOiAxLFxyXG4gICAgICAgIG9wZW5lZCAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgIGRlbGV0ZUluZGV4ICAgICAgICAgICAgICAgICA6IFwiXCIsXHJcbiAgICAgICAgcmVtZWRpYXRpb25Ub2dnbGUgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgc25hY2tiYWNrICAgICAgICAgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgaW5wdXRfYW5zICAgICAgICAgICAgICAgICAgIDogJycsXHJcbiAgICAgICAgc3BhbkNvdW50ZXIgICAgICAgICAgICAgICAgIDogMCxcclxuICAgICAgICBjdXJyZW50SWQgICAgICAgICAgICAgICAgICAgOiAnJyxcclxuICAgICAgICBjdXJyZW50SW5wICAgICAgICAgICAgICAgICAgOiAnJ1xyXG5cclxuICAgIH0pXHJcblxyXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdGF0ZURhdGEuc3Vic2NyaWJlKChpdGVtcyk9PntcclxuICAgICAgICBzdGF0ZSA9IGl0ZW1zO1xyXG4gICAgfSlcclxuXHJcbiAgICBvbk1vdW50KCgpPT57XHJcbiAgICAgICAgaWYoeG1sKSB7XHJcbiAgICAgICAgICAgIG5ld194bWwgPSBYTUxUb0pTT04oeG1sKTtcclxuICAgICAgICAgICAgc2hvd0l0ZW1zKG5ld194bWwuc214bWwuc3RlcCk7XHJcbiAgICAgICAgICAgIC8valF1ZXJ5KCcjc3RpY2t5X2NoZWNrYm94XzAnKS50cmlnZ2VyKCdjbGljaycpO1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoXCIjc3RpY2t5X2NoZWNrYm94XzBcIikuY2xpY2soKTtcclxuICAgICAgICAgICAgLy9zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy9qUXVlcnkoJyNzdGlja3lfY2hlY2tib3hfMCcpLnRyaWdnZXIoJ2NsaWNrJyk7XHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNzdGlja3lfY2hlY2tib3hfMCcpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIC8vfSwgMTAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8valF1ZXJ5KCcuc2F2ZV9idXR0b25fc3RlcHMnKS5wcm9wKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5zYXZlX2J1dHRvbl9zdGVwcycsJ2F0dHInLHtkaXNhYmxlZDonZGlzYWJsZWQnfSk7XHJcbiAgICAgICAgICAgIGluaXRFZGl0b3IoKTtcclxuICAgICAgICB9LCA1MDApO1xyXG5cclxuICAgICAgICAvLyBqUXVlcnkoZG9jdW1lbnQpLm9uKFwiY2xpY2sgdG91Y2hzdGFydFwiLCBcIi5lZGl0RmlsbFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdC8vIFx0aWYoalF1ZXJ5KHRoaXMpLmF0dHIoXCJ0eXBlXCIpID09IFwidFwiKSB7XHJcblx0XHQvLyBcdFx0ZWRpdFRleHRib3goalF1ZXJ5KHRoaXMpLmF0dHIoXCJvcmlnaW5hbEtleVwiKSk7XHJcblx0XHQvLyBcdH0gZWxzZSBpZihqUXVlcnkodGhpcykuYXR0cihcInR5cGVcIikgPT0gXCJlXCIpIHtcclxuXHRcdC8vIFx0XHRlZGl0TWF0aGJveChqUXVlcnkodGhpcykuYXR0cihcIm9yaWdpbmFsS2V5XCIpKTtcclxuXHRcdC8vIFx0fVxyXG5cdFx0Ly8gfSlcclxuXHJcbiAgICAgICAgQUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJy5lZGl0RmlsbCcsZnVuY3Rpb24oY3VycixlKSB7XHJcbiAgICAgICAgICAgIGlmKGN1cnIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcInRcIikge1xyXG4gICAgICAgICAgICAgICAgZWRpdFRleHRib3goY3Vyci5nZXRBdHRyaWJ1dGUoXCJvcmlnaW5hbEtleVwiKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyLmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT0gXCJlXCIpIHtcclxuICAgICAgICAgICAgICAgIGVkaXRNYXRoYm94KGN1cnIuZ2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgQUgubGlzdGVuKGRvY3VtZW50LCd0b3VjaHN0YXJ0JywnLmVkaXRGaWxsJyxmdW5jdGlvbihjdXJyLGUpIHtcclxuICAgICAgICAgICAgaWYoY3Vyci5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwidFwiKSB7XHJcbiAgICAgICAgICAgICAgICBlZGl0VGV4dGJveChjdXJyLmdldEF0dHJpYnV0ZShcIm9yaWdpbmFsS2V5XCIpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcImVcIikge1xyXG4gICAgICAgICAgICAgICAgZWRpdE1hdGhib3goY3Vyci5nZXRBdHRyaWJ1dGUoXCJvcmlnaW5hbEtleVwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuXHJcblxyXG4gICAgfSlcclxuXHJcbiAgICBmdW5jdGlvbiBlZGl0VGV4dGJveChrZXkpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGVja2luZycpO1xyXG5cdFx0a2V5ID0ga2V5LnJlcGxhY2UoLyV7fH0lL2csIFwiXCIpO1xyXG5cdFx0a2V5ID0ga2V5LnNwbGl0KFwifFwiKTtcclxuXHRcdGxldCBhbnMgPSBrZXlbMF0udHJpbSgpO1xyXG4gICAgICAgIFxyXG5cdFx0bGV0IGFuc190eXBlID0gKChrZXlbMV0pP2tleVsxXS50cmltKCk6XCJcIik7XHJcblx0XHRcclxuICAgICAgICAgICAgc3RhdGUubnVtZXJpYyA9ICgoYW5zX3R5cGUgPT0gXCJuXCIpPyB0cnVlIDogZmFsc2UgKTtcclxuICAgICAgICAgICAgc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID0gMTtcclxuICAgICAgICAgICAgc3RhdGUub3BlbiA9IHRydWU7XHJcbiAgICAgICAgXHJcblx0XHQvL3RoaXMuc2V0U3RhdGUoe2ZpbGxJblRoZUJsYW5rc0Nob2ljZToxfSk7XHJcblx0XHQvL3RoaXMuc2V0U3RhdGUoe29wZW46dHJ1ZX0pO1xyXG5cdFx0aWYoYW5zLmluZGV4T2YoXCIjc3R5bGUjXCIpICE9IC0xKSB7XHJcblx0XHRcdGxldCBjdXN0b21TdHlsZSAgPSBhbnMuc3BsaXQoXCIjc3R5bGUjXCIpXHJcblx0XHRcdC8valF1ZXJ5KFwiI3Jlc3BvbnNlRGlhbG9nICNjdXN0b21TdHlsZVRleHRcIikudmFsKGN1c3RvbVN0eWxlWzFdKTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KFwiI3Jlc3BvbnNlRGlhbG9nICNjdXN0b21TdHlsZVRleHRcIikudmFsdWUgPSBjdXN0b21TdHlsZVsxXTtcclxuXHJcblx0XHRcdC8valFVZXJ5KFwiI2lucHV0MVwiKS52YWwoY3VzdG9tU3R5bGVbMF0pO1xyXG4gICAgICAgICAgICAvL0FILnNlbGVjdChcIiNpbnB1dDFcIikudmFsdWUgPSBjdXN0b21TdHlsZVswXTtcclxuICAgICAgICAgICAgc3RhdGUuaW5wdXRfYW5zID0gY3VzdG9tU3R5bGVbMF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvL2pRdWVyeShcIiNpbnB1dDFcIikudmFsKGFucyk7XHJcbiAgICAgICAgICAgIC8vIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgLy8gICAgIEFILnNlbGVjdChcIiNpbnB1dDFcIikudmFsdWUgPSBhbnM7XHJcbiAgICAgICAgICAgIC8vIH0sMTAwKVxyXG4gICAgICAgICAgICBzdGF0ZS5pbnB1dF9hbnMgPSBhbnM7XHJcblx0XHR9XHRcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZWRpdE1hdGhib3goa2V5KSB7XHJcblx0XHRrZXkgPSBrZXkucmVwbGFjZSgvJXt8fSUvZywgXCJcIik7XHJcblx0XHRrZXkgPSBrZXkuc3BsaXQoXCJ8XCIpO1xyXG5cdFx0bGV0IGFucyA9IGtleVswXS50cmltKCk7XHJcblx0XHRsZXQgYW5zX3R5cGUgPSAoKGtleVsxXSk/a2V5WzFdLnRyaW0oKTpcIlwiKTtcclxuXHRcdC8vIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgIC8vICAgICBjdXN0b21TdHlsZTooKGFucy5pbmRleE9mKFwiI3N0eWxlI1wiKSAhPSAtMSk/dHJ1ZTpmYWxzZSksXHJcbiAgICAgICAgLy8gICAgIGZpbGxJblRoZUJsYW5rc0Nob2ljZToyLFxyXG4gICAgICAgIC8vICAgICBvcGVuOnRydWVcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICBzdGF0ZS5jdXN0b21TdHlsZSA9ICgoYW5zLmluZGV4T2YoXCIjc3R5bGUjXCIpICE9IC0xKT90cnVlOmZhbHNlKTtcclxuICAgICAgICBzdGF0ZS5maWxsSW5UaGVCbGFua3NDaG9pY2UgPTI7XHJcbiAgICAgICAgc3RhdGUub3BlbiA9IHRydWU7XHJcblx0XHQvL3RoaXMuc2V0U3RhdGUoe2ZpbGxJblRoZUJsYW5rc0Nob2ljZToyfSk7ICMjIEFMcmVhZHkgY29tbWVudGVkXHJcblx0XHQvL3RoaXMuc2V0U3RhdGUoe29wZW46dHJ1ZX0pOyAjIyBBTHJlYWR5IGNvbW1lbnRlZFxyXG5cclxuXHRcdGlmKGFucy5pbmRleE9mKFwiI3N0eWxlI1wiKSAhPSAtMSkge1xyXG5cdFx0XHRsZXQgY3VzdG9tU3R5bGUgID0gYW5zLnNwbGl0KFwiI3N0eWxlI1wiKVxyXG5cdFx0XHQvLyQoXCIjcmVzcG9uc2VEaWFsb2cgI2N1c3RvbVN0eWxlVGV4dFwiKS52YWwoY3VzdG9tU3R5bGVbMV0pO1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoXCIjcmVzcG9uc2VEaWFsb2dcIikudmFsdWUgPSBjdXN0b21TdHlsZVsxXTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjY3VzdG9tU3R5bGVUZXh0JykudmFsdWUgPSBjdXN0b21TdHlsZVsxXTtcclxuXHRcdFx0Ly8kKFwiI2lucHV0XCIraSkudmFsKGN1c3RvbVN0eWxlWzBdKTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KFwiI2lucHV0XCIraSkudmFsdWUgPSBjdXN0b21TdHlsZVswXTtcclxuXHRcdH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vJChcIiNpbnB1dFwiKS52YWwoYW5zKTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KFwiI2lucHV0XCIpLnZhbHVlID0gYW5zO1xyXG5cdFx0fVx0XHJcblx0fVxyXG4gICAgXHJcbiAgICBiZWZvcmVVcGRhdGUoKCk9PntcclxuICAgICAgICBpZiAoeG1sICE9IHN0YXRlLnhtbCkge1xyXG4gICAgICAgICAgICBzdGF0ZS54bWwgPSB4bWw7XHJcbiAgICAgICAgICAgIGlmIChzdG9wQXV0aG9yaW5nVXBkYXRlID09PSB0cnVlKSByZXR1cm47XHJcbiAgICAgICAgICAgIG5ld194bWwgPSBYTUxUb0pTT04oc3RhdGUueG1sKTtcclxuICAgICAgICAgICAgc2hvd0l0ZW1zKG5ld194bWwuc214bWwuc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBmdW5jdGlvbiBzaG93SXRlbXMoc3RlcHMpIHtcclxuICAgICAgICBzdGVwcyA9IHJlcGxhY2VWYXJpYWJsZXMoc3RlcHMpO1xyXG4gICAgICAgIGFsbF9zdGVwcyA9IHN0ZXBzO1xyXG4gICAgICAgIHNldFRvZ2dsZShhbGxfc3RlcHMpO1xyXG4gICAgICAgIHBhcnNlWG1sQXV0aG9yaW5nKHN0ZXBzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRUb2dnbGUoc3RlcHMpIHtcclxuICAgICAgICBsZXQgdG9vZ2xlID0gJyc7XHJcbiAgICAgICAgc3RlcHMubWFwKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmKGl0ZW0uX3ZpZXdvbmx5ID09IDEpIHtcclxuICAgICAgICAgICAgICAgIGFsbF9zdGVwc1tpbmRleF0udG9nZ2xlID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsbF9zdGVwc1tpbmRleF0udG9nZ2xlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIGFsbF9zdGVwcztcclxuICAgIH0gXHJcblxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZVZhcmlhYmxlcyhsYXRleF9zdHIpIHtcclxuICAgICAgICBsZXQgbGF0ZXhfYXJyID0gW107XHJcbiAgICAgICAgbGV0IGxhdGV4X2Fycl9jaGVjayA9IGxhdGV4X3N0cjtcclxuICAgICAgICBpZihsYXRleF9hcnJfY2hlY2subGVuZ3RoID09IHVuZGVmaW5lZCAmJiBsYXRleF9hcnJfY2hlY2sgIT0gXCJcIikge1xyXG4gICAgICAgICAgICBsYXRleF9hcnIucHVzaChsYXRleF9hcnJfY2hlY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxhdGV4X2FyciA9IGxhdGV4X2Fycl9jaGVjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGF0ZXhfYXJyLm1hcChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICBsZXQgY2RhdGEgPSBpdGVtLl9fY2RhdGE7XHJcbiAgICAgICAgICAgIGxldCB2YXJzID0gY2RhdGEubWF0Y2goLzx7W1xcc1xcU10qP30+L2dtKTtcclxuICAgICAgICAgICAgaWYodmFycykge1xyXG4gICAgICAgICAgICAgICAgdmFycy5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gZWxlbWVudC5tYXRjaCgvPFxceyguKj8pXFx9Pi9nKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS50b1N0cmluZygpLnJlcGxhY2UoLzxcXHt8XFx9Pi9nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFwidmFyOlwiK2l0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNkYXRhID0gY2RhdGEucmVwbGFjZShlbGVtZW50LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhdGV4X2FycltpbmRleF0uX19jZGF0YSA9IGNkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBsYXRleF9hcnI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VYbWxBdXRob3Jpbmcoc3RlcHMpIHtcclxuICAgICAgICBzdGVwcy5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgbGV0IGNkYXRhID0gaXRlbS5fX2NkYXRhO1xyXG4gICAgICAgICAgICBsZXQgYW5zd2VyS2V5ID0gY2RhdGEubWF0Y2goLyV7W1xcc1xcU10qP30lL2dtKTtcclxuICAgICAgICAgICAgbGV0IGFuc3dlclR5cGUgPSAnJztcclxuICAgICAgICAgICAgaWYoYW5zd2VyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAvL2pRdWVyeShhbnN3ZXJLZXkpLmVhY2goZnVuY3Rpb24oaSl7XHJcbiAgICAgICAgICAgICAgICBhbnN3ZXJLZXkuZm9yRWFjaChmdW5jdGlvbihkYXRhLGkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbEtleSA9IGFuc3dlcktleVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGF0ZXhLZXkgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlZGl0TWF0aCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyVHlwZSA9IGFuc3dlcktleVtpXS5tYXRjaCgvXFx8KC4qPyl9JSQvZ20pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuc3dlclR5cGUgPSAoYW5zd2VyVHlwZSkgPyBhbnN3ZXJUeXBlWzBdLnJlcGxhY2UoL1xcfHx9JS9nbSwgJycpIDogJ3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lcktleSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGljb24gPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZihhbnN3ZXJUeXBlID09IFwidFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBhbnN3ZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lcktleSA9IFwiVGV4dGJveFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gXCJpY29tb29uLWluc2VydC10ZW1wbGF0ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihhbnN3ZXJUeXBlID09IFwiblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcInRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJLZXkgPSBcIk51bWVyaWNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IFwiaWNvbW9vbi1pbnNlcnQtdGVtcGxhdGVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYW5zd2VyVHlwZT09IFwiZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBhbnN3ZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lcktleSA9IFwiTWF0aFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRleEtleSA9IG9yaWdpbmFsS2V5LnJlcGxhY2UoL1xcJVxce3xcXHxlXFx9XFwlL2csIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRleEtleSA9IFwibGF0ZXg9XFxcIlwiK2xhdGV4S2V5K1wiXFxcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0TWF0aCA9IFwiZWRpdE1hdGhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IFwiaWNvbW9vbi1pbnNlcnQtdGVtcGxhdGVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChSZWdFeHAucXVvdGUob3JpZ2luYWxLZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICBjZGF0YSA9IGNkYXRhLnJlcGxhY2UocmVnZXgsIFwiPHNwYW4gaWQ9XFxcImxhdGV4U3BhblwiKyhzdGF0ZS5zcGFuQ291bnRlciA9ICsrc3RhdGUuc3BhbkNvdW50ZXIpK1wiXFxcIiBcIitsYXRleEtleStcIiB0eXBlPSdcIit0eXBlK1wiJyBjbGFzcz0nYWxlcnQgYWxlcnQtaW5mbyBlZGl0RmlsbCBcIitlZGl0TWF0aCtcIicgb3JpZ2luYWxrZXk9J1wiK29yaWdpbmFsS2V5K1wiJyBzdHlsZT0ncGFkZGluZzogNXB4O291dGxpbmU6IG5vbmU7bGluZS1oZWlnaHQ6NDBweDtjdXJzb3I6bW92ZTtjb2xvcjojMDAwJyBjb250ZW50RWRpdGFibGU9J2ZhbHNlJz48aSBzdHlsZT0ncGFkZGluZy1yaWdodDo0cHgnIGNsYXNzPSdcIitpY29uK1wiJz48L2k+XCIraW5uZXJLZXkrXCI8L3NwYW4+XCIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWxsX3N0ZXBzW2luZGV4XS5fX2NkYXRhID0gY2RhdGE7XHJcbiAgICAgICAgfSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ29OZXh0KGlkKSB7XHJcbiAgICAgICAgbGV0IHJlZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjXCIraWQpO1xyXG4gICAgICAgIGlmKHJlZi5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmdvbmV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuX2dvbmV4dCA9IFwiMVwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmdvbmV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBuZXdfeG1sLnNteG1sLl9nb25leHQgPSBcIjBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlWE1MKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZml4ZWRBbnN3ZXIoaWQpIHtcclxuICAgICAgICBsZXQgcmVmID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNcIitpZCk7XHJcbiAgICAgICAgaWYocmVmLmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgc3RhdGUudmFyaWFibGVfYnV0dG9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5fZml4ZWQgPSBcIjFcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0ZS52YXJpYWJsZV9idXR0b24gPSBmYWxzZTtcclxuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5fZml4ZWQgPSBcIjBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlWE1MKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ2hlY2tib3goaWQsIGZpbGxpZCwgZSkge1xyXG4gICAgICAgIGxldCBuYW1lID0gZS50YXJnZXQubmFtZTtcclxuICAgICAgICBsZXQgcmVmID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNcIituYW1lK2lkKTtcclxuICAgICAgICBsZXQgdmFsID0gXCJfXCIrZS50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgbGV0IHNlcSA9IGlkO1xyXG4gICAgICAgIGlmKHJlZi5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtzZXFdW3ZhbF0gPSBcIjFcIjsgXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5zdGVwW3NlcV1bdmFsXSA9IFwiMFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2xldCBkYXRhID0galF1ZXJ5KCcjJytmaWxsaWQpLmh0bWwoKTtcclxuICAgICAgICBsZXQgZGF0YSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnK2ZpbGxpZCkuaW5uZXJIVE1MO1xyXG4gICAgICAgIHVwZGF0ZVhNTCgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVEaXNhYmxlKGkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnaGFuZGxlIGNsaWNrJyk7XHJcbiAgICAgICAgLy9qUXVlcnkoJyNzYXZlX3N0ZXBfJytpKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIEFILnNlbGVjdCgnI3NhdmVfc3RlcF8nK2ksJ3JlbW92ZUF0dHInLCdkaXNhYmxlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJhZGlvKGluZGV4LCBmaWxsaWQsIGV2ZW50KSB7XHJcbiAgICAgICAgaWYoYWxsX3N0ZXBzW2luZGV4XS50b2dnbGUgPT0gMSkge1xyXG4gICAgICAgICAgICBhbGxfc3RlcHNbaW5kZXhdLnRvZ2dsZSA9IDBcclxuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5zdGVwW2luZGV4XS5fdmlld29ubHkgPSBcIjBcIjtcclxuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5zdGVwW2luZGV4XS5fYXR0ZW1wdCA9IFwiMVwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFsbF9zdGVwc1tpbmRleF0udG9nZ2xlID09IDE7XHJcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtpbmRleF0uX3ZpZXdvbmx5ID0gXCIxXCI7XHJcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtpbmRleF0uX2F0dGVtcHQgPSBcIjBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9sZXQgZGF0YSA9IGpRdWVyeSgnIycrZmlsbGlkKS5odG1sKCk7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJytmaWxsaWQpLmlubmVySFRNTDtcclxuICAgICAgICB1cGRhdGVYTUwoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWxldGVFdmVudChpbmRleCwgZGF0YSkge1xyXG4gICAgICAgIGxldCBkZWxldGVfZXZlbnQ7XHJcbiAgICAgICAgaWYoZGF0YSA9PSAnc3RlcHMnKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZV9ldmVudCA9IGFsbF9zdGVwcztcclxuICAgICAgICAgICAgaWYoZGVsZXRlX2V2ZW50Lmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZCA9IGRlbGV0ZV9ldmVudC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQUguYWxlcnQoXCJZb3UgaGF2ZSBhdGxlYXN0IDIgc3RlcHMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgYWxsX3N0ZXBzID0gZGVsZXRlX2V2ZW50OyBcclxuICAgICAgICB1cGRhdGVYTUwoKTtcclxuICAgICAgICB9IGVsc2UgaWYoZGF0YSA9PSAnYWxnbycpIHtcclxuICAgICAgICAgICAgc3RhdGUub3BlbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhdGUuZGVsZXRlSW5kZXggPSBpbmRleDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNhdmUoaWQsIGZpbGxpZCkge1xyXG4gICAgICAgIC8vbGV0IGRhdGEgPSBqUXVlcnkoJyMnK2ZpbGxpZCkuaHRtbCgpO1xyXG4gICAgICAgIGxldCBkYXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycrZmlsbGlkKS5pbm5lckhUTUw7XHJcbiAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvJmFtcDsvZywnJicpOyAvLyByZXBsYWNlIGFtcCB0byBtYWludGFpbiBodG1sIGVudGl0eS5cclxuICAgICAgICBhbGxfc3RlcHNbaWRdLl9fY2RhdGEgPSBkYXRhOyBcclxuICAgICAgICAvL2pRdWVyeSgnI3NhdmVfc3RlcF8nK2lkKS5wcm9wKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xyXG4gICAgICAgIC8vZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NhdmVfc3RlcF8nK2lkKS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgQUguc2VsZWN0KCcjc2F2ZV9zdGVwXycraWQsJ2F0dHInLHtkaXNhYmxlZDonZGlzYWJsZWQnfSlcclxuICAgICAgICB1cGRhdGVYTUwoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVYTUwoKSB7XHJcbiAgICAgICAgbGV0IGZpeGFucyA9IG5ld194bWwuc214bWwuX2ZpeGVkO1xyXG4gICAgICAgIGxldCBnb25leHQgPSBuZXdfeG1sLnNteG1sLl9nb25leHQ7XHJcbiAgICAgICAgbGV0IHhtbCA9ICc8c214bWwgdHlwZT1cIjM3XCIgZml4ZWQ9XCInK2ZpeGFucysnXCIgZ29uZXh0PVwiJytnb25leHQrJ1wiPic7XHJcbiAgICAgICAgYWxsX3N0ZXBzLm1hcChmdW5jdGlvbihlbGVtZW50LCBpKSB7XHJcbiAgICAgICAgICAgIGxldCBzZXEgPSBpKzE7XHJcbiAgICAgICAgICAgIGxldCB2aWV3b25seSA9IGVsZW1lbnQuX3ZpZXdvbmx5O1xyXG4gICAgICAgICAgICBsZXQgbW9kZSA9IGVsZW1lbnQuX21vZGU7XHJcbiAgICAgICAgICAgIGxldCBhdHRlbXB0ID0gZWxlbWVudC5fYXR0ZW1wdDtcclxuICAgICAgICAgICAgbGV0IHN0aWNreSA9IGVsZW1lbnQuX3N0aWNreTtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBlbGVtZW50Ll9fY2RhdGE7XHJcbiAgICAgICAgICAgIC8vIGRhdGEgPSBzZWxmLnJldmVyc2VSZXBsYWNlVmFyaWFibGVzKGRhdGEpO1xyXG4gICAgICAgICAgICBkYXRhID0gcmV2ZXJzZUh0bWxTcGVjaWFsQ2hhcnMoZGF0YSk7XHJcbiAgICAgICAgICAgIGRhdGEgPSByZXBsYWNlU3BhY2VzKGRhdGEpO1xyXG4gICAgICAgICAgICBkYXRhICA9IGRhdGEucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpLnJlcGxhY2UoLyZuYnNwOy9nLCAnICcpO1xyXG4gICAgICAgICAgICBkYXRhICA9IGRhdGEucmVwbGFjZSgvJy9nLCAnXCInKS5yZXBsYWNlKC9cXG4vZywgJycpO1xyXG4gICAgICAgICAgICBsZXQgYXJyID0gZGF0YS5tYXRjaCgvPHNwYW4oLio/KT4oLio/KTxcXC9zcGFuPi9naSk7XHJcbiAgICAgICAgICAgIGlmKGFycikge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsa2V5ID0gYXJyW2ldLm1hdGNoKC9vcmlnaW5hbGtleT1cIiUoLio/KSVcIi9nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihvcmlnaW5hbGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbGtleSA9IG9yaWdpbmFsa2V5LnRvU3RyaW5nKCkucmVwbGFjZSgvb3JpZ2luYWxrZXk9L2csICcnKS5yZXBsYWNlKC9cIiV8JVwiL2csICclJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoYXJyW2ldLCBvcmlnaW5hbGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHhtbCA9IHhtbCArIFwiPHN0ZXAgc2VxPSdcIitzZXErXCInXCIgKyAoKGF0dGVtcHQgIT0gdW5kZWZpbmVkKT8gXCIgYXR0ZW1wdCA9J1wiK2F0dGVtcHQrXCInXCIgOiAnICcpICsgKCh2aWV3b25seSAhPSB1bmRlZmluZWQpPyBcIiB2aWV3b25seSA9J1wiK3ZpZXdvbmx5K1wiJ1wiIDogJyAnKSArICgobW9kZSAhPSB1bmRlZmluZWQpPyBcIiBtb2RlID0nXCIrbW9kZStcIidcIiA6ICcgJykgKyAoKHN0aWNreSAhPSB1bmRlZmluZWQpPyBcIiBzdGlja3kgPSdcIitzdGlja3krXCInXCIgOiAnICcpICtcIj48IS0tW0NEQVRBW1wiK2NkYXRhK1wiXV0tLT48L3N0ZXA+XCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgeG1sID0geG1sICsgXCI8L3NteG1sPlwiO1xyXG4gICAgICAgIGdldENoaWxkWG1sKHhtbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmV2ZXJzZUh0bWxTcGVjaWFsQ2hhcnMoZGF0YSkge1xyXG4gICAgICAgIGxldCB0YWdzID0gZGF0YS5tYXRjaCgvJmx0OyguKj8pJmd0Oy9nbSk7XHJcblx0XHRsZXQgdGFnID0gJyc7XHJcblx0XHRpZih0YWdzKSB7XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPHRhZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRhZyA9IHRhZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB0YWdzW2ldID0gdGFnc1tpXS5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKTtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UodGFnLCB0YWdzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZVNwYWNlcyhkYXRhKSB7XHJcbiAgICAgICAgbGV0IG1hdGNoaW5nID0gZGF0YS5tYXRjaCgvdmFyOnZhclxcZCtcXHMrXFxzKy9nKTtcclxuICAgICAgICBsZXQgbWF0Y2g7XHJcbiAgICAgICAgaWYobWF0Y2hpbmcpIHtcclxuICAgICAgICAgICAgbWF0Y2hpbmcubWFwKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KXtcclxuICAgICAgICAgICAgICAgIG1hdGNoID0gaXRlbS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKGl0ZW0sbWF0Y2gpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkRXZlbnQoZGF0YSkge1xyXG4gICAgICAgIGxldCBvYmogPSB7fTtcclxuICAgICAgICBvYmouX3NlcSA9IGFsbF9zdGVwcy5sZW5ndGgrMTtcclxuICAgICAgICBvYmouX3ZpZXdvbmx5ID0gXCIxXCI7XHJcbiAgICAgICAgb2JqLl9hdHRlbXB0ID0gXCIwXCI7XHJcbiAgICAgICAgb2JqLl9tb2RlID0gXCIwXCI7XHJcbiAgICAgICAgb2JqLl9fY2RhdGEgPSBcIk5ldyBTdGVwXCI7XHJcbiAgICAgICAgYWxsX3N0ZXBzLnB1c2gob2JqKTtcclxuICAgICAgICB1cGRhdGVYTUwoKTtcclxuICAgICAgICBzdGF0ZS5zbmFja2JhY2sgPSB0cnVlO1xyXG4gICAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGluaXRFZGl0b3IoKTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICB9LCA1MDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluaXRFZGl0b3IoKSB7XHJcbiAgICAgICAgLy8galF1ZXJ5KGRvY3VtZW50KS5vbihcImNsaWNrXCIsIFwiLmVkaXRNYXRoXCIsIGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIC8vICAgICB3aW5kb3cuY3VycmVudElkID0galF1ZXJ5KHRoaXMpLmF0dHIoJ2lkJyk7XHJcbiAgICAgICAgLy8gfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCxcImNsaWNrXCIsXCIuZWRpdE1hdGhcIixmdW5jdGlvbihfdGhpcyxlKXtcclxuICAgICAgICAgICAgLy8gd2luZG93LmN1cnJlbnRJZCA9IF90aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgc3RhdGUuY3VycmVudElkID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIGpRdWVyeShkb2N1bWVudCkub24oXCJjbGlja1wiLCBcIi5tYXRlcmlhbE92ZXJsYXlcIiwgZnVuY3Rpb24oZSl7XHJcblx0XHQvLyBcdHdpbmRvdy5jdXJyZW50SWQgPSBudWxsO1xyXG4gICAgICAgIC8vICAgICB3aW5kb3cuY3VycmVudElucCA9IG51bGw7XHJcbiAgICAgICAgLy8gfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcubWF0ZXJpYWxPdmVybGF5JyxmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgLy93aW5kb3cuY3VycmVudElkID0gbnVsbDtcclxuICAgICAgICAgICAgc3RhdGUuY3VycmVudElkICA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vd2luZG93LmN1cnJlbnRJbnAgPSBudWxsO1xyXG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50SW5wID0gbnVsbDtcclxuICAgICAgICB9KVxyXG5cclxuXHRcdHRpbnlNQ0UuUGx1Z2luTWFuYWdlci5hZGQoJ3JlcycsIGZ1bmN0aW9uKGVkaXRvciwgdXJsKSB7XHJcbiAgICAgICAgICAgIGVkaXRvci5hZGRNZW51SXRlbSgncmVzcCcsIHtcclxuICAgICAgICAgICAgICAgIHRleHQ6XCJBZGQgcmVzcG9uc2VcIixcclxuICAgICAgICAgICAgICAgIGlkOidhZGRUb2tlbicsXHJcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT3BlbigpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdpbnNlcnQnLFxyXG4gICAgICAgICAgICAgICAgcHJlcGVuZFRvQ29udGV4dDogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHRcdHRpbnltY2UuUGx1Z2luTWFuYWdlci5sb2FkKCdlcXVhdGlvbmVkaXRvcicsIHRoZW1lVXJsKydzdmVsdGVfaXRlbXMvdGlueW1jZS9wbHVnaW5zL2VxdWF0aW9uZWRpdG9yL3BsdWdpbi5taW4uanMnKTtcclxuXHRcdHRpbnltY2UuaW5pdCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnLnRpbnltY2UtZWRpdG9yLXJlcycsXHJcbiAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcclxuICAgICAgICAgICAgdGhlbWU6ICdtb2Rlcm4nLFxyXG4gICAgICAgICAgICBza2luOiAnc2tpbjAyJyxcclxuICAgICAgICAgICAgbWluX3dpZHRoOiAxMDAsXHJcbiAgICAgICAgICAgIHJlc2l6ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVudWJhcjogZmFsc2UsXHJcbiAgICAgICAgICAgIHRvb2xiYXI6IHRydWUsXHJcbiAgICAgICAgICAgIGVsZW1lbnRwYXRoOiBmYWxzZSxcclxuICAgICAgICAgICAgc3RhdHVzYmFyOiBmYWxzZSxcclxuICAgICAgICAgICAgZm9yY2VfYnJfbmV3bGluZXM6IHRydWUsXHJcbiAgICAgICAgICAgIHJlbW92ZV90cmFpbGluZ19icnM6IHRydWUsXHJcbiAgICAgICAgICAgIGZvcmNlZF9yb290X2Jsb2NrOiBmYWxzZSxcclxuICAgICAgICAgICAgZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHM6ICdzcGFuW29uQ2xpY2t8Y29udGVudEVkaXRhYmxlXScsXHJcbiAgICAgICAgICAgIHZhbGlkX2VsZW1lbnRzOiBcIipbKl1cIixcclxuXHRcdFx0Zml4ZWRfdG9vbGJhcl9jb250YWluZXI6ICcjdG9vbGJhcl9jb250YWluZXInLFxyXG4gICAgICAgICAgICBleHRlbmRlZF92YWxpZF9lbGVtZW50czogJ3VjOnN5bnRheCx1YzpyZWYnLFxyXG4gICAgICAgICAgICBjdXN0b21fZWxlbWVudHM6ICd1YzpzeW50YXgsfnVjOnJlZicsXHJcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcclxuICAgICAgICAgICAgICAgIFwibGlzdHMgbGluayBpbWFnZSBjaGFybWFwIHByaW50IHByZXZpZXcgYW5jaG9yXCIsXHJcbiAgICAgICAgICAgICAgICBcInNlYXJjaHJlcGxhY2UgY29kZSBmdWxsc2NyZWVuXCIsXHJcbiAgICAgICAgICAgICAgICBcImluc2VydGRhdGV0aW1lIG1lZGlhIHRhYmxlIGNvbnRleHRtZW51IHBhc3RlIHJlcyBlcXVhdGlvbmVkaXRvciBcIlxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBjb250ZW50X2NzczogdGhlbWVVcmwrJ3N2ZWx0ZV9pdGVtcy9zcmMvbGlicy9tYXRocXVpbGwuY3NzJyxcclxuICAgICAgICAgICAgdG9vbGJhcjogW1xyXG4gICAgICAgICAgICAnIGJvbGQgaXRhbGljIHVuZGVybGluZSB8IGVxdWF0aW9uZWRpdG9yJ1xyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBjb250ZXh0bWVudTpcInJlc3BcIixcclxuICAgICAgICAgICAgcGFzdGVfYXNfdGV4dDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cdH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcclxuICAgICAgICBpZihzdGF0ZS5maWxsSW5UaGVCbGFua3NDaG9pY2UgPT0gMikge1xyXG5cdFx0XHQvL3dpbmRvdy5jdXJyZW50SWQgPSBudWxsO1xyXG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50SW5wID0gbnVsbDtcclxuXHRcdH1cclxuICAgICAgICBzdGF0ZS5vcGVuID0gZmFsc2U7IFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZURpYWxvZyh0YXJnZXRWYWwpIHsgIFxyXG4gICAgICAgIHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9IHRhcmdldFZhbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRFZGl0YWJsZSgpIHtcclxuXHRcdC8vbGV0IHR4dCA9IGpRdWVyeShcIiNpbnB1dFwiKTtcclxuICAgICAgICBsZXQgdHh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dFwiKTtcclxuICAgICAgICAvL2xldCBjYXJldFBvcyA9IHR4dFswXS5zZWxlY3Rpb25TdGFydDtcclxuICAgICAgICBsZXQgY2FyZXRQb3MgPSB0eHQuc2VsZWN0aW9uU3RhcnQ7XHJcblx0XHQvL2xldCB0ZXh0QXJlYVR4dCA9IHR4dC52YWwoKTtcclxuICAgICAgICBsZXQgdGV4dEFyZWFUeHQgPSB0eHQudmFsdWU7XHJcbiAgICAgICAgIHZhciB0eHRUb0FkZCA9IFwiXFxcXE1hdGhRdWlsbE1hdGhGaWVsZFwiO1xyXG4gICAgICAgIHZhciB0eHRUb0FkZCAgPSBcInVzZXIgUmVzcG9uc2VcIjtcclxuICAgICAgICAvL3R4dC52YWwodGV4dEFyZWFUeHQuc3Vic3RyaW5nKDAsIGNhcmV0UG9zKSArIHR4dFRvQWRkICsgdGV4dEFyZWFUeHQuc3Vic3RyaW5nKGNhcmV0UG9zKSk7XHJcbiAgICAgICAgdHh0LnZhbHVlID0gdGV4dEFyZWFUeHQuc3Vic3RyaW5nKDAsIGNhcmV0UG9zKSArIHR4dFRvQWRkICsgdGV4dEFyZWFUeHQuc3Vic3RyaW5nKGNhcmV0UG9zKTtcclxuXHR9XHJcblxyXG4gICAgZnVuY3Rpb24gbGF0ZXhFZGl0KCkge1xyXG4gICAgICAgIHN0YXRlLm9wZW4gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0b3JlQW5zKCkge1xyXG5cdFx0dmFyIHZhbGlkYXRlID0gMDtcclxuXHRcdGlmKHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAxKSB7XHJcblx0XHRcdC8vbGV0IGFucyA9IGpRdWVyeShcIiNpbnB1dDFcIikudmFsKCk7XHJcbiAgICAgICAgICAgIGxldCBhbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0MVwiKS52YWx1ZTtcclxuXHRcdFx0Ly9sZXQgbnVtZXJpYyA9IGpRdWVyeShcIiNyZXNwb25zZURpYWxvZyAjbnVtZXJpY1wiKVswXS5jaGVja2VkO1xyXG4gICAgICAgICAgICBsZXQgbnVtZXJpYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcmVzcG9uc2VEaWFsb2cgI251bWVyaWNcIikuY2hlY2tlZDtcclxuICAgICAgICAgICAgaWYobnVtZXJpYyA9PSB0cnVlKSB7XHJcblx0XHRcdFx0YW5zICs9IFwiIHxuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoYW5zLnRyaW0oKSA9PSBcIlwiKSB7XHJcblx0XHRcdFx0dmFsaWRhdGUgPSAxO1xyXG5cdFx0XHRcdHZhbGlkYXRlKFwiQWxsIGZpZWxkcyBhcmUgcmVxdWlyZWRcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGlueU1DRS5hY3RpdmVFZGl0b3IuaW5zZXJ0Q29udGVudChcIjxzcGFuIHR5cGU9J3QnIGNsYXNzPSdhbGVydCBhbGVydC1pbmZvIGVkaXRGaWxsJyBvcmlnaW5hbEtleT0nJXtcIithbnMudHJpbSgpK1wifSUnIHN0eWxlPSdwYWRkaW5nOiA1cHg7b3V0bGluZTogbm9uZTtsaW5lLWhlaWdodDo0MHB4O2N1cnNvcjptb3ZlO2NvbG9yOiMwMDAnIGNvbnRlbnRFZGl0YWJsZT0nZmFsc2UnPjxpIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OjRweCcgY2xhc3M9J2ljb21vb24taW5zZXJ0LXRlbXBsYXRlJz48L2k+XCIrKChudW1lcmljID09IHRydWUpP1wiTnVtZXJpY1wiOlwiVGV4dGJveFwiKStcIjwvc3Bhbj5cIik7XHJcblx0XHRcdH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID09IDIpIHtcclxuXHRcdFx0Ly9sZXQgZSA9IGpRdWVyeShcIiNpbnB1dFwiKS52YWwoKTtcclxuICAgICAgICAgICAgbGV0IGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0XCIpLnZhbHVlO1xyXG5cdFx0XHRpZih2YWxpZGF0ZSA9PSAwKSB7XHJcblx0XHRcdFx0Ly9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK3dpbmRvdy5jdXJyZW50SWQpLnNldEF0dHJpYnV0ZShcImxhdGV4XCIsZSk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK3N0YXRlLmN1cnJlbnRJZCkuc2V0QXR0cmlidXRlKFwibGF0ZXhcIixlKTtcclxuXHRcdFx0XHQvL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjXCIrd2luZG93LmN1cnJlbnRJZCkuc2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIixcIiV7XCIrZStcInxlfSVcIik7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK3N0YXRlLmN1cnJlbnRJZCkuc2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIixcIiV7XCIrZStcInxlfSVcIik7XHJcblx0XHRcdFx0Ly93aW5kb3cuY3VycmVudElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJZCA9IG51bGw7XHJcblx0XHRcdFx0Ly93aW5kb3cuY3VycmVudElucCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50SW5wID0gbnVsbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YWxpZGF0ZShcIkFsbCBmaWVsZHMgYXJlIHJlcXVpcmVkXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodmFsaWRhdGUgPT0gMCkge1xyXG5cdFx0XHRoYW5kbGVDbG9zZSgpO1xyXG5cdFx0fVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZU9wZW4oKSB7XHJcbiAgICAgICAgLy8gdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgLy8gICAgIG9wZW46IHRydWUsXHJcbiAgICAgICAgLy8gICAgIGNvZGV0eXBlOiBmYWxzZSxcclxuICAgICAgICAvLyAgICAgbnVtZXJpYzogZmFsc2VcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICBzdGF0ZS5vcGVuID0gdHJ1ZTtcclxuICAgICAgICBzdGF0ZS5jb2RldHlwZSA9IGZhbHNlO1xyXG4gICAgICAgIHN0YXRlLm51bWVyaWMgPSBmYWxzZTtcclxuICAgICAgICAvL3RoaXMuc2V0U3RhdGUoe2NvZGV0eXBlOiBmYWxzZX0pOyAjYWxyZWFkeSBjb21tZW50ZWQgb24gYWxzbyByZWFjdFxyXG4gICAgICAgIC8vdGhpcy5zZXRTdGF0ZSh7bnVtZXJpYzogZmFsc2V9KTsgI2FscmVhZHkgY29tbWVudGVkIG9uIGFsc28gcmVhY3RcclxuICAgIH1cclxuXHJcbjwvc2NyaXB0PiBcclxuPG1haW4+XHJcbiAgICA8ZGl2IGNsYXNzPVwibXQtaW1wIGJvcmRlclwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJib3JkZXItYm90dG9tIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBweC0yIHB0LTFcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtaW5saW5lLWJsb2NrIHB0LTEgZmxvYXQtc3RhcnQgY3Jfc3RlcFwiIHN0eWxlPXsnZm9udC1zaXplOjIwcHg7cG9zaXRpb246cmVsYXRpdmU7J30+e2wuY3JlYXRlX3N0ZXBzfTwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7fX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZXNfY2hlY2tib3ggZC1pbmxpbmUtYmxvY2sgdG9wLWNoZWNrYm94X2dvbmV4dCBwb3NpdGlvbi1yZWxhdGl2ZSB0b3AyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJnb19uZXh0XCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0ge3N0YXRlLmdvbmV4dCA/IHRydWU6IGZhbHNlfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eyhlKT0+e2dvTmV4dChcImdvX25leHRcIixlKX19IFxyXG4gICAgICAgICAgICAgICAgICAgID57XCJHbyBOZXh0XCJ9PC9DaGVja2JveD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2Rlc19jaGVja2JveCBkLWlubGluZS1ibG9jayBtLWwgdG9wLWNoZWNrYm94X2ZpeCBwb3NpdGlvbi1yZWxhdGl2ZSB0b3AyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJmaXhlZGFuc19jaGVja2JveFwiIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHtzdGF0ZS52YXJpYWJsZV9idXR0b24gPyB0cnVlOiBmYWxzZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrPXsoZSk9PntmaXhlZEFuc3dlcihcImZpeGVkYW5zX2NoZWNrYm94XCIsZSl9fSBcclxuICAgICAgICAgICAgICAgICAgICA+e1wiRml4IEFuc3dlclwifSA8L0NoZWNrYm94PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwib3V0ZXJfc3RlcHMgbXQtMyBteC0zIGNsZWFyLWJvdGhcIj5cclxuICAgICAgICAgICAgPCEtLSB7dGhpcy5hbGxfc3RlcHMubWFwKChpdGVtLCBpbmRleCkgPT4gLS0+XHJcbiAgICAgICAgICAgIHsjZWFjaCBhbGxfc3RlcHMgYXMgaXRlbSxpbmRleH1cclxuICAgICAgICAgICAgICAgIDxmaWVsZHNldCBrZXk9e2luZGV4fSBzdHlsZT17J2JvcmRlcjoxcHggc29saWQgZ3JleSd9IGNsYXNzPVwibmV3X3N0ZXBzIHNlcV9pbmJveCBmdyBzaGFkb3ctc20gbWItMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsZWdlbmQgY2xhc3M9XCJmb250MTggbWIgbXMtMiBwbC0xXCIgc3R5bGU9eyd3aWR0aDoxZW07ZmxvYXQ6bm9uZTsnfT57aW5kZXgrMX08L2xlZ2VuZD5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1pbmxpbmUtYmxvY2sgdGFibGVfd2lkdGggbXMtMiBwbC0xIHBiLTIgbWItMVwiIHN0eWxlPXsnd2lkdGg6OTclOyd9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zZXE9e2luZGV4fSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidGlueW1jZS1lZGl0b3ItcmVzIHN0ZXBzX2VkaXQgcC0xIGJvcmRlciBmaWxsQXV0aG9yXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPXtgZmlsbEF1dGhvcl8ke2luZGV4fWB9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9eydwYWRkaW5nOjAgOHB4O292ZXJmbG93OmF1dG87b3V0bGluZTpub25lJ30gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWRpdGFibGU9e3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXRleHQ9XCJFbnRlciB0ZXh0IGhlcmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246a2V5dXA9eyhlKT0+e2hhbmRsZURpc2FibGUoaW5kZXgsZSl9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtAaHRtbCBpdGVtLl9fY2RhdGF9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2aWV3X2NoZWNrYm94IGQtaW5saW5lLWJsb2NrIGxpZ2h0LWN5YW4tYmcgcHgtMiBwLTEgZnVsbC13aWR0aCBmd2lkdGhcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGVzdCBkLWlubGluZS1ibG9ja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBvaW50ZXIgZC1pbmxpbmUtYmxvY2sgcGxhaW5fdGV4dFwiIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIHRpdGxlPVwiRG9uJ3QgdXNlIGFueSBpbnRlcmFjdGl2ZSBpdGVtIVwiIGZvcj17YHZpZXdvbmx5X3JhZGlvXyR7aW5kZXh9YH0+e2wucGxhaW5fdGV4dH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdC1wZXJjZW50IG1zLTRcIiBzdHlsZT17J2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlOyd9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb3JtLWNoZWNrIGZvcm0tc3dpdGNoXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIGlkPXtcInN3aXRjaEVsZW1lbnRcIitpbmRleH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17KGl0ZW0udG9nZ2xlID09IFwiMVwiPyBmYWxzZTogdHJ1ZSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17KGUpPT57aGFuZGxlUmFkaW8oaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgsZSl9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcj1cInByaW1hcnlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPXtcInN3aXRjaEVsZW1lbnRcIitpbmRleH0+e2wuaW50ZXJhY3RpdmV9PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiBcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1pbmxpbmUtYmxvY2sgcGxhaW5fdGV4dCBtcy0zXCIgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZXNfY2hlY2tib3ggZC1pbmxpbmUtYmxvY2sgbXMtMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGVja19ib3ggZC1pbmxpbmUtYmxvY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8IS0tIHsoaXRlbS5fbW9kZSA9PSBcIjFcIikgPyAtLT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uX21vZGUgPT0gXCIxXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBkYXRhLXNlcT17aW5kZXh9IGNsYXNzPVwiaW5uZXJfaW5wdXRzIG9wdGlvbl9jaGVja2JveFwiIG9uOmNsaWNrPXsoZSk9PntoYW5kbGVDaGFuZ2VDaGVja2JveChpbmRleCwgJ2ZpbGxBdXRob3JfJytpbmRleCxlKX19IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwibW9kZVwiIG5hbWU9XCJtb2RlX2NoZWNrYm94X1wiIGlkPXtgbW9kZV9jaGVja2JveF8ke2luZGV4fWB9IGNoZWNrZWQ9e3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGF0YS1zZXE9e2luZGV4fSBjbGFzcz1cImlubmVyX2lucHV0cyBvcHRpb25fY2hlY2tib3hcIiBvbjpjbGljaz17KGUpPT57aGFuZGxlQ2hhbmdlQ2hlY2tib3goaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgsZSl9fSB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIm1vZGVcIiBuYW1lPVwibW9kZV9jaGVja2JveF9cIiBpZD17YG1vZGVfY2hlY2tib3hfJHtpbmRleH1gfSBjaGVja2VkPXtmYWxzZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvbnQtd2VpZ2h0LW5vcm1hbCBtZS0xIHBvc2l0aW9uLXJlbGF0aXZlIHRvcDIgcmlnaHQzNVwiIGZvcj17YG1vZGVfY2hlY2tib3hfJHtpbmRleH1gfT57bC5ub192YWxpZGF0aW9ufTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIHtpbmRleCA9PSAwID8gIC0tPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGluZGV4ID09IDB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RpY2tfY2hlY2tib3ggZC1pbmxpbmUtYmxvY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoZWNrX2JveCBkLWlubGluZS1ibG9ja1wiPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSB7KGl0ZW0uX3N0aWNreSA9PSBcIjFcIikgPyAtLT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBpdGVtLl9zdGlja3kgPT0gXCIxXCJ9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGRhdGEtc2VxPXtpbmRleH0gY2hlY2tlZD17dHJ1ZX0gY2xhc3M9XCJpbm5lcl9pbnB1dHMgb3B0aW9uX2NoZWNrYm94XCIgb246Y2xpY2s9e2hhbmRsZUNoYW5nZUNoZWNrYm94LmJpbmQodGhpcywgaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgpfSB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInN0aWNreVwiIG5hbWU9XCJzdGlja3lfY2hlY2tib3hfXCIgaWQ9e2BzdGlja3lfY2hlY2tib3hfJHtpbmRleH1gfS8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBkYXRhLXNlcT17aW5kZXh9IGNoZWNrZWQ9e2ZhbHNlfSBjbGFzcz1cImlubmVyX2lucHV0cyBvcHRpb25fY2hlY2tib3hcIiBvbjpjbGljaz17aGFuZGxlQ2hhbmdlQ2hlY2tib3guYmluZCh0aGlzLCBpbmRleCwgJ2ZpbGxBdXRob3JfJytpbmRleCl9IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwic3RpY2t5XCIgbmFtZT1cInN0aWNreV9jaGVja2JveF9cIiBpZD17YHN0aWNreV9jaGVja2JveF8ke2luZGV4fWB9Lz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9udC13ZWlnaHQtbm9ybWFsIG1lLTEgcG9zaXRpb24tcmVsYXRpdmUgdG9wMiByaWdodDM1XCIgZm9yPXtgc3RpY2t5X2NoZWNrYm94XyR7aW5kZXh9YH0+e2wuc3RpY2t5fTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn0gXHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17J2Rpc3BsYXk6aW5saW5lLWJsb2NrO2Zsb2F0OnJpZ2h0Oyd9IGNsYXNzPVwiYnV0dG9ucyBlZGl0X3N0ZXBzXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWlubGluZS1ibG9jayBtclwiIHN0eWxlPXsnZGlzcGxheTppbmxpbmUtYmxvY2s7J30gb246Y2xpY2s9eyhlKT0+e2RlbGV0ZUV2ZW50KGluZGV4LCAnc3RlcHMnLGUpfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGlnaHQgZm9udDEyXCI+e2wuZGVsZXRlfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWlubGluZS1ibG9ja1wiIHN0eWxlPXsndGV4dC1hbGlnbjpyaWdodDttYXJnaW4tdG9wOjZweDsnfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9e2BzYXZlX3N0ZXBfJHtpbmRleH1gfSB0eXBlPVwiYnV0dG9uXCIgb246Y2xpY2s9eyhlKT0+e2hhbmRsZVNhdmUoaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgsZSl9fSBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBmb250MTIgc2F2ZV9idXR0b25fc3RlcHNcIj57bC5zYXZlfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcbiAgICAgICAgICAgIDwhLS0gKX0gLS0+XHJcbiAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG14LTMgbXQtMyBwYi0zXCI+XHJcbiAgICAgICAgICAgIDxCdXR0b24gdmFyaWFudD1cImZhYlwiIGNvbG9yPVwicHJpbWFyeVwiIG1pbmkgYXJpYS1sYWJlbD1cIkFkZFwiXHJcbiAgICAgICAgICAgICAgICBvbjpjbGljaz17YWRkRXZlbnQuYmluZCh0aGlzLCAnc3RlcHMnKX1cclxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgcm91bmRlZCBwb3NpdGlvbi1yZWxhdGl2ZSBib3R0b20wIGJnLXdoaXRlIHNoYWRvdy1zbSBoZWlnaHQzMFwiXHJcbiAgICAgICAgICAgICAgICBzdHlsZT17J2Zsb2F0OmxlZnQ7d2lkdGg6MTIwcHg7aGVpZ2h0OjMwcHg7Ym9yZGVyOjFweCBzb2xpZCAjNDI4NWY0O2NvbG9yOiM0Mjg1ZjQ7dGV4dC10cmFuc2Zvcm06bm9uZTsnfT5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udDE4XCI+JiM0MzsgJm5ic3A7PC9zcGFuPiBBZGQgU3RlcFxyXG4gICAgICAgICAgICA8L0J1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8RGlhbG9nIG92ZXJsYXlDbGFzcz1cIm1hdGVyaWFsT3ZlcmxheVwiICBiaW5kOnZpc2libGU9e3N0YXRlLm9wZW59IG9uOmNsb3NlPXtoYW5kbGVDbG9zZS5iaW5kKHRoaXMpfSBkaXNhYmxlRW5mb3JjZUZvY3VzPXt0cnVlfSB3aWR0aD1cIjY1MFwiIGNsYXNzPVwicm93XCIgc3R5bGU9eydiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyd9PlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gPERpYWxvZ1RpdGxlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290OlwicC1tZCBlZGl0b3JfbW9kYWxfdGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+IC0tPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc2xvdD1cInRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtci1sZyBmbG9hdC1sZWZ0XCIgc3R5bGU9eydwYWRkaW5nLXRvcDoxMHB4O3BhZGRpbmctbGVmdDoxM3B4O2ZvbnQtc2l6ZToxOHB4Oyd9PntsLmZpbGxfaGVhZGVyfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsb2F0LXJpZ2h0IG1yLTRcIj5cclxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG10LTEgcm93IG1sLTBcIj5cclxuXHRcdFx0XHRcdFx0XHRcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPXtcImJ0biBidG4tbGlnaHQgY29sLTNcIiArICgoc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID09IDEpPyBcIiBhY3RpdmVcIjogXCJcIil9IHZhbHVlPXsxfSBvbjpjbGljaz17dXBkYXRlRGlhbG9nLmJpbmQodGhpcywgMSl9ID5UZXh0PC9idXR0b24+XHJcblx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz17XCJidG4gYnRuLWxpZ2h0IGNvbC05XCIgKyAoKHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAyKT8gXCIgYWN0aXZlXCI6IFwiXCIpfSB2YWx1ZT17Mn0gb246Y2xpY2s9e3VwZGF0ZURpYWxvZy5iaW5kKHRoaXMsIDIpfSA+TWF0aGVtYXRpY2FsIEVxdWF0aW9uPC9idXR0b24+XHJcblx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gPC9EaWFsb2dUaXRsZT4gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInJlc3BvbnNlRGlhbG9nXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXggbXItMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIndpZHRoMTAwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94ICBpZCA9IFwibnVtZXJpY1wiIGNoZWNrZWQgPSB7c3RhdGUubnVtZXJpY30+e1wiTnVtZXJpY1wifTwvQ2hlY2tib3g+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IFwiaW5wdXQxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7c3RhdGUuaW5wdXRfYW5zfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbCBtci00IG1sLTNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17J21hcmdpbjo1cHgnfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvOmZvY3VzID0ge3RydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0geygoQUguc2VsZWN0KFwiI2lucHV0MVwiKS5pbm5lckhUTUwgIT0gXCJcIik/bC5maWxsX3RleHRfcGxhY2Vob2xkZXI6XCJcIil9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlciBmb250LXdlaWdodC1ib2xkIG1sLTIgbXQtM1wiPiogTm90ZTo8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtZGFuZ2VyIG1sLTJcIiBzdHlsZT17J3RleHQtaW5kZW50OjE1cHgnfT57bC5maWxsX3RleHRfaGVscDF9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlciBtbC0yXCIgc3R5bGU9eyd0ZXh0LWluZGVudDoxNXB4J30+Mi4gUGxlYXNlIGRvIG5vdCBpbmNsdWRlIHNwYWNlLjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXhcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0ge1wiaW5wdXRcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwibGF0ZXhJbnAgZm9ybS1jb250cm9sXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsnbWFyZ2luOjVweDt3aWR0aDo3MSU7J31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvOmZvY3VzID0ge3RydWV9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQgPSBcImNvbnRhaW5lZFwiIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gXCJwcmltYXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsnYm9yZGVyOjFweCBzb2xpZCAjNDI4NWY0O2NvbG9yOiM0Mjg1ZjQ7dGV4dC10cmFuc2Zvcm06bm9uZTsnfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljayA9IHthZGRFZGl0YWJsZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1wcmltYXJ5IGhlaWdodDMwIGJnLXdoaXRlIHNoYWRvdy1zbSBtdC0xIHRvcDEgbWwtMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBZGQgUmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFwibGF0ZXhFZGl0QnV0dG9uIGQtaW5saW5lLWJsb2NrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB7XCJsYXRleEVkaXRcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudCA9IFwiY29udGFpbmVkXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gXCJwcmltYXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7J21hcmdpbjo1cHg7ZGlzcGxheTpub25lOyd9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljayA9IHtsYXRleEVkaXR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWRpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1kYW5nZXIgZm9udC13ZWlnaHQtYm9sZCBtbC0xXCI+KiBOb3RlOjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1kYW5nZXIgbWwtMVwiIHN0eWxlPXsndGV4dC1pbmRlbnQ6IDE1cHg7J30+e2wuZmlsbF9tYXRoX2hlbHAxfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1kYW5nZXIgbWwtMVwiIHN0eWxlPXsndGV4dC1pbmRlbnQ6IDE1cHg7J30+e2wuZmlsbF9tYXRoX2hlbHAyfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn0gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN2ZWx0ZUZvb3RlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHZhcmlhbnQ9XCJjb250YWluZWRcIiBvbjpjbGljaz17aGFuZGxlQ2xvc2V9ID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsLmNhbmNlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHZhcmlhbnQ9XCJjb250YWluZWRcIiBvbjpjbGljaz17c3RvcmVBbnN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJnLXByaW1hcnkgdGV4dC13aGl0ZVwiPntsLmRvbmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvRGlhbG9nPlxyXG48L21haW4+XHJcblxyXG5cclxuICAgIFxyXG5cclxuXHJcbjxzdHlsZT5cclxuICAgIC5mb250MTgge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcclxuICAgIH1cclxuICAgIC5md2lkdGggICB7XHJcbiAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICB9XHJcblxyXG4gICAgLmxpZ2h0LWN5YW4tYmcge1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkNGU0ZmY7IFxyXG4gICAgICAgIGNvbG9yOiAjMzMzO1xyXG4gICAgfVxyXG5cclxuICAgIC50b3AyIHtcclxuICAgICAgICB0b3A6IDJweDtcclxuICAgIH1cclxuICAgIC5yaWdodDUge1xyXG4gICAgICAgIHJpZ2h0OiA1cHg7XHJcbiAgICB9XHJcblxyXG4gICAgLnJpZ2h0MzUge1xyXG4gICAgICAgIHJpZ2h0OiAzNXB4O1xyXG4gICAgfVxyXG5cclxuICAgIC5zdGVwX2NoZWNrYm94IHtcclxuICAgICAgICB3aWR0aDogMjIlO1xyXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICBib3R0b206IDFweDtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgcGFkZGluZzogM3B4IDJweCAwO1xyXG4gICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAvKiAuc3RlcHNfZWRpdDplbXB0eTpiZWZvcmUge1xyXG4gICAgICAgIGNvbnRlbnQ6IGF0dHIoZGF0YS10ZXh0KSxcclxuICAgICAgICBjb250ZW50LWVkaXRhYmxlOmZhbHNlO1xyXG4gICAgfSAqL1xyXG5cclxuICAgIC5maXhlZF9hbnMge1xyXG4gICAgICAgIHRvcDogMTBweDtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgZmxvYXQ6IHJpZ2h0O1xyXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNlMGUwZTA7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTtcclxuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgICAgICAgcGFkZGluZzogNXB4O1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTVweDtcclxuICAgICAgICBmb250LXdlaWdodDogNzAwO1xyXG4gICAgfVxyXG5cclxuICAgIC5jaGVja19ib3gge1xyXG4gICAgICAgIHJpZ2h0OiAyNHB4O1xyXG4gICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xyXG4gICAgICAgIHdpZHRoOiA0MHB4O1xyXG4gICAgfVxyXG5cclxuICAgIC5pbm5lcl9pbnB1dHMge1xyXG4gICAgICAgIG1hcmdpbjogMCAxMnB4IWltcG9ydGFudDtcclxuICAgIH0gICAgICBcclxuICAgIFxyXG4gICAgLnBvaW50ZXIge1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlciAhaW1wb3J0YW50O1xyXG4gICAgfVxyXG5cclxuICAgIC53aWR0aDEwMCB7d2lkdGg6IDEwMHB4O31cclxuXHJcbiAgICAvKiAuZWRpdF9zdGVwcyB7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogMTFweCFpbXBvcnRhbnQ7XHJcbiAgICB9XHJcbiAgICAudmlld19jaGVja2JveCB7XHJcbiAgICAgICAgaGVpZ2h0OiA3NXB4O1xyXG4gICAgfVxyXG4gICAgLnBsYWluX3RleHQge1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICBib3R0b206IDIwcHg7XHJcbiAgICB9ICovXHJcblxyXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0pIHtcclxuICAgICAgICBvdmVyZmxvdzpoaWRkZW47XHJcbiAgICAgICAgLyp3aWR0aDo3MDBweDsgIHRlc3RpbmcqL1xyXG4gICAgICAgIHRleHQtYWxpZ246bGVmdDtcclxuICAgIH1cclxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIHByZSkge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XHJcbiAgICAgICAgYm9yZGVyOiBub25lO1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweCFpbXBvcnRhbnQ7XHJcbiAgICB9XHJcbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuc3RyaW5nKSB7XHJcbiAgICAgICAgbWluLWhlaWdodDo1MHB4O1xyXG4gICAgICAgIG1hcmdpbi10b3A6MTBweDtcclxuICAgICAgICBtYXJnaW4tcmlnaHQ6MTBweDtcclxuICAgIH1cclxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5mb290ZXJzdHIpIHtcclxuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcclxuICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNjY2M7XHJcbiAgICAgICAgcGFkZGluZzogMTVweDtcclxuICAgICAgICBtaW4taGVpZ2h0OiA2MHB4Oy8qMTAwcHg7Ki9cclxuICAgIH1cclxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5mb290ZXJzdHIgLmFycm93LXVwKSB7XHJcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgIHRvcDogLTEwcHg7XHJcbiAgICAgICAgcmlnaHQ6IDUwJTtcclxuICAgICAgICB3aWR0aDogMDtcclxuICAgICAgICBoZWlnaHQ6IDA7XHJcbiAgICAgICAgYm9yZGVyLWxlZnQ6IDEwcHggc29saWQgdHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxMHB4IHNvbGlkIHRyYW5zcGFyZW50O1xyXG4gICAgICAgIGJvcmRlci1ib3R0b206IDEwcHggc29saWQgI2NjYztcclxuICAgIH1cclxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5maWxsLXJvdykge1xyXG4gICAgICAgIHBhZGRpbmc6NnB4O1xyXG4gICAgfVxyXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZpbGxlbGVtZW50LCBbaWRePVwiZmlsbG1haW5cIl0gLmRyYWctcmVzaXplKSB7XHJcbiAgICAgICAgaGVpZ2h0OjMwcHg7XHJcbiAgICAgICAgZGlzcGxheTppbmxpbmUtYmxvY2s7XHJcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XHJcbiAgICAgICAgbWluLWhlaWdodDogMzBweDtcclxuICAgICAgICBtYXJnaW46IDFweDtcclxuICAgIH1cclxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIGlucHV0W3R5cGU9XCJ0ZXh0XCJdLCBbaWRePVwiZmlsbG1haW5cIl0gc2VsZWN0KSB7XHRcclxuICAgICAgICBoZWlnaHQ6OTklIWltcG9ydGFudDtcclxuICAgICAgICByZXNpemU6IG5vbmU7XHJcbiAgICAgICAgZm9udC1zaXplOjEycHg7XHJcbiAgICAgICAgY29sb3I6ICMwMDA7XHJcbiAgICAgICAgbWF4LXdpZHRoOiA4MDBweDtcclxuICAgIH1cclxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5kcmFnLXJlc2l6ZSkge1xyXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOm1pZGRsZTtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkICMzMUI3MzE7XHJcbiAgICAgICAgdGV4dC1hbGlnbjpjZW50ZXI7XHJcbiAgICAgICAgcGFkZGluZzozcHg7XHJcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xyXG4gICAgfVxyXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmRyYWctcmVzaXplLnVpLWRyYWdnYWJsZSkge1xyXG4gICAgICAgIGN1cnNvcjptb3ZlO1xyXG4gICAgfVxyXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmRyb3AtaG92ZXIpIHtcclxuICAgICAgICBib3JkZXI6IDFweCBkYXNoZWQgcmVkIWltcG9ydGFudDtcclxuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAycHggeWVsbG93IGluc2V0O1xyXG4gICAgICAgIG91dGxpbmU6IDFweCBzb2xpZCBibHVlO1xyXG4gICAgfVxyXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZpbGxjaGVjayB1bCkge1xyXG4gICAgICAgIHdpZHRoOjIyMHB4O1xyXG4gICAgfVxyXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZpbGxjaGVjayBsaS5zZWxlY3RlZCkge1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNFNUU1RTU7XHJcbiAgICB9XHJcbiAgICA6Z2xvYmFsKC5maWxsY2hlY2sgLnNlbGVjdGVkIC5pY29tb29uLWNoZWNrbWFyay0zOmJlZm9yZSkge1xyXG4gICAgICAgIGZsb2F0OiBsZWZ0O1xyXG4gICAgICAgIGNvbG9yOiBibHVlO1xyXG4gICAgICAgIHBhZGRpbmc6IDNweDtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgcmlnaHQ6IDE0cHg7XHJcbiAgICB9XHJcbiAgICA6Z2xvYmFsKC5maWxsY2hlY2sgLmljb21vb24tY2xvc2UtMjpiZWZvcmUpIHtcclxuICAgICAgICBmbG9hdDogbGVmdDtcclxuICAgICAgICBjb2xvcjogYmx1ZTtcclxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgICAgcmlnaHQ6IDE0cHg7XHJcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xyXG4gICAgfVxyXG4gICAgOmdsb2JhbCguTWF0aEpheF9EaXNwbGF5KSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXkgOiBpbmxpbmUhaW1wb3J0YW50O1xyXG4gICAgfVxyXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLnNlbGVjdCkge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTVweDtcclxuICAgIH1cclxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC50ZXh0YXJlYSkge1xyXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOm1pZGRsZTtcclxuICAgICAgICBib3JkZXItcmFkaXVzOjNweDtcclxuICAgICAgICBiYWNrZ3JvdW5kOiNmZmU7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcclxuICAgICAgICAtd2Via2l0LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLDAuMDc1KTtcclxuICAgICAgICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwwLjA3NSk7XHJcbiAgICB9XHJcbiAgICA6Z2xvYmFsKC51aS1kcmFnZ2FibGUtZGlzYWJsZWQpIHtcclxuICAgICAgICBjdXJzb3I6IG5vLWRyb3AhaW1wb3J0YW50O1xyXG4gICAgICAgIG9wYWNpdHk6IDAuNSFpbXBvcnRhbnQ7XHJcbiAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBOHZCSSxPQUFPLGNBQUMsQ0FBQyxBQUNMLFNBQVMsQ0FBRSxJQUFJLEFBQ25CLENBQUMsQUFDRCxPQUFPLGNBQUcsQ0FBQyxBQUNQLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUVELGNBQWMsY0FBQyxDQUFDLEFBQ1osZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxLQUFLLGNBQUMsQ0FBQyxBQUNILEdBQUcsQ0FBRSxHQUFHLEFBQ1osQ0FBQyxBQUNELE9BQU8sY0FBQyxDQUFDLEFBQ0wsS0FBSyxDQUFFLEdBQUcsQUFDZCxDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDTixLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxjQUFjLGNBQUMsQ0FBQyxBQUNaLEtBQUssQ0FBRSxHQUFHLENBQ1YsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUN2QixXQUFXLENBQUUsSUFBSSxDQUNqQixRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsR0FBRyxDQUNYLE1BQU0sQ0FBRSxPQUFPLENBQ2YsT0FBTyxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUN0QixDQUFDLEFBT0QsVUFBVSxjQUFDLENBQUMsQUFDUixHQUFHLENBQUUsSUFBSSxDQUNULFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxLQUFLLENBQ1osTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUN6QixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxHQUFHLENBQ1osU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsR0FBRyxBQUNwQixDQUFDLEFBRUQsVUFBVSxjQUFDLENBQUMsQUFDUixLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsUUFBUSxDQUNqQixLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxhQUFhLGNBQUMsQ0FBQyxBQUNYLE1BQU0sQ0FBRSxDQUFDLENBQUMsSUFBSSxVQUFVLEFBQzVCLENBQUMsQUFFRCxRQUFRLGNBQUMsQ0FBQyxBQUNOLE1BQU0sQ0FBRSxPQUFPLENBQUMsVUFBVSxBQUM5QixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsS0FBSyxDQUFFLEtBQUssQUFBQyxDQUFDLEFBYWpCLGdCQUFnQixBQUFFLENBQUMsQUFDdkIsU0FBUyxNQUFNLENBRWYsV0FBVyxJQUFJLEFBQ25CLENBQUMsQUFDTyxvQkFBb0IsQUFBRSxDQUFDLEFBQzNCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxJQUFJLENBQ1osU0FBUyxDQUFFLElBQUksVUFBVSxBQUM3QixDQUFDLEFBQ08sd0JBQXdCLEFBQUUsQ0FBQyxBQUMvQixXQUFXLElBQUksQ0FDZixXQUFXLElBQUksQ0FDZixhQUFhLElBQUksQUFDckIsQ0FBQyxBQUNPLDJCQUEyQixBQUFFLENBQUMsQUFDbEMsU0FBUyxRQUFRLENBQ2pCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLGdCQUFnQixDQUFFLElBQUksQ0FDdEIsT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsSUFBSSxBQUNwQixDQUFDLEFBQ08scUNBQXFDLEFBQUUsQ0FBQyxBQUM1QyxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsS0FBSyxDQUNWLEtBQUssQ0FBRSxHQUFHLENBQ1YsS0FBSyxDQUFFLENBQUMsQ0FDUixNQUFNLENBQUUsQ0FBQyxDQUNULFdBQVcsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FDbkMsWUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUNwQyxhQUFhLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEFBQ2xDLENBQUMsQUFDTywwQkFBMEIsQUFBRSxDQUFDLEFBQ2pDLFFBQVEsR0FBRyxBQUNmLENBQUMsQUFDTyw0REFBNEQsQUFBRSxDQUFDLEFBQ25FLE9BQU8sSUFBSSxDQUNYLFFBQVEsWUFBWSxDQUNwQixTQUFTLFFBQVEsQ0FDakIsVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLEdBQUcsQUFDZixDQUFDLEFBQ08sNERBQTRELEFBQUUsQ0FBQyxBQUNuRSxPQUFPLEdBQUcsVUFBVSxDQUNwQixNQUFNLENBQUUsSUFBSSxDQUNaLFVBQVUsSUFBSSxDQUNkLEtBQUssQ0FBRSxJQUFJLENBQ1gsU0FBUyxDQUFFLEtBQUssQUFDcEIsQ0FBQyxBQUNPLDZCQUE2QixBQUFFLENBQUMsQUFDcEMsZUFBZSxNQUFNLENBQ3JCLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQ3hCLFdBQVcsTUFBTSxDQUNqQixRQUFRLEdBQUcsQ0FDWCxTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBQ08sMENBQTBDLEFBQUUsQ0FBQyxBQUNqRCxPQUFPLElBQUksQUFDZixDQUFDLEFBQ08sNEJBQTRCLEFBQUUsQ0FBQyxBQUNuQyxNQUFNLENBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLFVBQVUsQ0FDaEMsVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNsQyxPQUFPLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEFBQzNCLENBQUMsQUFDTyw4QkFBOEIsQUFBRSxDQUFDLEFBQ3JDLE1BQU0sS0FBSyxBQUNmLENBQUMsQUFDTyx1Q0FBdUMsQUFBRSxDQUFDLEFBQzlDLGdCQUFnQixDQUFFLE9BQU8sQUFDN0IsQ0FBQyxBQUNPLGdEQUFnRCxBQUFFLENBQUMsQUFDdkQsS0FBSyxDQUFFLElBQUksQ0FDWCxLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxHQUFHLENBQ1osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQUFDZixDQUFDLEFBQ08sa0NBQWtDLEFBQUUsQ0FBQyxBQUN6QyxLQUFLLENBQUUsSUFBSSxDQUNYLEtBQUssQ0FBRSxJQUFJLENBQ1gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBQ08sZ0JBQWdCLEFBQUUsQ0FBQyxBQUNuQixPQUFPLENBQUcsTUFBTSxVQUFVLEFBQ2xDLENBQUMsQUFDTyx3QkFBd0IsQUFBRSxDQUFDLEFBQy9CLFNBQVMsQ0FBRSxJQUFJLEFBQ25CLENBQUMsQUFDTywwQkFBMEIsQUFBRSxDQUFDLEFBQ2pDLGVBQWUsTUFBTSxDQUNyQixjQUFjLEdBQUcsQ0FDakIsV0FBVyxJQUFJLENBQ2YsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN0QixrQkFBa0IsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FDckQsVUFBVSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxBQUNqRCxDQUFDLEFBQ08sc0JBQXNCLEFBQUUsQ0FBQyxBQUM3QixNQUFNLENBQUUsT0FBTyxVQUFVLENBQ3pCLE9BQU8sQ0FBRSxHQUFHLFVBQVUsQUFDMUIsQ0FBQyJ9 */";
	append_dev(document_1.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

// (568:20) <Checkbox                            id="go_next"                           defaultChecked = {state.gonext ? true: false}                           on:click={(e)=>{goNext("go_next",e)}}                       >
function create_default_slot_8(ctx) {
	let t_value = "Go Next" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(568:20) <Checkbox                            id=\\\"go_next\\\"                           defaultChecked = {state.gonext ? true: false}                           on:click={(e)=>{goNext(\\\"go_next\\\",e)}}                       >",
		ctx
	});

	return block;
}

// (576:20) <Checkbox                            id="fixedans_checkbox"                           defaultChecked = {state.variable_button ? true: false}                           on:click={(e)=>{fixedAnswer("fixedans_checkbox",e)}}                       >
function create_default_slot_7(ctx) {
	let t_value = "Fix Answer" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(576:20) <Checkbox                            id=\\\"fixedans_checkbox\\\"                           defaultChecked = {state.variable_button ? true: false}                           on:click={(e)=>{fixedAnswer(\\\"fixedans_checkbox\\\",e)}}                       >",
		ctx
	});

	return block;
}

// (625:32) {:else}
function create_else_block_2(ctx) {
	let checkbox;
	let current;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[23](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: false
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_3);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(625:32) {:else}",
		ctx
	});

	return block;
}

// (622:32) {#if item._mode == "1"}
function create_if_block_3(ctx) {
	let checkbox;
	let current;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[22](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: true
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_2);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(622:32) {#if item._mode == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (634:24) {#if index == 0}
function create_if_block_1(ctx) {
	let div;
	let span;
	let current_block_type_index;
	let if_block;
	let t0;
	let label;
	let label_for_value;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[38]._sticky == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if_block.c();
			t0 = space();
			label = element("label");
			label.textContent = `${language.sticky}`;
			attr_dev(span, "class", "check_box d-inline-block svelte-smsdwz");
			add_location(span, file, 635, 32, 25199);
			attr_dev(label, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-smsdwz");
			attr_dev(label, "for", label_for_value = `sticky_checkbox_${/*index*/ ctx[40]}`);
			add_location(label, file, 644, 32, 26099);
			attr_dev(div, "class", "stick_checkbox d-inline-block");
			add_location(div, file, 634, 28, 25122);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			if_blocks[current_block_type_index].m(span, null);
			append_dev(div, t0);
			append_dev(div, label);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(span, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(634:24) {#if index == 0}",
		ctx
	});

	return block;
}

// (641:36) {:else}
function create_else_block_1(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: false,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], "fillAuthor_" + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(641:36) {:else}",
		ctx
	});

	return block;
}

// (639:36) {#if item._sticky == "1"}
function create_if_block_2(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: true,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], "fillAuthor_" + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(639:36) {#if item._sticky == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (587:12) {#each all_steps as item,index}
function create_each_block(ctx) {
	let fieldset;
	let legend;
	let t0_value = /*index*/ ctx[40] + 1 + "";
	let t0;
	let legend_style_value;
	let t1;
	let div1;
	let div0;
	let raw_value = /*item*/ ctx[38].__cdata + "";
	let div0_data_seq_value;
	let div0_id_value;
	let div0_style_value;
	let div0_contenteditable_value;
	let div1_style_value;
	let t2;
	let div8;
	let div2;
	let span0;
	let span0_for_value;
	let t4;
	let span2;
	let span1;
	let input;
	let input_id_value;
	let input_checked_value;
	let t5;
	let label0;
	let label0_for_value;
	let span2_style_value;
	let t7;
	let div4;
	let div3;
	let span3;
	let current_block_type_index;
	let if_block0;
	let t8;
	let label1;
	let label1_for_value;
	let t10;
	let t11;
	let div7;
	let div5;
	let button0;
	let div5_style_value;
	let t13;
	let div6;
	let button1;
	let button1_id_value;
	let div6_style_value;
	let div7_style_value;
	let fieldset_key_value;
	let fieldset_style_value;
	let t15;
	let current;
	let mounted;
	let dispose;

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[20](/*index*/ ctx[40], ...args);
	}

	function change_handler(...args) {
		return /*change_handler*/ ctx[21](/*index*/ ctx[40], ...args);
	}

	const if_block_creators = [create_if_block_3, create_else_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[38]._mode == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*index*/ ctx[40] == 0 && create_if_block_1(ctx);

	function click_handler_4(...args) {
		return /*click_handler_4*/ ctx[24](/*index*/ ctx[40], ...args);
	}

	function click_handler_5(...args) {
		return /*click_handler_5*/ ctx[25](/*index*/ ctx[40], ...args);
	}

	const block = {
		c: function create() {
			fieldset = element("fieldset");
			legend = element("legend");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			t2 = space();
			div8 = element("div");
			div2 = element("div");
			span0 = element("span");
			span0.textContent = `${language.plain_text}`;
			t4 = space();
			span2 = element("span");
			span1 = element("span");
			input = element("input");
			t5 = space();
			label0 = element("label");
			label0.textContent = `${language.interactive}`;
			t7 = space();
			div4 = element("div");
			div3 = element("div");
			span3 = element("span");
			if_block0.c();
			t8 = space();
			label1 = element("label");
			label1.textContent = `${language.no_validation}`;
			t10 = space();
			if (if_block1) if_block1.c();
			t11 = space();
			div7 = element("div");
			div5 = element("div");
			button0 = element("button");
			button0.textContent = `${language.delete}`;
			t13 = space();
			div6 = element("div");
			button1 = element("button");
			button1.textContent = `${language.save}`;
			t15 = space();
			attr_dev(legend, "class", "font18 mb ms-2 pl-1 svelte-smsdwz");
			attr_dev(legend, "style", legend_style_value = "width:1em;float:none;");
			add_location(legend, file, 588, 20, 21819);
			attr_dev(div0, "data-seq", div0_data_seq_value = /*index*/ ctx[40]);
			attr_dev(div0, "class", "tinymce-editor-res steps_edit p-1 border fillAuthor");
			attr_dev(div0, "id", div0_id_value = `fillAuthor_${/*index*/ ctx[40]}`);
			attr_dev(div0, "style", div0_style_value = "padding:0 8px;overflow:auto;outline:none");
			attr_dev(div0, "contenteditable", div0_contenteditable_value = true);
			attr_dev(div0, "data-text", "Enter text here");
			add_location(div0, file, 590, 24, 22034);
			attr_dev(div1, "class", "d-inline-block table_width ms-2 pl-1 pb-2 mb-1");
			attr_dev(div1, "style", div1_style_value = "width:97%;");
			add_location(div1, file, 589, 20, 21927);
			attr_dev(span0, "class", "pointer d-inline-block plain_text svelte-smsdwz");
			attr_dev(span0, "data-toggle", "tooltip");
			attr_dev(span0, "title", "Don't use any interactive item!");
			attr_dev(span0, "for", span0_for_value = `viewonly_radio_${/*index*/ ctx[40]}`);
			add_location(span0, file, 604, 24, 22811);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "form-check-input");
			attr_dev(input, "id", input_id_value = "switchElement" + /*index*/ ctx[40]);
			input.checked = input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true;
			attr_dev(input, "color", "primary");
			add_location(input, file, 607, 32, 23183);
			attr_dev(label0, "for", label0_for_value = "switchElement" + /*index*/ ctx[40]);
			add_location(label0, file, 612, 32, 23558);
			attr_dev(span1, "class", "form-check form-switch");
			add_location(span1, file, 606, 28, 23112);
			attr_dev(span2, "class", "stat-percent ms-4");
			attr_dev(span2, "style", span2_style_value = "display:inline-block;position:relative;");
			add_location(span2, file, 605, 24, 23000);
			attr_dev(div2, "class", "test d-inline-block");
			add_location(div2, file, 603, 20, 22752);
			attr_dev(span3, "class", "check_box d-inline-block svelte-smsdwz");
			add_location(span3, file, 619, 28, 23920);
			attr_dev(label1, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-smsdwz");
			attr_dev(label1, "for", label1_for_value = `mode_checkbox_${/*index*/ ctx[40]}`);
			add_location(label1, file, 630, 28, 24843);
			attr_dev(div3, "class", "modes_checkbox d-inline-block ms-2");
			add_location(div3, file, 618, 24, 23842);
			attr_dev(div4, "class", "d-inline-block plain_text ms-3");
			add_location(div4, file, 617, 20, 23771);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-light font12");
			add_location(button0, file, 650, 28, 26581);
			attr_dev(div5, "class", "d-inline-block mr");
			attr_dev(div5, "style", div5_style_value = "display:inline-block;");
			add_location(div5, file, 649, 24, 26440);
			attr_dev(button1, "id", button1_id_value = `save_step_${/*index*/ ctx[40]}`);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-primary font12 save_button_steps");
			add_location(button1, file, 653, 28, 26811);
			attr_dev(div6, "class", "d-inline-block");
			attr_dev(div6, "style", div6_style_value = "text-align:right;margin-top:6px;");
			add_location(div6, file, 652, 24, 26710);
			attr_dev(div7, "style", div7_style_value = "display:inline-block;float:right;");
			attr_dev(div7, "class", "buttons edit_steps");
			add_location(div7, file, 648, 20, 26338);
			attr_dev(div8, "class", "view_checkbox d-inline-block light-cyan-bg px-2 p-1 full-width fwidth svelte-smsdwz");
			add_location(div8, file, 602, 20, 22647);
			attr_dev(fieldset, "key", fieldset_key_value = /*index*/ ctx[40]);
			attr_dev(fieldset, "style", fieldset_style_value = "border:1px solid grey");
			attr_dev(fieldset, "class", "new_steps seq_inbox fw shadow-sm mb-2");
			add_location(fieldset, file, 587, 16, 21697);
		},
		m: function mount(target, anchor) {
			insert_dev(target, fieldset, anchor);
			append_dev(fieldset, legend);
			append_dev(legend, t0);
			append_dev(fieldset, t1);
			append_dev(fieldset, div1);
			append_dev(div1, div0);
			div0.innerHTML = raw_value;
			append_dev(fieldset, t2);
			append_dev(fieldset, div8);
			append_dev(div8, div2);
			append_dev(div2, span0);
			append_dev(div2, t4);
			append_dev(div2, span2);
			append_dev(span2, span1);
			append_dev(span1, input);
			append_dev(span1, t5);
			append_dev(span1, label0);
			append_dev(div8, t7);
			append_dev(div8, div4);
			append_dev(div4, div3);
			append_dev(div3, span3);
			if_blocks[current_block_type_index].m(span3, null);
			append_dev(div3, t8);
			append_dev(div3, label1);
			append_dev(div4, t10);
			if (if_block1) if_block1.m(div4, null);
			append_dev(div8, t11);
			append_dev(div8, div7);
			append_dev(div7, div5);
			append_dev(div5, button0);
			append_dev(div7, t13);
			append_dev(div7, div6);
			append_dev(div6, button1);
			insert_dev(target, t15, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "keyup", keyup_handler, false, false, false),
					listen_dev(input, "change", change_handler, false, false, false),
					listen_dev(div5, "click", click_handler_4, false, false, false),
					listen_dev(button1, "click", click_handler_5, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*all_steps*/ 2) && raw_value !== (raw_value = /*item*/ ctx[38].__cdata + "")) div0.innerHTML = raw_value;
			if (!current || dirty[0] & /*all_steps*/ 2 && input_checked_value !== (input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true)) {
				prop_dev(input, "checked", input_checked_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(span3, null);
			}

			if (/*index*/ ctx[40] == 0) if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(fieldset);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t15);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(587:12) {#each all_steps as item,index}",
		ctx
	});

	return block;
}

// (663:12) <Button variant="fab" color="primary" mini aria-label="Add"                  on:click={addEvent.bind(this, 'steps')}                  class="btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30"                  style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>
function create_default_slot_6(ctx) {
	let span;
	let t1;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "+ ";
			t1 = text(" Add Step");
			attr_dev(span, "class", "font18 svelte-smsdwz");
			add_location(span, file, 666, 16, 27587);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			insert_dev(target, t1, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(663:12) <Button variant=\\\"fab\\\" color=\\\"primary\\\" mini aria-label=\\\"Add\\\"                  on:click={addEvent.bind(this, 'steps')}                  class=\\\"btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30\\\"                  style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>",
		ctx
	});

	return block;
}

// (676:20) <div slot="title">
function create_title_slot(ctx) {
	let div0;
	let div1;
	let div1_style_value;
	let t1;
	let div3;
	let div2;
	let button0;
	let t2;
	let button0_class_value;
	let button0_value_value;
	let t3;
	let button1;
	let t4;
	let button1_class_value;
	let button1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			div1.textContent = `${language.fill_header}`;
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			button0 = element("button");
			t2 = text("Text");
			t3 = space();
			button1 = element("button");
			t4 = text("Mathematical Equation");
			attr_dev(div1, "class", "mr-lg float-left");
			attr_dev(div1, "style", div1_style_value = "padding-top:10px;padding-left:13px;font-size:18px;");
			add_location(div1, file, 676, 24, 28131);
			attr_dev(button0, "type", "button");

			attr_dev(button0, "class", button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-smsdwz"));

			button0.value = button0_value_value = 1;
			add_location(button0, file, 680, 8, 28381);
			attr_dev(button1, "type", "button");

			attr_dev(button1, "class", button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-smsdwz"));

			button1.value = button1_value_value = 2;
			add_location(button1, file, 681, 8, 28559);
			attr_dev(div2, "class", "btn-group mt-1 row ml-0");
			add_location(div2, file, 679, 7, 28334);
			attr_dev(div3, "class", "float-right mr-4");
			add_location(div3, file, 678, 24, 28295);
			attr_dev(div0, "slot", "title");
			add_location(div0, file, 675, 20, 28087);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
			append_dev(div0, t1);
			append_dev(div0, div3);
			append_dev(div3, div2);
			append_dev(div2, button0);
			append_dev(button0, t2);
			append_dev(div2, t3);
			append_dev(div2, button1);
			append_dev(button1, t4);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*updateDialog*/ ctx[11].bind(this, 1), false, false, false),
					listen_dev(button1, "click", /*updateDialog*/ ctx[11].bind(this, 2), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1 && button0_class_value !== (button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-smsdwz"))) {
				attr_dev(button0, "class", button0_class_value);
			}

			if (dirty[0] & /*state*/ 1 && button1_class_value !== (button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-smsdwz"))) {
				attr_dev(button1, "class", button1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot.name,
		type: "slot",
		source: "(676:20) <div slot=\\\"title\\\">",
		ctx
	});

	return block;
}

// (710:28) {:else}
function create_else_block(ctx) {
	let div5;
	let div1;
	let input;
	let input_id_value;
	let input_style_value;
	let input_auto_focus_value;
	let t0;
	let button0;
	let t1;
	let div0;
	let button1;
	let t2;
	let div2;
	let t4;
	let div3;
	let div3_style_value;
	let t6;
	let div4;
	let div4_style_value;
	let current;

	button0 = new Button({
			props: {
				variant: "contained",
				color: "primary",
				style: "border:1px solid #4285f4;color:#4285f4;text-transform:none;",
				class: "btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", addEditable);

	button1 = new Button({
			props: {
				id: "latexEdit",
				variant: "contained",
				color: "primary",
				style: "margin:5px;display:none;",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*latexEdit*/ ctx[12]);

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			input = element("input");
			t0 = space();
			create_component(button0.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(button1.$$.fragment);
			t2 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t4 = space();
			div3 = element("div");
			div3.textContent = `${language.fill_math_help1}`;
			t6 = space();
			div4 = element("div");
			div4.textContent = `${language.fill_math_help2}`;
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = "input");
			attr_dev(input, "class", "latexInp form-control");
			attr_dev(input, "style", input_style_value = "margin:5px;width:71%;");
			attr_dev(input, "auto:focus", input_auto_focus_value = true);
			add_location(input, file, 712, 40, 30638);
			attr_dev(div0, "class", "latexEditButton d-inline-block");
			add_location(div0, file, 729, 40, 31794);
			attr_dev(div1, "class", "d-flex");
			add_location(div1, file, 711, 36, 30576);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-1");
			add_location(div2, file, 741, 36, 32577);
			attr_dev(div3, "class", "text-danger ml-1");
			attr_dev(div3, "style", div3_style_value = "text-indent: 15px;");
			add_location(div3, file, 742, 36, 32675);
			attr_dev(div4, "class", "text-danger ml-1");
			attr_dev(div4, "style", div4_style_value = "text-indent: 15px;");
			add_location(div4, file, 743, 36, 32797);
			add_location(div5, file, 710, 32, 30533);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, input);
			append_dev(div1, t0);
			mount_component(button0, div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);
			mount_component(button1, div0, null);
			append_dev(div5, t2);
			append_dev(div5, div2);
			append_dev(div5, t4);
			append_dev(div5, div3);
			append_dev(div5, t6);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(710:28) {:else}",
		ctx
	});

	return block;
}

// (689:28) {#if state.fillInTheBlanksChoice == 1}
function create_if_block(ctx) {
	let div5;
	let div1;
	let div0;
	let checkbox;
	let t0;
	let input;
	let input_value_value;
	let input_style_value;
	let input_auto_focus_value;
	let input_placeholder_value;
	let t1;
	let div2;
	let t3;
	let div3;
	let div3_style_value;
	let t5;
	let div4;
	let div4_style_value;
	let current;

	checkbox = new Checkbox({
			props: {
				id: "numeric",
				checked: /*state*/ ctx[0].numeric,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			create_component(checkbox.$$.fragment);
			t0 = space();
			input = element("input");
			t1 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t3 = space();
			div3 = element("div");
			div3.textContent = `${language.fill_text_help1}`;
			t5 = space();
			div4 = element("div");
			div4.textContent = "2. Please do not include space.";
			attr_dev(div0, "class", "width100 svelte-smsdwz");
			add_location(div0, file, 691, 40, 29136);
			attr_dev(input, "type", "text");
			attr_dev(input, "id", "input1");
			input.value = input_value_value = /*state*/ ctx[0].input_ans;
			attr_dev(input, "class", "form-control mr-4 ml-3");
			attr_dev(input, "style", input_style_value = "margin:5px");
			attr_dev(input, "auto:focus", input_auto_focus_value = true);

			attr_dev(input, "placeholder", input_placeholder_value = AH.select("#input1").innerHTML != ""
			? language.fill_text_placeholder
			: "");

			add_location(input, file, 695, 44, 29418);
			attr_dev(div1, "class", "d-flex mr-2");
			add_location(div1, file, 690, 36, 29069);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-2 mt-3");
			add_location(div2, file, 705, 36, 30105);
			attr_dev(div3, "class", "text-danger ml-2");
			attr_dev(div3, "style", div3_style_value = "text-indent:15px");
			add_location(div3, file, 706, 36, 30208);
			attr_dev(div4, "class", "text-danger ml-2");
			attr_dev(div4, "style", div4_style_value = "text-indent:15px");
			add_location(div4, file, 707, 36, 30328);
			add_location(div5, file, 689, 32, 29026);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, div0);
			mount_component(checkbox, div0, null);
			append_dev(div1, t0);
			append_dev(div1, input);
			append_dev(div5, t1);
			append_dev(div5, div2);
			append_dev(div5, t3);
			append_dev(div5, div3);
			append_dev(div5, t5);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox_changes.checked = /*state*/ ctx[0].numeric;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);

			if (!current || dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = /*state*/ ctx[0].input_ans) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(checkbox);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(689:28) {#if state.fillInTheBlanksChoice == 1}",
		ctx
	});

	return block;
}

// (721:40) <Button                                               variant = "contained"                                               color = "primary"                                              style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                               on:click = {addEditable}                                              class="btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1"                                          >
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add Response");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(721:40) <Button                                               variant = \\\"contained\\\"                                               color = \\\"primary\\\"                                              style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                               on:click = {addEditable}                                              class=\\\"btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1\\\"                                          >",
		ctx
	});

	return block;
}

// (731:44) <Button                                                   id = {"latexEdit"}                                                  variant = "contained"                                                   color = "primary"                                                  style = {'margin:5px;display:none;'}                                                   on:click = {latexEdit}                                                                                 >
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(731:44) <Button                                                   id = {\\\"latexEdit\\\"}                                                  variant = \\\"contained\\\"                                                   color = \\\"primary\\\"                                                  style = {'margin:5px;display:none;'}                                                   on:click = {latexEdit}                                                                                 >",
		ctx
	});

	return block;
}

// (693:44) <Checkbox  id = "numeric" checked = {state.numeric}>
function create_default_slot_3(ctx) {
	let t_value = "Numeric" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(693:44) <Checkbox  id = \\\"numeric\\\" checked = {state.numeric}>",
		ctx
	});

	return block;
}

// (752:24) <Button variant="contained" on:click={handleClose} >
function create_default_slot_2(ctx) {
	let t0_value = language.cancel + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(752:24) <Button variant=\\\"contained\\\" on:click={handleClose} >",
		ctx
	});

	return block;
}

// (755:24) <Button variant="contained" on:click={storeAns}                              class="bg-primary text-white">
function create_default_slot_1(ctx) {
	let t_value = language.done + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(755:24) <Button variant=\\\"contained\\\" on:click={storeAns}                              class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (670:8) <Dialog overlayClass="materialOverlay"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width="650" class="row" style={'background-color: #fff;'}>
function create_default_slot(ctx) {
	let t0;
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div2;
	let button0;
	let t2;
	let button1;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*state*/ ctx[0].fillInTheBlanksChoice == 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button0 = new Button({
			props: {
				variant: "contained",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleClose*/ ctx[10]);

	button1 = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*storeAns*/ ctx[13]);

	const block = {
		c: function create() {
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			t1 = space();
			div2 = element("div");
			create_component(button0.$$.fragment);
			t2 = text(",\r\n                        ");
			create_component(button1.$$.fragment);
			attr_dev(div0, "id", "responseDialog");
			add_location(div0, file, 687, 24, 28899);
			add_location(div1, file, 686, 20, 28868);
			attr_dev(div2, "class", "svelteFooter");
			add_location(div2, file, 750, 20, 33046);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
			mount_component(button0, div2, null);
			append_dev(div2, t2);
			mount_component(button1, div2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			if_blocks[current_block_type_index].d();
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(670:8) <Dialog overlayClass=\\\"materialOverlay\\\"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width=\\\"650\\\" class=\\\"row\\\" style={'background-color: #fff;'}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div7;
	let div4;
	let div0;
	let div0_style_value;
	let t1;
	let div3;
	let div1;
	let checkbox0;
	let t2;
	let div2;
	let checkbox1;
	let div3_style_value;
	let t3;
	let div5;
	let t4;
	let div6;
	let button;
	let t5;
	let dialog;
	let updating_visible;
	let current;

	checkbox0 = new Checkbox({
			props: {
				id: "go_next",
				defaultChecked: /*state*/ ctx[0].gonext ? true : false,
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*click_handler*/ ctx[18]);

	checkbox1 = new Checkbox({
			props: {
				id: "fixedans_checkbox",
				defaultChecked: /*state*/ ctx[0].variable_button ? true : false,
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*click_handler_1*/ ctx[19]);
	let each_value = /*all_steps*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				mini: true,
				"aria-label": "Add",
				class: "btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30",
				style: "float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addEvent*/ ctx[9].bind(this, "steps"));

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[26].call(null, value);
	}

	let dialog_props = {
		overlayClass: "materialOverlay",
		disableEnforceFocus: true,
		width: "650",
		class: "row",
		style: "background-color: #fff;",
		$$slots: {
			default: [create_default_slot],
			title: [create_title_slot]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[0].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
	dialog.$on("close", /*handleClose*/ ctx[10].bind(this));

	const block = {
		c: function create() {
			main = element("main");
			div7 = element("div");
			div4 = element("div");
			div0 = element("div");
			div0.textContent = `${language.create_steps}`;
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			create_component(checkbox0.$$.fragment);
			t2 = space();
			div2 = element("div");
			create_component(checkbox1.$$.fragment);
			t3 = space();
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div6 = element("div");
			create_component(button.$$.fragment);
			t5 = space();
			create_component(dialog.$$.fragment);
			attr_dev(div0, "class", "d-inline-block pt-1 float-start cr_step");
			attr_dev(div0, "style", div0_style_value = "font-size:20px;position:relative;");
			add_location(div0, file, 563, 12, 20483);
			attr_dev(div1, "class", "modes_checkbox d-inline-block top-checkbox_gonext position-relative top2 svelte-smsdwz");
			add_location(div1, file, 565, 16, 20650);
			attr_dev(div2, "class", "modes_checkbox d-inline-block m-l top-checkbox_fix position-relative top2 svelte-smsdwz");
			add_location(div2, file, 574, 16, 21079);
			attr_dev(div3, "style", div3_style_value = {});
			add_location(div3, file, 564, 12, 20616);
			attr_dev(div4, "class", "border-bottom d-flex justify-content-between px-2 pt-1");
			add_location(div4, file, 562, 8, 20401);
			attr_dev(div5, "class", "outer_steps mt-3 mx-3 clear-both");
			add_location(div5, file, 584, 8, 21529);
			attr_dev(div6, "class", "row mx-3 mt-3 pb-3");
			add_location(div6, file, 661, 8, 27173);
			attr_dev(div7, "class", "mt-imp border");
			add_location(div7, file, 561, 4, 20364);
			add_location(main, file, 560, 0, 20352);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div7);
			append_dev(div7, div4);
			append_dev(div4, div0);
			append_dev(div4, t1);
			append_dev(div4, div3);
			append_dev(div3, div1);
			mount_component(checkbox0, div1, null);
			append_dev(div3, t2);
			append_dev(div3, div2);
			mount_component(checkbox1, div2, null);
			append_dev(div7, t3);
			append_dev(div7, div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_dev(div7, t4);
			append_dev(div7, div6);
			mount_component(button, div6, null);
			append_dev(div7, t5);
			mount_component(dialog, div7, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox0_changes.defaultChecked = /*state*/ ctx[0].gonext ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox1_changes.defaultChecked = /*state*/ ctx[0].variable_button ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);

			if (dirty[0] & /*handleSave, deleteEvent, handleChangeCheckbox, all_steps, handleRadio, handleDisable*/ 498) {
				each_value = /*all_steps*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div5, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const button_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const dialog_changes = {};

			if (dirty[0] & /*state*/ 1 | dirty[1] & /*$$scope*/ 1024) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 1) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[0].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(button.$$.fragment, local);
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(button.$$.fragment, local);
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
			destroy_component(dialog);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function replaceVariables(latex_str) {
	let latex_arr = [];
	let latex_arr_check = latex_str;

	if (latex_arr_check.length == undefined && latex_arr_check != "") {
		latex_arr.push(latex_arr_check);
	} else {
		latex_arr = latex_arr_check;
	}

	latex_arr.map(function (item, index) {
		let cdata = item.__cdata;
		let vars = cdata.match(/<{[\s\S]*?}>/gm);

		if (vars) {
			vars.map(function (element) {
				let item = element.match(/<\{(.*?)\}>/g);
				item = item.toString().replace(/<\{|\}>/g, "");
				item = "var:" + item;
				item = item.trim();
				cdata = cdata.replace(element, item);
			});
		}

		latex_arr[index].__cdata = cdata;
	});

	return latex_arr;
}

function reverseHtmlSpecialChars(data) {
	let tags = data.match(/&lt;(.*?)&gt;/gm);
	let tag = "";

	if (tags) {
		for (var i = 0; i < tags.length; i++) {
			tag = tags[i];
			tags[i] = tags[i].replace(/&lt;/g, "<").replace(/&gt;/g, ">");
			data = data.replace(tag, tags[i]);
		}
	}

	return data;
}

function replaceSpaces(data) {
	let matching = data.match(/var:var\d+\s+\s+/g);
	let match;

	if (matching) {
		matching.map(function (item, index) {
			match = item.trim();
			data = data.replace(item, match);
		});
	}

	return data;
}

function addEditable() {
	//let txt = jQuery("#input");
	let txt = document.querySelector("#input");

	//let caretPos = txt[0].selectionStart;
	let caretPos = txt.selectionStart;

	//let textAreaTxt = txt.val();
	let textAreaTxt = txt.value;

	var txtToAdd = "\\MathQuillMathField";
	var txtToAdd = "user Response";

	//txt.val(textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos));
	txt.value = textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos);
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("StepAlgo", slots, []);
	window.spanCounter = 0;

	// window.currentId = "";
	// window.currentInp = "";
	let state = {};

	let new_xml = {};
	var all_steps = [];
	let { stopAuthoringUpdate } = $$props;
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;

	let stateData = writable({
		xml: "",
		fillInTheBlanksChoice: 1,
		opened: false,
		deleteIndex: "",
		remediationToggle: false,
		snackback: false,
		input_ans: "",
		spanCounter: 0,
		currentId: "",
		currentInp: ""
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	onMount(() => {
		if (xml) {
			new_xml = XMLToJSON(xml);
			showItems(new_xml.smxml.step);

			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select("#sticky_checkbox_0").click();

			//setTimeout(function() {
			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select("#sticky_checkbox_0").click();
		} //}, 1000);

		setTimeout(
			function () {
				//jQuery('.save_button_steps').prop('disabled', 'disabled');
				AH.selectAll(".save_button_steps", "attr", { disabled: "disabled" });

				initEditor();
			},
			500
		);

		// jQuery(document).on("click touchstart", ".editFill", function() {
		// 	if(jQuery(this).attr("type") == "t") {
		// 		editTextbox(jQuery(this).attr("originalKey"));
		// 	} else if(jQuery(this).attr("type") == "e") {
		// 		editMathbox(jQuery(this).attr("originalKey"));
		// 	}
		// })
		AH.listen(document, "click", ".editFill", function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});

		AH.listen(document, "touchstart", ".editFill", function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});
	});

	function editTextbox(key) {
		//console.log('checking');
		key = key.replace(/%{|}%/g, "");

		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";
		$$invalidate(0, state.numeric = ans_type == "n" ? true : false, state);
		$$invalidate(0, state.fillInTheBlanksChoice = 1, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:1});
		//this.setState({open:true});
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//jQuery("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog #customStyleText").value = customStyle[1];

			//jQUery("#input1").val(customStyle[0]);
			//AH.select("#input1").value = customStyle[0];
			$$invalidate(0, state.input_ans = customStyle[0], state);
		} else {
			//jQuery("#input1").val(ans);
			// setTimeout(()=>{
			//     AH.select("#input1").value = ans;
			// },100)
			$$invalidate(0, state.input_ans = ans, state);
		}
	}

	function editMathbox(key) {
		key = key.replace(/%{|}%/g, "");
		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";

		// this.setState({
		//     customStyle:((ans.indexOf("#style#") != -1)?true:false),
		//     fillInTheBlanksChoice:2,
		//     open:true
		// });
		$$invalidate(0, state.customStyle = ans.indexOf("#style#") != -1 ? true : false, state);

		$$invalidate(0, state.fillInTheBlanksChoice = 2, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:2}); ## ALready commented
		//this.setState({open:true}); ## ALready commented
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//$("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog").value = customStyle[1];

			AH.select("#customStyleText").value = customStyle[1];

			//$("#input"+i).val(customStyle[0]);
			AH.select("#input" + i).value = customStyle[0];
		} else {
			//$("#input").val(ans);
			AH.select("#input").value = ans;
		}
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			if (stopAuthoringUpdate === true) return;
			new_xml = XMLToJSON(state.xml);
			showItems(new_xml.smxml.step);
		}
	});

	function showItems(steps) {
		steps = replaceVariables(steps);
		$$invalidate(1, all_steps = steps);
		setToggle(all_steps);
		parseXmlAuthoring(steps);
	}

	function setToggle(steps) {

		steps.map(function (item, index) {
			if (item._viewonly == 1) {
				$$invalidate(1, all_steps[index].toggle = 1, all_steps);
			} else {
				$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			}
		});

		return all_steps;
	}

	function parseXmlAuthoring(steps) {
		steps.map(function (item, index) {
			let cdata = item.__cdata;
			let answerKey = cdata.match(/%{[\s\S]*?}%/gm);
			let answerType = "";

			if (answerKey) {
				//jQuery(answerKey).each(function(i){
				answerKey.forEach(function (data, i) {
					let originalKey = answerKey[i];
					let latexKey = "";
					let editMath = "";
					answerType = answerKey[i].match(/\|(.*?)}%$/gm);
					answerType = answerType ? answerType[0].replace(/\||}%/gm, "") : "t";
					let innerKey = "";
					let icon = "";
					let type = "";

					if (answerType == "t") {
						type = answerType;
						innerKey = "Textbox";
						icon = "icomoon-insert-template";
					} else if (answerType == "n") {
						type = "t";
						innerKey = "Numeric";
						icon = "icomoon-insert-template";
					} else if (answerType == "e") {
						type = answerType;
						innerKey = "Math";
						latexKey = originalKey.replace(/\%\{|\|e\}\%/g, "");
						latexKey = "latex=\"" + latexKey + "\"";
						editMath = "editMath";
						icon = "icomoon-insert-template";
					}

					var regex = new RegExp(RegExp.quote(originalKey));
					cdata = cdata.replace(regex, "<span id=\"latexSpan" + $$invalidate(0, state.spanCounter = $$invalidate(0, ++state.spanCounter, state), state) + "\" " + latexKey + " type='" + type + "' class='alert alert-info editFill " + editMath + "' originalkey='" + originalKey + "' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='" + icon + "'></i>" + innerKey + "</span>");
				});
			}

			$$invalidate(1, all_steps[index].__cdata = cdata, all_steps);
		});
	}

	function goNext(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.gonext = true, state);
			new_xml.smxml._gonext = "1";
		} else {
			$$invalidate(0, state.gonext = false, state);
			new_xml.smxml._gonext = "0";
		}

		updateXML();
	}

	function fixedAnswer(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.variable_button = true, state);
			new_xml.smxml._fixed = "1";
		} else {
			$$invalidate(0, state.variable_button = false, state);
			new_xml.smxml._fixed = "0";
		}

		updateXML();
	}

	function handleChangeCheckbox(id, fillid, e) {
		let name = e.target.name;
		let ref = document.querySelector("#" + name + id);
		let val = "_" + e.target.value;
		let seq = id;

		if (ref.checked) {
			new_xml.smxml.step[seq][val] = "1";
		} else {
			new_xml.smxml.step[seq][val] = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		updateXML();
	}

	function handleDisable(i) {
		console.log("handle click");

		//jQuery('#save_step_'+i).removeAttr('disabled');
		AH.select("#save_step_" + i, "removeAttr", "disabled");
	}

	function handleRadio(index, fillid, event) {
		if (all_steps[index].toggle == 1) {
			$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			new_xml.smxml.step[index]._viewonly = "0";
			new_xml.smxml.step[index]._attempt = "1";
		} else {
			all_steps[index].toggle == 1;
			new_xml.smxml.step[index]._viewonly = "1";
			new_xml.smxml.step[index]._attempt = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		updateXML();
	}

	function deleteEvent(index, data) {
		let delete_event;

		if (data == "steps") {
			delete_event = all_steps;

			if (delete_event.length > 2) {
				const add = delete_event.splice(index, 1);
			} else {
				AH.alert("You have atleast 2 steps.");
			}

			$$invalidate(1, all_steps = delete_event);
			updateXML();
		} else if (data == "algo") {
			$$invalidate(0, state.opened = true, state);
			$$invalidate(0, state.deleteIndex = index, state);
		}

		
	}

	function handleSave(id, fillid) {
		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		data = data.replace(/&amp;/g, "&"); // replace amp to maintain html entity.
		$$invalidate(1, all_steps[id].__cdata = data, all_steps);

		//jQuery('#save_step_'+id).prop('disabled', 'disabled');
		//document.querySelector('#save_step_'+id).disabled = true;
		AH.select("#save_step_" + id, "attr", { disabled: "disabled" });

		updateXML();
	}

	function updateXML() {
		let fixans = new_xml.smxml._fixed;
		let gonext = new_xml.smxml._gonext;
		let xml = "<smxml type=\"37\" fixed=\"" + fixans + "\" gonext=\"" + gonext + "\">";

		all_steps.map(function (element, i) {
			let seq = i + 1;
			let viewonly = element._viewonly;
			let mode = element._mode;
			let attempt = element._attempt;
			let sticky = element._sticky;
			let data = element.__cdata;

			// data = self.reverseReplaceVariables(data);
			data = reverseHtmlSpecialChars(data);

			data = replaceSpaces(data);
			data = data.replace(/&quot;/g, "\"").replace(/&nbsp;/g, " ");
			data = data.replace(/'/g, "\"").replace(/\n/g, "");
			let arr = data.match(/<span(.*?)>(.*?)<\/span>/gi);

			if (arr) {
				for (var i = 0; i < arr.length; i++) {
					let originalkey = arr[i].match(/originalkey="%(.*?)%"/g);

					if (originalkey) {
						originalkey = originalkey.toString().replace(/originalkey=/g, "").replace(/"%|%"/g, "%");
						data = data.replace(arr[i], originalkey);
					}
				}
			}

			let cdata = data;

			xml = xml + "<step seq='" + seq + "'" + (attempt != undefined
			? " attempt ='" + attempt + "'"
			: " ") + (viewonly != undefined
			? " viewonly ='" + viewonly + "'"
			: " ") + (mode != undefined ? " mode ='" + mode + "'" : " ") + (sticky != undefined ? " sticky ='" + sticky + "'" : " ") + "><!--[CDATA[" + cdata + "]]--></step>";
		});

		xml = xml + "</smxml>";
		getChildXml(xml);
	}

	function addEvent(data) {
		let obj = {};
		obj._seq = all_steps.length + 1;
		obj._viewonly = "1";
		obj._attempt = "0";
		obj._mode = "0";
		obj.__cdata = "New Step";
		all_steps.push(obj);
		updateXML();
		$$invalidate(0, state.snackback = true, state);

		var timer = setTimeout(
			function () {
				initEditor();
				clearTimeout(timer);
			},
			500
		);
	}

	function initEditor() {
		// jQuery(document).on("click", ".editMath", function(e){
		//     window.currentId = jQuery(this).attr('id');
		// });
		AH.listen(document, "click", ".editMath", function (_this, e) {
			// window.currentId = _this.getAttribute('id');
			$$invalidate(0, state.currentId = _this.getAttribute("id"), state);
		});

		// jQuery(document).on("click", ".materialOverlay", function(e){
		// 	window.currentId = null;
		//     window.currentInp = null;
		// });
		AH.listen(document, "click", ".materialOverlay", function (e) {
			//window.currentId = null;
			$$invalidate(0, state.currentId = null, state);

			//window.currentInp = null;
			$$invalidate(0, state.currentInp = null, state);
		});

		tinyMCE.PluginManager.add("res", function (editor, url) {
			editor.addMenuItem("resp", {
				text: "Add response",
				id: "addToken",
				onclick() {
					handleOpen();
				},
				context: "insert",
				prependToContext: true
			});
		});

		tinymce.PluginManager.load("equationeditor", themeUrl + "svelte_items/tinymce/plugins/equationeditor/plugin.min.js");

		tinymce.init({
			selector: ".tinymce-editor-res",
			inline: true,
			theme: "modern",
			skin: "skin02",
			min_width: 100,
			resize: true,
			menubar: false,
			toolbar: true,
			elementpath: false,
			statusbar: false,
			force_br_newlines: true,
			remove_trailing_brs: true,
			forced_root_block: false,
			extended_valid_elements: "span[onClick|contentEditable]",
			valid_elements: "*[*]",
			fixed_toolbar_container: "#toolbar_container",
			extended_valid_elements: "uc:syntax,uc:ref",
			custom_elements: "uc:syntax,~uc:ref",
			plugins: [
				"lists link image charmap print preview anchor",
				"searchreplace code fullscreen",
				"insertdatetime media table contextmenu paste res equationeditor "
			],
			content_css: themeUrl + "svelte_items/src/libs/mathquill.css",
			toolbar: [" bold italic underline | equationeditor"],
			contextmenu: "resp",
			paste_as_text: true
		});
	}

	function handleClose() {
		if (state.fillInTheBlanksChoice == 2) {
			//window.currentId = null;
			$$invalidate(0, state.currentInp = null, state);
		}

		$$invalidate(0, state.open = false, state);
	}

	function updateDialog(targetVal) {
		$$invalidate(0, state.fillInTheBlanksChoice = targetVal, state);
	}

	function latexEdit() {
		$$invalidate(0, state.open = true, state);
	}

	function storeAns() {
		var validate = 0;

		if (state.fillInTheBlanksChoice == 1) {
			//let ans = jQuery("#input1").val();
			let ans = document.querySelector("#input1").value;

			//let numeric = jQuery("#responseDialog #numeric")[0].checked;
			let numeric = document.querySelector("#responseDialog #numeric").checked;

			if (numeric == true) {
				ans += " |n";
			}

			if (ans.trim() == "") {
				validate = 1;
				validate("All fields are required");
			} else {
				tinyMCE.activeEditor.insertContent("<span type='t' class='alert alert-info editFill' originalKey='%{" + ans.trim() + "}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template'></i>" + (numeric == true ? "Numeric" : "Textbox") + "</span>");
			}
		}

		if (state.fillInTheBlanksChoice == 2) {
			//let e = jQuery("#input").val();
			let e = document.querySelector("#input").value;

			if (validate == 0) {
				//document.querySelector("#"+window.currentId).setAttribute("latex",e);
				document.querySelector("#" + state.currentId).setAttribute("latex", e);

				//document.querySelector("#"+window.currentId).setAttribute("originalKey","%{"+e+"|e}%");
				document.querySelector("#" + state.currentId).setAttribute("originalKey", "%{" + e + "|e}%");

				//window.currentId = null;
				$$invalidate(0, state.currentId = null, state);

				//window.currentInp = null;
				$$invalidate(0, state.currentInp = null, state);
			} else {
				validate("All fields are required");
			}
		}

		if (validate == 0) {
			handleClose();
		}
	}

	function handleOpen() {
		// this.setState({
		//     open: true,
		//     codetype: false,
		//     numeric: false
		// });
		$$invalidate(0, state.open = true, state);

		$$invalidate(0, state.codetype = false, state);
		$$invalidate(0, state.numeric = false, state);
	} //this.setState({codetype: false}); #already commented on also react
	//this.setState({numeric: false}); #already commented on also react

	const writable_props = ["stopAuthoringUpdate", "xml", "editorState", "getChildXml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<StepAlgo> was created with unknown prop '${key}'`);
	});

	const click_handler = e => {
		goNext("go_next");
	};

	const click_handler_1 = e => {
		fixedAnswer("fixedans_checkbox");
	};

	const keyup_handler = (index, e) => {
		handleDisable(index);
	};

	const change_handler = (index, e) => {
		handleRadio(index, "fillAuthor_" + index);
	};

	const click_handler_2 = (index, e) => {
		handleChangeCheckbox(index, "fillAuthor_" + index, e);
	};

	const click_handler_3 = (index, e) => {
		handleChangeCheckbox(index, "fillAuthor_" + index, e);
	};

	const click_handler_4 = (index, e) => {
		deleteEvent(index, "steps");
	};

	const click_handler_5 = (index, e) => {
		handleSave(index, "fillAuthor_" + index);
	};

	function dialog_visible_binding(value) {
		state.open = value;
		$$invalidate(0, state);
	}

	$$self.$$set = $$props => {
		if ("stopAuthoringUpdate" in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		writable,
		Button,
		Dialog,
		Checkbox,
		l: language,
		beforeUpdate,
		onMount,
		AH,
		XMLToJSON,
		JSONToXML,
		state,
		new_xml,
		all_steps,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		stateData,
		unsubscribe,
		editTextbox,
		editMathbox,
		showItems,
		setToggle,
		replaceVariables,
		parseXmlAuthoring,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		updateXML,
		reverseHtmlSpecialChars,
		replaceSpaces,
		addEvent,
		initEditor,
		handleClose,
		updateDialog,
		addEditable,
		latexEdit,
		storeAns,
		handleOpen
	});

	$$self.$inject_state = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("new_xml" in $$props) new_xml = $$props.new_xml;
		if ("all_steps" in $$props) $$invalidate(1, all_steps = $$props.all_steps);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
		if ("stateData" in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		all_steps,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		addEvent,
		handleClose,
		updateDialog,
		latexEdit,
		storeAns,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		click_handler,
		click_handler_1,
		keyup_handler,
		change_handler,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		dialog_visible_binding
	];
}

class StepAlgo extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-smsdwz-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				stopAuthoringUpdate: 14,
				xml: 15,
				editorState: 16,
				getChildXml: 17
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StepAlgo",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stopAuthoringUpdate*/ ctx[14] === undefined && !("stopAuthoringUpdate" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*xml*/ ctx[15] === undefined && !("xml" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[16] === undefined && !("editorState" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[17] === undefined && !("getChildXml" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'getChildXml'");
		}
	}

	get stopAuthoringUpdate() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMMixedItem\ItemPlugin.svelte generated by Svelte v3.29.0 */
const file$1 = "clsSMMixedItem\\ItemPlugin.svelte";

// (13:4) {#if parseInt(editorState.content_icon) == 2}
function create_if_block$1(ctx) {
	let newauthoring;
	let current;

	newauthoring = new StepAlgo({
			props: {
				xml: /*xml*/ ctx[0],
				getChildXml: /*getChildXml*/ ctx[2],
				stopAuthoringUpdate: /*stopAuthoringUpdate*/ ctx[3],
				uxml: /*uxml*/ ctx[4]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(newauthoring.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(newauthoring, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const newauthoring_changes = {};
			if (dirty & /*xml*/ 1) newauthoring_changes.xml = /*xml*/ ctx[0];
			if (dirty & /*getChildXml*/ 4) newauthoring_changes.getChildXml = /*getChildXml*/ ctx[2];
			if (dirty & /*stopAuthoringUpdate*/ 8) newauthoring_changes.stopAuthoringUpdate = /*stopAuthoringUpdate*/ ctx[3];
			if (dirty & /*uxml*/ 16) newauthoring_changes.uxml = /*uxml*/ ctx[4];
			newauthoring.$set(newauthoring_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(newauthoring.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(newauthoring.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(newauthoring, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(13:4) {#if parseInt(editorState.content_icon) == 2}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let main;
	let show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;
	let current;
	let if_block = show_if && create_if_block$1(ctx);

	const block = {
		c: function create() {
			main = element("main");
			if (if_block) if_block.c();
			add_location(main, file$1, 11, 0, 235);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			if (if_block) if_block.m(main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*editorState*/ 2) show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*editorState*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(main, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ItemPlugin", slots, []);
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;
	let { stopAuthoringUpdate } = $$props;
	let { uxml } = $$props;
	const writable_props = ["xml", "editorState", "getChildXml", "stopAuthoringUpdate", "uxml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ItemPlugin> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("uxml" in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	$$self.$capture_state = () => ({
		NewAuthoring: StepAlgo,
		xml,
		editorState,
		getChildXml,
		stopAuthoringUpdate,
		uxml
	});

	$$self.$inject_state = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("uxml" in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [xml, editorState, getChildXml, stopAuthoringUpdate, uxml];
}

class ItemPlugin extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			xml: 0,
			editorState: 1,
			getChildXml: 2,
			stopAuthoringUpdate: 3,
			uxml: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ItemPlugin",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[0] === undefined && !("xml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[1] === undefined && !("editorState" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[2] === undefined && !("getChildXml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'getChildXml'");
		}

		if (/*stopAuthoringUpdate*/ ctx[3] === undefined && !("stopAuthoringUpdate" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*uxml*/ ctx[4] === undefined && !("uxml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'uxml'");
		}
	}

	get xml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stopAuthoringUpdate() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ItemPlugin;
//# sourceMappingURL=ItemPlugin-ff9021fb.js.map
