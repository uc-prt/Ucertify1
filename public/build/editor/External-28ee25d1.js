
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, af as Textfield, y as language, V as Checkbox, O as Dialog, P as binding_callbacks, Q as bind, R as Snackbar, v as validate_slots, o as onMount, L as beforeUpdate, A as AH, a3 as onDestroy, ag as tag_player, U as Button, w as writable, a8 as Loader, e as element, c as create_component, f as space, j as attr_dev, k as add_location, l as set_style, n as insert_dev, p as append_dev, m as mount_component, Y as select_option, q as listen_dev, W as add_flush_callback, t as transition_in, a as transition_out, x as detach_dev, b as destroy_component, h as text, B as noop, F as set_data_dev } from './main-0211720b.js';
import { U as UCLIB_1 } from './UCLIB-99785e0e.js';

/* clsSMExternal/External.svelte generated by Svelte v3.29.0 */

const { console: console_1 } = globals;
const file = "clsSMExternal/External.svelte";

// (409:5) <Checkbox       on:click = {multicheck}      >
function create_default_slot_3(ctx) {
	let t0_value = language.multi_check + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = text(" :");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(409:5) <Checkbox       on:click = {multicheck}      >",
		ctx
	});

	return block;
}

// (452:1) <div slot="title" style="text-align: left;">
function create_title_slot(ctx) {
	let div0;
	let div1;

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			div1.textContent = "Review";
			add_location(div1, file, 452, 2, 17523);
			attr_dev(div0, "slot", "title");
			set_style(div0, "text-align", "left");
			add_location(div0, file, 451, 1, 17476);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot.name,
		type: "slot",
		source: "(452:1) <div slot=\\\"title\\\" style=\\\"text-align: left;\\\">",
		ctx
	});

	return block;
}

// (464:2) <Button    on:click={()=> state.remediationToggle = false}   >
function create_default_slot_2(ctx) {
	let t_value = language.done + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(464:2) <Button    on:click={()=> state.remediationToggle = false}   >",
		ctx
	});

	return block;
}

// (463:1) <div slot="footer" class="footer" style="border-top: 1px solid var(--divider, rgba(0, 0, 0, 0.1));">
function create_footer_slot(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[9]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "footer");
			set_style(div, "border-top", "1px solid var(--divider, rgba(0, 0, 0, 0.1))");
			add_location(div, file, 462, 1, 17718);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(463:1) <div slot=\\\"footer\\\" class=\\\"footer\\\" style=\\\"border-top: 1px solid var(--divider, rgba(0, 0, 0, 0.1));\\\">",
		ctx
	});

	return block;
}

// (448:0) <Dialog              bind:visible={state.remediationToggle}  width={450} >
function create_default_slot_1(ctx) {
	let t0;
	let div1;
	let div0;
	let center;
	let loader;
	let t1;
	let h4;
	let t2_value = language.calculate_answer + "";
	let t2;
	let br;
	let t3;
	let t4_value = language.please_wait + "";
	let t4;
	let t5;
	let current;
	loader = new Loader({ props: { size: 70 }, $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			center = element("center");
			create_component(loader.$$.fragment);
			t1 = space();
			h4 = element("h4");
			t2 = text(t2_value);
			br = element("br");
			t3 = space();
			t4 = text(t4_value);
			t5 = space();
			add_location(br, file, 458, 28, 17660);
			add_location(h4, file, 458, 4, 17636);
			add_location(center, file, 456, 3, 17598);
			attr_dev(div0, "id", "remediationModel");
			add_location(div0, file, 455, 2, 17567);
			add_location(div1, file, 454, 1, 17559);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, center);
			mount_component(loader, center, null);
			append_dev(center, t1);
			append_dev(center, h4);
			append_dev(h4, t2);
			append_dev(h4, br);
			append_dev(h4, t3);
			append_dev(h4, t4);
			insert_dev(target, t5, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_component(loader);
			if (detaching) detach_dev(t5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(448:0) <Dialog              bind:visible={state.remediationToggle}  width={450} >",
		ctx
	});

	return block;
}

// (471:0) <Snackbar  bind:visible={state.snackback}   bg="#f44336"   bottom={true}   timeout={10}  style="position: absolute;z-index:9999" >
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*message*/ ctx[0]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 1) set_data_dev(t, /*message*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(471:0) <Snackbar  bind:visible={state.snackback}   bg=\\\"#f44336\\\"   bottom={true}   timeout={10}  style=\\\"position: absolute;z-index:9999\\\" >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div11;
	let div9;
	let div8;
	let div2;
	let div0;
	let textfield0;
	let t0;
	let div1;
	let textfield1;
	let t1;
	let div7;
	let div3;
	let checkbox;
	let t2;
	let div6;
	let div4;
	let t5;
	let div5;
	let select;
	let option0;
	let option1;
	let option2;
	let select_value_value;
	let t9;
	let center;
	let div10;
	let iframe;
	let iframe_allowfullscreen_value;
	let t10;
	let dialog;
	let updating_visible;
	let t11;
	let snackbar;
	let updating_visible_1;
	let current;
	let mounted;
	let dispose;

	textfield0 = new Textfield({
			props: {
				id: "externalTitle",
				label: language.title,
				style: "padding-top:0;"
			},
			$$inline: true
		});

	textfield0.$on("change", /*changeTitle*/ ctx[3]);

	textfield1 = new Textfield({
			props: {
				id: "defaultValues",
				label: language.default,
				multiline: true,
				fullWidth: true
			},
			$$inline: true
		});

	textfield1.$on("change", /*changeDefault*/ ctx[5]);

	checkbox = new Checkbox({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox.$on("click", /*multicheck*/ ctx[4]);

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[10].call(null, value);
	}

	let dialog_props = {
		width: 450,
		$$slots: {
			default: [create_default_slot_1],
			footer: [create_footer_slot],
			title: [create_title_slot]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[1].remediationToggle !== void 0) {
		dialog_props.visible = /*state*/ ctx[1].remediationToggle;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));

	function snackbar_visible_binding(value) {
		/*snackbar_visible_binding*/ ctx[11].call(null, value);
	}

	let snackbar_props = {
		bg: "#f44336",
		bottom: true,
		timeout: 10,
		style: "position: absolute;z-index:9999",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*state*/ ctx[1].snackback !== void 0) {
		snackbar_props.visible = /*state*/ ctx[1].snackback;
	}

	snackbar = new Snackbar({ props: snackbar_props, $$inline: true });
	binding_callbacks.push(() => bind(snackbar, "visible", snackbar_visible_binding));

	const block = {
		c: function create() {
			div11 = element("div");
			div9 = element("div");
			div8 = element("div");
			div2 = element("div");
			div0 = element("div");
			create_component(textfield0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(textfield1.$$.fragment);
			t1 = space();
			div7 = element("div");
			div3 = element("div");
			create_component(checkbox.$$.fragment);
			t2 = space();
			div6 = element("div");
			div4 = element("div");
			div4.textContent = `${language.sequence} :`;
			t5 = space();
			div5 = element("div");
			select = element("select");
			option0 = element("option");
			option0.textContent = `${"No match"}`;
			option1 = element("option");
			option1.textContent = `${"Loose match"}`;
			option2 = element("option");
			option2.textContent = `${"Exact match"}`;
			t9 = space();
			center = element("center");
			div10 = element("div");
			iframe = element("iframe");
			t10 = space();
			create_component(dialog.$$.fragment);
			t11 = space();
			create_component(snackbar.$$.fragment);
			attr_dev(div0, "class", "col-md-6");
			add_location(div0, file, 388, 4, 16085);
			attr_dev(div1, "class", "col-md-6");
			add_location(div1, file, 396, 4, 16256);
			attr_dev(div2, "class", "row mx-0");
			add_location(div2, file, 387, 3, 16058);
			attr_dev(div3, "class", "col-md-6 float-left");
			add_location(div3, file, 407, 4, 16472);
			attr_dev(div4, "class", "float-left");
			set_style(div4, "line-height", "27px");
			set_style(div4, "font-family", "'Roboto, sans-serif'");
			add_location(div4, file, 415, 5, 16642);
			option0.__value = "0";
			option0.value = option0.__value;
			add_location(option0, file, 422, 7, 16881);
			option1.__value = "1";
			option1.value = option1.__value;
			add_location(option1, file, 423, 7, 16928);
			option2.__value = "2";
			option2.value = option2.__value;
			add_location(option2, file, 424, 7, 16978);
			set_style(select, "margin-left", "10px");
			add_location(select, file, 417, 6, 16764);
			add_location(div5, file, 416, 5, 16752);
			attr_dev(div6, "class", "col-md-6");
			add_location(div6, file, 414, 4, 16614);
			attr_dev(div7, "class", "row mt-3 mx-0");
			add_location(div7, file, 406, 3, 16440);
			attr_dev(div8, "class", "col-md-12 float-left");
			add_location(div8, file, 386, 2, 16020);
			attr_dev(div9, "id", "externalInputs");
			attr_dev(div9, "class", "mt-md");
			add_location(div9, file, 385, 1, 15977);
			attr_dev(iframe, "id", "authoringFrame");
			attr_dev(iframe, "title", "External Module");
			iframe.allowFullscreen = iframe_allowfullscreen_value = true;
			attr_dev(iframe, "webkitallowfullscreen", "true");
			attr_dev(iframe, "mozallowfullscreen", "true");
			attr_dev(iframe, "height", "550");
			attr_dev(iframe, "width", "94%");
			attr_dev(iframe, "name", "authoringFrame");
			attr_dev(iframe, "data-authoring", "1");
			add_location(iframe, file, 433, 3, 17119);
			attr_dev(div10, "id", "frame");
			add_location(div10, file, 432, 2, 17099);
			add_location(center, file, 431, 1, 17088);
			attr_dev(div11, "id", "authoringArea");
			add_location(div11, file, 384, 0, 15951);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div11, anchor);
			append_dev(div11, div9);
			append_dev(div9, div8);
			append_dev(div8, div2);
			append_dev(div2, div0);
			mount_component(textfield0, div0, null);
			append_dev(div2, t0);
			append_dev(div2, div1);
			mount_component(textfield1, div1, null);
			append_dev(div8, t1);
			append_dev(div8, div7);
			append_dev(div7, div3);
			mount_component(checkbox, div3, null);
			append_dev(div7, t2);
			append_dev(div7, div6);
			append_dev(div6, div4);
			append_dev(div6, t5);
			append_dev(div6, div5);
			append_dev(div5, select);
			append_dev(select, option0);
			append_dev(select, option1);
			append_dev(select, option2);
			select_option(select, /*state*/ ctx[1].sequence);
			append_dev(div11, t9);
			append_dev(div11, center);
			append_dev(center, div10);
			append_dev(div10, iframe);
			insert_dev(target, t10, anchor);
			mount_component(dialog, target, anchor);
			insert_dev(target, t11, anchor);
			mount_component(snackbar, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(select, "blur", /*handleSequence*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const checkbox_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);

			if (!current || dirty & /*state*/ 2 && select_value_value !== (select_value_value = /*state*/ ctx[1].sequence)) {
				select_option(select, /*state*/ ctx[1].sequence);
			}

			const dialog_changes = {};

			if (dirty & /*$$scope, state*/ 134217730) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty & /*state*/ 2) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[1].remediationToggle;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
			const snackbar_changes = {};

			if (dirty & /*$$scope, message*/ 134217729) {
				snackbar_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_1 && dirty & /*state*/ 2) {
				updating_visible_1 = true;
				snackbar_changes.visible = /*state*/ ctx[1].snackback;
				add_flush_callback(() => updating_visible_1 = false);
			}

			snackbar.$set(snackbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textfield0.$$.fragment, local);
			transition_in(textfield1.$$.fragment, local);
			transition_in(checkbox.$$.fragment, local);
			transition_in(dialog.$$.fragment, local);
			transition_in(snackbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textfield0.$$.fragment, local);
			transition_out(textfield1.$$.fragment, local);
			transition_out(checkbox.$$.fragment, local);
			transition_out(dialog.$$.fragment, local);
			transition_out(snackbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div11);
			destroy_component(textfield0);
			destroy_component(textfield1);
			destroy_component(checkbox);
			if (detaching) detach_dev(t10);
			destroy_component(dialog, detaching);
			if (detaching) detach_dev(t11);
			destroy_component(snackbar, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("External", slots, []);

	let { setInlineEditor = () => {
		
	} } = $$props;

	let { editorState } = $$props;

	let { getChildXml = () => {
		
	} } = $$props;

	let _module = "",
		type = "",
		version = "",
		user_filter_ans = "",
		qxml = "",
		message = "";

	let state = {};

	let hdd = writable({
		xml: "",
		uxml: "",
		title: "",
		defaultValue: "",
		toggle: false,
		snackback: false,
		sequence: "0",
		multicheck: false,
		remediationToggle: false,
		titleData: "",
		stemData: "",
		remediationData: "",
		toggleMode: ""
	});

	let unsubscribe = hdd.subscribe(item => {
		$$invalidate(1, state = item);
	});

	onMount(async () => {
		didMount();
	});

	beforeUpdate(async () => {
		// check for toggle mode
		if (state.toggleMode != editorState.toggleMode) {
			$$invalidate(1, state.toggleMode = editorState.toggleMode, state);

			qxml = state.xml
			? document.getElementById("authoringFrame").contentWindow.save_data(1, 0, true)
			: "";

			if (editorState.toggleMode == true) {
				//Test mode on
				// check for the xml
				if (state.xml) {
					qxml = qxml.toString().replace(/'/gm, "\\x27");
					qxml = qxml.toString().match(/<correct>[\s\S]*?<\/correct>/img);
					qxml = qxml.toString().replace(/\$/g, "#dollar");

					// replace the special corrector in the xml inside the correct tag
					qxml = state.xml.toString().replace(/<correct>[\s\S]*?<\/correct>/img, qxml.toString());

					qxml = qxml.toString().replace(/#dollar/g, "$");

					if (qxml.match(/<correct>\s*<!\[CDATA\[\s*\]\]>\s*<\/correct>/gmi) && !state.xml.match(/<correct>\s*<!\[CDATA\[\s*\]\]>\s*<\/correct>/gmi)) {
						qxml = state.xml;
					} else {
						$$invalidate(1, state.xml = qxml, state);
						getChildXml(qxml);
					}
				} else {
					window.is_review = 0;
				}

				AH.select("#authoringFrame", "attr", { "data-authoring": "0" });
				AH.select("#headerTitle").innerHTML = language.preview;
				AH.find("#authoringArea", "form", { action: "remove" });
				renderPlayer();
				AH.empty("#authoringFrame");

				// updating the qxml 
				let testHtml = "<form method=\"post\" target=\"authoringFrame\" action=\"" + baseUrl + "sim/?in_editor=1\"><input type=\"hidden\" name=\"first_time\" value=\"1\"/><input type=\"hidden\" name=\"testmode\" value=\"1\"/><input type=\"hidden\" name=\"qxml\" value='" + qxml + "'/><input type=\"hidden\" name=\"content_guid\" value=\"0\" /></form>";

				AH.insert("#authoringArea", testHtml, "beforeend");
				$$invalidate(1, state.titleData = AH.select("#title").innerHTML, state);
				$$invalidate(1, state.stemData = AH.select("#stem").innerHTML, state);
				$$invalidate(1, state.remediationData = AH.select("#remediation").innerHTML, state);
				AH.insert(AH.select(AH.empty("#title"), "hide"), `<div id="tilteShow">${state.titleData}</div>`, "afterend");
				AH.insert(AH.select(AH.empty("#stem"), "hide"), `<div id="stemShow">${state.stemData}</div>`, "afterend");
				AH.insert(AH.select(AH.empty("#remediation"), "hide"), `<div id="remediationShow">${state.remediationData}</div>`, "afterend");
				AH.select("#externalInputs", "hide");

				// submit the form  and send data to sim/index.php
				setTimeout(
					function () {
						AH.find(document, "form[target=\"authoringFrame\"]").submit();
						$$invalidate(6, editorState.activator = true, editorState);
					},
					200
				);
			} else {
				//Authoring Mode.
				if (state.xml) {
					let uxml = document.getElementById("authoringFrame").contentWindow.save_data(0, 0, true);

					if (!uxml.match(/<!\[CDATA\[\s*html=dW5kZWZpbmVk\s*\]\]>/gmi)) {
						$$invalidate(1, state.uxml = uxml, state);
					}

					getChildXml(state.xml);

					// get all the details according to th current xml
					var windowHtml = getAuthoringForm(state.xml);

					AH.empty("#authoringFrame");
					AH.find("#authoringArea", "form", { action: "remove" });
					AH.insert("#authoringArea", windowHtml, "beforeend");

					// submit the form  and send data to sim/index.php
					setTimeout(
						function () {
							AH.find(document, "form[target=\"authoringFrame\"]").submit();
							$$invalidate(6, editorState.activator = true, editorState);
						},
						200
					);
				}

				AH.select("#headerTitle", "html", language.authoring);
				AH.select("#authoringFrame", "attr", { "data-authoring": "1" });
				AH.find(document, "#tilteShow,#stemShow,#remediationShow", { action: "remove" });
				AH.select("#title", "html", state.titleData);
				AH.select("#stem", "html", state.stemData);
				AH.select("#remediation", "html", state.remediationData);
				AH.selectAll("#title,#stem,#remediation,#externalInputs", "show");
				unRenderPlayer();
				setInlineEditor("#stem");
				setInlineEditor("#remediation");
			}
		}
	});

	// calls after unmount
	onDestroy(() => {
		AH.select("#preview", "show");
		$$invalidate(6, editorState.activator = false, editorState);
	});

	// calls just after rendering of the function
	function didMount() {
		if (window.inNative) {
			// for getting height in Native
			window.getHeight && window.getHeight();
		}

		setTimeout(
			function () {
				AH.select("#preview", "hide");
				$$invalidate(1, state.xml = editorState.xml, state);

				if (editorState.xml) {
					// get all the details according to th current xml
					var windowHtml = getAuthoringForm(editorState.xml);

					AH.insert("#authoringArea", windowHtml, "beforeend");

					setTimeout(
						function () {
							// submit the form getting by getAuthoringForm function
							AH.find(document, "form[target=\"authoringFrame\"]").submit();

							$$invalidate(6, editorState.activator = true, editorState);
						},
						200
					);
				} else {
					AH.select("#authoringArea", "hide");
					$$invalidate(6, editorState.activator = false, editorState);
				}
			},
			100
		);

		AH.listen(document, "click", "#your_ans_filter li", function (_this) {
			if (user_filter_ans == "") {
				user_filter_ans = AH.select("#user_answer").innerHTML;
			}

			filterUserAnswer(_this.textContent.trim().toLowerCase().replace(" ", "_"));
		});

		AH.listen(document, "click", "#answerCheck", remediationMode);

		setTimeout(
			function () {
				AH.bind("#authoringFrame", "load", function () {
					$$invalidate(6, editorState.activator = false, editorState);
				});
			},
			200
		);

		setTimeout(
			function () {
				let frameHeight = window.innerHeight - 60;

				if (in_frame == 1) {
					frameHeight = window.innerHeight;
				}

				AH.select("#authoringFrame", "attr", { height: frameHeight });
			},
			500
		);
	}

	// this function returns the form conaining all the details in xml
	function getAuthoringForm(xml) {
		try {
			let _qxml = `<textarea class="h hidden" name="qxml" id="qxml">${xml}</textarea>`;
			let defaultValues = _qxml.match(/<default>[\s\S]*?<\/default>/gmi);

			defaultValues = defaultValues.toString()
			? defaultValues.toString().replace(/<!\[CDATA\[|\]\]>|<default>|<\/default>/gmi, "").trim()
			: "";

			AH.select("#defaultValues").value = defaultValues;
			xml = xml.match(/<smxml([\s\S]*?)<(.*?)>/gmi);
			xml = xml.toString().replace(/<smxml(.*?)>/img, "");
			_module = xml.match(/<\w+/img);
			_module = _module.toString().replace(/</img, "");
			let newXml = AH.parseHtml(xml);
			AH.select("#externalTitle").value = newXml.getAttribute("title");

			let multicheck = newXml.getAttribute("multicheck") == "true"
			? true
			: false;

			$$invalidate(1, state.multicheck = multicheck, state);
			$$invalidate(1, state.sequence = newXml.getAttribute("sequence"), state);
			type = `<input type="hidden" name="type" value="${newXml.getAttribute("type")}">`;
			version = `<input type="hidden" name="version" value="${newXml.getAttribute("version")}">`;
			multicheck = `<input type="hidden" name="multicheck" value="${state.multicheck}">`;
			let windowHtml = `<form method="post" target="authoringFrame" action="${baseUrl}sim/?in_editor=1"><input type="hidden" name="module" value="${_module}"><input type="hidden" name="title" value=""><input type="hidden" name="sequence" value="${state.sequence}">${type + version + multicheck + _qxml}<input type="hidden" name="autheringmode" value="1"></form>`;
			return windowHtml;
		} catch(err) {
			console.log(err);
		}
	}

	// for filtering the user answer
	function filterUserAnswer(filter_type) {
		let user_answer_array = user_filter_ans.split("<br>");
		let correct_answer_string = AH.select("#correct_answer").innerHTML;

		if (filter_type == "only_unique") {
			let uniqueAnswers = [];

			user_answer_array.forEach((el, i) => {
				if (AH.inArray(el, uniqueAnswers) === -1) uniqueAnswers.push(el);
			});

			setTimeout(
				function () {
					AH.select("#user_answer", "html", uniqueAnswers.join("<br>"));
				},
				1000
			);
		} else if (filter_type == "only_relevant") {
			let releventAnswers = [];

			user_answer_array.forEach(function (el, i) {
				if (correct_answer_string.indexOf(el) != -1) {
					if (AH.inArray(el, releventAnswers) === -1) releventAnswers.push(el);
				}
			});

			setTimeout(
				function () {
					AH.select("#user_answer", "html", releventAnswers.join("<br>"));
				},
				1000
			);
		} else {
			setTimeout(
				function () {
					AH.select("#user_answer", "html", user_filter_ans);
				},
				1000
			);
		}
	}

	// not found where it is called @pradeep sir please check once
	function toggle() {
		qxml = document.getElementById("authoringFrame").contentWindow.save_data(1, 0, true);

		if (state.toggle == false) {
			//Test mode on
			qxml = qxml.toString().replace(/'/gm, "\\x27");

			AH.select("#authoringFrame", "attr", { "data-authoring": "0" });
			qxml = qxml.toString().match(/<correct>[\s\S]*?<\/correct>/img);
			qxml = state.xml.toString().replace(/<correct>[\s\S]*?<\/correct>/img, qxml.toString());

			if (qxml.match(/<correct>\s*<!\[CDATA\[\s*\]\]>\s*<\/correct>/gmi) && !state.xml.match(/<correct>\s*<!\[CDATA\[\s*\]\]>\s*<\/correct>/gmi)) {
				qxml = state.xml;
			} else {
				$$invalidate(1, state.xml = qxml, state);
				getChildXml(qxml);
			}

			AH.find("#authoringArea", "form").remove();
			renderPlayer();
			AH.empty("#authoringFrame");
			let testHtml = "<form method=\"post\" target=\"authoringFrame\" action=\"" + baseUrl + "sim/?in_editor=1\"><input type=\"hidden\" name=\"first_time\" value=\"1\"/><input type=\"hidden\" name=\"testmode\" value=\"1\"/><input type=\"hidden\" name=\"qxml\" value='" + qxml + "'/><input type=\"hidden\" name=\"content_guid\" value=\"0\" /></form>";
			AH.insert("#authoringArea", testHtml, "beforeend");
			AH.insert(AH.select("#title", "hide"), `<div id="tilteShow">${AH.select("#title").innerHTML}</div>`, "afterend");
			AH.insert(AH.select("#stem", "hide"), `<div id="stemShow">${AH.select("#stem").innerHTML}</div>`, "afterend");
			AH.insert(AH.select("#remediation", "hide"), `<div id="remediationShow">${AH.select("#remediation").innerHTML}</div>`, "afterend");
			AH.select("#externalInputs", "hide");

			setTimeout(
				function () {
					AH.find(document, "form[target=\"authoringFrame\"]").submit();
					$$invalidate(6, editorState.activator = true, editorState);
				},
				200
			);
		} else {
			//Authoring Mode.
			let uxml = document.getElementById("authoringFrame").contentWindow.save_data(0, 0, true);

			if (!uxml.match(/<!\[CDATA\[\s*html=dW5kZWZpbmVk\s*\]\]>/gmi)) {
				$$invalidate(1, state.uxml = uxml, state);
			}

			AH.select("#authoringFrame", "attr", { "data-authoring": "1" });
			getChildXml(state.xml);

			// get all the details according to th current xml
			var windowHtml = getAuthoringForm(state.xml);

			AH.empty("#authoringFrame");
			AH.find("#authoringArea", "form", { action: "remove" });
			AH.insert("#authoringArea", windowHtml, "beforeend");

			setTimeout(
				function () {
					// submit the form and send data to sim/index.php
					AH.find(document, "form[target=\"authoringFrame\"]").submit();

					$$invalidate(6, editorState.activator = true, editorState);
				},
				200
			);

			AH.find(document, "#tilteShow,#stemShow,#remediationShow", { action: "remove" });
			AH.selectAll("#title,#stem,#remediation,#externalInputs", "show");
			AH.select("#heading", "html", "Authoring");
			unRenderPlayer();
		}

		$$invalidate(1, state.toggle = !state.toggle, state);
	}

	// calls whenever there is change in sequence and update the xml accordingly
	function handleSequence(event) {
		// getting the selected dropdown value
		let value = event.target.value;

		$$invalidate(1, state.sequence = value, state);

		// updating the xml
		$$invalidate(1, state.xml = state.xml.toString().replace(/sequence="(.*?)"/, "sequence=\"" + value + "\""), state);

		// updating and storing the xml
		getChildXml(state.xml);
	}

	// calls whenever there is change in title textbox and update the xml accordingly
	function changeTitle(event) {
		$$invalidate(1, state.xml = state.xml.toString().replace(/title="(.*?)"/img, "title=\"" + event.target.value + "\""), state);

		// updating and storing the xml
		getChildXml(state.xml);
	}

	// calls whenever there is change in multicheck checkbox and update the xml accordingly
	function multicheck(event) {
		$$invalidate(1, state.multicheck = event.target.checked, state);

		// updating the xml on the basis of multicheck is checked 
		$$invalidate(1, state.xml = state.xml.toString().replace(/multicheck="(.*?)"/img, "multicheck=\"" + event.target.checked + "\""), state);

		// updating and storing the xml
		getChildXml(state.xml);
	}

	// calls whenever there is change in default textfield and update the xml accordingly
	function changeDefault(event) {
		$$invalidate(1, state.xml = state.xml.toString().replace(/<default>\s*<\!\[CDATA\[([\s\S]*?)\]\]>\s*<\/default>/img, "<default><![CDATA[" + event.target.value + "]]></default>"), state);

		// updating the xml and storing the xml 
		getChildXml(state.xml);
	}

	// for rendering the player
	function renderPlayer() {
		AH.empty("#authoringDiv player");
		tag_player(AH.select("#authoringDiv"));
		AH.find("#authoringDiv", "player", "addClass", "hidecontent");

		AH.selectAll("#editor img").forEach(function (_this) {
			let _src = _this.getAttribute("src");

			if (!_this.getAttribute("header-logo") && _src.indexOf("vimeocdn") == -1 && !_src.match(/\/\/s3.amazonaws.com\/jigyaasa_content_static/gm)) {
				_this.setAttribute("src", "//s3.amazonaws.com/jigyaasa_content_static/" + _src);
			}
		});
	}

	// for unrendering the player
	function unRenderPlayer() {
		AH.empty("#authoringDiv player");

		AH.find("#authoringDiv", "player", {
			action: "removeClass",
			actionData: "hidecontent"
		});

		AH.selectAll("#editor img").forEach(function (_this) {
			let _src = _this.getAttribute("src");

			if (_src.indexOf("vimeocdn") == -1 && !_src.match(/\/\/s3.amazonaws.com\/jigyaasa_content_static/gm)) {
				_this.setAttribute("src", _src);
			}
		});
	}

	// calls when remediation Mode is click
	function remediationMode() {
		if (state.xml) {
			let iframe = document.getElementById("authoringFrame");
			let uxml = iframe.contentWindow.save_data(0, 0, true);

			if (uxml.match(/<!\[CDATA\[\s*html=dW5kZWZpbmVk\s*\]\]>/gmi) && state.uxml != "") {
				uxml = state.uxml;
			} else {
				$$invalidate(1, state.uxml = uxml, state);
			}

			$$invalidate(1, state.remediationToggle = true, state);

			AH.ajax({
				url: baseUrl + "editor/index.php", // point to server-side PHP script 
				data: {
					ajax: "1",
					action: "external_reviewmode",
					get_message: state.xml,
					uxml,
					content_subtype: 16
				},
				type: "post"
			}).then(response => {
				response = response.replace(/\n/gmi, "<br/>");
				let answer = response.replace(/\s=\s/gim, "=").match(/ans="(.*?)"/img);
				answer = answer ? answer.toString().replace(/ans=|"/img, "") : "";
				$$invalidate(0, message = UCLIB_1.ucfirst(answer));
				$$invalidate(1, state.snackback = true, state);
				AH.find(document, "#remediationModel").innerHTML = response;
			});
		} else {
			window.is_review = 1;
			renderPlayer();
		}
	}

	// for resetting the function 
	// not found where it is called @pradeep sir please check once
	function resetData() {
		if (AH.select("#authoringFrame").getAttribute("data-authoring") == "0") {
			document.getElementById("authoringFrame").contentWindow.resetInEditor();
			$$invalidate(1, state.uxml = "<smxml></smxml>", state);
		} else {
			$$invalidate(1, state.xml = state.xml.toString().replace(/<!\[CDATA\[[\s\S]*?\]\]>/gmi, "<![CDATA[]]>"), state);
			$$invalidate(1, state.uxml = state.uxml.toString().replace(/<!\[CDATA\[[\s\S]*?\]\]>/gmi, "<![CDATA[]]>"), state);
			getChildXml(state.xml);
			AH.find(document, "form[target=\"authoringFrame\"]").submit();
			$$invalidate(6, editorState.activator = true, editorState);
		}
	}

	const writable_props = ["setInlineEditor", "editorState", "getChildXml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<External> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(1, state.remediationToggle = false, state);

	function dialog_visible_binding(value) {
		state.remediationToggle = value;
		$$invalidate(1, state);
	}

	function snackbar_visible_binding(value) {
		state.snackback = value;
		$$invalidate(1, state);
	}

	$$self.$$set = $$props => {
		if ("setInlineEditor" in $$props) $$invalidate(7, setInlineEditor = $$props.setInlineEditor);
		if ("editorState" in $$props) $$invalidate(6, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(8, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		onMount,
		beforeUpdate,
		onDestroy,
		Button,
		Dialog,
		Checkbox,
		Snackbar,
		Textfield,
		tag_player,
		writable,
		AH,
		Loader,
		UCLIB: UCLIB_1,
		l: language,
		setInlineEditor,
		editorState,
		getChildXml,
		_module,
		type,
		version,
		user_filter_ans,
		qxml,
		message,
		state,
		hdd,
		unsubscribe,
		didMount,
		getAuthoringForm,
		filterUserAnswer,
		toggle,
		handleSequence,
		changeTitle,
		multicheck,
		changeDefault,
		renderPlayer,
		unRenderPlayer,
		remediationMode,
		resetData
	});

	$$self.$inject_state = $$props => {
		if ("setInlineEditor" in $$props) $$invalidate(7, setInlineEditor = $$props.setInlineEditor);
		if ("editorState" in $$props) $$invalidate(6, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(8, getChildXml = $$props.getChildXml);
		if ("_module" in $$props) _module = $$props._module;
		if ("type" in $$props) type = $$props.type;
		if ("version" in $$props) version = $$props.version;
		if ("user_filter_ans" in $$props) user_filter_ans = $$props.user_filter_ans;
		if ("qxml" in $$props) qxml = $$props.qxml;
		if ("message" in $$props) $$invalidate(0, message = $$props.message);
		if ("state" in $$props) $$invalidate(1, state = $$props.state);
		if ("hdd" in $$props) hdd = $$props.hdd;
		if ("unsubscribe" in $$props) unsubscribe = $$props.unsubscribe;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		message,
		state,
		handleSequence,
		changeTitle,
		multicheck,
		changeDefault,
		editorState,
		setInlineEditor,
		getChildXml,
		click_handler,
		dialog_visible_binding,
		snackbar_visible_binding
	];
}

class External extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			setInlineEditor: 7,
			editorState: 6,
			getChildXml: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "External",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*editorState*/ ctx[6] === undefined && !("editorState" in props)) {
			console_1.warn("<External> was created without expected prop 'editorState'");
		}
	}

	get setInlineEditor() {
		throw new Error("<External>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set setInlineEditor(value) {
		throw new Error("<External>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<External>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<External>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<External>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<External>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default External;
//# sourceMappingURL=External-28ee25d1.js.map
