
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, v as validate_slots, L as beforeUpdate, X as XMLToJSON, o as onMount, a4 as jquery, A as AH, w as writable, y as language, a7 as afterUpdate, M as JSONToXML, _ as onUserAnsChange, C as validate_each_argument, c as create_component, f as space, j as attr_dev, k as add_location, n as insert_dev, m as mount_component, q as listen_dev, t as transition_in, r as group_outros, a as transition_out, u as check_outros, x as detach_dev, b as destroy_component, K as destroy_each } from './main-9d98459d.js';
import { I as ItemHelper } from './ItemHelper-f6a7dcd6.js';
import { F as FillInTheBlanksToolbar } from './FillInTheBlanksToolbar-62007022.js';

var ALGO = ALGO || {mathtype:""};

ALGO.init = function (algostr, genereted_str) {	
	let var_list = '';
	try {
		var_list = ALGO.util.generateVariables (algostr, genereted_str);
	} catch(e) {
		swal({
			html: true,          
			title: '',
			text: "<b>"+e+"<br/><br/>Variables are not correctly defined!</b>",
			type: "error"
		});
	}
	console.log('var llist',var_list);
	return var_list;
};

ALGO.util = {
	generateVariables : function (algostr, genereted_str) {
		const regex_mathtype = /is_advance[\s]*=([\s"'\d]*)/;
		//if (genereted_str != "" && genereted_str != "undefined") {
			//return JSON.parse(genereted_str);
		//} else {
			let fnName = "",
				var_list = {};				
			var xml = algostr.split("\n");
			try {			
                ALGO.mathtype = +xml[0].match(regex_mathtype)[1].match(/[\d]+/);
			} catch(err) {
                ALGO.mathtype = "";
			}		
			for (let i = 0; i < xml.length; i++) {			
                let xml_id = xml[i],
				xml_arr = xml_id.split("=");
				fnName = xml_arr[1].substr(0, xml_arr[1].indexOf('(')).trim();	
				switch (fnName) {
					case "rand_int":
					fnName = "randInt";
					break;
					case "rand_float":
						fnName = "randFloat";
						break;
					case "uc_sqrt":
						fnName = "ucSqrt";
						break;
					case "rand_obj":
						fnName = "randObj";
						break;
				}	
				if (typeof ALGO.math[fnName] != 'object') {
					fnName = "";
				}					
				if (fnName != "") {	 
					const regExp = /\(([^)]+)\)/;
					let val_eval = [],
					matches = regExp.exec(xml_arr[1]),
					min,
					max,
					fix_decimal;
					switch (fnName.trim()) {
						case "randInt":
							val_eval = matches[1].split(',');	
							min = parseInt(val_eval[0]);
							max = parseInt(val_eval[1]);
							fix_decimal = parseInt(val_eval[2]);
							var_list[xml_arr[0].trim()] = ALGO.math [fnName].f (min,max,fix_decimal);
							break;
						case "randFloat":
							val_eval = matches[1].split(',');					
							min = parseFloat(val_eval[0]);
							max = parseFloat(val_eval[1]);								
							fix_decimal = parseInt(val_eval[2]);
							var_list[xml_arr[0].trim()] = ALGO.math [fnName].f (min,max,fix_decimal);
							break;
						case "ucSqrt":
							val_eval = matches[1].split(',');	
							min = parseInt(val_eval[0]);
							max = parseInt(val_eval[1]);
							var_list[xml_arr[0].trim()] = ALGO.math [fnName].f (min, max);
							break;
						case "ucPow":
							val_eval = matches[1].split(',');	
							min = parseInt(val_eval[0]);
							max = parseInt(val_eval[1]);
							fix_decimal = parseInt(val_eval[2]);
							var_list[xml_arr[0].trim()] = ALGO.math [fnName].f (min,max,fix_decimal);
						break;						
						default:		
							let string = JSON.stringify(matches[1]);					
							string = string.trim().replace(/"|\\/g,'');					
							var_list[xml_arr[0].trim()] = ALGO.math [fnName].f (string);
					}						 
				}
				if (fnName == "") {								
					const regExp_arth = /(\*|\+|\-|\/|\^|\%|\(|\)|\,|\[|\]|\#)/g,
						regExp_semicolon = /;|\\/g;				
					let test = xml_arr[1].split(regExp_arth),
						expression = "";
					var iscartesian = false;			
					for (let j = 0; j < test.length; j++) {
						test[j] = test[j].trim();
						if (test[j] != ";" && test[j] != "") {
							test[j] = test[j].replace(regExp_semicolon,'');
							if (test[j] == "#") {
								test[j] = "'";								
							} else {
								test[j] = var_list.hasOwnProperty(test[j]) ? var_list[test[j]] : isNaN(+test[j])?test[j]:+test[j];
							}
							let t = test[j];
							t = typeof t == "string" ? t.trim() : t;						
							if (t == 'math.setCartesian') {								
								iscartesian = true;
							}
							expression = expression + test[j];
						} else {
							continue;
						}
					}		
					if (ALGO.mathtype == 2) {
						if (iscartesian == true) {
							var testing = eval(expression),
								str = "";
							for (var k=0;k<testing.length;k++) {
								testing[k] = "("+testing[k]+") ";
								str = str+testing[k];
							}	
							var_list[xml_arr[0].trim()] = str;
						}					
						if (!iscartesian) {
							var_list[xml_arr[0].trim()] = eval(expression).toString();					
						}						
						if (var_list[xml_arr[0].trim()] == "") {
							var_list[xml_arr[0].trim()] = "None of these";
						}				
					} 
					if (ALGO.mathtype == "") {						
						var_list[xml_arr[0].trim()] = eval(expression.trim());
					}
				}				
			}	
			return var_list;
		//}
    }
};
ALGO.init.replaceVariables = function (latex_str, var_list) {
    for (let i in var_list) {
		let temp = "<\{"+i+"\}>";
		var re = new RegExp(temp, "g");
        latex_str = latex_str.replace(re, var_list[i]);		
    }	
    return latex_str;
};

ALGO.math = {
	randObj : {
		text:"Randomize Object",
		description:"Find the random string or character",
		param:"(javascript,java,C,react,php)",
		use:"randObj(javascript,php,java,c)",
		f : function (object) {
			let val_eval = object.split(',');	
			return val_eval[ALGO.math.randInt.f(0,val_eval.length-1)];
		}
	},
	randInt : {
		text:"Randomize Integer",
		description:"Find the random integer value (min-value, max-value, no. of values after decimal)",
		param:"minimunvalue,maximumvalue",
		agrlength:2,
		use:"randInt(1,4,2)",
		f : function (min, max, fix_decimal) {	
			return (Math.floor(Math.random() * (max - min + 1)) + min).toFixed(fix_decimal);
		}
	},
	randFloat : {
		text:"Randomize Float",
		description:"Find the random float/decimal value (min-value, max-value, no. of values after decimal)",
		param:"minimunvalue,maximumvalue",
		agrlength:2,
		use:"randFloat(1,4,2)",
		f : function  (min, max, fix_decimal) {
			return (Math.random() * (max - min) + min).toFixed(fix_decimal);
		}
	},
	ucSqrt : {
		text:"Square root",
		description:"Find the square root (value, no. of values after decimal)",
		param:"minimunvalue,maximumvalue",
		agrlength:2,
		use:"ucSqrt(9,2)",
		f : function  (min, max) {
			return (Math.sqrt(min)).toFixed(max);
		}
	},
	ucPow : {
		text:"Power",
		description:"Return the value of the number 4 to the power of 3(value, power, no. of values after decimal)",
		param:"minimunvalue,maximumvalue",
		agrlength:2,
		use:"ucPow(4,3,2)",
		f : function  (min, max, fix_decimal) {
			return (Math.pow(min, max)).toFixed(fix_decimal);
		}
	}		
};

var Step = ALGO;

/* clsSMStepAlgo/StepAlgoPreview.svelte generated by Svelte v3.29.0 */

const { Object: Object_1, console: console_1, document: document_1 } = globals;
const file = "clsSMStepAlgo/StepAlgoPreview.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-142veau-style";
	style.textContent = ".darkgrey_border{border:1px solid #ccc!important}.p-lg{padding:15px}.true-hover{outline:0;border:2px solid #14ca14!important}.false-hover{outline:0;border:2px solid #e45252!important}.default-hover{border-color:transparent!important;-webkit-box-shadow:inset 0 1px 0px 0px rgba(0,0,0,.075), 0 0 1px rgba(2, 2, 2, 0.9)!important;-moz-box-shadow:inset 0 1px 0px 0px rgba(0,0,0,.075), 0 0 1px rgba(2, 2, 2, 0.9)!important;box-shadow:inset 0 1px 0px 0px rgba(0,0,0,.075), 0 0 1px rgba(2, 2, 2, 0.9)!important}.blocked{display:block !important}.border_green{border:3px solid green!important}.border_red{border:3px solid red!important}.sticky{z-index:800;position:sticky;top:0\n\t}.corr_div{position:absolute!important;width:60px;line-height:30px;background-color:#21a81d;color:#ffffff;z-index:1;display:inline-block;vertical-align:middle;cursor:default}[id^=\"fillmain\"]{overflow:hidden;text-align:left}[id^=\"fillmain\"] pre{background:none;border:none;font-size:14px!important}[id^=\"fillmain\"] .string{min-height:50px;margin-top:10px;margin-right:10px}[id^=\"fillmain\"] .footerstr{position:relative;margin-top:10px;background-color:#ccc;padding:15px;min-height:60px}[id^=\"fillmain\"] .footerstr .arrow-up{position:absolute;top:-10px;right:50%;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:10px solid #ccc}[id^=\"fillmain\"] .fill-row{padding:6px}[id^=\"fillmain\"] .fillelement, [id^=\"fillmain\"] .drag-resize{height:30px;display:inline-block;position:relative;min-height:30px;margin:1px}[id^=\"fillmain\"] input[type=\"text\"], [id^=\"fillmain\"] select{height:99%!important;resize:none;font-size:12px;color:#000;max-width:800px}[id^=\"fillmain\"] .drag-resize{vertical-align:middle;border:1px solid #31B731;text-align:center;padding:3px;font-size:14px}[id^=\"fillmain\"] .drag-resize.ui-draggable{cursor:move}[id^=\"fillmain\"] .drop-hover{border:1px dashed red!important;box-shadow:0 0 0 2px yellow inset;outline:1px solid blue}[id^=\"fillmain\"] .fillcheck ul{width:220px}[id^=\"fillmain\"] .fillcheck li.selected{background-color:#E5E5E5}.fillcheck .selected .icomoon-checkmark-3:before{float:left;color:blue;padding:3px;position:relative;right:14px}.fillcheck .icomoon-close-2:before{float:left;color:blue;position:relative;right:14px;font-size:20px}.MathJax_Display{display:inline!important}[id^=\"fillmain\"] .select{font-size:15px}[id^=\"fillmain\"] .textarea{vertical-align:middle;border-radius:3px;background:#ffe;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.ui-draggable-disabled{cursor:no-drop!important;opacity:0.5!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RlcEFsZ29QcmV2aWV3LnN2ZWx0ZSIsInNvdXJjZXMiOlsiU3RlcEFsZ29QcmV2aWV3LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tIFxuKiAgRmlsZSBOYW1lICAgOiBTdGVwQWxnb1ByZXZpZXcuc3ZlbHRlXG4qICBEZXNjcmlwdGlvbiA6IHNob3cgdGhlIGJveGVzIGZvciB1c2VycyBzaWRlXG4qICBBdXRob3IgICAgICA6IFN1bmRhcmFtIFRyaXBhdGhpXG4qICBWZXJzaW9uICAgICA6IDEuMFxuKiAgUGFja2FnZSAgICAgOiBwZS1pdGVtc1xuKiAgTGFzdCB1cGRhdGUgOiAgLS0+XG48c2NyaXB0PlxuICAgIGltcG9ydCB7d3JpdGFibGV9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5cdGltcG9ydCBqdSBmcm9tICcuLi9zcmMvbGlicy9qc2xpYic7XG5cdGltcG9ydCBBTEdPIGZyb20gXCIuL1N0ZXAuanNcIjtcbiAgICBpbXBvcnQgbCBmcm9tICcuLi9zcmMvbGlicy9lZGl0b3JMaWIvbGFuZ3VhZ2UuanMnO1xuICAgIGltcG9ydCB7IG9uTW91bnQsYWZ0ZXJVcGRhdGUsIGJlZm9yZVVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gICAgaW1wb3J0IHtBSCxYTUxUb0pTT04sSlNPTlRvWE1MLG9uVXNlckFuc0NoYW5nZX0gZnJvbSBcIi4uL2hlbHBlci9IZWxwZXJBSS5zdmVsdGVcIjtcblx0aW1wb3J0IEZpbGxJblRoZUJsYW5rc1Rvb2xiYXIgZnJvbSAnLi4vY2xzU01GaWxsL0ZpbGxJblRoZUJsYW5rc1Rvb2xiYXIuc3ZlbHRlJztcblx0aW1wb3J0IEl0ZW1IZWxwZXIgZnJvbSAnLi4vaGVscGVyL0l0ZW1IZWxwZXIuc3ZlbHRlJztcblx0aW1wb3J0ICcuLi9zcmMvbGlicy9tYXRocXVpbGwuY3NzJztcblxuICAgIGxldCBzdGVwX3htbDtcbiAgICBsZXQgc21hbnMgPSB7fTtcbiAgICBsZXQgdXNhbnMgPSB7fTtcbiAgICBsZXQgZWxlbWVudF9pZCwgZWxlbWVudF9kaXYgPSAnJztcbiAgICBsZXQgY2RhdGEgPSAnJztcbiAgICBsZXQgZmlsbF9tYXRoID0gW107XG4gICAgdmFyIGFuc3dlcl9hcnJheSA9IFtdO1xuXHRsZXQgYnRudHlwZTtcblx0bGV0IHJlc3VsdE5ldyA9IHt9O1xuXG5cbiAgICBsZXQgdmFyX2xpc3QgPSAnJztcblx0bGV0IHNwZWNpYWxfbW9kdWxlID0ge307XG5cdGxldCBsaXN0cyA9ICcnO1xuXHRsZXQgb2xkc3RlcCA9ICcnO1xuXHRsZXQgYW5zd2VyX2FyciA9IFtdO1xuXHRsZXQgZmlsbElkO1xuXHRsZXQgc3RlcHMgPSAwO1xuXHRsZXQgd3JvbmdfY2hvaWNlID0gMDtcblx0bGV0IG9wdGlvbnJlbSA9IDA7XHRcblx0bGV0IGZsYWd4bWwgPSBmYWxzZTtcbiAgICBsZXQgc3RhdGUgPSB7fTtcblxuICAgIGV4cG9ydCBsZXQgeG1sO1xuICAgIGV4cG9ydCBsZXQgc3RvcFByZXZpZXdVcGRhdGU7XG5cdGV4cG9ydCBsZXQgaXNSZXZpZXc7XG5cdGV4cG9ydCBsZXQgdXhtbDtcblxuICAgIGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7XG4gICAgICAgICAgICBibGFuayAgICAgICAgICAgICAgICAgICA6IHRydWUsXG5cdFx0XHRoaWRlTmV4dCAgICAgICAgICAgICAgICA6IGZhbHNlLFxuXHRcdFx0aXRlbUFycmF5ICAgICAgICAgICAgICAgOiBbXSxcblx0XHRcdGNsYXNzQ2hhbmdlICAgICAgICAgICAgIDogLTEsXG5cdFx0XHRpc0NvbG9yICAgICAgICAgICAgICAgICA6IHRydWUsXG5cdFx0XHRzbUNvbnRyb2xsZXIgICAgICAgICAgICA6IFwiaFwiLFxuXHRcdFx0ZGlzcGxheSAgICAgICAgICAgICAgICAgOiAtMSxcblx0XHRcdHNob3dUb29sYmFyICAgICAgICAgICAgIDogdHJ1ZSxcblx0XHRcdGlzTWF0aHF1aWxsICAgICAgICAgICAgIDogZmFsc2UsXG5cdFx0XHRjb3JyZWN0X2Fuc3dlciAgICAgICAgICA6IHRydWUsXG5cdFx0XHRtYWluX3N0ZXBzICAgICAgICAgICAgICA6IGZhbHNlLFxuXHRcdFx0eW91cl9hbnN3ZXIgICAgICAgICAgICAgOiBbXVxuICAgIH0pO1xuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdGF0ZURhdGEuc3Vic2NyaWJlKChpdGVtcyk9PntcbiAgICAgICAgc3RhdGUgPSBpdGVtcztcbiAgICB9KVxuXG5cdCQ6e1xuXHRcdGlmIChpc1Jldmlldykge1xuXHRcdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2V0UmV2aWV3KCk7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHR9LDUwMCk7XHRcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHRpbWVyX25leHQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR1bnNldFJldmlldygpO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXJfbmV4dCk7XG5cdFx0XHR9LDIwMCk7XG5cdFx0fVxuXHR9XG5cblx0YmVmb3JlVXBkYXRlKCgpPT57XG5cdFx0aWYoc3RhdGUuaXNNYXRocXVpbGwpIHtcblx0XHRcdGxvYWRMaWJzKCk7XG5cdFx0fVxuXHRcdGlmICh1eG1sKSB7XG5cdFx0XHRsZXQgYW5zd2VyID0gWE1MVG9KU09OKHV4bWwpO1xuXHRcdFx0aWYgKGFuc3dlci5zbWFucykge1xuXHRcdFx0XHRpZiAoYW5zd2VyLnNtYW5zLmRpdikge1xuXHRcdFx0XHRcdGlmIChhbnN3ZXIuc21hbnMuZGl2Ll91c2VyQW5zKSB7XG5cdFx0XHRcdFx0XHRwYXJzZVN0ZXBzKHV4bWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKHhtbCAhPSBzdGF0ZS54bWwpIHtcblx0XHRcdHN0YXRlLnhtbCA9IHhtbDtcblx0XHRcdGlmIChzdG9wUHJldmlld1VwZGF0ZSA9PSB0cnVlKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRpZiAoIXV4bWwpIHtcblx0XHRcdFx0c3RlcHMgPSAwO1xuXHRcdFx0XHRzdGF0ZS5pdGVtQXJyYXkgPSBbXTtcdFxuXHRcdFx0XHRzdGVwX3htbCwgc21hbnMsIHVzYW5zID0ge307XG5cdFx0XHRcdHN0YXRlLmhpZGVOZXh0ID0gZmFsc2U7XHRcdFx0XG5cdFx0XHRcdHJlc2V0KCk7XG5cdFx0XHR9XG5cdFx0XHRzdGF0ZS5ibGFuayA9IGZhbHNlO1xuXHRcdFx0bGV0IG5ld194bWwgPSBYTUxUb0pTT04oc3RhdGUueG1sKTtcblx0XHRcdGxvYWRNb2R1bGUobmV3X3htbCk7XG5cdFx0fVxuXHR9KVxuXG5cdG9uTW91bnQoKCk9Pntcblx0XHR3aW5kb3cuSiA9IGp1O1xuXHRcdEFJLnNldCgnc3RlcEFsZ28nLCB0aGlzKTtcblxuXHRcdEFILmFkZFNjcmlwdChcIlwiLCBcImh0dHBzOi8vYWpheC5nb29nbGVhcGlzLmNvbS9hamF4L2xpYnMvanF1ZXJ5LzEuMTEuMC9qcXVlcnkubWluLmpzXCIpO1xuXHRcdEFILmFkZFNjcmlwdChcIlwiLCB3aW5kb3cuaXRlbUZvbGRlciArIFwic3JjL2xpYnMvbWF0aFF1aWxsX25ldy5qc1wiKTtcblxuXHRcdGlmKHdpbmRvdy5pbk5hdGl2ZSkge1xuXHRcdFx0d2luZG93LmdldEhlaWdodCAmJiB3aW5kb3cuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly9qUXVlcnkoJy50b29sYmFyX2NvbnRhaW5lcl9vbmUnKS5hZGRDbGFzcygnaC1pbXAnKTtcblx0XHRcdEFILnNlbGVjdEFsbCgnLnRvb2xiYXJfY29udGFpbmVyX29uZScsJ2FkZENsYXNzJywnaC1pbXAnKTtcblx0XHR9LCAxMDApO1xuXG5cdFx0QUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJy5lZGl0X3N0ZXAnLChfZWxlbWVudCkgPT4ge1xuXHRcdFx0c2V0T3V0bGluZShfZWxlbWVudClcblx0XHR9KVxuXG5cdFx0QUgubGlzdGVuKGRvY3VtZW50LCdrZXl1cCcsJy5lZGl0X3N0ZXAnLChfZWxlbWVudCk9Pntcblx0XHRcdHNldE91dGxpbmUoX2VsZW1lbnQpXG5cdFx0fSlcblxuXHRcdEFILmxpc3Rlbihkb2N1bWVudCwnY2hhbmdlJywnLmVkaXRfc3RlcCcsKF9lbGVtZW50KT0+e1xuXHRcdFx0c2V0T3V0bGluZShfZWxlbWVudClcblx0XHR9KVxuXG5cdFx0QUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJ3NwYW4ubXEtZWRpdGFibGUtZmllbGQubXEtZm9jdXNlZCcsKF9lKT0+e1xuXHRcdFx0bGV0IHNwYW5fbWF0aCA9IF9lO1xuXHRcdFx0bGV0IGlzX2ZpbGxpZCA9IHRydWU7XG5cdFx0XHRsZXQgZmlsbGlkO1xuXHRcdFx0d2hpbGUoaXNfZmlsbGlkKSB7XG5cdFx0XHRcdHNwYW5fbWF0aCA9IHNwYW5fbWF0aC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRpZiAoc3Bhbl9tYXRoLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuXHRcdFx0XHRcdGlzX2ZpbGxpZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGZpbGxpZCA9IHNwYW5fbWF0aC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0XHRcdFx0ZmlsbElkID0gZmlsbGlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRsZXQgbGF0ZXhfYXJyYXkgPSBbXTtcblx0XHRcdEFILnNlbGVjdEFsbChcIiNcIiArZmlsbGlkICsgXCIgc3Bhbi5tcS1lZGl0YWJsZS1maWVsZFwiKS5mb3JFYWNoKChfdGhpcyk9PiB7XG5cdFx0XHRcdGxldCBjb21tYW5kX2lkID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdtYXRocXVpbGwtY29tbWFuZC1pZCcpO1xuXHRcdFx0XHRsYXRleF9hcnJheS5wdXNoKGNvbW1hbmRfaWQpO1xuXHRcdFx0fSk7IC8vIE5lZWQgdG8gZml4ZWQgaXRcblxuXHRcdFx0bGV0IG1hdGhfaWQgPSBfZS5nZXRBdHRyaWJ1dGUoJ21hdGhxdWlsbC1jb21tYW5kLWlkJyk7XG5cdFx0XHRsZXQgaW5kZXhfaWQgPSBsYXRleF9hcnJheS5pbmRleE9mKG1hdGhfaWQpO1xuXHRcdFx0c3RhdGUuc3BhbklkID0gaW5kZXhfaWQ7XG5cdFx0XHRzdGF0ZS5kaXZJZCA9IGZpbGxpZDtcblx0XHRcdFxuXHRcdFx0QUguc2VsZWN0QWxsKCcudG9vbGJhcl9jb250YWluZXJfb25lJywncmVtb3ZlQ2xhc3MnLCdoLWltcCcpO1xuXHRcdFx0c3RhdGUuc2hvd1Rvb2xiYXIgPSB0cnVlO1xuXHRcdH0pXG5cdFx0XG5cdFx0Ly8galF1ZXJ5KGRvY3VtZW50KS5vbignY2xpY2snLCAnLm5leHRfc3RlcCcsIGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBcdGlmICh0eXBlb2YgUVVJWlBMQVlFUklEICE9IFwidW5kZWZpbmVkXCIpIHtcblx0XHQvLyBcdFx0d2luZG93LnBhcmVudC5hdXRvUmVzaXplKFFVSVpQTEFZRVJJRCk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gXHRpbnB1dEZpbGxlZCgpO1xuXHRcdC8vIH0pO1xuXG5cdFx0QUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJy5uZXh0X3N0ZXAnLGZ1bmN0aW9uKGN1cnIsZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBRVUlaUExBWUVSSUQgIT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHR3aW5kb3cucGFyZW50RWxlbWVudC5hdXRvUmVzaXplKFFVSVpQTEFZRVJJRCk7XG5cdFx0XHR9XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRpbnB1dEZpbGxlZCgpO1xuXHRcdH0pXG5cdFx0XG5cdFx0Ly8gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHQvLyBcdGpRdWVyeShcIiNzZXQtcmV2aWV3XCIpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHRzZXRSZXZpZXcoKTtcblx0XHQvLyBcdH0pO1xuXHRcdC8vIFx0alF1ZXJ5KFwiI3Vuc2V0LXJldmlld1wiKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcblx0XHQvLyBcdFx0dW5zZXRSZXZpZXcoKTtcblx0XHQvLyBcdH0pO1xuXHRcdC8vIH0sMTAwMCk7XG5cblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0QUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJyNzZXQtcmV2aWV3JyxmdW5jdGlvbigpIHtcblx0XHRcdFx0c2V0UmV2aWV3KCk7XG5cdFx0XHR9KVxuXHRcdFx0QUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJyN1bnNldC1yZXZpZXcnLGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR1bnNldFJldmlldygpO1xuXHRcdFx0fSlcblx0XHR9LDEwMDApO1xuXG5cdFx0aWYgKHdpbmRvdy5pbk5hdGl2ZSkge1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0d2luZG93LnBvc3RNZXNzYWdlKCdoZWlnaHRfX18nK2RvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2luTmF0aXZlU3R5bGUnKVswXS5vZmZzZXRIZWlnaHQsJyonKTtcblx0XHRcdH0sIDIwMCk7XG5cdFx0fVxuXG5cdFx0aWYod2luZG93LmluTmF0aXZlKSB7XG5cdFx0XHR3aW5kb3cuY2hlY2tSZXZpZXcgPSAoaXNSZXZpZXcpID0+IGlzUmV2aWV3ID8gc2VsZi5zZXRSZXZpZXcoKSA6IHNlbGYudW5zZXRSZXZpZXcoKTtcblx0XHR9XG5cdFx0QUguYWRkU2NyaXB0KFwiXCIsIHdpbmRvdy5tYWluU2l0ZVRoZW1lVXJsICsgXCJwcmVwZW5naW5lL21hdGhxdWlsbC5qc1wiKTtcblx0fSlcblxuXHRmdW5jdGlvbiBzZXRPdXRsaW5lKF9lbGVtZW50KSB7XG5cdFx0aWYgKCBfZWxlbWVudC5ub2RlTmFtZSkge1xuXHRcdFx0aWYgKF9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbWF0aHF1aWxsJykpIHtcblx0XHRcdFx0bWF0aHF1aWxsQW5zKF9lbGVtZW50LCBmYWxzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgaW5wX2lkID0gIF9lbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRcdFx0bGV0IGlucF9kaXYgPSBfZWxlbWVudC5jbG9zZXN0KCdkaXYnKS5nZXRBdHRyaWJ1dGUoJ3NlcScpO1xuXHRcdFx0XHRsZXQgaW5wX3ZhbCA9IF9lbGVtZW50LnZhbHVlO1xuXHRcdFx0XHR1c2FucyA9IGNyZWF0ZUFucyh1c2FucywgaW5wX2lkLCBpbnBfZGl2LCBpbnBfdmFsKTtcblx0XHRcdFx0bGV0IHNtYW5zX292ZXJhbGwgPSBzbWFucztcblx0XHRcdFx0c2V0VXNlckFucyh1c2Fucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5wdXRGaWxsZWQoKSB7XG5cdFx0aWYgKHVzYW5zKSB7XG5cdFx0XHRmb3IgKGxldCBpIGluIHVzYW5zKSB7XG5cdFx0XHRcdGZvciAobGV0IGtleSBpbiB1c2Fuc1tpXSkge1xuXHRcdFx0XHRcdGxldCBhbnNfdmFsID0gdXNhbnNbaV1ba2V5XS52YWx1ZTtcblx0XHRcdFx0XHRpZiAoYW5zX3ZhbCAhPSAnJykge1xuXHRcdFx0XHRcdFx0bGV0IGFuc19hcnIgPSBhbnNfdmFsLm1hdGNoKC9NYXRoUXVpbGxNYXRoRmllbGRcXHsoLio/KVxcfS9nKTtcblx0XHRcdFx0XHRcdGlmIChhbnNfYXJyKSB7XG5cdFx0XHRcdFx0XHRcdGFuc19hcnIubWFwKGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBtYXRoX2ZpZWxkID0gb2JqLnRvU3RyaW5nKCkucmVwbGFjZSgvTWF0aFF1aWxsTWF0aEZpZWxkXFx7fFxcfS9nLCAnJylcblx0XHRcdFx0XHRcdFx0XHRpZiAobWF0aF9maWVsZCA9PSAnJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly9qUXVlcnkoXCIjXCIra2V5KS5yZW1vdmVDbGFzcygnYW5zd2VyX2lucHV0Jyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRBSC5zZWxlY3QoXCIjXCIra2V5LCdyZW1vdmVDbGFzcycsJ2Fuc3dlcl9pbnB1dCcpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvL2pRdWVyeShcIiNcIitrZXkpLmFkZENsYXNzKCdhbnN3ZXJfaW5wdXQnKTtcblx0XHRcdFx0XHRcdFx0XHRcdEFILnNlbGVjdChcIiNcIitrZXksJ2FkZENsYXNzJywnYW5zd2VyX2lucHV0Jyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8valF1ZXJ5KFwiI1wiK2tleSkuYWRkQ2xhc3MoJ2Fuc3dlcl9pbnB1dCcpO1xuXHRcdFx0XHRcdFx0XHRBSC5zZWxlY3QoXCIjXCIra2V5LCdhZGRDbGFzcycsJ2Fuc3dlcl9pbnB1dCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvL2pRdWVyeShcIiNcIitrZXkpLnJlbW92ZUNsYXNzKCdhbnN3ZXJfaW5wdXQnKTtcblx0XHRcdFx0XHRcdEFILnNlbGVjdChcIiNcIitrZXksJ3JlbW92ZUNsYXNzJywnYW5zd2VyX2lucHV0Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbiAgICBmdW5jdGlvbiBsb2FkTW9kdWxlKG5ld194bWwpIHtcblx0XHRmbGFneG1sID0gZmFsc2U7XG5cdFx0aWYobmV3X3htbC5zbXhtbC5hbGdvICE9IFwidW5kZWZpbmVkXCIgJiYgbmV3X3htbC5zbXhtbC5hbGdvKSB7XG5cdFx0XHRmbGFneG1sID0gdHJ1ZTtcdFx0XG5cdFx0fVxuXHRcdGlmKGZsYWd4bWwpIHtcblx0XHRcdHZhcl9saXN0ID0gQUxHTy5pbml0KG5ld194bWwuc214bWwuYWxnbyk7XG5cdFx0fVxuXHRcdGxldCB4bWxfc3RyID0gSlNPTi5zdHJpbmdpZnkobmV3X3htbCk7XG5cdFx0aWYoZmxhZ3htbCkge1xuXHRcdFx0aWYgKHV4bWwpIHtcblx0XHRcdFx0bGV0IGFuc3dlciA9IFhNTFRvSlNPTih1eG1sKTtcblx0XHRcdFx0aWYgKGFuc3dlci5zbWFucykge1xuXHRcdFx0XHRcdGlmIChhbnN3ZXIuc21hbnMuZGl2KSB7XG5cdFx0XHRcdFx0XHRpZiAoYW5zd2VyLnNtYW5zLmRpdi5fbGlzdHMpIHtcblx0XHRcdFx0XHRcdFx0dmFyX2xpc3QgPSBsaXN0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0ZXBfeG1sID0gQUxHTy5pbml0LnJlcGxhY2VWYXJpYWJsZXMoeG1sX3N0ciwgdmFyX2xpc3QpO1xuXHRcdFx0c3RlcF94bWwgPSBKU09OLnBhcnNlKHN0ZXBfeG1sKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RlcF94bWwgPSBuZXdfeG1sO1xuXHRcdH1cblx0XHRsZXQgYW5zd2VyX2Fycl9jbG9uZSA9IHN0ZXBfeG1sLnNteG1sLnN0ZXA7XG5cdFx0YW5zd2VyX2FycmF5ID0gYW5zd2VyX2Fycl9jbG9uZS5zbGljZSgpO1xuXHRcdGlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRPYmplY3QuYXNzaWduID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHRcdCd1c2Ugc3RyaWN0Jztcblx0XHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0ID0gT2JqZWN0KHRhcmdldCk7XG5cdFx0XHRcdGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRcdFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cdFx0XHRcdFx0aWYgKHNvdXJjZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0YW5zd2VyX2Fycl9jbG9uZS5tYXAoZnVuY3Rpb24oaXRlbSwgaSkge1xuXHRcdFx0YW5zd2VyX2FycmF5W2ldID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSk7XG5cdFx0fSk7XG5cdFx0aWYgKG9sZHN0ZXAgIT0gJycpIHtcblx0XHRcdHN0ZXBzID0gb2xkc3RlcDtcblx0XHRcdGZvciAobGV0IGk9MDsgaTw9b2xkc3RlcDsgaSsrKSB7XG5cdFx0XHRcdGNyZWF0ZVN0ZXAoaSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNyZWF0ZVN0ZXAoKTtcblx0XHR9XG5cdFx0aWYgKHV4bWwpIHtcblx0XHRcdGxldCBhbnN3ZXIgPSBYTUxUb0pTT04odXhtbCk7XG5cdFx0XHRpZiAoYW5zd2VyLnNtYW5zKSB7XG5cdFx0XHRcdGlmIChhbnN3ZXIuc21hbnMuZGl2KSB7XG5cdFx0XHRcdFx0aWYgKGFuc3dlci5zbWFucy5kaXYuX3VzZXJBbnMpIHtcblx0XHRcdFx0XHRcdHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlVXNlckFucyh1eG1sKTtcblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0XHRcdH0sNTApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlVXNlckFucyh1YW5zKSB7XG5cdFx0bGV0IHVzZXJfYW5zd2VyID0gWE1MVG9KU09OKHVhbnMpO1xuICAgICAgICBpZiAodXNlcl9hbnN3ZXIuc21hbnMgJiYgdXNlcl9hbnN3ZXIuc21hbnMuZGl2ICYmIHVzZXJfYW5zd2VyLnNtYW5zLmRpdi5fdXNlckFucykge1xuXHRcdFx0dXNlcl9hbnN3ZXIgPSBKU09OLnBhcnNlKHVzZXJfYW5zd2VyLnNtYW5zLmRpdi5fdXNlckFucyk7XG5cdFx0XHRmb3IgKGxldCBpIGluIHVzZXJfYW5zd2VyKSB7XG5cdFx0XHRcdGZvciAobGV0IGogaW4gdXNlcl9hbnN3ZXJbaV0pIHtcblx0XHRcdFx0XHRsZXQgcnVubiA9IGkuc3BsaXQoJycpO1xuXHRcdFx0XHRcdGxldCB2YWwgPSBydW5uWzFdO1xuXHRcdFx0XHRcdGxldCBib3hfdmFsdWUgPSB1c2VyX2Fuc3dlcltpXVtqXS52YWx1ZTtcblx0XHRcdFx0XHRpZiAoQUguc2VsZWN0KCcjJytqKS5jbGFzc0xpc3QuY29udGFpbnMoJ21hdGhxdWlsbCcpKSB7XG5cdFx0XHRcdFx0XHQvL2pRdWVyeSgnIycraikuYXR0cigndXNlcmFucycsIGJveF92YWx1ZSk7XG5cdFx0XHRcdFx0XHRBSC5zZWxlY3QoJyMnK2osJ3VzZXJhbnMnLGJveF92YWx1ZSk7XG5cdFx0XHRcdFx0XHRtYXRocXVpbGxBbnMoJyMnK2osIFwibWF0aF91c2VyXCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvL2pRdWVyeSgnIycraikudmFsKGJveF92YWx1ZSkuZm9jdXMoKS5ibHVyKCk7IFxuXHRcdFx0XHRcdFx0QUguc2VsZWN0KCcjJytqKS52YWx1ZSA9IGJveF92YWx1ZTtcblx0XHRcdFx0XHRcdHNldE91dGxpbmUoQUguc2VsZWN0KCcjJytqKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b3B0aW9ucmVtID0gMDsgXG5cdFx0XHRcdFx0aW5wdXRGaWxsZWQoKTtcblx0XHRcdFx0XHRjaGVja0Fucyh2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG4gICAgICAgICAgICAvL2ZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cblx0fVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU3RlcChpKSB7XG5cdFx0aWYoZmxhZ3htbCkge1xuXHRcdFx0c3BlY2lhbF9tb2R1bGUudmFyX2xpc3QgPSB2YXJfbGlzdDtcblx0XHR9XG5cdFx0c3BlY2lhbF9tb2R1bGUuY3V1cmVudFN0ZXAgPSBzdGVwcztcblx0XHRvcHRpb25yZW0gPSAwO1x0XG5cdFx0Y29uc3QgaXRlbSA9IHN0YXRlLml0ZW1BcnJheTtcblx0XHRwYXJzZVhtbEF1dGhvcmluZyhzdGVwX3htbCwgaSk7XG5cdFx0aXRlbS5wdXNoKHsgY2RhdGEgfSk7ICAgICAgICAgXG5cdFx0c3RhdGUuaXRlbUFycmF5ID0gaXRlbTtcblx0XHRpZiAoaSA8PSBvbGRzdGVwKSB7XG5cdFx0XHR2YXIgY3VyciA9IGk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjdXJyID0gc3RlcHM7XG5cdFx0fVxuXHRcdHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZigoc3RlcF94bWwuc214bWwuc3RlcFtjdXJyKzFdID09IHVuZGVmaW5lZCAmJiBzdGVwX3htbC5zbXhtbC5zdGVwW2N1cnJdLl9hdHRlbXB0ID09IFwiMVwiKSB8fCAoc3RlcF94bWwuc214bWwuc3RlcFtjdXJyKzFdID09IHVuZGVmaW5lZCAmJiBzdGVwX3htbC5zbXhtbC5zdGVwW2N1cnJdLl92aWV3b25seSA9PSBcIjFcIikpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBzZWxmLnNldFN0YXRlKHtoaWRlTmV4dDp0cnVlfSk7IFxuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHR9LDUwMCk7XG5cdH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuXHRcdC8valF1ZXJ5KGRvY3VtZW50KS5maW5kKCcuc3RpY2t5JykucmVtb3ZlQ2xhc3MoJ3N0aWNreScpO1xuXHRcdEFILmZpbmQoZG9jdW1lbnQsJy5zdGlja3knLHtcblx0XHRcdGFjdGlvbjoncmVtb3ZlQ2xhc3MnLFxuXHRcdFx0YWN0aW9uRGF0YTonc3RpY2t5J1xuXHRcdH0pXG5cdFx0Ly9qUXVlcnkoJy5lZGl0X3N0ZXAnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuXHRcdEFILnNlbGVjdEFsbCgnLmVkaXRfc3RlcCcsJ3JlbW92ZUF0dHInLCdkaXNhYmxlZCcpO1xuXG5cdFx0Ly9qUXVlcnkoJy5lZGl0X3N0ZXAnKS52YWwoJycpO1xuXHRcdEFILnNlbGVjdEFsbCgnLmVkaXRfc3RlcCcpLnZhbHVlID0gJyc7XG5cdH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlWG1sQXV0aG9yaW5nKE1ZWE1MLCB1c2VyX3htbCkge1xuXHRcdGlmICh1c2VyX3htbCA8PSBvbGRzdGVwKSB7XG5cdFx0XHRjZGF0YSA9IE1ZWE1MLnNteG1sLnN0ZXBbdXNlcl94bWxdLl9fY2RhdGE7XHRcblx0XHRcdGNyZWF0aW5nSW50ZXJhY3RpdmUodXNlcl94bWwsIGNkYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKE1ZWE1MLnNteG1sLnN0ZXBbc3RlcHNdICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjZGF0YSA9IE1ZWE1MLnNteG1sLnN0ZXBbc3RlcHNdLl9fY2RhdGE7XG5cdFx0XHRcdGNyZWF0aW5nSW50ZXJhY3RpdmUodXNlcl94bWwsIGNkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGluZ0ludGVyYWN0aXZlKHVzZXJfeG1sLCBjZGF0YSwgaW5kZXgpIHtcblx0XHRsZXQgYW5zd2VyX2tleSA9IGNkYXRhLm1hdGNoKC8le1tcXHNcXFNdKj99JS9nbSk7XG5cdFx0bGV0IGFuc3dlcl90eXBlID0gJyc7XG5cdFx0bGV0IGNoZWNrX3R5cGUgPSBbXTtcblx0XHRsZXQgdWF4bWxfbmV3ID0gXCJcIjtcblx0XHRsZXQgdG90YWxfbWFya3MgPSAwO1xuXHRcdGlmIChhbnN3ZXJfa2V5KSB7XG5cdFx0XHQvL2pRdWVyeShhbnN3ZXJfa2V5KS5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdGFuc3dlcl9rZXkuZm9yRWFjaChmdW5jdGlvbihkYXRhLGkpIHtcblx0XHRcdFx0aWYoaW5kZXggIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFyIG9yZ19jZGF0YSA9IGFuc3dlcl9hcnJheVtpbmRleF0uX19jZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b3RhbF9tYXJrcysrO1xuXHRcdFx0XHRsZXQgb3JpZ2luYWxLZXkgPSBhbnN3ZXJfa2V5W2ldO1xuXHRcdFx0XHRhbnN3ZXJfdHlwZSA9IGFuc3dlcl9rZXlbaV0ubWF0Y2goL1xcfCguKj8pfSUkL2dtKTtcblx0XHRcdFx0YW5zd2VyX3R5cGUgPSAoYW5zd2VyX3R5cGUpID8gYW5zd2VyX3R5cGVbMF0ucmVwbGFjZSgvXFx8fH0lL2dtLCAnJykgOiAnJztcblx0XHRcdFx0YW5zd2VyX3R5cGUgPSBhbnN3ZXJfdHlwZS50cmltKCk7XG5cdFx0XHRcdGNoZWNrX3R5cGUucHVzaChhbnN3ZXJfdHlwZSk7XG5cdFx0XHRcdGlmIChhbnN3ZXJfdHlwZSA9PSAnJyB8fCBhbnN3ZXJfdHlwZSA9PSAnYycpIHtcblx0XHRcdFx0XHRpZihpbmRleCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNyZWF0ZVRleHRib3gob3JpZ2luYWxLZXksIGksIHVzZXJfeG1sLCBpbmRleCwgb3JnX2NkYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3JlYXRlVGV4dGJveChvcmlnaW5hbEtleSwgaSwgdXNlcl94bWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhbnN3ZXJfdHlwZSA9PSAnbicpIHtcblx0XHRcdFx0XHRpZihpbmRleCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNyZWF0ZVRleHRib3gob3JpZ2luYWxLZXksIGksIHVzZXJfeG1sLCBpbmRleCwgb3JnX2NkYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3JlYXRlVGV4dGJveChvcmlnaW5hbEtleSwgaSwgdXNlcl94bWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhbnN3ZXJfdHlwZSA9PSBcImVcIikge1xuXHRcdFx0XHRcdHN0YXRlLmlzTWF0aHF1aWxsID0gdHJ1ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaW5kZXggIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRjcmVhdGVNYXRoRGl2KG9yaWdpbmFsS2V5LCBpLCB1c2VyX3htbCwgaW5kZXgsIG9yZ19jZGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNyZWF0ZU1hdGhEaXYob3JpZ2luYWxLZXksIGksIHVzZXJfeG1sKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2xhc3MoaW5kZXgpIHtcblx0XHRpZiAoaW5kZXggPT0gc3RhdGUuY2xhc3NDaGFuZ2UpIHtcblx0XHRcdGlmIChzdGF0ZS5pc0NvbG9yKSB7XG5cdFx0XHRcdHJldHVybiBcImJvcmRlcl9ncmVlblwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIFwiYm9yZGVyX3JlZFwiO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb3JyZWN0KGlkKSB7XG5cdFx0aWYgKHN0YXRlLmRpc3BsYXkgPT0gMSkge1xuXHRcdFx0aWYgKHNwZWNpYWxfbW9kdWxlLnNtYW5zICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoc3BlY2lhbF9tb2R1bGUuc21hbnNbaWRdICE9IHVuZGVmaW5lZCkge1x0XG5cdFx0XHRcdFx0aWYgKHNwZWNpYWxfbW9kdWxlLnNtYW5zW2lkXS5vdmVyYWxsID09IDEpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnYm9yZGVyX2dyZWVuJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuICdib3JkZXJfcmVkJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzU3RpY2t5KGluZGV4KSB7XG5cdFx0aWYoc3RlcF94bWwuc214bWwuc3RlcFtpbmRleF0gIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAoc3RlcF94bWwuc214bWwuc3RlcFtpbmRleF0uX3N0aWNreSA9PSAxKSB7XG5cdFx0XHRcdHJldHVybiBcInN0aWNreVwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHRvZ2dsZVRvb2xiYXIodmFsdWUpIHtcblx0XHRzdGF0ZS5zaG93VG9vbGJhciA9IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbW92ZU5leHQoKSB7XG5cdFx0aWYgKHR5cGVvZiBRVUlaUExBWUVSSUQgIT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHR3aW5kb3cucGFyZW50RWxlbWVudC5hdXRvUmVzaXplKFFVSVpQTEFZRVJJRCk7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdFx0aWYgKHN0ZXBfeG1sLnNteG1sLnN0ZXBbc3RlcHMrMV0gIT0gdW5kZWZpbmVkIHx8IHN0ZXBfeG1sLnNteG1sLnN0ZXBbc3RlcHNdLl9hdHRlbXB0ID09IFwiMVwiKSB7XG5cdFx0XHRpZihzdGVwX3htbC5zbXhtbC5fZ29uZXh0ID09IDEpIHtcblx0XHRcdFx0bmV4dGJ0bkFuc3dlcigpO1xuXHRcdFx0fSBlbHNlIHtcdFxuXHRcdFx0XHRpZiAoc3RlcF94bWwuc214bWwuc3RlcFtzdGVwc10uX2F0dGVtcHQgPT0gMSkge1xuXHRcdFx0XHRcdGlmIChBSC5zZWxlY3RBbGwoJy5lZGl0X3N0ZXAnKS5sZW5ndGggPT0gQUguc2VsZWN0QWxsKCcuYW5zd2VyX2lucHV0JykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjaGVja0FucygpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRub3RGaWxsZWQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7IFxuXHRcdFx0XHRcdG5leHRTdGVwKCk7XG5cdFx0XHRcdFx0YWRkU3RpY2t5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKChzdGVwX3htbC5zbXhtbC5zdGVwLmxlbmd0aCA8PSAoc3RlcF94bWwuc214bWwuc3RlcFtzdGVwc10uX3NlcSkpICYmIHN0ZXBfeG1sLnNteG1sLnN0ZXBbc3RlcHNdLl9hdHRlbXB0ICE9IDEpIHtcblx0XHRcdFx0c3RhdGUuaGlkZU5leHQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGF0ZS5oaWRlTmV4dCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbmV4dFN0ZXAoKSB7XG5cdFxuXHRcdEFILnNlbGVjdEFsbCgnLmVkaXRfc3RlcCcpLmZvckVhY2goKF90aGlzKT0+e1xuXHRcdFx0aWYoX3RoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdtYXRocXVpbGwnKSkge1xuXHRcdFx0XHRpZigoKF90aGlzLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVfZGl2XCIpKSkge1xuXHRcdFx0XHRcdEFILnNlbGVjdChfdGhpcy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCdyZW1vdmVDbGFzcycsJ2gnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3RoaXMuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0X3RoaXMuY2xhc3NMaXN0LmFkZCgnZGF0YS1jaGVjaycpO1xuXHRcdH0pXG5cdFx0b3B0aW9ucmVtID0gMDtcblx0XHRpZihzdGVwX3htbC5zbXhtbC5zdGVwW3N0ZXBzKzFdID09IHVuZGVmaW5lZCAmJiBzdGVwX3htbC5zbXhtbC5zdGVwW3N0ZXBzXS5fYXR0ZW1wdCA9PSBcIjFcIikge1xuXHRcdFx0c3RhdGUuaGlkZU5leHQgPSB0cnVlO1xuXHRcdFx0c2V0VXNlckFucyh1c2Fucyk7XG5cdFx0XHRvdmVyQWxsKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChzdGVwcyAhPSBzdGVwX3htbC5zbXhtbC5zdGVwLmxlbmd0aCAtMSkge1xuXHRcdFx0c3RlcHMgKz0gMTtcblx0XHRcdGNyZWF0ZVN0ZXAoKTtcblx0XHRcdHNldFVzZXJBbnModXNhbnMpO1xuXHRcdFx0b3ZlckFsbCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkFsbCBzdGVwcyBhcmUgYXR0ZW1wdGVkXCIpO1xuXHRcdH1cblx0fSBcblxuXG5cdFxuXG5cdGZ1bmN0aW9uIHNldFVzZXJBbnModXNlcl9hbnMpIHtcblx0XHRpZih3aW5kb3cuaW5OYXRpdmUpIHtcblx0XHRcdHdpbmRvdy5nZXRIZWlnaHQgJiYgd2luZG93LmdldEhlaWdodCgpO1xuICAgICAgICB9XG5cdFx0Ly9JU1NQRUNJQUxNT0RVTEVVU0VSWE1MQ0hBTkdFID0gMTsgIyMgZml4ZWQgaW4gb25Vc2VyQW5zQ2hhbmdlO1xuXHRcdHZhciBjb25kID0gZmxhZ3htbCA/ICdsaXN0cz0nK0pTT04uc3RyaW5naWZ5KHNwZWNpYWxfbW9kdWxlLnZhcl9saXN0KSA6ICcgJztcblx0XHRcblx0XHQvL2pRdWVyeShcIiNzcGVjaWFsX21vZHVsZV91c2VyX3htbFwiKS52YWwoXCI8c21hbnM+PGRpdiBcIisgY29uZCArXCIgY3VyclN0ZXA9J1wiK3N0ZXBzK1wiJyB1c2VyQW5zPSdcIitKU09OLnN0cmluZ2lmeSh1c2VyX2FucykrXCInPjwvZGl2Pjwvc21hbnM+XCIpO1xuXHRcdC8vQUguc2VsZWN0KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIpLnZhbHVlID0gXCI8c21hbnM+PGRpdiBcIisgY29uZCArXCIgY3VyclN0ZXA9J1wiK3N0ZXBzK1wiJyB1c2VyQW5zPSdcIitKU09OLnN0cmluZ2lmeSh1c2VyX2FucykrXCInPjwvZGl2Pjwvc21hbnM+XCI7ICMjIGZpeGVkIGluIG9uVXNlckFuc0NoYW5nZTtcblxuXHRcdHJlc3VsdE5ldy5zcGVjaWFsID0gXCI8c21hbnM+PGRpdiBcIisgY29uZCArXCIgY3VyclN0ZXA9J1wiK3N0ZXBzK1wiJyB1c2VyQW5zPSdcIitKU09OLnN0cmluZ2lmeSh1c2VyX2FucykrXCInPjwvZGl2Pjwvc21hbnM+XCI7XG5cdH1cblxuXHRmdW5jdGlvbiBvdmVyQWxsKCkge1xuXHRcdGxldCBvdmVyID0gZmFsc2U7XG5cdFx0bGV0IHVzZXJBbnN3ZXJzID0gbnVsbDtcblx0XHRsZXQgaW5OYXRpdmVJc0NvcnJlY3QgPSBmYWxzZTtcblx0XHRpZihzdGVwX3htbC5zbXhtbC5zdGVwLmxlbmd0aCA9PSBzdGF0ZS5pdGVtQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRsZXQgY2hlY2sgPSB0cnVlO1xuXHRcdFx0Zm9yIChsZXQgaSBpbiBzbWFucykge1xuXHRcdFx0XHRpZiAoc21hbnNbaV0ub3ZlcmFsbCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRpZiAoc21hbnNbaV0ub3ZlcmFsbCA9PSAxKSB7XG5cdFx0XHRcdFx0XHRvdmVyID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3ZlciA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGVjayA9IGNoZWNrICYmIG92ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNoZWNrID09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly9qUXVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTtcblx0XHRcdFx0XHRBSC5zZWxlY3QoXCIjYW5zd2VyXCIpLmNoZWNrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXN1bHROZXcuYW5zd2VyID0gZmFsc2U7XG5cdFx0XHRcdFx0aW5OYXRpdmVJc0NvcnJlY3QgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvL2pRdWVyeShcIiNhbnN3ZXJcIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRBSC5zZWxlY3QoXCIjYW5zd2VyXCIpLmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmVzdWx0TmV3LmFuc3dlciA9IHRydWU7XG5cdFx0XHRcdFx0XHRpbk5hdGl2ZUlzQ29ycmVjdCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3VzZXJBbnN3ZXJzID0galF1ZXJ5KCcjc3BlY2lhbF9tb2R1bGVfdXNlcl94bWwnKS52YWwoKTtcblx0XHQvL3VzZXJBbnN3ZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNzcGVjaWFsX21vZHVsZV91c2VyX3htbFwiKS52YWx1ZTtcblx0XHR1c2VyQW5zd2VycyA9IHJlc3VsdE5ldy5zcGVjaWFsO1xuXHRcdGlmICh3aW5kb3cuaW5OYXRpdmUpIHtcblx0XHRcdHdpbmRvdy5wb3N0TWVzc2FnZSgnaGVpZ2h0X19fJytkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpbk5hdGl2ZVN0eWxlJylbMF0ub2Zmc2V0SGVpZ2h0LCcqJyk7XG5cdFx0XHR3aW5kb3cucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeyB1c2VyQW5zd2VycywgaW5OYXRpdmVJc0NvcnJlY3QgfSksICcqJyk7XG5cdFx0fVxuXHRcdG9uVXNlckFuc0NoYW5nZSh7dVhtbDpyZXN1bHROZXcuc3BlY2lhbCxhbnM6cmVzdWx0TmV3LmFuc3dlcn0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkU3RpY2t5KCkge1xuXHRcdC8valF1ZXJ5KCdbZGF0YS1zdGlja3ldJykuYWRkQ2xhc3MoJ3N0aWNreScpO1xuXHRcdEFILnNlbGVjdCgnW2RhdGEtc3RpY2t5XScsJ2FkZENsYXNzJywnc3RpY2t5Jyk7XG5cdH1cblx0XG5cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dGJveChkYXRhLCBpLCB1c2VyX3htbCwgaW5kZXgsIG9yZ19jZGF0YSkge1xuXHRcdGxldCBvcmlnaW5hbF9kYXRhID0gZGF0YTtcblx0XHRkYXRhID0gZGF0YS5yZXBsYWNlKC8le3x9JS9nLCBcIlwiKTtcblx0XHRkYXRhID0gZGF0YS5zcGxpdChcInxcIik7XG5cdFx0bGV0IGNvZGV0eXBlID0gKGRhdGFbMV0gJiYgZGF0YVsxXS50cmltKCkgPT0gXCJuXCIpID8gXCIxXCIgOiBcIlwiO1xuXHRcdGxldCBjb3JyX2FucyA9IGRhdGFbMF0udHJpbSgpO1xuXHRcdGxldCBjc1N0eWxlID0gXCJcIjtcblx0XHRpZihjb3JyX2Fucy5pbmRleE9mKFwiI3N0eWxlI1wiKSAhPSAtMSkge1xuXHRcdFx0bGV0IGN1c3RvbVN0eWxlICA9IGNvcnJfYW5zLnNwbGl0KFwiI3N0eWxlI1wiKTtcblx0XHRcdGNvcnJfYW5zID0gY3VzdG9tU3R5bGVbMF07XG5cdFx0XHRjc1N0eWxlID0gY3VzdG9tU3R5bGVbMV07XG5cdFx0fVxuXHRcdGxldCB0eHRXaWR0aCAgPSBbXTtcblx0XHRsZXQgYW5zbGVuID0gY29ycl9hbnMuc3BsaXQoXCIsXCIpO1xuXHRcdC8vIGpRdWVyeShhbnNsZW4pLmVhY2goZnVuY3Rpb24oail7XG5cdFx0Ly8gXHR0eHRXaWR0aFtqXSA9ICgoYW5zbGVuW2pdLmxlbmd0aCkqMTArMzApXG5cdFx0Ly8gfSk7XG5cdFx0YW5zbGVuLmZvckVhY2goZnVuY3Rpb24oZGF0YSxqKXtcblx0XHRcdHR4dFdpZHRoW2pdID0gKChhbnNsZW5bal0ubGVuZ3RoKSoxMCszMClcblx0XHR9KVxuXHRcdGlmKGluZGV4ICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0dGV4dEJveChkYXRhLCB0eHRXaWR0aCwgY3NTdHlsZSwgb3JpZ2luYWxfZGF0YSwgdXNlcl94bWwsIGNvcnJfYW5zLCBpLCBpbmRleCwgb3JnX2NkYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGV4dEJveChkYXRhLCB0eHRXaWR0aCwgY3NTdHlsZSwgb3JpZ2luYWxfZGF0YSwgdXNlcl94bWwsIGNvcnJfYW5zLCBpKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB0ZXh0Qm94KGRhdGEsIHR4dFdpZHRoLCBjc1N0eWxlLCBvcmlnaW5hbF9kYXRhLCB1c2VyX3htbCwgY29ycl9hbnMsIGksIGluZGV4LCBvcmdfY2RhdGEpIHtcblx0XHRpZihpbmRleCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdGVsZW1lbnRfaWQgPSBcInNcIitpbmRleCtcIl90XCIraTtcblx0XHRcdGVsZW1lbnRfZGl2ID0gXCJzXCIraW5kZXg7XG5cdFx0XHRsZXQgdGV4dGJveCA9ICc8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cIicrZWxlbWVudF9pZCsnXCIgY2xhc3M9XCJmaWxsaW50aGVibGFuayBrcyBubWIgdGV4dC1jZW50ZXIgc3BhbjAgZWRpdF9zdFwiIGRlZmF1bHRhbnM9XCJcIiBoYXNrZXl3b3Jkcz1cIlwiICBoYXNub3RrZXl3b3Jkcz1cIlwiIGtleXdvcmR0eXBlPVwiXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgZGF0YS1yb2xlPVwibm9uZVwiIHN0eWxlPVwid2lkdGg6JysoTWF0aC5tYXgoLi4udHh0V2lkdGgpICsgMjApKydweDsnK2NzU3R5bGUrJ1wiIC8+Jztcblx0XHRcdGxldCB0YWcgPSAnPHNwYW4gaWQ9XCInK2VsZW1lbnRfZGl2KydcIiBjbGFzcz1cInRleHQtY2VudGVyIGZpbHRlciBmaWxsZWxlbWVudCBpbmxpbmUtYmxvY2tcIj48c3BhbiBjbGFzcz1cInJlbWVkX2Rpc2FibGUgZmggZndpZHRoIGFic29sdXRlIGhcIj48L3NwYW4+PHNwYW4gaWQ9XCJ0ZXh0XCIgY2xhc3M9XCJjb3JyX2RpdlwiPicrZGF0YVswXSsnPC9zcGFuPicrdGV4dGJveCsnPC9zcGFuPic7XG5cdFx0XHRsZXQgY2RfYW5zID0gb3JnX2NkYXRhLnJlcGxhY2Uob3JpZ2luYWxfZGF0YSwgdGFnKTtcblx0XHRcdGFuc3dlcl9hcnJheVtpbmRleF0uX19jZGF0YSA9IGNkX2Fucztcblx0XHR9IGVsc2Uge1x0XG5cdFx0XHRpZiAodXNlcl94bWwgPD0gb2xkc3RlcCkge1xuXHRcdFx0XHR2YXIgc3RlcHNfY291bnRlciA9IHVzZXJfeG1sO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHN0ZXBzX2NvdW50ZXIgPSBzdGVwcztcblx0XHRcdH1cblx0XHRcdGVsZW1lbnRfaWQgPSBcInNcIitzdGVwc19jb3VudGVyK1wiX3RcIitpO1xuXHRcdFx0ZWxlbWVudF9kaXYgPSBcInNcIitzdGVwc19jb3VudGVyO1xuXHRcdFx0bGV0IHRleHRib3ggPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCInK2VsZW1lbnRfaWQrJ1wiIGNsYXNzPVwiZmlsbGludGhlYmxhbmsga3Mgbm1iIHRleHQtY2VudGVyIHNwYW4wIGVkaXRfc3RlcFwiIGRlZmF1bHRhbnM9XCJcIiBoYXNrZXl3b3Jkcz1cIlwiICBoYXNub3RrZXl3b3Jkcz1cIlwiIGtleXdvcmR0eXBlPVwiXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgZGF0YS1yb2xlPVwibm9uZVwiICBzdHlsZT1cIndpZHRoOicrKE1hdGgubWF4KC4uLnR4dFdpZHRoKSArIDIwKSsncHg7Jytjc1N0eWxlKydcIiAvPic7XG5cdFx0XHRsZXQgdGFnID0gJzxzcGFuIGlkPVwiJytlbGVtZW50X2RpdisnXCIgY2xhc3M9XCJ0ZXh0LWNlbnRlciBmaWx0ZXIgZmlsbGVsZW1lbnQgaW5saW5lLWJsb2NrXCI+PHNwYW4gY2xhc3M9XCJyZW1lZF9kaXNhYmxlIGZoIGZ3aWR0aCBhYnNvbHV0ZSBoXCI+PC9zcGFuPjxzcGFuIGlkPVwiXCIgY2xhc3M9XCJjb3JyX2RpdiBoLWltcFwiPicrZGF0YVswXSsnPC9zcGFuPicrdGV4dGJveCsnPC9zcGFuPic7XG5cdFx0XHRjZGF0YSA9IGNkYXRhLnJlcGxhY2Uob3JpZ2luYWxfZGF0YSwgdGFnKTtcblx0XHRcdHNtYW5zID0gY3JlYXRlQW5zKHNtYW5zLCBlbGVtZW50X2lkLCBlbGVtZW50X2RpdiwgY29ycl9hbnMpXG5cdFx0XHRzcGVjaWFsX21vZHVsZS5zbWFucyA9IHNtYW5zO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUFucyhvYmosIGVsZW1lbnRfaWQsIGVsZW1lbnRfZGl2LCBjb3JyZWN0dmFsKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmpbZWxlbWVudF9kaXZdID09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG9ialtlbGVtZW50X2Rpdl1bZWxlbWVudF9pZF0gPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0aWYgKHR5cGVvZiBvYmpbZWxlbWVudF9kaXZdID09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0b2JqW2VsZW1lbnRfZGl2XSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0b2JqW2VsZW1lbnRfZGl2XVtlbGVtZW50X2lkXSA9IHt9O1xuXHRcdH1cblx0XHRvYmpbZWxlbWVudF9kaXZdW2VsZW1lbnRfaWRdLnZhbHVlID0gY29ycmVjdHZhbDtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0LypmdW5jdGlvbiBub3RGaWxsZWQoKSB7XG5cdFx0alF1ZXJ5KCcuZWRpdF9zdGVwJykuZWFjaChmdW5jdGlvbihpLCBvYmopIHtcblx0XHRcdGxldCBlbGVtZW50ID0galF1ZXJ5KHRoaXMpO1xuXHRcdFx0aWYgKCFqUXVlcnkodGhpcykuaGFzQ2xhc3MoJ2Fuc3dlcl9pbnB1dCcpKSB7XG5cdFx0XHRcdGVsZW1lbnQuY3NzKHtib3JkZXI6ICcycHggc29saWQgI2ZmMDAwMCd9KTtcblx0XHRcdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRlbGVtZW50LmNzcyh7Ym9yZGVyOiAnMXB4IHNvbGlkICNjY2MnfSk7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0fSwgNTAwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjsgXG5cdFx0fSk7XG5cdH0qL1xuXG5cdGZ1bmN0aW9uIG5vdEZpbGxlZCgpIHtcblx0XHRBSC5zZWxlY3RBbGwoJy5lZGl0X3N0ZXAnKS5mb3JFYWNoKChfZWxlbWVudCk9PiB7XG5cdFx0XHRcblx0XHRcdGlmICghX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhbnN3ZXJfaW5wdXQnKSkge1xuXHRcdFx0XHRfZWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICNmZjAwMDAnO1xuXHRcdFx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF9lbGVtZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgI2NjYydcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0XHR9LCA1MDApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuOyBcblx0XHR9KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gY2hlY2tBbnMoaikge1xuXHRcdFxuXHRcdHdyb25nX2Nob2ljZSA9IDA7XG5cdFx0b3B0aW9ucmVtICs9IDE7XG5cdFx0Zm9yIChsZXQgaSBpbiBzbWFucykge1xuXHRcdFx0Zm9yIChsZXQgcHJvcCBpbiBzbWFuc1tpXSkge1xuXHRcdFx0XHRpZiAoaiA8IG9sZHN0ZXApIHtcblx0XHRcdFx0XHR2YXIgY3VyciA9IGo7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGN1cnIgPSBzdGVwcztcblx0XHRcdFx0fVxuXHRcdFx0XHQvL3RyeSB7XG5cdFx0XHRcdFx0aWYgKHVzYW5zW1wic1wiK2N1cnJdICYmIHVzYW5zW1wic1wiK2N1cnJdW3Byb3BdICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0aWYgKHNtYW5zW1wic1wiK2N1cnJdW3Byb3BdLnZhbHVlID09IHVzYW5zW1wic1wiK2N1cnJdW3Byb3BdLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdGlucHV0SG92ZXIoJ2NvcnJlY3QnLCBwcm9wKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoL1xcLC9nLnRlc3Qoc21hbnNbXCJzXCIrY3Vycl1bcHJvcF0udmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBzX2FucyA9IChzbWFuc1tcInNcIitjdXJyXVtwcm9wXS52YWx1ZSkuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdFx0XHRsZXQgdV9hbnMgPSB1c2Fuc1tcInNcIitjdXJyXVtwcm9wXS52YWx1ZTtcblx0XHRcdFx0XHRcdFx0aWYoc19hbnMuaW5kZXhPZih1X2FucykgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGlucHV0SG92ZXIoJ2NvcnJlY3QnLCBwcm9wKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR3cm9uZ19jaG9pY2UgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdGlucHV0SG92ZXIoJ3dyb25nJywgcHJvcCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHdyb25nX2Nob2ljZSA9IDE7XG5cdFx0XHRcdFx0XHRcdGlucHV0SG92ZXIoJ3dyb25nJywgcHJvcCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQvL30gY2F0Y2goZSkge1xuXHRcdFx0XHQvL1x0Y29uc29sZS53YXJuKGUpO1xuXHRcdFx0XHQvL31cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN0ZXBfeG1sLnNteG1sLnN0ZXBbc3RlcHNdLl9tb2RlID09IDEpIHsgXG5cdFx0XHRzaG93QW5zTW9kKGosIFwic1wiK2opO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaG93QW5zKGosIFwic1wiK2opO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlucHV0SG92ZXIob3B0aW9uLCBlbGVtKSB7XG5cdFx0aWYgKHN0ZXBfeG1sLnNteG1sLnN0ZXBbc3RlcHNdLl9tb2RlICE9IDEpIHsgXG5cdFx0XHRpZiAob3B0aW9uID09ICdjb3JyZWN0Jykge1xuXHRcdFx0XHQvL2pRdWVyeSgnIycrZWxlbSkucmVtb3ZlQ2xhc3MoJ2ZhbHNlLWhvdmVyJyk7XG5cdFx0XHRcdEFILnNlbGVjdCgnIycrZWxlbSwncmVtb3ZlQ2xhc3MnLCdmYWxzZS1ob3ZlcicpO1xuXHRcdFx0XHQvL2pRdWVyeSgnIycrZWxlbSkuYWRkQ2xhc3MoJ3RydWUtaG92ZXInKTtcblx0XHRcdFx0QUguc2VsZWN0KCcjJytlbGVtLCdhZGRDbGFzcycsJ3RydWUtaG92ZXInKTtcblx0XHRcdH0gZWxzZSBpZiAob3B0aW9uID09ICd3cm9uZycpIHtcblx0XHRcdFx0Ly9qUXVlcnkoJyMnK2VsZW0pLnJlbW92ZUNsYXNzKCd0cnVlLWhvdmVyJyk7XG5cdFx0XHRcdEFILnNlbGVjdCgnIycrZWxlbSwncmVtb3ZlQ2xhc3MnLCd0cnVlLWhvdmVyJyk7XG5cdFx0XHRcdC8valF1ZXJ5KCcjJytlbGVtKS5hZGRDbGFzcygnZmFsc2UtaG92ZXInKTtcblx0XHRcdFx0QUguc2VsZWN0KCcjJytlbGVtLCdhZGRDbGFzcycsJ2ZhbHNlLWhvdmVyJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucmVtPjEpIHtcblx0XHRcdFx0Ly9qUXVlcnkoJyMnK2VsZW0pLnByZXYoKS5yZW1vdmVDbGFzcygnaC1pbXAnKTtcblx0XHRcdFx0QUguc2VsZWN0KEFJLnNlbGVjdCgnIycrZWxlbSkucHJldmlvdXNFbGVtZW50U2libGluZywncmVtb3ZlQ2xhc3MnLCdoLWltcCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYoc3RlcF94bWwuc214bWwuX2ZpeGVkICE9IDEpIHtcblx0XHRcdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvL2pRdWVyeSgnIycrZWxlbSkucHJldigpLmFkZENsYXNzKCdoLWltcCcpO1xuXHRcdFx0XHRcdEFILnNlbGVjdChBSS5zZWxlY3QoJyMnK2VsZW0pLnByZXZpb3VzRWxlbWVudFNpYmxpbmcsJ2FkZENsYXNzJywnaC1pbXAnKTtcblx0XHRcdFx0IFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0fSwyMDAwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHV4bWwpIHtcblx0XHRcdC8valF1ZXJ5KCcuZWRpdF9zdGVwJykuZWFjaChmdW5jdGlvbihpLCBvYmopIHtcblx0XHRcdEFILnNlbGVjdEFsbCgnLmVkaXRfc3RlcCcpLmZvckVhY2goZnVuY3Rpb24ob2JqLCBpKSB7XHRcdFxuXHRcdFx0XHQvL2lmIChqUXVlcnkodGhpcykuaGFzQ2xhc3MoJ21hdGhxdWlsbCcpKSB7XG5cdFx0XHRcdFx0aWYgKG9iai5jbGFzc0xpc3QuY29udGFpbnMoJ21hdGhxdWlsbCcpKSB7XHRcdFxuXHRcdFx0XHRcdC8valF1ZXJ5KCcjJytlbGVtKS5wcmV2QWxsKCcuZGlzYWJsZV9kaXYnKS5yZW1vdmVDbGFzcygnaCcpO1x0XG5cdFx0XHRcdFx0aWYoKEFILnNlbGVjdCgnIycrZWxlbSkucHJldmlvdXNFbGVtZW50U2libGluZykuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZV9kaXZcIikpIHtcblx0XHRcdFx0XHRcdEFILnNlbGVjdChBSC5zZWxlY3QoJyMnK2VsZW0pLnByZXZpb3VzRWxlbWVudFNpYmxpbmcsJ3JlbW92ZUNsYXNzJywnaCcpO1xuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vfSBlbHNlIGlmKGpRdWVyeSh0aGlzKS5oYXNDbGFzcygnYW5zd2VyX2lucHV0JykpIHtcblx0XHRcdFx0fVx0ZWxzZSBpZihvYmouY2xhc3NMaXN0LmNvbnRhaW5zKCdhbnN3ZXJfaW5wdXQnKSkge1x0XHRcblx0XHRcdFx0XHQvL2pRdWVyeSh0aGlzKS5wcm9wKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdG9iai5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRcdH1cdFx0XG5cdFx0XHRcdC8valF1ZXJ5KHRoaXMpLmFkZENsYXNzKCdkYXRhLWNoZWNrJyk7XG5cdFx0XHRcdG9iai5jbGFzc0xpc3QuYWRkKCdkYXRhLWNoZWNrJyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzaG93QW5zKGosIG91dGVyKSB7XG5cdFx0dmFyIG92ZXJhbGwgPSAwO1xuXHRcdGlmICh3cm9uZ19jaG9pY2U+MCkge1xuXHRcdFx0c3RhdGUuY2xhc3NDaGFuZ2UgPSBzdGF0ZS5pdGVtQXJyYXkubGVuZ3RoLTE7IFxuXHRcdFx0c3RhdGUuaXNDb2xvciA9IGZhbHNlO1xuXHRcdFx0b3ZlcmFsbCA9IDA7XG5cdFx0XHRpZiAoajw9b2xkc3RlcCkge1xuXHRcdFx0XHRzbWFuc1tvdXRlcl0ub3ZlcmFsbCA9IG92ZXJhbGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzbWFuc1tlbGVtZW50X2Rpdl0ub3ZlcmFsbCA9IG92ZXJhbGw7XG5cdFx0XHRcdG92ZXJBbGwoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhdGUuY2xhc3NDaGFuZ2UgPSBzdGF0ZS5pdGVtQXJyYXkubGVuZ3RoLTE7IFxuXHRcdFx0c3RhdGUuaXNDb2xvciA9IHRydWU7XG5cdFx0XHRvdmVyYWxsID0gMTtcblx0XHRcdGlmIChqPD1vbGRzdGVwKSB7XG5cdFx0XHRcdHNtYW5zW291dGVyXS5vdmVyYWxsID0gb3ZlcmFsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNtYW5zW2VsZW1lbnRfZGl2XS5vdmVyYWxsID0gb3ZlcmFsbDtcblx0XHRcdFx0bmV4dFN0ZXAoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9wdGlvbnJlbT4xKSB7XG5cdFx0XHRuZXh0U3RlcCgpO1xuXHRcdH1cblx0XHRpZiAodXNhbnNbZWxlbWVudF9kaXZdICYmICB1c2Fuc1tlbGVtZW50X2lkXSAhPSB1bmRlZmluZWQpIHtcblx0XHRcdHVzYW5zW2VsZW1lbnRfZGl2XS5vcHRyeSA9IG9wdGlvbnJlbTtcblx0XHR9XG5cdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdHN0YXRlLmNsYXNzQ2hhbmdlID0gLTE7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdH0sIDI1MDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2hvd0Fuc01vZChqLCBvdXRlcikge1xuXHRcdHZhciBvdmVyYWxsID0gMDtcblx0XHRpZiAod3JvbmdfY2hvaWNlPjApIHtcblx0XHRcdG92ZXJhbGwgPSAwO1xuXHRcdFx0aWYgKGo8PW9sZHN0ZXApIHtcblx0XHRcdFx0c21hbnNbb3V0ZXJdLm92ZXJhbGwgPSBvdmVyYWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c21hbnNbZWxlbWVudF9kaXZdLm92ZXJhbGwgPSBvdmVyYWxsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdmVyYWxsID0gMTtcblx0XHRcdGlmIChqPD1vbGRzdGVwKSB7XG5cdFx0XHRcdHNtYW5zW291dGVyXS5vdmVyYWxsID0gb3ZlcmFsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNtYW5zW2VsZW1lbnRfZGl2XS5vdmVyYWxsID0gb3ZlcmFsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0bmV4dFN0ZXAoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvZ2dsZShidG4pIHtcblx0XHRpZiAoYnRuID09IDEpIHtcblx0XHRcdGJ0bnR5cGUgPSBcImNvcnJlY3RhbnNcIjtcblx0XHR9IGVsc2UgaWYgKGJ0biA9PSAyKSB7XG5cdFx0XHRidG50eXBlID0gXCJ5b3VyYW5zXCI7XG5cdFx0fVxuXHRcdC8vZm9yY2VVcGRhdGUoKTsgXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRSZXZpZXcoKSB7XG5cdFx0XG5cdFx0aXNSZXZpZXcgPSB0cnVlO1xuXHRcdG92ZXJBbGwoKTtcdFxuXHRcdHlvdXJBbnN3ZXIoKTtcblx0XHQvL2pRdWVyeSgnLmZpbGxpbnRoZWJsYW5rJykucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5maWxsaW50aGVibGFuaycpLmRpc2FibGVkID0gdHJ1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVuc2V0UmV2aWV3KCkge1xuXHRcdFxuXHRcdGlzUmV2aWV3ID0gZmFsc2U7XG5cdFx0c3RhdGUuZGlzcGxheSA9IC0xO1xuXHRcdHN0YXRlLnNtQ29udHJvbGxlciA9ICcgaCc7XG5cdFx0XG5cdFx0Ly9qUXVlcnkoJy5maWxsaW50aGVibGFuaycpLnJlbW92ZUNsYXNzKCdkZWZhdWx0LWhvdmVyJyk7XG5cdFx0QUguc2VsZWN0QWxsKCcuZmlsbGludGhlYmxhbmsnLCdyZW1vdmVDbGFzcycsJ2RlZmF1bHQtaG92ZXInKTtcblx0XHQvL2pRdWVyeSgnLmZpbGxpbnRoZWJsYW5rJykucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKTtcblx0XHRBSC5zZWxlY3RBbGwoJy5maWxsaW50aGVibGFuaycpLmRpc2FibGVkID0gZmFsc2U7XG5cdFx0c3RhdGUubWFpbl9zdGVwcyA9IGZhbHNlO1xuXHRcdHN0YXRlLmNvcnJlY3RfYW5zd2VyID0gdHJ1ZTtcblx0XHRcblx0XHQvL2pRdWVyeSgnLnJlbWVkX2Rpc2FibGUnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXHRcdEFILnNlbGVjdEFsbCgnLnJlbWVkX2Rpc2FibGUnLCdjc3MnLHtkaXNwbGF5Oidub25lJ30pO1xuXHRcdGlmKChzdGVwX3htbC5zbXhtbC5zdGVwW3N0ZXBzKzFdID09IHVuZGVmaW5lZCAmJiBzdGVwX3htbC5zbXhtbC5zdGVwW3N0ZXBzXS5fYXR0ZW1wdCA9PSBcIjFcIikgfHwgKHN0ZXBfeG1sLnNteG1sLnN0ZXBbc3RlcHMrMV0gPT0gdW5kZWZpbmVkICYmIHN0ZXBfeG1sLnNteG1sLnN0ZXBbc3RlcHNdLl92aWV3b25seSA9PSBcIjFcIikpIHtcblx0XHRcdGlmIChBSC5zZWxlY3RBbGwoJy5lZGl0X3N0ZXAnKS5sZW5ndGggPT0gQUguc2VsZWN0QWxsKCcuZGF0YS1jaGVjaycpLmxlbmd0aCkge1xuXHRcdFx0XHRzdGF0ZS5oaWRlTmV4dCA9ICB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhdGUuaGlkZU5leHQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1x0XHRcdFxuXHRcdFx0c3RhdGUuaGlkZU5leHQgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYod2luZG93LmluTmF0aXZlKSB7XG4gICAgICAgICAgICB3aW5kb3cuZ2V0SGVpZ2h0ICYmIHdpbmRvdy5nZXRIZWlnaHQoKTtcbiAgICAgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY29ycmVjdEFuc3dlcigpIHtcblx0XHQvL2hhbmRsZVRvZ2dsZSgxKTtcblx0XHRzdGF0ZS5kaXNwbGF5ID0gLTE7XG5cdFx0Ly9qUXVlcnkoJy5maWxsaW50aGVibGFuaycpLmFkZENsYXNzKCdkZWZhdWx0LWhvdmVyJyk7XG5cdFx0QUguc2VsZWN0QWxsKCcuZmlsbGludGhlYmxhbmsnLCdhZGRDbGFzcycsJ2RlZmF1bHQtaG92ZXInKTtcblx0XHRzaG93Q29ycmVjdCgpO1xuXHRcdHN0YXRlLm1haW5fc3RlcHMgPSB0cnVlO1xuXHRcdHN0YXRlLmNvcnJlY3RfYW5zd2VyID0gZmFsc2U7XG5cdFxuXHRcdGlmKHdpbmRvdy5pbk5hdGl2ZSkge1xuXHRcdFx0d2luZG93LmdldEhlaWdodCAmJiB3aW5kb3cuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNob3dDb3JyZWN0KCkge1xuXHRcdGxldCBzaG93X2FucyA9IHN0ZXBfeG1sLnNteG1sLnN0ZXA7XG5cdFx0c2hvd19hbnMubWFwKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG5cdFx0XHRsZXQgY2RhdGFfYW5zID0gaXRlbS5fX2NkYXRhO1x0XG5cdFx0XHRsZXQgb3JnX2NkYXRhID0gY2RhdGFfYW5zO1x0XHRcblx0XHRcdGNyZWF0aW5nSW50ZXJhY3RpdmUoJ2NvcnJfYW5zJywgb3JnX2NkYXRhLCBpbmRleCk7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiB5b3VyQW5zd2VyKCkge1xuXHRcdC8vaGFuZGxlVG9nZ2xlKDIpO1xuXHRcdFxuXHRcdHN0YXRlLmRpc3BsYXkgPSAxO1xuXHRcdHN0YXRlLmhpZGVOZXh0ID0gdHJ1ZTtcblx0XHRzdGF0ZS5zbUNvbnRyb2xsZXIgPSAnJztcblx0XHRcblx0XHQvLyQoJy5maWxsaW50aGVibGFuaycpLnJlbW92ZUNsYXNzKCdkZWZhdWx0LWhvdmVyJyk7XG5cdFx0QUguc2VsZWN0QWxsKFwiLmZpbGxpbnRoZWJsYW5rXCIsXCJyZW1vdmVDbGFzc1wiLFwiZGVmYXVsdC1ob3ZlclwiKTtcblx0XHRzdGF0ZS5tYWluX3N0ZXBzID0gZmFsc2U7XG5cdFx0c3RhdGUuY29ycmVjdF9hbnN3ZXIgPSB0cnVlO1xuXHRcdFxuXHRcdC8valF1ZXJ5KCcucmVtZWRfZGlzYWJsZScpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXHRcdEFILnNlbGVjdEFsbCgnLnJlbWVkX2Rpc2FibGUnLCdjc3MnLHtkaXNwbGF5OidibG9jayd9KTtcblx0XHRpZih3aW5kb3cuaW5OYXRpdmUpIHtcblx0XHRcdHdpbmRvdy5nZXRIZWlnaHQgJiYgd2luZG93LmdldEhlaWdodCgpO1xuICAgICAgICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZVN0ZXBzKHN0ZXBzKSB7XG5cdFx0bGV0IHVzZXJfc3RlcCA9IFhNTFRvSlNPTihzdGVwcyk7XG5cdFx0aWYoZmxhZ3htbCkge1xuXHRcdFx0bGlzdHMgPSBKU09OLnBhcnNlKHVzZXJfc3RlcC5zbWFucy5kaXYuX2xpc3RzKTtcblx0XHR9XG5cdFx0b2xkc3RlcCA9IEpTT04ucGFyc2UodXNlcl9zdGVwLnNtYW5zLmRpdi5fY3VyclN0ZXApO1xuXHR9XG5cblx0ZnVuY3Rpb24gbmV4dGJ0bkFuc3dlcigpIHtcblx0XHRcblx0XHRsZXQgY3VycmVudCA9IGBzJHtzdGVwc31gO1xuXHRcdC8vbGV0IHRleHRib3hlcyA9IGpRdWVyeSgnIycrY3VycmVudCkuZmluZCgnLmVkaXRfc3RlcCcpO1xuXHRcdGxldCB0ZXh0Ym94ZXMgPSBBSC5maW5kKCcjJytjdXJyZW50LCcuZWRpdF9zdGVwJywnYWxsJyk7XG5cdFx0dGV4dGJveGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCkge1xuXHRcdFx0aWYgKGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdtYXRocXVpbGwnKSkge1xuXHRcdFx0XHRtYXRocXVpbGxBbnMoaXRlbSwgZmFsc2UpO1x0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvL2xldCBpbnBfaWQgPSBqUXVlcnkoaXRlbSkuYXR0cignaWQnKTtcblx0XHRcdFx0bGV0IGlucF9pZCA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRcdFx0XHQvL2xldCBpbnBfdmFsID0galF1ZXJ5KGl0ZW0pLnZhbCgpO1xuXHRcdFx0XHRsZXQgaW5wX3ZhbCA9IGl0ZW0udmFsdWU7XG5cdFx0XHRcdHVzYW5zID0gY3JlYXRlQW5zKHVzYW5zLCBpbnBfaWQsIGN1cnJlbnQsIGlucF92YWwpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmIChzdGVwX3htbC5zbXhtbC5zdGVwW3N0ZXBzXS5fYXR0ZW1wdCA9PSAxKSB7XG5cdFx0XHRjaGVja0FucygpO1xuXHRcdH0gZWxzZSB7IFxuXHRcdFx0bmV4dFN0ZXAoKTtcblx0XHRcdGFkZFN0aWNreSgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFILmNyZWF0ZUxpbmsoJy4uL2Nsc1NNRmlsbC9jc3MvZmlsbGludGhlYmxhbmsuY3NzJyk7XG5cblxuXHRcdC8vVG8gaGFuZGxlIHJldmlldyB0b2dnbGVcblx0ZnVuY3Rpb24gaGFuZGxlUmV2aWV3KG1vZGUsIGV2ZW50KSB7XG5cdFx0XG5cdFx0aWYgKG1vZGUgPT0gJ2MnKSB7XG5cdFx0XHRjb3JyZWN0QW5zd2VyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHlvdXJBbnN3ZXIoKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGNyZWF0ZU1hdGhEaXYoZGF0YSwgaSwgdXNlcl94bWwsIGluZGV4LCBvcmdfY2RhdGEpIHtcblx0XHRsZXQgb3JpZ2luYWxfZGF0YSA9IGRhdGE7XG5cdFx0ZGF0YSA9IGRhdGEucmVwbGFjZSgvJXt8fSUvZyxcIlwiKTtcblx0XHRkYXRhID0gZGF0YS5zcGxpdChcInxcIik7XG5cdFx0ZGF0YVswXSA9IGRhdGFbMF0ucmVwbGFjZSgvdXNlciBSZXNwb25zZS9nLCAnXFxcXE1hdGhRdWlsbE1hdGhGaWVsZCcpO1xuXHRcdC8vIGxldCBzcGxpdF9kYXRhID0gYWRkTWF0aHF1aWxsLnNwbGl0KFwiIyNcIik7XG5cdFx0bGV0IHNwbGl0X2RhdGEgPSBkYXRhWzBdLnNwbGl0KFwiIyNcIik7XG5cdFx0bGV0IHJhbmRvbV9rZXkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzcGxpdF9kYXRhLmxlbmd0aClcblx0XHRsZXQgcmFuZG9tX29wdGlvbiA9IHNwbGl0X2RhdGFbcmFuZG9tX2tleV07XG5cdFx0bGV0IHVzZXJhbnMgPSByYW5kb21fb3B0aW9uLnJlcGxhY2UoL01hdGhRdWlsbE1hdGhGaWVsZHsoLio/KX0vZywnTWF0aFF1aWxsTWF0aEZpZWxke30nKTtcblx0XHRsZXQgZGVmYXVsdGFucyA9IDA7XG5cdFx0bGV0IGFuc2tleSA9IHJhbmRvbV9vcHRpb247XG5cdFx0bGV0IGFuc3dlcl9lbGVtZW50ID0gYW5za2V5LnJlcGxhY2UoL1xcXFxNYXRoUXVpbGxNYXRoRmllbGQvZywnJyk7XG5cdFx0aWYgKHJhbmRvbV9vcHRpb24uaW5kZXhPZihcIlxcTWF0aFF1aWxsTWF0aEZpZWxkXCIpID4gLTEpIHtcblx0XHRcdGFuc2tleSA9IHJhbmRvbV9vcHRpb247XG5cdFx0XHRkZWZhdWx0YW5zID0gMTtcblx0XHR9XHRcblx0XHRpZihpbmRleCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdG1hdGhRdWlsbCh1c2VyYW5zLCBkYXRhLCBvcmlnaW5hbF9kYXRhLCB1c2VyX3htbCwgaSwgcmFuZG9tX2tleSwgZGVmYXVsdGFucywgYW5za2V5LCBhbnN3ZXJfZWxlbWVudCwgaW5kZXgsIG9yZ19jZGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGhRdWlsbCh1c2VyYW5zLCBkYXRhLCBvcmlnaW5hbF9kYXRhLCB1c2VyX3htbCwgaSwgcmFuZG9tX2tleSwgZGVmYXVsdGFucywgYW5za2V5LCBhbnN3ZXJfZWxlbWVudCk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBtYXRoUXVpbGwodXNlcmFucywgZGF0YSwgb3JpZ2luYWxfZGF0YSwgdXNlcl94bWwsIGksIHJhbmRvbV9rZXksIGRlZmF1bHRhbnMsIGFuc2tleSwgYW5zd2VyX2VsZW1lbnQsIGluZGV4LCBvcmdfY2RhdGEpIHtcblx0XHRsZXQgY29ycl9hbnMgPSBkYXRhWzBdLnRyaW0oKTtcblx0XHRpZiAodXNlcl94bWwgPD0gb2xkc3RlcCkge1xuXHRcdFx0dmFyIHN0ZXBzX2NvdW50ZXIgPSB1c2VyX3htbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHN0ZXBzX2NvdW50ZXIgPSBzdGVwcztcblx0XHR9XG5cdFx0aWYoaW5kZXggIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRlbGVtZW50X2lkID0gXCJzMFwiK2luZGV4K1wiX3RcIitpO1xuXHRcdFx0ZWxlbWVudF9kaXYgPSBcInMwXCIraW5kZXg7XG5cdFx0XHRsZXQgYW5zX2lkID0gXCJtMFwiK2luZGV4K1wiX3RcIitpO1xuXHRcdFx0bGV0IG1hdGhlcSA9ICc8c3BhbiAgaWQ9XCInK2VsZW1lbnRfaWQrJ1wiIGNsYXNzPVwiYXV0b19oZWlnaHQgZWRpdF9zdCBmaWxsbWF0aGVsZW1lbnQgbWF0aHF1aWxsIG1xJytzdGVwc19jb3VudGVyKydcIiB1c2VyQW5zU2VxPVwiJytyYW5kb21fa2V5KydcIiB1c2VyYW5zPVwiJyt1c2VyYW5zKydcIiBhbnNrZXk9XCInK2Fuc2tleSsnXCIgZGVmYXVsdGFucz1cIicrZGVmYXVsdGFucysnXCIgbWF0aHR5cGU9XCIxXCI+JysncycrJzwvc3Bhbj4nO1xuXHRcdFx0bGV0IHRhZyA9ICc8c3BhbiBpZD1cIicrZWxlbWVudF9kaXYrJ1wiIGNsYXNzPVwidGV4dC1jZW50ZXIgZmlsdGVyIGZpbGxlbGVtZW50IGlubGluZS1ibG9ja1wiPjxzcGFuIGNsYXNzPVwiZGlzYWJsZV9kaXYgZmggZndpZHRoIGFic29sdXRlIGhcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJyZW1lZF9kaXNhYmxlIGZoIGZ3aWR0aCBhYnNvbHV0ZSBoXCI+PC9zcGFuPjxzcGFuICBpZD1cIicrYW5zX2lkKydcIiBjbGFzcz1cImNvcnJfZGl2IGZpbGxtYXRoZWxlbWVudCBtYXRocXVpbGwgbXEnK3N0ZXBzX2NvdW50ZXIrJ1wiIHVzZXJBbnNTZXE9XCInK3JhbmRvbV9rZXkrJ1wiIGFuc2tleT1cIicrYW5za2V5KydcIiBkZWZhdWx0YW5zPVwiJytkZWZhdWx0YW5zKydcIiBtYXRodHlwZT1cIjFcIj4nK2Fuc3dlcl9lbGVtZW50Kyc8L3NwYW4+JyttYXRoZXErJzwvc3Bhbj4nO1xuXHRcdFx0bGV0IGNkX2FucyA9IG9yZ19jZGF0YS5yZXBsYWNlKG9yaWdpbmFsX2RhdGEsIHRhZyk7XG5cdFx0XHRhbnN3ZXJfYXJyYXlbaW5kZXhdLl9fY2RhdGEgPSBjZF9hbnM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnRfaWQgPSBcInNcIitzdGVwc19jb3VudGVyK1wiX3RcIitpO1xuXHRcdFx0ZWxlbWVudF9kaXYgPSBcInNcIitzdGVwc19jb3VudGVyO1xuXHRcdFx0bGV0IGFuc19pZCA9IFwibVwiK3N0ZXBzX2NvdW50ZXIrXCJfdFwiK2k7XG5cdFx0XHRsZXQgbWF0aGVxID0gJzxzcGFuICBpZD1cIicrZWxlbWVudF9pZCsnXCIgY2xhc3M9XCJhdXRvX2hlaWdodCBlZGl0X3N0ZXAgZmlsbG1hdGhlbGVtZW50IG1hdGhxdWlsbCBtcScrc3RlcHNfY291bnRlcisnXCIgdXNlckFuc1NlcT1cIicrcmFuZG9tX2tleSsnXCIgdXNlcmFucz1cIicrdXNlcmFucysnXCIgYW5za2V5PVwiJythbnNrZXkrJ1wiIGRlZmF1bHRhbnM9XCInK2RlZmF1bHRhbnMrJ1wiIG1hdGh0eXBlPVwiMVwiPicrJ3MnKyc8L3NwYW4+Jztcblx0XHRcdGxldCB0YWcgPSAnPHNwYW4gaWQ9XCInK2VsZW1lbnRfZGl2KydcIiBjbGFzcz1cInRleHQtY2VudGVyIGZpbHRlciBmaWxsZWxlbWVudCBpbmxpbmUtYmxvY2tcIj48c3BhbiBjbGFzcz1cImRpc2FibGVfZGl2IGZoIGZ3aWR0aCBhYnNvbHV0ZSBoXCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwicmVtZWRfZGlzYWJsZSBmaCBmd2lkdGggYWJzb2x1dGUgaFwiPjwvc3Bhbj48c3BhbiAgaWQ9XCInK2Fuc19pZCsnXCIgY2xhc3M9XCJjb3JyX2RpdiBoLWltcCBmaWxsbWF0aGVsZW1lbnQgbWF0aHF1aWxsIG1xJytzdGVwc19jb3VudGVyKydcIiB1c2VyQW5zU2VxPVwiJytyYW5kb21fa2V5KydcIiBhbnNrZXk9XCInK2Fuc2tleSsnXCIgZGVmYXVsdGFucz1cIicrZGVmYXVsdGFucysnXCIgbWF0aHR5cGU9XCIxXCI+JythbnN3ZXJfZWxlbWVudCsnPC9zcGFuPicrbWF0aGVxKyc8L3NwYW4+Jztcblx0XHRcdGNkYXRhID0gY2RhdGEucmVwbGFjZShvcmlnaW5hbF9kYXRhLCB0YWcpO1xuXHRcdFx0c21hbnMgPSBjcmVhdGVBbnMoc21hbnMsIGVsZW1lbnRfaWQsIGVsZW1lbnRfZGl2LCBjb3JyX2Fucyk7XG5cdFx0XHRzcGVjaWFsX21vZHVsZS5zbWFucyA9IHNtYW5zO1xuXHRcdH1cblxuXHRcdGxldCB0aW1lX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IFxuXHRcdFx0aWYgKHR5cGVvZiBNYXRoUXVpbGwgPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGNsZWFySW50ZXJ2YWwodGltZV9pbnRlcnZhbCk7XG5cdFx0XHRcdGxldCBNUSA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMik7XG5cdFx0XHRcdC8valF1ZXJ5KFwiLm1hdGhxdWlsbC5tcVwiK3N0ZXBzX2NvdW50ZXIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdEFILnNlbGVjdEFsbChcIi5tYXRocXVpbGwubXFcIitzdGVwc19jb3VudGVyKS5mb3JFYWNoKChfdGhpcyk9PiB7XG5cdFx0XHRcdFx0Ly9sZXQgbWF0aF9pdGVtaWQgID0galF1ZXJ5KHRoaXMpLmF0dHIoJ2lkJyk7XG5cdFx0XHRcdFx0bGV0IG1hdGhfaXRlbWlkICA9IF90aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRcdFx0XHQvL2xldCBkZWZhdWx0YW5zID0galF1ZXJ5KHRoaXMpLmF0dHIoJ2RlZmF1bHRhbnMnKTtcblx0XHRcdFx0XHRsZXQgZGVmYXVsdGFucyA9IF90aGlzLmdldEF0dHJpYnV0ZSgnZGVmYXVsdGFucycpO1xuXHRcdFx0XHRcdGlmIChkZWZhdWx0YW5zID09IDEpIHtcblx0XHRcdFx0XHRcdC8vbGV0IGxhdGV4ID0galF1ZXJ5KHRoaXMpLmF0dHIoJ3VzZXJhbnMnKTtcblx0XHRcdFx0XHRcdGxldCBsYXRleCA9IF90aGlzLmdldEF0dHJpYnV0ZSgndXNlcmFucycpO1xuXHRcdFx0XHRcdFx0Ly9qUXVlcnkoJyMnK21hdGhfaXRlbWlkKS50ZXh0KGxhdGV4KTtcblx0XHRcdFx0XHRcdEFILnNlbGVjdCgnIycrbWF0aF9pdGVtaWQpLmlubmVyVGV4dCA9IGxhdGV4XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8valF1ZXJ5KCcjJyttYXRoX2l0ZW1pZCkudGV4dChqUXVlcnkodGhpcykuYXR0cigndXNlcmFucycpKTtcblx0XHRcdFx0XHRcdEFILnNlbGVjdCgnIycrbWF0aF9pdGVtaWQpLmlubmVyVGV4dCA9IF90aGlzLmdldEF0dHJpYnV0ZShcInVzZXJhbnNcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRmaWxsX21hdGhbbWF0aF9pdGVtaWRdICA9IE1RLlN0YXRpY01hdGgoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0aF9pdGVtaWQpKTtcblx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fS5iaW5kKHRoaXMpLDEwMCk7XHRcblx0fVxuXG5cdGZ1bmN0aW9uIG1hdGhxdWlsbEFucyhlbGVtZW50LCBtYXRoX3VzZXIpIHtcblx0XHRsZXQgaW5uZXJmaWVsZCA9IFtdO1xuXHRcdGxldCBkaXZfb3V0ZXIgPSBqUXVlcnkoZWxlbWVudCkuY2xvc2VzdCgnZGl2JykuZmluZChcInNwYW4uZmlsbGVsZW1lbnRcIikuYXR0cignaWQnKTtcblx0XHRsZXQgbWF0aF9pdGVtaWQgPSBqUXVlcnkoZWxlbWVudCkuYXR0cignaWQnKTtcblx0XHRsZXQgb3JpZ2luYWxfbGF0ZXggPSBqUXVlcnkoZWxlbWVudCkuYXR0cihcInVzZXJhbnNcIikudHJpbSgpO1xuXHRcdGxldCB1c2VyYW5zO1xuXHRcdGlmIChtYXRoX3VzZXIgPT0gXCJtYXRoX3VzZXJcIikge1xuXHRcdFx0dXNlcmFucyA9IG9yaWdpbmFsX2xhdGV4OyBcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IE1RID0gTWF0aFF1aWxsLmdldEludGVyZmFjZSgyKTtcblx0XHRcdGxldCBtYXRoX2l0ZW0gPSBNUS5TdGF0aWNNYXRoKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdGhfaXRlbWlkKSk7XG5cdFx0XHRmb3IgKGxldCBpPTA7IGk8PSBtYXRoX2l0ZW0uaW5uZXJGaWVsZHMubGVuZ3RoLTEgOyBpKyspIHtcblx0XHRcdFx0aW5uZXJmaWVsZFtpXSA9IG1hdGhfaXRlbS5pbm5lckZpZWxkc1tpXS5sYXRleCgpO1xuXHRcdFx0fVxuXHRcdFx0bGV0IG5ld19tYXRoX2ZpZWxkID0gb3JpZ2luYWxfbGF0ZXg7XG5cdFx0XHQvLyBsZXQgbWF0aGZpZWxkID0gb3JpZ2luYWxfbGF0ZXgubWF0Y2goL1xcXFxNYXRoUXVpbGxNYXRoRmllbGQoLio/KX0qfXs0LDZ9fFxcXFxNYXRoUXVpbGxNYXRoRmllbGQoLio/KX0qfXszLDZ9fFxcXFxNYXRoUXVpbGxNYXRoRmllbGQoLio/KX0qfXsyLDZ9fFxcXFxNYXRoUXVpbGxNYXRoRmllbGQoLio/KX0qfXsxLDZ9L2cpO1xuXHRcdFx0bGV0IG1hdGhmaWVsZCA9IG9yaWdpbmFsX2xhdGV4Lm1hdGNoKC9cXFxcTWF0aFF1aWxsTWF0aEZpZWxkeyguKj8pXFx9L2cpO1xuXHRcdFx0Zm9yIChsZXQgaSBpbiBtYXRoZmllbGQpIHtcblx0XHRcdFx0Y29uc3QgY3JlYXRlX21hdGhmaWVsZCA9ICdcXFxcTWF0aFF1aWxsTWF0aEZpZWxkeycraW5uZXJmaWVsZFtpXSsnfSc7XG5cdFx0XHRcdC8vIGNvbnN0IG5ld19tYXRoZmllbGQgPSBtYXRoZmllbGRbaV0ucmVwbGFjZSgvXFxcXE1hdGhRdWlsbE1hdGhGaWVsZCguKj8pfSp9ezQsNn18XFxcXE1hdGhRdWlsbE1hdGhGaWVsZCguKj8pfSp9ezMsNn18XFxcXE1hdGhRdWlsbE1hdGhGaWVsZCguKj8pfSp9ezIsNn18XFxcXE1hdGhRdWlsbE1hdGhGaWVsZCguKj8pfSp9ezEsNn0vZyAsIGNyZWF0ZV9tYXRoZmllbGQpO1xuXHRcdFx0XHRjb25zdCBuZXdfbWF0aGZpZWxkID0gbWF0aGZpZWxkW2ldLnJlcGxhY2UoL1xcXFxNYXRoUXVpbGxNYXRoRmllbGR7KC4qPylcXH0vZywgY3JlYXRlX21hdGhmaWVsZCk7XG5cdFx0XHRcdGxldCByZWdleCA9IG1hdGhmaWVsZFtpXTtcblx0XHRcdFx0bmV3X21hdGhfZmllbGQgPSBuZXdfbWF0aF9maWVsZC5yZXBsYWNlKHJlZ2V4LCBuZXdfbWF0aGZpZWxkKTtcblx0XHRcdH1cblx0XHRcdG9yaWdpbmFsX2xhdGV4ID0gbmV3X21hdGhfZmllbGQ7XG5cdFx0XHR1c2VyYW5zID0gb3JpZ2luYWxfbGF0ZXg7XG5cdFx0fVxuXG5cdFx0dXNhbnMgPSBjcmVhdGVBbnModXNhbnMsIG1hdGhfaXRlbWlkLCBkaXZfb3V0ZXIsIHVzZXJhbnMpO1xuXHRcdHNldFVzZXJBbnModXNhbnMpO1xuXHR9XG5cdFxuXG48L3NjcmlwdD5cblxuPG1haW4+XG5cdHsjaWYgc3RhdGUuYmxhbmsgPT0gZmFsc2V9XG5cdFx0XG5cdFx0PGNlbnRlcj5cblx0XHRcdDwhLS0gPGRpdiBjbGFzcz17XCJidG4tZ3JvdXAgY2xlYXJmaXggcmV2aWV3IFwiICtzdGF0ZS5zbUNvbnRyb2xsZXJ9IGlkPVwic21fY29udHJvbGxlclwiPlxuXHRcdFx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz17YnRudHlwZSA9PSBcImNvcnJlY3RhbnNcIiA/IFwiYnRuIGJ0bi1saWdodCBjb3JyZWN0LWFucyBhY3RpdmVcIiA6IFwiYnRuIGJ0bi1saWdodCBjb3JyZWN0LWFuc1wifSBvbjpjbGljaz17KCkgPT4ge2NvcnJlY3RBbnN3ZXIoKTsgfX0+e2wuY29ycmVjdF9hbnN3ZXJ9PC9idXR0b24+XG5cdFx0XHRcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPXtidG50eXBlID09IFwieW91cmFuc1wiID8gXCJidG4gYnRuLWxpZ2h0IHlvdXItYW5zIGFjdGl2ZVwiIDogXCJidG4gYnRuLWxpZ2h0IHlvdXItYW5zXCJ9IG9uOmNsaWNrPXsoKSA9PiB7eW91ckFuc3dlcigpO319PntsLnlvdXJfYW5zd2VyfTwvYnV0dG9uPlxuXHRcdFx0PC9kaXY+IC0tPlxuXHRcdFx0PEl0ZW1IZWxwZXIgXG5cdFx0XHRcdFxuXHRcdFx0XHRvbjpzZXRSZXZpZXcgPSB7c2V0UmV2aWV3fVxuXHRcdFx0XHRvbjp1bnNldFJldmlldyA9IHt1bnNldFJldmlld31cblx0XHRcdFx0aGFuZGxlUmV2aWV3Q2xpY2s9e2hhbmRsZVJldmlld31cblx0XHRcdFx0cmV2aWV3TW9kZT17aXNSZXZpZXd9XG5cdFx0XHQvPlxuXHRcdFx0PGRpdiBjbGFzcz17c3RhdGUubWFpbl9zdGVwcyA/ICdoLWltcCc6ICdpbk5hdGl2ZVN0eWxlJ30gc3R5bGU9e1wid2lkdGg6XCIgKyAoQUguaXNWYWxpZCh3aW5kb3cuaW5OYXRpdmUpID8gXCIxMDAlXCIgOiBcIjcwMHB4XCIpfT5cblx0XHRcdFx0XG5cdFx0XHRcdHsjZWFjaCBzdGF0ZS5pdGVtQXJyYXkgYXMgaXRlbSwgaW5kZXh9XG5cdFx0XHRcdFx0XHQ8ZGl2IGRhdGEtc3RpY2t5PXtpc1N0aWNreShpbmRleCl9IGNsYXNzPVwiYnQtcGQgYmctd2hpdGUgbXQtM1wiIHRhYmluZGV4PXswfT4gXHQgXHRcblx0XHRcdFx0XHRcdFx0PGRpdiBpZD17XCJzXCIraW5kZXh9IGNsYXNzPXtcImJnLXdoaXRlIFwiICsgKChzdGF0ZS5kaXNwbGF5ID09IDEpID8gKChzcGVjaWFsX21vZHVsZS5zbWFucyAhPSB1bmRlZmluZWQpID8gICgoc3BlY2lhbF9tb2R1bGUuc21hbnNbXCJzXCIraW5kZXhdICE9IHVuZGVmaW5lZCkgPyAoKHNwZWNpYWxfbW9kdWxlLnNtYW5zW1wic1wiK2luZGV4XS5vdmVyYWxsID09IDEpID8gJ2JvcmRlcl9ncmVlbic6ICdib3JkZXJfcmVkJykgOiAnJykgIDogJycpICA6ICcnKX0+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBpZD17J2RhdGEtYmxvY2tfJytpbmRleH0gY2xhc3M9e1wibWFpbl9pdGVtIGRhcmtncmV5X2JvcmRlciBzZWN1cmUtaWNvbiBwLWxnIGpxc2ZpZWxkIHNwYW5saW5rX25hdiBcIiArKChpbmRleCA9PSBzdGF0ZS5jbGFzc0NoYW5nZSkgPyAoKHN0YXRlLmlzQ29sb3IpID8gJ2JvcmRlcl9ncmVlbicgOiAnYm9yZGVyX3JlZCcpIDogJycpfSBrZXk9e2luZGV4fT5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgc2VxPXtcInNcIitpbmRleH0+e0BodG1sIGl0ZW0uY2RhdGF9PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9e3N0YXRlLmNvcnJlY3RfYW5zd2VyID8gJ2gtaW1wJzogJyd9IHN0eWxlPXtcIndpZHRoOlwiICsgKEFILmlzVmFsaWQod2luZG93LmluTmF0aXZlKSA/IFwiMTAwJVwiIDogXCI3MDBweFwiKX0+XG5cdFx0XHRcdHsjZWFjaCBhbnN3ZXJfYXJyYXkgYXMgaXRlbSxpbmRleH1cblx0XHRcdFxuXHRcdFx0XHRcdFx0PGRpdiBkYXRhLXN0aWNreT17aXNTdGlja3koaW5kZXgpfSBjbGFzcz1cImJ0LXBkIGJnLXdoaXRlIG10LTNcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBpZD17XCJzXCIraW5kZXh9IGNsYXNzPXtcImJnLXdoaXRlIFwiICsgKChzdGF0ZS5kaXNwbGF5ID09IDEpID8gKChzcGVjaWFsX21vZHVsZS5zbWFucyAhPSB1bmRlZmluZWQpID8gICgoc3BlY2lhbF9tb2R1bGUuc21hbnNbXCJzXCIraW5kZXhdICE9IHVuZGVmaW5lZCkgPyAoKHNwZWNpYWxfbW9kdWxlLnNtYW5zW1wic1wiK2luZGV4XS5vdmVyYWxsID09IDEpID8gJ2JvcmRlcl9ncmVlbic6ICdib3JkZXJfcmVkJykgOiAnJykgIDogJycpICA6ICcnKX0+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBpZD17J2RhdGEtYmxvY2tfJytpbmRleH0gY2xhc3M9e1wibWFpbl9pdGVtIGRhcmtncmV5X2JvcmRlciBzZWN1cmUtaWNvbiBwLWxnIGpxc2ZpZWxkIHNwYW5saW5rX25hdiBcIiArKChpbmRleCA9PSBzdGF0ZS5jbGFzc0NoYW5nZSkgPyAoKHN0YXRlLmlzQ29sb3IpID8gJ2JvcmRlcl9ncmVlbicgOiAnYm9yZGVyX3JlZCcpIDogJycpfSBrZXk9e2luZGV4fT5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgc2VxPXtcInNcIitpbmRleH0+e0BodG1sIGl0ZW0uX19jZGF0YX08L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdDwvZGl2PlxuXHRcdFx0eyNpZiBzdGF0ZS5zaG93VG9vbGJhcn1cblx0XHRcdFx0PEZpbGxJblRoZUJsYW5rc1Rvb2xiYXIgIHNwYW5JZD17c3RhdGUuc3BhbklkfSBkaXZJZD17c3RhdGUuZGl2SWR9IGFjdGlvbj17ZmlsbF9tYXRoW2ZpbGxJZF19IHNob3c9eyh2YWx1ZSkgPT4ge3RvZ2dsZVRvb2xiYXIodmFsdWUpfX0vPlxuXHRcdFx0ey9pZn1cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPXtzdGF0ZS5oaWRlTmV4dCA/ICdoLWltcCc6IG51bGx9PlxuXHRcdFx0XHRcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIHN0eWxlPXsnd2lkdGg6YXV0bztmb250LXNpemU6MTVweDttYXJnaW46MTVweCAwOyd9IGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1wcmltYXJ5IGltZ2NlbnRlciBuZXh0X3N0ZXAgcHgtbWQtNSBweC1zbS0zXCIgIG9uOmNsaWNrPXsoKSA9PiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bW92ZU5leHQoKX0sMTAwKX0gPntsLm5leHR9PC9idXR0b24+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdDwvY2VudGVyPlxuXHR7L2lmfVxuPC9tYWluPlxuXG48c3R5bGU+XG5cdDpnbG9iYWwoLmRhcmtncmV5X2JvcmRlcikge1xuICBcdCAgYm9yZGVyOiAxcHggc29saWQgI2NjYyFpbXBvcnRhbnQ7XG5cdH1cblxuXHQ6Z2xvYmFsKC5wLWxnKSB7XG4gIFx0ICBwYWRkaW5nOiAxNXB4O1xuXHR9XG5cdDpnbG9iYWwoLnRydWUtaG92ZXIpIHtcblx0XHRvdXRsaW5lOiAwO1xuXHRcdGJvcmRlcjogMnB4IHNvbGlkICMxNGNhMTQhaW1wb3J0YW50O1xuXHR9XG5cblx0Omdsb2JhbCguZmFsc2UtaG92ZXIpIHtcblx0XHRvdXRsaW5lOiAwO1xuXHRcdGJvcmRlcjogMnB4IHNvbGlkICNlNDUyNTIhaW1wb3J0YW50O1xuXHR9XG5cblx0Omdsb2JhbCguZGVmYXVsdC1ob3Zlcikge1xuXHRcdGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQhaW1wb3J0YW50O1xuXHRcdC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMHB4IDBweCByZ2JhKDAsMCwwLC4wNzUpLCAwIDAgMXB4IHJnYmEoMiwgMiwgMiwgMC45KSFpbXBvcnRhbnQ7XG5cdFx0LW1vei1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAwcHggMHB4IHJnYmEoMCwwLDAsLjA3NSksIDAgMCAxcHggcmdiYSgyLCAyLCAyLCAwLjkpIWltcG9ydGFudDtcblx0XHRib3gtc2hhZG93OiBpbnNldCAwIDFweCAwcHggMHB4IHJnYmEoMCwwLDAsLjA3NSksIDAgMCAxcHggcmdiYSgyLCAyLCAyLCAwLjkpIWltcG9ydGFudDtcblx0fVxuXG5cdDpnbG9iYWwoLmJsb2NrZWQpIHtcblx0XHRkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xuXHR9XG5cblx0Omdsb2JhbCguYm9yZGVyX2dyZWVuKSB7XG5cdFx0Ym9yZGVyOiAzcHggc29saWQgZ3JlZW4haW1wb3J0YW50O1xuXHR9XG5cblx0Omdsb2JhbCguYm9yZGVyX3JlZCkge1xuXHRcdGJvcmRlcjogM3B4IHNvbGlkIHJlZCFpbXBvcnRhbnQ7XG5cdH1cblxuXHQ6Z2xvYmFsKC5zdGlja3kpIHtcblx0XHR6LWluZGV4OiA4MDA7XG5cdFx0cG9zaXRpb246IHN0aWNreTtcblx0XHR0b3A6IDBcblx0fVxuXG5cdDpnbG9iYWwoLmNvcnJfZGl2KSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlIWltcG9ydGFudDtcblx0XHR3aWR0aDogNjBweDtcblx0XHRsaW5lLWhlaWdodDogMzBweDtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjMjFhODFkO1xuXHRcdGNvbG9yOiAjZmZmZmZmO1xuXHRcdHotaW5kZXg6IDE7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0Y3Vyc29yOiBkZWZhdWx0O1xuXHR9XG5cblx0Omdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0pIHtcbiAgICAgICAgb3ZlcmZsb3c6aGlkZGVuO1xuICAgICAgICAvKndpZHRoOjcwMHB4OyAgdGVzdGluZyovXG4gICAgICAgIHRleHQtYWxpZ246bGVmdDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gcHJlKSB7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4IWltcG9ydGFudDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLnN0cmluZykge1xuICAgICAgICBtaW4taGVpZ2h0OjUwcHg7XG4gICAgICAgIG1hcmdpbi10b3A6MTBweDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OjEwcHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5mb290ZXJzdHIpIHtcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNjY2M7XG4gICAgICAgIHBhZGRpbmc6IDE1cHg7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDYwcHg7LyoxMDBweDsqL1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZm9vdGVyc3RyIC5hcnJvdy11cCkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTEwcHg7XG4gICAgICAgIHJpZ2h0OiA1MCU7XG4gICAgICAgIHdpZHRoOiAwO1xuICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIGJvcmRlci1sZWZ0OiAxMHB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXItcmlnaHQ6IDEwcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDEwcHggc29saWQgI2NjYztcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZpbGwtcm93KSB7XG4gICAgICAgIHBhZGRpbmc6NnB4O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZmlsbGVsZW1lbnQsIFtpZF49XCJmaWxsbWFpblwiXSAuZHJhZy1yZXNpemUpIHtcbiAgICAgICAgaGVpZ2h0OjMwcHg7XG4gICAgICAgIGRpc3BsYXk6aW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICAgICAgbWluLWhlaWdodDogMzBweDtcbiAgICAgICAgbWFyZ2luOiAxcHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIGlucHV0W3R5cGU9XCJ0ZXh0XCJdLCBbaWRePVwiZmlsbG1haW5cIl0gc2VsZWN0KSB7XHRcbiAgICAgICAgaGVpZ2h0Ojk5JSFpbXBvcnRhbnQ7XG4gICAgICAgIHJlc2l6ZTogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOjEycHg7XG4gICAgICAgIGNvbG9yOiAjMDAwO1xuICAgICAgICBtYXgtd2lkdGg6IDgwMHB4O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZHJhZy1yZXNpemUpIHtcbiAgICAgICAgdmVydGljYWwtYWxpZ246bWlkZGxlO1xuICAgICAgICBib3JkZXI6MXB4IHNvbGlkICMzMUI3MzE7XG4gICAgICAgIHRleHQtYWxpZ246Y2VudGVyO1xuICAgICAgICBwYWRkaW5nOjNweDtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZHJhZy1yZXNpemUudWktZHJhZ2dhYmxlKSB7XG4gICAgICAgIGN1cnNvcjptb3ZlO1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZHJvcC1ob3Zlcikge1xuICAgICAgICBib3JkZXI6IDFweCBkYXNoZWQgcmVkIWltcG9ydGFudDtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMnB4IHllbGxvdyBpbnNldDtcbiAgICAgICAgb3V0bGluZTogMXB4IHNvbGlkIGJsdWU7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5maWxsY2hlY2sgdWwpIHtcbiAgICAgICAgd2lkdGg6MjIwcHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5maWxsY2hlY2sgbGkuc2VsZWN0ZWQpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0U1RTVFNTtcbiAgICB9XG4gICAgOmdsb2JhbCguZmlsbGNoZWNrIC5zZWxlY3RlZCAuaWNvbW9vbi1jaGVja21hcmstMzpiZWZvcmUpIHtcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgICAgICBwYWRkaW5nOiAzcHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcmlnaHQ6IDE0cHg7XG4gICAgfVxuICAgIDpnbG9iYWwoLmZpbGxjaGVjayAuaWNvbW9vbi1jbG9zZS0yOmJlZm9yZSkge1xuICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcmlnaHQ6IDE0cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICB9XG4gICAgOmdsb2JhbCguTWF0aEpheF9EaXNwbGF5KSB7XG4gICAgICAgICAgICBkaXNwbGF5IDogaW5saW5lIWltcG9ydGFudDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLnNlbGVjdCkge1xuICAgICAgICBmb250LXNpemU6IDE1cHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC50ZXh0YXJlYSkge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6M3B4O1xuICAgICAgICBiYWNrZ3JvdW5kOiNmZmU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG4gICAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsMC4wNzUpO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwwLjA3NSk7XG4gICAgfVxuICAgIDpnbG9iYWwoLnVpLWRyYWdnYWJsZS1kaXNhYmxlZCkge1xuICAgICAgICBjdXJzb3I6IG5vLWRyb3AhaW1wb3J0YW50O1xuICAgICAgICBvcGFjaXR5OiAwLjUhaW1wb3J0YW50O1xuICAgIH1cblxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBK25DUyxnQkFBZ0IsQUFBRSxDQUFDLEFBQ3ZCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksVUFBVSxBQUNwQyxDQUFDLEFBRU8sS0FBSyxBQUFFLENBQUMsQUFDWixPQUFPLENBQUUsSUFBSSxBQUNqQixDQUFDLEFBQ08sV0FBVyxBQUFFLENBQUMsQUFDckIsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLFVBQVUsQUFDcEMsQ0FBQyxBQUVPLFlBQVksQUFBRSxDQUFDLEFBQ3RCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxVQUFVLEFBQ3BDLENBQUMsQUFFTyxjQUFjLEFBQUUsQ0FBQyxBQUN4QixZQUFZLENBQUUsV0FBVyxVQUFVLENBQ25DLGtCQUFrQixDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FDOUYsZUFBZSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FDM0YsVUFBVSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQUFDdkYsQ0FBQyxBQUVPLFFBQVEsQUFBRSxDQUFDLEFBQ2xCLE9BQU8sQ0FBRSxLQUFLLENBQUMsVUFBVSxBQUMxQixDQUFDLEFBRU8sYUFBYSxBQUFFLENBQUMsQUFDdkIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxVQUFVLEFBQ2xDLENBQUMsQUFFTyxXQUFXLEFBQUUsQ0FBQyxBQUNyQixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLFVBQVUsQUFDaEMsQ0FBQyxBQUVPLE9BQU8sQUFBRSxDQUFDLEFBQ2pCLE9BQU8sQ0FBRSxHQUFHLENBQ1osUUFBUSxDQUFFLE1BQU0sQ0FDaEIsR0FBRyxDQUFFLENBQUM7Q0FDUCxDQUFDLEFBRU8sU0FBUyxBQUFFLENBQUMsQUFDbkIsUUFBUSxDQUFFLFFBQVEsVUFBVSxDQUM1QixLQUFLLENBQUUsSUFBSSxDQUNYLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsS0FBSyxDQUFFLE9BQU8sQ0FDZCxPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLE1BQU0sQ0FBRSxPQUFPLEFBQ2hCLENBQUMsQUFFTyxnQkFBZ0IsQUFBRSxDQUFDLEFBQ3BCLFNBQVMsTUFBTSxDQUVmLFdBQVcsSUFBSSxBQUNuQixDQUFDLEFBQ08sb0JBQW9CLEFBQUUsQ0FBQyxBQUMzQixVQUFVLENBQUUsSUFBSSxDQUNoQixNQUFNLENBQUUsSUFBSSxDQUNaLFNBQVMsQ0FBRSxJQUFJLFVBQVUsQUFDN0IsQ0FBQyxBQUNPLHdCQUF3QixBQUFFLENBQUMsQUFDL0IsV0FBVyxJQUFJLENBQ2YsV0FBVyxJQUFJLENBQ2YsYUFBYSxJQUFJLEFBQ3JCLENBQUMsQUFDTywyQkFBMkIsQUFBRSxDQUFDLEFBQ2xDLFNBQVMsUUFBUSxDQUNqQixVQUFVLENBQUUsSUFBSSxDQUNoQixnQkFBZ0IsQ0FBRSxJQUFJLENBQ3RCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLElBQUksQUFDcEIsQ0FBQyxBQUNPLHFDQUFxQyxBQUFFLENBQUMsQUFDNUMsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLEtBQUssQ0FDVixLQUFLLENBQUUsR0FBRyxDQUNWLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxXQUFXLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQ25DLFlBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FDcEMsYUFBYSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUNsQyxDQUFDLEFBQ08sMEJBQTBCLEFBQUUsQ0FBQyxBQUNqQyxRQUFRLEdBQUcsQUFDZixDQUFDLEFBQ08sNERBQTRELEFBQUUsQ0FBQyxBQUNuRSxPQUFPLElBQUksQ0FDWCxRQUFRLFlBQVksQ0FDcEIsU0FBUyxRQUFRLENBQ2pCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxHQUFHLEFBQ2YsQ0FBQyxBQUNPLDREQUE0RCxBQUFFLENBQUMsQUFDbkUsT0FBTyxHQUFHLFVBQVUsQ0FDcEIsTUFBTSxDQUFFLElBQUksQ0FDWixVQUFVLElBQUksQ0FDZCxLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxLQUFLLEFBQ3BCLENBQUMsQUFDTyw2QkFBNkIsQUFBRSxDQUFDLEFBQ3BDLGVBQWUsTUFBTSxDQUNyQixPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUN4QixXQUFXLE1BQU0sQ0FDakIsUUFBUSxHQUFHLENBQ1gsU0FBUyxDQUFFLElBQUksQUFDbkIsQ0FBQyxBQUNPLDBDQUEwQyxBQUFFLENBQUMsQUFDakQsT0FBTyxJQUFJLEFBQ2YsQ0FBQyxBQUNPLDRCQUE0QixBQUFFLENBQUMsQUFDbkMsTUFBTSxDQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxVQUFVLENBQ2hDLFVBQVUsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FDbEMsT0FBTyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUMzQixDQUFDLEFBQ08sOEJBQThCLEFBQUUsQ0FBQyxBQUNyQyxNQUFNLEtBQUssQUFDZixDQUFDLEFBQ08sdUNBQXVDLEFBQUUsQ0FBQyxBQUM5QyxnQkFBZ0IsQ0FBRSxPQUFPLEFBQzdCLENBQUMsQUFDTyxnREFBZ0QsQUFBRSxDQUFDLEFBQ3ZELEtBQUssQ0FBRSxJQUFJLENBQ1gsS0FBSyxDQUFFLElBQUksQ0FDWCxPQUFPLENBQUUsR0FBRyxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUNPLGtDQUFrQyxBQUFFLENBQUMsQUFDekMsS0FBSyxDQUFFLElBQUksQ0FDWCxLQUFLLENBQUUsSUFBSSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsU0FBUyxDQUFFLElBQUksQUFDbkIsQ0FBQyxBQUNPLGdCQUFnQixBQUFFLENBQUMsQUFDbkIsT0FBTyxDQUFHLE1BQU0sVUFBVSxBQUNsQyxDQUFDLEFBQ08sd0JBQXdCLEFBQUUsQ0FBQyxBQUMvQixTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBQ08sMEJBQTBCLEFBQUUsQ0FBQyxBQUNqQyxlQUFlLE1BQU0sQ0FDckIsY0FBYyxHQUFHLENBQ2pCLFdBQVcsSUFBSSxDQUNmLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDdEIsa0JBQWtCLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQ3JELFVBQVUsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQUFDakQsQ0FBQyxBQUNPLHNCQUFzQixBQUFFLENBQUMsQUFDN0IsTUFBTSxDQUFFLE9BQU8sVUFBVSxDQUN6QixPQUFPLENBQUUsR0FBRyxVQUFVLEFBQzFCLENBQUMifQ== */";
	append_dev(document_1.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[67] = list[i];
	child_ctx[69] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[67] = list[i];
	child_ctx[69] = i;
	return child_ctx;
}

// (1100:1) {#if state.blank == false}
function create_if_block(ctx) {
	let center;
	let itemhelper;
	let t0;
	let div0;
	let div0_class_value;
	let div0_style_value;
	let t1;
	let div1;
	let div1_class_value;
	let div1_style_value;
	let t2;
	let t3;
	let div2;
	let button;
	let button_style_value;
	let div2_class_value;
	let current;
	let mounted;
	let dispose;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[11],
				reviewMode: /*isReview*/ ctx[0]
			},
			$$inline: true
		});

	itemhelper.$on("setReview", /*setReview*/ ctx[9]);
	itemhelper.$on("unsetReview", /*unsetReview*/ ctx[10]);
	let each_value_1 = /*state*/ ctx[5].itemArray;
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*answer_array*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block = /*state*/ ctx[5].showToolbar && create_if_block_1(ctx);

	const block = {
		c: function create() {
			center = element("center");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block) if_block.c();
			t3 = space();
			div2 = element("div");
			button = element("button");
			button.textContent = `${language.next}`;
			attr_dev(div0, "class", div0_class_value = /*state*/ ctx[5].main_steps ? "h-imp" : "inNativeStyle");
			attr_dev(div0, "style", div0_style_value = "width:" + (AH.isValid(window.inNative) ? "100%" : "700px"));
			add_location(div0, file, 1113, 3, 33713);
			attr_dev(div1, "class", div1_class_value = /*state*/ ctx[5].correct_answer ? "h-imp" : "");
			attr_dev(div1, "style", div1_style_value = "width:" + (AH.isValid(window.inNative) ? "100%" : "700px"));
			add_location(div1, file, 1126, 3, 34581);
			attr_dev(button, "type", "button");
			attr_dev(button, "style", button_style_value = "width:auto;font-size:15px;margin:15px 0;");
			attr_dev(button, "class", "btn btn-sm btn-outline-primary imgcenter next_step px-md-5 px-sm-3");
			add_location(button, file, 1144, 5, 35649);
			attr_dev(div2, "class", div2_class_value = /*state*/ ctx[5].hideNext ? "h-imp" : null);
			add_location(div2, file, 1143, 4, 35599);
			add_location(center, file, 1101, 2, 33077);
		},
		m: function mount(target, anchor) {
			insert_dev(target, center, anchor);
			mount_component(itemhelper, center, null);
			append_dev(center, t0);
			append_dev(center, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append_dev(center, t1);
			append_dev(center, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_dev(center, t2);
			if (if_block) if_block.m(center, null);
			append_dev(center, t3);
			append_dev(center, div2);
			append_dev(div2, button);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[16], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);

			if (dirty[0] & /*isSticky, state, special_module*/ 104) {
				each_value_1 = /*state*/ ctx[5].itemArray;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (!current || dirty[0] & /*state*/ 32 && div0_class_value !== (div0_class_value = /*state*/ ctx[5].main_steps ? "h-imp" : "inNativeStyle")) {
				attr_dev(div0, "class", div0_class_value);
			}

			if (dirty[0] & /*isSticky, state, special_module, answer_array*/ 108) {
				each_value = /*answer_array*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*state*/ 32 && div1_class_value !== (div1_class_value = /*state*/ ctx[5].correct_answer ? "h-imp" : "")) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (/*state*/ ctx[5].showToolbar) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*state*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(center, t3);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*state*/ 32 && div2_class_value !== (div2_class_value = /*state*/ ctx[5].hideNext ? "h-imp" : null)) {
				attr_dev(div2, "class", div2_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(center);
			destroy_component(itemhelper);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(1100:1) {#if state.blank == false}",
		ctx
	});

	return block;
}

// (1116:4) {#each state.itemArray as item, index}
function create_each_block_1(ctx) {
	let div3;
	let div2;
	let div1;
	let div0;
	let raw_value = /*item*/ ctx[67].cdata + "";
	let div0_seq_value;
	let div1_id_value;
	let div1_class_value;
	let div1_key_value;
	let div2_id_value;
	let div2_class_value;
	let t;
	let div3_data_sticky_value;
	let div3_tabindex_value;

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t = space();
			attr_dev(div0, "seq", div0_seq_value = "s" + /*index*/ ctx[69]);
			add_location(div0, file, 1119, 9, 34463);
			attr_dev(div1, "id", div1_id_value = "data-block_" + /*index*/ ctx[69]);

			attr_dev(div1, "class", div1_class_value = "main_item darkgrey_border secure-icon p-lg jqsfield spanlink_nav " + (/*index*/ ctx[69] == /*state*/ ctx[5].classChange
			? /*state*/ ctx[5].isColor ? "border_green" : "border_red"
			: ""));

			attr_dev(div1, "key", div1_key_value = /*index*/ ctx[69]);
			add_location(div1, file, 1118, 8, 34246);
			attr_dev(div2, "id", div2_id_value = "s" + /*index*/ ctx[69]);

			attr_dev(div2, "class", div2_class_value = "bg-white " + (/*state*/ ctx[5].display == 1
			? /*special_module*/ ctx[3].smans != undefined
				? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]] != undefined
					? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]].overall == 1
						? "border_green"
						: "border_red"
					: ""
				: ""
			: ""));

			add_location(div2, file, 1117, 7, 33981);
			attr_dev(div3, "data-sticky", div3_data_sticky_value = /*isSticky*/ ctx[6](/*index*/ ctx[69]));
			attr_dev(div3, "class", "bt-pd bg-white mt-3");
			attr_dev(div3, "tabindex", div3_tabindex_value = 0);
			add_location(div3, file, 1116, 6, 33893);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			div0.innerHTML = raw_value;
			append_dev(div3, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 32 && raw_value !== (raw_value = /*item*/ ctx[67].cdata + "")) div0.innerHTML = raw_value;
			if (dirty[0] & /*state*/ 32 && div1_class_value !== (div1_class_value = "main_item darkgrey_border secure-icon p-lg jqsfield spanlink_nav " + (/*index*/ ctx[69] == /*state*/ ctx[5].classChange
			? /*state*/ ctx[5].isColor ? "border_green" : "border_red"
			: ""))) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (dirty[0] & /*state, special_module*/ 40 && div2_class_value !== (div2_class_value = "bg-white " + (/*state*/ ctx[5].display == 1
			? /*special_module*/ ctx[3].smans != undefined
				? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]] != undefined
					? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]].overall == 1
						? "border_green"
						: "border_red"
					: ""
				: ""
			: ""))) {
				attr_dev(div2, "class", div2_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(1116:4) {#each state.itemArray as item, index}",
		ctx
	});

	return block;
}

// (1128:4) {#each answer_array as item,index}
function create_each_block(ctx) {
	let div3;
	let div2;
	let div1;
	let div0;
	let raw_value = /*item*/ ctx[67].__cdata + "";
	let div0_seq_value;
	let div1_id_value;
	let div1_class_value;
	let div1_key_value;
	let div2_id_value;
	let div2_class_value;
	let t;
	let div3_data_sticky_value;

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t = space();
			attr_dev(div0, "seq", div0_seq_value = "s" + /*index*/ ctx[69]);
			add_location(div0, file, 1132, 9, 35300);
			attr_dev(div1, "id", div1_id_value = "data-block_" + /*index*/ ctx[69]);

			attr_dev(div1, "class", div1_class_value = "main_item darkgrey_border secure-icon p-lg jqsfield spanlink_nav " + (/*index*/ ctx[69] == /*state*/ ctx[5].classChange
			? /*state*/ ctx[5].isColor ? "border_green" : "border_red"
			: ""));

			attr_dev(div1, "key", div1_key_value = /*index*/ ctx[69]);
			add_location(div1, file, 1131, 8, 35083);
			attr_dev(div2, "id", div2_id_value = "s" + /*index*/ ctx[69]);

			attr_dev(div2, "class", div2_class_value = "bg-white " + (/*state*/ ctx[5].display == 1
			? /*special_module*/ ctx[3].smans != undefined
				? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]] != undefined
					? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]].overall == 1
						? "border_green"
						: "border_red"
					: ""
				: ""
			: ""));

			add_location(div2, file, 1130, 7, 34818);
			attr_dev(div3, "data-sticky", div3_data_sticky_value = /*isSticky*/ ctx[6](/*index*/ ctx[69]));
			attr_dev(div3, "class", "bt-pd bg-white mt-3");
			add_location(div3, file, 1129, 6, 34747);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			div0.innerHTML = raw_value;
			append_dev(div3, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*answer_array*/ 4 && raw_value !== (raw_value = /*item*/ ctx[67].__cdata + "")) div0.innerHTML = raw_value;
			if (dirty[0] & /*state*/ 32 && div1_class_value !== (div1_class_value = "main_item darkgrey_border secure-icon p-lg jqsfield spanlink_nav " + (/*index*/ ctx[69] == /*state*/ ctx[5].classChange
			? /*state*/ ctx[5].isColor ? "border_green" : "border_red"
			: ""))) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (dirty[0] & /*state, special_module*/ 40 && div2_class_value !== (div2_class_value = "bg-white " + (/*state*/ ctx[5].display == 1
			? /*special_module*/ ctx[3].smans != undefined
				? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]] != undefined
					? /*special_module*/ ctx[3].smans["s" + /*index*/ ctx[69]].overall == 1
						? "border_green"
						: "border_red"
					: ""
				: ""
			: ""))) {
				attr_dev(div2, "class", div2_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(1128:4) {#each answer_array as item,index}",
		ctx
	});

	return block;
}

// (1140:3) {#if state.showToolbar}
function create_if_block_1(ctx) {
	let fillintheblankstoolbar;
	let current;

	fillintheblankstoolbar = new FillInTheBlanksToolbar({
			props: {
				spanId: /*state*/ ctx[5].spanId,
				divId: /*state*/ ctx[5].divId,
				action: /*fill_math*/ ctx[1][/*fillId*/ ctx[4]],
				show: /*func*/ ctx[15]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(fillintheblankstoolbar.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(fillintheblankstoolbar, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fillintheblankstoolbar_changes = {};
			if (dirty[0] & /*state*/ 32) fillintheblankstoolbar_changes.spanId = /*state*/ ctx[5].spanId;
			if (dirty[0] & /*state*/ 32) fillintheblankstoolbar_changes.divId = /*state*/ ctx[5].divId;
			if (dirty[0] & /*fill_math, fillId*/ 18) fillintheblankstoolbar_changes.action = /*fill_math*/ ctx[1][/*fillId*/ ctx[4]];
			fillintheblankstoolbar.$set(fillintheblankstoolbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fillintheblankstoolbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fillintheblankstoolbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(fillintheblankstoolbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(1140:3) {#if state.showToolbar}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let current;
	let if_block = /*state*/ ctx[5].blank == false && create_if_block(ctx);

	const block = {
		c: function create() {
			main = element("main");
			if (if_block) if_block.c();
			add_location(main, file, 1098, 0, 33037);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			if (if_block) if_block.m(main, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*state*/ ctx[5].blank == false) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*state*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(main, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function createAns(obj, element_id, element_div, correctval) {
	if (typeof obj[element_div] == "undefined" || typeof obj[element_div][element_id] == "undefined") {
		if (typeof obj[element_div] == "undefined") {
			obj[element_div] = {};
		}

		obj[element_div][element_id] = {};
	}

	obj[element_div][element_id].value = correctval;
	return obj;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("StepAlgoPreview", slots, []);
	let step_xml;
	let smans = {};
	let usans = {};
	let element_id, element_div = "";
	let cdata = "";
	let fill_math = [];
	var answer_array = [];
	let btntype;
	let resultNew = {};
	let var_list = "";
	let special_module = {};
	let lists = "";
	let oldstep = "";
	let answer_arr = [];
	let fillId;
	let steps = 0;
	let wrong_choice = 0;
	let optionrem = 0;
	let flagxml = false;
	let state = {};
	let { xml } = $$props;
	let { stopPreviewUpdate } = $$props;
	let { isReview } = $$props;
	let { uxml } = $$props;

	let stateData = writable({
		blank: true,
		hideNext: false,
		itemArray: [],
		classChange: -1,
		isColor: true,
		smController: "h",
		display: -1,
		showToolbar: true,
		isMathquill: false,
		correct_answer: true,
		main_steps: false,
		your_answer: []
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(5, state = items);
	});

	beforeUpdate(() => {
		if (state.isMathquill) {
			loadLibs();
		}

		if (uxml) {
			let answer = XMLToJSON(uxml);

			if (answer.smans) {
				if (answer.smans.div) {
					if (answer.smans.div._userAns) {
						parseSteps(uxml);
					}
				}
			}
		}

		if (xml != state.xml) {
			$$invalidate(5, state.xml = xml, state);
			if (stopPreviewUpdate == true) return false;

			if (!uxml) {
				steps = 0;
				$$invalidate(5, state.itemArray = [], state);
				(usans = {});
				$$invalidate(5, state.hideNext = false, state);
				reset();
			}

			$$invalidate(5, state.blank = false, state);
			let new_xml = XMLToJSON(state.xml);
			loadModule(new_xml);
		}
	});

	onMount(() => {
		window.J = jquery;
		AI.set("stepAlgo", this);
		AH.addScript("", "https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js");
		AH.addScript("", window.itemFolder + "src/libs/mathQuill_new.js");

		if (window.inNative) {
			window.getHeight && window.getHeight();
		}

		setTimeout(
			function () {
				//jQuery('.toolbar_container_one').addClass('h-imp');
				AH.selectAll(".toolbar_container_one", "addClass", "h-imp");
			},
			100
		);

		AH.listen(document, "click", ".edit_step", _element => {
			setOutline(_element);
		});

		AH.listen(document, "keyup", ".edit_step", _element => {
			setOutline(_element);
		});

		AH.listen(document, "change", ".edit_step", _element => {
			setOutline(_element);
		});

		AH.listen(document, "click", "span.mq-editable-field.mq-focused", _e => {
			let span_math = _e;
			let is_fillid = true;
			let fillid;

			while (is_fillid) {
				span_math = span_math.parentElement;

				if (span_math.getAttribute("id")) {
					is_fillid = false;
					fillid = span_math.getAttribute("id");
					$$invalidate(4, fillId = fillid);
				}
			}

			let latex_array = [];

			AH.selectAll("#" + fillid + " span.mq-editable-field").forEach(_this => {
				let command_id = _this.getAttribute("mathquill-command-id");
				latex_array.push(command_id);
			}); // Need to fixed it

			let math_id = _e.getAttribute("mathquill-command-id");
			let index_id = latex_array.indexOf(math_id);
			$$invalidate(5, state.spanId = index_id, state);
			$$invalidate(5, state.divId = fillid, state);
			AH.selectAll(".toolbar_container_one", "removeClass", "h-imp");
			$$invalidate(5, state.showToolbar = true, state);
		});

		// jQuery(document).on('click', '.next_step', function(e) {
		// 	if (typeof QUIZPLAYERID != "undefined") {
		// 		window.parent.autoResize(QUIZPLAYERID);
		// 	}
		// 	e.preventDefault();
		// 	inputFilled();
		// });
		AH.listen(document, "click", ".next_step", function (curr, e) {
			if (typeof QUIZPLAYERID != "undefined") {
				window.parentElement.autoResize(QUIZPLAYERID);
			}

			e.preventDefault();
			inputFilled();
		});

		// setTimeout(function() {
		// 	jQuery("#set-review").on('click', function() {
		// 		setReview();
		// 	});
		// 	jQuery("#unset-review").on('click', function() {
		// 		unsetReview();
		// 	});
		// },1000);
		setTimeout(
			function () {
				AH.listen(document, "click", "#set-review", function () {
					setReview();
				});

				AH.listen(document, "click", "#unset-review", function () {
					unsetReview();
				});
			},
			1000
		);

		if (window.inNative) {
			setTimeout(
				function () {
					window.postMessage("height___" + document.getElementsByClassName("inNativeStyle")[0].offsetHeight, "*");
				},
				200
			);
		}

		if (window.inNative) {
			window.checkReview = isReview => isReview ? self.setReview() : self.unsetReview();
		}

		AH.addScript("", window.mainSiteThemeUrl + "prepengine/mathquill.js");
	});

	function setOutline(_element) {
		if (_element.nodeName) {
			if (_element.classList.contains("mathquill")) {
				mathquillAns(_element, false);
			} else {
				let inp_id = _element.getAttribute("id");
				let inp_div = _element.closest("div").getAttribute("seq");
				let inp_val = _element.value;
				usans = createAns(usans, inp_id, inp_div, inp_val);
				setUserAns(usans);
			}
		}
	}

	function inputFilled() {
		if (usans) {
			for (let i in usans) {
				for (let key in usans[i]) {
					let ans_val = usans[i][key].value;

					if (ans_val != "") {
						let ans_arr = ans_val.match(/MathQuillMathField\{(.*?)\}/g);

						if (ans_arr) {
							ans_arr.map(function (obj) {
								let math_field = obj.toString().replace(/MathQuillMathField\{|\}/g, "");

								if (math_field == "") {
									//jQuery("#"+key).removeClass('answer_input');
									AH.select("#" + key, "removeClass", "answer_input");
								} else {
									//jQuery("#"+key).addClass('answer_input');
									AH.select("#" + key, "addClass", "answer_input");
								}
							});
						} else {
							//jQuery("#"+key).addClass('answer_input');
							AH.select("#" + key, "addClass", "answer_input");
						}
					} else {
						//jQuery("#"+key).removeClass('answer_input');
						AH.select("#" + key, "removeClass", "answer_input");
					}
				}
			}
		}
	}

	function loadModule(new_xml) {
		flagxml = false;

		if (new_xml.smxml.algo != "undefined" && new_xml.smxml.algo) {
			flagxml = true;
		}

		if (flagxml) {
			var_list = Step.init(new_xml.smxml.algo);
		}

		let xml_str = JSON.stringify(new_xml);

		if (flagxml) {
			if (uxml) {
				let answer = XMLToJSON(uxml);

				if (answer.smans) {
					if (answer.smans.div) {
						if (answer.smans.div._lists) {
							var_list = lists;
						}
					}
				}
			}

			step_xml = Step.init.replaceVariables(xml_str, var_list);
			step_xml = JSON.parse(step_xml);
		} else {
			step_xml = new_xml;
		}

		let answer_arr_clone = step_xml.smxml.step;
		$$invalidate(2, answer_array = answer_arr_clone.slice());

		if (typeof Object.assign != "function") {
			Object.assign = function (target) {

				if (target == null) {
					throw new TypeError("Cannot convert undefined or null to object");
				}

				target = Object(target);

				for (var index = 1; index < arguments.length; index++) {
					var source = arguments[index];

					if (source != null) {
						for (var key in source) {
							if (Object.prototype.hasOwnProperty.call(source, key)) {
								target[key] = source[key];
							}
						}
					}
				}

				return target;
			};
		}

		answer_arr_clone.map(function (item, i) {
			$$invalidate(2, answer_array[i] = Object.assign({}, item), answer_array);
		});

		if (oldstep != "") {
			steps = oldstep;

			for (let i = 0; i <= oldstep; i++) {
				createStep(i);
			}
		} else {
			createStep();
		}

		if (uxml) {
			let answer = XMLToJSON(uxml);

			if (answer.smans) {
				if (answer.smans.div) {
					if (answer.smans.div._userAns) {
						var timer = setTimeout(
							function () {
								parseUserAns(uxml);
								clearTimeout(timer);
							},
							50
						);
					}
				}
			}
		}
	}

	function parseUserAns(uans) {
		let user_answer = XMLToJSON(uans);

		if (user_answer.smans && user_answer.smans.div && user_answer.smans.div._userAns) {
			user_answer = JSON.parse(user_answer.smans.div._userAns);

			for (let i in user_answer) {
				for (let j in user_answer[i]) {
					let runn = i.split("");
					let val = runn[1];
					let box_value = user_answer[i][j].value;

					if (AH.select("#" + j).classList.contains("mathquill")) {
						//jQuery('#'+j).attr('userans', box_value);
						AH.select("#" + j, "userans", box_value);

						mathquillAns("#" + j, "math_user");
					} else {
						//jQuery('#'+j).val(box_value).focus().blur(); 
						AH.select("#" + j).value = box_value;

						setOutline(AH.select("#" + j));
					}

					optionrem = 0;
					inputFilled();
					checkAns(val);
				}
			}
		} //forceUpdate();
	}

	function createStep(i) {
		if (flagxml) {
			$$invalidate(3, special_module.var_list = var_list, special_module);
		}

		$$invalidate(3, special_module.cuurentStep = steps, special_module);
		optionrem = 0;
		const item = state.itemArray;
		parseXmlAuthoring(step_xml, i);
		item.push({ cdata });
		$$invalidate(5, state.itemArray = item, state);

		if (i <= oldstep) {
			var curr = i;
		} else {
			var curr = steps;
		}

		var timer = setTimeout(
			function () {
				if (step_xml.smxml.step[curr + 1] == undefined && step_xml.smxml.step[curr]._attempt == "1" || step_xml.smxml.step[curr + 1] == undefined && step_xml.smxml.step[curr]._viewonly == "1") ;

				clearTimeout(timer);
			},
			500
		);
	}

	function reset() {
		//jQuery(document).find('.sticky').removeClass('sticky');
		AH.find(document, ".sticky", {
			action: "removeClass",
			actionData: "sticky"
		});

		//jQuery('.edit_step').removeAttr('disabled');
		AH.selectAll(".edit_step", "removeAttr", "disabled");

		//jQuery('.edit_step').val('');
		AH.selectAll(".edit_step").value = "";
	}

	function parseXmlAuthoring(MYXML, user_xml) {
		if (user_xml <= oldstep) {
			cdata = MYXML.smxml.step[user_xml].__cdata;
			creatingInteractive(user_xml, cdata);
		} else {
			if (MYXML.smxml.step[steps] != undefined) {
				cdata = MYXML.smxml.step[steps].__cdata;
				creatingInteractive(user_xml, cdata);
			}
		}
	}

	function creatingInteractive(user_xml, cdata, index) {
		let answer_key = cdata.match(/%{[\s\S]*?}%/gm);
		let answer_type = "";

		if (answer_key) {
			//jQuery(answer_key).each(function(i) {
			answer_key.forEach(function (data, i) {
				if (index != undefined) {
					var org_cdata = answer_array[index].__cdata;
				}
				let originalKey = answer_key[i];
				answer_type = answer_key[i].match(/\|(.*?)}%$/gm);
				answer_type = answer_type ? answer_type[0].replace(/\||}%/gm, "") : "";
				answer_type = answer_type.trim();

				if (answer_type == "" || answer_type == "c") {
					if (index != undefined) {
						createTextbox(originalKey, i, user_xml, index, org_cdata);
					} else {
						createTextbox(originalKey, i, user_xml);
					}
				} else if (answer_type == "n") {
					if (index != undefined) {
						createTextbox(originalKey, i, user_xml, index, org_cdata);
					} else {
						createTextbox(originalKey, i, user_xml);
					}
				} else if (answer_type == "e") {
					$$invalidate(5, state.isMathquill = true, state);

					if (index != undefined) {
						createMathDiv(originalKey, i, user_xml, index, org_cdata);
					} else {
						createMathDiv(originalKey, i, user_xml);
					}
				}
			});
		} else {
			return "";
		}
	}

	function getClass(index) {
		if (index == state.classChange) {
			if (state.isColor) {
				return "border_green";
			} else {
				return "border_red";
			}
		} else {
			return "";
		}
	}

	function getCorrect(id) {
		if (state.display == 1) {
			if (special_module.smans != undefined) {
				if (special_module.smans[id] != undefined) {
					if (special_module.smans[id].overall == 1) {
						return "border_green";
					} else {
						return "border_red";
					}
				}
			}
		} else {
			return "";
		}
	}

	function isSticky(index) {
		if (step_xml.smxml.step[index] != undefined) {
			if (step_xml.smxml.step[index]._sticky == 1) {
				return "sticky";
			}
		}
	}

	function toggleToolbar(value) {
		$$invalidate(5, state.showToolbar = value, state);
	}

	function moveNext() {
		if (typeof QUIZPLAYERID != "undefined") {
			var timer = setTimeout(
				function () {
					window.parentElement.autoResize(QUIZPLAYERID);
					clearTimeout(timer);
				},
				0
			);
		}

		if (step_xml.smxml.step[steps + 1] != undefined || step_xml.smxml.step[steps]._attempt == "1") {
			if (step_xml.smxml._gonext == 1) {
				nextbtnAnswer();
			} else {
				if (step_xml.smxml.step[steps]._attempt == 1) {
					if (AH.selectAll(".edit_step").length == AH.selectAll(".answer_input").length) {
						checkAns();
					} else {
						notFilled();
					}
				} else {
					nextStep();
					addSticky();
				}
			}

			if (step_xml.smxml.step.length <= step_xml.smxml.step[steps]._seq && step_xml.smxml.step[steps]._attempt != 1) {
				$$invalidate(5, state.hideNext = true, state);
			}
		} else {
			$$invalidate(5, state.hideNext = true, state);
		}
	}

	function nextStep() {
		AH.selectAll(".edit_step").forEach(_this => {
			if (_this.classList.contains("mathquill")) {
				if (_this.previousElementSibling.classList.contains("disable_div")) {
					AH.select(_this.previousElementSibling, "removeClass", "h");
				}
			} else {
				_this.disabled = true;
			}

			_this.classList.add("data-check");
		});

		optionrem = 0;

		if (step_xml.smxml.step[steps + 1] == undefined && step_xml.smxml.step[steps]._attempt == "1") {
			$$invalidate(5, state.hideNext = true, state);
			setUserAns(usans);
			overAll();
			return;
		}

		if (steps != step_xml.smxml.step.length - 1) {
			steps += 1;
			createStep();
			setUserAns(usans);
			overAll();
		} else {
			console.log("All steps are attempted");
		}
	}

	function setUserAns(user_ans) {
		if (window.inNative) {
			window.getHeight && window.getHeight();
		}

		//ISSPECIALMODULEUSERXMLCHANGE = 1; ## fixed in onUserAnsChange;
		var cond = flagxml
		? "lists=" + JSON.stringify(special_module.var_list)
		: " ";

		//jQuery("#special_module_user_xml").val("<smans><div "+ cond +" currStep='"+steps+"' userAns='"+JSON.stringify(user_ans)+"'></div></smans>");
		//AH.select("#special_module_user_xml").value = "<smans><div "+ cond +" currStep='"+steps+"' userAns='"+JSON.stringify(user_ans)+"'></div></smans>"; ## fixed in onUserAnsChange;
		resultNew.special = "<smans><div " + cond + " currStep='" + steps + "' userAns='" + JSON.stringify(user_ans) + "'></div></smans>";
	}

	function overAll() {
		let over = false;
		let userAnswers = null;
		let inNativeIsCorrect = false;

		if (step_xml.smxml.step.length == state.itemArray.length) {
			let check = true;

			for (let i in smans) {
				if (smans[i].overall != undefined) {
					if (smans[i].overall == 1) {
						over = true;
					} else {
						over = false;
					}

					check = check && over;
				}

				if (check == false) {
					//jQuery("#answer").prop("checked", false);
					AH.select("#answer").checked = false;

					resultNew.answer = false;
					inNativeIsCorrect = false;
				} else {
					//jQuery("#answer").prop("checked", true);
					AH.select("#answer").checked = true;

					resultNew.answer = true;
					inNativeIsCorrect = true;
				}
			}
		}

		//userAnswers = jQuery('#special_module_user_xml').val();
		//userAnswers = document.querySelector("#special_module_user_xml").value;
		userAnswers = resultNew.special;

		if (window.inNative) {
			window.postMessage("height___" + document.getElementsByClassName("inNativeStyle")[0].offsetHeight, "*");
			window.postMessage(JSON.stringify({ userAnswers, inNativeIsCorrect }), "*");
		}

		onUserAnsChange({
			uXml: resultNew.special,
			ans: resultNew.answer
		});
	}

	function addSticky() {
		//jQuery('[data-sticky]').addClass('sticky');
		AH.select("[data-sticky]", "addClass", "sticky");
	}

	function createTextbox(data, i, user_xml, index, org_cdata) {
		let original_data = data;
		data = data.replace(/%{|}%/g, "");
		data = data.split("|");
		let codetype = data[1] && data[1].trim() == "n" ? "1" : "";
		let corr_ans = data[0].trim();
		let csStyle = "";

		if (corr_ans.indexOf("#style#") != -1) {
			let customStyle = corr_ans.split("#style#");
			corr_ans = customStyle[0];
			csStyle = customStyle[1];
		}

		let txtWidth = [];
		let anslen = corr_ans.split(",");

		// jQuery(anslen).each(function(j){
		// 	txtWidth[j] = ((anslen[j].length)*10+30)
		// });
		anslen.forEach(function (data, j) {
			txtWidth[j] = anslen[j].length * 10 + 30;
		});

		if (index != undefined) {
			textBox(data, txtWidth, csStyle, original_data, user_xml, corr_ans, i, index, org_cdata);
		} else {
			textBox(data, txtWidth, csStyle, original_data, user_xml, corr_ans, i);
		}
	}

	function textBox(
		data,
	txtWidth,
	csStyle,
	original_data,
	user_xml,
	corr_ans,
	i,
	index,
	org_cdata
	) {
		if (index != undefined) {
			element_id = "s" + index + "_t" + i;
			element_div = "s" + index;
			let textbox = "<input type=\"text\" id=\"" + element_id + "\" class=\"fillintheblank ks nmb text-center span0 edit_st\" defaultans=\"\" haskeywords=\"\"  hasnotkeywords=\"\" keywordtype=\"\" autocomplete=\"off\" data-role=\"none\" style=\"width:" + (Math.max(...txtWidth) + 20) + "px;" + csStyle + "\" />";
			let tag = "<span id=\"" + element_div + "\" class=\"text-center filter fillelement inline-block\"><span class=\"remed_disable fh fwidth absolute h\"></span><span id=\"text\" class=\"corr_div\">" + data[0] + "</span>" + textbox + "</span>";
			let cd_ans = org_cdata.replace(original_data, tag);
			$$invalidate(2, answer_array[index].__cdata = cd_ans, answer_array);
		} else {
			if (user_xml <= oldstep) {
				var steps_counter = user_xml;
			} else {
				var steps_counter = steps;
			}

			element_id = "s" + steps_counter + "_t" + i;
			element_div = "s" + steps_counter;
			let textbox = "<input type=\"text\" id=\"" + element_id + "\" class=\"fillintheblank ks nmb text-center span0 edit_step\" defaultans=\"\" haskeywords=\"\"  hasnotkeywords=\"\" keywordtype=\"\" autocomplete=\"off\" data-role=\"none\"  style=\"width:" + (Math.max(...txtWidth) + 20) + "px;" + csStyle + "\" />";
			let tag = "<span id=\"" + element_div + "\" class=\"text-center filter fillelement inline-block\"><span class=\"remed_disable fh fwidth absolute h\"></span><span id=\"\" class=\"corr_div h-imp\">" + data[0] + "</span>" + textbox + "</span>";
			cdata = cdata.replace(original_data, tag);
			smans = createAns(smans, element_id, element_div, corr_ans);
			$$invalidate(3, special_module.smans = smans, special_module);
		}
	}

	/*function notFilled() {
	jQuery('.edit_step').each(function(i, obj) {
		let element = jQuery(this);
		if (!jQuery(this).hasClass('answer_input')) {
			element.css({border: '2px solid #ff0000'});
			var timer = setTimeout(function() {
				element.css({border: '1px solid #ccc'});
				clearTimeout(timer);
			}, 500);
		}
		return; 
	});
}*/
	function notFilled() {
		AH.selectAll(".edit_step").forEach(_element => {
			if (!_element.classList.contains("answer_input")) {
				_element.style.border = "2px solid #ff0000";

				var timer = setTimeout(
					function () {
						_element.style.border = "1px solid #ccc";
						clearTimeout(timer);
					},
					500
				);
			}

			return;
		});
	}

	function checkAns(j) {
		wrong_choice = 0;
		optionrem += 1;

		for (let i in smans) {
			for (let prop in smans[i]) {
				if (j < oldstep) {
					var curr = j;
				} else {
					var curr = steps;
				}

				//try {
				if (usans["s" + curr] && usans["s" + curr][prop] != undefined) {
					if (smans["s" + curr][prop].value == usans["s" + curr][prop].value) {
						inputHover("correct", prop);
					} else if ((/\,/g).test(smans["s" + curr][prop].value)) {
						let s_ans = smans["s" + curr][prop].value.split(",");
						let u_ans = usans["s" + curr][prop].value;

						if (s_ans.indexOf(u_ans) > -1) {
							inputHover("correct", prop);
						} else {
							wrong_choice = 1;
							inputHover("wrong", prop);
						}
					} else {
						wrong_choice = 1;
						inputHover("wrong", prop);
					}
				}
			} //} catch(e) {
			//	console.warn(e);
		} //}

		if (step_xml.smxml.step[steps]._mode == 1) {
			showAnsMod(j, "s" + j);
		} else {
			showAns(j, "s" + j);
		}
	}

	function inputHover(option, elem) {
		if (step_xml.smxml.step[steps]._mode != 1) {
			if (option == "correct") {
				//jQuery('#'+elem).removeClass('false-hover');
				AH.select("#" + elem, "removeClass", "false-hover");

				//jQuery('#'+elem).addClass('true-hover');
				AH.select("#" + elem, "addClass", "true-hover");
			} else if (option == "wrong") {
				//jQuery('#'+elem).removeClass('true-hover');
				AH.select("#" + elem, "removeClass", "true-hover");

				//jQuery('#'+elem).addClass('false-hover');
				AH.select("#" + elem, "addClass", "false-hover");
			}

			if (optionrem > 1) {
				//jQuery('#'+elem).prev().removeClass('h-imp');
				AH.select(AI.select("#" + elem).previousElementSibling, "removeClass", "h-imp");
			}

			if (step_xml.smxml._fixed != 1) {
				var timer = setTimeout(
					function () {
						//jQuery('#'+elem).prev().addClass('h-imp');
						AH.select(AI.select("#" + elem).previousElementSibling, "addClass", "h-imp");

						clearTimeout(timer);
					},
					2000
				);
			}
		}

		if (uxml) {
			//jQuery('.edit_step').each(function(i, obj) {
			AH.selectAll(".edit_step").forEach(function (obj, i) {
				//if (jQuery(this).hasClass('mathquill')) {
				if (obj.classList.contains("mathquill")) {
					//jQuery('#'+elem).prevAll('.disable_div').removeClass('h');	
					if (AH.select("#" + elem).previousElementSibling.classList.contains("disable_div")) {
						AH.select(AH.select("#" + elem).previousElementSibling, "removeClass", "h");
					}
				} else if (obj.classList.contains("answer_input")) {
					//jQuery(this).prop('disabled', 'disabled');
					obj.disabled = true; //} else if(jQuery(this).hasClass('answer_input')) {
				}

				//jQuery(this).addClass('data-check');
				obj.classList.add("data-check");
			});
		}
	}

	function showAns(j, outer) {
		var overall = 0;

		if (wrong_choice > 0) {
			$$invalidate(5, state.classChange = state.itemArray.length - 1, state);
			$$invalidate(5, state.isColor = false, state);
			overall = 0;

			if (j <= oldstep) {
				smans[outer].overall = overall;
			} else {
				smans[element_div].overall = overall;
				overAll();
			}
		} else {
			$$invalidate(5, state.classChange = state.itemArray.length - 1, state);
			$$invalidate(5, state.isColor = true, state);
			overall = 1;

			if (j <= oldstep) {
				smans[outer].overall = overall;
			} else {
				smans[element_div].overall = overall;
				nextStep();
			}
		}

		if (optionrem > 1) {
			nextStep();
		}

		if (usans[element_div] && usans[element_id] != undefined) {
			usans[element_div].optry = optionrem;
		}

		var timer = setTimeout(
			function () {
				$$invalidate(5, state.classChange = -1, state);
				clearTimeout(timer);
			},
			2500
		);
	}

	function showAnsMod(j, outer) {
		var overall = 0;

		if (wrong_choice > 0) {
			overall = 0;

			if (j <= oldstep) {
				smans[outer].overall = overall;
			} else {
				smans[element_div].overall = overall;
			}
		} else {
			overall = 1;

			if (j <= oldstep) {
				smans[outer].overall = overall;
			} else {
				smans[element_div].overall = overall;
			}
		}

		nextStep();
	}

	function handleToggle(btn) {
		if (btn == 1) {
			btntype = "correctans";
		} else if (btn == 2) {
			btntype = "yourans";
		}
	} //forceUpdate(); 

	function setReview() {
		$$invalidate(0, isReview = true);
		overAll();
		yourAnswer();

		//jQuery('.fillintheblank').prop("disabled", true);
		document.querySelectorAll(".fillintheblank").disabled = true;
	}

	function unsetReview() {
		$$invalidate(0, isReview = false);
		$$invalidate(5, state.display = -1, state);
		$$invalidate(5, state.smController = " h", state);

		//jQuery('.fillintheblank').removeClass('default-hover');
		AH.selectAll(".fillintheblank", "removeClass", "default-hover");

		//jQuery('.fillintheblank').prop("disabled", false);
		AH.selectAll(".fillintheblank").disabled = false;

		$$invalidate(5, state.main_steps = false, state);
		$$invalidate(5, state.correct_answer = true, state);

		//jQuery('.remed_disable').css('display', 'none');
		AH.selectAll(".remed_disable", "css", { display: "none" });

		if (step_xml.smxml.step[steps + 1] == undefined && step_xml.smxml.step[steps]._attempt == "1" || step_xml.smxml.step[steps + 1] == undefined && step_xml.smxml.step[steps]._viewonly == "1") {
			if (AH.selectAll(".edit_step").length == AH.selectAll(".data-check").length) {
				$$invalidate(5, state.hideNext = true, state);
			} else {
				$$invalidate(5, state.hideNext = false, state);
			}
		} else {
			$$invalidate(5, state.hideNext = false, state);
		}

		if (window.inNative) {
			window.getHeight && window.getHeight();
		}
	}

	function correctAnswer() {
		//handleToggle(1);
		$$invalidate(5, state.display = -1, state);

		//jQuery('.fillintheblank').addClass('default-hover');
		AH.selectAll(".fillintheblank", "addClass", "default-hover");

		showCorrect();
		$$invalidate(5, state.main_steps = true, state);
		$$invalidate(5, state.correct_answer = false, state);

		if (window.inNative) {
			window.getHeight && window.getHeight();
		}
	}

	function showCorrect() {
		let show_ans = step_xml.smxml.step;

		show_ans.map(function (item, index) {
			let cdata_ans = item.__cdata;
			let org_cdata = cdata_ans;
			creatingInteractive("corr_ans", org_cdata, index);
		});
	}

	function yourAnswer() {
		//handleToggle(2);
		$$invalidate(5, state.display = 1, state);

		$$invalidate(5, state.hideNext = true, state);
		$$invalidate(5, state.smController = "", state);

		//$('.fillintheblank').removeClass('default-hover');
		AH.selectAll(".fillintheblank", "removeClass", "default-hover");

		$$invalidate(5, state.main_steps = false, state);
		$$invalidate(5, state.correct_answer = true, state);

		//jQuery('.remed_disable').css('display', 'block');
		AH.selectAll(".remed_disable", "css", { display: "block" });

		if (window.inNative) {
			window.getHeight && window.getHeight();
		}
	}

	function parseSteps(steps) {
		let user_step = XMLToJSON(steps);

		if (flagxml) {
			lists = JSON.parse(user_step.smans.div._lists);
		}

		oldstep = JSON.parse(user_step.smans.div._currStep);
	}

	function nextbtnAnswer() {
		let current = `s${steps}`;

		//let textboxes = jQuery('#'+current).find('.edit_step');
		let textboxes = AH.find("#" + current, ".edit_step", "all");

		textboxes.forEach(function (item, index) {
			if (item.classList.contains("mathquill")) {
				mathquillAns(item, false);
			} else {
				//let inp_id = jQuery(item).attr('id');
				let inp_id = item.getAttribute("id");

				//let inp_val = jQuery(item).val();
				let inp_val = item.value;

				usans = createAns(usans, inp_id, current, inp_val);
			}
		});

		if (step_xml.smxml.step[steps]._attempt == 1) {
			checkAns();
		} else {
			nextStep();
			addSticky();
		}
	}

	// AH.createLink('../clsSMFill/css/fillintheblank.css');
	//To handle review toggle
	function handleReview(mode, event) {
		if (mode == "c") {
			correctAnswer();
		} else {
			yourAnswer();
		}
	}

	function createMathDiv(data, i, user_xml, index, org_cdata) {
		let original_data = data;
		data = data.replace(/%{|}%/g, "");
		data = data.split("|");
		data[0] = data[0].replace(/user Response/g, "\\MathQuillMathField");

		// let split_data = addMathquill.split("##");
		let split_data = data[0].split("##");

		let random_key = Math.floor(Math.random() * split_data.length);
		let random_option = split_data[random_key];
		let userans = random_option.replace(/MathQuillMathField{(.*?)}/g, "MathQuillMathField{}");
		let defaultans = 0;
		let anskey = random_option;
		let answer_element = anskey.replace(/\\MathQuillMathField/g, "");

		if (random_option.indexOf("MathQuillMathField") > -1) {
			anskey = random_option;
			defaultans = 1;
		}

		if (index != undefined) {
			mathQuill(userans, data, original_data, user_xml, i, random_key, defaultans, anskey, answer_element, index, org_cdata);
		} else {
			mathQuill(userans, data, original_data, user_xml, i, random_key, defaultans, anskey, answer_element);
		}
	}

	function mathQuill(
		userans,
	data,
	original_data,
	user_xml,
	i,
	random_key,
	defaultans,
	anskey,
	answer_element,
	index,
	org_cdata
	) {
		let corr_ans = data[0].trim();

		if (user_xml <= oldstep) {
			var steps_counter = user_xml;
		} else {
			var steps_counter = steps;
		}

		if (index != undefined) {
			element_id = "s0" + index + "_t" + i;
			element_div = "s0" + index;
			let ans_id = "m0" + index + "_t" + i;
			let matheq = "<span  id=\"" + element_id + "\" class=\"auto_height edit_st fillmathelement mathquill mq" + steps_counter + "\" userAnsSeq=\"" + random_key + "\" userans=\"" + userans + "\" anskey=\"" + anskey + "\" defaultans=\"" + defaultans + "\" mathtype=\"1\">" + "s" + "</span>";
			let tag = "<span id=\"" + element_div + "\" class=\"text-center filter fillelement inline-block\"><span class=\"disable_div fh fwidth absolute h\"></span><span class=\"remed_disable fh fwidth absolute h\"></span><span  id=\"" + ans_id + "\" class=\"corr_div fillmathelement mathquill mq" + steps_counter + "\" userAnsSeq=\"" + random_key + "\" anskey=\"" + anskey + "\" defaultans=\"" + defaultans + "\" mathtype=\"1\">" + answer_element + "</span>" + matheq + "</span>";
			let cd_ans = org_cdata.replace(original_data, tag);
			$$invalidate(2, answer_array[index].__cdata = cd_ans, answer_array);
		} else {
			element_id = "s" + steps_counter + "_t" + i;
			element_div = "s" + steps_counter;
			let ans_id = "m" + steps_counter + "_t" + i;
			let matheq = "<span  id=\"" + element_id + "\" class=\"auto_height edit_step fillmathelement mathquill mq" + steps_counter + "\" userAnsSeq=\"" + random_key + "\" userans=\"" + userans + "\" anskey=\"" + anskey + "\" defaultans=\"" + defaultans + "\" mathtype=\"1\">" + "s" + "</span>";
			let tag = "<span id=\"" + element_div + "\" class=\"text-center filter fillelement inline-block\"><span class=\"disable_div fh fwidth absolute h\"></span><span class=\"remed_disable fh fwidth absolute h\"></span><span  id=\"" + ans_id + "\" class=\"corr_div h-imp fillmathelement mathquill mq" + steps_counter + "\" userAnsSeq=\"" + random_key + "\" anskey=\"" + anskey + "\" defaultans=\"" + defaultans + "\" mathtype=\"1\">" + answer_element + "</span>" + matheq + "</span>";
			cdata = cdata.replace(original_data, tag);
			smans = createAns(smans, element_id, element_div, corr_ans);
			$$invalidate(3, special_module.smans = smans, special_module);
		}

		let time_interval = setInterval(
			(function () {
				if (typeof MathQuill == "function") {
					clearInterval(time_interval);
					let MQ = MathQuill.getInterface(2);

					//jQuery(".mathquill.mq"+steps_counter).each(function() {
					AH.selectAll(".mathquill.mq" + steps_counter).forEach(_this => {
						//let math_itemid  = jQuery(this).attr('id');
						let math_itemid = _this.getAttribute("id");

						//let defaultans = jQuery(this).attr('defaultans');
						let defaultans = _this.getAttribute("defaultans");

						if (defaultans == 1) {
							//let latex = jQuery(this).attr('userans');
							let latex = _this.getAttribute("userans");

							//jQuery('#'+math_itemid).text(latex);
							AH.select("#" + math_itemid).innerText = latex;
						} else {
							//jQuery('#'+math_itemid).text(jQuery(this).attr('userans'));
							AH.select("#" + math_itemid).innerText = _this.getAttribute("userans");
						}

						try {
							$$invalidate(1, fill_math[math_itemid] = MQ.StaticMath(document.getElementById(math_itemid)), fill_math);
						} catch(e) {
							console.log(e);
						}
					});
				}
			}).bind(this),
			100
		);
	}

	function mathquillAns(element, math_user) {
		let innerfield = [];
		let div_outer = jQuery(element).closest("div").find("span.fillelement").attr("id");
		let math_itemid = jQuery(element).attr("id");
		let original_latex = jQuery(element).attr("userans").trim();
		let userans;

		if (math_user == "math_user") {
			userans = original_latex;
		} else {
			let MQ = MathQuill.getInterface(2);
			let math_item = MQ.StaticMath(document.getElementById(math_itemid));

			for (let i = 0; i <= math_item.innerFields.length - 1; i++) {
				innerfield[i] = math_item.innerFields[i].latex();
			}

			let new_math_field = original_latex;

			// let mathfield = original_latex.match(/\\MathQuillMathField(.*?)}*}{4,6}|\\MathQuillMathField(.*?)}*}{3,6}|\\MathQuillMathField(.*?)}*}{2,6}|\\MathQuillMathField(.*?)}*}{1,6}/g);
			let mathfield = original_latex.match(/\\MathQuillMathField{(.*?)\}/g);

			for (let i in mathfield) {
				const create_mathfield = "\\MathQuillMathField{" + innerfield[i] + "}";

				// const new_mathfield = mathfield[i].replace(/\\MathQuillMathField(.*?)}*}{4,6}|\\MathQuillMathField(.*?)}*}{3,6}|\\MathQuillMathField(.*?)}*}{2,6}|\\MathQuillMathField(.*?)}*}{1,6}/g , create_mathfield);
				const new_mathfield = mathfield[i].replace(/\\MathQuillMathField{(.*?)\}/g, create_mathfield);

				let regex = mathfield[i];
				new_math_field = new_math_field.replace(regex, new_mathfield);
			}

			original_latex = new_math_field;
			userans = original_latex;
		}

		usans = createAns(usans, math_itemid, div_outer, userans);
		setUserAns(usans);
	}

	const writable_props = ["xml", "stopPreviewUpdate", "isReview", "uxml"];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<StepAlgoPreview> was created with unknown prop '${key}'`);
	});

	const func = value => {
		toggleToolbar(value);
	};

	const click_handler = () => setTimeout(
		function () {
			moveNext();
		},
		100
	);

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(12, xml = $$props.xml);
		if ("stopPreviewUpdate" in $$props) $$invalidate(13, stopPreviewUpdate = $$props.stopPreviewUpdate);
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("uxml" in $$props) $$invalidate(14, uxml = $$props.uxml);
	};

	$$self.$capture_state = () => ({
		writable,
		ju: jquery,
		ALGO: Step,
		l: language,
		onMount,
		afterUpdate,
		beforeUpdate,
		AH,
		XMLToJSON,
		JSONToXML,
		onUserAnsChange,
		FillInTheBlanksToolbar,
		ItemHelper,
		step_xml,
		smans,
		usans,
		element_id,
		element_div,
		cdata,
		fill_math,
		answer_array,
		btntype,
		resultNew,
		var_list,
		special_module,
		lists,
		oldstep,
		answer_arr,
		fillId,
		steps,
		wrong_choice,
		optionrem,
		flagxml,
		state,
		xml,
		stopPreviewUpdate,
		isReview,
		uxml,
		stateData,
		unsubscribe,
		timer,
		timer_next,
		setOutline,
		inputFilled,
		loadModule,
		parseUserAns,
		createStep,
		reset,
		parseXmlAuthoring,
		creatingInteractive,
		getClass,
		getCorrect,
		isSticky,
		toggleToolbar,
		moveNext,
		nextStep,
		setUserAns,
		overAll,
		addSticky,
		createTextbox,
		textBox,
		createAns,
		notFilled,
		checkAns,
		inputHover,
		showAns,
		showAnsMod,
		handleToggle,
		setReview,
		unsetReview,
		correctAnswer,
		showCorrect,
		yourAnswer,
		parseSteps,
		nextbtnAnswer,
		handleReview,
		createMathDiv,
		mathQuill,
		mathquillAns
	});

	$$self.$inject_state = $$props => {
		if ("step_xml" in $$props) step_xml = $$props.step_xml;
		if ("smans" in $$props) smans = $$props.smans;
		if ("usans" in $$props) usans = $$props.usans;
		if ("element_id" in $$props) element_id = $$props.element_id;
		if ("element_div" in $$props) element_div = $$props.element_div;
		if ("cdata" in $$props) cdata = $$props.cdata;
		if ("fill_math" in $$props) $$invalidate(1, fill_math = $$props.fill_math);
		if ("answer_array" in $$props) $$invalidate(2, answer_array = $$props.answer_array);
		if ("btntype" in $$props) btntype = $$props.btntype;
		if ("resultNew" in $$props) resultNew = $$props.resultNew;
		if ("var_list" in $$props) var_list = $$props.var_list;
		if ("special_module" in $$props) $$invalidate(3, special_module = $$props.special_module);
		if ("lists" in $$props) lists = $$props.lists;
		if ("oldstep" in $$props) oldstep = $$props.oldstep;
		if ("answer_arr" in $$props) answer_arr = $$props.answer_arr;
		if ("fillId" in $$props) $$invalidate(4, fillId = $$props.fillId);
		if ("steps" in $$props) steps = $$props.steps;
		if ("wrong_choice" in $$props) wrong_choice = $$props.wrong_choice;
		if ("optionrem" in $$props) optionrem = $$props.optionrem;
		if ("flagxml" in $$props) flagxml = $$props.flagxml;
		if ("state" in $$props) $$invalidate(5, state = $$props.state);
		if ("xml" in $$props) $$invalidate(12, xml = $$props.xml);
		if ("stopPreviewUpdate" in $$props) $$invalidate(13, stopPreviewUpdate = $$props.stopPreviewUpdate);
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("uxml" in $$props) $$invalidate(14, uxml = $$props.uxml);
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("timer" in $$props) $$invalidate(35, timer = $$props.timer);
		if ("timer_next" in $$props) $$invalidate(36, timer_next = $$props.timer_next);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isReview*/ 1) {
			 {
				if (isReview) {
					var timer = setTimeout(
						function () {
							setReview();
							clearTimeout(timer);
						},
						500
					);
				} else {
					var timer_next = setTimeout(
						function () {
							unsetReview();
							clearTimeout(timer_next);
						},
						200
					);
				}
			}
		}
	};

	return [
		isReview,
		fill_math,
		answer_array,
		special_module,
		fillId,
		state,
		isSticky,
		toggleToolbar,
		moveNext,
		setReview,
		unsetReview,
		handleReview,
		xml,
		stopPreviewUpdate,
		uxml,
		func,
		click_handler
	];
}

class StepAlgoPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-142veau-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				xml: 12,
				stopPreviewUpdate: 13,
				isReview: 0,
				uxml: 14
			},
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StepAlgoPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[12] === undefined && !("xml" in props)) {
			console_1.warn("<StepAlgoPreview> was created without expected prop 'xml'");
		}

		if (/*stopPreviewUpdate*/ ctx[13] === undefined && !("stopPreviewUpdate" in props)) {
			console_1.warn("<StepAlgoPreview> was created without expected prop 'stopPreviewUpdate'");
		}

		if (/*isReview*/ ctx[0] === undefined && !("isReview" in props)) {
			console_1.warn("<StepAlgoPreview> was created without expected prop 'isReview'");
		}

		if (/*uxml*/ ctx[14] === undefined && !("uxml" in props)) {
			console_1.warn("<StepAlgoPreview> was created without expected prop 'uxml'");
		}
	}

	get xml() {
		throw new Error("<StepAlgoPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<StepAlgoPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stopPreviewUpdate() {
		throw new Error("<StepAlgoPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopPreviewUpdate(value) {
		throw new Error("<StepAlgoPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isReview() {
		throw new Error("<StepAlgoPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<StepAlgoPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<StepAlgoPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<StepAlgoPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMMixedItem/ItemPluginPreview.svelte generated by Svelte v3.29.0 */
const file$1 = "clsSMMixedItem/ItemPluginPreview.svelte";

function create_fragment$1(ctx) {
	let main;
	let stepalgopreview;
	let current;

	stepalgopreview = new StepAlgoPreview({
			props: {
				xml: /*xml*/ ctx[0],
				remedStatus: /*remedStatus*/ ctx[1],
				showAns: /*showAns*/ ctx[2],
				stopPreviewUpdate: /*stopPreviewUpdate*/ ctx[3],
				isReview: /*isReview*/ ctx[4]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			main = element("main");
			create_component(stepalgopreview.$$.fragment);
			add_location(main, file$1, 13, 0, 260);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(stepalgopreview, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const stepalgopreview_changes = {};
			if (dirty & /*xml*/ 1) stepalgopreview_changes.xml = /*xml*/ ctx[0];
			if (dirty & /*remedStatus*/ 2) stepalgopreview_changes.remedStatus = /*remedStatus*/ ctx[1];
			if (dirty & /*showAns*/ 4) stepalgopreview_changes.showAns = /*showAns*/ ctx[2];
			if (dirty & /*stopPreviewUpdate*/ 8) stepalgopreview_changes.stopPreviewUpdate = /*stopPreviewUpdate*/ ctx[3];
			if (dirty & /*isReview*/ 16) stepalgopreview_changes.isReview = /*isReview*/ ctx[4];
			stepalgopreview.$set(stepalgopreview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(stepalgopreview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(stepalgopreview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(stepalgopreview);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ItemPluginPreview", slots, []);
	let { xml } = $$props;
	let { remedStatus } = $$props;
	let { showAns } = $$props;
	let { stopPreviewUpdate } = $$props;
	let { editorState } = $$props;
	let { isReview } = $$props;

	const writable_props = [
		"xml",
		"remedStatus",
		"showAns",
		"stopPreviewUpdate",
		"editorState",
		"isReview"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ItemPluginPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("remedStatus" in $$props) $$invalidate(1, remedStatus = $$props.remedStatus);
		if ("showAns" in $$props) $$invalidate(2, showAns = $$props.showAns);
		if ("stopPreviewUpdate" in $$props) $$invalidate(3, stopPreviewUpdate = $$props.stopPreviewUpdate);
		if ("editorState" in $$props) $$invalidate(5, editorState = $$props.editorState);
		if ("isReview" in $$props) $$invalidate(4, isReview = $$props.isReview);
	};

	$$self.$capture_state = () => ({
		StepAlgoPreview,
		xml,
		remedStatus,
		showAns,
		stopPreviewUpdate,
		editorState,
		isReview
	});

	$$self.$inject_state = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("remedStatus" in $$props) $$invalidate(1, remedStatus = $$props.remedStatus);
		if ("showAns" in $$props) $$invalidate(2, showAns = $$props.showAns);
		if ("stopPreviewUpdate" in $$props) $$invalidate(3, stopPreviewUpdate = $$props.stopPreviewUpdate);
		if ("editorState" in $$props) $$invalidate(5, editorState = $$props.editorState);
		if ("isReview" in $$props) $$invalidate(4, isReview = $$props.isReview);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [xml, remedStatus, showAns, stopPreviewUpdate, isReview, editorState];
}

class ItemPluginPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			xml: 0,
			remedStatus: 1,
			showAns: 2,
			stopPreviewUpdate: 3,
			editorState: 5,
			isReview: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ItemPluginPreview",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[0] === undefined && !("xml" in props)) {
			console.warn("<ItemPluginPreview> was created without expected prop 'xml'");
		}

		if (/*remedStatus*/ ctx[1] === undefined && !("remedStatus" in props)) {
			console.warn("<ItemPluginPreview> was created without expected prop 'remedStatus'");
		}

		if (/*showAns*/ ctx[2] === undefined && !("showAns" in props)) {
			console.warn("<ItemPluginPreview> was created without expected prop 'showAns'");
		}

		if (/*stopPreviewUpdate*/ ctx[3] === undefined && !("stopPreviewUpdate" in props)) {
			console.warn("<ItemPluginPreview> was created without expected prop 'stopPreviewUpdate'");
		}

		if (/*editorState*/ ctx[5] === undefined && !("editorState" in props)) {
			console.warn("<ItemPluginPreview> was created without expected prop 'editorState'");
		}

		if (/*isReview*/ ctx[4] === undefined && !("isReview" in props)) {
			console.warn("<ItemPluginPreview> was created without expected prop 'isReview'");
		}
	}

	get xml() {
		throw new Error("<ItemPluginPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ItemPluginPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get remedStatus() {
		throw new Error("<ItemPluginPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set remedStatus(value) {
		throw new Error("<ItemPluginPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showAns() {
		throw new Error("<ItemPluginPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<ItemPluginPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stopPreviewUpdate() {
		throw new Error("<ItemPluginPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopPreviewUpdate(value) {
		throw new Error("<ItemPluginPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ItemPluginPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ItemPluginPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isReview() {
		throw new Error("<ItemPluginPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<ItemPluginPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ItemPluginPreview;
//# sourceMappingURL=ItemPluginPreview-a8a5b3a5.js.map
