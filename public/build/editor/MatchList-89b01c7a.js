
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { a5 as Lang, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, V as Checkbox, C as validate_each_argument, O as Dialog, P as binding_callbacks, Q as bind, v as validate_slots, L as beforeUpdate, X as XMLToJSON, o as onMount, a7 as afterUpdate, w as writable, a8 as Loader, A as AH$1, M as JSONToXML, U as Button, z as empty, n as insert_dev, x as detach_dev, f as space, c as create_component, h as text, j as attr_dev, k as add_location, m as mount_component, q as listen_dev, G as prop_dev, W as add_flush_callback, t as transition_in, a as transition_out, b as destroy_component, K as destroy_each, H as run_all, $ as null_to_empty, l as set_style, B as noop, F as set_data_dev } from './main-ad414885.js';

/**
 *  Filename    : ValidateItems.js
 *  @Author     : Saquib Ajaz <saquib.ajaz@ucertify.com>
 *  @Version    : 1.0
 *  Last update : 29 May 2020
 *  Last updated by: Dharmendra Mishra
 */

const smVal = {
    err: {
        q9: Lang.max_error,
        q27:
            "You have exceeded the module limit. You can only create 6 statement nodes and 4 option nodes.",
        q6_advance: Lang.max_row_col_error
    },

    processError: function(err, msg) {
        var smErr = {
        error: err,
        message: msg
        };
        return smErr;
    },
  //@TOOD:? @pradeep item-refactor
    validate: function(type, subtype, content_icon) {
        if (type == "q" || type == "u") {
        switch (subtype) {
            case 9:
            return this.validate9(content_icon);
            case 14:
            return this.validate14(content_icon);
            case 6:
            return this.validate6(content_icon);
            case 26:
            return this.validate26(content_icon);
            case 27:
            return this.validate27(content_icon);
        }
        }
    },

    validate9: function(icon) {
        var len = AH.selectAll("#fillmain [id^=elem]").length;
        if (len > 6) {
        return this.processError(true, this.err.q9);
        } else {
        return this.processError(false, "valid");
        }
    },

    validate6: function(icon) {
         //var len = jQuery("#choose").find("#sortable li").length;
    let len = AH.selectAll("#choose #sortable li").length;
    console.log("len =>"+len);
    if (len > 5) {
      return this.processError(true, this.err.q9);
    } else {
      return this.processError(false, "valid");
    }
    },

    validate26: function(icon) {
         //var len = jQuery("#mytable >tbody >tr").length;
        let len = AH.selectAll("#mytable >tbody >tr").length;
        //var len1 = jQuery("#mytable >thead >tr >th").length;
        let len1 = AH.selectAll("#mytable >thead >tr >th").length;
        if (len > 5 || len1 > 6) {
        return this.processError(true, this.err.q6_advance);
        } else {
        return this.processError(false, "valid");
        }
    },

    validate14: function(icon) {
        var len1 =AI.selectAll("#matchListArea [class*='textarea_1']").length;

        var len2 = AI.selectAll("#matchListArea [class*='textarea_2']").length;
        if (len1 > 6 || len2 > 6) {
        return this.processError(true, this.err.q9);
        } else {
        return this.processError(false, "valid");
        }
    },
    validate27: function(icon) {
        let len1 = AH.selectAll("#choicemain .testmode_table tbody tr").length;
        //var len2 = jQuery("#choicemain").find(".testmode_table thead tr th").length;
        let len2 = AH.selectAll("#choicemain .testmode_table thead tr th").length;
        if (len1 > 6 || len2 > 5) {
          return this.processError(true, this.err.q27);
        } else {
          return this.processError(false, "valid");
        }
    }
};

/* clsSMMatchList/MatchList.svelte generated by Svelte v3.29.0 */

const { document: document_1 } = globals;
const file = "clsSMMatchList/MatchList.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1kpz00h-style";
	style.textContent = ".colorgray.svelte-1kpz00h{width:56px;background-color:rgb(255, 206, 206)}.colorgray1.svelte-1kpz00h{width:74px;background:#E0E0E0}.font24.svelte-1kpz00h{font-size:22px !important;margin-right:5px}.add_button.svelte-1kpz00h{height:31px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWF0Y2hMaXN0LnN2ZWx0ZSIsInNvdXJjZXMiOlsiTWF0Y2hMaXN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbjwhLS0gXG4qICBGaWxlIE5hbWUgICA6IE1hdGNoTGlzdC5zdmVsdGVcbiogIERlc2NyaXB0aW9uIDogTWF0Y2ggdGhlIGxpc3Qgb3B0aW9ucyBhbmQgdHlwZVxuKiAgQXV0aG9yICAgICAgOiBTdW5kYXJhbSBUcmlwYXRoaVxuKiAgVmVyc2lvbiAgICAgOiAxLjBcbiogIFBhY2thZ2UgICAgIDogcGUtaXRlbXNcbiogIExhc3QgdXBkYXRlIDogIC0tPlxuXG48c2NyaXB0PiBcblx0XG4gICAgaW1wb3J0IHtvbk1vdW50LGFmdGVyVXBkYXRlLGJlZm9yZVVwZGF0ZX0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHt3cml0YWJsZX0gZnJvbSAnc3ZlbHRlL3N0b3JlJztcblx0aW1wb3J0IExvYWRlciBmcm9tICcuLi9oZWxwZXIvTG9hZGVyLnN2ZWx0ZSc7XG5cdGltcG9ydCB7QUgsWE1MVG9KU09OLEpTT05Ub1hNTH0gZnJvbSBcIi4uL2hlbHBlci9IZWxwZXJBSS5zdmVsdGVcIjtcbiAgICBpbXBvcnQge3NtVmFsfSBmcm9tICcuL2xpYi9WYWxpZGF0ZUl0ZW1zJztcbiAgICBpbXBvcnQgbCBmcm9tICcuLi9zcmMvbGlicy9MYW5nLmpzJ1xuICAgIGltcG9ydCB7IEJ1dHRvbiwgRGlhbG9nLCBDaGVja2JveCB9IGZyb20gJ3N2ZWx0ZS1tdWkvc3JjJztcblxuXG5cdC8vLy9leHBvcnRpbmcgdmFpYWJsZXNcblx0ZXhwb3J0IGxldCBlZGl0b3JTdGF0ZTtcbiAgICBleHBvcnQgbGV0IHhtbDtcbiAgICBleHBvcnQgbGV0IGdldENoaWxkWG1sO1xuICAgIGV4cG9ydCBsZXQgc21WYWxpZGF0ZTtcblxuXG4gICAgLy8gdmFyaWFibGVzIGRlY2xyYXRpb25cbiAgICBsZXQgdGltZXIgPSB7fTtcbiAgICBsZXQgdGVtcGRhdGExID0gW107XG4gICAgbGV0IHRlbXBkYXRhMiA9IFtdO1xuICAgIGxldCBsaXN0aGVhZGluZzEgPSBcIlwiO1xuICAgIGxldCBsaXN0aGVhZGluZzIgPSBcIlwiO1xuICAgIGxldCBtdWx0aW1hdGNoID0gXCJcIjtcbiAgICBsZXQgbGlzdDEgPSBbXTtcbiAgICBsZXQgbGlzdDIgPSBbXTtcbiAgICBsZXQgbG9jYWxDRGF0YSA9IFtdO1xuICAgIGxldCBjZGF0YSA9IFwiXCI7XG4gICAgbGV0IGVkaXRGbGFnID0gZmFsc2U7XG4gICAgbGV0IGVkaXRWYWx1ZSA9IFwiXCI7XG4gICAgbGV0IGNsc25hbWUgPSBcIlwiO1xuICAgIGxldCBjb2x1bW5pZCA9IFwiXCI7XG4gICAgbGV0IGNvbHVtbm5hbWUgPSBcIlwiO1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgcm93ID0gMDtcbiAgICBsZXQgc3RhdGUgPSB7fTtcblxuLy8vLy8vIEhvbGRpbmcgc3RhdGVzIGluIHdyaXRhYmxlIGZvcm0gLy8vLy9cblxuICAgIGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7XG4gICAgICAgIHNuYWNrYmFjayAgICAgICAgICAgICAgIDpmYWxzZSxcbiAgICAgICAgeG1sICAgICAgICAgICAgICAgICAgICAgOlwiXCIsXG4gICAgICAgIGxpc3RoZWFkaW5nMSAgICAgICAgICAgIDpcIlwiLFxuICAgICAgICBsaXN0aGVhZGluZzIgICAgICAgICAgICA6XCJcIixcbiAgICAgICAgbXVsdGltYXRjaCAgICAgICAgICAgICAgOlwiXCIsXG4gICAgICAgIG9wZW5SZXNwb25zZURpYWxvZyAgICAgIDpmYWxzZSxcbiAgICAgICAgc2V0dGluZyAgICAgICAgICAgICAgICAgOjEsXG4gICAgICAgIG9wZW5JbWFnZURpYWxvZyAgICAgICAgIDpmYWxzZSxcbiAgICAgICAgaW1hZ2VDbGFzcyAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICBtYXhub2RlICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIGNsbmFtZSAgICAgICAgICAgICAgICAgIDpcIlwiLFxuICAgICAgICBhbmNob3JFbCAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIGRyYWdfbW9kZSAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIG9wZW5EZWxldGVEaWFsb2cgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHJvd19pZCAgICAgICAgICAgICAgICAgIDpcIlwiLFxuXHRcdGRpclx0XHRcdFx0XHRcdDogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RhdGVEYXRhLnN1YnNjcmliZSgoaXRlbXMpID0+IHtcbiAgICAgICAgc3RhdGUgPSBpdGVtcztcbiAgICB9KVxuXG5cbiAgICAgICAgXG4gICAgYmVmb3JlVXBkYXRlKCgpPT57XG5cdFx0XG4gICAgICAgIGlmKCBzdGF0ZS54bWwhPSB4bWwgKSB7XG4gICAgICAgICAgICBzdGF0ZS54bWwgPSB4bWw7XG5cdFx0XHR0ZW1wZGF0YTEgPSBbXTtcbiAgICBcdFx0dGVtcGRhdGEyID0gW107XG5cdFx0XHRcblx0XHRcdFxuICAgICAgICAgICAgdmFyIG5ld1htbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xuICAgICAgICAgICAgcGFyc2VYTUxBdXRob3JpbmcobmV3WG1sKTtcbiAgICAgICAgIH1cbiAgICB9KVxuXG5cdGZ1bmN0aW9uIGxvYWRMaWJzKCkge1xuICAgICAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICAgICAgcHJlbG9hZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICAgIGFzOiAnc3R5bGUnXG4gICAgICAgIH1cbiAgICAgICAgQUguY3JlYXRlTGluayh0aGVtZVVybCArICdwZS1pdGVtcy9zdmVsdGUvY2xzU01NYXRjaExpc3QvY3NzL21hdGNobGlzdEF1dGguY3NzJywgY29uZmlnKTtcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpPT57XG5cdFx0bG9hZExpYnMoKTtcbiAgICAgICAgLy8gcHJldmVudGluZyB0aGUgZW50ZXIga2V5IGluIHRoZSB0ZXh0YXJlYVxuICAgICAgICBBSS5saXN0ZW4oZG9jdW1lbnQsJ2tleWRvd24nLCd0ZXh0YXJlYScsZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmKGV2ZW50LmtleUNvZGUgPT0gMTMpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXHRcdH0pO1xuXHRcdC8vIGpRdWVyeShkb2N1bWVudCkub2ZmKFwia2V5ZG93blwiLFwidGV4dGFyZWFcIikub24oXCJrZXlkb3duXCIsIFwidGV4dGFyZWFcIiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBcdGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7XG5cdFx0Ly8gXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cdFx0Ly8gZm9yIGRlbGV0aW5nIHRoZSBpbWFnZVxuXHRcdEFJLmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcuaW1hZ2VfZGVsZXRlJywgKF9lbGUpID0+IHtcblx0XHRcdGxldCBvbGRJbWFnZSA9IEFJLmZpbmQoX2VsZS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQsJ3RleHRhcmVhJykudmFsdWU7XG5cdFx0XHRsZXQgbmV3VmFsdWUgPSBzdGF0ZS54bWwucmVwbGFjZShvbGRJbWFnZSwgXCJpbnNlcnQgdmFsdWVcIik7XG5cdFx0XHRnZXRDaGlsZFhtbChuZXdWYWx1ZSk7XG5cdFx0fSlcblxuXG5cdFx0Ly8galF1ZXJ5KCcjbWF0Y2hMaXN0QXJlYScpLnRvb2x0aXAoe1xuXHRcdC8vIFx0c2VsZWN0b3I6ICdbZGF0YS10b2dnbGU9XCJ0b29sdGlwXCJdJ1xuXHRcdC8vIH0pO1xuXHRcdFxuXHRcdFxuXHRcdEFJLmxpc3Rlbihkb2N1bWVudCwnbW91c2V1cCcsJy51aS1kcm9wcGFibGUnLGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5tYXRjaGxpc3QtZGVsZXRlXCIpLmZvckVhY2goKF9lbG0pID0+IHtcblx0XHRcdFx0XHRfZWxtLmNsYXNzTGlzdC5hZGQoXCJ0dHNfbm9zcGVha1wiKTtcblx0XHRcdFx0fSlcblx0XHRcdH0pXG5cdFx0fSlcblx0XHQvL2pRdWVyeSgnLmFsZ29fZGl2IHNwYW4nKS5jc3MoJ2NvbG9yJywnIzMzMycpO1xuXHRcdGxldCBhbGdvX2Rpdl9sZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFsZ29fZGl2IHNwYW5cIik7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IGFsZ29fZGl2X2xlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0YWxnb19kaXZfbGVuW2ldLnN0eWxlLmNvbG9yID0gXCIjMzMzXCI7XG5cdFx0fVxuXG5cdFx0Ly8galF1ZXJ5KGRvY3VtZW50KS5vbigna2V5ZG93bicsICcuZGVsZXRlX21hdGNoX25vZGUsIC5kZWxldGVfbWF0Y2hfbm9kZV9hdXRoJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBcdGlmICgoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC53aGljaCA9PSAxMykpIHtcblx0XHQvLyBcdC8vIGNsaWNrIHRoZSBlbGVtZW50IHdoaWNoIGN1cnJlbnRseSBnZXQgdGhlIGZvY3VzIGFuZCBlbnRlciBrZXkgaXMgZG93blxuXHRcdC8vIFx0alF1ZXJ5KHRoaXMpLnRyaWdnZXIoJ2NsaWNrJyk7XG5cdFx0Ly8gXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH0pO1xuXHRcdEFJLmxpc3Rlbihkb2N1bWVudCwna2V5ZG93bicsJy5kZWxldGVfbWF0Y2hfbm9kZSwgLmRlbGV0ZV9tYXRjaF9ub2RlX2F1dGgnLCBmdW5jdGlvbihkYXRhLGV2ZW50KSB7XG5cdFx0XHRpZigoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC53aGljaCA9PSAxMykpIHtcblx0XHRcdFx0Ly8gTmVlZCB0aSBmaXggb25lIG1vcmUgbGluZSBoZXJlLi4uLlxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0pXG4gICAgfSlcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgdGhlIHhtbFxuXHRmdW5jdGlvbiBwYXJzZVhNTEF1dGhvcmluZyhRWE1MKSB7XG5cdFx0bGlzdDEgPSBbXTtcblx0XHRsaXN0MiA9IFtdO1xuXHRcdGxvY2FsQ0RhdGEgPSBbXTtcblx0XHQvLyBzZXR0aW5nIHRoZSBzdGF0ZSB3aXRoIHRoZSB2YWx1ZSBpbiB0aGUgeG1sXG5cdFx0c3RhdGUubGlzdGhlYWRpbmcxID0gUVhNTC5zbXhtbC5tYXRjaGxpc3QuX2xpc3RoZWFkaW5nMTtcblx0XHRzdGF0ZS5saXN0aGVhZGluZzIgPSBRWE1MLnNteG1sLm1hdGNobGlzdC5fbGlzdGhlYWRpbmcyO1xuXHRcdHN0YXRlLm11bHRpbWF0Y2ggPSBRWE1MLnNteG1sLm1hdGNobGlzdC5fbXVsdGltYXRjaDtcblx0XHRzdGF0ZS5kcmFnX21vZGUgPSAoUVhNTC5zbXhtbC5tYXRjaGxpc3QuX211bHRpbWF0Y2ggPT0gMikgPyB0cnVlIDogZmFsc2Vcblx0XHRcblx0XHQvLyBzdG9yaW5nIHRoZSB2YWx1ZXMgaW4gbXVsdGltYXRjaCBhbmQgY2RhdGFcblx0XHRtdWx0aW1hdGNoID0gUVhNTC5zbXhtbC5tYXRjaGxpc3QuX211bHRpbWF0Y2g7XG5cdFx0Y2RhdGEgPSBRWE1MLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhO1xuXG5cdFx0Ly8gY2hlY2tpbmcgZm9yIGlmIGlzX2FsZ28gaXMgZGVmaW5lZCBpbiB4bWwgb3Igbm90XG5cdFx0aWYgKFFYTUwuc214bWwubWF0Y2hsaXN0Ll9pc19hbGdvKSB7XG5cdFx0XHQvLyBpZiBpc19hbGdvIGlzIHRydWUgdGhlbiBwdXQgdGhlIHZhbHVlIGluIGlzYWxnbyBhcyB0cnVlIGVsc2UgZmFsc2Vcblx0XHRcdHN0YXRlLmlzYWxnbyA9IChRWE1MLnNteG1sLm1hdGNobGlzdC5faXNfYWxnbyA9PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIGlzX2FsZ28gaXMgbm90IGRlZmluZWQgbWVhbnMgaXRzIHZhbHVlIHdpbGwgYmUgZmFsc2Vcblx0XHRcdHN0YXRlLmlzYWxnbyA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGZvciB0aGUgbWF4aW11bSBubyBvZiBub2RlIGkuZSwgbWF4X25vZGVcblx0XHRpZiAoUVhNTC5zbXhtbC5tYXRjaGxpc3QuX21heF9ub2RlKSB7XG5cdFx0XHR2YXIgbnVtID0gTnVtYmVyKFFYTUwuc214bWwubWF0Y2hsaXN0Ll9tYXhfbm9kZSk7XG5cdFx0XHRzdGF0ZS5tYXhub2RlID0gKCBudW0gPiAwID8gbnVtIDogMCApXG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlLm1heG5vZGUgPSAnJztcblx0XHR9XG5cdFx0Ly8gc3BsaXR0aW5nIHRoZSBjZGF0YSB3aXRoIG5ldyBsaW5lXG5cdFx0Y2RhdGEgPSBjZGF0YS5zcGxpdChcIlxcblwiKTtcblxuXHRcdFxuXHRcdC8vIHRyYXZlcnNpbmcgdGhyb3VnaCB0aGUgY2RhdGFcblx0XHQvLyBqUXVlcnkoY2RhdGEpLmVhY2goIGZ1bmN0aW9uIChpKSB7XG5cdFx0Y2RhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhLGkpIHtcblx0XHRcdGlmIChjZGF0YVtpXS50cmltKCkgIT0gXCJcIikge1xuXHRcdFx0XHQvLyBGaW5kaW5nIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGJyYWNrZXRzIGluIGNkYXRhXG5cdFx0XHRcdGlmIChjZGF0YVtpXS5pbmRleE9mKFwiW1wiKSA+PSAwICYmIGNkYXRhW2ldLmluZGV4T2YoXCJdXCIpID49IDApIHtcblx0XHRcdFx0XHQvLyBleHRyYWN0aW5nIHZhbHVlIDEgYnkgcmVwbGNpbmcgdGhlIGNvbnRlbnQgc3RhcnQgd2l0aCBbIGFuZCBlbmQgd2l0aCBdXG5cdFx0XHRcdFx0bGV0IHZhbHVlMSA9IGNkYXRhW2ldLnJlcGxhY2UoY2RhdGFbaV0ubWF0Y2goL1xcWyguKj8pXFxdL2cpLFwiXCIpLnJlcGxhY2UoL15cXHMrL2csIFwiXCIpO1xuXHRcdFx0XHRcdGxldCB2YWx1ZTIgPSBjZGF0YVtpXS5tYXRjaCgvXFxbKC4qPylcXF0vZylbMF07XG5cdFx0XHRcdFx0Ly8gZmluZGluZyB0aGUgdmFsdWUgMiBieSBmaW5kaW5nIHRoZSB0ZXh0IHN0YXJ0IHdpdGggWyBhbmQgZW5kIHdpdGggXSBhbmQgdGhlIHJlbW92aW5nIHRoZXNlIGJyYWNrZXRzXG5cdFx0XHRcdFx0dmFsdWUyID0gdmFsdWUyLnJlcGxhY2UoXCJbXCIsXCJcIikucmVwbGFjZShcIl1cIixcIlwiKTtcblx0XHRcdFx0XHQvLyBzdG9yZSB0aGUgdmFsdWUgaW4gdGhlIGxvY2FsQ0RhdGFcblx0XHRcdFx0XHQvLyBsb2NhbENEYXRhLnB1c2goe1xuXHRcdFx0XHRcdC8vIFx0dmFsdWUxOiB2YWx1ZTEsXG5cdFx0XHRcdFx0Ly8gXHR2YWx1ZTI6IHZhbHVlMixcblx0XHRcdFx0XHQvLyBcdGlkOmlcblx0XHRcdFx0XHQvLyB9KTtcblx0XHRcdFx0XHRsb2NhbENEYXRhID0gW1xuXHRcdFx0XHRcdFx0Li4ubG9jYWxDRGF0YSwge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZTE6IHZhbHVlMSxcblx0XHRcdFx0XHRcdFx0dmFsdWUyOiB2YWx1ZTIsXG5cdFx0XHRcdFx0XHRcdGlkOmlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0bGlzdDJbaV0gPSBjZGF0YVtpXS5yZXBsYWNlKGNkYXRhW2ldLm1hdGNoKC9cXFsoLio/KVxcXS9nKSxcIlwiKS5yZXBsYWNlKC9eXFxzKy9nLCBcIlwiKTsgLy8gdmFsdWUgMVxuXHRcdFx0XHRcdGxpc3QxW2ldID0gY2RhdGFbaV0ubWF0Y2goL1xcWyguKj8pXFxdL2cpWzBdOyBcblx0XHRcdFx0XHRsaXN0MVtpXSA9IGxpc3QxW2ldLnJlcGxhY2UoXCJbXCIsXCJcIikucmVwbGFjZShcIl1cIixcIlwiKTsgLy8gdmFsdWUgMlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVyck1lc3NhZ2UgPSBcIkJyYWNrZXQgaXMgTWlzc2luZyBpbiBsaW5lIG5vLiBcIitpO1xuXHRcdFx0XHRcdHN0YXRlLnNuYWNrYmFjayA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHRcblx0XHQvL2ZvcmNlVXBkYXRlKCk7XG4gICAgfSBcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGNhbGxzICYgdXBkYXRlZCB0aGUgeG1sIHdoZW5ldmVyIHRoZXJlIGlzIGNoYW5nZSBpbiBsaXN0IGhlYWRpbmcgdGV4dGJveCAmIG1heG5vZGUgdGV4dGJveFxuXHRmdW5jdGlvbiB1cGRhdGVYbWwoZSkge1xuXHRcdC8vIHVwZGF0aW5nIHRoZSB4bWwgdG8ganNvbiBieSBYTUxUb0pTT04gZnVuY3Rpb25cblx0XHR2YXIgbmV3WG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XG5cdFx0Ly8gaWYgdGhlcmUgaXMgY2hhbmdlIGluIGxpc3RoZWFkaW5nIDFcblx0XHRpZiAoZS50YXJnZXQuaWQgPT0gXCJsaXN0aGVhZGluZzFcIikge1xuXHRcdFx0c3RhdGUubGlzdGhlYWRpbmcxID0gZS50YXJnZXQudmFsdWU7XG5cdFx0fSBlbHNlIGlmIChlLnRhcmdldC5pZCA9PSBcImxpc3RoZWFkaW5nMlwiKSB7XG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBjaGFuZ2UgaW4gbGlzdGhlYWRpbmcgMlxuXHRcdFx0c3RhdGUubGlzdGhlYWRpbmcyID0gZS50YXJnZXQudmFsdWU7XG5cdFx0fSBlbHNlIGlmIChlLnRhcmdldC5pZCA9PSBcIm1heG5vZGVcIikge1xuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgY2hhbmdlIGluIG1heG5vZGVcblx0XHRcdGlmIChpc05hTihlLnRhcmdldC52YWx1ZSkpIHtcblx0XHRcdFx0QUkuc2hvd21zZyhcblx0XHRcdFx0XHQnRXJyb3IgTWVzc2FnZScsXG5cdFx0XHRcdFx0J1BsZWFzZSBlbnRlciBudW1lcmljIHZhbHVlJyxcblx0XHRcdFx0XHQnZXJyb3InXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGUudGFyZ2V0LnZhbHVlID4gNikge1xuXHRcdFx0XHRBSS5zaG93bXNnKCdQbGVhc2UgaW5zZXJ0IHZhbHVlIGJldHdlZW4gMSB0byA2Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGF0ZS5tYXhub2RlID0gZS50YXJnZXQudmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRpbWVyWyd1cGRhdGVYTWwxJ10gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gdXBkYXRpbmcgdGhlIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHRcdG5ld1htbC5zbXhtbC5tYXRjaGxpc3QuX2xpc3RoZWFkaW5nMSA9IHN0YXRlLmxpc3RoZWFkaW5nMTtcblx0XHRcdG5ld1htbC5zbXhtbC5tYXRjaGxpc3QuX2xpc3RoZWFkaW5nMiA9IHN0YXRlLmxpc3RoZWFkaW5nMjtcblx0XHRcdGlmIChzdGF0ZS5tYXhub2RlKSB7XG5cdFx0XHRcdG5ld1htbC5zbXhtbC5tYXRjaGxpc3QuX21heF9ub2RlID0gc3RhdGUubWF4bm9kZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGRlbGV0aW5nIG1heF9ub2RlIGlmIGl0IGlzIG5vdCBpbiB1c2Vcblx0XHRcdFx0ZGVsZXRlIG5ld1htbC5zbXhtbC5tYXRjaGxpc3QuX21heF9ub2RlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGFuZCBzdG9yZSB0aGUgeG1sIFxuXHRcdFx0Z2V0Q2hpbGRYbWwoSlNPTlRvWE1MKG5ld1htbCkpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyWyd1cGRhdGVYTWwxJ10pO1xuXHRcdH0sIDIwMCk7XG4gICAgfVxuICAgIFxuICAgIC8vIHdoZW5ldmVyIGFkZCBidXR0b24gaXMgY2xpY2tlZFxuXHRmdW5jdGlvbiB1cGRhdGVDRGF0YSgpIHtcblx0XHQvL3ZhciByb3dJbkZpcnN0Q29sdW1uID0galF1ZXJ5KFwiI21hdGNoTGlzdEFyZWEgW2NsYXNzKj0ndGV4dGFyZWFfMSddXCIpLmxlbmd0aDtcblx0XHR2YXIgcm93SW5GaXJzdENvbHVtbiA9IEFJLnNlbGVjdEFsbChcIiNtYXRjaExpc3RBcmVhIFtjbGFzcyo9J3RleHRhcmVhXzEnXVwiKS5sZW5ndGg7XG5cdFx0XG5cdFx0Ly92YXIgcm93SW5TZWNvbmZDb2x1bW4gPSBqUXVlcnkoXCIjbWF0Y2hMaXN0QXJlYSBbY2xhc3MqPSd0ZXh0YXJlYV8yJ11cIikubGVuZ3RoO1xuXHRcdHZhciByb3dJblNlY29uZkNvbHVtbiA9IEFJLnNlbGVjdEFsbChcIiNtYXRjaExpc3RBcmVhIFtjbGFzcyo9J3RleHRhcmVhXzInXVwiKS5sZW5ndGg7XG5cdFx0aWYgKHJvd0luRmlyc3RDb2x1bW4gPiAxOSB8fCByb3dJblNlY29uZkNvbHVtbiA+IDE5KSB7XG5cdFx0XHRBSSAmJiBBSS5zaG93bXNnKCdNYXhpbXVtIHBvc3NpYmxlIG9wdGlvbnMgYXJlIDIwJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJvdysrO1xuXHRcdFx0Ly8gY29udmVydGluZyB0aGUgeG1sIGluIGpzb24gdXNpbmcgdGhlIGZ1bmN0aW9uIFhNTFRvSlNPTiBcblx0XHRcdGxldCB4bWwgPSBYTUxUb0pTT04oc3RhdGUueG1sKTtcblx0XHRcdC8vIHVwZGF0aW5nIHRoZSBjZGF0YVxuXHRcdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhID0geG1sLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhICsgYFxcbk9wdGlvbiAyIFZhbHVlIG9mIHJvdyAke3Jvd31bT3B0aW9uIDEgdmFsdWUgb2Ygcm93ICR7cm93fV1cXG5gO1xuXHRcdFx0Ly8gdXBkYXRlIGFuZCBzdG9yZSB0aGUgeG1sIFxuXHRcdFx0Z2V0Q2hpbGRYbWwoSlNPTlRvWE1MKHhtbCkpO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVyciA9IHNtVmFsLnZhbGlkYXRlKGVkaXRvclN0YXRlLmNvbnRlbnRfdHlwZSwgZWRpdG9yU3RhdGUuaXRlbSwgZWRpdG9yU3RhdGUuY29udGVudF9pY29uKTtcblx0XHRcdFx0c21WYWxpZGF0ZShlcnIpO1xuXHRcdFx0fSwgMjAwKTtcblx0XHR9IFxuXHR9XG5cdFxuXHRmdW5jdGlvbiBvcGVuTWVkaWFEaWFsb2coKSB7XG5cdFx0Ly9qUXVlcnkoXCIjbW9kYWwtbWVkaWEtdXBsb2FkXCIpLm1vZGFsKFwic2hvd1wiKTtcblx0XHRBSC5nZXRCUyhcIiNtb2RhbC1tZWRpYS11cGxvYWRcIiwgXCJNb2RhbFwiKS5zaG93KCk7XG5cdH1cblxuXHRcblxuICAgIC8vIGZ1bmN0aW9uIGNhbGxzIG9uY2hhbmdlIG9mIHRoZSB0ZXh0YXJlYSBpbiB3aGljaCBvcHRpb24gdmFsdWUgaXMgZ2l2ZW4gaWYgaXNhbGdvIGlzIG9mZlxuXHRmdW5jdGlvbiBlZGl0Q0RhdGEodmFsMSwgdmFsMiwgaSwgZSkge1xuXHRcdGlmICghZS50YXJnZXQudmFsdWUpIHJldHVybjtcblx0XHRpZiAoZS50YXJnZXQuaWQgPT0gXCJtYXRjaExpc3QxXCIpIHtcblx0XHRcdGxvY2FsQ0RhdGFbaV0udmFsdWUxID0gZS50YXJnZXQudmFsdWUucmVwbGFjZSgvXFxuL2dtLFwiXCIpO1xuXHRcdFx0Ly9mb3JjZVVwZGF0ZSgpO1xuXHRcdH0gZWxzZSBpZiAoZS50YXJnZXQuaWQgPT0gXCJtYXRjaExpc3QyXCIpIHtcblx0XHRcdGxvY2FsQ0RhdGFbaV0udmFsdWUyID0gZS50YXJnZXQudmFsdWUucmVwbGFjZSgvXFxuL2dtLFwiXCIpO1xuXHRcdFx0Ly9mb3JjZVVwZGF0ZSgpO1xuXHRcdH1cblx0XHQvLyBjb252ZXJ0aW5nIHRoZSB4bWwgdG8ganNvbiBcblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XG5cdFx0dGltZXJbJ2VkaXRDZGF0YSddID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgXG5cdFx0XHRsZXQgbmV3Q0RhdGEgPSBcIlxcblwiO1xuXHRcdFx0Ly8galF1ZXJ5KGxvY2FsQ0RhdGEpLmVhY2goZnVuY3Rpb24oaSkgeyAvLyBSZXBsYWNlZFxuXHRcdFx0XHRsb2NhbENEYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKXtcblx0XHRcdFx0bmV3Q0RhdGEgKz0gbG9jYWxDRGF0YVtpXS52YWx1ZTErXCJbXCIrbG9jYWxDRGF0YVtpXS52YWx1ZTIrXCJdXFxuXCI7XG5cdFx0XHR9KTtcblx0XHRcdC8vIHVwZGF0aW5nIHRoZSBjZGF0YVxuXHRcdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhID0gbmV3Q0RhdGE7XG5cdFx0XHQvLyB1cGRhdGluZyB0aGUgeG1sXG5cdFx0XHRnZXRDaGlsZFhtbChKU09OVG9YTUwoeG1sKSk7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXJbJ2VkaXRDZGF0YSddKTtcblx0XHR9LCA1MDApO1xuXHR9XG4gICAgXG4gICAgLy8gZnVuY3Rpb24gY2FsbHMgb25jaGFuZ2Ugb2YgdGhlIHRleHRhcmVhIGluIHdoaWNoIG9wdGlvbiB2YWx1ZSBpcyBnaXZlbiBpZiBpc2FsZ28gaXMgb25cblx0ZnVuY3Rpb24gZWRpdGFsZ29DRGF0YSh2YWwxLCBpLCBwbGFjZUluZGV4LCBlKSB7XG5cdFx0aWYgKCFlLnRhcmdldC52YWx1ZSkgcmV0dXJuO1xuXHRcdGlmIChlLnRhcmdldC5pZCA9PSBcIm1hdGNoTGlzdDFcIikge1xuXHRcdFx0bGV0IHBsYWNlaW5kZXgyID0gcGxhY2VJbmRleC5zcGxpdChcIl9cIilbMV07XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxvY2FsQ0RhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKCgoaisxKSA9PSAoaSsxKSkpIHtcblx0XHRcdFx0XHRsZXQgc3RyID0gbG9jYWxDRGF0YVtpXS52YWx1ZTE7XG5cdFx0XHRcdFx0dmFyIHN0cmFyciA9IHN0ci5zcGxpdChcIiUlXCIpO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc3RyYXJyLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA9PSBwbGFjZWluZGV4Mikge1xuXHRcdFx0XHRcdFx0XHRzdHJhcnJba10gPSBlLnRhcmdldC52YWx1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0cmFyciA9IHN0cmFyci5qb2luKFwiJSVcIik7XG5cdFx0XHRsb2NhbENEYXRhW2ldLnZhbHVlMSA9IHN0cmFycjtcblx0XHRcdC8vZm9yY2VVcGRhdGUoKTtcblx0XHR9IGVsc2UgaWYgKGUudGFyZ2V0LmlkID09IFwibWF0Y2hMaXN0MlwiKSB7XG5cdFx0XHRsZXQgcGxhY2VpbmRleDIgPSBwbGFjZUluZGV4LnNwbGl0KFwiX1wiKVsxXTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbG9jYWxDRGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAoKChqKzEpID09IChpKzEpKSkge1xuXHRcdFx0XHRcdGxldCBzdHIgPSBsb2NhbENEYXRhW2ldLnZhbHVlMjtcblx0XHRcdFx0XHR2YXIgc3RyYXJyID0gc3RyLnNwbGl0KFwiJSVcIik7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBzdHJhcnIubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmIChrID09IHBsYWNlaW5kZXgyKSB7XG5cdFx0XHRcdFx0XHRcdHN0cmFycltrXSA9IGUudGFyZ2V0LnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3RyYXJyID0gc3RyYXJyLmpvaW4oXCIlJVwiKTtcblx0XHRcdGxvY2FsQ0RhdGFbaV0udmFsdWUyID0gc3RyYXJyO1xuXHRcdFx0Ly9mb3JjZVVwZGF0ZSgpO1xuXHRcdH1cblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XG5cdFx0dGltZXJbJ2FsZ28nXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRsZXQgbmV3Q0RhdGEgPSBcIlxcblwiO1xuXHRcdFx0Ly8galF1ZXJ5KGxvY2FsQ0RhdGEpLmVhY2goZnVuY3Rpb24oaSkgeyAvLyBSZXBsYWNlZFxuXHRcdFx0bG9jYWxDRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsaSl7XG5cdFx0XHRcdG5ld0NEYXRhICs9IGxvY2FsQ0RhdGFbaV0udmFsdWUxK1wiW1wiK2xvY2FsQ0RhdGFbaV0udmFsdWUyK1wiXVxcblwiO1xuXHRcdFx0fSk7XG5cdFx0XHR4bWwuc214bWwubWF0Y2hsaXN0Ll9fY2RhdGEgPSBuZXdDRGF0YTtcblx0XHRcdGdldENoaWxkWG1sKEpTT05Ub1hNTCh4bWwpKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lclsnYWxnbyddKTtcblx0XHR9LCA1MDApO1x0XG4gICAgfVxuICAgIFxuICAgIC8vIGZvciBkZWxldGluZyB0aGUgY3VycmVudCBvcHRpb25cblx0ZnVuY3Rpb24gcmVtb3ZlQ0RhdGEobGlzdDFWYWwsIGxpc3QyVmFsLCBpZCkge1xuXHRcdC8vQUguYWxlcnQoXCJjaGVja2luZ1wiKVxuXHRcdHN0YXRlLm9wZW5EZWxldGVEaWFsb2cgPSB0cnVlO1xuXHRcdHN0YXRlLnJvd19pZCA9IGlkO1xuXHRcdFxuICAgIH1cbiAgICBcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGNhbGxzIHdoZW4gdGhlIHNldHRpbmcgYnRuIG9wdGlvbiBpcyBjbGlja2VkXG5cdGZ1bmN0aW9uIGNoYW5nZVNldHRpbmcodmFsdWUpIHtcblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XG5cdFx0Ly8gaWYgTm9ybWFsIG9wdGlvbnMgaXMgc2VsZWN0ZWRcblx0XHRpZiAodmFsdWUgPT0gMikge1xuXHRcdFx0aWYgKHN0YXRlLmRyYWdfbW9kZSkge1xuXHRcdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fbXVsdGltYXRjaCA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fbXVsdGltYXRjaCA9IDI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSAzKSB7XG5cdFx0XHQvLyBmb3Igc3dhcCBsaXN0XG5cdFx0XHRsZXQgdGVtcEFyciA9IHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YS5zcGxpdCgnXFxuJyk7XG5cdFx0XHRsZXQgc3dhcGVkQ2RhdGEgPSBcIlwiO1xuXHRcdFx0dGVtcEFyci5tYXAoKGl0ZW1zLGkpPT57XG5cdFx0XHRcdGxldCB0ZW1wTGlzdCA9IGl0ZW1zLnNwbGl0KC9cXFsoLio/KVxcXS8pO1xuXHRcdFx0XHRpZiAodGVtcExpc3QubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdHN3YXBlZENkYXRhICs9IGAke3RlbXBMaXN0WzFdfVske3RlbXBMaXN0WzBdLnRyaW0oKX1dXFxuYDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR4bWwuc214bWwubWF0Y2hsaXN0Ll9fY2RhdGEgPSBzd2FwZWRDZGF0YTtcblx0XHR9XG5cdFx0Ly8gdXBkYXRpbmcgYW5kIHN0b3JpbmcgdGhlIHhtbFxuXHRcdGdldENoaWxkWG1sKEpTT05Ub1hNTCh4bWwpKTtcblx0XHRoYW5kbGVNZW51Q2xvc2UoKTtcbiAgICB9XG4gICAgXG5cdC8vIHdoZW5ldmVyIHRoZSBpbWFnZSBpY29uIGlzIGNsaWNrZWQgdGhpcyBmdW5jdGlvbiBjYWxsc1xuXHRmdW5jdGlvbiBvcGVuSW1hZ2VEaWFsb2coY2xhc3NfbmFtZSkge1xuXHRcdHN0YXRlLm9wZW5JbWFnZURpYWxvZyA9IHRydWU7XG5cdFx0c3RhdGUuaW1hZ2VDbGFzcyA9IGNsYXNzX25hbWU7XG5cdFx0Ly8gZXh0cmN0aW5nIGltYWdlIGRldGFpbHNcblx0XHRsZXQgaW1hZ2UgPSB7fTtcblxuXG5cdFx0aWYoQUguc2VsZWN0KCcuJytjbGFzc19uYW1lKycgKyBpbWcnKS5ub2RlTmFtZSkge1xuXHRcdFx0aW1hZ2UubmFtZSA9IEFILnNlbGVjdCgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuZ2V0QXR0cmlidXRlKFwic3JjXCIpLnNwbGl0KCcvJykucG9wKCk7XG5cdFx0XHRpbWFnZS5hbHQgPSBBSC5zZWxlY3QoJy4nK2NsYXNzX25hbWUrJyArIGltZycpLmdldEF0dHJpYnV0ZShcImFsdFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW1hZ2UubmFtZSA9IFwiXCI7XG5cdFx0XHRpbWFnZS5hbHQgPSBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIHNob3cgdmFsdWUgaW4gdGhlIG9wZW5lZCBkYWlsb2dcblx0XHR0aW1lclsnaW1hZ2UnXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRBSC5zZWxlY3QoJyNNYXRjaGxpc3RJbWcnKS52YWx1ZSA9IGltYWdlLm5hbWU7XG5cdFx0XHRBSC5zZWxlY3QoJyNNYXRjaGxpc3RBbHQnKS52YWx1ZSA9IGltYWdlLmFsdDtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lclsnaW1hZ2UnXSk7XG5cdFx0fSwyMDApO1xuICAgIH1cbiAgICBcbiAgICAvLyBjYWxscyB3aGVuIGltYWdlIGljb24gaXMgY2xpY2tlZCBhbmQgaXNfYWxnbyBpcyB0cnVlIFxuXHRmdW5jdGlvbiBvcGVuSW1hZ2VEaWFsb2dBbGdvKGNsYXNzX25hbWUsIGlkcywgaSwgY2xuYW1lKSB7XG5cdFx0c3RhdGUub3BlbkltYWdlRGlhbG9nID0gdHJ1ZTtcblx0XHRjbHNuYW1lID0gY2xhc3NfbmFtZTtcblx0XHRpbmRleCA9IGlkcztcblx0XHRjb2x1bW5pZCA9IGk7XG5cdFx0Y29sdW1ubmFtZSA9IGNsbmFtZTtcblx0XG5cblx0XHRzdGF0ZS5pbWFnZUNsYXNzID0gY2xhc3NfbmFtZTtcblx0XHRzdGF0ZS5jbG5hbWUgPSBjbG5hbWU7XG5cdFx0Ly8gZXh0cmN0aW5nIGltYWdlIGRldGFpbHNcblx0XHRsZXQgaW1hZ2UgPSB7fTtcblx0XHQvL2ltYWdlLm5hbWUgPSAoalF1ZXJ5KCcuJytjbGFzc19uYW1lKycgKyBpbWcnKS5hdHRyKFwic3JjXCIpKSA/IGpRdWVyeSgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuYXR0cihcInNyY1wiKS5zcGxpdCgnLycpLnBvcCgpIDogXCJcIjtcblx0XHRpZihBSC5zZWxlY3QoJy4nK2NsYXNzX25hbWUsJyArIGltZycpLmdldEF0dHJpYnV0ZSgnc3JjJykgIT0gbnVsbCkge1xuXHRcdFx0aW1hZ2UubmFtZSA9IEFILnNlbGVjdCgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuZ2V0QXR0cmlidXRlKFwic3JjXCIpLnNwbGl0KCcvJykucG9wKCk7XG5cdFx0XHRpbWFnZS5hbHQgPSBBSC5zZWxlY3QoJy4nK2NsYXNzX25hbWUrJyArIGltZycpLmdldEF0dHJpYnV0ZShcImFsdFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW1hZ2UubmFtZSA9IFwiXCI7XG5cdFx0XHRpbWFnZS5hbHQgPSBcIlwiO1xuXHRcdH1cblxuXHRcdC8vaW1hZ2UuYWx0ID0gKGpRdWVyeSgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuYXR0cihcImFsdFwiKSkgPyBqUXVlcnkoJy4nK2NsYXNzX25hbWUrJyArIGltZycpLmF0dHIoXCJhbHRcIik6IFwiXCI7XG5cblx0XHRcblx0XHRcblx0XHQvLyBzaG93IHZhbHVlIGluIHRoZSBvcGVuZWQgZGFpbG9nXG5cdFx0dGltZXJbJ2FsZ29JbWFnZSddID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdC8valF1ZXJ5KCcjTWF0Y2hsaXN0SW1nJykudmFsKGltYWdlLm5hbWUpO1xuXHRcdFx0QUguc2VsZWN0KCcjTWF0Y2hsaXN0SW1nJykudmFsdWUgPSBpbWFnZS5uYW1lO1xuXG5cdFx0XHQvL2pRdWVyeSgnI01hdGNobGlzdEFsdCcpLnZhbChpbWFnZS5hbHQpO1xuXHRcdFx0QUguc2VsZWN0KCcjTWF0Y2hsaXN0QWx0JykudmFsdWUgPSBpbWFnZS5hbHQ7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXJbJ2FsZ29JbWFnZSddKTtcblx0XHR9LDUwMCk7XG4gICAgfVxuXG4gICAgLy8gb24gY2xpY2sgb2YgY2FuY2VsIGJ0biBvZiBpbWFnZSBkaWFsb2cgdGhpcyBmdW5jdGlvbiBjYWxsZWRcblx0ZnVuY3Rpb24gY2xvc2VJbWFnZURpYWxvZygpIHtcblx0XHRzdGF0ZS5vcGVuSW1hZ2VEaWFsb2cgPSBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gb24gY2xpY2sgb2YgZG9uZSBidG4gb2YgaW1hZ2UgZGlhbG9nIHRoaXMgZnVuY3Rpb24gY2FsbGVkXG5cdGZ1bmN0aW9uIGluc2VydEltYWdlKCkge1xuXHRcdGlmIChzdGF0ZS5pc2FsZ28gPT0gdHJ1ZSkge1x0XG5cdFx0XHQvLyBAcHJhZGVlcCBzaXIgOiBpbiBib3RoIGNvbmRpdGlvbiBzYW1lIGNvZGUgaXMgd3JpdHRlbiBjYW4gd2UgbWFrZSBpdCBpbiBvbmVcblx0XHRcdGlmICgoc3RhdGUuY2xuYW1lID09IFwibWF0Y2hsaXN0MlwiKSB8fCAoc3RhdGUuY2xuYW1lID09IFwibWF0Y2hsaXN0MVwiKSkge1xuXHRcdFx0XHRsZXQgaW1hZ2UgPSB7fTtcblx0XHRcdFx0Ly8gZ2V0dGluZyB0aGUgaW1hZ2UgaW5mb3JtYXRpb25cblx0XHRcdFx0XG5cdFx0XHRcdGltYWdlLm5hbWUgPSBBSC5zZWxlY3QoXCIjTWF0Y2hsaXN0SW1nXCIpLnZhbHVlO1xuXHRcdFx0XHRpbWFnZS5hbHQgPSBBSC5zZWxlY3QoJyNNYXRjaGxpc3RBbHQnKS52YWx1ZTtcblx0XHRcdFx0aW1hZ2Uub2xkVmFsdWUgPSBBSC5zZWxlY3QoJy4nK3N0YXRlLmltYWdlQ2xhc3MpLnZhbHVlO1xuXHRcdFx0XHRzdGF0ZS5vcGVuSW1hZ2VEaWFsb2cgPSBmYWxzZTtcblx0XHRcdFx0Ly8gcmVwbGFjZSB3aXRoIG5ldyB2YWx1ZSBpbiB0aGUgeG1sXG5cdFx0XHRcdGltYWdlLm5ld1ZhbHVlID0gc3RhdGUueG1sLnJlcGxhY2UoaW1hZ2Uub2xkVmFsdWUsJyonK2ltYWdlLm5hbWUrJyMjJytpbWFnZS5hbHQpO1xuXHRcdFx0XHQvLyB1cGRhdGVzIHRoZSB4bWxcblx0XHRcdFx0Z2V0Q2hpbGRYbWwoaW1hZ2UubmV3VmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBmaW5kaW5nIHRoZSBjZGF0YVxuXHRcdFx0bGV0IGNkYXRhQXJyID0gKC9cXDxcXCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KVxcXVxcXVxcPi9naSkuZXhlYyhzdGF0ZS54bWwpO1xuXHRcdFx0bGV0IGNkYXRhID0gXCJcIjtcblx0XHRcdGxldCBrZXlJbmRleCA9IHBhcnNlSW50KChzdGF0ZS5pbWFnZUNsYXNzKS5tYXRjaCgvXFxkKyQvZykpO1xuXHRcdFx0bGV0IGltYWdlID0ge307XG5cdFx0XHQvLyBnZXR0aW5nIGltYWdlIGluZm9ybWF0aW9uXG5cdFx0XHQvL2ltYWdlLm5hbWUgPSBqUXVlcnkoJyNNYXRjaGxpc3RJbWcnKS52YWwoKTtcblx0XHRcdGltYWdlLm5hbWUgPSBBSC5zZWxlY3QoXCIjTWF0Y2hsaXN0SW1nXCIpLnZhbHVlO1xuXHRcdFx0Ly9pbWFnZS5hbHQgPSBqUXVlcnkoJyNNYXRjaGxpc3RBbHQnKS52YWwoKTtcblx0XHRcdGltYWdlLmFsdCA9IEFILnNlbGVjdCgnI01hdGNobGlzdEFsdCcpLnZhbHVlO1xuXHRcdFx0Ly9pbWFnZS5vbGRWYWx1ZSA9IGpRdWVyeSgnLicrc3RhdGUuaW1hZ2VDbGFzcykudmFsKCk7XG5cdFx0XHRpbWFnZS5vbGRWYWx1ZSA9IEFILnNlbGVjdCgnLicrc3RhdGUuaW1hZ2VDbGFzcykudmFsdWU7XG5cdFx0XHRzdGF0ZS5vcGVuSW1hZ2VEaWFsb2cgPSBmYWxzZTtcblx0XHRcdGlmIChjZGF0YUFycikge1xuXHRcdFx0XHRjZGF0YSA9IGNkYXRhQXJyWzFdO1xuXHRcdFx0XHQvLyByZXBsYWNpbmcgdHdvIG5ld2xpbmVzIHdpdGggc2luZ2xpbmUgbmV3bGluZSBhbmQgc3BsaXRpbmcgaXQgd2l0aCBuZXdsaW5lXG5cdFx0XHRcdGNkYXRhID0gKGNkYXRhLnJlcGxhY2UoXCJcXG5cXG5cIixcIlxcblwiKSkudHJpbSgpO1xuXHRcdFx0XHRjZGF0YUFyciA9IGNkYXRhLnNwbGl0KFwiXFxuXCIpO1xuXHRcdFx0XHQvLyBhZGRpbmcgbmV3IGltYWdlIGRldGFpbHNcblx0XHRcdFx0Y2RhdGFBcnJba2V5SW5kZXhdID0gY2RhdGFBcnJba2V5SW5kZXhdLnJlcGxhY2UoaW1hZ2Uub2xkVmFsdWUsJyonK2ltYWdlLm5hbWUrJyMjJytpbWFnZS5hbHQpO1xuXHRcdFx0XHQvLyBqb2luIGNkYXRhQXJyIHdpdGggbmVlbGluZVxuXHRcdFx0XHRjZGF0YSA9IGNkYXRhQXJyLmpvaW4oXCJcXG5cIik7XG5cdFx0XHRcdC8vIHJlcGxhY2UgdGhlIGNkYXRhIHdpdGggbmV3IHZhbHVlXG5cdFx0XHRcdGltYWdlLm5ld1ZhbHVlID0geG1sLnJlcGxhY2UoL1xcPFxcIVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXVxcPi9naSxcIjwhW0NEQVRBW1xcblwiK2NkYXRhK1wiXFxuXV0+XCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYWRkaW5nIG5ldyBpbWFnZSBkZXRhaWxzXG5cdFx0XHRcdGltYWdlLm5ld1ZhbHVlID0geG1sLnJlcGxhY2UoaW1hZ2Uub2xkVmFsdWUsJyonK2ltYWdlLm5hbWUrJyMjJytpbWFnZS5hbHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIHRoZSB4bWxcblx0XHRcdGdldENoaWxkWG1sKGltYWdlLm5ld1ZhbHVlKTtcblx0XHR9XG5cdH1cbiAgICBcbiAgICAvLyBjYWxsZWQgd2hlbiBhbGdvcml0aG1pYyBjaGVja2JveCBzdGF0ZSBpcyBjaGFuZ2VkIChvbiBjbGljaylcblx0ZnVuY3Rpb24gY2hhbmdlaXNhbGdvKGUpIHtcblx0XHRcblx0XHQvLyBjb252ZXJ0IHhtbCB0byBqc29uXG5cdFx0bGV0IHhtbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xuXHRcdHN0YXRlLmlzYWxnbyA9IGUudGFyZ2V0LmNoZWNrZWQ7XG5cdFx0Ly8gaWYgY2hlY2tib3ggaXMgY2hlY2tlZCBcblx0XHQvLyBpZiAoZS50YXJnZXQuY2hlY2tlZCkge1xuXHRcdC8vIFx0eG1sLnNteG1sLm1hdGNobGlzdC5faXNfYWxnbyA9IHRydWU7IFxuXHRcdC8vIH0gZWxzZSB7XG5cdFx0Ly8gXHR4bWwuc214bWwubWF0Y2hsaXN0Ll9pc19hbGdvID0gZmFsc2U7XG5cdFx0Ly8gfVxuXHRcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX2lzX2FsZ28gPSBlLnRhcmdldC5jaGVja2VkO1xuXHRcdC8vIHVwZGF0ZXMgdGhlIHhtbFxuXHRcdGdldENoaWxkWG1sKEpTT05Ub1hNTCh4bWwpKTtcblx0fVxuXG4gICAgLy8gb24gY2xpY2sgb2YgZGVsZXRlIGljb24gd2hpY2ggaXMgYWRqdXNlbnQgdG8gdGhlIG9wdGlvbiBidG4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcblx0ZnVuY3Rpb24gcmVtb3ZldGV4dGJveChpZHMsIHBsYWNlSW5kZXgsIHRlc3QsIGksIGUpIHtcblx0XHRpZiAodGVzdCA9PSBcIm1hdGNobGlzdDFcIikge1xuXHRcdFx0dmFyIHN0cmFycjtcblx0XHRcdGxldCBwbGFjZWluZGV4MiA9IHBsYWNlSW5kZXguc3BsaXQoXCJfXCIpWzFdO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsb2NhbENEYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmICgoKGorMSkgPT0gKGkrMSkpKSB7XG5cdFx0XHRcdFx0bGV0IHN0ciA9IGxvY2FsQ0RhdGFbaV0udmFsdWUxO1xuXHRcdFx0XHRcdHN0cmFyciA9IHN0ci5zcGxpdChcIiUlXCIpO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc3RyYXJyLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA9PSBwbGFjZWluZGV4Mikge1xuXHRcdFx0XHRcdFx0XHRzdHJhcnIuc3BsaWNlKGssIDEpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3RyYXJyID0gc3RyYXJyLmpvaW4oXCIlJVwiKTtcblx0XHRcdGxvY2FsQ0RhdGFbaV0udmFsdWUxID0gc3RyYXJyO1xuXHRcdFx0aWYgKGxvY2FsQ0RhdGFbaV0udmFsdWUxID09ICcnIHx8IGxvY2FsQ0RhdGFbaV0udmFsdWUxID09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRsb2NhbENEYXRhW2ldLnZhbHVlMSA9ICdpbnNlcnQgdmFsdWUnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGVzdCA9PSBcIm1hdGNobGlzdDJcIikge1xuXHRcdFx0dmFyIHN0cmFycjtcblx0XHRcdGxldCBwbGFjZWluZGV4MiA9IHBsYWNlSW5kZXguc3BsaXQoXCJfXCIpWzFdO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsb2NhbENEYXRhLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmICgoKGorMSkgPT0gKGkrMSkpKSB7XG5cdFx0XHRcdFx0bGV0IHN0ciA9IGxvY2FsQ0RhdGFbaV0udmFsdWUyO1xuXHRcdFx0XHRcdHN0cmFyciA9IHN0ci5zcGxpdChcIiUlXCIpO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc3RyYXJyLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA9PSBwbGFjZWluZGV4Mikge1xuXHRcdFx0XHRcdFx0XHRzdHJhcnIuc3BsaWNlKGssIDEpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3RyYXJyID0gc3RyYXJyLmpvaW4oXCIlJVwiKTtcblx0XHRcdGxvY2FsQ0RhdGFbaV0udmFsdWUyID0gc3RyYXJyO1xuXHRcdFx0aWYgKGxvY2FsQ0RhdGFbaV0udmFsdWUyID09ICcnIHx8IGxvY2FsQ0RhdGFbaV0udmFsdWUyID09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRsb2NhbENEYXRhW2ldLnZhbHVlMiA9ICdpbnNlcnQgdmFsdWUnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XG5cdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGxldCBuZXdDRGF0YSA9IFwiXFxuXCI7XG5cdFx0XHQvL2pRdWVyeShsb2NhbENEYXRhKS5lYWNoKGZ1bmN0aW9uKGkpIHsgLy8gUmVwbGFjZWRcblx0XHRcdGxvY2FsQ0RhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhLGkpIHtcblx0XHRcdFx0bmV3Q0RhdGEgKz0gbG9jYWxDRGF0YVtpXS52YWx1ZTErXCJbXCIrbG9jYWxDRGF0YVtpXS52YWx1ZTIrXCJdXFxuXCI7XG5cdFx0XHR9KTtcblx0XHRcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YSA9IG5ld0NEYXRhO1xuXHRcdFx0Z2V0Q2hpbGRYbWwoSlNPTlRvWE1MKHhtbCkpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHR9LCA1MDApO1xuXHRcdHN0YXRlLmRpciA9ICFzdGF0ZS5kaXI7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGFkZExpc3RJdGVtKGluZGV4KSB7XG5cdFx0Ly8gY29udmVydCB4bWwgdG8ganNvbiBcblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XG5cdFx0Ly8gc3BsaXR0aW5nIGNkYXRhIHdpdGggbmV3bGluZSBhbmQgc3RvcnJpbmcgaXQgaW4gdmFyaWFibGUgbmV3QXJyXG5cdFx0bGV0IG5ld0FyciA9IHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YS5zcGxpdCgnXFxuJyk7XG5cdFx0aWYgKG5ld0FyclsobmV3QXJyLmxlbmd0aCAtIDEpXSA9PSBcIlwiKSB7XG5cdFx0XHRuZXdBcnIucG9wKCk7XG5cdFx0XHRuZXdBcnIudW5zaGlmdChcIlwiKTtcblx0XHR9IFxuXHRcdGlmICgobmV3QXJyWzBdID09IFwiXCIpICYmIChuZXdBcnJbMV0gPT0gXCJcIikpIHtcblx0XHRcdG5ld0Fyci5zaGlmdCgpO1xuXHRcdH1cblx0XHQvLyBnZXR0bmcgdGhlIGluZGV4IG9mIHRoZSBvcHRpb24gXG5cdFx0bGV0IHN0ciA9IG5ld0FycltwYXJzZUludChpbmRleCsxKV07XG5cdFx0Ly8gZXh0cmFjdGluZyB2YWx1ZSAxXG5cdFx0bGV0IHZhbHVlMSA9IHN0ci5yZXBsYWNlKHN0ci5tYXRjaCgvXFxbKC4qPylcXF0vZyksXCJcIikucmVwbGFjZSgvXlxccysvZywgXCJcIik7XG5cdFx0bGV0IHZhbHVlMiA9IHN0ci5tYXRjaCgvXFxbKC4qPylcXF0vZylbMF07XG5cdFx0dmFsdWUyID0gdmFsdWUyLnN1YnN0cmluZygxLCB2YWx1ZTIubGVuZ3RoLTEpO1xuXHRcdC8vIGV4dHJhY3RpbmcgdmFsdWUgMlxuXHRcdHZhbHVlMiA9ICdbJyt2YWx1ZTIrJ10nO1xuXHRcdC8vIGFkZGluZyBuZXcgb3B0aW9uIHZhbHVlXG5cdFx0dmFsdWUxID0gdmFsdWUxKyclJU9wdGlvbiAyIFZhbHVlJztcblx0XHQvLyBzdG9yZSB0aGUgZmluYWwgc3RyaW5nIGF0IHRoYXQgaW5kZXhcblx0XHRsZXQgZlN0ciA9IHZhbHVlMSt2YWx1ZTI7XG5cdFx0bmV3QXJyW3BhcnNlSW50KGluZGV4KzEpXSA9IGZTdHI7XG5cdFx0Ly8gam9pbiB0aGUgYXJyYXlcblx0XHRuZXdBcnIgPSBuZXdBcnIuam9pbignXFxuJyk7XG5cdFx0Ly8gdXBkYXRlIHRoZSBjZGF0YVxuXHRcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YSA9IG5ld0Fycjtcblx0XHQvLyBzdG9yZXMgYW5kIHVwZGF0ZSB0aGUgeG1sIHVzaW5nIHRoZSBmdW5jdGlvbiBnZXRDaGlsZFhtbFxuXHRcdGdldENoaWxkWG1sKEpTT05Ub1hNTCh4bWwpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gY2FsbGVkIHdoZW4gZHJvcGRvd24gaXMgb3BlbiBcblx0ZnVuY3Rpb24gaGFuZGxlTWVudU9wZW4oZXZlbnQpIHtcblx0XHRzdGF0ZS5hbmNob3JFbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgfVxuICAgIFxuICAgIC8vIGNhbGxlZCB3aGVuIGRyb3Bkb3duIGlzIGNsb3NlIFxuXHRmdW5jdGlvbiBoYW5kbGVNZW51Q2xvc2UoKSB7XG5cdFx0c3RhdGUuYW5jaG9yRWwgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiByZW1vdmVSb3coKSB7XG5cdFx0XG5cdFx0c3RhdGUub3BlbkRlbGV0ZURpYWxvZyA9IGZhbHNlO1xuXHRcdFxuXHRcdGxldCBub3RfbWF0Y2hlZF9kYXRhID0gXCJcIjtcblx0XHQvLyBzdG9yaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIG9wdGlvbiBpbiBhIGV4Y2VwdCB0aGUgZGVsZXRlZCBvbmVcblx0XHQvLyBqUXVlcnkobG9jYWxDRGF0YSkuZWFjaChmdW5jdGlvbihpbmRleF9ubykgeyAvLyBSZXBsYWNlZFxuXHRcdGxvY2FsQ0RhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhLGluZGV4X25vKSB7XG5cdFx0XHQvLyBjaGVjayBtaW4gbm8gb2Ygb3B0aW9uc1xuXHRcdFx0aWYgKGxvY2FsQ0RhdGEubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRpZiAobG9jYWxDRGF0YVtpbmRleF9ub10uaWQgIT0gc3RhdGUucm93X2lkKSB7XG5cdFx0XHRcdFx0bm90X21hdGNoZWRfZGF0YSArPSBsb2NhbENEYXRhW2luZGV4X25vXS52YWx1ZTEgKyBcIltcIiArIGxvY2FsQ0RhdGFbaW5kZXhfbm9dLnZhbHVlMiArIFwiXVxcblwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRBSS5zaG93bXNnKCdBdCBsZWFzdCBvbmUgZmllbGQgcmVxdWlyZWQuJyk7XG5cdFx0XHRcdG5vdF9tYXRjaGVkX2RhdGEgKz0gbG9jYWxDRGF0YVtpbmRleF9ub10udmFsdWUxICsgXCJbXCIgKyBsb2NhbENEYXRhW2luZGV4X25vXS52YWx1ZTIgKyBcIl1cXG5cIjtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvLyBjb252ZXJ0IHhtbCB0byBqc29uXG5cdFx0bGV0IHhtbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xuXHRcdC8vIHVwZGF0aW5nIGNkYXRhXG5cdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhID0gJ1xcbicgKyBub3RfbWF0Y2hlZF9kYXRhO1xuXHRcdC8vIHVwZGF0aW5nIHRoZSB4bWxcblx0XHRnZXRDaGlsZFhtbChKU09OVG9YTUwoeG1sKSk7XG5cdH1cblx0XG5cdFxuICAgIFxuXG5cdC8vIHRlbXBkYXRhMSA9IFtdO1xuXHQvLyB0ZW1wZGF0YTIgPSBbXTtcblxuXHQvLyAkOntcblx0Ly8gXHRsb2NhbENEYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKXtcblx0Ly8gXHRcdGlmKHN0YXRlLmlzYWxnbyA9PSB0cnVlKSB7XG5cdC8vIFx0XHRcdHRlbXBkYXRhMSA9IGRhdGEudmFsdWUxLnNwbGl0KFwiJSVcIilcbiAgICAvLyAgICAgICAgIFx0dGVtcGRhdGEyID0gZGF0YS52YWx1ZTIuc3BsaXQoXCIlJVwiKVxuXHQvLyBcdFx0fVxuXHQvLyBcdH0pXG5cdC8vIH1cblxuXG48L3NjcmlwdD5cblxuPG1haW4+XG4gICAgPGNlbnRlcj5cbiAgICAgICAgPGRpdiBpZD1cImZpeGVkTWF0Y2hMaXN0XCIgY2xhc3M9XCJib3JkZXIgaC1hdXRvIGZ3aWR0aFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1iLTFcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm9yZGVyLWJvdHRvbSB3LTEwMCBkLWlubGluZS1ibG9jayBwYi0wIHB4LTMgcHQtM1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IHJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02IHByLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwibGlzdGhlYWRpbmcxXCIgY2xhc3M9XCJtYi0wIGZsb2F0LWxlZnRcIj57bC5tYXRjaGxpc3RfaGVhZGluZzF9PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImxpc3RoZWFkaW5nMVwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgb246Y2hhbmdlPXt1cGRhdGVYbWx9IHZhbHVlPXtzdGF0ZS5saXN0aGVhZGluZzF9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNiBwbC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImxpc3RoZWFkaW5nMlwiIGNsYXNzPVwibWItMCBmbG9hdC1sZWZ0XCI+e2wubWF0Y2hsaXN0X2hlYWRpbmcyfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJsaXN0aGVhZGluZzJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG9uOmNoYW5nZT17dXBkYXRlWG1sfSB2YWx1ZT17c3RhdGUubGlzdGhlYWRpbmcyfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IHdpZHRoMSBmbG9hdC1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaCBmbG9hdC1sZWZ0IHctc20gbXItMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJtYXhub2RlXCIgY2xhc3M9XCJtYi0wIGZsb2F0LWxlZnRcIj5NYXhub2RlOjwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJtYXhub2RlXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBwbGFjZWhvbGRlcj1cIkVudGVyIG51bWJlciBvbmx5IDEgdG8gNlwiIG9uOmNoYW5nZT17dXBkYXRlWG1sfSB2YWx1ZT17c3RhdGUubWF4bm9kZX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTIgZC1mbGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17c3RhdGUuZHJhZ19tb2RlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0geyhlKT0+e2NoYW5nZVNldHRpbmcoXCIyXCIsZSl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiaXNEcmFnRHJvcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJwcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXHQgICAgICAgICAgICBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlO3JpZ2h0OjEwcHg7XCI+IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgIERyYWcgJiBEcm9wPC9DaGVja2JveD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0geyhlKT0+e2NoYW5nZVNldHRpbmcoXCIzXCIsZSl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiaXNTd2FwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcj1cInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlN3YXAgTGlzdDwvQ2hlY2tib3g+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHsoc3RhdGUuaXNhbGdvID09IHRydWUgPyB0cnVlIDogZmFsc2UpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0ge2NoYW5nZWlzYWxnb30gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHtcImlzYWxnb1wifSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHtcImlzYWxnb1wifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yPVwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+QWxnb3JpdGhtaWMgPC9DaGVja2JveD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBpZD1cIm1hdGNoTGlzdEFyZWFcIiBjbGFzcz1cInJvdy1mbHVpZCBwLTIgY2xlYXItYm90aFwiPlxuXHRcdFx0XHRcbiAgICAgICAgICAgICAgICB7I2VhY2ggbG9jYWxDRGF0YSBhcyBkYXRhLCBpfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5pc2FsZ28gPT09IHRydWV9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaC1pbXBcIj5cblx0XHRcdFx0XHRcdFx0XHR7dGVtcGRhdGExID0gZGF0YS52YWx1ZTEuc3BsaXQoXCIlJVwiKX1cblx0XHRcdFx0XHRcdFx0XHR7dGVtcGRhdGEyID0gZGF0YS52YWx1ZTIuc3BsaXQoXCIlJVwiKX1cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3M9XCJkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIG1iLTJcIiBkaXI9e3N0YXRlLmRpcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtaW5saW5lLWJsb2NrIGNsZWFyLWJvdGggcG9pbnRlciBsaWdodC1jeWFuLWJnIG14LTAgbXktMSBwLTIgd2lkdGgxMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxvYXQtbGVmdCBjbGVhci1ib3RoXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCB0ZW1wZGF0YTIgYXMgdGVtcCwgan1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInB1bGwtbGVmdCB3b3JkX2JyZWFrIHdpZHRoMjAwIHAtMSBtYXhfd2lkdGhfMzAwXCIgc3R5bGU9eydib3JkZXItcmFkaXVzOjNweDsnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgcm93cz1cIjNcIiBjb2xzPVwiMjBcIiBzdHlsZT17XCJyZXNpemU6bm9uZTtcIn0gY2xhc3M9eyh0ZW1wLmNoYXJBdCgwKSA9PSBcIipcIikgPyBcImggZm9ybS1jb250cm9sIHRleHRhcmVhXzJfXCIraStcIl9cIitqIDogXCJmb3JtLWNvbnRyb2wgdGV4dGFyZWFfMl9cIitpK1wiX1wiK2p9IGlkPVwibWF0Y2hMaXN0MlwiIG9uOmNoYW5nZSA9IHsoZSk9PntlZGl0YWxnb0NEYXRhKHRlbXAsaSxpKydfJytqLGUpfX0gdmFsdWU9e3RlbXB9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHRlbXAuY2hhckF0KDApID09IFwiKlwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwiYXV0aG9yaW5nSW1hZ2VcIiBzcmM9e1wiLy9zMy5hbWF6b25hd3MuY29tL2ppZ3lhYXNhX2NvbnRlbnRfc3RhdGljL1wiK3RlbXAuc3Vic3RyKDEpLnNwbGl0KFwiIyNcIilbMF19IGFsdD17KHRlbXAuc3BsaXQoXCIjI1wiKVsxXSkgPyB0ZW1wLnNwbGl0KFwiIyNcIilbMV0gOm51bGx9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHVsbC1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgdGVtcC5jaGFyQXQoMCkgPT0gXCIqXCJ9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWNvbW9vbi1jbG9zZS0yIHM0IGltYWdlX2RlbGV0ZVwiIGRhdGEtYnMtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtYnMtcGxhY2VtZW50PVwicmlnaHRcIiB0aXRsZT1cIkRlbGV0ZSBJbWFnZVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJkLWJsb2NrIGJ0biBidG4tb3V0bGluZS1wcmltYXJ5IGJ0bi1zbSBlZGl0X2J0biBiZy13aGl0ZSBtYi0xXCIgb246Y2xpY2s9eyhlKT0+e29wZW5JbWFnZURpYWxvZ0FsZ28oXCJ0ZXh0YXJlYV8yX1wiK2krXCJfXCIraixpK1wiX1wiK2osaSxcIm1hdGNobGlzdDJcIixlKX19PjxzcGFuIGNsYXNzPVwiaWNvbW9vbi1pbWFnZXMgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBwdC1zbTEgcGItc20xXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiQWRkIEltYWdlXCI+PC9zcGFuPjwvYnV0dG9uPlx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSBidG4tc20gZWRpdF9idG4gdGV4dGRlbCBiZy13aGl0ZVwiIG9uOmNsaWNrPXsoZSk9PntyZW1vdmV0ZXh0Ym94KFwidGV4dGFyZWFfMl9cIitpK1wiX1wiK2osaStcIl9cIitqLFwibWF0Y2hsaXN0MlwiLGksZSl9fSBzdHlsZT17IHN0YXRlLmlzYWxnbyA/IHsgZGlzcGxheTonYmxvY2snfSA6IHtkaXNwbGF5IDogJ25vbmUnfSB9PjxzcGFuIGNsYXNzPVwiaWNvbW9vbi0yNHB4LWRlbGV0ZS0xIGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXIgcHQtc20xIHBiLXNtMVwiIGRhdGEtYnMtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtYnMtcGxhY2VtZW50PVwicmlnaHRcIiB0aXRsZT1cIkRlbGV0ZVwiPjwvc3Bhbj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbG9hdC1sZWZ0IG1zLTFcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9e1wiYWRkX2J1dHRvbiBweC0xIGJ0biBidG4tb3V0bGluZS1wcmltYXJ5IGJ0bi1zbSBiZy13aGl0ZSBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHByLTIgXCIrXCJsaXN0aXRlbVwiK2l9IG9uOmNsaWNrPXthZGRMaXN0SXRlbS5iaW5kKHRoaXMsaSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udDI0XCI+JiM0Mzs8L3NwYW4+QWRkIGl0ZW08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInB1bGwtcmlnaHRcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHRlbXBkYXRhMSBhcyB0ZW1wMSwga31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInB1bGwtbGVmdCB3b3JkX2JyZWFrIHdpZHRoMjAwIHAtMSBtYXhfd2lkdGhfMzAwXCIgc3R5bGU9e1wiYm9yZGVyLXJhZGl1czozcHg7XCJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSByb3dzPVwiM1wiIGNvbHM9XCIyMFwiIHN0eWxlPXtcInJlc2l6ZTpub25lO1wifSBjbGFzcz17KHRlbXAxLmNoYXJBdCgwKSA9PSBcIipcIikgPyBcImggZm9ybS1jb250cm9sIHRleHRhcmVhXzFfXCIraStcIl9cIitrIDogXCJmb3JtLWNvbnRyb2wgdGV4dGFyZWFfMV9cIitpK1wiX1wiK2t9IGlkPVwibWF0Y2hMaXN0MVwiIG9uOmNoYW5nZT17KGUpPT57ZWRpdGFsZ29DRGF0YSh0ZW1wMSxpLGkrJ18nK2ssZSl9fSB2YWx1ZT17dGVtcDF9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHRlbXAxLmNoYXJBdCgwKSA9PSBcIipcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cImF1dGhvcmluZ0ltYWdlXCIgc3JjPXtcIi8vczMuYW1hem9uYXdzLmNvbS9qaWd5YWFzYV9jb250ZW50X3N0YXRpYy9cIit0ZW1wMS5zdWJzdHIoMSkuc3BsaXQoXCIjI1wiKVswXX0gYWx0PXsodGVtcDEuc3BsaXQoXCIjI1wiKVsxXSkgPyB0ZW1wMS5zcGxpdChcIiMjXCIpWzFdIDpudWxsfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiB0ZW1wMS5jaGFyQXQoMCkgPT0gXCIqXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpY29tb29uLWNsb3NlLTIgczQgaW1hZ2VfZGVsZXRlXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiRGVsZXRlIEltYWdlXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImQtYmxvY2sgYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGVkaXRfYnRuIGJnLXdoaXRlIG1iLTFcIiBvbjpjbGljaz17KGUpPT57b3BlbkltYWdlRGlhbG9nQWxnbyhcInRleHRhcmVhXzFfXCIraStcIl9cIitrLGkrXCJfXCIrayxpLFwibWF0Y2hsaXN0MVwiLGUpfX0+PHNwYW4gY2xhc3M9XCJpY29tb29uLWltYWdlcyBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHB0LXNtMSBwYi1zbTFcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJBZGQgSW1hZ2VcIj48L3NwYW4+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSBidG4tc20gZWRpdF9idG4gdGV4dGRlbCBiZy13aGl0ZVwiIG9uOmNsaWNrPXsoZSk9PntyZW1vdmV0ZXh0Ym94KFwidGV4dGFyZWFfMl9cIitpK1wiX1wiK2ssaStcIl9cIitrLFwibWF0Y2hsaXN0MVwiLGksZSl9fSBzdHlsZT17IHN0YXRlLmlzYWxnbyA/ICdkaXNwbGF5OmJsb2NrOycgOiAnZGlzcGxheSA6IG5vbmUnIH0+PHNwYW4gY2xhc3M9XCJpY29tb29uLTI0cHgtZGVsZXRlLTEgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBwdC1zbTEgcGItc20xXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiRGVsZXRlXCI+PC9zcGFuPjwvYnV0dG9uPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIndpZHRoMSBmbG9hdC1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBvbjpjbGljaz17KCk9PntyZW1vdmVDRGF0YShkYXRhLnZhbHVlMSxkYXRhLnZhbHVlMixkYXRhLmlkKX19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJkZWxldGVfbWF0Y2hfbm9kZV9hdXRoIGljb21vb24gaWNvbW9vbi1uZXctMjRweC1kZWxldGUtMSBzMyBweS0xXCIgdGFiaW5kZXg9XCIwXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiRGVsZXRlXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBtYi0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9pbnRlciBkLWlubGluZS1ibG9jayBjbGVhci1ib3RoIGxpZ2h0LWN5YW4tYmcgbXgtMCBteS0xIHAtMiB3aWR0aDEwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInB1bGwtbGVmdCBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLWxlZnQgd29yZF9icmVhayB3aWR0aDIwMCBwLTEgbWF4X3dpZHRoXzMwMFwiIHN0eWxlPXsnYm9yZGVyUmFkaXVzOjNweDsnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSByb3dzPVwiM1wiIGNvbHM9XCIyMFwiIHN0eWxlPXtcInJlc2l6ZTpub25lO1wifSBjbGFzcz17KGRhdGEudmFsdWUyLmNoYXJBdCgwKSA9PSBcIipcIikgPyBcImggZm9ybS1jb250cm9sIHRleHRhcmVhXzJfXCIraSA6IFwiZm9ybS1jb250cm9sIHRleHRhcmVhXzJfXCIraX0gaWQ9XCJtYXRjaExpc3QyXCIgb246Y2hhbmdlPXsoZSk9PntlZGl0Q0RhdGEoZGF0YS52YWx1ZTIsZGF0YS52YWx1ZTIsaSxlKX19IHZhbHVlPXtkYXRhLnZhbHVlMn0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBkYXRhLnZhbHVlMi5jaGFyQXQoMCkgPT0gXCIqXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cImF1dGhvcmluZ0ltYWdlXCIgc3JjPXtcIi8vczMuYW1hem9uYXdzLmNvbS9qaWd5YWFzYV9jb250ZW50X3N0YXRpYy9cIitkYXRhLnZhbHVlMi5zdWJzdHIoMSkuc3BsaXQoXCIjI1wiKVswXS5zcGxpdCgnJSUnKVswXX0gYWx0PXsoZGF0YS52YWx1ZTIuc3BsaXQoXCIjI1wiKVsxXSkgPyBkYXRhLnZhbHVlMi5zcGxpdChcIiMjXCIpWzFdIDpudWxsfSAvPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLXJpZ2h0IG10XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGRhdGEudmFsdWUyLmNoYXJBdCgwKSA9PSBcIipcIn0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb21vb24tY2xvc2UtMiBzNCBpbWFnZV9kZWxldGVcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJEZWxldGUgSW1hZ2VcIj48L2Rpdj4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSBidG4tc20gZWRpdF9idG4gYmctd2hpdGVcIiBvbjpjbGljaz17KCk9PntvcGVuSW1hZ2VEaWFsb2coXCJ0ZXh0YXJlYV8yX1wiK2kpfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29tb29uLWltYWdlcyBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHB0LXNtMSBwYi1zbTFcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJBZGQgSW1hZ2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInB1bGwtcmlnaHQgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHVsbC1sZWZ0IHdvcmRfYnJlYWsgd2lkdGgyMDAgcC0xIG1heF93aWR0aF8zMDBcIiBzdHlsZT17XCJib3JkZXItcmFkaXVzOjNweFwifX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgcm93cz1cIjNcIiBjb2xzPVwiMjBcIiBzdHlsZT17XCJyZXNpemU6bm9uZTtcIn0gY2xhc3M9eyhkYXRhLnZhbHVlMS5jaGFyQXQoMCkgPT0gXCIqXCIpID8gXCJoIGZvcm0tY29udHJvbCB0ZXh0YXJlYV8xX1wiK2kgOiBcImZvcm0tY29udHJvbCB0ZXh0YXJlYV8xX1wiK2l9IGlkPVwibWF0Y2hMaXN0MVwiIG9uOmNoYW5nZT17KGUpPT57ZWRpdENEYXRhKGRhdGEudmFsdWUxLGRhdGEudmFsdWUyLGksZSl9fSB2YWx1ZT17ZGF0YS52YWx1ZTF9IC8+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZGF0YS52YWx1ZTEuY2hhckF0KDApID09IFwiKlwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJhdXRob3JpbmdJbWFnZVwiIHNyYz17XCIvL3MzLmFtYXpvbmF3cy5jb20vamlneWFhc2FfY29udGVudF9zdGF0aWMvXCIrZGF0YS52YWx1ZTEuc3Vic3RyKDEpLnNwbGl0KFwiIyNcIilbMF0uc3BsaXQoJyUlJylbMF19IGFsdD17KGRhdGEudmFsdWUxLnNwbGl0KFwiIyNcIilbMV0pID8gZGF0YS52YWx1ZTEuc3BsaXQoXCIjI1wiKVsxXSA6bnVsbH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHVsbC1yaWdodCBtdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBkYXRhLnZhbHVlMS5jaGFyQXQoMCkgPT0gXCIqXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb21vb24tY2xvc2UtMiBzNCBpbWFnZV9kZWxldGVcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJEZWxldGUgSW1hZ2VcIj48L2Rpdj4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSBidG4tc20gZWRpdF9idG4gYmctd2hpdGVcIiBvbjpjbGljaz17KCk9PntvcGVuSW1hZ2VEaWFsb2coXCJ0ZXh0YXJlYV8xX1wiK2kpfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29tb29uLWltYWdlcyBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHB0LXNtMSBwYi1zbTFcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJBZGQgSW1hZ2VcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3aWR0aDEgZmxvYXQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBvbjpjbGljaz17KCk9PntyZW1vdmVDRGF0YShkYXRhLnZhbHVlMSxkYXRhLnZhbHVlMixkYXRhLmlkKX19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cImljb21vb24gaWNvbW9vbi1uZXctMjRweC1kZWxldGUtMSBzMyBkZWxldGVfbWF0Y2hfbm9kZSBweS0xXCIgdGFiaW5kZXg9XCIwXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiRGVsZXRlXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWxlZnQgbWwtMiBwYi0zXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBcImFkZF9ub2RlXCJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbCA9IFwiQWRkIG5vZGVcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXIgcHItbWQgYWRkX2J1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID17dXBkYXRlQ0RhdGF9PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZvbnQyNFwiPiYjNDM7PC9zcGFuPkFkZCBub2RlXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cdDwvY2VudGVyPlxuXHQ8RGlhbG9nIGJpbmQ6dmlzaWJsZT17c3RhdGUub3BlbkltYWdlRGlhbG9nfSBkaXNhYmxlRW5mb3JjZUZvY3VzPXt0cnVlfSBzdHlsZT17J3dpZHRoOjYwMHB4Oyd9PlxuXHRcdFx0XHQ8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjogbGVmdDtmb250LXdlaWdodDpib2xkO1wiIGNsYXNzPVwibWItNVwiPlxuXHRcdFx0XHRcdDxkaXY+QWRkIEltYWdlPC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdCAgICAgICAgXHQ8ZGl2PlxuXHRcdCAgICAgICAgXHRcdDxkaXYgY2xhc3M9XCJpbWFnZURpYWxvZ1wiPlxuXHRcdFx0XHQgICAgICAgIFx0PGRpdiBjbGFzcz1cInJvdyBteC0wXCI+XG5cdFx0XHRcdFx0XHQgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNiBweC0xXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsIGZvbnQtd2VpZ2h0LW5vcm1hbCBtYi0wXCIgZm9yPVwiTWF0Y2hsaXN0SW1nXCI+QmFja2dyb3VuZCBJbWFnZTwvbGFiZWw+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1tZFwiIGlkPVwiTWF0Y2hsaXN0SW1nXCIgcGxhY2Vob2xkZXI9XCJJbWFnZSB1cmxcIiAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQgICAgICAgIDwvZGl2PlxuXHRcdFx0XHRcdFx0ICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTYgcHgtMVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbCBmb250LXdlaWdodC1ub3JtYWwgbWItMFwiIGZvcj1cIk1hdGNobGlzdEFsdFwiPkJhY2tncm91bmQgQWx0PC9sYWJlbD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLW1kXCIgaWQ9XCJNYXRjaGxpc3RBbHRcIiBwbGFjZWhvbGRlcj1cIkJhY2tncm91bmQgYWx0IHRleHRcIiAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQgICAgICAgIDwvZGl2PlxuXHRcdFx0XHRcdFx0ICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTYgcHgtMVwiPlxuXHRcdFx0XHRcdFx0ICAgIFx0XHQ8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnlcIiBvbjpjbGljaz17b3Blbk1lZGlhRGlhbG9nfT5VcGxvYWQgSW1hZ2U8L2J1dHRvbj5cblx0XHRcdFx0XHRcdCAgICBcdDwvZGl2PlxuXHRcdFx0XHRcdFx0ICAgIDwvZGl2PlxuXHRcdFx0XHQgICAgICAgIDwvZGl2PlxuXHRcdCAgICAgICAgXHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgc2xvdD1cImZvb3RlclwiIGNsYXNzPVwic3ZlbHRlRm9vdGVyXCI+XG5cdFx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjYW5jZWxfYnRuX3BvcCBidG4gYnRuLWxpZ2h0IGNvbG9yZ3JheTFcIiB2YXJpYW50PVwiY29udGFpbmVkXCIgb246Y2xpY2s9e2Nsb3NlSW1hZ2VEaWFsb2d9IHZhbHVlPXtsLmNhbmNlbH0gLz5cblx0XHRcdFx0XHRcdFx0PEJ1dHRvbiB2YXJpYW50PVwiY29udGFpbmVkXCIgaWQ9XCJjZGF0YVwiIG9uOmNsaWNrPXtpbnNlcnRJbWFnZX0gY2xhc3M9XCJ0ZXh0LXdoaXRlIGJnLXByaW1hcnlcIj5cblx0XHRcdFx0XHRcdFx0XHREb25lXG5cdFx0XHRcdFx0XHRcdDwvQnV0dG9uPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvRGlhbG9nPlxuXHRcdFx0XHRcblx0XHRcdFx0PERpYWxvZ1xuXHRcdFx0XHRcdGJpbmQ6dmlzaWJsZT17c3RhdGUub3BlbkRlbGV0ZURpYWxvZ31cblx0XHRcdFx0XHRzdHlsZT17J3dpZHRoOjUwMHB4Oyd9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8ZGl2IHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZDtcIj57bC5zYXZlX2hlYWRlcn08L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cInJvd1wiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJjb2wtbWQtMTJcIiBzdHlsZT17J21hcmdpbi10b3A6NDBweDttYXJnaW4tYm90dG9tOjQwcHg7J30+e2wuZGVsX2NvbmZpcm1hdGlvbn08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XG5cblx0XHRcdFx0XHQ8ZGl2IHNsb3Q9XCJmb290ZXJcIiBjbGFzcz1cInN2ZWx0ZUZvb3RlclwiPlxuXHRcdFx0XHRcdFx0PEJ1dHRvbiB2YXJpYW50PVwiY29udGFpbmVkXCIgb246Y2xpY2s9e3JlbW92ZVJvd31cblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJiZy1wcmltYXJ5IHRleHQtd2hpdGVcIj4gWWVzIDwvQnV0dG9uPlxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJidXR0b25cIiB2YXJpYW50PVwiY29udGFpbmVkXCIgb246Y2xpY2s9eygpID0+IHtzdGF0ZS5vcGVuRGVsZXRlRGlhbG9nID0gZmFsc2U7fX0gY2xhc3M9XCJidG4gYnRuLWxpZ2h0IGNvbG9yZ3JheVwiIHZhbHVlPVwiTm9cIiAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdDwvRGlhbG9nPlxuPC9tYWluPlxuPHN0eWxlPlxuXG5cdFxuXG5cdC5jb2xvcmdyYXkge1xuICAgICAgICB3aWR0aDo1NnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1LCAyMDYsIDIwNik7XG4gICAgfVxuXHQuY29sb3JncmF5MSB7XG5cdFx0d2lkdGg6NzRweDtcblx0XHRiYWNrZ3JvdW5kOiAjRTBFMEUwO1xuXHR9XG5cblx0LmZvbnQyNCB7XG5cdFx0Zm9udC1zaXplOiAyMnB4ICFpbXBvcnRhbnQ7XG5cdFx0bWFyZ2luLXJpZ2h0OiA1cHg7XG4gICAgfVxuXG5cdC5hZGRfYnV0dG9uIHtcblx0XHRoZWlnaHQ6MzFweDtcblx0fVxuXG5cdFxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBdTZCQyxVQUFVLGVBQUMsQ0FBQyxBQUNMLE1BQU0sSUFBSSxDQUNWLGdCQUFnQixDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEFBQ3hDLENBQUMsQUFDSixXQUFXLGVBQUMsQ0FBQyxBQUNaLE1BQU0sSUFBSSxDQUNWLFVBQVUsQ0FBRSxPQUFPLEFBQ3BCLENBQUMsQUFFRCxPQUFPLGVBQUMsQ0FBQyxBQUNSLFNBQVMsQ0FBRSxJQUFJLENBQUMsVUFBVSxDQUMxQixZQUFZLENBQUUsR0FBRyxBQUNmLENBQUMsQUFFSixXQUFXLGVBQUMsQ0FBQyxBQUNaLE9BQU8sSUFBSSxBQUNaLENBQUMifQ== */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[63] = list[i];
	child_ctx[65] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[66] = list[i];
	child_ctx[68] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[60] = list[i];
	child_ctx[62] = i;
	return child_ctx;
}

// (713:36) <Checkbox                                         checked={state.drag_mode}                                         on:click = {(e)=>{changeSetting("2",e)}}                                         id="isDragDrop"                                         color="primary"                                        style="position:relative;right:10px;">
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Drag & Drop");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(713:36) <Checkbox                                         checked={state.drag_mode}                                         on:click = {(e)=>{changeSetting(\\\"2\\\",e)}}                                         id=\\\"isDragDrop\\\"                                         color=\\\"primary\\\"                                        style=\\\"position:relative;right:10px;\\\">",
		ctx
	});

	return block;
}

// (721:36) <Checkbox                                                                                  on:click = {(e)=>{changeSetting("3",e)}}                                         id="isSwap"                                         color="primary"                                     >
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Swap List");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(721:36) <Checkbox                                                                                  on:click = {(e)=>{changeSetting(\\\"3\\\",e)}}                                         id=\\\"isSwap\\\"                                         color=\\\"primary\\\"                                     >",
		ctx
	});

	return block;
}

// (731:36) <Checkbox                                          defaultChecked = {(state.isalgo == true ? true : false)}                                         on:click = {changeisalgo}                                          name = {"isalgo"}                                          id = {"isalgo"}                                         color="primary"                                     >
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Algorithmic");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(731:36) <Checkbox                                          defaultChecked = {(state.isalgo == true ? true : false)}                                         on:click = {changeisalgo}                                          name = {\\\"isalgo\\\"}                                          id = {\\\"isalgo\\\"}                                         color=\\\"primary\\\"                                     >",
		ctx
	});

	return block;
}

// (814:24) {:else}
function create_else_block(ctx) {
	let div8;
	let div6;
	let div2;
	let div0;
	let textarea0;
	let textarea0_style_value;
	let textarea0_class_value;
	let textarea0_value_value;
	let t0;
	let show_if_3 = /*data*/ ctx[60].value2.charAt(0) == "*";
	let div0_style_value;
	let t1;
	let div1;
	let show_if_2 = /*data*/ ctx[60].value2.charAt(0) == "*";
	let t2;
	let button0;
	let span0;
	let t3;
	let div5;
	let div3;
	let textarea1;
	let textarea1_style_value;
	let textarea1_class_value;
	let textarea1_value_value;
	let t4;
	let show_if_1 = /*data*/ ctx[60].value1.charAt(0) == "*";
	let div3_style_value;
	let t5;
	let div4;
	let show_if = /*data*/ ctx[60].value1.charAt(0) == "*";
	let t6;
	let button1;
	let span1;
	let t7;
	let div7;
	let a;
	let span2;
	let t8;
	let div8_key_value;
	let mounted;
	let dispose;

	function change_handler_2(...args) {
		return /*change_handler_2*/ ctx[32](/*data*/ ctx[60], /*i*/ ctx[62], ...args);
	}

	let if_block0 = show_if_3 && create_if_block_8(ctx);
	let if_block1 = show_if_2 && create_if_block_7(ctx);

	function click_handler_7(...args) {
		return /*click_handler_7*/ ctx[33](/*i*/ ctx[62], ...args);
	}

	function change_handler_3(...args) {
		return /*change_handler_3*/ ctx[34](/*data*/ ctx[60], /*i*/ ctx[62], ...args);
	}

	let if_block2 = show_if_1 && create_if_block_6(ctx);
	let if_block3 = show_if && create_if_block_5(ctx);

	function click_handler_8(...args) {
		return /*click_handler_8*/ ctx[35](/*i*/ ctx[62], ...args);
	}

	function click_handler_9(...args) {
		return /*click_handler_9*/ ctx[36](/*data*/ ctx[60], ...args);
	}

	const block = {
		c: function create() {
			div8 = element("div");
			div6 = element("div");
			div2 = element("div");
			div0 = element("div");
			textarea0 = element("textarea");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			button0 = element("button");
			span0 = element("span");
			t3 = space();
			div5 = element("div");
			div3 = element("div");
			textarea1 = element("textarea");
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			div4 = element("div");
			if (if_block3) if_block3.c();
			t6 = space();
			button1 = element("button");
			span1 = element("span");
			t7 = space();
			div7 = element("div");
			a = element("a");
			span2 = element("span");
			t8 = space();
			attr_dev(textarea0, "rows", "3");
			attr_dev(textarea0, "cols", "20");
			attr_dev(textarea0, "style", textarea0_style_value = "resize:none;");

			attr_dev(textarea0, "class", textarea0_class_value = "" + (null_to_empty(/*data*/ ctx[60].value2.charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62]
			: "form-control textarea_2_" + /*i*/ ctx[62]) + " svelte-1kpz00h"));

			attr_dev(textarea0, "id", "matchList2");
			textarea0.value = textarea0_value_value = /*data*/ ctx[60].value2;
			add_location(textarea0, file, 819, 48, 32179);
			attr_dev(div0, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div0, "style", div0_style_value = "borderRadius:3px;");
			add_location(div0, file, 818, 44, 32041);
			attr_dev(span0, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span0, "data-bs-toggle", "tooltip");
			attr_dev(span0, "data-bs-placement", "right");
			attr_dev(span0, "title", "Add Image");
			add_location(span0, file, 830, 52, 33556);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-outline-primary btn-sm edit_btn bg-white");
			add_location(button0, file, 829, 48, 33374);
			attr_dev(div1, "class", "pull-right mt");
			add_location(div1, file, 825, 44, 32983);
			attr_dev(div2, "class", "pull-left d-flex align-items-center");
			add_location(div2, file, 817, 40, 31947);
			attr_dev(textarea1, "rows", "3");
			attr_dev(textarea1, "cols", "20");
			attr_dev(textarea1, "style", textarea1_style_value = "resize:none;");

			attr_dev(textarea1, "class", textarea1_class_value = "" + (null_to_empty(/*data*/ ctx[60].value1.charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62]
			: "form-control textarea_1_" + /*i*/ ctx[62]) + " svelte-1kpz00h"));

			attr_dev(textarea1, "id", "matchList1");
			textarea1.value = textarea1_value_value = /*data*/ ctx[60].value1;
			add_location(textarea1, file, 837, 48, 34185);
			attr_dev(div3, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div3, "style", div3_style_value = "" + ("border-radius:3px" + "}"));
			add_location(div3, file, 836, 44, 34046);
			attr_dev(span1, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Add Image");
			add_location(span1, file, 848, 52, 35499);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm edit_btn bg-white");
			add_location(button1, file, 847, 48, 35317);
			attr_dev(div4, "class", "pull-right mt");
			add_location(div4, file, 843, 44, 34927);
			attr_dev(div5, "class", "pull-right d-flex align-items-center");
			add_location(div5, file, 835, 40, 33951);
			attr_dev(div6, "class", "pointer d-inline-block clear-both light-cyan-bg mx-0 my-1 p-2 width10");
			add_location(div6, file, 816, 36, 31823);
			attr_dev(span2, "aria-hidden", "true");
			attr_dev(span2, "class", "icomoon icomoon-new-24px-delete-1 s3 delete_match_node py-1");
			attr_dev(span2, "tabindex", "0");
			attr_dev(span2, "data-bs-toggle", "tooltip");
			attr_dev(span2, "data-bs-placement", "right");
			attr_dev(span2, "title", "Delete");
			add_location(span2, file, 855, 44, 36063);
			add_location(a, file, 854, 40, 35953);
			attr_dev(div7, "class", "width1 float-right");
			add_location(div7, file, 853, 36, 35880);
			attr_dev(div8, "key", div8_key_value = /*i*/ ctx[62]);
			attr_dev(div8, "class", "d-flex align-items-center mb-2");
			add_location(div8, file, 815, 32, 31734);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div8, anchor);
			append_dev(div8, div6);
			append_dev(div6, div2);
			append_dev(div2, div0);
			append_dev(div0, textarea0);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, button0);
			append_dev(button0, span0);
			append_dev(div6, t3);
			append_dev(div6, div5);
			append_dev(div5, div3);
			append_dev(div3, textarea1);
			append_dev(div3, t4);
			if (if_block2) if_block2.m(div3, null);
			append_dev(div5, t5);
			append_dev(div5, div4);
			if (if_block3) if_block3.m(div4, null);
			append_dev(div4, t6);
			append_dev(div4, button1);
			append_dev(button1, span1);
			append_dev(div8, t7);
			append_dev(div8, div7);
			append_dev(div7, a);
			append_dev(a, span2);
			append_dev(div8, t8);

			if (!mounted) {
				dispose = [
					listen_dev(textarea0, "change", change_handler_2, false, false, false),
					listen_dev(button0, "click", click_handler_7, false, false, false),
					listen_dev(textarea1, "change", change_handler_3, false, false, false),
					listen_dev(button1, "click", click_handler_8, false, false, false),
					listen_dev(a, "click", click_handler_9, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*localCData*/ 4 && textarea0_class_value !== (textarea0_class_value = "" + (null_to_empty(/*data*/ ctx[60].value2.charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62]
			: "form-control textarea_2_" + /*i*/ ctx[62]) + " svelte-1kpz00h"))) {
				attr_dev(textarea0, "class", textarea0_class_value);
			}

			if (dirty[0] & /*localCData*/ 4 && textarea0_value_value !== (textarea0_value_value = /*data*/ ctx[60].value2)) {
				prop_dev(textarea0, "value", textarea0_value_value);
			}

			if (dirty[0] & /*localCData*/ 4) show_if_3 = /*data*/ ctx[60].value2.charAt(0) == "*";

			if (show_if_3) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*localCData*/ 4) show_if_2 = /*data*/ ctx[60].value2.charAt(0) == "*";

			if (show_if_2) {
				if (if_block1) ; else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*localCData*/ 4 && textarea1_class_value !== (textarea1_class_value = "" + (null_to_empty(/*data*/ ctx[60].value1.charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62]
			: "form-control textarea_1_" + /*i*/ ctx[62]) + " svelte-1kpz00h"))) {
				attr_dev(textarea1, "class", textarea1_class_value);
			}

			if (dirty[0] & /*localCData*/ 4 && textarea1_value_value !== (textarea1_value_value = /*data*/ ctx[60].value1)) {
				prop_dev(textarea1, "value", textarea1_value_value);
			}

			if (dirty[0] & /*localCData*/ 4) show_if_1 = /*data*/ ctx[60].value1.charAt(0) == "*";

			if (show_if_1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_6(ctx);
					if_block2.c();
					if_block2.m(div3, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*localCData*/ 4) show_if = /*data*/ ctx[60].value1.charAt(0) == "*";

			if (show_if) {
				if (if_block3) ; else {
					if_block3 = create_if_block_5(ctx);
					if_block3.c();
					if_block3.m(div4, t6);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div8);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(814:24) {:else}",
		ctx
	});

	return block;
}

// (747:24) {#if state.isalgo === true}
function create_if_block(ctx) {
	let div0;
	let t0_value = (/*tempdata1*/ ctx[0] = /*data*/ ctx[60].value1.split("%%")) + "";
	let t0;
	let t1;
	let t2_value = (/*tempdata2*/ ctx[1] = /*data*/ ctx[60].value2.split("%%")) + "";
	let t2;
	let t3;
	let div6;
	let div4;
	let div2;
	let t4;
	let div1;
	let button;
	let span0;
	let t6;
	let button_class_value;
	let t7;
	let div3;
	let t8;
	let div5;
	let a;
	let span1;
	let t9;
	let div6_key_value;
	let div6_dir_value;
	let mounted;
	let dispose;
	let each_value_2 = /*tempdata2*/ ctx[1];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = /*tempdata1*/ ctx[0];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	function click_handler_6(...args) {
		return /*click_handler_6*/ ctx[31](/*data*/ ctx[60], ...args);
	}

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			div6 = element("div");
			div4 = element("div");
			div2 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t4 = space();
			div1 = element("div");
			button = element("button");
			span0 = element("span");
			span0.textContent = "+";
			t6 = text("Add item");
			t7 = space();
			div3 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t8 = space();
			div5 = element("div");
			a = element("a");
			span1 = element("span");
			t9 = space();
			attr_dev(div0, "class", "h-imp");
			add_location(div0, file, 748, 7, 24475);
			attr_dev(span0, "class", "font24 svelte-1kpz00h");
			add_location(span0, file, 781, 52, 28056);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", button_class_value = "" + (null_to_empty("add_button px-1 btn btn-outline-primary btn-sm bg-white d-flex align-items-center pr-2 " + "listitem" + /*i*/ ctx[62]) + " svelte-1kpz00h"));
			add_location(button, file, 780, 13, 27834);
			attr_dev(div1, "class", "float-left ms-1");
			add_location(div1, file, 779, 48, 27791);
			attr_dev(div2, "class", "float-left clear-both");
			add_location(div2, file, 756, 44, 24908);
			attr_dev(div3, "class", "pull-right");
			add_location(div3, file, 784, 44, 28257);
			attr_dev(div4, "class", "d-inline-block clear-both pointer light-cyan-bg mx-0 my-1 p-2 width10");
			add_location(div4, file, 755, 40, 24780);
			attr_dev(span1, "aria-hidden", "true");
			attr_dev(span1, "class", "delete_match_node_auth icomoon icomoon-new-24px-delete-1 s3 py-1");
			attr_dev(span1, "tabindex", "0");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Delete");
			add_location(span1, file, 809, 48, 31317);
			add_location(a, file, 808, 44, 31203);
			attr_dev(div5, "class", "width1 float-right");
			add_location(div5, file, 807, 40, 31126);
			attr_dev(div6, "key", div6_key_value = /*i*/ ctx[62]);
			attr_dev(div6, "class", "d-flex align-items-center mb-2");
			attr_dev(div6, "dir", div6_dir_value = /*state*/ ctx[3].dir);
			add_location(div6, file, 754, 36, 24671);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, t0);
			append_dev(div0, t1);
			append_dev(div0, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, div6, anchor);
			append_dev(div6, div4);
			append_dev(div4, div2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div2, null);
			}

			append_dev(div2, t4);
			append_dev(div2, div1);
			append_dev(div1, button);
			append_dev(button, span0);
			append_dev(button, t6);
			append_dev(div4, t7);
			append_dev(div4, div3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div3, null);
			}

			append_dev(div6, t8);
			append_dev(div6, div5);
			append_dev(div5, a);
			append_dev(a, span1);
			append_dev(div6, t9);

			if (!mounted) {
				dispose = [
					listen_dev(button, "click", /*addListItem*/ ctx[17].bind(this, /*i*/ ctx[62]), false, false, false),
					listen_dev(a, "click", click_handler_6, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*tempdata1, localCData*/ 5 && t0_value !== (t0_value = (/*tempdata1*/ ctx[0] = /*data*/ ctx[60].value1.split("%%")) + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*tempdata2, localCData*/ 6 && t2_value !== (t2_value = (/*tempdata2*/ ctx[1] = /*data*/ ctx[60].value2.split("%%")) + "")) set_data_dev(t2, t2_value);

			if (dirty[0] & /*state, removetextbox, openImageDialogAlgo, tempdata2, editalgoCData*/ 69898) {
				each_value_2 = /*tempdata2*/ ctx[1];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div2, t4);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (dirty[0] & /*state, removetextbox, openImageDialogAlgo, tempdata1, editalgoCData*/ 69897) {
				each_value_1 = /*tempdata1*/ ctx[0];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*state*/ 8 && div6_dir_value !== (div6_dir_value = /*state*/ ctx[3].dir)) {
				attr_dev(div6, "dir", div6_dir_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div6);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(747:24) {#if state.isalgo === true}",
		ctx
	});

	return block;
}

// (822:48) {#if data.value2.charAt(0) == "*"}
function create_if_block_8(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value2.substr(1).split("##")[0].split("%%")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*data*/ ctx[60].value2.split("##")[1]
			? /*data*/ ctx[60].value2.split("##")[1]
			: null);

			add_location(img, file, 822, 52, 32615);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*localCData*/ 4 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value2.substr(1).split("##")[0].split("%%")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*localCData*/ 4 && img_alt_value !== (img_alt_value = /*data*/ ctx[60].value2.split("##")[1]
			? /*data*/ ctx[60].value2.split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(822:48) {#if data.value2.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (827:48) {#if data.value2.charAt(0) == "*"}
function create_if_block_7(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 827, 52, 33147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(827:48) {#if data.value2.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (840:48) {#if data.value1.charAt(0) == "*"}
function create_if_block_6(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value1.substr(1).split("##")[0].split("%%")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*data*/ ctx[60].value1.split("##")[1]
			? /*data*/ ctx[60].value1.split("##")[1]
			: null);

			add_location(img, file, 840, 52, 34573);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*localCData*/ 4 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value1.substr(1).split("##")[0].split("%%")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*localCData*/ 4 && img_alt_value !== (img_alt_value = /*data*/ ctx[60].value1.split("##")[1]
			? /*data*/ ctx[60].value1.split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(840:48) {#if data.value1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (845:48) {#if data.value1.charAt(0) == "*"}
function create_if_block_5(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 845, 52, 35090);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(845:48) {#if data.value1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (764:64) {#if temp.charAt(0) == "*"}
function create_if_block_4(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp*/ ctx[66].substr(1).split("##")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*temp*/ ctx[66].split("##")[1]
			? /*temp*/ ctx[66].split("##")[1]
			: null);

			add_location(img, file, 764, 68, 25750);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*tempdata2*/ 2 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp*/ ctx[66].substr(1).split("##")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*tempdata2*/ 2 && img_alt_value !== (img_alt_value = /*temp*/ ctx[66].split("##")[1]
			? /*temp*/ ctx[66].split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(764:64) {#if temp.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (770:64) {#if temp.charAt(0) == "*"}
function create_if_block_3(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 770, 68, 26380);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(770:64) {#if temp.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (759:48) {#each tempdata2 as temp, j}
function create_each_block_2(ctx) {
	let div2;
	let div0;
	let textarea;
	let textarea_style_value;
	let textarea_class_value;
	let textarea_value_value;
	let t0;
	let show_if_1 = /*temp*/ ctx[66].charAt(0) == "*";
	let div0_style_value;
	let t1;
	let div1;
	let show_if = /*temp*/ ctx[66].charAt(0) == "*";
	let t2;
	let button0;
	let span0;
	let t3;
	let button1;
	let span1;
	let button1_style_value;
	let mounted;
	let dispose;

	function change_handler(...args) {
		return /*change_handler*/ ctx[25](/*temp*/ ctx[66], /*i*/ ctx[62], /*j*/ ctx[68], ...args);
	}

	let if_block0 = show_if_1 && create_if_block_4(ctx);
	let if_block1 = show_if && create_if_block_3(ctx);

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[26](/*i*/ ctx[62], /*j*/ ctx[68], ...args);
	}

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[27](/*i*/ ctx[62], /*j*/ ctx[68], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			button0 = element("button");
			span0 = element("span");
			t3 = space();
			button1 = element("button");
			span1 = element("span");
			attr_dev(textarea, "rows", "3");
			attr_dev(textarea, "cols", "20");
			attr_dev(textarea, "style", textarea_style_value = "resize:none;");

			attr_dev(textarea, "class", textarea_class_value = "" + (null_to_empty(/*temp*/ ctx[66].charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]
			: "form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]) + " svelte-1kpz00h"));

			attr_dev(textarea, "id", "matchList2");
			textarea.value = textarea_value_value = /*temp*/ ctx[66];
			add_location(textarea, file, 762, 64, 25346);
			attr_dev(div0, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div0, "style", div0_style_value = "border-radius:3px;");
			add_location(div0, file, 761, 60, 25191);
			attr_dev(span0, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span0, "data-bs-toggle", "tooltip");
			attr_dev(span0, "data-bs-placement", "right");
			attr_dev(span0, "title", "Add Image");
			add_location(span0, file, 773, 242, 26881);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "d-block btn btn-outline-primary btn-sm edit_btn bg-white mb-1");
			add_location(button0, file, 773, 64, 26703);
			attr_dev(span1, "class", "icomoon-24px-delete-1 d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Delete");
			add_location(span1, file, 774, 296, 27345);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm edit_btn textdel bg-white");

			attr_dev(button1, "style", button1_style_value = /*state*/ ctx[3].isalgo
			? { display: "block" }
			: { display: "none" });

			add_location(button1, file, 774, 64, 27113);
			attr_dev(div1, "class", "pull-right");
			add_location(div1, file, 768, 60, 26194);
			attr_dev(div2, "class", "d-flex align-items-center");
			add_location(div2, file, 760, 56, 25091);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, textarea);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, button0);
			append_dev(button0, span0);
			append_dev(div1, t3);
			append_dev(div1, button1);
			append_dev(button1, span1);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", change_handler, false, false, false),
					listen_dev(button0, "click", click_handler_2, false, false, false),
					listen_dev(button1, "click", click_handler_3, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*tempdata2*/ 2 && textarea_class_value !== (textarea_class_value = "" + (null_to_empty(/*temp*/ ctx[66].charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]
			: "form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]) + " svelte-1kpz00h"))) {
				attr_dev(textarea, "class", textarea_class_value);
			}

			if (dirty[0] & /*tempdata2*/ 2 && textarea_value_value !== (textarea_value_value = /*temp*/ ctx[66])) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*tempdata2*/ 2) show_if_1 = /*temp*/ ctx[66].charAt(0) == "*";

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*tempdata2*/ 2) show_if = /*temp*/ ctx[66].charAt(0) == "*";

			if (show_if) {
				if (if_block1) ; else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*state*/ 8 && button1_style_value !== (button1_style_value = /*state*/ ctx[3].isalgo
			? { display: "block" }
			: { display: "none" })) {
				attr_dev(button1, "style", button1_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(759:48) {#each tempdata2 as temp, j}",
		ctx
	});

	return block;
}

// (792:64) {#if temp1.charAt(0) == "*"}
function create_if_block_2(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp1*/ ctx[63].substr(1).split("##")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*temp1*/ ctx[63].split("##")[1]
			? /*temp1*/ ctx[63].split("##")[1]
			: null);

			add_location(img, file, 792, 68, 29139);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*tempdata1*/ 1 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp1*/ ctx[63].substr(1).split("##")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*tempdata1*/ 1 && img_alt_value !== (img_alt_value = /*temp1*/ ctx[63].split("##")[1]
			? /*temp1*/ ctx[63].split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(792:64) {#if temp1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (798:64) {#if temp1.charAt(0) == "*"}
function create_if_block_1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 798, 68, 29759);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(798:64) {#if temp1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (787:48) {#each tempdata1 as temp1, k}
function create_each_block_1(ctx) {
	let div2;
	let div0;
	let textarea;
	let textarea_style_value;
	let textarea_class_value;
	let textarea_value_value;
	let t0;
	let show_if_1 = /*temp1*/ ctx[63].charAt(0) == "*";
	let div0_style_value;
	let t1;
	let div1;
	let show_if = /*temp1*/ ctx[63].charAt(0) == "*";
	let t2;
	let button0;
	let span0;
	let t3;
	let button1;
	let span1;
	let button1_style_value;
	let t4;
	let mounted;
	let dispose;

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[28](/*temp1*/ ctx[63], /*i*/ ctx[62], /*k*/ ctx[65], ...args);
	}

	let if_block0 = show_if_1 && create_if_block_2(ctx);
	let if_block1 = show_if && create_if_block_1(ctx);

	function click_handler_4(...args) {
		return /*click_handler_4*/ ctx[29](/*i*/ ctx[62], /*k*/ ctx[65], ...args);
	}

	function click_handler_5(...args) {
		return /*click_handler_5*/ ctx[30](/*i*/ ctx[62], /*k*/ ctx[65], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			button0 = element("button");
			span0 = element("span");
			t3 = space();
			button1 = element("button");
			span1 = element("span");
			t4 = space();
			attr_dev(textarea, "rows", "3");
			attr_dev(textarea, "cols", "20");
			attr_dev(textarea, "style", textarea_style_value = "resize:none;");

			attr_dev(textarea, "class", textarea_class_value = "" + (null_to_empty(/*temp1*/ ctx[63].charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]
			: "form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]) + " svelte-1kpz00h"));

			attr_dev(textarea, "id", "matchList1");
			textarea.value = textarea_value_value = /*temp1*/ ctx[63];
			add_location(textarea, file, 790, 64, 28733);
			attr_dev(div0, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div0, "style", div0_style_value = "border-radius:3px;");
			add_location(div0, file, 789, 60, 28578);
			attr_dev(span0, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span0, "data-bs-toggle", "tooltip");
			attr_dev(span0, "data-bs-placement", "right");
			attr_dev(span0, "title", "Add Image");
			add_location(span0, file, 800, 242, 30195);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "d-block btn btn-outline-primary btn-sm edit_btn bg-white mb-1");
			add_location(button0, file, 800, 64, 30017);
			attr_dev(span1, "class", "icomoon-24px-delete-1 d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Delete");
			add_location(span1, file, 801, 292, 30642);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm edit_btn textdel bg-white");

			attr_dev(button1, "style", button1_style_value = /*state*/ ctx[3].isalgo
			? "display:block;"
			: "display : none");

			add_location(button1, file, 801, 64, 30414);
			attr_dev(div1, "class", "pull-right");
			add_location(div1, file, 796, 60, 29573);
			attr_dev(div2, "class", "d-flex align-items-center");
			add_location(div2, file, 788, 56, 28478);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, textarea);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, button0);
			append_dev(button0, span0);
			append_dev(div1, t3);
			append_dev(div1, button1);
			append_dev(button1, span1);
			append_dev(div2, t4);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", change_handler_1, false, false, false),
					listen_dev(button0, "click", click_handler_4, false, false, false),
					listen_dev(button1, "click", click_handler_5, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*tempdata1*/ 1 && textarea_class_value !== (textarea_class_value = "" + (null_to_empty(/*temp1*/ ctx[63].charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]
			: "form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]) + " svelte-1kpz00h"))) {
				attr_dev(textarea, "class", textarea_class_value);
			}

			if (dirty[0] & /*tempdata1*/ 1 && textarea_value_value !== (textarea_value_value = /*temp1*/ ctx[63])) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*tempdata1*/ 1) show_if_1 = /*temp1*/ ctx[63].charAt(0) == "*";

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*tempdata1*/ 1) show_if = /*temp1*/ ctx[63].charAt(0) == "*";

			if (show_if) {
				if (if_block1) ; else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*state*/ 8 && button1_style_value !== (button1_style_value = /*state*/ ctx[3].isalgo
			? "display:block;"
			: "display : none")) {
				attr_dev(button1, "style", button1_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(787:48) {#each tempdata1 as temp1, k}",
		ctx
	});

	return block;
}

// (745:16) {#each localCData as data, i}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*state*/ ctx[3].isalgo === true) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(745:16) {#each localCData as data, i}",
		ctx
	});

	return block;
}

// (904:7) <Button variant="contained" id="cdata" on:click={insertImage} class="text-white bg-primary">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Done");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(904:7) <Button variant=\\\"contained\\\" id=\\\"cdata\\\" on:click={insertImage} class=\\\"text-white bg-primary\\\">",
		ctx
	});

	return block;
}

// (902:6) <div slot="footer" class="svelteFooter">
function create_footer_slot_1(ctx) {
	let div;
	let input;
	let input_value_value;
	let t;
	let button;
	let current;
	let mounted;
	let dispose;

	button = new Button({
			props: {
				variant: "contained",
				id: "cdata",
				class: "text-white bg-primary",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*insertImage*/ ctx[14]);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t = space();
			create_component(button.$$.fragment);
			attr_dev(input, "type", "button");
			attr_dev(input, "class", "cancel_btn_pop btn btn-light colorgray1 svelte-1kpz00h");
			attr_dev(input, "variant", "contained");
			input.value = input_value_value = Lang.cancel;
			add_location(input, file, 902, 7, 38177);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file, 901, 6, 38129);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t);
			mount_component(button, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "click", /*closeImageDialog*/ ctx[13], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot_1.name,
		type: "slot",
		source: "(902:6) <div slot=\\\"footer\\\" class=\\\"svelteFooter\\\">",
		ctx
	});

	return block;
}

// (877:1) <Dialog bind:visible={state.openImageDialog} disableEnforceFocus={true} style={'width:600px;'}>
function create_default_slot_2(ctx) {
	let div1;
	let div0;
	let t1;
	let div9;
	let div8;
	let div7;
	let div3;
	let div2;
	let label0;
	let t3;
	let input0;
	let t4;
	let div5;
	let div4;
	let label1;
	let t6;
	let input1;
	let t7;
	let div6;
	let button;
	let t9;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Add Image";
			t1 = space();
			div9 = element("div");
			div8 = element("div");
			div7 = element("div");
			div3 = element("div");
			div2 = element("div");
			label0 = element("label");
			label0.textContent = "Background Image";
			t3 = space();
			input0 = element("input");
			t4 = space();
			div5 = element("div");
			div4 = element("div");
			label1 = element("label");
			label1.textContent = "Background Alt";
			t6 = space();
			input1 = element("input");
			t7 = space();
			div6 = element("div");
			button = element("button");
			button.textContent = "Upload Image";
			t9 = space();
			add_location(div0, file, 878, 5, 37115);
			set_style(div1, "text-align", "left");
			set_style(div1, "font-weight", "bold");
			attr_dev(div1, "class", "mb-5");
			add_location(div1, file, 877, 4, 37048);
			attr_dev(label0, "class", "control-label font-weight-normal mb-0");
			attr_dev(label0, "for", "MatchlistImg");
			add_location(label0, file, 885, 10, 37324);
			attr_dev(input0, "type", "text");
			attr_dev(input0, "class", "form-control form-control-md");
			attr_dev(input0, "id", "MatchlistImg");
			attr_dev(input0, "placeholder", "Image url");
			add_location(input0, file, 886, 10, 37431);
			attr_dev(div2, "class", "form-group");
			add_location(div2, file, 884, 9, 37289);
			attr_dev(div3, "class", "col-md-6 px-1");
			add_location(div3, file, 883, 14, 37252);
			attr_dev(label1, "class", "control-label font-weight-normal mb-0");
			attr_dev(label1, "for", "MatchlistAlt");
			add_location(label1, file, 891, 10, 37655);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "class", "form-control form-control-md");
			attr_dev(input1, "id", "MatchlistAlt");
			attr_dev(input1, "placeholder", "Background alt text");
			add_location(input1, file, 892, 10, 37760);
			attr_dev(div4, "class", "form-group");
			add_location(div4, file, 890, 9, 37620);
			attr_dev(div5, "class", "col-md-6 px-1");
			add_location(div5, file, 889, 14, 37583);
			attr_dev(button, "class", "btn btn-outline-primary");
			add_location(button, file, 896, 12, 37962);
			attr_dev(div6, "class", "col-md-6 px-1");
			add_location(div6, file, 895, 14, 37922);
			attr_dev(div7, "class", "row mx-0");
			add_location(div7, file, 882, 13, 37215);
			attr_dev(div8, "class", "imageDialog");
			add_location(div8, file, 881, 12, 37176);
			add_location(div9, file, 880, 11, 37158);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div9, anchor);
			append_dev(div9, div8);
			append_dev(div8, div7);
			append_dev(div7, div3);
			append_dev(div3, div2);
			append_dev(div2, label0);
			append_dev(div2, t3);
			append_dev(div2, input0);
			append_dev(div7, t4);
			append_dev(div7, div5);
			append_dev(div5, div4);
			append_dev(div4, label1);
			append_dev(div4, t6);
			append_dev(div4, input1);
			append_dev(div7, t7);
			append_dev(div7, div6);
			append_dev(div6, button);
			insert_dev(target, t9, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*openMediaDialog*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div9);
			if (detaching) detach_dev(t9);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(877:1) <Dialog bind:visible={state.openImageDialog} disableEnforceFocus={true} style={'width:600px;'}>",
		ctx
	});

	return block;
}

// (923:6) <Button variant="contained" on:click={removeRow}        class="bg-primary text-white">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Yes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(923:6) <Button variant=\\\"contained\\\" on:click={removeRow}        class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (922:5) <div slot="footer" class="svelteFooter">
function create_footer_slot(ctx) {
	let div;
	let button;
	let t;
	let input;
	let current;
	let mounted;
	let dispose;

	button = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*removeRow*/ ctx[18]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t = space();
			input = element("input");
			attr_dev(input, "type", "button");
			attr_dev(input, "variant", "contained");
			attr_dev(input, "class", "btn btn-light colorgray svelte-1kpz00h");
			input.value = "No";
			add_location(input, file, 924, 6, 38952);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file, 921, 5, 38798);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			append_dev(div, t);
			append_dev(div, input);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "click", /*click_handler_10*/ ctx[38], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(922:5) <div slot=\\\"footer\\\" class=\\\"svelteFooter\\\">",
		ctx
	});

	return block;
}

// (910:4) <Dialog      bind:visible={state.openDeleteDialog}      style={'width:500px;'}     >
function create_default_slot(ctx) {
	let div0;
	let t1;
	let div2;
	let div1;
	let span;
	let span_style_value;
	let t3;

	const block = {
		c: function create() {
			div0 = element("div");
			div0.textContent = `${Lang.save_header}`;
			t1 = space();
			div2 = element("div");
			div1 = element("div");
			span = element("span");
			span.textContent = `${Lang.del_confirmation}`;
			t3 = space();
			set_style(div0, "font-weight", "bold");
			add_location(div0, file, 913, 5, 38570);
			attr_dev(span, "class", "col-md-12");
			attr_dev(span, "style", span_style_value = "margin-top:40px;margin-bottom:40px;");
			add_location(span, file, 916, 6, 38664);
			attr_dev(div1, "class", "row");
			add_location(div1, file, 915, 6, 38640);
			add_location(div2, file, 914, 5, 38628);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, span);
			insert_dev(target, t3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
			if (detaching) detach_dev(t3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(910:4) <Dialog      bind:visible={state.openDeleteDialog}      style={'width:500px;'}     >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let center;
	let div12;
	let div9;
	let div8;
	let div2;
	let div0;
	let label0;
	let t1;
	let input0;
	let input0_value_value;
	let t2;
	let div1;
	let label1;
	let t4;
	let input1;
	let input1_value_value;
	let t5;
	let div4;
	let div3;
	let label2;
	let t7;
	let input2;
	let input2_value_value;
	let t8;
	let div7;
	let div5;
	let checkbox0;
	let t9;
	let checkbox1;
	let t10;
	let div6;
	let checkbox2;
	let t11;
	let div10;
	let t12;
	let div11;
	let button;
	let span;
	let t14;
	let t15;
	let dialog0;
	let updating_visible;
	let t16;
	let dialog1;
	let updating_visible_1;
	let current;
	let mounted;
	let dispose;

	checkbox0 = new Checkbox({
			props: {
				checked: /*state*/ ctx[3].drag_mode,
				id: "isDragDrop",
				color: "primary",
				style: "position:relative;right:10px;",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*click_handler*/ ctx[23]);

	checkbox1 = new Checkbox({
			props: {
				id: "isSwap",
				color: "primary",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*click_handler_1*/ ctx[24]);

	checkbox2 = new Checkbox({
			props: {
				defaultChecked: /*state*/ ctx[3].isalgo == true ? true : false,
				name: "isalgo",
				id: "isalgo",
				color: "primary",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox2.$on("click", /*changeisalgo*/ ctx[15]);
	let each_value = /*localCData*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function dialog0_visible_binding(value) {
		/*dialog0_visible_binding*/ ctx[37].call(null, value);
	}

	let dialog0_props = {
		disableEnforceFocus: true,
		style: "width:600px;",
		$$slots: {
			default: [create_default_slot_2],
			footer: [create_footer_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[3].openImageDialog !== void 0) {
		dialog0_props.visible = /*state*/ ctx[3].openImageDialog;
	}

	dialog0 = new Dialog({ props: dialog0_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog0, "visible", dialog0_visible_binding));

	function dialog1_visible_binding(value) {
		/*dialog1_visible_binding*/ ctx[39].call(null, value);
	}

	let dialog1_props = {
		style: "width:500px;",
		$$slots: {
			default: [create_default_slot],
			footer: [create_footer_slot]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[3].openDeleteDialog !== void 0) {
		dialog1_props.visible = /*state*/ ctx[3].openDeleteDialog;
	}

	dialog1 = new Dialog({ props: dialog1_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog1, "visible", dialog1_visible_binding));

	const block = {
		c: function create() {
			main = element("main");
			center = element("center");
			div12 = element("div");
			div9 = element("div");
			div8 = element("div");
			div2 = element("div");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = `${Lang.matchlist_heading1}`;
			t1 = space();
			input0 = element("input");
			t2 = space();
			div1 = element("div");
			label1 = element("label");
			label1.textContent = `${Lang.matchlist_heading2}`;
			t4 = space();
			input1 = element("input");
			t5 = space();
			div4 = element("div");
			div3 = element("div");
			label2 = element("label");
			label2.textContent = "Maxnode:";
			t7 = space();
			input2 = element("input");
			t8 = space();
			div7 = element("div");
			div5 = element("div");
			create_component(checkbox0.$$.fragment);
			t9 = space();
			create_component(checkbox1.$$.fragment);
			t10 = space();
			div6 = element("div");
			create_component(checkbox2.$$.fragment);
			t11 = space();
			div10 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t12 = space();
			div11 = element("div");
			button = element("button");
			span = element("span");
			span.textContent = "+";
			t14 = text("Add node");
			t15 = space();
			create_component(dialog0.$$.fragment);
			t16 = space();
			create_component(dialog1.$$.fragment);
			attr_dev(label0, "for", "listheading1");
			attr_dev(label0, "class", "mb-0 float-left");
			add_location(label0, file, 695, 28, 21614);
			attr_dev(input0, "type", "text");
			attr_dev(input0, "id", "listheading1");
			attr_dev(input0, "class", "form-control");
			input0.value = input0_value_value = /*state*/ ctx[3].listheading1;
			add_location(input0, file, 696, 28, 21723);
			attr_dev(div0, "class", "col-md-6 pr-1");
			add_location(div0, file, 694, 24, 21558);
			attr_dev(label1, "for", "listheading2");
			attr_dev(label1, "class", "mb-0 float-left");
			add_location(label1, file, 699, 28, 21944);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", "listheading2");
			attr_dev(input1, "class", "form-control");
			input1.value = input1_value_value = /*state*/ ctx[3].listheading2;
			add_location(input1, file, 700, 28, 22053);
			attr_dev(div1, "class", "col-md-6 pl-1");
			add_location(div1, file, 698, 24, 21888);
			attr_dev(div2, "class", "d-flex row");
			add_location(div2, file, 693, 20, 21509);
			attr_dev(label2, "for", "maxnode");
			attr_dev(label2, "class", "mb-0 float-left");
			add_location(label2, file, 705, 28, 22369);
			attr_dev(input2, "type", "text");
			attr_dev(input2, "id", "maxnode");
			attr_dev(input2, "class", "form-control");
			attr_dev(input2, "placeholder", "Enter number only 1 to 6");
			input2.value = input2_value_value = /*state*/ ctx[3].maxnode;
			add_location(input2, file, 706, 28, 22459);
			attr_dev(div3, "class", "h float-left w-sm mr-2");
			add_location(div3, file, 704, 24, 22304);
			attr_dev(div4, "class", "d-flex width1 float-left");
			add_location(div4, file, 703, 20, 22241);
			attr_dev(div5, "class", "mt-2 d-flex");
			add_location(div5, file, 710, 24, 22745);
			attr_dev(div6, "class", "mt-2");
			add_location(div6, file, 728, 24, 23650);
			attr_dev(div7, "class", "d-flex justify-content-between");
			add_location(div7, file, 709, 20, 22676);
			attr_dev(div8, "class", "border-bottom w-100 d-inline-block pb-0 px-3 pt-3");
			add_location(div8, file, 692, 16, 21425);
			attr_dev(div9, "class", "mb-1");
			add_location(div9, file, 691, 12, 21390);
			attr_dev(div10, "id", "matchListArea");
			attr_dev(div10, "class", "row-fluid p-2 clear-both");
			add_location(div10, file, 742, 12, 24282);
			attr_dev(span, "class", "font24 svelte-1kpz00h");
			add_location(span, file, 871, 20, 36834);
			attr_dev(button, "id", "add_node");
			attr_dev(button, "aria-label", "Add node");
			attr_dev(button, "class", "btn btn-outline-primary btn-sm d-flex align-items-center pr-md add_button svelte-1kpz00h");
			add_location(button, file, 866, 16, 36576);
			attr_dev(div11, "class", "text-left ml-2 pb-3");
			add_location(div11, file, 865, 12, 36526);
			attr_dev(div12, "id", "fixedMatchList");
			attr_dev(div12, "class", "border h-auto fwidth");
			add_location(div12, file, 690, 8, 21323);
			add_location(center, file, 689, 4, 21306);
			add_location(main, file, 688, 0, 21295);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, center);
			append_dev(center, div12);
			append_dev(div12, div9);
			append_dev(div9, div8);
			append_dev(div8, div2);
			append_dev(div2, div0);
			append_dev(div0, label0);
			append_dev(div0, t1);
			append_dev(div0, input0);
			append_dev(div2, t2);
			append_dev(div2, div1);
			append_dev(div1, label1);
			append_dev(div1, t4);
			append_dev(div1, input1);
			append_dev(div8, t5);
			append_dev(div8, div4);
			append_dev(div4, div3);
			append_dev(div3, label2);
			append_dev(div3, t7);
			append_dev(div3, input2);
			append_dev(div8, t8);
			append_dev(div8, div7);
			append_dev(div7, div5);
			mount_component(checkbox0, div5, null);
			append_dev(div5, t9);
			mount_component(checkbox1, div5, null);
			append_dev(div7, t10);
			append_dev(div7, div6);
			mount_component(checkbox2, div6, null);
			append_dev(div12, t11);
			append_dev(div12, div10);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div10, null);
			}

			append_dev(div12, t12);
			append_dev(div12, div11);
			append_dev(div11, button);
			append_dev(button, span);
			append_dev(button, t14);
			append_dev(main, t15);
			mount_component(dialog0, main, null);
			append_dev(main, t16);
			mount_component(dialog1, main, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "change", /*updateXml*/ ctx[4], false, false, false),
					listen_dev(input1, "change", /*updateXml*/ ctx[4], false, false, false),
					listen_dev(input2, "change", /*updateXml*/ ctx[4], false, false, false),
					listen_dev(button, "click", /*updateCData*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*state*/ 8 && input0_value_value !== (input0_value_value = /*state*/ ctx[3].listheading1) && input0.value !== input0_value_value) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (!current || dirty[0] & /*state*/ 8 && input1_value_value !== (input1_value_value = /*state*/ ctx[3].listheading2) && input1.value !== input1_value_value) {
				prop_dev(input1, "value", input1_value_value);
			}

			if (!current || dirty[0] & /*state*/ 8 && input2_value_value !== (input2_value_value = /*state*/ ctx[3].maxnode) && input2.value !== input2_value_value) {
				prop_dev(input2, "value", input2_value_value);
			}

			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 8) checkbox0_changes.checked = /*state*/ ctx[3].drag_mode;

			if (dirty[2] & /*$$scope*/ 128) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);
			const checkbox2_changes = {};
			if (dirty[0] & /*state*/ 8) checkbox2_changes.defaultChecked = /*state*/ ctx[3].isalgo == true ? true : false;

			if (dirty[2] & /*$$scope*/ 128) {
				checkbox2_changes.$$scope = { dirty, ctx };
			}

			checkbox2.$set(checkbox2_changes);

			if (dirty[0] & /*state, removeCData, localCData, tempdata1, removetextbox, openImageDialogAlgo, editalgoCData, addListItem, tempdata2, openImageDialog, editCData*/ 203663) {
				each_value = /*localCData*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div10, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const dialog0_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				dialog0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 8) {
				updating_visible = true;
				dialog0_changes.visible = /*state*/ ctx[3].openImageDialog;
				add_flush_callback(() => updating_visible = false);
			}

			dialog0.$set(dialog0_changes);
			const dialog1_changes = {};

			if (dirty[0] & /*state*/ 8 | dirty[2] & /*$$scope*/ 128) {
				dialog1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_1 && dirty[0] & /*state*/ 8) {
				updating_visible_1 = true;
				dialog1_changes.visible = /*state*/ ctx[3].openDeleteDialog;
				add_flush_callback(() => updating_visible_1 = false);
			}

			dialog1.$set(dialog1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);
			transition_in(checkbox2.$$.fragment, local);
			transition_in(dialog0.$$.fragment, local);
			transition_in(dialog1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			transition_out(checkbox2.$$.fragment, local);
			transition_out(dialog0.$$.fragment, local);
			transition_out(dialog1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_component(checkbox2);
			destroy_each(each_blocks, detaching);
			destroy_component(dialog0);
			destroy_component(dialog1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("MatchList", slots, []);
	let { editorState } = $$props;
	let { xml } = $$props;
	let { getChildXml } = $$props;
	let { smValidate } = $$props;

	// variables declration
	let timer = {};

	let tempdata1 = [];
	let tempdata2 = [];
	let listheading1 = "";
	let listheading2 = "";
	let multimatch = "";
	let list1 = [];
	let list2 = [];
	let localCData = [];
	let cdata = "";
	let editFlag = false;
	let editValue = "";
	let clsname = "";
	let columnid = "";
	let columnname = "";
	let index;
	let row = 0;
	let state = {};

	////// Holding states in writable form /////
	let stateData = writable({
		snackback: false,
		xml: "",
		listheading1: "",
		listheading2: "",
		multimatch: "",
		openResponseDialog: false,
		setting: 1,
		openImageDialog: false,
		imageClass: "",
		maxnode: 0,
		clname: "",
		anchorEl: null,
		drag_mode: false,
		openDeleteDialog: false,
		row_id: "",
		dir: false
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(3, state = items);
	});

	beforeUpdate(() => {
		if (state.xml != xml) {
			$$invalidate(3, state.xml = xml, state);
			$$invalidate(0, tempdata1 = []);
			$$invalidate(1, tempdata2 = []);
			var newXml = XMLToJSON(state.xml);
			parseXMLAuthoring(newXml);
		}
	});

	function loadLibs() {
		let config = {
			preload: true,
			type: "stylesheet",
			as: "style"
		};

		AH$1.createLink(themeUrl + "pe-items/svelte/clsSMMatchList/css/matchlistAuth.css", config);
	}

	onMount(() => {
		loadLibs();

		// preventing the enter key in the textarea
		AI.listen(document, "keydown", "textarea", function (event) {
			if (event.keyCode == 13) {
				event.preventDefault();
			}
		});

		// jQuery(document).off("keydown","textarea").on("keydown", "textarea", function(event) {
		// 	if (event.keyCode == 13) {
		// 		event.preventDefault();
		// 	}
		// });
		// for deleting the image
		AI.listen(document, "click", ".image_delete", _ele => {
			let oldImage = AI.find(_ele.parentElement.parentElement, "textarea").value;
			let newValue = state.xml.replace(oldImage, "insert value");
			getChildXml(newValue);
		});

		// jQuery('#matchListArea').tooltip({
		// 	selector: '[data-toggle="tooltip"]'
		// });
		AI.listen(document, "mouseup", ".ui-droppable", function () {
			setTimeout(function () {
				document.querySelectorAll(".matchlist-delete").forEach(_elm => {
					_elm.classList.add("tts_nospeak");
				});
			});
		});

		//jQuery('.algo_div span').css('color','#333');
		let algo_div_len = document.querySelectorAll(".algo_div span");

		for (let i = 0; i < algo_div_len.length; i++) {
			algo_div_len[i].style.color = "#333";
		}

		// jQuery(document).on('keydown', '.delete_match_node, .delete_match_node_auth', function(event) {
		// 	if ((event.keyCode == 13 || event.which == 13)) {
		// 	// click the element which currently get the focus and enter key is down
		// 	jQuery(this).trigger('click');
		// 	event.preventDefault();
		// 	}
		// });
		AI.listen(document, "keydown", ".delete_match_node, .delete_match_node_auth", function (data, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// Need ti fix one more line here....
				event.preventDefault();
			}
		});
	});

	// this function is responsible for parsing the xml
	function parseXMLAuthoring(QXML) {
		list1 = [];
		list2 = [];
		$$invalidate(2, localCData = []);

		// setting the state with the value in the xml
		$$invalidate(3, state.listheading1 = QXML.smxml.matchlist._listheading1, state);

		$$invalidate(3, state.listheading2 = QXML.smxml.matchlist._listheading2, state);
		$$invalidate(3, state.multimatch = QXML.smxml.matchlist._multimatch, state);
		$$invalidate(3, state.drag_mode = QXML.smxml.matchlist._multimatch == 2 ? true : false, state);

		// storing the values in multimatch and cdata
		multimatch = QXML.smxml.matchlist._multimatch;

		cdata = QXML.smxml.matchlist.__cdata;

		// checking for if is_algo is defined in xml or not
		if (QXML.smxml.matchlist._is_algo) {
			// if is_algo is true then put the value in isalgo as true else false
			$$invalidate(3, state.isalgo = QXML.smxml.matchlist._is_algo == "true" ? true : false, state);
		} else {
			// if is_algo is not defined means its value will be false
			$$invalidate(3, state.isalgo = false, state);
		}

		// for the maximum no of node i.e, max_node
		if (QXML.smxml.matchlist._max_node) {
			var num = Number(QXML.smxml.matchlist._max_node);
			$$invalidate(3, state.maxnode = num > 0 ? num : 0, state);
		} else {
			$$invalidate(3, state.maxnode = "", state);
		}

		// splitting the cdata with new line
		cdata = cdata.split("\n");

		// traversing through the cdata
		// jQuery(cdata).each( function (i) {
		cdata.forEach(function (data, i) {
			if (cdata[i].trim() != "") {
				// Finding the opening and closing brackets in cdata
				if (cdata[i].indexOf("[") >= 0 && cdata[i].indexOf("]") >= 0) {
					// extracting value 1 by replcing the content start with [ and end with ]
					let value1 = cdata[i].replace(cdata[i].match(/\[(.*?)\]/g), "").replace(/^\s+/g, "");

					let value2 = cdata[i].match(/\[(.*?)\]/g)[0];

					// finding the value 2 by finding the text start with [ and end with ] and the removing these brackets
					value2 = value2.replace("[", "").replace("]", "");

					// store the value in the localCData
					// localCData.push({
					// 	value1: value1,
					// 	value2: value2,
					// 	id:i
					// });
					$$invalidate(2, localCData = [...localCData, { value1, value2, id: i }]);

					list2[i] = cdata[i].replace(cdata[i].match(/\[(.*?)\]/g), "").replace(/^\s+/g, ""); // value 1
					list1[i] = cdata[i].match(/\[(.*?)\]/g)[0];
					list1[i] = list1[i].replace("[", "").replace("]", ""); // value 2
				} else {
					errMessage = "Bracket is Missing in line no. " + i;
					$$invalidate(3, state.snackback = true, state);
				}
			}
		});
	} //forceUpdate();

	// this function calls & updated the xml whenever there is change in list heading textbox & maxnode textbox
	function updateXml(e) {
		// updating the xml to json by XMLToJSON function
		var newXml = XMLToJSON(state.xml);

		// if there is change in listheading 1
		if (e.target.id == "listheading1") {
			$$invalidate(3, state.listheading1 = e.target.value, state);
		} else if (e.target.id == "listheading2") {
			// if there is change in listheading 2
			$$invalidate(3, state.listheading2 = e.target.value, state);
		} else if (e.target.id == "maxnode") {
			// if there is change in maxnode
			if (isNaN(e.target.value)) {
				AI.showmsg("Error Message", "Please enter numeric value", "error");
			} else if (e.target.value > 6) {
				AI.showmsg("Please insert value between 1 to 6");
			} else {
				$$invalidate(3, state.maxnode = e.target.value, state);
			}
		}

		timer["updateXMl1"] = setTimeout(
			function () {
				// updating the attribute values
				newXml.smxml.matchlist._listheading1 = state.listheading1;

				newXml.smxml.matchlist._listheading2 = state.listheading2;

				if (state.maxnode) {
					newXml.smxml.matchlist._max_node = state.maxnode;
				} else {
					// deleting max_node if it is not in use
					delete newXml.smxml.matchlist._max_node;
				}

				// update and store the xml 
				getChildXml(JSONToXML(newXml));

				clearTimeout(timer["updateXMl1"]);
			},
			200
		);
	}

	// whenever add button is clicked
	function updateCData() {
		//var rowInFirstColumn = jQuery("#matchListArea [class*='textarea_1']").length;
		var rowInFirstColumn = AI.selectAll("#matchListArea [class*='textarea_1']").length;

		//var rowInSeconfColumn = jQuery("#matchListArea [class*='textarea_2']").length;
		var rowInSeconfColumn = AI.selectAll("#matchListArea [class*='textarea_2']").length;

		if (rowInFirstColumn > 19 || rowInSeconfColumn > 19) {
			AI && AI.showmsg("Maximum possible options are 20");
		} else {
			row++;

			// converting the xml in json using the function XMLToJSON 
			let xml = XMLToJSON(state.xml);

			// updating the cdata
			xml.smxml.matchlist.__cdata = xml.smxml.matchlist.__cdata + `\nOption 2 Value of row ${row}[Option 1 value of row ${row}]\n`;

			// update and store the xml 
			getChildXml(JSONToXML(xml));

			setTimeout(
				function () {
					var err = smVal.validate(editorState.content_type, editorState.item, editorState.content_icon);
					smValidate(err);
				},
				200
			);
		}
	}

	function openMediaDialog() {
		//jQuery("#modal-media-upload").modal("show");
		AH$1.getBS("#modal-media-upload", "Modal").show();
	}

	// function calls onchange of the textarea in which option value is given if isalgo is off
	function editCData(val1, val2, i, e) {
		if (!e.target.value) return;

		if (e.target.id == "matchList1") {
			$$invalidate(2, localCData[i].value1 = e.target.value.replace(/\n/gm, ""), localCData);
		} else if (e.target.id == "matchList2") {
			$$invalidate(2, localCData[i].value2 = e.target.value.replace(/\n/gm, ""), localCData); //forceUpdate();
		} //forceUpdate();

		// converting the xml to json 
		let xml = XMLToJSON(state.xml);

		timer["editCdata"] = setTimeout(
			function () {
				let newCData = "\n";

				// jQuery(localCData).each(function(i) { // Replaced
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value1 + "[" + localCData[i].value2 + "]\n";
				});

				// updating the cdata
				xml.smxml.matchlist.__cdata = newCData;

				// updating the xml
				getChildXml(JSONToXML(xml));

				clearTimeout(timer["editCdata"]);
			},
			500
		);
	}

	// function calls onchange of the textarea in which option value is given if isalgo is on
	function editalgoCData(val1, i, placeIndex, e) {
		if (!e.target.value) return;

		if (e.target.id == "matchList1") {
			let placeindex2 = placeIndex.split("_")[1];

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value1;
					var strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr[k] = e.target.value;
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value1 = strarr, localCData);
		} else if (e.target.id == "matchList2") {
			let placeindex2 = placeIndex.split("_")[1]; //forceUpdate();

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value2;
					var strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr[k] = e.target.value;
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value2 = strarr, localCData);
		} //forceUpdate();

		let xml = XMLToJSON(state.xml);

		timer["algo"] = setTimeout(
			function () {
				let newCData = "\n";

				// jQuery(localCData).each(function(i) { // Replaced
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value1 + "[" + localCData[i].value2 + "]\n";
				});

				xml.smxml.matchlist.__cdata = newCData;
				getChildXml(JSONToXML(xml));
				clearTimeout(timer["algo"]);
			},
			500
		);
	}

	// for deleting the current option
	function removeCData(list1Val, list2Val, id) {
		//AH.alert("checking")
		$$invalidate(3, state.openDeleteDialog = true, state);

		$$invalidate(3, state.row_id = id, state);
	}

	// this function calls when the setting btn option is clicked
	function changeSetting(value) {
		let xml = XMLToJSON(state.xml);

		// if Normal options is selected
		if (value == 2) {
			if (state.drag_mode) {
				xml.smxml.matchlist._multimatch = 0;
			} else {
				xml.smxml.matchlist._multimatch = 2;
			}
		} else if (value == 3) {
			// for swap list
			let tempArr = xml.smxml.matchlist.__cdata.split("\n");

			let swapedCdata = "";

			tempArr.map((items, i) => {
				let tempList = items.split(/\[(.*?)\]/);

				if (tempList.length > 1) {
					swapedCdata += `${tempList[1]}[${tempList[0].trim()}]\n`;
				}
			});

			xml.smxml.matchlist.__cdata = swapedCdata;
		}

		// updating and storing the xml
		getChildXml(JSONToXML(xml));

		handleMenuClose();
	}

	// whenever the image icon is clicked this function calls
	function openImageDialog(class_name) {
		$$invalidate(3, state.openImageDialog = true, state);
		$$invalidate(3, state.imageClass = class_name, state);

		// extrcting image details
		let image = {};

		if (AH$1.select("." + class_name + " + img").nodeName) {
			image.name = AH$1.select("." + class_name + " + img").getAttribute("src").split("/").pop();
			image.alt = AH$1.select("." + class_name + " + img").getAttribute("alt");
		} else {
			image.name = "";
			image.alt = "";
		}

		// show value in the opened dailog
		timer["image"] = setTimeout(
			function () {
				AH$1.select("#MatchlistImg").value = image.name;
				AH$1.select("#MatchlistAlt").value = image.alt;
				clearTimeout(timer["image"]);
			},
			200
		);
	}

	// calls when image icon is clicked and is_algo is true 
	function openImageDialogAlgo(class_name, ids, i, clname) {
		$$invalidate(3, state.openImageDialog = true, state);
		clsname = class_name;
		index = ids;
		columnid = i;
		columnname = clname;
		$$invalidate(3, state.imageClass = class_name, state);
		$$invalidate(3, state.clname = clname, state);

		// extrcting image details
		let image = {};

		//image.name = (jQuery('.'+class_name+' + img').attr("src")) ? jQuery('.'+class_name+' + img').attr("src").split('/').pop() : "";
		if (AH$1.select("." + class_name, " + img").getAttribute("src") != null) {
			image.name = AH$1.select("." + class_name + " + img").getAttribute("src").split("/").pop();
			image.alt = AH$1.select("." + class_name + " + img").getAttribute("alt");
		} else {
			image.name = "";
			image.alt = "";
		}

		//image.alt = (jQuery('.'+class_name+' + img').attr("alt")) ? jQuery('.'+class_name+' + img').attr("alt"): "";
		// show value in the opened dailog
		timer["algoImage"] = setTimeout(
			function () {
				//jQuery('#MatchlistImg').val(image.name);
				AH$1.select("#MatchlistImg").value = image.name;

				//jQuery('#MatchlistAlt').val(image.alt);
				AH$1.select("#MatchlistAlt").value = image.alt;

				clearTimeout(timer["algoImage"]);
			},
			500
		);
	}

	// on click of cancel btn of image dialog this function called
	function closeImageDialog() {
		$$invalidate(3, state.openImageDialog = false, state);
	}

	// on click of done btn of image dialog this function called
	function insertImage() {
		if (state.isalgo == true) {
			// @pradeep sir : in both condition same code is written can we make it in one
			if (state.clname == "matchlist2" || state.clname == "matchlist1") {
				let image = {};

				// getting the image information
				image.name = AH$1.select("#MatchlistImg").value;

				image.alt = AH$1.select("#MatchlistAlt").value;
				image.oldValue = AH$1.select("." + state.imageClass).value;
				$$invalidate(3, state.openImageDialog = false, state);

				// replace with new value in the xml
				image.newValue = state.xml.replace(image.oldValue, "*" + image.name + "##" + image.alt);

				// updates the xml
				getChildXml(image.newValue);
			}
		} else {
			// finding the cdata
			let cdataArr = (/\<\!\[CDATA\[([\s\S]*?)\]\]\>/gi).exec(state.xml);

			let cdata = "";
			let keyIndex = parseInt(state.imageClass.match(/\d+$/g));
			let image = {};

			// getting image information
			//image.name = jQuery('#MatchlistImg').val();
			image.name = AH$1.select("#MatchlistImg").value;

			//image.alt = jQuery('#MatchlistAlt').val();
			image.alt = AH$1.select("#MatchlistAlt").value;

			//image.oldValue = jQuery('.'+state.imageClass).val();
			image.oldValue = AH$1.select("." + state.imageClass).value;

			$$invalidate(3, state.openImageDialog = false, state);

			if (cdataArr) {
				cdata = cdataArr[1];

				// replacing two newlines with singline newline and spliting it with newline
				cdata = cdata.replace("\n\n", "\n").trim();

				cdataArr = cdata.split("\n");

				// adding new image details
				cdataArr[keyIndex] = cdataArr[keyIndex].replace(image.oldValue, "*" + image.name + "##" + image.alt);

				// join cdataArr with neeline
				cdata = cdataArr.join("\n");

				// replace the cdata with new value
				image.newValue = xml.replace(/\<\!\[CDATA\[[\s\S]*?\]\]\>/gi, "<![CDATA[\n" + cdata + "\n]]>");
			} else {
				// adding new image details
				image.newValue = xml.replace(image.oldValue, "*" + image.name + "##" + image.alt);
			}

			// update the xml
			getChildXml(image.newValue);
		}
	}

	// called when algorithmic checkbox state is changed (on click)
	function changeisalgo(e) {
		// convert xml to json
		let xml = XMLToJSON(state.xml);

		$$invalidate(3, state.isalgo = e.target.checked, state);

		// if checkbox is checked 
		// if (e.target.checked) {
		// 	xml.smxml.matchlist._is_algo = true; 
		// } else {
		// 	xml.smxml.matchlist._is_algo = false;
		// }
		xml.smxml.matchlist._is_algo = e.target.checked;

		// updates the xml
		getChildXml(JSONToXML(xml));
	}

	// on click of delete icon which is adjusent to the option btn this function is called
	function removetextbox(ids, placeIndex, test, i, e) {
		if (test == "matchlist1") {
			var strarr;
			let placeindex2 = placeIndex.split("_")[1];

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value1;
					strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr.splice(k, 1);
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value1 = strarr, localCData);

			if (localCData[i].value1 == "" || localCData[i].value1 == "undefined") {
				$$invalidate(2, localCData[i].value1 = "insert value", localCData);
			}
		}

		if (test == "matchlist2") {
			var strarr;
			let placeindex2 = placeIndex.split("_")[1];

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value2;
					strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr.splice(k, 1);
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value2 = strarr, localCData);

			if (localCData[i].value2 == "" || localCData[i].value2 == "undefined") {
				$$invalidate(2, localCData[i].value2 = "insert value", localCData);
			}
		}

		let xml = XMLToJSON(state.xml);

		var timer = setTimeout(
			function () {
				let newCData = "\n";

				//jQuery(localCData).each(function(i) { // Replaced
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value1 + "[" + localCData[i].value2 + "]\n";
				});

				xml.smxml.matchlist.__cdata = newCData;
				getChildXml(JSONToXML(xml));
				clearTimeout(timer);
			},
			500
		);

		$$invalidate(3, state.dir = !state.dir, state);
	}

	function addListItem(index) {
		// convert xml to json 
		let xml = XMLToJSON(state.xml);

		// splitting cdata with newline and storring it in variable newArr
		let newArr = xml.smxml.matchlist.__cdata.split("\n");

		if (newArr[newArr.length - 1] == "") {
			newArr.pop();
			newArr.unshift("");
		}

		if (newArr[0] == "" && newArr[1] == "") {
			newArr.shift();
		}

		// gettng the index of the option 
		let str = newArr[parseInt(index + 1)];

		// extracting value 1
		let value1 = str.replace(str.match(/\[(.*?)\]/g), "").replace(/^\s+/g, "");

		let value2 = str.match(/\[(.*?)\]/g)[0];
		value2 = value2.substring(1, value2.length - 1);

		// extracting value 2
		value2 = "[" + value2 + "]";

		// adding new option value
		value1 = value1 + "%%Option 2 Value";

		// store the final string at that index
		let fStr = value1 + value2;

		newArr[parseInt(index + 1)] = fStr;

		// join the array
		newArr = newArr.join("\n");

		// update the cdata
		xml.smxml.matchlist.__cdata = newArr;

		// stores and update the xml using the function getChildXml
		getChildXml(JSONToXML(xml));
	}

	// called when dropdown is open 
	function handleMenuOpen(event) {
		$$invalidate(3, state.anchorEl = event.currentTarget, state);
	}

	// called when dropdown is close 
	function handleMenuClose() {
		$$invalidate(3, state.anchorEl = null, state);
	}

	function removeRow() {
		$$invalidate(3, state.openDeleteDialog = false, state);
		let not_matched_data = "";

		// storing the values of the option in a except the deleted one
		// jQuery(localCData).each(function(index_no) { // Replaced
		localCData.forEach(function (data, index_no) {
			// check min no of options
			if (localCData.length > 1) {
				if (localCData[index_no].id != state.row_id) {
					not_matched_data += localCData[index_no].value1 + "[" + localCData[index_no].value2 + "]\n";
				}
			} else {
				AI.showmsg("At least one field required.");
				not_matched_data += localCData[index_no].value1 + "[" + localCData[index_no].value2 + "]\n";
			}
		});

		// convert xml to json
		let xml = XMLToJSON(state.xml);

		// updating cdata
		xml.smxml.matchlist.__cdata = "\n" + not_matched_data;

		// updating the xml
		getChildXml(JSONToXML(xml));
	}

	const writable_props = ["editorState", "xml", "getChildXml", "smValidate"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MatchList> was created with unknown prop '${key}'`);
	});

	const click_handler = e => {
		changeSetting("2");
	};

	const click_handler_1 = e => {
		changeSetting("3");
	};

	const change_handler = (temp, i, j, e) => {
		editalgoCData(temp, i, i + "_" + j, e);
	};

	const click_handler_2 = (i, j, e) => {
		openImageDialogAlgo("textarea_2_" + i + "_" + j, i + "_" + j, i, "matchlist2");
	};

	const click_handler_3 = (i, j, e) => {
		removetextbox("textarea_2_" + i + "_" + j, i + "_" + j, "matchlist2", i);
	};

	const change_handler_1 = (temp1, i, k, e) => {
		editalgoCData(temp1, i, i + "_" + k, e);
	};

	const click_handler_4 = (i, k, e) => {
		openImageDialogAlgo("textarea_1_" + i + "_" + k, i + "_" + k, i, "matchlist1");
	};

	const click_handler_5 = (i, k, e) => {
		removetextbox("textarea_2_" + i + "_" + k, i + "_" + k, "matchlist1", i);
	};

	const click_handler_6 = data => {
		removeCData(data.value1, data.value2, data.id);
	};

	const change_handler_2 = (data, i, e) => {
		editCData(data.value2, data.value2, i, e);
	};

	const click_handler_7 = i => {
		openImageDialog("textarea_2_" + i);
	};

	const change_handler_3 = (data, i, e) => {
		editCData(data.value1, data.value2, i, e);
	};

	const click_handler_8 = i => {
		openImageDialog("textarea_1_" + i);
	};

	const click_handler_9 = data => {
		removeCData(data.value1, data.value2, data.id);
	};

	function dialog0_visible_binding(value) {
		state.openImageDialog = value;
		$$invalidate(3, state);
	}

	const click_handler_10 = () => {
		$$invalidate(3, state.openDeleteDialog = false, state);
	};

	function dialog1_visible_binding(value) {
		state.openDeleteDialog = value;
		$$invalidate(3, state);
	}

	$$self.$$set = $$props => {
		if ("editorState" in $$props) $$invalidate(19, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(20, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(21, getChildXml = $$props.getChildXml);
		if ("smValidate" in $$props) $$invalidate(22, smValidate = $$props.smValidate);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		beforeUpdate,
		writable,
		Loader,
		AH: AH$1,
		XMLToJSON,
		JSONToXML,
		smVal,
		l: Lang,
		Button,
		Dialog,
		Checkbox,
		editorState,
		xml,
		getChildXml,
		smValidate,
		timer,
		tempdata1,
		tempdata2,
		listheading1,
		listheading2,
		multimatch,
		list1,
		list2,
		localCData,
		cdata,
		editFlag,
		editValue,
		clsname,
		columnid,
		columnname,
		index,
		row,
		state,
		stateData,
		unsubscribe,
		loadLibs,
		parseXMLAuthoring,
		updateXml,
		updateCData,
		openMediaDialog,
		editCData,
		editalgoCData,
		removeCData,
		changeSetting,
		openImageDialog,
		openImageDialogAlgo,
		closeImageDialog,
		insertImage,
		changeisalgo,
		removetextbox,
		addListItem,
		handleMenuOpen,
		handleMenuClose,
		removeRow
	});

	$$self.$inject_state = $$props => {
		if ("editorState" in $$props) $$invalidate(19, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(20, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(21, getChildXml = $$props.getChildXml);
		if ("smValidate" in $$props) $$invalidate(22, smValidate = $$props.smValidate);
		if ("timer" in $$props) timer = $$props.timer;
		if ("tempdata1" in $$props) $$invalidate(0, tempdata1 = $$props.tempdata1);
		if ("tempdata2" in $$props) $$invalidate(1, tempdata2 = $$props.tempdata2);
		if ("listheading1" in $$props) listheading1 = $$props.listheading1;
		if ("listheading2" in $$props) listheading2 = $$props.listheading2;
		if ("multimatch" in $$props) multimatch = $$props.multimatch;
		if ("list1" in $$props) list1 = $$props.list1;
		if ("list2" in $$props) list2 = $$props.list2;
		if ("localCData" in $$props) $$invalidate(2, localCData = $$props.localCData);
		if ("cdata" in $$props) cdata = $$props.cdata;
		if ("editFlag" in $$props) editFlag = $$props.editFlag;
		if ("editValue" in $$props) editValue = $$props.editValue;
		if ("clsname" in $$props) clsname = $$props.clsname;
		if ("columnid" in $$props) columnid = $$props.columnid;
		if ("columnname" in $$props) columnname = $$props.columnname;
		if ("index" in $$props) index = $$props.index;
		if ("row" in $$props) row = $$props.row;
		if ("state" in $$props) $$invalidate(3, state = $$props.state);
		if ("stateData" in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		tempdata1,
		tempdata2,
		localCData,
		state,
		updateXml,
		updateCData,
		openMediaDialog,
		editCData,
		editalgoCData,
		removeCData,
		changeSetting,
		openImageDialog,
		openImageDialogAlgo,
		closeImageDialog,
		insertImage,
		changeisalgo,
		removetextbox,
		addListItem,
		removeRow,
		editorState,
		xml,
		getChildXml,
		smValidate,
		click_handler,
		click_handler_1,
		change_handler,
		click_handler_2,
		click_handler_3,
		change_handler_1,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		change_handler_2,
		click_handler_7,
		change_handler_3,
		click_handler_8,
		click_handler_9,
		dialog0_visible_binding,
		click_handler_10,
		dialog1_visible_binding
	];
}

class MatchList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-1kpz00h-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				editorState: 19,
				xml: 20,
				getChildXml: 21,
				smValidate: 22
			},
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MatchList",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*editorState*/ ctx[19] === undefined && !("editorState" in props)) {
			console.warn("<MatchList> was created without expected prop 'editorState'");
		}

		if (/*xml*/ ctx[20] === undefined && !("xml" in props)) {
			console.warn("<MatchList> was created without expected prop 'xml'");
		}

		if (/*getChildXml*/ ctx[21] === undefined && !("getChildXml" in props)) {
			console.warn("<MatchList> was created without expected prop 'getChildXml'");
		}

		if (/*smValidate*/ ctx[22] === undefined && !("smValidate" in props)) {
			console.warn("<MatchList> was created without expected prop 'smValidate'");
		}
	}

	get editorState() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smValidate() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smValidate(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default MatchList;
//# sourceMappingURL=MatchList-89b01c7a.js.map
