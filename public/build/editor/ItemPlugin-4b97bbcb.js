
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, V as Checkbox, C as validate_each_argument, U as Button, O as Dialog, P as binding_callbacks, Q as bind, v as validate_slots, o as onMount, X as XMLToJSON, A as AH, L as beforeUpdate, w as writable, y as language, M as JSONToXML, h as text, f as space, j as attr_dev, k as add_location, n as insert_dev, q as listen_dev, G as prop_dev, r as group_outros, a as transition_out, u as check_outros, t as transition_in, x as detach_dev, H as run_all, c as create_component, m as mount_component, W as add_flush_callback, b as destroy_component, K as destroy_each, B as noop, $ as null_to_empty } from './main-59da555a.js';

/* clsSMStepAlgo/StepAlgo.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMStepAlgo/StepAlgo.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-smsdwz-style";
	style.textContent = ".font18.svelte-smsdwz{font-size:16px}.fwidth.svelte-smsdwz{width:100%}.light-cyan-bg.svelte-smsdwz{background-color:#d4e4ff;color:#333}.top2.svelte-smsdwz{top:2px}.right5.svelte-smsdwz{right:5px}.right35.svelte-smsdwz{right:35px}.step_checkbox.svelte-smsdwz{width:22%;border:1px solid black;margin-left:10px;position:relative;bottom:1px;cursor:pointer;padding:3px 2px 0}.fixed_ans.svelte-smsdwz{top:10px;position:relative;float:right;border:1px solid #e0e0e0;background-color:#f5f5f5;border-radius:4px;padding:5px;font-size:15px;font-weight:700}.check_box.svelte-smsdwz{right:24px;position:relative;width:40px}.inner_inputs.svelte-smsdwz{margin:0 12px!important}.pointer.svelte-smsdwz{cursor:pointer !important}.width100.svelte-smsdwz{width:100px}[id^=\"fillmain\"]{overflow:hidden;text-align:left}[id^=\"fillmain\"] pre{background:none;border:none;font-size:14px!important}[id^=\"fillmain\"] .string{min-height:50px;margin-top:10px;margin-right:10px}[id^=\"fillmain\"] .footerstr{position:relative;margin-top:10px;background-color:#ccc;padding:15px;min-height:60px}[id^=\"fillmain\"] .footerstr .arrow-up{position:absolute;top:-10px;right:50%;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:10px solid #ccc}[id^=\"fillmain\"] .fill-row{padding:6px}[id^=\"fillmain\"] .fillelement, [id^=\"fillmain\"] .drag-resize{height:30px;display:inline-block;position:relative;min-height:30px;margin:1px}[id^=\"fillmain\"] input[type=\"text\"], [id^=\"fillmain\"] select{height:99%!important;resize:none;font-size:12px;color:#000;max-width:800px}[id^=\"fillmain\"] .drag-resize{vertical-align:middle;border:1px solid #31B731;text-align:center;padding:3px;font-size:14px}[id^=\"fillmain\"] .drag-resize.ui-draggable{cursor:move}[id^=\"fillmain\"] .drop-hover{border:1px dashed red!important;box-shadow:0 0 0 2px yellow inset;outline:1px solid blue}[id^=\"fillmain\"] .fillcheck ul{width:220px}[id^=\"fillmain\"] .fillcheck li.selected{background-color:#E5E5E5}.fillcheck .selected .icomoon-checkmark-3:before{float:left;color:blue;padding:3px;position:relative;right:14px}.fillcheck .icomoon-close-2:before{float:left;color:blue;position:relative;right:14px;font-size:20px}.MathJax_Display{display:inline!important}[id^=\"fillmain\"] .select{font-size:15px}[id^=\"fillmain\"] .textarea{vertical-align:middle;border-radius:3px;background:#ffe;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.ui-draggable-disabled{cursor:no-drop!important;opacity:0.5!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RlcEFsZ28uc3ZlbHRlIiwic291cmNlcyI6WyJTdGVwQWxnby5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiXG48IS0tIFxuKiAgRmlsZSBOYW1lICAgOiBTdGVwQWxnby5zdmVsdGVcbiogIERlc2NyaXB0aW9uIDogU2F2aW5nIGFuc3dlciB0b29sIGFuZCBxdWVzdGlvbiBtb2RlbCBib3hlc1xuKiAgQXV0aG9yICAgICAgOiBTdW5kYXJhbSBUcmlwYXRoaVxuKiAgVmVyc2lvbiAgICAgOiAxLjBcbiogIFBhY2thZ2UgICAgIDogcGUtaXRlbXNcbiogIExhc3QgdXBkYXRlIDogIC0tPlxuPHNjcmlwdD5cbiAgICBpbXBvcnQge3dyaXRhYmxlfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuICAgIGltcG9ydCB7IEJ1dHRvbiwgRGlhbG9nLCBDaGVja2JveCB9IGZyb20gJ3N2ZWx0ZS1tdWkvc3JjJztcbiAgICBpbXBvcnQgbCBmcm9tICcuLi9zcmMvbGlicy9lZGl0b3JMaWIvbGFuZ3VhZ2UuanMnO1xuICAgIGltcG9ydCB7IGJlZm9yZVVwZGF0ZSxvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQge0FILFhNTFRvSlNPTixKU09OVG9YTUx9IGZyb20gXCIuLi9oZWxwZXIvSGVscGVyQUkuc3ZlbHRlXCI7XG5cbiAgICAgd2luZG93LnNwYW5Db3VudGVyID0gMDtcbiAgICAvLyB3aW5kb3cuY3VycmVudElkID0gXCJcIjtcbiAgICAvLyB3aW5kb3cuY3VycmVudElucCA9IFwiXCI7XG4gICAgbGV0IHN0YXRlID0ge307XG4gICAgbGV0IG5ld194bWwgPSB7fVxuICAgIHZhciBhbGxfc3RlcHMgPSBbXTtcbiAgICBleHBvcnQgbGV0IHN0b3BBdXRob3JpbmdVcGRhdGU7XG4gICAgZXhwb3J0IGxldCB4bWw7XG4gICAgZXhwb3J0IGxldCBlZGl0b3JTdGF0ZTtcbiAgICBleHBvcnQgbGV0IGdldENoaWxkWG1sO1xuXG4gICAgXG4gICAgXG4gICAgbGV0IHN0YXRlRGF0YSA9IHdyaXRhYmxlKHtcbiAgICAgICAgeG1sICAgICAgICAgICAgICAgICAgICAgICAgIDogJycsICAgICAgICAgXG4gICAgICAgIGZpbGxJblRoZUJsYW5rc0Nob2ljZSAgICAgICA6IDEsXG4gICAgICAgIG9wZW5lZCAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBkZWxldGVJbmRleCAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICByZW1lZGlhdGlvblRvZ2dsZSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgc25hY2tiYWNrICAgICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGlucHV0X2FucyAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICBzcGFuQ291bnRlciAgICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICBjdXJyZW50SWQgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgY3VycmVudElucCAgICAgICAgICAgICAgICAgIDogJydcblxuICAgIH0pXG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0YXRlRGF0YS5zdWJzY3JpYmUoKGl0ZW1zKT0+e1xuICAgICAgICBzdGF0ZSA9IGl0ZW1zO1xuICAgIH0pXG5cbiAgICBvbk1vdW50KCgpPT57XG4gICAgICAgIGlmKHhtbCkge1xuICAgICAgICAgICAgbmV3X3htbCA9IFhNTFRvSlNPTih4bWwpO1xuICAgICAgICAgICAgc2hvd0l0ZW1zKG5ld194bWwuc214bWwuc3RlcCk7XG4gICAgICAgICAgICAvL2pRdWVyeSgnI3N0aWNreV9jaGVja2JveF8wJykudHJpZ2dlcignY2xpY2snKTtcbiAgICAgICAgICAgIEFILnNlbGVjdChcIiNzdGlja3lfY2hlY2tib3hfMFwiKS5jbGljaygpO1xuICAgICAgICAgICAgLy9zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8valF1ZXJ5KCcjc3RpY2t5X2NoZWNrYm94XzAnKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3N0aWNreV9jaGVja2JveF8wJykuY2xpY2soKTtcbiAgICAgICAgICAgIC8vfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8valF1ZXJ5KCcuc2F2ZV9idXR0b25fc3RlcHMnKS5wcm9wKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuc2F2ZV9idXR0b25fc3RlcHMnLCdhdHRyJyx7ZGlzYWJsZWQ6J2Rpc2FibGVkJ30pO1xuICAgICAgICAgICAgaW5pdEVkaXRvcigpO1xuICAgICAgICB9LCA1MDApO1xuXG4gICAgICAgIC8vIGpRdWVyeShkb2N1bWVudCkub24oXCJjbGljayB0b3VjaHN0YXJ0XCIsIFwiLmVkaXRGaWxsXCIsIGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0aWYoalF1ZXJ5KHRoaXMpLmF0dHIoXCJ0eXBlXCIpID09IFwidFwiKSB7XG5cdFx0Ly8gXHRcdGVkaXRUZXh0Ym94KGpRdWVyeSh0aGlzKS5hdHRyKFwib3JpZ2luYWxLZXlcIikpO1xuXHRcdC8vIFx0fSBlbHNlIGlmKGpRdWVyeSh0aGlzKS5hdHRyKFwidHlwZVwiKSA9PSBcImVcIikge1xuXHRcdC8vIFx0XHRlZGl0TWF0aGJveChqUXVlcnkodGhpcykuYXR0cihcIm9yaWdpbmFsS2V5XCIpKTtcblx0XHQvLyBcdH1cblx0XHQvLyB9KVxuXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcuZWRpdEZpbGwnLGZ1bmN0aW9uKGN1cnIsZSkge1xuICAgICAgICAgICAgaWYoY3Vyci5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwidFwiKSB7XG4gICAgICAgICAgICAgICAgZWRpdFRleHRib3goY3Vyci5nZXRBdHRyaWJ1dGUoXCJvcmlnaW5hbEtleVwiKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoY3Vyci5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwiZVwiKSB7XG4gICAgICAgICAgICAgICAgZWRpdE1hdGhib3goY3Vyci5nZXRBdHRyaWJ1dGUoXCJvcmlnaW5hbEtleVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgQUgubGlzdGVuKGRvY3VtZW50LCd0b3VjaHN0YXJ0JywnLmVkaXRGaWxsJyxmdW5jdGlvbihjdXJyLGUpIHtcbiAgICAgICAgICAgIGlmKGN1cnIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcInRcIikge1xuICAgICAgICAgICAgICAgIGVkaXRUZXh0Ym94KGN1cnIuZ2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcImVcIikge1xuICAgICAgICAgICAgICAgIGVkaXRNYXRoYm94KGN1cnIuZ2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG5cblxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBlZGl0VGV4dGJveChrZXkpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY2hlY2tpbmcnKTtcblx0XHRrZXkgPSBrZXkucmVwbGFjZSgvJXt8fSUvZywgXCJcIik7XG5cdFx0a2V5ID0ga2V5LnNwbGl0KFwifFwiKTtcblx0XHRsZXQgYW5zID0ga2V5WzBdLnRyaW0oKTtcbiAgICAgICAgXG5cdFx0bGV0IGFuc190eXBlID0gKChrZXlbMV0pP2tleVsxXS50cmltKCk6XCJcIik7XG5cdFx0XG4gICAgICAgICAgICBzdGF0ZS5udW1lcmljID0gKChhbnNfdHlwZSA9PSBcIm5cIik/IHRydWUgOiBmYWxzZSApO1xuICAgICAgICAgICAgc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID0gMTtcbiAgICAgICAgICAgIHN0YXRlLm9wZW4gPSB0cnVlO1xuICAgICAgICBcblx0XHQvL3RoaXMuc2V0U3RhdGUoe2ZpbGxJblRoZUJsYW5rc0Nob2ljZToxfSk7XG5cdFx0Ly90aGlzLnNldFN0YXRlKHtvcGVuOnRydWV9KTtcblx0XHRpZihhbnMuaW5kZXhPZihcIiNzdHlsZSNcIikgIT0gLTEpIHtcblx0XHRcdGxldCBjdXN0b21TdHlsZSAgPSBhbnMuc3BsaXQoXCIjc3R5bGUjXCIpXG5cdFx0XHQvL2pRdWVyeShcIiNyZXNwb25zZURpYWxvZyAjY3VzdG9tU3R5bGVUZXh0XCIpLnZhbChjdXN0b21TdHlsZVsxXSk7XG4gICAgICAgICAgICBBSC5zZWxlY3QoXCIjcmVzcG9uc2VEaWFsb2cgI2N1c3RvbVN0eWxlVGV4dFwiKS52YWx1ZSA9IGN1c3RvbVN0eWxlWzFdO1xuXG5cdFx0XHQvL2pRVWVyeShcIiNpbnB1dDFcIikudmFsKGN1c3RvbVN0eWxlWzBdKTtcbiAgICAgICAgICAgIC8vQUguc2VsZWN0KFwiI2lucHV0MVwiKS52YWx1ZSA9IGN1c3RvbVN0eWxlWzBdO1xuICAgICAgICAgICAgc3RhdGUuaW5wdXRfYW5zID0gY3VzdG9tU3R5bGVbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8valF1ZXJ5KFwiI2lucHV0MVwiKS52YWwoYW5zKTtcbiAgICAgICAgICAgIC8vIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIC8vICAgICBBSC5zZWxlY3QoXCIjaW5wdXQxXCIpLnZhbHVlID0gYW5zO1xuICAgICAgICAgICAgLy8gfSwxMDApXG4gICAgICAgICAgICBzdGF0ZS5pbnB1dF9hbnMgPSBhbnM7XG5cdFx0fVx0XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBlZGl0TWF0aGJveChrZXkpIHtcblx0XHRrZXkgPSBrZXkucmVwbGFjZSgvJXt8fSUvZywgXCJcIik7XG5cdFx0a2V5ID0ga2V5LnNwbGl0KFwifFwiKTtcblx0XHRsZXQgYW5zID0ga2V5WzBdLnRyaW0oKTtcblx0XHRsZXQgYW5zX3R5cGUgPSAoKGtleVsxXSk/a2V5WzFdLnRyaW0oKTpcIlwiKTtcblx0XHQvLyB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgLy8gICAgIGN1c3RvbVN0eWxlOigoYW5zLmluZGV4T2YoXCIjc3R5bGUjXCIpICE9IC0xKT90cnVlOmZhbHNlKSxcbiAgICAgICAgLy8gICAgIGZpbGxJblRoZUJsYW5rc0Nob2ljZToyLFxuICAgICAgICAvLyAgICAgb3Blbjp0cnVlXG4gICAgICAgIC8vIH0pO1xuICAgICAgICBzdGF0ZS5jdXN0b21TdHlsZSA9ICgoYW5zLmluZGV4T2YoXCIjc3R5bGUjXCIpICE9IC0xKT90cnVlOmZhbHNlKTtcbiAgICAgICAgc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID0yO1xuICAgICAgICBzdGF0ZS5vcGVuID0gdHJ1ZTtcblx0XHQvL3RoaXMuc2V0U3RhdGUoe2ZpbGxJblRoZUJsYW5rc0Nob2ljZToyfSk7ICMjIEFMcmVhZHkgY29tbWVudGVkXG5cdFx0Ly90aGlzLnNldFN0YXRlKHtvcGVuOnRydWV9KTsgIyMgQUxyZWFkeSBjb21tZW50ZWRcblxuXHRcdGlmKGFucy5pbmRleE9mKFwiI3N0eWxlI1wiKSAhPSAtMSkge1xuXHRcdFx0bGV0IGN1c3RvbVN0eWxlICA9IGFucy5zcGxpdChcIiNzdHlsZSNcIilcblx0XHRcdC8vJChcIiNyZXNwb25zZURpYWxvZyAjY3VzdG9tU3R5bGVUZXh0XCIpLnZhbChjdXN0b21TdHlsZVsxXSk7XG4gICAgICAgICAgICBBSC5zZWxlY3QoXCIjcmVzcG9uc2VEaWFsb2dcIikudmFsdWUgPSBjdXN0b21TdHlsZVsxXTtcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI2N1c3RvbVN0eWxlVGV4dCcpLnZhbHVlID0gY3VzdG9tU3R5bGVbMV07XG5cdFx0XHQvLyQoXCIjaW5wdXRcIitpKS52YWwoY3VzdG9tU3R5bGVbMF0pO1xuICAgICAgICAgICAgQUguc2VsZWN0KFwiI2lucHV0XCIraSkudmFsdWUgPSBjdXN0b21TdHlsZVswXTtcblx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgLy8kKFwiI2lucHV0XCIpLnZhbChhbnMpO1xuICAgICAgICAgICAgQUguc2VsZWN0KFwiI2lucHV0XCIpLnZhbHVlID0gYW5zO1xuXHRcdH1cdFxuXHR9XG4gICAgXG4gICAgYmVmb3JlVXBkYXRlKCgpPT57XG4gICAgICAgIGlmICh4bWwgIT0gc3RhdGUueG1sKSB7XG4gICAgICAgICAgICBzdGF0ZS54bWwgPSB4bWw7XG4gICAgICAgICAgICBpZiAoc3RvcEF1dGhvcmluZ1VwZGF0ZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgbmV3X3htbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xuICAgICAgICAgICAgc2hvd0l0ZW1zKG5ld194bWwuc214bWwuc3RlcCk7XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gc2hvd0l0ZW1zKHN0ZXBzKSB7XG4gICAgICAgIHN0ZXBzID0gcmVwbGFjZVZhcmlhYmxlcyhzdGVwcyk7XG4gICAgICAgIGFsbF9zdGVwcyA9IHN0ZXBzO1xuICAgICAgICBzZXRUb2dnbGUoYWxsX3N0ZXBzKTtcbiAgICAgICAgcGFyc2VYbWxBdXRob3Jpbmcoc3RlcHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRvZ2dsZShzdGVwcykge1xuICAgICAgICBsZXQgdG9vZ2xlID0gJyc7XG4gICAgICAgIHN0ZXBzLm1hcChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYoaXRlbS5fdmlld29ubHkgPT0gMSkge1xuICAgICAgICAgICAgICAgIGFsbF9zdGVwc1tpbmRleF0udG9nZ2xlID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsX3N0ZXBzW2luZGV4XS50b2dnbGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYWxsX3N0ZXBzO1xuICAgIH0gXG5cbiAgICBmdW5jdGlvbiByZXBsYWNlVmFyaWFibGVzKGxhdGV4X3N0cikge1xuICAgICAgICBsZXQgbGF0ZXhfYXJyID0gW107XG4gICAgICAgIGxldCBsYXRleF9hcnJfY2hlY2sgPSBsYXRleF9zdHI7XG4gICAgICAgIGlmKGxhdGV4X2Fycl9jaGVjay5sZW5ndGggPT0gdW5kZWZpbmVkICYmIGxhdGV4X2Fycl9jaGVjayAhPSBcIlwiKSB7XG4gICAgICAgICAgICBsYXRleF9hcnIucHVzaChsYXRleF9hcnJfY2hlY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGF0ZXhfYXJyID0gbGF0ZXhfYXJyX2NoZWNrO1xuICAgICAgICB9XG4gICAgICAgIGxhdGV4X2Fyci5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBjZGF0YSA9IGl0ZW0uX19jZGF0YTtcbiAgICAgICAgICAgIGxldCB2YXJzID0gY2RhdGEubWF0Y2goLzx7W1xcc1xcU10qP30+L2dtKTtcbiAgICAgICAgICAgIGlmKHZhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXJzLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gZWxlbWVudC5tYXRjaCgvPFxceyguKj8pXFx9Pi9nKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udG9TdHJpbmcoKS5yZXBsYWNlKC88XFx7fFxcfT4vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gXCJ2YXI6XCIraXRlbTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBjZGF0YSA9IGNkYXRhLnJlcGxhY2UoZWxlbWVudCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXRleF9hcnJbaW5kZXhdLl9fY2RhdGEgPSBjZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXRleF9hcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VYbWxBdXRob3Jpbmcoc3RlcHMpIHtcbiAgICAgICAgc3RlcHMubWFwKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBsZXQgY2RhdGEgPSBpdGVtLl9fY2RhdGE7XG4gICAgICAgICAgICBsZXQgYW5zd2VyS2V5ID0gY2RhdGEubWF0Y2goLyV7W1xcc1xcU10qP30lL2dtKTtcbiAgICAgICAgICAgIGxldCBhbnN3ZXJUeXBlID0gJyc7XG4gICAgICAgICAgICBpZihhbnN3ZXJLZXkpIHtcbiAgICAgICAgICAgICAgICAvL2pRdWVyeShhbnN3ZXJLZXkpLmVhY2goZnVuY3Rpb24oaSl7XG4gICAgICAgICAgICAgICAgYW5zd2VyS2V5LmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsS2V5ID0gYW5zd2VyS2V5W2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF0ZXhLZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWRpdE1hdGggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBhbnN3ZXJUeXBlID0gYW5zd2VyS2V5W2ldLm1hdGNoKC9cXHwoLio/KX0lJC9nbSk7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlclR5cGUgPSAoYW5zd2VyVHlwZSkgPyBhbnN3ZXJUeXBlWzBdLnJlcGxhY2UoL1xcfHx9JS9nbSwgJycpIDogJ3QnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXJLZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWNvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYoYW5zd2VyVHlwZSA9PSBcInRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGFuc3dlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lcktleSA9IFwiVGV4dGJveFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IFwiaWNvbW9vbi1pbnNlcnQtdGVtcGxhdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGFuc3dlclR5cGUgPT0gXCJuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcInRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyS2V5ID0gXCJOdW1lcmljXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gXCJpY29tb29uLWluc2VydC10ZW1wbGF0ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYW5zd2VyVHlwZT09IFwiZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gYW5zd2VyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyS2V5ID0gXCJNYXRoXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRleEtleSA9IG9yaWdpbmFsS2V5LnJlcGxhY2UoL1xcJVxce3xcXHxlXFx9XFwlL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXhLZXkgPSBcImxhdGV4PVxcXCJcIitsYXRleEtleStcIlxcXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRNYXRoID0gXCJlZGl0TWF0aFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IFwiaWNvbW9vbi1pbnNlcnQtdGVtcGxhdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFJlZ0V4cC5xdW90ZShvcmlnaW5hbEtleSkpO1xuICAgICAgICAgICAgICAgICAgICBjZGF0YSA9IGNkYXRhLnJlcGxhY2UocmVnZXgsIFwiPHNwYW4gaWQ9XFxcImxhdGV4U3BhblwiKyhzdGF0ZS5zcGFuQ291bnRlciA9ICsrc3RhdGUuc3BhbkNvdW50ZXIpK1wiXFxcIiBcIitsYXRleEtleStcIiB0eXBlPSdcIit0eXBlK1wiJyBjbGFzcz0nYWxlcnQgYWxlcnQtaW5mbyBlZGl0RmlsbCBcIitlZGl0TWF0aCtcIicgb3JpZ2luYWxrZXk9J1wiK29yaWdpbmFsS2V5K1wiJyBzdHlsZT0ncGFkZGluZzogNXB4O291dGxpbmU6IG5vbmU7bGluZS1oZWlnaHQ6NDBweDtjdXJzb3I6bW92ZTtjb2xvcjojMDAwJyBjb250ZW50RWRpdGFibGU9J2ZhbHNlJz48aSBzdHlsZT0ncGFkZGluZy1yaWdodDo0cHgnIGNsYXNzPSdcIitpY29uK1wiJz48L2k+XCIraW5uZXJLZXkrXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsX3N0ZXBzW2luZGV4XS5fX2NkYXRhID0gY2RhdGE7XG4gICAgICAgIH0pO1xuXHR9XG5cblxuXG4gICAgZnVuY3Rpb24gZ29OZXh0KGlkKSB7XG4gICAgICAgIGxldCByZWYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK2lkKTtcbiAgICAgICAgaWYocmVmLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmdvbmV4dCA9IHRydWU7XG4gICAgICAgICAgICBuZXdfeG1sLnNteG1sLl9nb25leHQgPSBcIjFcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmdvbmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5fZ29uZXh0ID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlWE1MKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4ZWRBbnN3ZXIoaWQpIHtcbiAgICAgICAgbGV0IHJlZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjXCIraWQpO1xuICAgICAgICBpZihyZWYuY2hlY2tlZCkge1xuICAgICAgICAgICAgc3RhdGUudmFyaWFibGVfYnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuX2ZpeGVkID0gXCIxXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS52YXJpYWJsZV9idXR0b24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuX2ZpeGVkID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlWE1MKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ2hlY2tib3goaWQsIGZpbGxpZCwgZSkge1xuICAgICAgICBsZXQgbmFtZSA9IGUudGFyZ2V0Lm5hbWU7XG4gICAgICAgIGxldCByZWYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK25hbWUraWQpO1xuICAgICAgICBsZXQgdmFsID0gXCJfXCIrZS50YXJnZXQudmFsdWU7XG4gICAgICAgIGxldCBzZXEgPSBpZDtcbiAgICAgICAgaWYocmVmLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtzZXFdW3ZhbF0gPSBcIjFcIjsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfeG1sLnNteG1sLnN0ZXBbc2VxXVt2YWxdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9sZXQgZGF0YSA9IGpRdWVyeSgnIycrZmlsbGlkKS5odG1sKCk7XG4gICAgICAgIGxldCBkYXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycrZmlsbGlkKS5pbm5lckhUTUw7XG4gICAgICAgIHVwZGF0ZVhNTCgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRGlzYWJsZShpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoYW5kbGUgY2xpY2snKTtcbiAgICAgICAgLy9qUXVlcnkoJyNzYXZlX3N0ZXBfJytpKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICBBSC5zZWxlY3QoJyNzYXZlX3N0ZXBfJytpLCdyZW1vdmVBdHRyJywnZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSYWRpbyhpbmRleCwgZmlsbGlkLCBldmVudCkge1xuICAgICAgICBpZihhbGxfc3RlcHNbaW5kZXhdLnRvZ2dsZSA9PSAxKSB7XG4gICAgICAgICAgICBhbGxfc3RlcHNbaW5kZXhdLnRvZ2dsZSA9IDBcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtpbmRleF0uX3ZpZXdvbmx5ID0gXCIwXCI7XG4gICAgICAgICAgICBuZXdfeG1sLnNteG1sLnN0ZXBbaW5kZXhdLl9hdHRlbXB0ID0gXCIxXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxfc3RlcHNbaW5kZXhdLnRvZ2dsZSA9PSAxO1xuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5zdGVwW2luZGV4XS5fdmlld29ubHkgPSBcIjFcIjtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtpbmRleF0uX2F0dGVtcHQgPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2xldCBkYXRhID0galF1ZXJ5KCcjJytmaWxsaWQpLmh0bWwoKTtcbiAgICAgICAgbGV0IGRhdGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJytmaWxsaWQpLmlubmVySFRNTDtcbiAgICAgICAgdXBkYXRlWE1MKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlRXZlbnQoaW5kZXgsIGRhdGEpIHtcbiAgICAgICAgbGV0IGRlbGV0ZV9ldmVudDtcbiAgICAgICAgaWYoZGF0YSA9PSAnc3RlcHMnKSB7XG4gICAgICAgICAgICBkZWxldGVfZXZlbnQgPSBhbGxfc3RlcHM7XG4gICAgICAgICAgICBpZihkZWxldGVfZXZlbnQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZCA9IGRlbGV0ZV9ldmVudC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBSC5hbGVydChcIllvdSBoYXZlIGF0bGVhc3QgMiBzdGVwcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGFsbF9zdGVwcyA9IGRlbGV0ZV9ldmVudDsgXG4gICAgICAgIHVwZGF0ZVhNTCgpO1xuICAgICAgICB9IGVsc2UgaWYoZGF0YSA9PSAnYWxnbycpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS5kZWxldGVJbmRleCA9IGluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTYXZlKGlkLCBmaWxsaWQpIHtcbiAgICAgICAgLy9sZXQgZGF0YSA9IGpRdWVyeSgnIycrZmlsbGlkKS5odG1sKCk7XG4gICAgICAgIGxldCBkYXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycrZmlsbGlkKS5pbm5lckhUTUw7XG4gICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLyZhbXA7L2csJyYnKTsgLy8gcmVwbGFjZSBhbXAgdG8gbWFpbnRhaW4gaHRtbCBlbnRpdHkuXG4gICAgICAgIGFsbF9zdGVwc1tpZF0uX19jZGF0YSA9IGRhdGE7IFxuICAgICAgICAvL2pRdWVyeSgnI3NhdmVfc3RlcF8nK2lkKS5wcm9wKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAvL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzYXZlX3N0ZXBfJytpZCkuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBBSC5zZWxlY3QoJyNzYXZlX3N0ZXBfJytpZCwnYXR0cicse2Rpc2FibGVkOidkaXNhYmxlZCd9KVxuICAgICAgICB1cGRhdGVYTUwoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVYTUwoKSB7XG4gICAgICAgIGxldCBmaXhhbnMgPSBuZXdfeG1sLnNteG1sLl9maXhlZDtcbiAgICAgICAgbGV0IGdvbmV4dCA9IG5ld194bWwuc214bWwuX2dvbmV4dDtcbiAgICAgICAgbGV0IHhtbCA9ICc8c214bWwgdHlwZT1cIjM3XCIgZml4ZWQ9XCInK2ZpeGFucysnXCIgZ29uZXh0PVwiJytnb25leHQrJ1wiPic7XG4gICAgICAgIGFsbF9zdGVwcy5tYXAoZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgICAgICAgbGV0IHNlcSA9IGkrMTtcbiAgICAgICAgICAgIGxldCB2aWV3b25seSA9IGVsZW1lbnQuX3ZpZXdvbmx5O1xuICAgICAgICAgICAgbGV0IG1vZGUgPSBlbGVtZW50Ll9tb2RlO1xuICAgICAgICAgICAgbGV0IGF0dGVtcHQgPSBlbGVtZW50Ll9hdHRlbXB0O1xuICAgICAgICAgICAgbGV0IHN0aWNreSA9IGVsZW1lbnQuX3N0aWNreTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZWxlbWVudC5fX2NkYXRhO1xuICAgICAgICAgICAgLy8gZGF0YSA9IHNlbGYucmV2ZXJzZVJlcGxhY2VWYXJpYWJsZXMoZGF0YSk7XG4gICAgICAgICAgICBkYXRhID0gcmV2ZXJzZUh0bWxTcGVjaWFsQ2hhcnMoZGF0YSk7XG4gICAgICAgICAgICBkYXRhID0gcmVwbGFjZVNwYWNlcyhkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgID0gZGF0YS5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJykucmVwbGFjZSgvJm5ic3A7L2csICcgJyk7XG4gICAgICAgICAgICBkYXRhICA9IGRhdGEucmVwbGFjZSgvJy9nLCAnXCInKS5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgICAgICAgICAgbGV0IGFyciA9IGRhdGEubWF0Y2goLzxzcGFuKC4qPyk+KC4qPyk8XFwvc3Bhbj4vZ2kpO1xuICAgICAgICAgICAgaWYoYXJyKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbGtleSA9IGFycltpXS5tYXRjaCgvb3JpZ2luYWxrZXk9XCIlKC4qPyklXCIvZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG9yaWdpbmFsa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbGtleSA9IG9yaWdpbmFsa2V5LnRvU3RyaW5nKCkucmVwbGFjZSgvb3JpZ2luYWxrZXk9L2csICcnKS5yZXBsYWNlKC9cIiV8JVwiL2csICclJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKGFycltpXSwgb3JpZ2luYWxrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNkYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHhtbCA9IHhtbCArIFwiPHN0ZXAgc2VxPSdcIitzZXErXCInXCIgKyAoKGF0dGVtcHQgIT0gdW5kZWZpbmVkKT8gXCIgYXR0ZW1wdCA9J1wiK2F0dGVtcHQrXCInXCIgOiAnICcpICsgKCh2aWV3b25seSAhPSB1bmRlZmluZWQpPyBcIiB2aWV3b25seSA9J1wiK3ZpZXdvbmx5K1wiJ1wiIDogJyAnKSArICgobW9kZSAhPSB1bmRlZmluZWQpPyBcIiBtb2RlID0nXCIrbW9kZStcIidcIiA6ICcgJykgKyAoKHN0aWNreSAhPSB1bmRlZmluZWQpPyBcIiBzdGlja3kgPSdcIitzdGlja3krXCInXCIgOiAnICcpICtcIj48IS0tW0NEQVRBW1wiK2NkYXRhK1wiXV0tLT48L3N0ZXA+XCI7XG4gICAgICAgIH0pO1xuICAgICAgICB4bWwgPSB4bWwgKyBcIjwvc214bWw+XCI7XG4gICAgICAgIGdldENoaWxkWG1sKHhtbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV2ZXJzZUh0bWxTcGVjaWFsQ2hhcnMoZGF0YSkge1xuICAgICAgICBsZXQgdGFncyA9IGRhdGEubWF0Y2goLyZsdDsoLio/KSZndDsvZ20pO1xuXHRcdGxldCB0YWcgPSAnJztcblx0XHRpZih0YWdzKSB7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFnID0gdGFnc1tpXTtcbiAgICAgICAgICAgICAgICB0YWdzW2ldID0gdGFnc1tpXS5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKHRhZywgdGFnc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTcGFjZXMoZGF0YSkge1xuICAgICAgICBsZXQgbWF0Y2hpbmcgPSBkYXRhLm1hdGNoKC92YXI6dmFyXFxkK1xccytcXHMrL2cpO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGlmKG1hdGNoaW5nKSB7XG4gICAgICAgICAgICBtYXRjaGluZy5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIG1hdGNoID0gaXRlbS50cmltKCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShpdGVtLG1hdGNoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEV2ZW50KGRhdGEpIHtcbiAgICAgICAgbGV0IG9iaiA9IHt9O1xuICAgICAgICBvYmouX3NlcSA9IGFsbF9zdGVwcy5sZW5ndGgrMTtcbiAgICAgICAgb2JqLl92aWV3b25seSA9IFwiMVwiO1xuICAgICAgICBvYmouX2F0dGVtcHQgPSBcIjBcIjtcbiAgICAgICAgb2JqLl9tb2RlID0gXCIwXCI7XG4gICAgICAgIG9iai5fX2NkYXRhID0gXCJOZXcgU3RlcFwiO1xuICAgICAgICBhbGxfc3RlcHMucHVzaChvYmopO1xuICAgICAgICB1cGRhdGVYTUwoKTtcbiAgICAgICAgc3RhdGUuc25hY2tiYWNrID0gdHJ1ZTtcbiAgICAgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXRFZGl0b3IoKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEVkaXRvcigpIHtcbiAgICAgICAgLy8galF1ZXJ5KGRvY3VtZW50KS5vbihcImNsaWNrXCIsIFwiLmVkaXRNYXRoXCIsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyAgICAgd2luZG93LmN1cnJlbnRJZCA9IGpRdWVyeSh0aGlzKS5hdHRyKCdpZCcpO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICBBSC5saXN0ZW4oZG9jdW1lbnQsXCJjbGlja1wiLFwiLmVkaXRNYXRoXCIsZnVuY3Rpb24oX3RoaXMsZSl7XG4gICAgICAgICAgICAvLyB3aW5kb3cuY3VycmVudElkID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudElkID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGpRdWVyeShkb2N1bWVudCkub24oXCJjbGlja1wiLCBcIi5tYXRlcmlhbE92ZXJsYXlcIiwgZnVuY3Rpb24oZSl7XG5cdFx0Ly8gXHR3aW5kb3cuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgLy8gICAgIHdpbmRvdy5jdXJyZW50SW5wID0gbnVsbDtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgQUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJy5tYXRlcmlhbE92ZXJsYXknLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgLy93aW5kb3cuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJZCAgPSBudWxsO1xuICAgICAgICAgICAgLy93aW5kb3cuY3VycmVudElucCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50SW5wID0gbnVsbDtcbiAgICAgICAgfSlcblxuXHRcdHRpbnlNQ0UuUGx1Z2luTWFuYWdlci5hZGQoJ3JlcycsIGZ1bmN0aW9uKGVkaXRvciwgdXJsKSB7XG4gICAgICAgICAgICBlZGl0b3IuYWRkTWVudUl0ZW0oJ3Jlc3AnLCB7XG4gICAgICAgICAgICAgICAgdGV4dDpcIkFkZCByZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGlkOidhZGRUb2tlbicsXG4gICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPcGVuKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiAnaW5zZXJ0JyxcbiAgICAgICAgICAgICAgICBwcmVwZW5kVG9Db250ZXh0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cdFx0dGlueW1jZS5QbHVnaW5NYW5hZ2VyLmxvYWQoJ2VxdWF0aW9uZWRpdG9yJywgdGhlbWVVcmwrJ3BlLWl0ZW1zL3RpbnltY2UvcGx1Z2lucy9lcXVhdGlvbmVkaXRvci9wbHVnaW4ubWluLmpzJyk7XG5cdFx0dGlueW1jZS5pbml0KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnLnRpbnltY2UtZWRpdG9yLXJlcycsXG4gICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICB0aGVtZTogJ21vZGVybicsXG4gICAgICAgICAgICBza2luOiAnc2tpbjAyJyxcbiAgICAgICAgICAgIG1pbl93aWR0aDogMTAwLFxuICAgICAgICAgICAgcmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgbWVudWJhcjogZmFsc2UsXG4gICAgICAgICAgICB0b29sYmFyOiB0cnVlLFxuICAgICAgICAgICAgZWxlbWVudHBhdGg6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzYmFyOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcmNlX2JyX25ld2xpbmVzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX3RyYWlsaW5nX2JyczogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlZF9yb290X2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzOiAnc3BhbltvbkNsaWNrfGNvbnRlbnRFZGl0YWJsZV0nLFxuICAgICAgICAgICAgdmFsaWRfZWxlbWVudHM6IFwiKlsqXVwiLFxuXHRcdFx0Zml4ZWRfdG9vbGJhcl9jb250YWluZXI6ICcjdG9vbGJhcl9jb250YWluZXInLFxuICAgICAgICAgICAgZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHM6ICd1YzpzeW50YXgsdWM6cmVmJyxcbiAgICAgICAgICAgIGN1c3RvbV9lbGVtZW50czogJ3VjOnN5bnRheCx+dWM6cmVmJyxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBcImxpc3RzIGxpbmsgaW1hZ2UgY2hhcm1hcCBwcmludCBwcmV2aWV3IGFuY2hvclwiLFxuICAgICAgICAgICAgICAgIFwic2VhcmNocmVwbGFjZSBjb2RlIGZ1bGxzY3JlZW5cIixcbiAgICAgICAgICAgICAgICBcImluc2VydGRhdGV0aW1lIG1lZGlhIHRhYmxlIGNvbnRleHRtZW51IHBhc3RlIHJlcyBlcXVhdGlvbmVkaXRvciBcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNvbnRlbnRfY3NzOiB0aGVtZVVybCsncGUtaXRlbXMvc3JjL2xpYnMvbWF0aHF1aWxsLmNzcycsXG4gICAgICAgICAgICB0b29sYmFyOiBbXG4gICAgICAgICAgICAnIGJvbGQgaXRhbGljIHVuZGVybGluZSB8IGVxdWF0aW9uZWRpdG9yJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNvbnRleHRtZW51OlwicmVzcFwiLFxuICAgICAgICAgICAgcGFzdGVfYXNfdGV4dDogdHJ1ZVxuICAgICAgICB9KTtcblx0fVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgICAgIGlmKHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAyKSB7XG5cdFx0XHQvL3dpbmRvdy5jdXJyZW50SWQgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudElucCA9IG51bGw7XG5cdFx0fVxuICAgICAgICBzdGF0ZS5vcGVuID0gZmFsc2U7IFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURpYWxvZyh0YXJnZXRWYWwpIHsgIFxuICAgICAgICBzdGF0ZS5maWxsSW5UaGVCbGFua3NDaG9pY2UgPSB0YXJnZXRWYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRWRpdGFibGUoKSB7XG5cdFx0Ly9sZXQgdHh0ID0galF1ZXJ5KFwiI2lucHV0XCIpO1xuICAgICAgICBsZXQgdHh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dFwiKTtcbiAgICAgICAgLy9sZXQgY2FyZXRQb3MgPSB0eHRbMF0uc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGxldCBjYXJldFBvcyA9IHR4dC5zZWxlY3Rpb25TdGFydDtcblx0XHQvL2xldCB0ZXh0QXJlYVR4dCA9IHR4dC52YWwoKTtcbiAgICAgICAgbGV0IHRleHRBcmVhVHh0ID0gdHh0LnZhbHVlO1xuICAgICAgICAgdmFyIHR4dFRvQWRkID0gXCJcXFxcTWF0aFF1aWxsTWF0aEZpZWxkXCI7XG4gICAgICAgIHZhciB0eHRUb0FkZCAgPSBcInVzZXIgUmVzcG9uc2VcIjtcbiAgICAgICAgLy90eHQudmFsKHRleHRBcmVhVHh0LnN1YnN0cmluZygwLCBjYXJldFBvcykgKyB0eHRUb0FkZCArIHRleHRBcmVhVHh0LnN1YnN0cmluZyhjYXJldFBvcykpO1xuICAgICAgICB0eHQudmFsdWUgPSB0ZXh0QXJlYVR4dC5zdWJzdHJpbmcoMCwgY2FyZXRQb3MpICsgdHh0VG9BZGQgKyB0ZXh0QXJlYVR4dC5zdWJzdHJpbmcoY2FyZXRQb3MpO1xuXHR9XG5cbiAgICBmdW5jdGlvbiBsYXRleEVkaXQoKSB7XG4gICAgICAgIHN0YXRlLm9wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3JlQW5zKCkge1xuXHRcdHZhciB2YWxpZGF0ZSA9IDA7XG5cdFx0aWYoc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID09IDEpIHtcblx0XHRcdC8vbGV0IGFucyA9IGpRdWVyeShcIiNpbnB1dDFcIikudmFsKCk7XG4gICAgICAgICAgICBsZXQgYW5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dDFcIikudmFsdWU7XG5cdFx0XHQvL2xldCBudW1lcmljID0galF1ZXJ5KFwiI3Jlc3BvbnNlRGlhbG9nICNudW1lcmljXCIpWzBdLmNoZWNrZWQ7XG4gICAgICAgICAgICBsZXQgbnVtZXJpYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcmVzcG9uc2VEaWFsb2cgI251bWVyaWNcIikuY2hlY2tlZDtcbiAgICAgICAgICAgIGlmKG51bWVyaWMgPT0gdHJ1ZSkge1xuXHRcdFx0XHRhbnMgKz0gXCIgfG5cIjtcblx0XHRcdH1cblx0XHRcdGlmKGFucy50cmltKCkgPT0gXCJcIikge1xuXHRcdFx0XHR2YWxpZGF0ZSA9IDE7XG5cdFx0XHRcdHZhbGlkYXRlKFwiQWxsIGZpZWxkcyBhcmUgcmVxdWlyZWRcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aW55TUNFLmFjdGl2ZUVkaXRvci5pbnNlcnRDb250ZW50KFwiPHNwYW4gdHlwZT0ndCcgY2xhc3M9J2FsZXJ0IGFsZXJ0LWluZm8gZWRpdEZpbGwnIG9yaWdpbmFsS2V5PScle1wiK2Fucy50cmltKCkrXCJ9JScgc3R5bGU9J3BhZGRpbmc6IDVweDtvdXRsaW5lOiBub25lO2xpbmUtaGVpZ2h0OjQwcHg7Y3Vyc29yOm1vdmU7Y29sb3I6IzAwMCcgY29udGVudEVkaXRhYmxlPSdmYWxzZSc+PGkgc3R5bGU9J3BhZGRpbmctcmlnaHQ6NHB4JyBjbGFzcz0naWNvbW9vbi1pbnNlcnQtdGVtcGxhdGUnPjwvaT5cIisoKG51bWVyaWMgPT0gdHJ1ZSk/XCJOdW1lcmljXCI6XCJUZXh0Ym94XCIpK1wiPC9zcGFuPlwiKTtcblx0XHRcdH1cbiAgICAgICAgfVxuICAgICAgICBpZihzdGF0ZS5maWxsSW5UaGVCbGFua3NDaG9pY2UgPT0gMikge1xuXHRcdFx0Ly9sZXQgZSA9IGpRdWVyeShcIiNpbnB1dFwiKS52YWwoKTtcbiAgICAgICAgICAgIGxldCBlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dFwiKS52YWx1ZTtcblx0XHRcdGlmKHZhbGlkYXRlID09IDApIHtcblx0XHRcdFx0Ly9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK3dpbmRvdy5jdXJyZW50SWQpLnNldEF0dHJpYnV0ZShcImxhdGV4XCIsZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNcIitzdGF0ZS5jdXJyZW50SWQpLnNldEF0dHJpYnV0ZShcImxhdGV4XCIsZSk7XG5cdFx0XHRcdC8vZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNcIit3aW5kb3cuY3VycmVudElkKS5zZXRBdHRyaWJ1dGUoXCJvcmlnaW5hbEtleVwiLFwiJXtcIitlK1wifGV9JVwiKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK3N0YXRlLmN1cnJlbnRJZCkuc2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIixcIiV7XCIrZStcInxlfSVcIik7XG5cdFx0XHRcdC8vd2luZG93LmN1cnJlbnRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudElkID0gbnVsbDtcblx0XHRcdFx0Ly93aW5kb3cuY3VycmVudElucCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudElucCA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWxpZGF0ZShcIkFsbCBmaWVsZHMgYXJlIHJlcXVpcmVkXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHZhbGlkYXRlID09IDApIHtcblx0XHRcdGhhbmRsZUNsb3NlKCk7XG5cdFx0fVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU9wZW4oKSB7XG4gICAgICAgIC8vIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAvLyAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgLy8gICAgIGNvZGV0eXBlOiBmYWxzZSxcbiAgICAgICAgLy8gICAgIG51bWVyaWM6IGZhbHNlXG4gICAgICAgIC8vIH0pO1xuICAgICAgICBzdGF0ZS5vcGVuID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuY29kZXR5cGUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUubnVtZXJpYyA9IGZhbHNlO1xuICAgICAgICAvL3RoaXMuc2V0U3RhdGUoe2NvZGV0eXBlOiBmYWxzZX0pOyAjYWxyZWFkeSBjb21tZW50ZWQgb24gYWxzbyByZWFjdFxuICAgICAgICAvL3RoaXMuc2V0U3RhdGUoe251bWVyaWM6IGZhbHNlfSk7ICNhbHJlYWR5IGNvbW1lbnRlZCBvbiBhbHNvIHJlYWN0XG4gICAgfVxuXG48L3NjcmlwdD4gXG48bWFpbj5cbiAgICA8ZGl2IGNsYXNzPVwibXQtaW1wIGJvcmRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYm9yZGVyLWJvdHRvbSBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gcHgtMiBwdC0xXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1pbmxpbmUtYmxvY2sgcHQtMSBmbG9hdC1zdGFydCBjcl9zdGVwXCIgc3R5bGU9eydmb250LXNpemU6MjBweDtwb3NpdGlvbjpyZWxhdGl2ZTsnfT57bC5jcmVhdGVfc3RlcHN9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7fX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGVzX2NoZWNrYm94IGQtaW5saW5lLWJsb2NrIHRvcC1jaGVja2JveF9nb25leHQgcG9zaXRpb24tcmVsYXRpdmUgdG9wMlwiPlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94ICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiZ29fbmV4dFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSB7c3RhdGUuZ29uZXh0ID8gdHJ1ZTogZmFsc2V9IFxuICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eyhlKT0+e2dvTmV4dChcImdvX25leHRcIixlKX19IFxuICAgICAgICAgICAgICAgICAgICA+e1wiR28gTmV4dFwifTwvQ2hlY2tib3g+XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZXNfY2hlY2tib3ggZC1pbmxpbmUtYmxvY2sgbS1sIHRvcC1jaGVja2JveF9maXggcG9zaXRpb24tcmVsYXRpdmUgdG9wMlwiPlxuICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJmaXhlZGFuc19jaGVja2JveFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSB7c3RhdGUudmFyaWFibGVfYnV0dG9uID8gdHJ1ZTogZmFsc2V9IFxuICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eyhlKT0+e2ZpeGVkQW5zd2VyKFwiZml4ZWRhbnNfY2hlY2tib3hcIixlKX19IFxuICAgICAgICAgICAgICAgICAgICA+e1wiRml4IEFuc3dlclwifSA8L0NoZWNrYm94PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJvdXRlcl9zdGVwcyBtdC0zIG14LTMgY2xlYXItYm90aFwiPlxuICAgICAgICAgICAgPCEtLSB7dGhpcy5hbGxfc3RlcHMubWFwKChpdGVtLCBpbmRleCkgPT4gLS0+XG4gICAgICAgICAgICB7I2VhY2ggYWxsX3N0ZXBzIGFzIGl0ZW0saW5kZXh9XG4gICAgICAgICAgICAgICAgPGZpZWxkc2V0IGtleT17aW5kZXh9IHN0eWxlPXsnYm9yZGVyOjFweCBzb2xpZCBncmV5J30gY2xhc3M9XCJuZXdfc3RlcHMgc2VxX2luYm94IGZ3IHNoYWRvdy1zbSBtYi0yXCI+XG4gICAgICAgICAgICAgICAgICAgIDxsZWdlbmQgY2xhc3M9XCJmb250MTggbWIgbXMtMiBwbC0xXCIgc3R5bGU9eyd3aWR0aDoxZW07ZmxvYXQ6bm9uZTsnfT57aW5kZXgrMX08L2xlZ2VuZD5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtaW5saW5lLWJsb2NrIHRhYmxlX3dpZHRoIG1zLTIgcGwtMSBwYi0yIG1iLTFcIiBzdHlsZT17J3dpZHRoOjk3JTsnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1zZXE9e2luZGV4fSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRpbnltY2UtZWRpdG9yLXJlcyBzdGVwc19lZGl0IHAtMSBib3JkZXIgZmlsbEF1dGhvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2BmaWxsQXV0aG9yXyR7aW5kZXh9YH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9eydwYWRkaW5nOjAgOHB4O292ZXJmbG93OmF1dG87b3V0bGluZTpub25lJ30gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVkaXRhYmxlPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdGV4dD1cIkVudGVyIHRleHQgaGVyZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246a2V5dXA9eyhlKT0+e2hhbmRsZURpc2FibGUoaW5kZXgsZSl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAge0BodG1sIGl0ZW0uX19jZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZpZXdfY2hlY2tib3ggZC1pbmxpbmUtYmxvY2sgbGlnaHQtY3lhbi1iZyBweC0yIHAtMSBmdWxsLXdpZHRoIGZ3aWR0aFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGVzdCBkLWlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwb2ludGVyIGQtaW5saW5lLWJsb2NrIHBsYWluX3RleHRcIiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiB0aXRsZT1cIkRvbid0IHVzZSBhbnkgaW50ZXJhY3RpdmUgaXRlbSFcIiBmb3I9e2B2aWV3b25seV9yYWRpb18ke2luZGV4fWB9PntsLnBsYWluX3RleHR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0LXBlcmNlbnQgbXMtNFwiIHN0eWxlPXsnZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7J30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb3JtLWNoZWNrIGZvcm0tc3dpdGNoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiBpZD1cInN3aXRjaEVsZW1lbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17KGl0ZW0udG9nZ2xlID09IFwiMVwiPyBmYWxzZTogdHJ1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9eyhlKT0+e2hhbmRsZVJhZGlvKGluZGV4LCAnZmlsbEF1dGhvcl8nK2luZGV4LGUpfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yPVwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInN3aXRjaEVsZW1lbnRcIj57bC5pbnRlcmFjdGl2ZX08L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtaW5saW5lLWJsb2NrIHBsYWluX3RleHQgbXMtM1wiID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2Rlc19jaGVja2JveCBkLWlubGluZS1ibG9jayBtcy0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGVja19ib3ggZC1pbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSB7KGl0ZW0uX21vZGUgPT0gXCIxXCIpID8gLS0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5fbW9kZSA9PSBcIjFcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCBkYXRhLXNlcT17aW5kZXh9IGNsYXNzPVwiaW5uZXJfaW5wdXRzIG9wdGlvbl9jaGVja2JveFwiIG9uOmNsaWNrPXsoZSk9PntoYW5kbGVDaGFuZ2VDaGVja2JveChpbmRleCwgJ2ZpbGxBdXRob3JfJytpbmRleCxlKX19IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwibW9kZVwiIG5hbWU9XCJtb2RlX2NoZWNrYm94X1wiIGlkPXtgbW9kZV9jaGVja2JveF8ke2luZGV4fWB9IGNoZWNrZWQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGF0YS1zZXE9e2luZGV4fSBjbGFzcz1cImlubmVyX2lucHV0cyBvcHRpb25fY2hlY2tib3hcIiBvbjpjbGljaz17KGUpPT57aGFuZGxlQ2hhbmdlQ2hlY2tib3goaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgsZSl9fSB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIm1vZGVcIiBuYW1lPVwibW9kZV9jaGVja2JveF9cIiBpZD17YG1vZGVfY2hlY2tib3hfJHtpbmRleH1gfSBjaGVja2VkPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9udC13ZWlnaHQtbm9ybWFsIG1lLTEgcG9zaXRpb24tcmVsYXRpdmUgdG9wMiByaWdodDM1XCIgZm9yPXtgbW9kZV9jaGVja2JveF8ke2luZGV4fWB9PntsLm5vX3ZhbGlkYXRpb259PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSB7aW5kZXggPT0gMCA/ICAtLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaW5kZXggPT0gMH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RpY2tfY2hlY2tib3ggZC1pbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGVja19ib3ggZC1pbmxpbmUtYmxvY2tcIj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSB7KGl0ZW0uX3N0aWNreSA9PSBcIjFcIikgPyAtLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5fc3RpY2t5ID09IFwiMVwifSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGF0YS1zZXE9e2luZGV4fSBjaGVja2VkPXt0cnVlfSBjbGFzcz1cImlubmVyX2lucHV0cyBvcHRpb25fY2hlY2tib3hcIiBvbjpjbGljaz17aGFuZGxlQ2hhbmdlQ2hlY2tib3guYmluZCh0aGlzLCBpbmRleCwgJ2ZpbGxBdXRob3JfJytpbmRleCl9IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwic3RpY2t5XCIgbmFtZT1cInN0aWNreV9jaGVja2JveF9cIiBpZD17YHN0aWNreV9jaGVja2JveF8ke2luZGV4fWB9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGF0YS1zZXE9e2luZGV4fSBjaGVja2VkPXtmYWxzZX0gY2xhc3M9XCJpbm5lcl9pbnB1dHMgb3B0aW9uX2NoZWNrYm94XCIgb246Y2xpY2s9e2hhbmRsZUNoYW5nZUNoZWNrYm94LmJpbmQodGhpcywgaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgpfSB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInN0aWNreVwiIG5hbWU9XCJzdGlja3lfY2hlY2tib3hfXCIgaWQ9e2BzdGlja3lfY2hlY2tib3hfJHtpbmRleH1gfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvbnQtd2VpZ2h0LW5vcm1hbCBtZS0xIHBvc2l0aW9uLXJlbGF0aXZlIHRvcDIgcmlnaHQzNVwiIGZvcj17YHN0aWNreV9jaGVja2JveF8ke2luZGV4fWB9PntsLnN0aWNreX08L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn0gXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXsnZGlzcGxheTppbmxpbmUtYmxvY2s7ZmxvYXQ6cmlnaHQ7J30gY2xhc3M9XCJidXR0b25zIGVkaXRfc3RlcHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWlubGluZS1ibG9jayBtclwiIHN0eWxlPXsnZGlzcGxheTppbmxpbmUtYmxvY2s7J30gb246Y2xpY2s9eyhlKT0+e2RlbGV0ZUV2ZW50KGluZGV4LCAnc3RlcHMnLGUpfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpZ2h0IGZvbnQxMlwiPntsLmRlbGV0ZX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWlubGluZS1ibG9ja1wiIHN0eWxlPXsndGV4dC1hbGlnbjpyaWdodDttYXJnaW4tdG9wOjZweDsnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPXtgc2F2ZV9zdGVwXyR7aW5kZXh9YH0gdHlwZT1cImJ1dHRvblwiIG9uOmNsaWNrPXsoZSk9PntoYW5kbGVTYXZlKGluZGV4LCAnZmlsbEF1dGhvcl8nK2luZGV4LGUpfX0gY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgZm9udDEyIHNhdmVfYnV0dG9uX3N0ZXBzXCI+e2wuc2F2ZX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9maWVsZHNldD5cbiAgICAgICAgICAgIDwhLS0gKX0gLS0+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG14LTMgbXQtMyBwYi0zXCI+XG4gICAgICAgICAgICA8QnV0dG9uIHZhcmlhbnQ9XCJmYWJcIiBjb2xvcj1cInByaW1hcnlcIiBtaW5pIGFyaWEtbGFiZWw9XCJBZGRcIlxuICAgICAgICAgICAgICAgIG9uOmNsaWNrPXthZGRFdmVudC5iaW5kKHRoaXMsICdzdGVwcycpfVxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgcm91bmRlZCBwb3NpdGlvbi1yZWxhdGl2ZSBib3R0b20wIGJnLXdoaXRlIHNoYWRvdy1zbSBoZWlnaHQzMFwiXG4gICAgICAgICAgICAgICAgc3R5bGU9eydmbG9hdDpsZWZ0O3dpZHRoOjEyMHB4O2hlaWdodDozMHB4O2JvcmRlcjoxcHggc29saWQgIzQyODVmNDtjb2xvcjojNDI4NWY0O3RleHQtdHJhbnNmb3JtOm5vbmU7J30+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb250MThcIj4mIzQzOyAmbmJzcDs8L3NwYW4+IEFkZCBTdGVwXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxEaWFsb2cgb3ZlcmxheUNsYXNzPVwibWF0ZXJpYWxPdmVybGF5XCIgIGJpbmQ6dmlzaWJsZT17c3RhdGUub3Blbn0gb246Y2xvc2U9e2hhbmRsZUNsb3NlLmJpbmQodGhpcyl9IGRpc2FibGVFbmZvcmNlRm9jdXM9e3RydWV9IHdpZHRoPVwiNjUwXCIgY2xhc3M9XCJyb3dcIiBzdHlsZT17J2JhY2tncm91bmQtY29sb3I6ICNmZmY7J30+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gPERpYWxvZ1RpdGxlIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcz17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6XCJwLW1kIGVkaXRvcl9tb2RhbF90aXRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPiAtLT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzbG90PVwidGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtci1sZyBmbG9hdC1sZWZ0XCIgc3R5bGU9eydwYWRkaW5nLXRvcDoxMHB4O3BhZGRpbmctbGVmdDoxM3B4O2ZvbnQtc2l6ZToxOHB4Oyd9PntsLmZpbGxfaGVhZGVyfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxvYXQtcmlnaHQgbXItNFwiPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG10LTEgcm93IG1sLTBcIj5cblx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz17XCJidG4gYnRuLWxpZ2h0IGNvbC0zXCIgKyAoKHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAxKT8gXCIgYWN0aXZlXCI6IFwiXCIpfSB2YWx1ZT17MX0gb246Y2xpY2s9e3VwZGF0ZURpYWxvZy5iaW5kKHRoaXMsIDEpfSA+VGV4dDwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHRcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPXtcImJ0biBidG4tbGlnaHQgY29sLTlcIiArICgoc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID09IDIpPyBcIiBhY3RpdmVcIjogXCJcIil9IHZhbHVlPXsyfSBvbjpjbGljaz17dXBkYXRlRGlhbG9nLmJpbmQodGhpcywgMil9ID5NYXRoZW1hdGljYWwgRXF1YXRpb248L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gPC9EaWFsb2dUaXRsZT4gLS0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwicmVzcG9uc2VEaWFsb2dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAxfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBtci0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIndpZHRoMTAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAgaWQgPSBcIm51bWVyaWNcIiBjaGVja2VkID0ge3N0YXRlLm51bWVyaWN9PntcIk51bWVyaWNcIn08L0NoZWNrYm94PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IFwiaW5wdXQxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge3N0YXRlLmlucHV0X2Fuc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sIG1yLTQgbWwtM1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17J21hcmdpbjo1cHgnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0bzpmb2N1cyA9IHt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSB7KChBSC5zZWxlY3QoXCIjaW5wdXQxXCIpLmlubmVySFRNTCAhPSBcIlwiKT9sLmZpbGxfdGV4dF9wbGFjZWhvbGRlcjpcIlwiKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtZGFuZ2VyIGZvbnQtd2VpZ2h0LWJvbGQgbWwtMiBtdC0zXCI+KiBOb3RlOjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtZGFuZ2VyIG1sLTJcIiBzdHlsZT17J3RleHQtaW5kZW50OjE1cHgnfT57bC5maWxsX3RleHRfaGVscDF9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1kYW5nZXIgbWwtMlwiIHN0eWxlPXsndGV4dC1pbmRlbnQ6MTVweCd9PjIuIFBsZWFzZSBkbyBub3QgaW5jbHVkZSBzcGFjZS48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB7XCJpbnB1dFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwibGF0ZXhJbnAgZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7J21hcmdpbjo1cHg7d2lkdGg6NzElOyd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG86Zm9jdXMgPSB7dHJ1ZX1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQgPSBcImNvbnRhaW5lZFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IFwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geydib3JkZXI6MXB4IHNvbGlkICM0Mjg1ZjQ7Y29sb3I6IzQyODVmNDt0ZXh0LXRyYW5zZm9ybTpub25lOyd9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljayA9IHthZGRFZGl0YWJsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSBoZWlnaHQzMCBiZy13aGl0ZSBzaGFkb3ctc20gbXQtMSB0b3AxIG1sLTFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBZGQgUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj4gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzID0gXCJsYXRleEVkaXRCdXR0b24gZC1pbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0ge1wibGF0ZXhFZGl0XCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50ID0gXCJjb250YWluZWRcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gXCJwcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geydtYXJnaW46NXB4O2Rpc3BsYXk6bm9uZTsnfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0ge2xhdGV4RWRpdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlciBmb250LXdlaWdodC1ib2xkIG1sLTFcIj4qIE5vdGU6PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1kYW5nZXIgbWwtMVwiIHN0eWxlPXsndGV4dC1pbmRlbnQ6IDE1cHg7J30+e2wuZmlsbF9tYXRoX2hlbHAxfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtZGFuZ2VyIG1sLTFcIiBzdHlsZT17J3RleHQtaW5kZW50OiAxNXB4Oyd9PntsLmZpbGxfbWF0aF9oZWxwMn08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn0gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3ZlbHRlRm9vdGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHZhcmlhbnQ9XCJjb250YWluZWRcIiBvbjpjbGljaz17aGFuZGxlQ2xvc2V9ID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bC5jYW5jZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj4sXG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHZhcmlhbnQ9XCJjb250YWluZWRcIiBvbjpjbGljaz17c3RvcmVBbnN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiZy1wcmltYXJ5IHRleHQtd2hpdGVcIj57bC5kb25lfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0RpYWxvZz5cbjwvbWFpbj5cblxuXG4gICAgXG5cblxuPHN0eWxlPlxuICAgIC5mb250MTgge1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgfVxuICAgIC5md2lkdGggICB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIC5saWdodC1jeWFuLWJnIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Q0ZTRmZjsgXG4gICAgICAgIGNvbG9yOiAjMzMzO1xuICAgIH1cblxuICAgIC50b3AyIHtcbiAgICAgICAgdG9wOiAycHg7XG4gICAgfVxuICAgIC5yaWdodDUge1xuICAgICAgICByaWdodDogNXB4O1xuICAgIH1cblxuICAgIC5yaWdodDM1IHtcbiAgICAgICAgcmlnaHQ6IDM1cHg7XG4gICAgfVxuXG4gICAgLnN0ZXBfY2hlY2tib3gge1xuICAgICAgICB3aWR0aDogMjIlO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDEwcHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm90dG9tOiAxcHg7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgcGFkZGluZzogM3B4IDJweCAwO1xuICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAvKiAuc3RlcHNfZWRpdDplbXB0eTpiZWZvcmUge1xuICAgICAgICBjb250ZW50OiBhdHRyKGRhdGEtdGV4dCksXG4gICAgICAgIGNvbnRlbnQtZWRpdGFibGU6ZmFsc2U7XG4gICAgfSAqL1xuXG4gICAgLmZpeGVkX2FucyB7XG4gICAgICAgIHRvcDogMTBweDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNlMGUwZTA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgcGFkZGluZzogNXB4O1xuICAgICAgICBmb250LXNpemU6IDE1cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgfVxuXG4gICAgLmNoZWNrX2JveCB7XG4gICAgICAgIHJpZ2h0OiAyNHB4O1xuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDQwcHg7XG4gICAgfVxuXG4gICAgLmlubmVyX2lucHV0cyB7XG4gICAgICAgIG1hcmdpbjogMCAxMnB4IWltcG9ydGFudDtcbiAgICB9ICAgICAgXG4gICAgXG4gICAgLnBvaW50ZXIge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXIgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAud2lkdGgxMDAge3dpZHRoOiAxMDBweDt9XG5cbiAgICAvKiAuZWRpdF9zdGVwcyB7XG4gICAgICAgIG1hcmdpbi10b3A6IDExcHghaW1wb3J0YW50O1xuICAgIH1cbiAgICAudmlld19jaGVja2JveCB7XG4gICAgICAgIGhlaWdodDogNzVweDtcbiAgICB9XG4gICAgLnBsYWluX3RleHQge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJvdHRvbTogMjBweDtcbiAgICB9ICovXG5cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSkge1xuICAgICAgICBvdmVyZmxvdzpoaWRkZW47XG4gICAgICAgIC8qd2lkdGg6NzAwcHg7ICB0ZXN0aW5nKi9cbiAgICAgICAgdGV4dC1hbGlnbjpsZWZ0O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSBwcmUpIHtcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICBmb250LXNpemU6IDE0cHghaW1wb3J0YW50O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuc3RyaW5nKSB7XG4gICAgICAgIG1pbi1oZWlnaHQ6NTBweDtcbiAgICAgICAgbWFyZ2luLXRvcDoxMHB4O1xuICAgICAgICBtYXJnaW4tcmlnaHQ6MTBweDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZvb3RlcnN0cikge1xuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgbWluLWhlaWdodDogNjBweDsvKjEwMHB4OyovXG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5mb290ZXJzdHIgLmFycm93LXVwKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtMTBweDtcbiAgICAgICAgcmlnaHQ6IDUwJTtcbiAgICAgICAgd2lkdGg6IDA7XG4gICAgICAgIGhlaWdodDogMDtcbiAgICAgICAgYm9yZGVyLWxlZnQ6IDEwcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlci1yaWdodDogMTBweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMTBweCBzb2xpZCAjY2NjO1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZmlsbC1yb3cpIHtcbiAgICAgICAgcGFkZGluZzo2cHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5maWxsZWxlbWVudCwgW2lkXj1cImZpbGxtYWluXCJdIC5kcmFnLXJlc2l6ZSkge1xuICAgICAgICBoZWlnaHQ6MzBweDtcbiAgICAgICAgZGlzcGxheTppbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xuICAgICAgICBtaW4taGVpZ2h0OiAzMHB4O1xuICAgICAgICBtYXJnaW46IDFweDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gaW5wdXRbdHlwZT1cInRleHRcIl0sIFtpZF49XCJmaWxsbWFpblwiXSBzZWxlY3QpIHtcdFxuICAgICAgICBoZWlnaHQ6OTklIWltcG9ydGFudDtcbiAgICAgICAgcmVzaXplOiBub25lO1xuICAgICAgICBmb250LXNpemU6MTJweDtcbiAgICAgICAgY29sb3I6ICMwMDA7XG4gICAgICAgIG1heC13aWR0aDogODAwcHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5kcmFnLXJlc2l6ZSkge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7XG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgIzMxQjczMTtcbiAgICAgICAgdGV4dC1hbGlnbjpjZW50ZXI7XG4gICAgICAgIHBhZGRpbmc6M3B4O1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5kcmFnLXJlc2l6ZS51aS1kcmFnZ2FibGUpIHtcbiAgICAgICAgY3Vyc29yOm1vdmU7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5kcm9wLWhvdmVyKSB7XG4gICAgICAgIGJvcmRlcjogMXB4IGRhc2hlZCByZWQhaW1wb3J0YW50O1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAycHggeWVsbG93IGluc2V0O1xuICAgICAgICBvdXRsaW5lOiAxcHggc29saWQgYmx1ZTtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZpbGxjaGVjayB1bCkge1xuICAgICAgICB3aWR0aDoyMjBweDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZpbGxjaGVjayBsaS5zZWxlY3RlZCkge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRTVFNUU1O1xuICAgIH1cbiAgICA6Z2xvYmFsKC5maWxsY2hlY2sgLnNlbGVjdGVkIC5pY29tb29uLWNoZWNrbWFyay0zOmJlZm9yZSkge1xuICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgICAgIHBhZGRpbmc6IDNweDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICByaWdodDogMTRweDtcbiAgICB9XG4gICAgOmdsb2JhbCguZmlsbGNoZWNrIC5pY29tb29uLWNsb3NlLTI6YmVmb3JlKSB7XG4gICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICBjb2xvcjogYmx1ZTtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICByaWdodDogMTRweDtcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgIH1cbiAgICA6Z2xvYmFsKC5NYXRoSmF4X0Rpc3BsYXkpIHtcbiAgICAgICAgICAgIGRpc3BsYXkgOiBpbmxpbmUhaW1wb3J0YW50O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuc2VsZWN0KSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTVweDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLnRleHRhcmVhKSB7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOm1pZGRsZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czozcHg7XG4gICAgICAgIGJhY2tncm91bmQ6I2ZmZTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcbiAgICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwwLjA3NSk7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLDAuMDc1KTtcbiAgICB9XG4gICAgOmdsb2JhbCgudWktZHJhZ2dhYmxlLWRpc2FibGVkKSB7XG4gICAgICAgIGN1cnNvcjogbm8tZHJvcCFpbXBvcnRhbnQ7XG4gICAgICAgIG9wYWNpdHk6IDAuNSFpbXBvcnRhbnQ7XG4gICAgfVxuICAgICAgICAgICAgICAgIFxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBOHZCSSxPQUFPLGNBQUMsQ0FBQyxBQUNMLFNBQVMsQ0FBRSxJQUFJLEFBQ25CLENBQUMsQUFDRCxPQUFPLGNBQUcsQ0FBQyxBQUNQLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUVELGNBQWMsY0FBQyxDQUFDLEFBQ1osZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxLQUFLLGNBQUMsQ0FBQyxBQUNILEdBQUcsQ0FBRSxHQUFHLEFBQ1osQ0FBQyxBQUNELE9BQU8sY0FBQyxDQUFDLEFBQ0wsS0FBSyxDQUFFLEdBQUcsQUFDZCxDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDTixLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxjQUFjLGNBQUMsQ0FBQyxBQUNaLEtBQUssQ0FBRSxHQUFHLENBQ1YsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUN2QixXQUFXLENBQUUsSUFBSSxDQUNqQixRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsR0FBRyxDQUNYLE1BQU0sQ0FBRSxPQUFPLENBQ2YsT0FBTyxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUN0QixDQUFDLEFBT0QsVUFBVSxjQUFDLENBQUMsQUFDUixHQUFHLENBQUUsSUFBSSxDQUNULFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxLQUFLLENBQ1osTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUN6QixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxHQUFHLENBQ1osU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsR0FBRyxBQUNwQixDQUFDLEFBRUQsVUFBVSxjQUFDLENBQUMsQUFDUixLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsUUFBUSxDQUNqQixLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxhQUFhLGNBQUMsQ0FBQyxBQUNYLE1BQU0sQ0FBRSxDQUFDLENBQUMsSUFBSSxVQUFVLEFBQzVCLENBQUMsQUFFRCxRQUFRLGNBQUMsQ0FBQyxBQUNOLE1BQU0sQ0FBRSxPQUFPLENBQUMsVUFBVSxBQUM5QixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsS0FBSyxDQUFFLEtBQUssQUFBQyxDQUFDLEFBYWpCLGdCQUFnQixBQUFFLENBQUMsQUFDdkIsU0FBUyxNQUFNLENBRWYsV0FBVyxJQUFJLEFBQ25CLENBQUMsQUFDTyxvQkFBb0IsQUFBRSxDQUFDLEFBQzNCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxJQUFJLENBQ1osU0FBUyxDQUFFLElBQUksVUFBVSxBQUM3QixDQUFDLEFBQ08sd0JBQXdCLEFBQUUsQ0FBQyxBQUMvQixXQUFXLElBQUksQ0FDZixXQUFXLElBQUksQ0FDZixhQUFhLElBQUksQUFDckIsQ0FBQyxBQUNPLDJCQUEyQixBQUFFLENBQUMsQUFDbEMsU0FBUyxRQUFRLENBQ2pCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLGdCQUFnQixDQUFFLElBQUksQ0FDdEIsT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsSUFBSSxBQUNwQixDQUFDLEFBQ08scUNBQXFDLEFBQUUsQ0FBQyxBQUM1QyxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsS0FBSyxDQUNWLEtBQUssQ0FBRSxHQUFHLENBQ1YsS0FBSyxDQUFFLENBQUMsQ0FDUixNQUFNLENBQUUsQ0FBQyxDQUNULFdBQVcsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FDbkMsWUFBWSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUNwQyxhQUFhLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEFBQ2xDLENBQUMsQUFDTywwQkFBMEIsQUFBRSxDQUFDLEFBQ2pDLFFBQVEsR0FBRyxBQUNmLENBQUMsQUFDTyw0REFBNEQsQUFBRSxDQUFDLEFBQ25FLE9BQU8sSUFBSSxDQUNYLFFBQVEsWUFBWSxDQUNwQixTQUFTLFFBQVEsQ0FDakIsVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLEdBQUcsQUFDZixDQUFDLEFBQ08sNERBQTRELEFBQUUsQ0FBQyxBQUNuRSxPQUFPLEdBQUcsVUFBVSxDQUNwQixNQUFNLENBQUUsSUFBSSxDQUNaLFVBQVUsSUFBSSxDQUNkLEtBQUssQ0FBRSxJQUFJLENBQ1gsU0FBUyxDQUFFLEtBQUssQUFDcEIsQ0FBQyxBQUNPLDZCQUE2QixBQUFFLENBQUMsQUFDcEMsZUFBZSxNQUFNLENBQ3JCLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQ3hCLFdBQVcsTUFBTSxDQUNqQixRQUFRLEdBQUcsQ0FDWCxTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBQ08sMENBQTBDLEFBQUUsQ0FBQyxBQUNqRCxPQUFPLElBQUksQUFDZixDQUFDLEFBQ08sNEJBQTRCLEFBQUUsQ0FBQyxBQUNuQyxNQUFNLENBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLFVBQVUsQ0FDaEMsVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNsQyxPQUFPLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEFBQzNCLENBQUMsQUFDTyw4QkFBOEIsQUFBRSxDQUFDLEFBQ3JDLE1BQU0sS0FBSyxBQUNmLENBQUMsQUFDTyx1Q0FBdUMsQUFBRSxDQUFDLEFBQzlDLGdCQUFnQixDQUFFLE9BQU8sQUFDN0IsQ0FBQyxBQUNPLGdEQUFnRCxBQUFFLENBQUMsQUFDdkQsS0FBSyxDQUFFLElBQUksQ0FDWCxLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxHQUFHLENBQ1osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQUFDZixDQUFDLEFBQ08sa0NBQWtDLEFBQUUsQ0FBQyxBQUN6QyxLQUFLLENBQUUsSUFBSSxDQUNYLEtBQUssQ0FBRSxJQUFJLENBQ1gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBQ08sZ0JBQWdCLEFBQUUsQ0FBQyxBQUNuQixPQUFPLENBQUcsTUFBTSxVQUFVLEFBQ2xDLENBQUMsQUFDTyx3QkFBd0IsQUFBRSxDQUFDLEFBQy9CLFNBQVMsQ0FBRSxJQUFJLEFBQ25CLENBQUMsQUFDTywwQkFBMEIsQUFBRSxDQUFDLEFBQ2pDLGVBQWUsTUFBTSxDQUNyQixjQUFjLEdBQUcsQ0FDakIsV0FBVyxJQUFJLENBQ2YsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN0QixrQkFBa0IsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FDckQsVUFBVSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxBQUNqRCxDQUFDLEFBQ08sc0JBQXNCLEFBQUUsQ0FBQyxBQUM3QixNQUFNLENBQUUsT0FBTyxVQUFVLENBQ3pCLE9BQU8sQ0FBRSxHQUFHLFVBQVUsQUFDMUIsQ0FBQyJ9 */";
	append_dev(document_1.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

// (568:20) <Checkbox                           id="go_next"                          defaultChecked = {state.gonext ? true: false}                          on:click={(e)=>{goNext("go_next",e)}}                      >
function create_default_slot_8(ctx) {
	let t_value = "Go Next" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(568:20) <Checkbox                           id=\\\"go_next\\\"                          defaultChecked = {state.gonext ? true: false}                          on:click={(e)=>{goNext(\\\"go_next\\\",e)}}                      >",
		ctx
	});

	return block;
}

// (576:20) <Checkbox                           id="fixedans_checkbox"                          defaultChecked = {state.variable_button ? true: false}                          on:click={(e)=>{fixedAnswer("fixedans_checkbox",e)}}                      >
function create_default_slot_7(ctx) {
	let t_value = "Fix Answer" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(576:20) <Checkbox                           id=\\\"fixedans_checkbox\\\"                          defaultChecked = {state.variable_button ? true: false}                          on:click={(e)=>{fixedAnswer(\\\"fixedans_checkbox\\\",e)}}                      >",
		ctx
	});

	return block;
}

// (625:32) {:else}
function create_else_block_2(ctx) {
	let checkbox;
	let current;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[23](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: false
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_3);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(625:32) {:else}",
		ctx
	});

	return block;
}

// (622:32) {#if item._mode == "1"}
function create_if_block_3(ctx) {
	let checkbox;
	let current;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[22](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: true
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_2);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(622:32) {#if item._mode == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (634:24) {#if index == 0}
function create_if_block_1(ctx) {
	let div;
	let span;
	let current_block_type_index;
	let if_block;
	let t0;
	let label;
	let label_for_value;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[38]._sticky == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if_block.c();
			t0 = space();
			label = element("label");
			label.textContent = `${language.sticky}`;
			attr_dev(span, "class", "check_box d-inline-block svelte-smsdwz");
			add_location(span, file, 635, 32, 24536);
			attr_dev(label, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-smsdwz");
			attr_dev(label, "for", label_for_value = `sticky_checkbox_${/*index*/ ctx[40]}`);
			add_location(label, file, 644, 32, 25427);
			attr_dev(div, "class", "stick_checkbox d-inline-block");
			add_location(div, file, 634, 28, 24460);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			if_blocks[current_block_type_index].m(span, null);
			append_dev(div, t0);
			append_dev(div, label);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(span, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(634:24) {#if index == 0}",
		ctx
	});

	return block;
}

// (641:36) {:else}
function create_else_block_1(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: false,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], "fillAuthor_" + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(641:36) {:else}",
		ctx
	});

	return block;
}

// (639:36) {#if item._sticky == "1"}
function create_if_block_2(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: true,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], "fillAuthor_" + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(639:36) {#if item._sticky == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (587:12) {#each all_steps as item,index}
function create_each_block(ctx) {
	let fieldset;
	let legend;
	let t0_value = /*index*/ ctx[40] + 1 + "";
	let t0;
	let legend_style_value;
	let t1;
	let div1;
	let div0;
	let raw_value = /*item*/ ctx[38].__cdata + "";
	let div0_data_seq_value;
	let div0_id_value;
	let div0_style_value;
	let div0_contenteditable_value;
	let div1_style_value;
	let t2;
	let div8;
	let div2;
	let span0;
	let span0_for_value;
	let t4;
	let span2;
	let span1;
	let input;
	let input_checked_value;
	let t5;
	let label0;
	let span2_style_value;
	let t7;
	let div4;
	let div3;
	let span3;
	let current_block_type_index;
	let if_block0;
	let t8;
	let label1;
	let label1_for_value;
	let t10;
	let t11;
	let div7;
	let div5;
	let button0;
	let div5_style_value;
	let t13;
	let div6;
	let button1;
	let button1_id_value;
	let div6_style_value;
	let div7_style_value;
	let fieldset_key_value;
	let fieldset_style_value;
	let t15;
	let current;
	let mounted;
	let dispose;

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[20](/*index*/ ctx[40], ...args);
	}

	function change_handler(...args) {
		return /*change_handler*/ ctx[21](/*index*/ ctx[40], ...args);
	}

	const if_block_creators = [create_if_block_3, create_else_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[38]._mode == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*index*/ ctx[40] == 0 && create_if_block_1(ctx);

	function click_handler_4(...args) {
		return /*click_handler_4*/ ctx[24](/*index*/ ctx[40], ...args);
	}

	function click_handler_5(...args) {
		return /*click_handler_5*/ ctx[25](/*index*/ ctx[40], ...args);
	}

	const block = {
		c: function create() {
			fieldset = element("fieldset");
			legend = element("legend");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			t2 = space();
			div8 = element("div");
			div2 = element("div");
			span0 = element("span");
			span0.textContent = `${language.plain_text}`;
			t4 = space();
			span2 = element("span");
			span1 = element("span");
			input = element("input");
			t5 = space();
			label0 = element("label");
			label0.textContent = `${language.interactive}`;
			t7 = space();
			div4 = element("div");
			div3 = element("div");
			span3 = element("span");
			if_block0.c();
			t8 = space();
			label1 = element("label");
			label1.textContent = `${language.no_validation}`;
			t10 = space();
			if (if_block1) if_block1.c();
			t11 = space();
			div7 = element("div");
			div5 = element("div");
			button0 = element("button");
			button0.textContent = `${language.delete}`;
			t13 = space();
			div6 = element("div");
			button1 = element("button");
			button1.textContent = `${language.save}`;
			t15 = space();
			attr_dev(legend, "class", "font18 mb ms-2 pl-1 svelte-smsdwz");
			attr_dev(legend, "style", legend_style_value = "width:1em;float:none;");
			add_location(legend, file, 588, 20, 21219);
			attr_dev(div0, "data-seq", div0_data_seq_value = /*index*/ ctx[40]);
			attr_dev(div0, "class", "tinymce-editor-res steps_edit p-1 border fillAuthor");
			attr_dev(div0, "id", div0_id_value = `fillAuthor_${/*index*/ ctx[40]}`);
			attr_dev(div0, "style", div0_style_value = "padding:0 8px;overflow:auto;outline:none");
			attr_dev(div0, "contenteditable", div0_contenteditable_value = true);
			attr_dev(div0, "data-text", "Enter text here");
			add_location(div0, file, 590, 24, 21432);
			attr_dev(div1, "class", "d-inline-block table_width ms-2 pl-1 pb-2 mb-1");
			attr_dev(div1, "style", div1_style_value = "width:97%;");
			add_location(div1, file, 589, 20, 21326);
			attr_dev(span0, "class", "pointer d-inline-block plain_text svelte-smsdwz");
			attr_dev(span0, "data-toggle", "tooltip");
			attr_dev(span0, "title", "Don't use any interactive item!");
			attr_dev(span0, "for", span0_for_value = `viewonly_radio_${/*index*/ ctx[40]}`);
			add_location(span0, file, 604, 24, 22195);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "form-check-input");
			attr_dev(input, "id", "switchElement");
			input.checked = input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true;
			attr_dev(input, "color", "primary");
			add_location(input, file, 607, 32, 22564);
			attr_dev(label0, "for", "switchElement");
			add_location(label0, file, 612, 32, 22926);
			attr_dev(span1, "class", "form-check form-switch");
			add_location(span1, file, 606, 28, 22494);
			attr_dev(span2, "class", "stat-percent ms-4");
			attr_dev(span2, "style", span2_style_value = "display:inline-block;position:relative;");
			add_location(span2, file, 605, 24, 22383);
			attr_dev(div2, "class", "test d-inline-block");
			add_location(div2, file, 603, 20, 22137);
			attr_dev(span3, "class", "check_box d-inline-block svelte-smsdwz");
			add_location(span3, file, 619, 28, 23273);
			attr_dev(label1, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-smsdwz");
			attr_dev(label1, "for", label1_for_value = `mode_checkbox_${/*index*/ ctx[40]}`);
			add_location(label1, file, 630, 28, 24185);
			attr_dev(div3, "class", "modes_checkbox d-inline-block ms-2");
			add_location(div3, file, 618, 24, 23196);
			attr_dev(div4, "class", "d-inline-block plain_text ms-3");
			add_location(div4, file, 617, 20, 23126);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-light font12");
			add_location(button0, file, 650, 28, 25903);
			attr_dev(div5, "class", "d-inline-block mr");
			attr_dev(div5, "style", div5_style_value = "display:inline-block;");
			add_location(div5, file, 649, 24, 25763);
			attr_dev(button1, "id", button1_id_value = `save_step_${/*index*/ ctx[40]}`);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-primary font12 save_button_steps");
			add_location(button1, file, 653, 28, 26130);
			attr_dev(div6, "class", "d-inline-block");
			attr_dev(div6, "style", div6_style_value = "text-align:right;margin-top:6px;");
			add_location(div6, file, 652, 24, 26030);
			attr_dev(div7, "style", div7_style_value = "display:inline-block;float:right;");
			attr_dev(div7, "class", "buttons edit_steps");
			add_location(div7, file, 648, 20, 25662);
			attr_dev(div8, "class", "view_checkbox d-inline-block light-cyan-bg px-2 p-1 full-width fwidth svelte-smsdwz");
			add_location(div8, file, 602, 20, 22033);
			attr_dev(fieldset, "key", fieldset_key_value = /*index*/ ctx[40]);
			attr_dev(fieldset, "style", fieldset_style_value = "border:1px solid grey");
			attr_dev(fieldset, "class", "new_steps seq_inbox fw shadow-sm mb-2");
			add_location(fieldset, file, 587, 16, 21098);
		},
		m: function mount(target, anchor) {
			insert_dev(target, fieldset, anchor);
			append_dev(fieldset, legend);
			append_dev(legend, t0);
			append_dev(fieldset, t1);
			append_dev(fieldset, div1);
			append_dev(div1, div0);
			div0.innerHTML = raw_value;
			append_dev(fieldset, t2);
			append_dev(fieldset, div8);
			append_dev(div8, div2);
			append_dev(div2, span0);
			append_dev(div2, t4);
			append_dev(div2, span2);
			append_dev(span2, span1);
			append_dev(span1, input);
			append_dev(span1, t5);
			append_dev(span1, label0);
			append_dev(div8, t7);
			append_dev(div8, div4);
			append_dev(div4, div3);
			append_dev(div3, span3);
			if_blocks[current_block_type_index].m(span3, null);
			append_dev(div3, t8);
			append_dev(div3, label1);
			append_dev(div4, t10);
			if (if_block1) if_block1.m(div4, null);
			append_dev(div8, t11);
			append_dev(div8, div7);
			append_dev(div7, div5);
			append_dev(div5, button0);
			append_dev(div7, t13);
			append_dev(div7, div6);
			append_dev(div6, button1);
			insert_dev(target, t15, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "keyup", keyup_handler, false, false, false),
					listen_dev(input, "change", change_handler, false, false, false),
					listen_dev(div5, "click", click_handler_4, false, false, false),
					listen_dev(button1, "click", click_handler_5, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*all_steps*/ 2) && raw_value !== (raw_value = /*item*/ ctx[38].__cdata + "")) div0.innerHTML = raw_value;
			if (!current || dirty[0] & /*all_steps*/ 2 && input_checked_value !== (input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true)) {
				prop_dev(input, "checked", input_checked_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(span3, null);
			}

			if (/*index*/ ctx[40] == 0) if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(fieldset);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t15);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(587:12) {#each all_steps as item,index}",
		ctx
	});

	return block;
}

// (663:12) <Button variant="fab" color="primary" mini aria-label="Add"                 on:click={addEvent.bind(this, 'steps')}                 class="btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30"                 style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>
function create_default_slot_6(ctx) {
	let span;
	let t1;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "+  ";
			t1 = text(" Add Step");
			attr_dev(span, "class", "font18 svelte-smsdwz");
			add_location(span, file, 666, 16, 26893);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			insert_dev(target, t1, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(663:12) <Button variant=\\\"fab\\\" color=\\\"primary\\\" mini aria-label=\\\"Add\\\"                 on:click={addEvent.bind(this, 'steps')}                 class=\\\"btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30\\\"                 style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>",
		ctx
	});

	return block;
}

// (676:20) <div slot="title">
function create_title_slot(ctx) {
	let div0;
	let div1;
	let div1_style_value;
	let t1;
	let div3;
	let div2;
	let button0;
	let t2;
	let button0_class_value;
	let button0_value_value;
	let t3;
	let button1;
	let t4;
	let button1_class_value;
	let button1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			div1.textContent = `${language.fill_header}`;
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			button0 = element("button");
			t2 = text("Text");
			t3 = space();
			button1 = element("button");
			t4 = text("Mathematical Equation");
			attr_dev(div1, "class", "mr-lg float-left");
			attr_dev(div1, "style", div1_style_value = "padding-top:10px;padding-left:13px;font-size:18px;");
			add_location(div1, file, 676, 24, 27427);
			attr_dev(button0, "type", "button");

			attr_dev(button0, "class", button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-smsdwz"));

			button0.value = button0_value_value = 1;
			add_location(button0, file, 680, 8, 27673);
			attr_dev(button1, "type", "button");

			attr_dev(button1, "class", button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-smsdwz"));

			button1.value = button1_value_value = 2;
			add_location(button1, file, 681, 8, 27850);
			attr_dev(div2, "class", "btn-group mt-1 row ml-0");
			add_location(div2, file, 679, 7, 27627);
			attr_dev(div3, "class", "float-right mr-4");
			add_location(div3, file, 678, 24, 27589);
			attr_dev(div0, "slot", "title");
			add_location(div0, file, 675, 20, 27384);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
			append_dev(div0, t1);
			append_dev(div0, div3);
			append_dev(div3, div2);
			append_dev(div2, button0);
			append_dev(button0, t2);
			append_dev(div2, t3);
			append_dev(div2, button1);
			append_dev(button1, t4);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*updateDialog*/ ctx[11].bind(this, 1), false, false, false),
					listen_dev(button1, "click", /*updateDialog*/ ctx[11].bind(this, 2), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1 && button0_class_value !== (button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-smsdwz"))) {
				attr_dev(button0, "class", button0_class_value);
			}

			if (dirty[0] & /*state*/ 1 && button1_class_value !== (button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-smsdwz"))) {
				attr_dev(button1, "class", button1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot.name,
		type: "slot",
		source: "(676:20) <div slot=\\\"title\\\">",
		ctx
	});

	return block;
}

// (710:28) {:else}
function create_else_block(ctx) {
	let div5;
	let div1;
	let input;
	let input_id_value;
	let input_style_value;
	let input_auto_focus_value;
	let t0;
	let button0;
	let t1;
	let div0;
	let button1;
	let t2;
	let div2;
	let t4;
	let div3;
	let div3_style_value;
	let t6;
	let div4;
	let div4_style_value;
	let current;

	button0 = new Button({
			props: {
				variant: "contained",
				color: "primary",
				style: "border:1px solid #4285f4;color:#4285f4;text-transform:none;",
				class: "btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", addEditable);

	button1 = new Button({
			props: {
				id: "latexEdit",
				variant: "contained",
				color: "primary",
				style: "margin:5px;display:none;",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*latexEdit*/ ctx[12]);

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			input = element("input");
			t0 = space();
			create_component(button0.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(button1.$$.fragment);
			t2 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t4 = space();
			div3 = element("div");
			div3.textContent = `${language.fill_math_help1}`;
			t6 = space();
			div4 = element("div");
			div4.textContent = `${language.fill_math_help2}`;
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = "input");
			attr_dev(input, "class", "latexInp form-control");
			attr_dev(input, "style", input_style_value = "margin:5px;width:71%;");
			attr_dev(input, "auto:focus", input_auto_focus_value = true);
			add_location(input, file, 712, 40, 29898);
			attr_dev(div0, "class", "latexEditButton d-inline-block");
			add_location(div0, file, 729, 40, 31037);
			attr_dev(div1, "class", "d-flex");
			add_location(div1, file, 711, 36, 29837);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-1");
			add_location(div2, file, 741, 36, 31808);
			attr_dev(div3, "class", "text-danger ml-1");
			attr_dev(div3, "style", div3_style_value = "text-indent: 15px;");
			add_location(div3, file, 742, 36, 31905);
			attr_dev(div4, "class", "text-danger ml-1");
			attr_dev(div4, "style", div4_style_value = "text-indent: 15px;");
			add_location(div4, file, 743, 36, 32026);
			add_location(div5, file, 710, 32, 29795);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, input);
			append_dev(div1, t0);
			mount_component(button0, div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);
			mount_component(button1, div0, null);
			append_dev(div5, t2);
			append_dev(div5, div2);
			append_dev(div5, t4);
			append_dev(div5, div3);
			append_dev(div5, t6);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(710:28) {:else}",
		ctx
	});

	return block;
}

// (689:28) {#if state.fillInTheBlanksChoice == 1}
function create_if_block(ctx) {
	let div5;
	let div1;
	let div0;
	let checkbox;
	let t0;
	let input;
	let input_value_value;
	let input_style_value;
	let input_auto_focus_value;
	let input_placeholder_value;
	let t1;
	let div2;
	let t3;
	let div3;
	let div3_style_value;
	let t5;
	let div4;
	let div4_style_value;
	let current;

	checkbox = new Checkbox({
			props: {
				id: "numeric",
				checked: /*state*/ ctx[0].numeric,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			create_component(checkbox.$$.fragment);
			t0 = space();
			input = element("input");
			t1 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t3 = space();
			div3 = element("div");
			div3.textContent = `${language.fill_text_help1}`;
			t5 = space();
			div4 = element("div");
			div4.textContent = "2. Please do not include space.";
			attr_dev(div0, "class", "width100 svelte-smsdwz");
			add_location(div0, file, 691, 40, 28417);
			attr_dev(input, "type", "text");
			attr_dev(input, "id", "input1");
			input.value = input_value_value = /*state*/ ctx[0].input_ans;
			attr_dev(input, "class", "form-control mr-4 ml-3");
			attr_dev(input, "style", input_style_value = "margin:5px");
			attr_dev(input, "auto:focus", input_auto_focus_value = true);

			attr_dev(input, "placeholder", input_placeholder_value = AH.select("#input1").innerHTML != ""
			? language.fill_text_placeholder
			: "");

			add_location(input, file, 695, 44, 28695);
			attr_dev(div1, "class", "d-flex mr-2");
			add_location(div1, file, 690, 36, 28351);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-2 mt-3");
			add_location(div2, file, 705, 36, 29372);
			attr_dev(div3, "class", "text-danger ml-2");
			attr_dev(div3, "style", div3_style_value = "text-indent:15px");
			add_location(div3, file, 706, 36, 29474);
			attr_dev(div4, "class", "text-danger ml-2");
			attr_dev(div4, "style", div4_style_value = "text-indent:15px");
			add_location(div4, file, 707, 36, 29593);
			add_location(div5, file, 689, 32, 28309);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, div0);
			mount_component(checkbox, div0, null);
			append_dev(div1, t0);
			append_dev(div1, input);
			append_dev(div5, t1);
			append_dev(div5, div2);
			append_dev(div5, t3);
			append_dev(div5, div3);
			append_dev(div5, t5);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox_changes.checked = /*state*/ ctx[0].numeric;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);

			if (!current || dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = /*state*/ ctx[0].input_ans) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(checkbox);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(689:28) {#if state.fillInTheBlanksChoice == 1}",
		ctx
	});

	return block;
}

// (721:40) <Button                                              variant = "contained"                                              color = "primary"                                             style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                              on:click = {addEditable}                                             class="btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1"                                         >
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add Response");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(721:40) <Button                                              variant = \\\"contained\\\"                                              color = \\\"primary\\\"                                             style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                              on:click = {addEditable}                                             class=\\\"btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1\\\"                                         >",
		ctx
	});

	return block;
}

// (731:44) <Button                                                  id = {"latexEdit"}                                                 variant = "contained"                                                  color = "primary"                                                 style = {'margin:5px;display:none;'}                                                  on:click = {latexEdit}                                                                                >
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(731:44) <Button                                                  id = {\\\"latexEdit\\\"}                                                 variant = \\\"contained\\\"                                                  color = \\\"primary\\\"                                                 style = {'margin:5px;display:none;'}                                                  on:click = {latexEdit}                                                                                >",
		ctx
	});

	return block;
}

// (693:44) <Checkbox  id = "numeric" checked = {state.numeric}>
function create_default_slot_3(ctx) {
	let t_value = "Numeric" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(693:44) <Checkbox  id = \\\"numeric\\\" checked = {state.numeric}>",
		ctx
	});

	return block;
}

// (752:24) <Button variant="contained" on:click={handleClose} >
function create_default_slot_2(ctx) {
	let t0_value = language.cancel + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(752:24) <Button variant=\\\"contained\\\" on:click={handleClose} >",
		ctx
	});

	return block;
}

// (755:24) <Button variant="contained" on:click={storeAns}                             class="bg-primary text-white">
function create_default_slot_1(ctx) {
	let t_value = language.done + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(755:24) <Button variant=\\\"contained\\\" on:click={storeAns}                             class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (670:8) <Dialog overlayClass="materialOverlay"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width="650" class="row" style={'background-color: #fff;'}>
function create_default_slot(ctx) {
	let t0;
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div2;
	let button0;
	let t2;
	let button1;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*state*/ ctx[0].fillInTheBlanksChoice == 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button0 = new Button({
			props: {
				variant: "contained",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleClose*/ ctx[10]);

	button1 = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*storeAns*/ ctx[13]);

	const block = {
		c: function create() {
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			t1 = space();
			div2 = element("div");
			create_component(button0.$$.fragment);
			t2 = text(",\n                        ");
			create_component(button1.$$.fragment);
			attr_dev(div0, "id", "responseDialog");
			add_location(div0, file, 687, 24, 28184);
			add_location(div1, file, 686, 20, 28154);
			attr_dev(div2, "class", "svelteFooter");
			add_location(div2, file, 750, 20, 32268);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
			mount_component(button0, div2, null);
			append_dev(div2, t2);
			mount_component(button1, div2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			if_blocks[current_block_type_index].d();
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(670:8) <Dialog overlayClass=\\\"materialOverlay\\\"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width=\\\"650\\\" class=\\\"row\\\" style={'background-color: #fff;'}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div7;
	let div4;
	let div0;
	let div0_style_value;
	let t1;
	let div3;
	let div1;
	let checkbox0;
	let t2;
	let div2;
	let checkbox1;
	let div3_style_value;
	let t3;
	let div5;
	let t4;
	let div6;
	let button;
	let t5;
	let dialog;
	let updating_visible;
	let current;

	checkbox0 = new Checkbox({
			props: {
				id: "go_next",
				defaultChecked: /*state*/ ctx[0].gonext ? true : false,
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*click_handler*/ ctx[18]);

	checkbox1 = new Checkbox({
			props: {
				id: "fixedans_checkbox",
				defaultChecked: /*state*/ ctx[0].variable_button ? true : false,
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*click_handler_1*/ ctx[19]);
	let each_value = /*all_steps*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				mini: true,
				"aria-label": "Add",
				class: "btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30",
				style: "float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addEvent*/ ctx[9].bind(this, "steps"));

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[26].call(null, value);
	}

	let dialog_props = {
		overlayClass: "materialOverlay",
		disableEnforceFocus: true,
		width: "650",
		class: "row",
		style: "background-color: #fff;",
		$$slots: {
			default: [create_default_slot],
			title: [create_title_slot]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[0].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
	dialog.$on("close", /*handleClose*/ ctx[10].bind(this));

	const block = {
		c: function create() {
			main = element("main");
			div7 = element("div");
			div4 = element("div");
			div0 = element("div");
			div0.textContent = `${language.create_steps}`;
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			create_component(checkbox0.$$.fragment);
			t2 = space();
			div2 = element("div");
			create_component(checkbox1.$$.fragment);
			t3 = space();
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div6 = element("div");
			create_component(button.$$.fragment);
			t5 = space();
			create_component(dialog.$$.fragment);
			attr_dev(div0, "class", "d-inline-block pt-1 float-start cr_step");
			attr_dev(div0, "style", div0_style_value = "font-size:20px;position:relative;");
			add_location(div0, file, 563, 12, 19908);
			attr_dev(div1, "class", "modes_checkbox d-inline-block top-checkbox_gonext position-relative top2 svelte-smsdwz");
			add_location(div1, file, 565, 16, 20073);
			attr_dev(div2, "class", "modes_checkbox d-inline-block m-l top-checkbox_fix position-relative top2 svelte-smsdwz");
			add_location(div2, file, 574, 16, 20493);
			attr_dev(div3, "style", div3_style_value = {});
			add_location(div3, file, 564, 12, 20040);
			attr_dev(div4, "class", "border-bottom d-flex justify-content-between px-2 pt-1");
			add_location(div4, file, 562, 8, 19827);
			attr_dev(div5, "class", "outer_steps mt-3 mx-3 clear-both");
			add_location(div5, file, 584, 8, 20933);
			attr_dev(div6, "class", "row mx-3 mt-3 pb-3");
			add_location(div6, file, 661, 8, 26484);
			attr_dev(div7, "class", "mt-imp border");
			add_location(div7, file, 561, 4, 19791);
			add_location(main, file, 560, 0, 19780);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div7);
			append_dev(div7, div4);
			append_dev(div4, div0);
			append_dev(div4, t1);
			append_dev(div4, div3);
			append_dev(div3, div1);
			mount_component(checkbox0, div1, null);
			append_dev(div3, t2);
			append_dev(div3, div2);
			mount_component(checkbox1, div2, null);
			append_dev(div7, t3);
			append_dev(div7, div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_dev(div7, t4);
			append_dev(div7, div6);
			mount_component(button, div6, null);
			append_dev(div7, t5);
			mount_component(dialog, div7, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox0_changes.defaultChecked = /*state*/ ctx[0].gonext ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox1_changes.defaultChecked = /*state*/ ctx[0].variable_button ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);

			if (dirty[0] & /*handleSave, deleteEvent, handleChangeCheckbox, all_steps, handleRadio, handleDisable*/ 498) {
				each_value = /*all_steps*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div5, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const button_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const dialog_changes = {};

			if (dirty[0] & /*state*/ 1 | dirty[1] & /*$$scope*/ 1024) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 1) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[0].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(button.$$.fragment, local);
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(button.$$.fragment, local);
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
			destroy_component(dialog);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function replaceVariables(latex_str) {
	let latex_arr = [];
	let latex_arr_check = latex_str;

	if (latex_arr_check.length == undefined && latex_arr_check != "") {
		latex_arr.push(latex_arr_check);
	} else {
		latex_arr = latex_arr_check;
	}

	latex_arr.map(function (item, index) {
		let cdata = item.__cdata;
		let vars = cdata.match(/<{[\s\S]*?}>/gm);

		if (vars) {
			vars.map(function (element) {
				let item = element.match(/<\{(.*?)\}>/g);
				item = item.toString().replace(/<\{|\}>/g, "");
				item = "var:" + item;
				item = item.trim();
				cdata = cdata.replace(element, item);
			});
		}

		latex_arr[index].__cdata = cdata;
	});

	return latex_arr;
}

function reverseHtmlSpecialChars(data) {
	let tags = data.match(/&lt;(.*?)&gt;/gm);
	let tag = "";

	if (tags) {
		for (var i = 0; i < tags.length; i++) {
			tag = tags[i];
			tags[i] = tags[i].replace(/&lt;/g, "<").replace(/&gt;/g, ">");
			data = data.replace(tag, tags[i]);
		}
	}

	return data;
}

function replaceSpaces(data) {
	let matching = data.match(/var:var\d+\s+\s+/g);
	let match;

	if (matching) {
		matching.map(function (item, index) {
			match = item.trim();
			data = data.replace(item, match);
		});
	}

	return data;
}

function addEditable() {
	//let txt = jQuery("#input");
	let txt = document.querySelector("#input");

	//let caretPos = txt[0].selectionStart;
	let caretPos = txt.selectionStart;

	//let textAreaTxt = txt.val();
	let textAreaTxt = txt.value;

	var txtToAdd = "\\MathQuillMathField";
	var txtToAdd = "user Response";

	//txt.val(textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos));
	txt.value = textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos);
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("StepAlgo", slots, []);
	window.spanCounter = 0;

	// window.currentId = "";
	// window.currentInp = "";
	let state = {};

	let new_xml = {};
	var all_steps = [];
	let { stopAuthoringUpdate } = $$props;
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;

	let stateData = writable({
		xml: "",
		fillInTheBlanksChoice: 1,
		opened: false,
		deleteIndex: "",
		remediationToggle: false,
		snackback: false,
		input_ans: "",
		spanCounter: 0,
		currentId: "",
		currentInp: ""
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	onMount(() => {
		if (xml) {
			new_xml = XMLToJSON(xml);
			showItems(new_xml.smxml.step);

			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select("#sticky_checkbox_0").click();

			//setTimeout(function() {
			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select("#sticky_checkbox_0").click();
		} //}, 1000);

		setTimeout(
			function () {
				//jQuery('.save_button_steps').prop('disabled', 'disabled');
				AH.selectAll(".save_button_steps", "attr", { disabled: "disabled" });

				initEditor();
			},
			500
		);

		// jQuery(document).on("click touchstart", ".editFill", function() {
		// 	if(jQuery(this).attr("type") == "t") {
		// 		editTextbox(jQuery(this).attr("originalKey"));
		// 	} else if(jQuery(this).attr("type") == "e") {
		// 		editMathbox(jQuery(this).attr("originalKey"));
		// 	}
		// })
		AH.listen(document, "click", ".editFill", function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});

		AH.listen(document, "touchstart", ".editFill", function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});
	});

	function editTextbox(key) {
		//console.log('checking');
		key = key.replace(/%{|}%/g, "");

		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";
		$$invalidate(0, state.numeric = ans_type == "n" ? true : false, state);
		$$invalidate(0, state.fillInTheBlanksChoice = 1, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:1});
		//this.setState({open:true});
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//jQuery("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog #customStyleText").value = customStyle[1];

			//jQUery("#input1").val(customStyle[0]);
			//AH.select("#input1").value = customStyle[0];
			$$invalidate(0, state.input_ans = customStyle[0], state);
		} else {
			//jQuery("#input1").val(ans);
			// setTimeout(()=>{
			//     AH.select("#input1").value = ans;
			// },100)
			$$invalidate(0, state.input_ans = ans, state);
		}
	}

	function editMathbox(key) {
		key = key.replace(/%{|}%/g, "");
		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";

		// this.setState({
		//     customStyle:((ans.indexOf("#style#") != -1)?true:false),
		//     fillInTheBlanksChoice:2,
		//     open:true
		// });
		$$invalidate(0, state.customStyle = ans.indexOf("#style#") != -1 ? true : false, state);

		$$invalidate(0, state.fillInTheBlanksChoice = 2, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:2}); ## ALready commented
		//this.setState({open:true}); ## ALready commented
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//$("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog").value = customStyle[1];

			AH.select("#customStyleText").value = customStyle[1];

			//$("#input"+i).val(customStyle[0]);
			AH.select("#input" + i).value = customStyle[0];
		} else {
			//$("#input").val(ans);
			AH.select("#input").value = ans;
		}
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			if (stopAuthoringUpdate === true) return;
			new_xml = XMLToJSON(state.xml);
			showItems(new_xml.smxml.step);
		}
	});

	function showItems(steps) {
		steps = replaceVariables(steps);
		$$invalidate(1, all_steps = steps);
		setToggle(all_steps);
		parseXmlAuthoring(steps);
	}

	function setToggle(steps) {

		steps.map(function (item, index) {
			if (item._viewonly == 1) {
				$$invalidate(1, all_steps[index].toggle = 1, all_steps);
			} else {
				$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			}
		});

		return all_steps;
	}

	function parseXmlAuthoring(steps) {
		steps.map(function (item, index) {
			let cdata = item.__cdata;
			let answerKey = cdata.match(/%{[\s\S]*?}%/gm);
			let answerType = "";

			if (answerKey) {
				//jQuery(answerKey).each(function(i){
				answerKey.forEach(function (data, i) {
					let originalKey = answerKey[i];
					let latexKey = "";
					let editMath = "";
					answerType = answerKey[i].match(/\|(.*?)}%$/gm);
					answerType = answerType ? answerType[0].replace(/\||}%/gm, "") : "t";
					let innerKey = "";
					let icon = "";
					let type = "";

					if (answerType == "t") {
						type = answerType;
						innerKey = "Textbox";
						icon = "icomoon-insert-template";
					} else if (answerType == "n") {
						type = "t";
						innerKey = "Numeric";
						icon = "icomoon-insert-template";
					} else if (answerType == "e") {
						type = answerType;
						innerKey = "Math";
						latexKey = originalKey.replace(/\%\{|\|e\}\%/g, "");
						latexKey = "latex=\"" + latexKey + "\"";
						editMath = "editMath";
						icon = "icomoon-insert-template";
					}

					var regex = new RegExp(RegExp.quote(originalKey));
					cdata = cdata.replace(regex, "<span id=\"latexSpan" + $$invalidate(0, state.spanCounter = $$invalidate(0, ++state.spanCounter, state), state) + "\" " + latexKey + " type='" + type + "' class='alert alert-info editFill " + editMath + "' originalkey='" + originalKey + "' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='" + icon + "'></i>" + innerKey + "</span>");
				});
			}

			$$invalidate(1, all_steps[index].__cdata = cdata, all_steps);
		});
	}

	function goNext(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.gonext = true, state);
			new_xml.smxml._gonext = "1";
		} else {
			$$invalidate(0, state.gonext = false, state);
			new_xml.smxml._gonext = "0";
		}

		updateXML();
	}

	function fixedAnswer(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.variable_button = true, state);
			new_xml.smxml._fixed = "1";
		} else {
			$$invalidate(0, state.variable_button = false, state);
			new_xml.smxml._fixed = "0";
		}

		updateXML();
	}

	function handleChangeCheckbox(id, fillid, e) {
		let name = e.target.name;
		let ref = document.querySelector("#" + name + id);
		let val = "_" + e.target.value;
		let seq = id;

		if (ref.checked) {
			new_xml.smxml.step[seq][val] = "1";
		} else {
			new_xml.smxml.step[seq][val] = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		updateXML();
	}

	function handleDisable(i) {
		console.log("handle click");

		//jQuery('#save_step_'+i).removeAttr('disabled');
		AH.select("#save_step_" + i, "removeAttr", "disabled");
	}

	function handleRadio(index, fillid, event) {
		if (all_steps[index].toggle == 1) {
			$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			new_xml.smxml.step[index]._viewonly = "0";
			new_xml.smxml.step[index]._attempt = "1";
		} else {
			all_steps[index].toggle == 1;
			new_xml.smxml.step[index]._viewonly = "1";
			new_xml.smxml.step[index]._attempt = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		updateXML();
	}

	function deleteEvent(index, data) {
		let delete_event;

		if (data == "steps") {
			delete_event = all_steps;

			if (delete_event.length > 2) {
				const add = delete_event.splice(index, 1);
			} else {
				AH.alert("You have atleast 2 steps.");
			}

			$$invalidate(1, all_steps = delete_event);
			updateXML();
		} else if (data == "algo") {
			$$invalidate(0, state.opened = true, state);
			$$invalidate(0, state.deleteIndex = index, state);
		}

		
	}

	function handleSave(id, fillid) {
		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		data = data.replace(/&amp;/g, "&"); // replace amp to maintain html entity.
		$$invalidate(1, all_steps[id].__cdata = data, all_steps);

		//jQuery('#save_step_'+id).prop('disabled', 'disabled');
		//document.querySelector('#save_step_'+id).disabled = true;
		AH.select("#save_step_" + id, "attr", { disabled: "disabled" });

		updateXML();
	}

	function updateXML() {
		let fixans = new_xml.smxml._fixed;
		let gonext = new_xml.smxml._gonext;
		let xml = "<smxml type=\"37\" fixed=\"" + fixans + "\" gonext=\"" + gonext + "\">";

		all_steps.map(function (element, i) {
			let seq = i + 1;
			let viewonly = element._viewonly;
			let mode = element._mode;
			let attempt = element._attempt;
			let sticky = element._sticky;
			let data = element.__cdata;

			// data = self.reverseReplaceVariables(data);
			data = reverseHtmlSpecialChars(data);

			data = replaceSpaces(data);
			data = data.replace(/&quot;/g, "\"").replace(/&nbsp;/g, " ");
			data = data.replace(/'/g, "\"").replace(/\n/g, "");
			let arr = data.match(/<span(.*?)>(.*?)<\/span>/gi);

			if (arr) {
				for (var i = 0; i < arr.length; i++) {
					let originalkey = arr[i].match(/originalkey="%(.*?)%"/g);

					if (originalkey) {
						originalkey = originalkey.toString().replace(/originalkey=/g, "").replace(/"%|%"/g, "%");
						data = data.replace(arr[i], originalkey);
					}
				}
			}

			let cdata = data;

			xml = xml + "<step seq='" + seq + "'" + (attempt != undefined
			? " attempt ='" + attempt + "'"
			: " ") + (viewonly != undefined
			? " viewonly ='" + viewonly + "'"
			: " ") + (mode != undefined ? " mode ='" + mode + "'" : " ") + (sticky != undefined ? " sticky ='" + sticky + "'" : " ") + "><!--[CDATA[" + cdata + "]]--></step>";
		});

		xml = xml + "</smxml>";
		getChildXml(xml);
	}

	function addEvent(data) {
		let obj = {};
		obj._seq = all_steps.length + 1;
		obj._viewonly = "1";
		obj._attempt = "0";
		obj._mode = "0";
		obj.__cdata = "New Step";
		all_steps.push(obj);
		updateXML();
		$$invalidate(0, state.snackback = true, state);

		var timer = setTimeout(
			function () {
				initEditor();
				clearTimeout(timer);
			},
			500
		);
	}

	function initEditor() {
		// jQuery(document).on("click", ".editMath", function(e){
		//     window.currentId = jQuery(this).attr('id');
		// });
		AH.listen(document, "click", ".editMath", function (_this, e) {
			// window.currentId = _this.getAttribute('id');
			$$invalidate(0, state.currentId = _this.getAttribute("id"), state);
		});

		// jQuery(document).on("click", ".materialOverlay", function(e){
		// 	window.currentId = null;
		//     window.currentInp = null;
		// });
		AH.listen(document, "click", ".materialOverlay", function (e) {
			//window.currentId = null;
			$$invalidate(0, state.currentId = null, state);

			//window.currentInp = null;
			$$invalidate(0, state.currentInp = null, state);
		});

		tinyMCE.PluginManager.add("res", function (editor, url) {
			editor.addMenuItem("resp", {
				text: "Add response",
				id: "addToken",
				onclick() {
					handleOpen();
				},
				context: "insert",
				prependToContext: true
			});
		});

		tinymce.PluginManager.load("equationeditor", themeUrl + "pe-items/tinymce/plugins/equationeditor/plugin.min.js");

		tinymce.init({
			selector: ".tinymce-editor-res",
			inline: true,
			theme: "modern",
			skin: "skin02",
			min_width: 100,
			resize: true,
			menubar: false,
			toolbar: true,
			elementpath: false,
			statusbar: false,
			force_br_newlines: true,
			remove_trailing_brs: true,
			forced_root_block: false,
			extended_valid_elements: "span[onClick|contentEditable]",
			valid_elements: "*[*]",
			fixed_toolbar_container: "#toolbar_container",
			extended_valid_elements: "uc:syntax,uc:ref",
			custom_elements: "uc:syntax,~uc:ref",
			plugins: [
				"lists link image charmap print preview anchor",
				"searchreplace code fullscreen",
				"insertdatetime media table contextmenu paste res equationeditor "
			],
			content_css: themeUrl + "pe-items/src/libs/mathquill.css",
			toolbar: [" bold italic underline | equationeditor"],
			contextmenu: "resp",
			paste_as_text: true
		});
	}

	function handleClose() {
		if (state.fillInTheBlanksChoice == 2) {
			//window.currentId = null;
			$$invalidate(0, state.currentInp = null, state);
		}

		$$invalidate(0, state.open = false, state);
	}

	function updateDialog(targetVal) {
		$$invalidate(0, state.fillInTheBlanksChoice = targetVal, state);
	}

	function latexEdit() {
		$$invalidate(0, state.open = true, state);
	}

	function storeAns() {
		var validate = 0;

		if (state.fillInTheBlanksChoice == 1) {
			//let ans = jQuery("#input1").val();
			let ans = document.querySelector("#input1").value;

			//let numeric = jQuery("#responseDialog #numeric")[0].checked;
			let numeric = document.querySelector("#responseDialog #numeric").checked;

			if (numeric == true) {
				ans += " |n";
			}

			if (ans.trim() == "") {
				validate = 1;
				validate("All fields are required");
			} else {
				tinyMCE.activeEditor.insertContent("<span type='t' class='alert alert-info editFill' originalKey='%{" + ans.trim() + "}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template'></i>" + (numeric == true ? "Numeric" : "Textbox") + "</span>");
			}
		}

		if (state.fillInTheBlanksChoice == 2) {
			//let e = jQuery("#input").val();
			let e = document.querySelector("#input").value;

			if (validate == 0) {
				//document.querySelector("#"+window.currentId).setAttribute("latex",e);
				document.querySelector("#" + state.currentId).setAttribute("latex", e);

				//document.querySelector("#"+window.currentId).setAttribute("originalKey","%{"+e+"|e}%");
				document.querySelector("#" + state.currentId).setAttribute("originalKey", "%{" + e + "|e}%");

				//window.currentId = null;
				$$invalidate(0, state.currentId = null, state);

				//window.currentInp = null;
				$$invalidate(0, state.currentInp = null, state);
			} else {
				validate("All fields are required");
			}
		}

		if (validate == 0) {
			handleClose();
		}
	}

	function handleOpen() {
		// this.setState({
		//     open: true,
		//     codetype: false,
		//     numeric: false
		// });
		$$invalidate(0, state.open = true, state);

		$$invalidate(0, state.codetype = false, state);
		$$invalidate(0, state.numeric = false, state);
	} //this.setState({codetype: false}); #already commented on also react
	//this.setState({numeric: false}); #already commented on also react

	const writable_props = ["stopAuthoringUpdate", "xml", "editorState", "getChildXml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<StepAlgo> was created with unknown prop '${key}'`);
	});

	const click_handler = e => {
		goNext("go_next");
	};

	const click_handler_1 = e => {
		fixedAnswer("fixedans_checkbox");
	};

	const keyup_handler = (index, e) => {
		handleDisable(index);
	};

	const change_handler = (index, e) => {
		handleRadio(index, "fillAuthor_" + index);
	};

	const click_handler_2 = (index, e) => {
		handleChangeCheckbox(index, "fillAuthor_" + index, e);
	};

	const click_handler_3 = (index, e) => {
		handleChangeCheckbox(index, "fillAuthor_" + index, e);
	};

	const click_handler_4 = (index, e) => {
		deleteEvent(index, "steps");
	};

	const click_handler_5 = (index, e) => {
		handleSave(index, "fillAuthor_" + index);
	};

	function dialog_visible_binding(value) {
		state.open = value;
		$$invalidate(0, state);
	}

	$$self.$$set = $$props => {
		if ("stopAuthoringUpdate" in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		writable,
		Button,
		Dialog,
		Checkbox,
		l: language,
		beforeUpdate,
		onMount,
		AH,
		XMLToJSON,
		JSONToXML,
		state,
		new_xml,
		all_steps,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		stateData,
		unsubscribe,
		editTextbox,
		editMathbox,
		showItems,
		setToggle,
		replaceVariables,
		parseXmlAuthoring,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		updateXML,
		reverseHtmlSpecialChars,
		replaceSpaces,
		addEvent,
		initEditor,
		handleClose,
		updateDialog,
		addEditable,
		latexEdit,
		storeAns,
		handleOpen
	});

	$$self.$inject_state = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("new_xml" in $$props) new_xml = $$props.new_xml;
		if ("all_steps" in $$props) $$invalidate(1, all_steps = $$props.all_steps);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
		if ("stateData" in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		all_steps,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		addEvent,
		handleClose,
		updateDialog,
		latexEdit,
		storeAns,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		click_handler,
		click_handler_1,
		keyup_handler,
		change_handler,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		dialog_visible_binding
	];
}

class StepAlgo extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-smsdwz-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				stopAuthoringUpdate: 14,
				xml: 15,
				editorState: 16,
				getChildXml: 17
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StepAlgo",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stopAuthoringUpdate*/ ctx[14] === undefined && !("stopAuthoringUpdate" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*xml*/ ctx[15] === undefined && !("xml" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[16] === undefined && !("editorState" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[17] === undefined && !("getChildXml" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'getChildXml'");
		}
	}

	get stopAuthoringUpdate() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMMixedItem/ItemPlugin.svelte generated by Svelte v3.29.0 */
const file$1 = "clsSMMixedItem/ItemPlugin.svelte";

// (13:4) {#if parseInt(editorState.content_icon) == 2}
function create_if_block$1(ctx) {
	let newauthoring;
	let current;

	newauthoring = new StepAlgo({
			props: {
				xml: /*xml*/ ctx[0],
				getChildXml: /*getChildXml*/ ctx[2],
				stopAuthoringUpdate: /*stopAuthoringUpdate*/ ctx[3],
				uxml: /*uxml*/ ctx[4]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(newauthoring.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(newauthoring, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const newauthoring_changes = {};
			if (dirty & /*xml*/ 1) newauthoring_changes.xml = /*xml*/ ctx[0];
			if (dirty & /*getChildXml*/ 4) newauthoring_changes.getChildXml = /*getChildXml*/ ctx[2];
			if (dirty & /*stopAuthoringUpdate*/ 8) newauthoring_changes.stopAuthoringUpdate = /*stopAuthoringUpdate*/ ctx[3];
			if (dirty & /*uxml*/ 16) newauthoring_changes.uxml = /*uxml*/ ctx[4];
			newauthoring.$set(newauthoring_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(newauthoring.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(newauthoring.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(newauthoring, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(13:4) {#if parseInt(editorState.content_icon) == 2}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let main;
	let show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;
	let current;
	let if_block = show_if && create_if_block$1(ctx);

	const block = {
		c: function create() {
			main = element("main");
			if (if_block) if_block.c();
			add_location(main, file$1, 11, 0, 224);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			if (if_block) if_block.m(main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*editorState*/ 2) show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*editorState*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(main, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ItemPlugin", slots, []);
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;
	let { stopAuthoringUpdate } = $$props;
	let { uxml } = $$props;
	const writable_props = ["xml", "editorState", "getChildXml", "stopAuthoringUpdate", "uxml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ItemPlugin> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("uxml" in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	$$self.$capture_state = () => ({
		NewAuthoring: StepAlgo,
		xml,
		editorState,
		getChildXml,
		stopAuthoringUpdate,
		uxml
	});

	$$self.$inject_state = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("uxml" in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [xml, editorState, getChildXml, stopAuthoringUpdate, uxml];
}

class ItemPlugin extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			xml: 0,
			editorState: 1,
			getChildXml: 2,
			stopAuthoringUpdate: 3,
			uxml: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ItemPlugin",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[0] === undefined && !("xml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[1] === undefined && !("editorState" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[2] === undefined && !("getChildXml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'getChildXml'");
		}

		if (/*stopAuthoringUpdate*/ ctx[3] === undefined && !("stopAuthoringUpdate" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*uxml*/ ctx[4] === undefined && !("uxml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'uxml'");
		}
	}

	get xml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stopAuthoringUpdate() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ItemPlugin;
//# sourceMappingURL=ItemPlugin-4b97bbcb.js.map
