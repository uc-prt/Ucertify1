
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, C as validate_each_argument, v as validate_slots, o as onMount, A as AH, L as beforeUpdate, y as language, w as writable, X as XMLToJSON, M as JSONToXML, _ as onUserAnsChange, a7 as afterUpdate, z as empty, n as insert_dev, x as detach_dev, c as create_component, f as space, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, j as attr_dev, k as add_location, K as destroy_each, l as set_style, r as group_outros, u as check_outros, q as listen_dev, G as prop_dev, H as run_all, B as noop, h as text } from './main-d98b8a5f.js';
import { I as ItemHelper } from './ItemHelper-5f3cad21.js';
import { G as GriddedHelper } from './GriddedHelper-37225820.js';

/* clsSMGridded/GriddedPreview.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMGridded/GriddedPreview.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-vscbpc-style";
	style.textContent = ".layoutHeading{font-weight:bold;font-size:16px;color:#1877b1}.items_element:hover{border:1.2px solid #777}.moreOptions{-webkit-box-shadow:3px 4px 6px #c4c5c5;-moz-box-shadow:3px 4px 6px #c4c5c5;box-shadow:3px 4px 6px #c4c5c5;background-color:#f0f0f0;border-top:1px solid #1877b1;border-bottom:1px solid #1877b1}.moreOptionDetails{background-color:#f7f7f7}.input_col{position:relative;left:5px}.layoutheading{padding:5px;font-size:20px;font-weight:bold}.numbr_range{position:relative;left:130px}.numbr_range_txt{position:relative;left:200px}.plus_minus_fraction{position:relative;top:20px}.floating_fraction{position:relative;top:27px}.plus_minus_span{position:relative;left:5px}.floating_decimal{float:right;margin-right:45px}.fontStyle{width:100px;float:right;margin-right:60px}.fraction_slash{position:relative;left:177px}.minus_tab,\n    .plus_tab,\n    .slash_tab{text-align:center}.gridded_tab{background-color:#f0f0f0!important;user-select:none!important;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.font_size_label{position:relative;left:198px}.font_size{position:relative;left:225px}.decimal_col{position:relative;left:208px;width:90px}.correct_color{background-color:#E9FFE9}.fixed_decimal_check{position:relative;top:26px;left:13px}.correct_incorrect_icon_fill{position:relative;width:19px;height:19px;right:121px;top:-55px;background:white;border-radius:50%}.row_column_decimal{position:relative;top:30px;left:5px}.fixed_point_class{position:relative;left:7px}.row_column{position:relative;left:5px}.answer_icon{position:absolute;top:7px;right:34px}.myP tbody{cursor:pointer}.col_range{width:205px}.posSize{position:relative;left:7px}.fontSmall{font-size:12px;text-align:center}.fontNormal{font-size:14px;text-align:center}.fontLarge{font-size:24px;text-align:center}.fontExtraLarge{font-size:26px;text-align:center}.grid{position:relative;top:10px;box-shadow:10px 5px 10px #000}.items_element{border:1px solid #8080807a;padding:6px 10px;border-radius:50%;background-color:white}.griddedModule .active{color:white;transition:1s;background:#696969;border:2px solid #fff}.minus_point,\n    .decl_point{padding:6px 12px}.sla_point{padding:6px 11px}.griddedModule table tr td:last-child{border-right:1px solid #ccc !important}.griddedModule .lastGrid tr:last-child td{border-bottom:1px solid #ccc !important}.griddedModule td{border:1px solid #f0f0f0 !important;border-left:1px solid #ccc !important}.token:hover{border:1px solid #000 !important}.bla .token:hover{border:1px solid #fff !important}.token_selected{background-color:#64bb63;color:#fff}.bla .token_highlight_heading{color:#000 !important}.griddedModule .expandIcon{font-size:27px;font-weight:bold;color:#1877b1}table td, table th{padding:.5rem .5rem!important;vertical-align:top!important;border-top:1px solid #dee2e6!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZGRlZFByZXZpZXcuc3ZlbHRlIiwic291cmNlcyI6WyJHcmlkZGVkUHJldmlldy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBcbiAqICBGaWxlIE5hbWUgICA6IEdyaWRkZWRQcmV2aWV3LmpzXG4gKiAgRGVzY3JpcHRpb24gOiBTaG93aW5nIHRoZSBncmlkZGVkIHNoZWV0IGZvciBzdHVkZW50XG4gKiAgQXV0aG9yICAgICAgOiBTdW5kYXJhbSBUcmlwYXRoaVxuICogIFZlcnNpb24gICAgIDogMS4wXG4gKiAgUGFja2FnZSAgICAgOiBwZS1nb2xkXG4gKiAgTGFzdCB1cGRhdGUgOiAyNi1qdW5lLTIwMjEgIC0tPlxuPHNjcmlwdD5cbiAgICBpbXBvcnQgbCBmcm9tICcuLi9zcmMvbGlicy9lZGl0b3JMaWIvbGFuZ3VhZ2UuanMnO1xuICAgIGltcG9ydCBJdGVtSGVscGVyIGZyb20gJy4uL2hlbHBlci9JdGVtSGVscGVyLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IHt3cml0YWJsZX0gZnJvbSAnc3ZlbHRlL3N0b3JlJztcbiAgICBpbXBvcnQge0FILFhNTFRvSlNPTixKU09OVG9YTUwsb25Vc2VyQW5zQ2hhbmdlfSBmcm9tIFwiLi4vaGVscGVyL0hlbHBlckFJLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBiZWZvcmVVcGRhdGUsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCBHcmlkZGVkSGVscGVyIGZyb20gJy4vR3JpZGRlZEhlbHBlci5zdmVsdGUnO1xuICAgIFxuXG5cblxuICAgIGV4cG9ydCBsZXQgaXNSZXZpZXc7XG4gICAgZXhwb3J0IGxldCB4bWw7XG4gICAgZXhwb3J0IGxldCBzaG93QW5zO1xuICAgIGV4cG9ydCBsZXQgdXhtbDtcbiAgICBleHBvcnQgbGV0IGVkaXRvclN0YXRlO1xuXG4gICAgLy8gRGVjbGFyZSBnbG9iYWwgdmFyaWFibGVzIC8vLy9cblxuICAgIGxldCBib29sID0gJyAnOyBcbiAgICBsZXQgdXNlckFucyA9IFtdO1xuICAgIGxldCBhbnMgPSBbXTtcbiAgICBsZXQgbXlBbnMgPSBbXTtcbiAgICBsZXQgYyA9IDA7XG4gICAgbGV0IGNvcnJlY3RJbmM7XG4gICAgbGV0IGlzQW5zd2VyQ29ycmVjdCA9ICcnO1xuICAgIGxldCBhbnN3ZXJTdGF0dXMgPSAnJztcbiAgICBsZXQgYXV0aEFuc1NwbGl0O1xuICAgIGxldCBpbmNvcnJlY3RDbHMgPSBcIlwiO1xuXG5cblxuICAgIGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7ICBcbiAgICAgICAgcm93TnVtICAgICAgICAgICAgICAgICAgOiA0LFxuICAgICAgICBjb2xOdW0gICAgICAgICAgICAgICAgICA6IDQsXG4gICAgICAgIGl0ZW0gICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICAgICAgcGx1c19taW51cyAgICAgICAgICAgICAgOiAwLFxuICAgICAgICBzbGFzaF92YWwgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIGRlY2ltYWxfdmFsICAgICAgICAgICAgIDogMCxcbiAgICAgICAgeG1sICAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgdGV4dFNpemVQICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICBjb3JyZWN0QW5zICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB1c2VyTGlzdCAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICBpc01hdGhxdWlsbCAgICAgICAgICAgICA6ZmFsc2UsXG4gICAgICAgIHNtQ29udHJvbGxlciAgICAgICAgICAgIDogXCJoXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHMgICAgICAgICAgIDogXCJhdXRvXCIsXG4gICAgICAgIGRlY2ltYWxfcG9pbnQgICAgICAgICAgIDogMCxcbiAgICAgICAgaWNvblZpc2libGUgICAgICAgICAgICAgOiBcImhcIixcbiAgICAgICAgXG4gICAgfSlcblxuICAgIGxldCBzdGF0ZSA9IHt9O1xuICAgIFxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RhdGVEYXRhLnN1YnNjcmliZSgoaXRlbXMpPT57XG4gICAgICAgIHN0YXRlID0gaXRlbXM7XG4gICAgfSlcblxuICAgICQ6e1xuICAgICAgICBpZiAoaXNSZXZpZXcpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXZpZXcoKTsgXG4gICAgICAgICAgICAgICAvLyB0aGlzLmNoZWNrQW5zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdW5zZXRSZXZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91bnQoKCk9PntcbiAgICAgICAgLy8gJCgnYm9keScpLm9uKCdrZXlkb3duJywgJy50ZF9kYXRhJywgZnVuY3Rpb24oZSkgeyBcbiAgICAgICAgLy8gICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAvLyAgICAgICAgICQodGhpcykuY2xpY2soKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfSk7XG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwna2V5ZG93bicsJy50ZF9kYXRhJywoKGUpPT57XG4gICAgICAgICAgICBpZihlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgIGUuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpXG5cbiAgICAgICAgLy8galF1ZXJ5KCcjc21fY29udHJvbGxlciBidXR0b24nKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgIGpRdWVyeSgnI3NtX2NvbnRyb2xsZXIgYnV0dG9uJykucmVtb3ZlQ2xhc3MoXCJhY3RpdmUgYnRuLXNlY29uZGFyeSB0ZXh0LXdoaXRlIGJnLXNlY29uZGFyeVwiKTtcbiAgICAgICAgLy8gICAgIGpRdWVyeSh0aGlzKS5hZGRDbGFzcygnYWN0aXZlIGJ0bi1zZWNvbmRhcnkgdGV4dC13aGl0ZSBiZy1zZWNvbmRhcnknKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcjc21fY29udHJvbGxlciBidXR0b24nLCgoZSk9PntcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnI3NtX2NvbnRyb2xsZXIgYnV0dG9uJywncmVtb3ZlQ2xhc3MnLFsnYWN0aXZlLGJ0bi1zZWNvbmRhcnksdGV4dC13aGl0ZSxiZy1zZWNvbmRhcnknXSk7XG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoZSwnYWRkQ2xhc3MnLFsnYWN0aXZlLGJ0bi1zZWNvbmRhcnksdGV4dC13aGl0ZSxiZy1zZWNvbmRhcnknXSk7XG4gICAgICAgIH0pKVxuXG4gICAgICAgIFxuXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcjc2V0LXJldmlldycsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNldFJldmlldygpO1xuICAgICAgICB9KVxuXG4gICAgICAgIFxuXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcjdW5zZXQtcmV2aWV3JyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgdW5zZXRSZXZpZXcoKTtcbiAgICAgICAgfSlcbiAgICB9KVxuXG4gICAgXG4gICAgZnVuY3Rpb24gbG9hZE1vZHVsZShsb2FkWG1sKSB7XG4gICAgICAgIGxvYWRYbWwgPSBYTUxUb0pTT04obG9hZFhtbCk7XG4gICAgICAgIHBhcnNlWE1MUHJldmlldyhsb2FkWG1sKTsgXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VYTUxQcmV2aWV3KE1ZWE1MKSB7XG5cdCAgICB0cnkge1xuXHRcdFx0XG5cdFx0XHRzdGF0ZS5yb3dOdW0gPSBNWVhNTC5zbXhtbC5fcm93O1xuICAgICAgICAgICAgc3RhdGUuY29sTnVtID0gTVlYTUwuc214bWwuX2NvbDsgIFxuICAgICAgICAgICAgc3RhdGUuc2xhc2hfdmFsID0gTVlYTUwuc214bWwuX3NsYXNoO1xuICAgICAgICAgICAgc3RhdGUucGx1c19taW51cyA9IE1ZWE1MLnNteG1sLl9wbHVzbWludXM7XG4gICAgICAgICAgICBzdGF0ZS5kZWNpbWFsX3ZhbCA9ICBNWVhNTC5zbXhtbC5fZGVjaW1hbDtcbiAgICAgICAgICAgIHN0YXRlLnRleHRTaXplUCA9IE1ZWE1MLnNteG1sLl9mb250O1xuICAgICAgICAgICAgc3RhdGUuY29ycmVjdEFucyA9IE1ZWE1MLnNteG1sLl9jb3JyZWN0QW5zLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBzdGF0ZS5kZWNpbWFsX3BvaW50ID0gTVlYTUwuc214bWwuX2ZpeGVkX3BvaW50O1xuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgKHdpbmRvdy51YVhNTCkge1xuICAgICAgICAgICAgaWYodXhtbCkge1xuICAgICAgICAgICAgICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcGFyc2VVc2VyQW5zKHdpbmRvdy51YVhNTCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlVXNlckFucyh1eG1sKVxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIH0sNTApO1xuICAgICAgICAgICAgfVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHsnZXJyb3InOmVycm9yLm1lc3NhZ2UsJ2Z1bmN0aW9uIG5hbWUnOidwYXJzZVhNTFByZXZpZXcnLCdGaWxlIG5hbWUnOidHcmlkZGVkUHJldmlldy5qcyd9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVXNlckFucyh1YW5zKSB7XG4gICAgICAgICAgICBsZXQgdXNlckFuc3dlciA9IFhNTFRvSlNPTih1YW5zKTtcbiAgICAgICAgICAgIGlmICh1c2VyQW5zd2VyLnNtYW5zICYmIHVzZXJBbnN3ZXIuc21hbnMuZGl2ICYmIHVzZXJBbnN3ZXIuc21hbnMuZGl2Ll91c2VyQW5zKSB7XG4gICAgICAgICAgICAgICAgdXNlckFucyA9IHVzZXJBbnN3ZXIuc21hbnMuZGl2Ll91c2VyQW5zLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICBib29sID0gdXNlckFuc3dlci5zbWFucy5kaXYuX2NvcnJlY3Q7XG4gICAgICAgICAgICAgICAvLyAkKFwiI2Fuc3dlclwiKS5wcm9wKFwiY2hlY2tlZFwiLCBib29sKVxuICAgICAgICAgICAgICAgIGFucyA9IHVzZXJBbnM7XG4gICAgICAgICAgICAgICAgLy9mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIGJlZm9yZVVwZGF0ZSgoKT0+e1xuICAgICAgICBpZiAoeG1sICE9IHN0YXRlLnhtbCkge1xuICAgICAgICAgICAgc3RhdGUueG1sID0geG1sO1xuICAgICAgICAgICAgbG9hZE1vZHVsZSh4bWwpO1xuICAgICAgICB9ICBcbiAgICAgICAgLy9pZiAodGhpcy5wcm9wcy5yZW1lZFN0YXR1cyAhPSBuZXh0UHJvcHMucmVtZWRTdGF0dXMpIHtcbiAgICAgICAgICAgXG4gICAgICAgIC8vfSBcbiAgICAgICAgLy9pZiAod2luZG93LlFYTUwpIHtcbiAgICAgICAgaWYoeG1sKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncXhtbCcpO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Um93SXRlbVByZSgpO1xuICAgICAgICBkZWNpbWFsRmxvYXRpbmdQcmUoKTtcbiAgICAgICAgc2xhc2hGdW5jUHJlKCk7XG4gICAgICAgIHBsdXNNaW51c1NpZ25QcmUoKTtcbiAgICAgICAgY3JlYXRlZFNoZWV0Um93UHJlKCk7XG4gICAgICAgIFxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgICAgICBcbiAgICAgICAgLy8vLy8vLy8vLy8vLy9jaGFuZ2luZyBjb2xvciBhY2NvcmRpbmcgdG8gdXNlci8vLy8vLy8vL1xuICAgICAgICBsZXQgY2VsbF9jbGFzcyA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgIGxldCBjb2x1bW5faW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShjZWxsX2NsYXNzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uX2luZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG5cbiAgICAgICAgICAvLy8vLy8vL1Rocm93IHRoZSBzZWxlY3QgZGF0YSBpbiB0b3Agcm93Ly8vLy8vL1xuICAgICAgICAgICAgbGV0IHRhcmdldF9pZCA9IGV2ZW50LnRhcmdldC5pZDtcbiAgICAgICAgICAgIGxldCB0YXJnZXRfdG9fZGlzcGxheSA9IHRhcmdldF9pZC5zcGxpdChcIi1cIik7IFxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0X3RvX2Rpc3BsYXlbMF0pLnZhbHVlID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTDtcbiAgICAgICAgICAgIHNldFVzZXJBbnMoZXZlbnQpOyAvLy8vLy8vLyBDYWxsIGZ1bmN0aW9uIGZvciBhbnN3ZXIgY2hlY2tpbmdcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRVc2VyQW5zIChldmVudCkgIHtcbiAgICAgICAgbGV0IGNvdW50UmVzO1xuICAgICAgICBsZXQgcmVzTmV3O1xuXG4gICAgICAgLy8vLy8vLy8gVGhpcyBjb2RlIHNldCB0aGUgYW5zd2VyLy8vLy8vLy8vLy9cbiAgICAgICAgbGV0IGF0dHIgPSBldmVudC50YXJnZXQuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtdGFnJykudmFsdWU7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQuaW5uZXJIVE1MID09PSAnJykge1xuICAgICAgICAgICAgdXNlckFuc1thdHRyXSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgdXNlckFuc1thdHRyXSA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8dXNlckFucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodXNlckFuc1tpXSkgPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFuc1tpXSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdXNlckFuc1tpXSA9IFwiJWJsYW5rJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZXJBbnNbKHVzZXJBbnMubGVuZ3RoKS0xXSA9PSBcIiVibGFuayVcIikge1xuICAgICAgICAgICAgdXNlckFucy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgICAgICBzdGF0ZS51c2VyTGlzdCA9IHVzZXJBbnM7XG4gICAgICAgIFxuICAgICAgICAgICAgYXV0aEFuc1NwbGl0ID0gc3RhdGUuY29ycmVjdEFucztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHVzZXIgPSBzdGF0ZS51c2VyTGlzdDtcbiAgICAgICAgICAgIGlmICh1c2VyLmxlbmd0aCA9PSBhdXRoQW5zU3BsaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdXRoQW5zU3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJbaV0gPT0gYXV0aEFuc1NwbGl0W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjKys7ICBcblxuICAgICAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjID09IHVzZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5jb3JyZWN0XG4gICAgICAgICAgICAgICAgICAgIGlzQW5zd2VyQ29ycmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY291bnRSZXMgPSBsLmluY29ycmVjdDtcbiAgICAgICAgICAgICAgICAgICAgaXNBbnN3ZXJDb3JyZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudFJlcyA9IGwuaW5jb3JyZWN0O1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmICghd2luZG93LlFYTUwpIHtcbiAgICAgICAgICAgIGlmKGVkaXRvclN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc2hvd0Fucyhjb3VudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQUguc2VsZWN0KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIpLnZhbHVlID0gXCI8c21hbnM+PGRpdiB0eXBlPSc1NicgY29ycmVjdD0nXCIraXNBbnN3ZXJDb3JyZWN0K1wiJyB1c2VyQW5zPSdcIitzdGF0ZS51c2VyTGlzdCtcIic+PC9kaXY+PC9zbWFucz5cIlxuXG4gICAgICAgICAgICByZXNOZXcgPSBcIjxzbWFucz48ZGl2IHR5cGU9JzU2JyBjb3JyZWN0PSdcIitpc0Fuc3dlckNvcnJlY3QrXCInIHVzZXJBbnM9J1wiK3N0YXRlLnVzZXJMaXN0K1wiJz48L2Rpdj48L3NtYW5zPlwiO1xuICAgICAgICAgICAgaWYgKGJvb2wgIT0gJyAnICYmIGMgPT0gdXNlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL2pRVWVyeShcIiNhbnN3ZXJcIikucHJvcChcImNoZWNrZWRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KFwiI2Fuc3dlclwiLCdhdHRyJyx7XCJjaGVja2VkXCI6Ym9vbH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2pRdWVyeShcIiNhbnN3ZXJcIikucHJvcChcImNoZWNrZWRcIiwgaXNBbnN3ZXJDb3JyZWN0KTtcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoXCIjYW5zd2VyXCIsJ2F0dHInLHtcImNoZWNrZWRcIjppc0Fuc3dlckNvcnJlY3R9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uVXNlckFuc0NoYW5nZSh7dVhNTDpyZXNOZXcsYW5zOmNvdW50UmVzfSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrQ29tYm8oZXZlbnQpIHtcbiAgICAgICAgXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vY2hhbmdpbmcgY29sb3IgYWNjb3JkaW5nIHRvIHVzZXIvLy8vLy8vLy9cbiAgICAgICAgbGV0IGNlbGxfY2xhc3MgPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICBsZXQgY29sdW1uX2luZGV4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoY2VsbF9jbGFzcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChldmVudC5kZXRhaWwudGFyZ2V0KS5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuXG4gICAgICAgICAgLy8vLy8vLy9UaHJvdyB0aGUgc2VsZWN0IGRhdGEgaW4gdG9wIHJvdy8vLy8vLy9cbiAgICAgICAgICAgIGxldCB0YXJnZXRfaWQgPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkuaWQ7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0X3RvX2Rpc3BsYXkgPSB0YXJnZXRfaWQuc3BsaXQoXCItXCIpOyBcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldF90b19kaXNwbGF5WzBdKS52YWx1ZSA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pbm5lckhUTUw7XG4gICAgICAgICAgICBzZXRVc2VyQW5zQ29tYm8oZXZlbnQpOyAvLy8vLy8vLyBDYWxsIGZ1bmN0aW9uIGZvciBhbnN3ZXIgY2hlY2tpbmdcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRVc2VyQW5zQ29tYm8gKGV2ZW50KSAge1xuICAgICAgICBsZXQgY291bnRSZXM7XG5cbiAgICAgICAvLy8vLy8vLyBUaGlzIGNvZGUgc2V0IHRoZSBhbnN3ZXIvLy8vLy8vLy8vL1xuICAgICAgICBsZXQgYXR0ciA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS10YWcnKS52YWx1ZTtcbiAgICAgICAgaWYgKChldmVudC5kZXRhaWwudGFyZ2V0KS5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgICAgICAgICB1c2VyQW5zW2F0dHJdID0gKGV2ZW50LmRldGFpbC50YXJnZXQpLnZhbHVlO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICB1c2VyQW5zW2F0dHJdID0gKGV2ZW50LmRldGFpbC50YXJnZXQpLmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaTx1c2VyQW5zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih1c2VyQW5zW2ldKSA9PSAndW5kZWZpbmVkJyB8fCB1c2VyQW5zW2ldID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB1c2VyQW5zW2ldID0gXCIlYmxhbmslXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlckFuc1sodXNlckFucy5sZW5ndGgpLTFdID09IFwiJWJsYW5rJVwiKSB7XG4gICAgICAgICAgICB1c2VyQW5zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIHN0YXRlLnVzZXJMaXN0ID0gdXNlckFucztcbiAgICAgICAgXG4gICAgICAgICAgICBhdXRoQW5zU3BsaXQgPSBzdGF0ZS5jb3JyZWN0QW5zO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgdXNlciA9IHN0YXRlLnVzZXJMaXN0O1xuICAgICAgICAgICAgaWYgKHVzZXIubGVuZ3RoID09IGF1dGhBbnNTcGxpdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1dGhBbnNTcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlcltpXSA9PSBhdXRoQW5zU3BsaXRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMrKzsgIFxuXG4gICAgICAgICAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gdXNlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY291bnRSZXMgPSBsLmNvcnJlY3RcbiAgICAgICAgICAgICAgICAgICAgaXNBbnN3ZXJDb3JyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudFJlcyA9IGwuaW5jb3JyZWN0O1xuICAgICAgICAgICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5pbmNvcnJlY3Q7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiAoIXdpbmRvdy5RWE1MKSB7XG4gICAgICAgICAgICBpZihlZGl0b3JTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHNob3dBbnMoY291bnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8valF1ZXJ5KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIpLnZhbChcIjxzbWFucz48ZGl2IHR5cGU9JzU2JyBjb3JyZWN0PSdcIitpc0Fuc3dlckNvcnJlY3QrXCInIHVzZXJBbnM9J1wiK3N0YXRlLnVzZXJMaXN0K1wiJz48L2Rpdj48L3NtYW5zPlwiKTtcbiAgICAgICAgICAgIEFILnNlbGVjdChcIiNzcGVjaWFsX21vZHVsZV91c2VyX3htbFwiKS52YWx1ZSA9IFwiPHNtYW5zPjxkaXYgdHlwZT0nNTYnIGNvcnJlY3Q9J1wiK2lzQW5zd2VyQ29ycmVjdCtcIicgdXNlckFucz0nXCIrc3RhdGUudXNlckxpc3QrXCInPjwvZGl2Pjwvc21hbnM+XCJcbiAgICAgICAgICAgIGlmIChib29sICE9ICcgJyAmJiBjID09IHVzZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9qUVVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIEFILnNlbGVjdChcIiNhbnN3ZXJcIiwnYXR0cicse1wiY2hlY2tlZFwiOmJvb2x9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9qUXVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGlzQW5zd2VyQ29ycmVjdCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KFwiI2Fuc3dlclwiLCdhdHRyJyx7XCJjaGVja2VkXCI6aXNBbnN3ZXJDb3JyZWN0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3dWYWxpZGF0aW9uKGV2ZW50KSB7ICBcbiAgICAgICAgbGV0IGEgPSBzdGF0ZS5yb3dOdW0gLSAxO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIEFILmFsZXJ0KCdEb3VibGUgZGlnaXQgbm90IGFjY2VwdGVkJyk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfWVsc2UgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIEFILmFsZXJ0KFwiTGVzcyB0aGVuIDEgbm90IGFjY2VwdGVkXCIpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfWVsc2UgaWYgKCBhIDwgZXZlbnQudGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICBBSC5hbGVydCgnTnVtYmVyIGluc2VydCBvbmx5IDAgdG8gJytzdGF0ZS5yb3dOdW0pO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VXNlckFucyhldmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlnaExpZ2h0KGV2ZW50KSB7ICAgIFxuICAgICAgICBsZXQgY2VsbF9jbGFzcyA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgbGV0IGNvbHVtbl9pbmRleCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGNlbGxfY2xhc3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICBpZiAoY29sdW1uX2luZGV4W2ldLmlubmVySFRNTCA9PSBldmVudC50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH1cblxuXG4gICAgIC8vLy8vLy8vLy8vLy8vLy8vLyBDcmVhdGUgdmVyeSBmaXJzdCByb3cgYW5kIHN0b3JlIGRhdGEgYWNjb3JkaW5nIHRvIGNsaWNrLy8vLy8vLy8vL1xuXG4gICAgbGV0IENvbHNQcmUgPSBbXTtcbiAgICBmdW5jdGlvbiBmaXJzdFJvd0l0ZW1QcmUoKSB7XG4gICAgICAgICAgICBsZXQgUm93cyA9IFtdO1xuICAgICAgICAgICAgQ29sc1ByZSA9IFtdO1xuICAgICAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLmNvbE51bTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuc1tqXSA9PT0gXCIlYmxhbmslXCIpe1xuICAgICAgICAgICAgICAgICAgICBteUFuc1tqXSA9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG15QW5zW2pdID0gYW5zW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHNQcmUgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzUHJlLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb2xzUHJlLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29sc1ByZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzUHJlLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd0JytqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncCcraixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG15QW5zW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuaWQ6IFwidF9cIitqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgfVxuXG5cblxuICAgIGxldCB0b3RhbFJvd3MgPSBbXTtcbiAgICBsZXQgdG90YWxDb2xzID0gW107XG4gICAgZnVuY3Rpb24gY3JlYXRlZFNoZWV0Um93UHJlKCkge1xuICAgICAgICB0b3RhbFJvd3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5yb3dOdW07IGkrKykge1xuICAgICAgICAgICAgICAgIHRvdGFsQ29scyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxDb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjb2xcIitpK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsQ29scy5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbENvbHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjb2xcIitpK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncCcraixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqICsgXCItXCIgKyBpICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL3RvdGFsUm93cy5wdXNoKDx0ciBrZXk9e1wicm93XCIraX0+e3RvdGFsQ29sc308L3RyPik7XG4gICAgICAgICAgICAgICAgdG90YWxSb3dzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi50b3RhbFJvd3Mse1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInJvd1wiK2lcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgQ29sc19zbGFzaCA9IFtdO1xuICAgIGZ1bmN0aW9uIHNsYXNoRnVuY1ByZShldmVudCkge1xuICAgICAgICAgICAgbGV0IFJvd3Nfc2xhc2ggPSBbXTtcbiAgICAgICAgICAgIENvbHNfc2xhc2ggPSBbXTtcbiAgICAgICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb2xzX3NsYXNoID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLkNvbHNfc2xhc2gse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiY29sXCIraixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENvbHNfc2xhc2gubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29sc19zbGFzaCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19zbGFzaCx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3AnK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IENvbHNfZGVjaW1hbCA9IFtdO1xuICAgIGZ1bmN0aW9uIGRlY2ltYWxGbG9hdGluZ1ByZShldmVudCkge1xuICAgICAgICBsZXQgUm93c19kZWNpbWFsID0gW107XG4gICAgICAgIENvbHNfZGVjaW1hbCA9IFtdO1xuICAgICAgICBsZXQgZGVjX3BvaW50ID0gc3RhdGUuZGVjaW1hbF9wb2ludDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xuICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50LTEgJiYgZGVjX3BvaW50ICE9IDApIHsgXG4gICAgICAgICAgICAgICAgQ29sc19kZWNpbWFsID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX2RlY2ltYWwse1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImNvbFwiK2osXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoQ29sc19kZWNpbWFsLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xuICAgICAgICAgICAgICAgICAgICBDb2xzX2RlY2ltYWwgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX2RlY2ltYWwse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRcIiArIGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3AnK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vIFNldCByZXZpZXcgYW5kIHVuc2V0IHJldmlldyBmdW5jdGlvbi8vLy8vLy8vLy8vLy8vXG5cbiAgICBmdW5jdGlvbiBzZXRSZXZpZXcoKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgc3RhdGUuc21Db250cm9sbGVyID0gXCJcIixcbiAgICAgICAgc3RhdGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiXG4gICAgICAgIGlzUmV2aWV3ID0gdHJ1ZTtcbiAgICAgICAgc2hvd0Fuc3dlcihcInlhbnNcIiwgXCJzaG93SWNvblwiKTtcbiAgICAgICAgLy9qUXVlcnkoJyNzbV9jb250cm9sbGVyIC55b3VyLWFucycpLmFkZENsYXNzKFwiYnRuLWxpZ2h0IGFjdGl2ZVwiKTtcblxuICAgICAgICBBSC5zZWxlY3RBbGwoJyNzbV9jb250cm9sbGVyIC55b3VyLWFucycsJ2FkZENsYXNzJyxbJ2J0bi1saWdodCcsJ2FjdGl2ZSddKTtcblxuXG4gICAgICAgIC8valF1ZXJ5KFwiLnRva2VuSGVhZGVyXCIpLmF0dHIoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgICAgIEFILnNlbGVjdEFsbChcIi50b2tlbkhlYWRlclwiLFwiYXR0clwiLHtcInRhYmluZGV4XCI6MH0pXG5cbiAgICAgICAgLy9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRva2VuSGVhZGVyXCIpLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCIwXCIpO1xuICAgICAgICBzZXRUaW1lb3V0KGdldENvcnJlY3QoKSwyMDApOyBcbiAgICAgICAgLy8gaWYgKCF3aW5kb3cuUVhNTCkge1xuICAgICAgICBpZihlZGl0b3JTdGF0ZSkge1xuICAgICAgICAgICAgc2hvd0FucygoaXNBbnN3ZXJDb3JyZWN0KT8obC5jb3JyZWN0KToobC5pbmNvcnJlY3QpKTtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb3JyZWN0KCkge1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5jb3JyZWN0QW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuY29ycmVjdEFuc1tpXSA9PSBzdGF0ZS51c2VyTGlzdFtpXSkge1xuICAgICAgICAgICAgICAgIC8valF1ZXJ5KCcjdF8nK2kpLnJlbW92ZUNsYXNzKFwiaWNvbW9vbi1uZXctMjRweC1jYW5jZWwtY2lyY2xlLTFcIikuYWRkQ2xhc3MoXCJpY29tb29uLW5ldy0yNHB4LWNoZWNrbWFyay1jaXJjbGUtMVwiKTtcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyN0XycraSwncmVtb3ZlQ2xhc3MnLCdpY29tb29uLW5ldy0yNHB4LWNhbmNlbC1jaXJjbGUtMScpO1xuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3RfJytpLCdhZGRDbGFzcycsJ2ljb21vb24tbmV3LTI0cHgtY2hlY2ttYXJrLWNpcmNsZS0xJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8valF1ZXJ5KCcjdF8nK2kpLnJlbW92ZUNsYXNzKFwiaWNvbW9vbi1uZXctMjRweC1jaGVja21hcmstY2lyY2xlLTFcIikuYWRkQ2xhc3MoXCJpY29tb29uLW5ldy0yNHB4LWNhbmNlbC1jaXJjbGUtMVwiKTtcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyN0XycraSwncmVtb3ZlQ2xhc3MnLCdpY29tb29uLW5ldy0yNHB4LWNoZWNrbWFyay1jaXJjbGUtMScpO1xuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3RfJytpLCdhZGRDbGFzcycsJ2ljb21vb24tbmV3LTI0cHgtY2FuY2VsLWNpcmNsZS0xJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcblx0fVxuIFxuICAgIGZ1bmN0aW9uIHVuc2V0UmV2aWV3KCkgeyAgXG4gICAgICAgIHN0YXRlLnNtQ29udHJvbGxlciA9IFwiaFwiLFxuICAgICAgICBzdGF0ZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCJcbiAgICAgICAgaXNSZXZpZXcgPSBmYWxzZTtcbiAgICAgICAgc2hvd0Fuc3dlcihcInlhbnNcIiwgXCJoaWRlSWNvblwiKTtcbiAgICAgICAgLy9qUXVlcnkoXCIudG9rZW5IZWFkZXJcIikucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpO1xuICAgICAgICBBSC5zZWxlY3RBbGwoXCIudG9rZW5IZWFkZXJcIiwgJ3JlbW92ZUF0dHInLCAndGFiaW5kZXgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93QW5zd2VyKHZhbCxpY29uU3RhdGUpIHtcbiAgICAgICAgXG4gICAgICAvL3Nob3cgY29ycmVjdCBpbmNvcnJlY3QgaWNvbiB3aXRoIHJlc3BlY3QgdG8gaWNvblN0YXRlXG4gICAgICAgIGlmIChpY29uU3RhdGUgPT0gXCJzaG93SWNvblwiKSB7XG4gICAgICAgICAgICBzdGF0ZS5pY29uVmlzaWJsZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5pY29uVmlzaWJsZSA9IFwiaFwiO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodmFsID09IFwiY2Fuc1wiKSB7XG4gICAgICAgICAgICBsZXQgZWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZ3JpZGRlZF90YWInKTtcbiAgICAgICAgICAgIGVsZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBhbnMgPSBzdGF0ZS5jb3JyZWN0QW5zO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PSBcInlhbnNcIikge1xuICAgICAgICAgICAgYW5zID0gdXNlckFucztcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBjcmVhdGUgcGx1cyBhbmQgbWludXMgcm93Ly8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IENvbHMgPSBbXTtcbiAgICBsZXQgQ29sc19NaW51cyA9IFtdO1xuICAgIGZ1bmN0aW9uIHBsdXNNaW51c1NpZ25QcmUoZXZlbnQpICB7XG4gICAgICAgIENvbHMgPSBbXTtcbiAgICAgICAgQ29sc19NaW51cyA9IFtdO1xuICAgICAgICBsZXQgZGVjX3BvaW50ID0gc3RhdGUuZGVjaW1hbF9wb2ludDtcbiAgICAgICAgLy9sZXQgYXJyID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqID09IGRlY19wb2ludCAtIDEgJiYgZGVjX3BvaW50ICE9IDApIHtcbiAgICAgICAgICAgICAgICBDb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkOiBcInRkXCIgKyBqICsgJy0nICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbHMubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwJytqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHNfTWludXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX01pbnVzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZDogXCJ0ZFwiICsgaiArICctJyArIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbHNfTWludXMubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHNfTWludXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX01pbnVzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwJytqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmV2aWV3KG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT0gJ2MnKSB7XG5cdFx0XHRzaG93QW5zd2VyKFwiY2Fuc1wiLCBcImhpZGVJY29uXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaG93QW5zd2VyKFwieWFuc1wiLCBcInNob3dJY29uXCIpO1xuXHRcdH1cbiAgICB9XG4gICAgLy9sZXQgZGlzcGxheUNsYXNzID0gKChzdGF0ZS5pY29uVmlzaWJsZSA9PSBcIlwiICYmIChzdGF0ZS51c2VyQW5zKS5pbmNsdWRlcyh2YWwuaWQpKSk7XG5cbjwvc2NyaXB0PlxuXG48bWFpbj5cbiAgICA8Y2VudGVyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZ3JpZGRlZE1vZHVsZVwiPlxuICAgICAgICAgICAgPGNlbnRlcj4gXG4gICAgICAgICAgICAgICAgPEl0ZW1IZWxwZXIgXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVJldmlld0NsaWNrPXtoYW5kbGVSZXZpZXd9XG4gICAgICAgICAgICAgICAgICAgIHJldmlld01vZGU9e2lzUmV2aWV3fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2NlbnRlcj5cbiAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XCIxXCIgaWQ9XCJ0YWIyXCIgc3R5bGU9eydib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7dGV4dC1hbGlnbjpjZW50ZXInfSA+XG4gICAgICAgICAgICAgICAgPHRyIHN0eWxlPVwiZGlzcGxheTpmbGV4O1wiPlxuICAgICAgICAgICAgICAgICAgICB7I2VhY2ggQ29sc1ByZSBhcyB2YWwsaX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgdmFsLmRlY3BvaW50ID09IHRydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgc3R5bGU9eyd3aWR0aDo1MHB4O3RleHQtYWxpZ246Y2VudGVyOyd9ICB2YWx1ZT1cIi5cIiBkaXNhYmxlZD1cInRydWVcIiBjbGFzcz1cInRkRm9udFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPXt2YWwuaWR9IGRhdGEtdGFnPXt2YWwuZGF0YVRhZ30gbmFtZT17dmFsLm5hbWV9IHN0eWxlPXsnd2lkdGg6NTBweDt0ZXh0LWFsaWduOmNlbnRlcjsnfSBvbjpjaGFuZ2U9e3Jvd1ZhbGlkYXRpb259IG9uOmlucHV0PXtoaWdoTGlnaHR9IHZhbHVlPXsobXlBbnNbaV0gPT09IHVuZGVmaW5lZCk/XCIgXCI6bXlBbnNbaV19IGNsYXNzPVwidGRGb250XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICBjbGFzcz17c3RhdGUuaWNvblZpc2libGUrJyByZWxhdGl2ZSd9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9e3ZhbC5zcGFuaWR9IGNsYXNzPVwiYW5zd2VyX2ljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICA8L3RhYmxlPlxuXG4gICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5wbHVzX21pbnVzID09IDF9XG4gICAgICAgICAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxuICAgICAgICAgICAgICAgICAgICAgICAgb246aGFuZGxlQ2xpY2tDb21ibyA9IHtoYW5kbGVDbGlja0NvbWJvfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MxID0gXCJ0ZEZvbnQgcGx1c190YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250UCBwbHVzX3RhYiBpdGVtc19lbGVtZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwicGx1c19taW51c190YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJwbHVzX21pbnVzX3RhYiBncmlkZGVkX3RhYiBtdC0wIG15UFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiK1wiXG4gICAgICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XG4gICAgICAgICAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxuICAgICAgICAgICAgICAgICAgICAgICAgb246aGFuZGxlQ2xpY2tDb21ibyA9IHtoYW5kbGVDbGlja0NvbWJvfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX01pbnVzfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MxID0gXCJ0ZEZvbnQgcGx1c190YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250UCBwbHVzX3RhYiBpdGVtc19lbGVtZW50IG1pbnVzX3BvaW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwicGx1c19taW51c190YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJwbHVzX21pbnVzX3RhYiBncmlkZGVkX3RhYiBtdC0wIG15UFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiLVwiXG4gICAgICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XG4gICAgICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAgeyNpZiBzdGF0ZS5kZWNpbWFsX3ZhbCA9PSAxfVxuICAgICAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxuICAgICAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvID0ge2hhbmRsZUNsaWNrQ29tYm99XG4gICAgICAgICAgICAgICAgICAgIGxvb3AgPSB7Q29sc19kZWNpbWFsfVxuICAgICAgICAgICAgICAgICAgICBjbGFzczEgPSBcInRkRm9udCBwb2ludHNcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZEZvbnRQIHRleHQtY2VudGVyIGl0ZW1zX2VsZW1lbnQgZGVjbF9wb2ludFwiXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwic2xhc2hfdGFiXCJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJzbGFzaF90YWIgZ3JpZGRlZF90YWIgbXQtMCBtYi0wIG15UFwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCIuXCJcbiAgICAgICAgICAgICAgICA+PC9HcmlkZGVkSGVscGVyPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgc3RhdGUuc2xhc2hfdmFsID09IDF9XG4gICAgICAgICAgICAgICAgPEdyaWRkZWRIZWxwZXIgIFxuICAgICAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvID0ge2hhbmRsZUNsaWNrQ29tYm99XG4gICAgICAgICAgICAgICAgICAgIGxvb3AgPSB7Q29sc19zbGFzaH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3MxID0gXCJ0ZEZvbnQgcG9pbnRzXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250UCB0ZXh0LWNlbnRlciBpdGVtc19lbGVtZW50IHNsYV9wb2ludFwiXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwidGRGb250UCBzbGFzaF90YWJcIlxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzID1cInNsYXNoX3RhYiBncmlkZGVkX3RhYiBtdC0wXCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIi9cIlxuICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICBcbiAgICAgICAgICAgIDx0YWJsZSBpZD1cImdyaWRkZWRfc2hlZXRcIiBjbGFzcz1cImdyaWRkZWRfdGFiIG10LTAgbGFzdEdyaWQgY3JlYXRlX3RhYiBteVBcIj5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCB0b3RhbFJvd3MgYXMgZGF0YSxub31cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBrZXk9e2RhdGEua2V5fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggdG90YWxDb2xzIGFzIHZhbCxpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHZhbC5kZWNwb2ludH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBrZXk9e3ZhbC5rZXl9IGNsYXNzID0ndGRGb250IHRleHQtY2VudGVyJyB3aWR0aD1cIjUwXCIgZGlzYWJsZWQ9XCJ0cnVlXCI+ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHdpZHRoPVwiNTBcIiBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdGFiaW5kZXg9e3ZhbC50YWJJbmRleH0ga2V5PXt2YWwua2V5fSBuYW1lPXt2YWwubmFtZX0gZGF0YS10YWc9e3ZhbC5kYXRhVGFnfSBjbGFzcz1cInRkRm9udFAgdGV4dC1jZW50ZXIgdGRfZGF0YSBhbGduIGl0ZW1zX2VsZW1lbnRcIiBpZD17dmFsLmlkfSBvbjpjbGljaz17aGFuZGxlQ2xpY2t9Pnsrbm99PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9jZW50ZXI+XG48L21haW4+XG5cbjxzdHlsZT5cbiAgICBcbiAgICA6Z2xvYmFsKC5sYXlvdXRIZWFkaW5nKSB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGNvbG9yOiAjMTg3N2IxO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLml0ZW1zX2VsZW1lbnQ6aG92ZXIpIHtcbiAgICAgICAgYm9yZGVyOiAxLjJweCBzb2xpZCAjNzc3O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLm1vcmVPcHRpb25zKSB7XG4gICAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogM3B4IDRweCA2cHggI2M0YzVjNTtcbiAgICAgICAgLW1vei1ib3gtc2hhZG93OiAzcHggNHB4IDZweCAjYzRjNWM1O1xuICAgICAgICBib3gtc2hhZG93OiAzcHggNHB4IDZweCAjYzRjNWM1O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmMGYwO1xuICAgICAgICBib3JkZXItdG9wOiAxcHggc29saWQgIzE4NzdiMTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICMxODc3YjE7XG4gICAgfVxuXG4gICAgOmdsb2JhbCgubW9yZU9wdGlvbkRldGFpbHMpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5pbnB1dF9jb2wpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiA1cHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCgubGF5b3V0aGVhZGluZykge1xuICAgICAgICBwYWRkaW5nOiA1cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG5cbiAgICA6Z2xvYmFsKC5udW1icl9yYW5nZSkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxlZnQ6IDEzMHB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLm51bWJyX3JhbmdlX3R4dCkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxlZnQ6IDIwMHB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLnBsdXNfbWludXNfZnJhY3Rpb24pIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB0b3A6IDIwcHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZmxvYXRpbmdfZnJhY3Rpb24pIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB0b3A6IDI3cHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCgucGx1c19taW51c19zcGFuKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogNXB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmZsb2F0aW5nX2RlY2ltYWwpIHtcbiAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDQ1cHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZm9udFN0eWxlKSB7XG4gICAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDYwcHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZnJhY3Rpb25fc2xhc2gpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiAxNzdweDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5taW51c190YWIsXG4gICAgLnBsdXNfdGFiLFxuICAgIC5zbGFzaF90YWIpIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmdyaWRkZWRfdGFiKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjAhaW1wb3J0YW50O1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZSFpbXBvcnRhbnQ7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5mb250X3NpemVfbGFiZWwpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiAxOThweDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5mb250X3NpemUpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiAyMjVweDtcbiAgICB9XG5cblxuICAgIDpnbG9iYWwoLmRlY2ltYWxfY29sKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogMjA4cHg7XG4gICAgICAgIHdpZHRoOiA5MHB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmNvcnJlY3RfY29sb3IpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0U5RkZFOTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5maXhlZF9kZWNpbWFsX2NoZWNrKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiAyNnB4O1xuICAgICAgICBsZWZ0OiAxM3B4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmNvcnJlY3RfaW5jb3JyZWN0X2ljb25fZmlsbCkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxOXB4O1xuICAgICAgICBoZWlnaHQ6IDE5cHg7XG4gICAgICAgIHJpZ2h0OiAxMjFweDtcbiAgICAgICAgdG9wOiAtNTVweDtcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5yb3dfY29sdW1uX2RlY2ltYWwpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB0b3A6IDMwcHg7XG4gICAgICAgIGxlZnQ6IDVweDtcblxuICAgIH1cblxuICAgIDpnbG9iYWwoLmZpeGVkX3BvaW50X2NsYXNzKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogN3B4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLnJvd19jb2x1bW4pIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiA1cHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYW5zd2VyX2ljb24pIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDdweDtcbiAgICAgICAgcmlnaHQ6IDM0cHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCgubXlQIHRib2R5KSB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5jb2xfcmFuZ2UpIHtcbiAgICAgICAgd2lkdGg6IDIwNXB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLnBvc1NpemUpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiA3cHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZm9udFNtYWxsKSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmZvbnROb3JtYWwpIHtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZm9udExhcmdlKSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmZvbnRFeHRyYUxhcmdlKSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMjZweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmdyaWQpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB0b3A6IDEwcHg7XG4gICAgICAgIGJveC1zaGFkb3c6IDEwcHggNXB4IDEwcHggIzAwMDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5pdGVtc19lbGVtZW50KSB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICM4MDgwODA3YTtcbiAgICAgICAgcGFkZGluZzogNnB4IDEwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZ3JpZGRlZE1vZHVsZSAuYWN0aXZlKSB7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgdHJhbnNpdGlvbjogMXM7XG4gICAgICAgIGJhY2tncm91bmQ6ICM2OTY5Njk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XG4gICAgfVxuXG4gICAgOmdsb2JhbCgubWludXNfcG9pbnQsXG4gICAgLmRlY2xfcG9pbnQpIHtcbiAgICAgICAgcGFkZGluZzogNnB4IDEycHg7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguc2xhX3BvaW50KSB7XG4gICAgICAgIHBhZGRpbmc6IDZweCAxMXB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgdGFibGUgdHIgdGQ6bGFzdC1jaGlsZCkge1xuICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjY2NjICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZ3JpZGRlZE1vZHVsZSAubGFzdEdyaWQgdHI6bGFzdC1jaGlsZCB0ZCkge1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYyAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgdGQpIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2YwZjBmMCAhaW1wb3J0YW50O1xuICAgICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNjY2MgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC50b2tlbjpob3Zlcikge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjMDAwICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYmxhIC50b2tlbjpob3Zlcikge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZmZmICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgOmdsb2JhbCgudG9rZW5fc2VsZWN0ZWQpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzY0YmI2MztcbiAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYmxhIC50b2tlbl9oaWdobGlnaHRfaGVhZGluZykge1xuICAgICAgICBjb2xvcjogIzAwMCAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgLmV4cGFuZEljb24pIHtcbiAgICAgICAgZm9udC1zaXplOiAyN3B4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgY29sb3I6ICMxODc3YjE7XG4gICAgfVxuICAgIDpnbG9iYWwodGFibGUgdGQsIHRhYmxlIHRoKSB7XG4gICAgICAgIHBhZGRpbmc6IC41cmVtIC41cmVtIWltcG9ydGFudDtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcCFpbXBvcnRhbnQ7XG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGVlMmU2IWltcG9ydGFudDtcbiAgICB9XG48L3N0eWxlPiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFzdkJZLGNBQWMsQUFBRSxDQUFDLEFBQ3JCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsS0FBSyxDQUFFLE9BQU8sQUFDbEIsQ0FBQyxBQUVPLG9CQUFvQixBQUFFLENBQUMsQUFDM0IsTUFBTSxDQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUM1QixDQUFDLEFBRU8sWUFBWSxBQUFFLENBQUMsQUFDbkIsa0JBQWtCLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUN2QyxlQUFlLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUNwQyxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUMvQixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLFVBQVUsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDN0IsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxBQUNwQyxDQUFDLEFBRU8sa0JBQWtCLEFBQUUsQ0FBQyxBQUN6QixnQkFBZ0IsQ0FBRSxPQUFPLEFBQzdCLENBQUMsQUFFTyxVQUFVLEFBQUUsQ0FBQyxBQUNqQixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxBQUNiLENBQUMsQUFFTyxjQUFjLEFBQUUsQ0FBQyxBQUNyQixPQUFPLENBQUUs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 */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[46] = list[i];
	child_ctx[48] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	child_ctx[45] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[46] = list[i];
	child_ctx[48] = i;
	return child_ctx;
}

// (676:24) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_id_value;
	let input_data_tag_value;
	let input_name_value;
	let input_style_value;
	let input_value_value;
	let t0;
	let span1;
	let span0;
	let span0_id_value;
	let t1;
	let span1_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			span1 = element("span");
			span0 = element("span");
			t1 = space();
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = /*val*/ ctx[46].id);
			attr_dev(input, "data-tag", input_data_tag_value = /*val*/ ctx[46].dataTag);
			attr_dev(input, "name", input_name_value = /*val*/ ctx[46].name);
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");

			input.value = input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[48]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[48]];

			attr_dev(input, "class", "tdFont");
			add_location(input, file, 677, 32, 22606);
			attr_dev(span0, "id", span0_id_value = /*val*/ ctx[46].spanid);
			attr_dev(span0, "class", "answer_icon");
			add_location(span0, file, 680, 36, 22968);
			attr_dev(span1, "class", span1_class_value = /*state*/ ctx[2].iconVisible + " relative");
			add_location(span1, file, 679, 32, 22886);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t1);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*rowValidation*/ ctx[12], false, false, false),
					listen_dev(input, "input", highLight, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsPre*/ 8 && input_id_value !== (input_id_value = /*val*/ ctx[46].id)) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_data_tag_value !== (input_data_tag_value = /*val*/ ctx[46].dataTag)) {
				attr_dev(input, "data-tag", input_data_tag_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_name_value !== (input_name_value = /*val*/ ctx[46].name)) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty[0] & /*myAns*/ 2 && input_value_value !== (input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[48]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[48]]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && span0_id_value !== (span0_id_value = /*val*/ ctx[46].spanid)) {
				attr_dev(span0, "id", span0_id_value);
			}

			if (dirty[0] & /*state*/ 4 && span1_class_value !== (span1_class_value = /*state*/ ctx[2].iconVisible + " relative")) {
				attr_dev(span1, "class", span1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(676:24) {:else}",
		ctx
	});

	return block;
}

// (674:24) {#if val.decpoint == true}
function create_if_block_4(ctx) {
	let input;
	let input_style_value;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");
			input.value = ".";
			input.disabled = "true";
			attr_dev(input, "class", "tdFont");
			add_location(input, file, 674, 28, 22409);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(674:24) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (673:20) {#each ColsPre as val,i}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*val*/ ctx[46].decpoint == true) return create_if_block_4;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(673:20) {#each ColsPre as val,i}",
		ctx
	});

	return block;
}

// (690:16) {#if state.plus_minus == 1}
function create_if_block_3(ctx) {
	let griddedhelper0;
	let t;
	let griddedhelper1;
	let current;

	griddedhelper0 = new GriddedHelper({
			props: {
				loop: /*Cols*/ ctx[8],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "+"
			},
			$$inline: true
		});

	griddedhelper0.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	griddedhelper1 = new GriddedHelper({
			props: {
				loop: /*Cols_Minus*/ ctx[9],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element minus_point",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "-"
			},
			$$inline: true
		});

	griddedhelper1.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper0.$$.fragment);
			t = space();
			create_component(griddedhelper1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(griddedhelper1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper0_changes = {};
			if (dirty[0] & /*Cols*/ 256) griddedhelper0_changes.loop = /*Cols*/ ctx[8];
			griddedhelper0.$set(griddedhelper0_changes);
			const griddedhelper1_changes = {};
			if (dirty[0] & /*Cols_Minus*/ 512) griddedhelper1_changes.loop = /*Cols_Minus*/ ctx[9];
			griddedhelper1.$set(griddedhelper1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper0.$$.fragment, local);
			transition_in(griddedhelper1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper0.$$.fragment, local);
			transition_out(griddedhelper1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(griddedhelper1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(690:16) {#if state.plus_minus == 1}",
		ctx
	});

	return block;
}

// (711:12) {#if state.decimal_val == 1}
function create_if_block_2(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_decimal*/ ctx[7],
				class1: "tdFont points",
				className: "tdFontP text-center items_element decl_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 mb-0 myP",
				value: "."
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_decimal*/ 128) griddedhelper_changes.loop = /*Cols_decimal*/ ctx[7];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(711:12) {#if state.decimal_val == 1}",
		ctx
	});

	return block;
}

// (722:12) {#if state.slash_val == 1}
function create_if_block_1(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[6],
				class1: "tdFont points",
				className: "tdFontP text-center items_element sla_point",
				tableId: "tdFontP slash_tab",
				tableClass: "slash_tab gridded_tab mt-0",
				value: "/"
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 64) griddedhelper_changes.loop = /*Cols_slash*/ ctx[6];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(722:12) {#if state.slash_val == 1}",
		ctx
	});

	return block;
}

// (742:32) {:else}
function create_else_block(ctx) {
	let td;
	let span;
	let t_value = +/*no*/ ctx[45] + "";
	let t;
	let span_tabindex_value;
	let span_key_value;
	let span_name_value;
	let span_data_tag_value;
	let span_id_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "tabindex", span_tabindex_value = /*val*/ ctx[46].tabIndex);
			attr_dev(span, "key", span_key_value = /*val*/ ctx[46].key);
			attr_dev(span, "name", span_name_value = /*val*/ ctx[46].name);
			attr_dev(span, "data-tag", span_data_tag_value = /*val*/ ctx[46].dataTag);
			attr_dev(span, "class", "tdFontP text-center td_data algn items_element");
			attr_dev(span, "id", span_id_value = /*val*/ ctx[46].id);
			add_location(span, file, 743, 40, 25830);
			attr_dev(td, "width", "50");
			attr_dev(td, "class", "text-center");
			add_location(td, file, 742, 36, 25754);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*handleClick*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && span_tabindex_value !== (span_tabindex_value = /*val*/ ctx[46].tabIndex)) {
				attr_dev(span, "tabindex", span_tabindex_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_key_value !== (span_key_value = /*val*/ ctx[46].key)) {
				attr_dev(span, "key", span_key_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_name_value !== (span_name_value = /*val*/ ctx[46].name)) {
				attr_dev(span, "name", span_name_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_data_tag_value !== (span_data_tag_value = /*val*/ ctx[46].dataTag)) {
				attr_dev(span, "data-tag", span_data_tag_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_id_value !== (span_id_value = /*val*/ ctx[46].id)) {
				attr_dev(span, "id", span_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(742:32) {:else}",
		ctx
	});

	return block;
}

// (739:32) {#if val.decpoint}
function create_if_block(ctx) {
	let td;
	let td_key_value;

	const block = {
		c: function create() {
			td = element("td");
			attr_dev(td, "key", td_key_value = /*val*/ ctx[46].key);
			attr_dev(td, "class", "tdFont text-center");
			attr_dev(td, "width", "50");
			attr_dev(td, "disabled", "true");
			add_location(td, file, 739, 36, 25558);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && td_key_value !== (td_key_value = /*val*/ ctx[46].key)) {
				attr_dev(td, "key", td_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(739:32) {#if val.decpoint}",
		ctx
	});

	return block;
}

// (738:28) {#each totalCols as val,i}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*val*/ ctx[46].decpoint) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(738:28) {#each totalCols as val,i}",
		ctx
	});

	return block;
}

// (736:20) {#each totalRows as data,no}
function create_each_block(ctx) {
	let tr;
	let t;
	let tr_key_value;
	let each_value_1 = /*totalCols*/ ctx[5];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "key", tr_key_value = /*data*/ ctx[43].key);
			add_location(tr, file, 736, 24, 25396);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols, handleClick*/ 1056) {
				each_value_1 = /*totalCols*/ ctx[5];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*totalRows*/ 16 && tr_key_value !== (tr_key_value = /*data*/ ctx[43].key)) {
				attr_dev(tr, "key", tr_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(736:20) {#each totalRows as data,no}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let center1;
	let div;
	let center0;
	let itemhelper;
	let t0;
	let table0;
	let tr;
	let table0_style_value;
	let t1;
	let t2;
	let t3;
	let t4;
	let table1;
	let tbody;
	let current;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[13],
				reviewMode: /*isReview*/ ctx[0]
			},
			$$inline: true
		});

	let each_value_2 = /*ColsPre*/ ctx[3];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block0 = /*state*/ ctx[2].plus_minus == 1 && create_if_block_3(ctx);
	let if_block1 = /*state*/ ctx[2].decimal_val == 1 && create_if_block_2(ctx);
	let if_block2 = /*state*/ ctx[2].slash_val == 1 && create_if_block_1(ctx);
	let each_value = /*totalRows*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			main = element("main");
			center1 = element("center");
			div = element("div");
			center0 = element("center");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			table0 = element("table");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			table1 = element("table");
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(center0, file, 664, 12, 21972);
			set_style(tr, "display", "flex");
			add_location(tr, file, 671, 16, 22258);
			attr_dev(table0, "border", "1");
			attr_dev(table0, "id", "tab2");
			attr_dev(table0, "style", table0_style_value = "border-collapse:collapse;text-align:center");
			add_location(table0, file, 670, 12, 22159);
			add_location(tbody, file, 734, 16, 25315);
			attr_dev(table1, "id", "gridded_sheet");
			attr_dev(table1, "class", "gridded_tab mt-0 lastGrid create_tab myP");
			add_location(table1, file, 733, 12, 25223);
			attr_dev(div, "class", "griddedModule");
			add_location(div, file, 663, 8, 21932);
			add_location(center1, file, 662, 4, 21915);
			add_location(main, file, 661, 0, 21904);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, center1);
			append_dev(center1, div);
			append_dev(div, center0);
			mount_component(itemhelper, center0, null);
			append_dev(div, t0);
			append_dev(div, table0);
			append_dev(table0, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t4);
			append_dev(div, table1);
			append_dev(table1, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);

			if (dirty[0] & /*ColsPre, state, myAns, rowValidation*/ 4110) {
				each_value_2 = /*ColsPre*/ ctx[3];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (/*state*/ ctx[2].plus_minus == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].decimal_val == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].slash_val == 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*totalRows, totalCols, handleClick*/ 1072) {
				each_value = /*totalRows*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(itemhelper);
			destroy_each(each_blocks_1, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function highLight(event) {
	let cell_class = event.target.getAttribute("name");
	let column_index = document.getElementsByName(cell_class);

	for (let i = 1; i < column_index.length; i++) {
		if (column_index[i].classList.contains("active")) {
			column_index[i].classList.remove("active");
		}

		if (column_index[i].innerHTML == event.target.value) {
			column_index[i].classList.add("active");
		}
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GriddedPreview", slots, []);
	let { isReview } = $$props;
	let { xml } = $$props;
	let { showAns } = $$props;
	let { uxml } = $$props;
	let { editorState } = $$props;

	// Declare global variables ////
	let bool = " ";

	let userAns = [];
	let ans = [];
	let myAns = [];
	let c = 0;
	let correctInc;
	let isAnswerCorrect = "";
	let answerStatus = "";
	let authAnsSplit;
	let incorrectCls = "";

	let stateData = writable({
		rowNum: 4,
		colNum: 4,
		item: 1,
		plus_minus: 0,
		slash_val: 0,
		decimal_val: 0,
		xml: "",
		textSizeP: 0,
		correctAns: [],
		userList: [],
		isMathquill: false,
		smController: "h",
		pointerEvents: "auto",
		decimal_point: 0,
		iconVisible: "h"
	});

	let state = {};

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(2, state = items);
	});

	onMount(() => {
		// $('body').on('keydown', '.td_data', function(e) { 
		//     if (e.which === 13) {
		//         $(this).click();
		//     }
		// });
		AH.listen(document, "keydown", ".td_data", e => {
			if (e.which === 13) {
				e.click();
			}
		});

		// jQuery('#sm_controller button').click(function() {
		//     jQuery('#sm_controller button').removeClass("active btn-secondary text-white bg-secondary");
		//     jQuery(this).addClass('active btn-secondary text-white bg-secondary');
		// });
		AH.listen(document, "click", "#sm_controller button", e => {
			AH.selectAll("#sm_controller button", "removeClass", ["active,btn-secondary,text-white,bg-secondary"]);
			AH.selectAll(e, "addClass", ["active,btn-secondary,text-white,bg-secondary"]);
		});

		AH.listen(document, "click", "#set-review", function () {
			setReview();
		});

		AH.listen(document, "click", "#unset-review", function () {
			unsetReview();
		});
	});

	function loadModule(loadXml) {
		loadXml = XMLToJSON(loadXml);
		parseXMLPreview(loadXml);
	}

	function parseXMLPreview(MYXML) {
		try {
			$$invalidate(2, state.rowNum = MYXML.smxml._row, state);
			$$invalidate(2, state.colNum = MYXML.smxml._col, state);
			$$invalidate(2, state.slash_val = MYXML.smxml._slash, state);
			$$invalidate(2, state.plus_minus = MYXML.smxml._plusminus, state);
			$$invalidate(2, state.decimal_val = MYXML.smxml._decimal, state);
			$$invalidate(2, state.textSizeP = MYXML.smxml._font, state);
			$$invalidate(2, state.correctAns = MYXML.smxml._correctAns.split(","), state);
			$$invalidate(2, state.decimal_point = MYXML.smxml._fixed_point, state);

			//if (window.uaXML) {
			if (uxml) {
				let timer = setTimeout(
					function () {
						//parseUserAns(window.uaXML);
						parseUserAns(uxml);

						clearTimeout(timer);
					},
					50
				);
			}
		} catch(error) {
			onError = error;

			console.log({
				"error": error.message,
				"function name": "parseXMLPreview",
				"File name": "GriddedPreview.js"
			});
		}
	}

	function parseUserAns(uans) {
		let userAnswer = XMLToJSON(uans);

		if (userAnswer.smans && userAnswer.smans.div && userAnswer.smans.div._userAns) {
			userAns = userAnswer.smans.div._userAns.split(",");
			bool = userAnswer.smans.div._correct;

			// $("#answer").prop("checked", bool)
			ans = userAns;
		} //forceUpdate();
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(2, state.xml = xml, state);
			loadModule(xml);
		}

		//if (this.props.remedStatus != nextProps.remedStatus) {
		//} 
		//if (window.QXML) {
		if (xml) {
			console.log("qxml");
		}

		firstRowItemPre();
		decimalFloatingPre();
		slashFuncPre();
		plusMinusSignPre();
		createdSheetRowPre();
	});

	function handleClick(event) {
		//////////////changing color according to user/////////
		let cell_class = event.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.target.innerHTML;
		setUserAns(event); //////// Call function for answer checking
	}

	function setUserAns(event) {
		let countRes;
		let resNew;

		//////// This code set the answer///////////
		let attr = event.target.attributes.getNamedItem("data-tag").value;

		if (event.target.innerHTML === "") {
			userAns[attr] = event.target.value;
		} else {
			userAns[attr] = event.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == "undefined" || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = language.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = language.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = language.incorrect;
		} // return false;

		// if (!window.QXML) {
		if (editorState) {
			showAns(countRes);
		}

		AH.select("#special_module_user_xml").value = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";
		resNew = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != " " && c == user.length) {
			//jQUery("#answer").prop("checked", bool);
			AH.select("#answer", "attr", { "checked": bool });
		} else {
			//jQuery("#answer").prop("checked", isAnswerCorrect);
			AH.select("#answer", "attr", { "checked": isAnswerCorrect });
		}

		onUserAnsChange({ uXML: resNew, ans: countRes });
	}

	function handleClickCombo(event) {
		//////////////changing color according to user/////////
		let cell_class = event.detail.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.detail.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.detail.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.detail.target.innerHTML;
		setUserAnsCombo(event); //////// Call function for answer checking
	}

	function setUserAnsCombo(event) {
		let countRes;

		//////// This code set the answer///////////
		let attr = event.detail.target.attributes.getNamedItem("data-tag").value;

		if (event.detail.target.innerHTML === "") {
			userAns[attr] = event.detail.target.value;
		} else {
			userAns[attr] = event.detail.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == "undefined" || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = language.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = language.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = language.incorrect;
		} // return false;

		//if (!window.QXML) {
		if (editorState) {
			showAns(countRes);
		}

		//jQuery("#special_module_user_xml").val("<smans><div type='56' correct='"+isAnswerCorrect+"' userAns='"+state.userList+"'></div></smans>");
		AH.select("#special_module_user_xml").value = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != " " && c == user.length) {
			//jQUery("#answer").prop("checked", bool);
			AH.select("#answer", "attr", { "checked": bool });
		} else {
			//jQuery("#answer").prop("checked", isAnswerCorrect);
			AH.select("#answer", "attr", { "checked": isAnswerCorrect });
		}
	}

	function rowValidation(event) {
		let a = state.rowNum - 1;

		if (event.target.value.length > 1) {
			AH.alert("Double digit not accepted");
			event.target.value = "";
			return false;
		} else if (event.target.value < 0) {
			AH.alert("Less then 1 not accepted");
			event.target.value = "";
			return false;
		} else if (a < event.target.value) {
			AH.alert("Number insert only 0 to " + state.rowNum);
			event.target.value = "";
			return false;
		}

		setUserAns(event);
	}

	////////////////// Create very first row and store data according to click//////////
	let ColsPre = [];

	function firstRowItemPre() {
		$$invalidate(3, ColsPre = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (ans[j] === "%blank%") {
				$$invalidate(1, myAns[j] = " ", myAns);
			} else {
				$$invalidate(1, myAns[j] = ans[j], myAns);
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(3, ColsPre = [...ColsPre, { decpoint: true }]);
			} else {
				if (ColsPre.length < state.colNum) {
					$$invalidate(3, ColsPre = [
						...ColsPre,
						{
							id: "t" + j,
							dataTag: j,
							name: "p" + j,
							value: myAns[j],
							spanid: "t_" + j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	let totalRows = [];
	let totalCols = [];

	function createdSheetRowPre() {
		$$invalidate(4, totalRows = []);
		let dec_point = state.decimal_point;

		for (let i = 0; i < state.rowNum; i++) {
			$$invalidate(5, totalCols = []);

			for (let j = 0; j < state.colNum; j++) {
				if (j == dec_point - 1 && dec_point != 0) {
					$$invalidate(5, totalCols = [...totalCols, { key: "col" + i + j, decpoint: true }]);
				} else {
					if (totalCols.length < state.colNum) {
						$$invalidate(5, totalCols = [
							...totalCols,
							{
								tabIndex: 0,
								key: "col" + i + j,
								name: "p" + j,
								dataTag: j,
								id: "t" + j + "-" + i + j,
								decpoint: false
							}
						]);
					}
				}
			}

			//totalRows.push(<tr key={"row"+i}>{totalCols}</tr>);
			$$invalidate(4, totalRows = [...totalRows, { key: "row" + i }]);
		}
	}

	let Cols_slash = [];

	function slashFuncPre(event) {
		$$invalidate(6, Cols_slash = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(6, Cols_slash = [...Cols_slash, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_slash.length < state.colNum) {
					$$invalidate(6, Cols_slash = [
						...Cols_slash,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	
	let Cols_decimal = [];

	function decimalFloatingPre(event) {
		$$invalidate(7, Cols_decimal = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(7, Cols_decimal = [...Cols_decimal, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_decimal.length < state.colNum) {
					$$invalidate(7, Cols_decimal = [
						...Cols_decimal,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	///////////////// Set review and unset review function//////////////
	function setReview() {
		console.trace();
		($$invalidate(2, state.smController = "", state), $$invalidate(2, state.pointerEvents = "none", state));
		$$invalidate(0, isReview = true);
		showAnswer("yans", "showIcon");

		//jQuery('#sm_controller .your-ans').addClass("btn-light active");
		AH.selectAll("#sm_controller .your-ans", "addClass", ["btn-light", "active"]);

		//jQuery(".tokenHeader").attr("tabindex", "0");
		AH.selectAll(".tokenHeader", "attr", { "tabindex": 0 });

		//document.querySelector(".tokenHeader").setAttribute("tabindex","0");
		setTimeout(getCorrect(), 200);

		// if (!window.QXML) {
		if (editorState) {
			showAns(isAnswerCorrect ? language.correct : language.incorrect);
		}
	}

	function getCorrect() {
		for (let i = 0; i < state.correctAns.length; i++) {
			if (state.correctAns[i] == state.userList[i]) {
				//jQuery('#t_'+i).removeClass("icomoon-new-24px-cancel-circle-1").addClass("icomoon-new-24px-checkmark-circle-1");
				AH.select("#t_" + i, "removeClass", "icomoon-new-24px-cancel-circle-1");

				AH.select("#t_" + i, "addClass", "icomoon-new-24px-checkmark-circle-1");
			} else {
				//jQuery('#t_'+i).removeClass("icomoon-new-24px-checkmark-circle-1").addClass("icomoon-new-24px-cancel-circle-1");
				AH.select("#t_" + i, "removeClass", "icomoon-new-24px-checkmark-circle-1");

				AH.select("#t_" + i, "addClass", "icomoon-new-24px-cancel-circle-1");
			}
		}
	}

	function unsetReview() {
		($$invalidate(2, state.smController = "h", state), $$invalidate(2, state.pointerEvents = "auto", state));
		$$invalidate(0, isReview = false);
		showAnswer("yans", "hideIcon");

		//jQuery(".tokenHeader").removeAttr("tabindex");
		AH.selectAll(".tokenHeader", "removeAttr", "tabindex");
	}

	function showAnswer(val, iconState) {
		//show correct incorrect icon with respect to iconState
		if (iconState == "showIcon") {
			$$invalidate(2, state.iconVisible = "", state);
		} else {
			$$invalidate(2, state.iconVisible = "h", state);
		}

		if (val == "cans") {
			let ele = document.getElementsByClassName("gridded_tab");
			ele.disabled = true;
			ans = state.correctAns;
		} else if (val == "yans") {
			ans = userAns;
		}
	}

	///////////////////////////// create plus and minus row//////////////////
	let Cols = [];

	let Cols_Minus = [];

	function plusMinusSignPre(event) {
		$$invalidate(8, Cols = []);
		$$invalidate(9, Cols_Minus = []);
		let dec_point = state.decimal_point;

		//let arr = [];
		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(8, Cols = [
					...Cols,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols.length < state.colNum) {
					$$invalidate(8, Cols = [
						...Cols,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(9, Cols_Minus = [
					...Cols_Minus,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols_Minus.length < state.colNum) {
					$$invalidate(9, Cols_Minus = [
						...Cols_Minus,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	function handleReview(mode) {
		if (mode == "c") {
			showAnswer("cans", "hideIcon");
		} else {
			showAnswer("yans", "showIcon");
		}
	}

	const writable_props = ["isReview", "xml", "showAns", "uxml", "editorState"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<GriddedPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
		if ("showAns" in $$props) $$invalidate(15, showAns = $$props.showAns);
		if ("uxml" in $$props) $$invalidate(16, uxml = $$props.uxml);
		if ("editorState" in $$props) $$invalidate(17, editorState = $$props.editorState);
	};

	$$self.$capture_state = () => ({
		l: language,
		ItemHelper,
		writable,
		AH,
		XMLToJSON,
		JSONToXML,
		onUserAnsChange,
		afterUpdate,
		beforeUpdate,
		onMount,
		GriddedHelper,
		isReview,
		xml,
		showAns,
		uxml,
		editorState,
		bool,
		userAns,
		ans,
		myAns,
		c,
		correctInc,
		isAnswerCorrect,
		answerStatus,
		authAnsSplit,
		incorrectCls,
		stateData,
		state,
		unsubscribe,
		loadModule,
		parseXMLPreview,
		parseUserAns,
		handleClick,
		setUserAns,
		handleClickCombo,
		setUserAnsCombo,
		rowValidation,
		highLight,
		ColsPre,
		firstRowItemPre,
		totalRows,
		totalCols,
		createdSheetRowPre,
		Cols_slash,
		slashFuncPre,
		Cols_decimal,
		decimalFloatingPre,
		setReview,
		getCorrect,
		unsetReview,
		showAnswer,
		Cols,
		Cols_Minus,
		plusMinusSignPre,
		handleReview
	});

	$$self.$inject_state = $$props => {
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
		if ("showAns" in $$props) $$invalidate(15, showAns = $$props.showAns);
		if ("uxml" in $$props) $$invalidate(16, uxml = $$props.uxml);
		if ("editorState" in $$props) $$invalidate(17, editorState = $$props.editorState);
		if ("bool" in $$props) bool = $$props.bool;
		if ("userAns" in $$props) userAns = $$props.userAns;
		if ("ans" in $$props) ans = $$props.ans;
		if ("myAns" in $$props) $$invalidate(1, myAns = $$props.myAns);
		if ("c" in $$props) c = $$props.c;
		if ("correctInc" in $$props) correctInc = $$props.correctInc;
		if ("isAnswerCorrect" in $$props) isAnswerCorrect = $$props.isAnswerCorrect;
		if ("answerStatus" in $$props) answerStatus = $$props.answerStatus;
		if ("authAnsSplit" in $$props) authAnsSplit = $$props.authAnsSplit;
		if ("incorrectCls" in $$props) incorrectCls = $$props.incorrectCls;
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
		if ("ColsPre" in $$props) $$invalidate(3, ColsPre = $$props.ColsPre);
		if ("totalRows" in $$props) $$invalidate(4, totalRows = $$props.totalRows);
		if ("totalCols" in $$props) $$invalidate(5, totalCols = $$props.totalCols);
		if ("Cols_slash" in $$props) $$invalidate(6, Cols_slash = $$props.Cols_slash);
		if ("Cols_decimal" in $$props) $$invalidate(7, Cols_decimal = $$props.Cols_decimal);
		if ("Cols" in $$props) $$invalidate(8, Cols = $$props.Cols);
		if ("Cols_Minus" in $$props) $$invalidate(9, Cols_Minus = $$props.Cols_Minus);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isReview*/ 1) {
			 {
				if (isReview) {
					setReview();
				} else {
					unsetReview(); // this.checkAns();
				}
			}
		}
	};

	return [
		isReview,
		myAns,
		state,
		ColsPre,
		totalRows,
		totalCols,
		Cols_slash,
		Cols_decimal,
		Cols,
		Cols_Minus,
		handleClick,
		handleClickCombo,
		rowValidation,
		handleReview,
		xml,
		showAns,
		uxml,
		editorState
	];
}

class GriddedPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-vscbpc-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				isReview: 0,
				xml: 14,
				showAns: 15,
				uxml: 16,
				editorState: 17
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GriddedPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isReview*/ ctx[0] === undefined && !("isReview" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'isReview'");
		}

		if (/*xml*/ ctx[14] === undefined && !("xml" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'xml'");
		}

		if (/*showAns*/ ctx[15] === undefined && !("showAns" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'showAns'");
		}

		if (/*uxml*/ ctx[16] === undefined && !("uxml" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'uxml'");
		}

		if (/*editorState*/ ctx[17] === undefined && !("editorState" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'editorState'");
		}
	}

	get isReview() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showAns() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default GriddedPreview;
//# sourceMappingURL=GriddedPreview-0d0bff71.js.map
