
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, a0 as createEventDispatcher, z as empty, n as insert_dev, B as noop, x as detach_dev, e as element, h as text, f as space, j as attr_dev, k as add_location, p as append_dev, q as listen_dev, F as set_data_dev, G as prop_dev, H as run_all, C as validate_each_argument, y as language, o as onMount, X as XMLToJSON, w as writable, A as AH, M as JSONToXML, c as create_component, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, r as group_outros, u as check_outros, K as destroy_each } from './main-4ecd610a.js';

/* clsSMSlider\inputItem.svelte generated by Svelte v3.29.0 */
const file = "clsSMSlider\\inputItem.svelte";

// (42:0) {:else}
function create_else_block(ctx) {
	let div;
	let label_1;
	let t0;
	let t1;
	let input;
	let input_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			label_1 = element("label");
			t0 = text(/*label*/ ctx[0]);
			t1 = space();
			input = element("input");
			attr_dev(label_1, "for", /*id*/ ctx[3]);
			attr_dev(label_1, "class", "pr-1 mb-0");
			add_location(label_1, file, 43, 4, 1406);
			attr_dev(input, "class", input_class_value = "sm_input_text sm-num " + /*classVal*/ ctx[1] + " mt-0");
			attr_dev(input, "type", "number");
			attr_dev(input, "name", /*name*/ ctx[2]);
			attr_dev(input, "id", /*id*/ ctx[3]);
			input.value = /*value*/ ctx[4];
			attr_dev(input, "min", /*min*/ ctx[5]);
			attr_dev(input, "max", /*max*/ ctx[6]);
			input.disabled = /*disabledValue*/ ctx[8];
			add_location(input, file, 44, 4, 1462);
			attr_dev(div, "class", "float-start mb-2 pr-2 width100");
			add_location(div, file, 42, 0, 1356);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, label_1);
			append_dev(label_1, t0);
			append_dev(div, t1);
			append_dev(div, input);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*change_handler_1*/ ctx[18], false, false, false),
					listen_dev(input, "blur", /*blur_handler*/ ctx[19], false, false, false),
					listen_dev(input, "keypress", preventNonNumericalInput, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data_dev(t0, /*label*/ ctx[0]);

			if (dirty & /*id*/ 8) {
				attr_dev(label_1, "for", /*id*/ ctx[3]);
			}

			if (dirty & /*classVal*/ 2 && input_class_value !== (input_class_value = "sm_input_text sm-num " + /*classVal*/ ctx[1] + " mt-0")) {
				attr_dev(input, "class", input_class_value);
			}

			if (dirty & /*name*/ 4) {
				attr_dev(input, "name", /*name*/ ctx[2]);
			}

			if (dirty & /*id*/ 8) {
				attr_dev(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*value*/ 16) {
				prop_dev(input, "value", /*value*/ ctx[4]);
			}

			if (dirty & /*min*/ 32) {
				attr_dev(input, "min", /*min*/ ctx[5]);
			}

			if (dirty & /*max*/ 64) {
				attr_dev(input, "max", /*max*/ ctx[6]);
			}

			if (dirty & /*disabledValue*/ 256) {
				prop_dev(input, "disabled", /*disabledValue*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(42:0) {:else}",
		ctx
	});

	return block;
}

// (27:26) 
function create_if_block_1(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "id", /*id*/ ctx[3]);
			attr_dev(input, "type", "range");
			attr_dev(input, "name", "sliderrange");
			attr_dev(input, "defaultvalue", /*defaultValue*/ ctx[13]);
			attr_dev(input, "min", /*min*/ ctx[5]);
			attr_dev(input, "max", /*max*/ ctx[6]);
			attr_dev(input, "step", /*step*/ ctx[14]);
			attr_dev(input, "class", "slideritem");
			attr_dev(input, "aria-label", "Range");
			input.value = /*value*/ ctx[4];
			input.disabled = /*disabledValue*/ ctx[8];
			add_location(input, file, 27, 4, 961);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_handler*/ ctx[17], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*id*/ 8) {
				attr_dev(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*defaultValue*/ 8192) {
				attr_dev(input, "defaultvalue", /*defaultValue*/ ctx[13]);
			}

			if (dirty & /*min*/ 32) {
				attr_dev(input, "min", /*min*/ ctx[5]);
			}

			if (dirty & /*max*/ 64) {
				attr_dev(input, "max", /*max*/ ctx[6]);
			}

			if (dirty & /*step*/ 16384) {
				attr_dev(input, "step", /*step*/ ctx[14]);
			}

			if (dirty & /*value*/ 16) {
				prop_dev(input, "value", /*value*/ ctx[4]);
			}

			if (dirty & /*disabledValue*/ 256) {
				prop_dev(input, "disabled", /*disabledValue*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(27:26) ",
		ctx
	});

	return block;
}

// (16:0) {#if inputText == 1}
function create_if_block(ctx) {
	let input;
	let input_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "id", /*id*/ ctx[3]);
			attr_dev(input, "type", "text");
			attr_dev(input, "name", "slider_title");
			attr_dev(input, "class", input_class_value = "sm_input_text slidertitle mb-3 form-control " + /*classVal*/ ctx[1]);
			input.value = /*value*/ ctx[4];
			attr_dev(input, "aria-label", "Title");
			attr_dev(input, "placeholder", "Title");
			add_location(input, file, 16, 4, 599);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*change_handler*/ ctx[16], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*id*/ 8) {
				attr_dev(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*classVal*/ 2 && input_class_value !== (input_class_value = "sm_input_text slidertitle mb-3 form-control " + /*classVal*/ ctx[1])) {
				attr_dev(input, "class", input_class_value);
			}

			if (dirty & /*value*/ 16 && input.value !== /*value*/ ctx[4]) {
				prop_dev(input, "value", /*value*/ ctx[4]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(16:0) {#if inputText == 1}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*inputText*/ ctx[11] == 1) return create_if_block;
		if (/*inputRange*/ ctx[12] == 1) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function preventNonNumericalInput(e) {
	e = e || window.event;
	var charCode = typeof e.which == "undefined" ? e.keyCode : e.which;
	var charStr = String.fromCharCode(charCode);

	if (!charStr.match(/^[0-9]+$/)) {
		e.preventDefault();
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("InputItem", slots, []);

	let { label } = $$props,
		{ classVal } = $$props,
		{ name } = $$props,
		{ id } = $$props,
		{ value } = $$props,
		{ min } = $$props,
		{ max } = $$props,
		{ key } = $$props,
		{ disabledValue } = $$props,
		{ funcChange } = $$props,
		{ funcBlur } = $$props,
		{ inputText } = $$props,
		{ inputRange } = $$props,
		{ defaultValue } = $$props,
		{ step } = $$props;

	const dispatch = createEventDispatcher();

	const writable_props = [
		"label",
		"classVal",
		"name",
		"id",
		"value",
		"min",
		"max",
		"key",
		"disabledValue",
		"funcChange",
		"funcBlur",
		"inputText",
		"inputRange",
		"defaultValue",
		"step"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InputItem> was created with unknown prop '${key}'`);
	});

	const change_handler = e => dispatch("updateXmlValue", { index: key, func: funcChange, value: e });
	const input_handler = e => dispatch("updateXmlValue", { index: key, func: funcChange, value: e });
	const change_handler_1 = e => dispatch("updateXmlValue", { index: key, func: funcChange, value: e });
	const blur_handler = e => dispatch("updateXmlValue", { index: key, func: funcBlur, value: e });

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("classVal" in $$props) $$invalidate(1, classVal = $$props.classVal);
		if ("name" in $$props) $$invalidate(2, name = $$props.name);
		if ("id" in $$props) $$invalidate(3, id = $$props.id);
		if ("value" in $$props) $$invalidate(4, value = $$props.value);
		if ("min" in $$props) $$invalidate(5, min = $$props.min);
		if ("max" in $$props) $$invalidate(6, max = $$props.max);
		if ("key" in $$props) $$invalidate(7, key = $$props.key);
		if ("disabledValue" in $$props) $$invalidate(8, disabledValue = $$props.disabledValue);
		if ("funcChange" in $$props) $$invalidate(9, funcChange = $$props.funcChange);
		if ("funcBlur" in $$props) $$invalidate(10, funcBlur = $$props.funcBlur);
		if ("inputText" in $$props) $$invalidate(11, inputText = $$props.inputText);
		if ("inputRange" in $$props) $$invalidate(12, inputRange = $$props.inputRange);
		if ("defaultValue" in $$props) $$invalidate(13, defaultValue = $$props.defaultValue);
		if ("step" in $$props) $$invalidate(14, step = $$props.step);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		label,
		classVal,
		name,
		id,
		value,
		min,
		max,
		key,
		disabledValue,
		funcChange,
		funcBlur,
		inputText,
		inputRange,
		defaultValue,
		step,
		dispatch,
		preventNonNumericalInput
	});

	$$self.$inject_state = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("classVal" in $$props) $$invalidate(1, classVal = $$props.classVal);
		if ("name" in $$props) $$invalidate(2, name = $$props.name);
		if ("id" in $$props) $$invalidate(3, id = $$props.id);
		if ("value" in $$props) $$invalidate(4, value = $$props.value);
		if ("min" in $$props) $$invalidate(5, min = $$props.min);
		if ("max" in $$props) $$invalidate(6, max = $$props.max);
		if ("key" in $$props) $$invalidate(7, key = $$props.key);
		if ("disabledValue" in $$props) $$invalidate(8, disabledValue = $$props.disabledValue);
		if ("funcChange" in $$props) $$invalidate(9, funcChange = $$props.funcChange);
		if ("funcBlur" in $$props) $$invalidate(10, funcBlur = $$props.funcBlur);
		if ("inputText" in $$props) $$invalidate(11, inputText = $$props.inputText);
		if ("inputRange" in $$props) $$invalidate(12, inputRange = $$props.inputRange);
		if ("defaultValue" in $$props) $$invalidate(13, defaultValue = $$props.defaultValue);
		if ("step" in $$props) $$invalidate(14, step = $$props.step);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		label,
		classVal,
		name,
		id,
		value,
		min,
		max,
		key,
		disabledValue,
		funcChange,
		funcBlur,
		inputText,
		inputRange,
		defaultValue,
		step,
		dispatch,
		change_handler,
		input_handler,
		change_handler_1,
		blur_handler
	];
}

class InputItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			label: 0,
			classVal: 1,
			name: 2,
			id: 3,
			value: 4,
			min: 5,
			max: 6,
			key: 7,
			disabledValue: 8,
			funcChange: 9,
			funcBlur: 10,
			inputText: 11,
			inputRange: 12,
			defaultValue: 13,
			step: 14
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InputItem",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
			console.warn("<InputItem> was created without expected prop 'label'");
		}

		if (/*classVal*/ ctx[1] === undefined && !("classVal" in props)) {
			console.warn("<InputItem> was created without expected prop 'classVal'");
		}

		if (/*name*/ ctx[2] === undefined && !("name" in props)) {
			console.warn("<InputItem> was created without expected prop 'name'");
		}

		if (/*id*/ ctx[3] === undefined && !("id" in props)) {
			console.warn("<InputItem> was created without expected prop 'id'");
		}

		if (/*value*/ ctx[4] === undefined && !("value" in props)) {
			console.warn("<InputItem> was created without expected prop 'value'");
		}

		if (/*min*/ ctx[5] === undefined && !("min" in props)) {
			console.warn("<InputItem> was created without expected prop 'min'");
		}

		if (/*max*/ ctx[6] === undefined && !("max" in props)) {
			console.warn("<InputItem> was created without expected prop 'max'");
		}

		if (/*key*/ ctx[7] === undefined && !("key" in props)) {
			console.warn("<InputItem> was created without expected prop 'key'");
		}

		if (/*disabledValue*/ ctx[8] === undefined && !("disabledValue" in props)) {
			console.warn("<InputItem> was created without expected prop 'disabledValue'");
		}

		if (/*funcChange*/ ctx[9] === undefined && !("funcChange" in props)) {
			console.warn("<InputItem> was created without expected prop 'funcChange'");
		}

		if (/*funcBlur*/ ctx[10] === undefined && !("funcBlur" in props)) {
			console.warn("<InputItem> was created without expected prop 'funcBlur'");
		}

		if (/*inputText*/ ctx[11] === undefined && !("inputText" in props)) {
			console.warn("<InputItem> was created without expected prop 'inputText'");
		}

		if (/*inputRange*/ ctx[12] === undefined && !("inputRange" in props)) {
			console.warn("<InputItem> was created without expected prop 'inputRange'");
		}

		if (/*defaultValue*/ ctx[13] === undefined && !("defaultValue" in props)) {
			console.warn("<InputItem> was created without expected prop 'defaultValue'");
		}

		if (/*step*/ ctx[14] === undefined && !("step" in props)) {
			console.warn("<InputItem> was created without expected prop 'step'");
		}
	}

	get label() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get classVal() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classVal(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get key() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabledValue() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabledValue(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get funcChange() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set funcChange(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get funcBlur() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set funcBlur(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputText() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputText(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputRange() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputRange(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultValue() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultValue(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<InputItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<InputItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMSlider\SliderButton.svelte generated by Svelte v3.29.0 */
const file$1 = "clsSMSlider\\SliderButton.svelte";

// (14:8) {#if modalbtn != 1}
function create_if_block$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = space();
			attr_dev(span, "class", "icomoon-new-24px-add-circle-1 s3 me-1");
			add_location(span, file$1, 13, 27, 473);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(14:8) {#if modalbtn != 1}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let button;
	let span;
	let t;
	let mounted;
	let dispose;
	let if_block = /*modalbtn*/ ctx[5] != 1 && create_if_block$1(ctx);

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			if (if_block) if_block.c();
			t = text(/*buttonName*/ ctx[2]);
			attr_dev(span, "class", "d-flex align-items-center");
			add_location(span, file$1, 12, 4, 404);
			attr_dev(button, "type", "button");
			attr_dev(button, "id", /*id*/ ctx[4]);
			attr_dev(button, "class", /*classVal*/ ctx[0]);
			button.disabled = /*disabledValue*/ ctx[3];
			add_location(button, file$1, 5, 0, 213);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);
			if (if_block) if_block.m(span, null);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[8], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*modalbtn*/ ctx[5] != 1) {
				if (if_block) ; else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*buttonName*/ 4) set_data_dev(t, /*buttonName*/ ctx[2]);

			if (dirty & /*id*/ 16) {
				attr_dev(button, "id", /*id*/ ctx[4]);
			}

			if (dirty & /*classVal*/ 1) {
				attr_dev(button, "class", /*classVal*/ ctx[0]);
			}

			if (dirty & /*disabledValue*/ 8) {
				prop_dev(button, "disabled", /*disabledValue*/ ctx[3]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SliderButton", slots, []);

	let { classVal } = $$props,
		{ funcClick } = $$props,
		{ buttonName } = $$props,
		{ disabledValue = false } = $$props,
		{ id } = $$props,
		{ modalbtn } = $$props,
		{ key = "" } = $$props;

	const dispatch = createEventDispatcher();

	const writable_props = [
		"classVal",
		"funcClick",
		"buttonName",
		"disabledValue",
		"id",
		"modalbtn",
		"key"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliderButton> was created with unknown prop '${key}'`);
	});

	const click_handler = e => dispatch("updateXmlValue", { index: key, func: funcClick, value: e });

	$$self.$$set = $$props => {
		if ("classVal" in $$props) $$invalidate(0, classVal = $$props.classVal);
		if ("funcClick" in $$props) $$invalidate(1, funcClick = $$props.funcClick);
		if ("buttonName" in $$props) $$invalidate(2, buttonName = $$props.buttonName);
		if ("disabledValue" in $$props) $$invalidate(3, disabledValue = $$props.disabledValue);
		if ("id" in $$props) $$invalidate(4, id = $$props.id);
		if ("modalbtn" in $$props) $$invalidate(5, modalbtn = $$props.modalbtn);
		if ("key" in $$props) $$invalidate(6, key = $$props.key);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classVal,
		funcClick,
		buttonName,
		disabledValue,
		id,
		modalbtn,
		key,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ("classVal" in $$props) $$invalidate(0, classVal = $$props.classVal);
		if ("funcClick" in $$props) $$invalidate(1, funcClick = $$props.funcClick);
		if ("buttonName" in $$props) $$invalidate(2, buttonName = $$props.buttonName);
		if ("disabledValue" in $$props) $$invalidate(3, disabledValue = $$props.disabledValue);
		if ("id" in $$props) $$invalidate(4, id = $$props.id);
		if ("modalbtn" in $$props) $$invalidate(5, modalbtn = $$props.modalbtn);
		if ("key" in $$props) $$invalidate(6, key = $$props.key);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		classVal,
		funcClick,
		buttonName,
		disabledValue,
		id,
		modalbtn,
		key,
		dispatch,
		click_handler
	];
}

class SliderButton extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			classVal: 0,
			funcClick: 1,
			buttonName: 2,
			disabledValue: 3,
			id: 4,
			modalbtn: 5,
			key: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SliderButton",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*classVal*/ ctx[0] === undefined && !("classVal" in props)) {
			console.warn("<SliderButton> was created without expected prop 'classVal'");
		}

		if (/*funcClick*/ ctx[1] === undefined && !("funcClick" in props)) {
			console.warn("<SliderButton> was created without expected prop 'funcClick'");
		}

		if (/*buttonName*/ ctx[2] === undefined && !("buttonName" in props)) {
			console.warn("<SliderButton> was created without expected prop 'buttonName'");
		}

		if (/*id*/ ctx[4] === undefined && !("id" in props)) {
			console.warn("<SliderButton> was created without expected prop 'id'");
		}

		if (/*modalbtn*/ ctx[5] === undefined && !("modalbtn" in props)) {
			console.warn("<SliderButton> was created without expected prop 'modalbtn'");
		}
	}

	get classVal() {
		throw new Error("<SliderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classVal(value) {
		throw new Error("<SliderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get funcClick() {
		throw new Error("<SliderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set funcClick(value) {
		throw new Error("<SliderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonName() {
		throw new Error("<SliderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonName(value) {
		throw new Error("<SliderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabledValue() {
		throw new Error("<SliderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabledValue(value) {
		throw new Error("<SliderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<SliderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<SliderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get modalbtn() {
		throw new Error("<SliderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set modalbtn(value) {
		throw new Error("<SliderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get key() {
		throw new Error("<SliderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<SliderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMSlider\SliderItem.svelte generated by Svelte v3.29.0 */
const file$2 = "clsSMSlider\\SliderItem.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[15] = i;
	return child_ctx;
}

// (253:8) {#each localSliderData as data, i}
function create_each_block(ctx) {
	let div5;
	let div0;
	let span0;
	let t0_value = /*i*/ ctx[15] + 1 + "";
	let t0;
	let t1;
	let span1;
	let span1_class_value;
	let span1_id_value;
	let t2;
	let div4;
	let inputitem0;
	let t3;
	let inputitem1;
	let t4;
	let div3;
	let inputitem2;
	let t5;
	let inputitem3;
	let t6;
	let inputitem4;
	let t7;
	let inputitem5;
	let t8;
	let div2;
	let label;
	let t9_value = language.correct + "";
	let t9;
	let label_for_value;
	let t10;
	let div1;
	let output;
	let t11_value = /*data*/ ctx[13].anskey + "";
	let t11;
	let output_for_value;
	let output_id_value;
	let t12;
	let input;
	let input_name_value;
	let input_id_value;
	let t13;
	let div5_key_value;
	let current;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[7](/*i*/ ctx[15], ...args);
	}

	inputitem0 = new InputItem({
			props: {
				classVal: /*isValidationOK*/ ctx[1] ? "" : "cursor_not_allowed",
				id: /*data*/ ctx[13].title_id,
				value: /*data*/ ctx[13].title_val,
				key: /*i*/ ctx[15],
				funcChange: "setTitle",
				inputText: "1"
			},
			$$inline: true
		});

	inputitem0.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	inputitem1 = new InputItem({
			props: {
				classVal: /*isValidationOK*/ ctx[1] ? "" : "cursor_not_allowed",
				id: /*data*/ ctx[13].sliderid1,
				value: /*data*/ ctx[13].anskey,
				defaultValue: /*data*/ ctx[13].defaultans,
				key: /*i*/ ctx[15],
				step: /*data*/ ctx[13].step_val,
				funcChange: "setAnswer",
				min: /*data*/ ctx[13].minval,
				max: /*data*/ ctx[13].maxval,
				inputRange: "1",
				disabledValue: /*isValidationOK*/ ctx[1] ? "" : true
			},
			$$inline: true
		});

	inputitem1.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	inputitem2 = new InputItem({
			props: {
				label: language.min_val,
				classVal: "slidermin",
				name: "minval",
				id: /*data*/ ctx[13].minid,
				value: /*data*/ ctx[13].minval,
				min: 0,
				max: 999,
				key: /*i*/ ctx[15],
				funcChange: "setMin",
				funcBlur: "setMinOnBlur",
				disabledValue: /*target_id*/ ctx[2].indexOf("minID") < 0 && /*target_id*/ ctx[2] != ""
				? "disabled"
				: /*target_id*/ ctx[2] != /*data*/ ctx[13].defaultans_id && /*target_id*/ ctx[2] != ""
					? "disabled"
					: false
			},
			$$inline: true
		});

	inputitem2.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	inputitem3 = new InputItem({
			props: {
				label: language.max_val,
				classVal: "slidermax",
				name: "maxval",
				id: /*data*/ ctx[13].maxid,
				value: /*data*/ ctx[13].maxval,
				min: /*data*/ ctx[13].minval,
				max: 999,
				key: /*i*/ ctx[15],
				funcChange: "setMax",
				funcBlur: "setMaxOnBlur",
				disabledValue: /*target_id*/ ctx[2].indexOf("maxID") < 0 && /*target_id*/ ctx[2] != ""
				? "disabled"
				: /*target_id*/ ctx[2] != /*data*/ ctx[13].defaultans_id && /*target_id*/ ctx[2] != ""
					? "disabled"
					: false
			},
			$$inline: true
		});

	inputitem3.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	inputitem4 = new InputItem({
			props: {
				label: language.default,
				classVal: "sliderdefaultans",
				name: "defaultans",
				id: /*data*/ ctx[13].defaultans_id,
				value: /*data*/ ctx[13].defaultans,
				min: /*data*/ ctx[13].minval,
				max: /*data*/ ctx[13].maxval,
				key: /*i*/ ctx[15],
				funcChange: "setDefault",
				funcBlur: "setDefaultOnBlur",
				disabledValue: /*target_id*/ ctx[2].indexOf("defaultansID") < 0 && /*target_id*/ ctx[2] != ""
				? "disabled"
				: /*target_id*/ ctx[2] != /*data*/ ctx[13].defaultans_id && /*target_id*/ ctx[2] != ""
					? "disabled"
					: false
			},
			$$inline: true
		});

	inputitem4.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	inputitem5 = new InputItem({
			props: {
				label: language.step,
				classVal: "sliderstep",
				name: "stepval",
				id: /*data*/ ctx[13].step_id,
				value: /*data*/ ctx[13].step_val,
				min: "0",
				max: "5",
				key: /*i*/ ctx[15],
				funcChange: "setStep",
				funcBlur: "setDefaultOnBlur",
				disabledValue: /*isValidationOK*/ ctx[1] ? false : true
			},
			$$inline: true
		});

	inputitem5.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	const block = {
		c: function create() {
			div5 = element("div");
			div0 = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			span1 = element("span");
			t2 = space();
			div4 = element("div");
			create_component(inputitem0.$$.fragment);
			t3 = space();
			create_component(inputitem1.$$.fragment);
			t4 = space();
			div3 = element("div");
			create_component(inputitem2.$$.fragment);
			t5 = space();
			create_component(inputitem3.$$.fragment);
			t6 = space();
			create_component(inputitem4.$$.fragment);
			t7 = space();
			create_component(inputitem5.$$.fragment);
			t8 = space();
			div2 = element("div");
			label = element("label");
			t9 = text(t9_value);
			t10 = space();
			div1 = element("div");
			output = element("output");
			t11 = text(t11_value);
			t12 = space();
			input = element("input");
			t13 = space();
			attr_dev(span0, "class", "slider_title float-start ml-3");
			add_location(span0, file$2, 255, 20, 13254);
			attr_dev(span1, "class", span1_class_value = "removeitem icomoon-24px-delete-1 height21 float-end " + (/*isValidationOK*/ ctx[1] ? "" : "pointer_event_none"));
			attr_dev(span1, "id", span1_id_value = /*data*/ ctx[13].remove_item);
			attr_dev(span1, "tabindex", "0");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "title", "Delete item");
			add_location(span1, file$2, 256, 20, 13335);
			attr_dev(div0, "class", "slider_heading pt-sm text-white font-weight-bold bg-primary");
			add_location(div0, file$2, 254, 16, 13159);
			attr_dev(label, "for", label_for_value = /*data*/ ctx[13].sliderop);
			attr_dev(label, "class", "pr-4 me-3 mb-0");
			add_location(label, file$2, 348, 28, 18252);
			attr_dev(output, "for", output_for_value = /*data*/ ctx[13].sliderid);
			attr_dev(output, "id", output_id_value = /*data*/ ctx[13].sliderop);
			attr_dev(output, "class", "slideropt position-relative");
			add_location(output, file$2, 350, 32, 18428);
			attr_dev(div1, "class", "slideroutput mt-0 text-center");
			add_location(div1, file$2, 349, 28, 18351);
			attr_dev(div2, "class", "float-start mb-2 pr-2 width100");
			add_location(div2, file$2, 347, 24, 18178);
			attr_dev(div3, "class", "clear-both mt-2");
			add_location(div3, file$2, 290, 20, 15034);
			attr_dev(input, "type", "hidden");
			attr_dev(input, "name", input_name_value = /*data*/ ctx[13].sliderans);
			attr_dev(input, "id", input_id_value = /*data*/ ctx[13].sliderans);
			attr_dev(input, "class", "sliderans");
			add_location(input, file$2, 360, 20, 18868);
			attr_dev(div4, "class", "col-md-12 select_slider pt-4 px-3 pb-2");
			add_location(div4, file$2, 266, 16, 13874);
			attr_dev(div5, "key", div5_key_value = /*i*/ ctx[15]);
			attr_dev(div5, "class", "clearfix slider_container shadow-sm slider_container mb-3 rounded");
			add_location(div5, file$2, 253, 12, 13054);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div0);
			append_dev(div0, span0);
			append_dev(span0, t0);
			append_dev(div0, t1);
			append_dev(div0, span1);
			append_dev(div5, t2);
			append_dev(div5, div4);
			mount_component(inputitem0, div4, null);
			append_dev(div4, t3);
			mount_component(inputitem1, div4, null);
			append_dev(div4, t4);
			append_dev(div4, div3);
			mount_component(inputitem2, div3, null);
			append_dev(div3, t5);
			mount_component(inputitem3, div3, null);
			append_dev(div3, t6);
			mount_component(inputitem4, div3, null);
			append_dev(div3, t7);
			mount_component(inputitem5, div3, null);
			append_dev(div3, t8);
			append_dev(div3, div2);
			append_dev(div2, label);
			append_dev(label, t9);
			append_dev(div2, t10);
			append_dev(div2, div1);
			append_dev(div1, output);
			append_dev(output, t11);
			append_dev(div4, t12);
			append_dev(div4, input);
			append_dev(div5, t13);
			current = true;

			if (!mounted) {
				dispose = listen_dev(span1, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty & /*isValidationOK*/ 2 && span1_class_value !== (span1_class_value = "removeitem icomoon-24px-delete-1 height21 float-end " + (/*isValidationOK*/ ctx[1] ? "" : "pointer_event_none"))) {
				attr_dev(span1, "class", span1_class_value);
			}

			if (!current || dirty & /*localSliderData*/ 1 && span1_id_value !== (span1_id_value = /*data*/ ctx[13].remove_item)) {
				attr_dev(span1, "id", span1_id_value);
			}

			const inputitem0_changes = {};
			if (dirty & /*isValidationOK*/ 2) inputitem0_changes.classVal = /*isValidationOK*/ ctx[1] ? "" : "cursor_not_allowed";
			if (dirty & /*localSliderData*/ 1) inputitem0_changes.id = /*data*/ ctx[13].title_id;
			if (dirty & /*localSliderData*/ 1) inputitem0_changes.value = /*data*/ ctx[13].title_val;
			inputitem0.$set(inputitem0_changes);
			const inputitem1_changes = {};
			if (dirty & /*isValidationOK*/ 2) inputitem1_changes.classVal = /*isValidationOK*/ ctx[1] ? "" : "cursor_not_allowed";
			if (dirty & /*localSliderData*/ 1) inputitem1_changes.id = /*data*/ ctx[13].sliderid1;
			if (dirty & /*localSliderData*/ 1) inputitem1_changes.value = /*data*/ ctx[13].anskey;
			if (dirty & /*localSliderData*/ 1) inputitem1_changes.defaultValue = /*data*/ ctx[13].defaultans;
			if (dirty & /*localSliderData*/ 1) inputitem1_changes.step = /*data*/ ctx[13].step_val;
			if (dirty & /*localSliderData*/ 1) inputitem1_changes.min = /*data*/ ctx[13].minval;
			if (dirty & /*localSliderData*/ 1) inputitem1_changes.max = /*data*/ ctx[13].maxval;
			if (dirty & /*isValidationOK*/ 2) inputitem1_changes.disabledValue = /*isValidationOK*/ ctx[1] ? "" : true;
			inputitem1.$set(inputitem1_changes);
			const inputitem2_changes = {};
			if (dirty & /*localSliderData*/ 1) inputitem2_changes.id = /*data*/ ctx[13].minid;
			if (dirty & /*localSliderData*/ 1) inputitem2_changes.value = /*data*/ ctx[13].minval;

			if (dirty & /*target_id, localSliderData*/ 5) inputitem2_changes.disabledValue = /*target_id*/ ctx[2].indexOf("minID") < 0 && /*target_id*/ ctx[2] != ""
			? "disabled"
			: /*target_id*/ ctx[2] != /*data*/ ctx[13].defaultans_id && /*target_id*/ ctx[2] != ""
				? "disabled"
				: false;

			inputitem2.$set(inputitem2_changes);
			const inputitem3_changes = {};
			if (dirty & /*localSliderData*/ 1) inputitem3_changes.id = /*data*/ ctx[13].maxid;
			if (dirty & /*localSliderData*/ 1) inputitem3_changes.value = /*data*/ ctx[13].maxval;
			if (dirty & /*localSliderData*/ 1) inputitem3_changes.min = /*data*/ ctx[13].minval;

			if (dirty & /*target_id, localSliderData*/ 5) inputitem3_changes.disabledValue = /*target_id*/ ctx[2].indexOf("maxID") < 0 && /*target_id*/ ctx[2] != ""
			? "disabled"
			: /*target_id*/ ctx[2] != /*data*/ ctx[13].defaultans_id && /*target_id*/ ctx[2] != ""
				? "disabled"
				: false;

			inputitem3.$set(inputitem3_changes);
			const inputitem4_changes = {};
			if (dirty & /*localSliderData*/ 1) inputitem4_changes.id = /*data*/ ctx[13].defaultans_id;
			if (dirty & /*localSliderData*/ 1) inputitem4_changes.value = /*data*/ ctx[13].defaultans;
			if (dirty & /*localSliderData*/ 1) inputitem4_changes.min = /*data*/ ctx[13].minval;
			if (dirty & /*localSliderData*/ 1) inputitem4_changes.max = /*data*/ ctx[13].maxval;

			if (dirty & /*target_id, localSliderData*/ 5) inputitem4_changes.disabledValue = /*target_id*/ ctx[2].indexOf("defaultansID") < 0 && /*target_id*/ ctx[2] != ""
			? "disabled"
			: /*target_id*/ ctx[2] != /*data*/ ctx[13].defaultans_id && /*target_id*/ ctx[2] != ""
				? "disabled"
				: false;

			inputitem4.$set(inputitem4_changes);
			const inputitem5_changes = {};
			if (dirty & /*localSliderData*/ 1) inputitem5_changes.id = /*data*/ ctx[13].step_id;
			if (dirty & /*localSliderData*/ 1) inputitem5_changes.value = /*data*/ ctx[13].step_val;
			if (dirty & /*isValidationOK*/ 2) inputitem5_changes.disabledValue = /*isValidationOK*/ ctx[1] ? false : true;
			inputitem5.$set(inputitem5_changes);

			if (!current || dirty & /*localSliderData*/ 1 && label_for_value !== (label_for_value = /*data*/ ctx[13].sliderop)) {
				attr_dev(label, "for", label_for_value);
			}

			if ((!current || dirty & /*localSliderData*/ 1) && t11_value !== (t11_value = /*data*/ ctx[13].anskey + "")) set_data_dev(t11, t11_value);

			if (!current || dirty & /*localSliderData*/ 1 && output_for_value !== (output_for_value = /*data*/ ctx[13].sliderid)) {
				attr_dev(output, "for", output_for_value);
			}

			if (!current || dirty & /*localSliderData*/ 1 && output_id_value !== (output_id_value = /*data*/ ctx[13].sliderop)) {
				attr_dev(output, "id", output_id_value);
			}

			if (!current || dirty & /*localSliderData*/ 1 && input_name_value !== (input_name_value = /*data*/ ctx[13].sliderans)) {
				attr_dev(input, "name", input_name_value);
			}

			if (!current || dirty & /*localSliderData*/ 1 && input_id_value !== (input_id_value = /*data*/ ctx[13].sliderans)) {
				attr_dev(input, "id", input_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(inputitem0.$$.fragment, local);
			transition_in(inputitem1.$$.fragment, local);
			transition_in(inputitem2.$$.fragment, local);
			transition_in(inputitem3.$$.fragment, local);
			transition_in(inputitem4.$$.fragment, local);
			transition_in(inputitem5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(inputitem0.$$.fragment, local);
			transition_out(inputitem1.$$.fragment, local);
			transition_out(inputitem2.$$.fragment, local);
			transition_out(inputitem3.$$.fragment, local);
			transition_out(inputitem4.$$.fragment, local);
			transition_out(inputitem5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(inputitem0);
			destroy_component(inputitem1);
			destroy_component(inputitem2);
			destroy_component(inputitem3);
			destroy_component(inputitem4);
			destroy_component(inputitem5);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(253:8) {#each localSliderData as data, i}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div3;
	let div0;
	let t0;
	let div2;
	let div1;
	let sliderbutton0;
	let t1;
	let input;
	let input_value_value;
	let t2;
	let div10;
	let div9;
	let div8;
	let div4;
	let h4;
	let t4;
	let button0;
	let t5;
	let div6;
	let div5;
	let span;
	let t7;
	let div7;
	let button1;
	let t9;
	let sliderbutton1;
	let current;
	let each_value = /*localSliderData*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	sliderbutton0 = new SliderButton({
			props: {
				classVal: "add-option btn btn-outline-primary btn-sm pr-2",
				funcClick: "add",
				disabledValue: /*isValidationOK*/ ctx[1] ? false : true,
				buttonName: language.add_slider
			},
			$$inline: true
		});

	sliderbutton0.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	sliderbutton1 = new SliderButton({
			props: {
				classVal: "btn btn-primary",
				id: "ok_btn",
				key: /*state*/ ctx[3].formkey,
				funcClick: "delete",
				buttonName: language.yes_label,
				modalbtn: "1"
			},
			$$inline: true
		});

	sliderbutton1.$on("updateXmlValue", /*updateXmlValue*/ ctx[4]);

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div2 = element("div");
			div1 = element("div");
			create_component(sliderbutton0.$$.fragment);
			t1 = space();
			input = element("input");
			t2 = space();
			div10 = element("div");
			div9 = element("div");
			div8 = element("div");
			div4 = element("div");
			h4 = element("h4");
			h4.textContent = `${language.save_header}`;
			t4 = space();
			button0 = element("button");
			t5 = space();
			div6 = element("div");
			div5 = element("div");
			span = element("span");
			span.textContent = `${language.del_confirmation}`;
			t7 = space();
			div7 = element("div");
			button1 = element("button");
			button1.textContent = `${language.no_label}`;
			t9 = space();
			create_component(sliderbutton1.$$.fragment);
			attr_dev(div0, "class", "slider_item_container");
			add_location(div0, file$2, 251, 4, 12961);
			add_location(div1, file$2, 366, 8, 19104);
			attr_dev(div2, "class", "slider_head_content pb-3 text-start pl-3 pt-0 ms-1");
			add_location(div2, file$2, 365, 4, 19030);
			attr_dev(div3, "id", "mainslider");
			attr_dev(div3, "class", "border");
			add_location(div3, file$2, 250, 0, 12919);
			attr_dev(input, "type", "hidden");
			attr_dev(input, "id", "special_module_xml");
			input.value = input_value_value = /*state*/ ctx[3].xml;
			add_location(input, file$2, 377, 0, 19467);
			attr_dev(h4, "class", "modal-title");
			add_location(h4, file$2, 383, 16, 19728);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn-close");
			attr_dev(button0, "data-bs-dismiss", "modal");
			attr_dev(button0, "aria-hidden", "true");
			add_location(button0, file$2, 384, 16, 19790);
			attr_dev(div4, "class", "modal-header");
			add_location(div4, file$2, 382, 12, 19684);
			attr_dev(span, "class", "col-md-12");
			add_location(span, file$2, 388, 20, 20009);
			attr_dev(div5, "class", "row");
			add_location(div5, file$2, 387, 16, 19970);
			attr_dev(div6, "class", "modal-body text-center");
			add_location(div6, file$2, 386, 12, 19916);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "id", "cancel_btn");
			attr_dev(button1, "class", "btn btn-light");
			attr_dev(button1, "data-bs-dismiss", "modal");
			add_location(button1, file$2, 392, 16, 20167);
			attr_dev(div7, "class", "modal-footer mt-0");
			add_location(div7, file$2, 391, 12, 20118);
			attr_dev(div8, "class", "modal-content");
			add_location(div8, file$2, 381, 8, 19643);
			attr_dev(div9, "class", "modal-dialog modal-dialog-centered span4");
			add_location(div9, file$2, 380, 4, 19579);
			attr_dev(div10, "class", "modal");
			attr_dev(div10, "id", "delete_modal");
			add_location(div10, file$2, 379, 0, 19536);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, div1);
			mount_component(sliderbutton0, div1, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, input, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div10, anchor);
			append_dev(div10, div9);
			append_dev(div9, div8);
			append_dev(div8, div4);
			append_dev(div4, h4);
			append_dev(div4, t4);
			append_dev(div4, button0);
			append_dev(div8, t5);
			append_dev(div8, div6);
			append_dev(div6, div5);
			append_dev(div5, span);
			append_dev(div8, t7);
			append_dev(div8, div7);
			append_dev(div7, button1);
			append_dev(div7, t9);
			mount_component(sliderbutton1, div7, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*localSliderData, l, isValidationOK, updateXmlValue, target_id, state, AH*/ 31) {
				each_value = /*localSliderData*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const sliderbutton0_changes = {};
			if (dirty & /*isValidationOK*/ 2) sliderbutton0_changes.disabledValue = /*isValidationOK*/ ctx[1] ? false : true;
			sliderbutton0.$set(sliderbutton0_changes);

			if (!current || dirty & /*state*/ 8 && input_value_value !== (input_value_value = /*state*/ ctx[3].xml)) {
				prop_dev(input, "value", input_value_value);
			}

			const sliderbutton1_changes = {};
			if (dirty & /*state*/ 8) sliderbutton1_changes.key = /*state*/ ctx[3].formkey;
			sliderbutton1.$set(sliderbutton1_changes);
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(sliderbutton0.$$.fragment, local);
			transition_in(sliderbutton1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(sliderbutton0.$$.fragment, local);
			transition_out(sliderbutton1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_each(each_blocks, detaching);
			destroy_component(sliderbutton0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div10);
			destroy_component(sliderbutton1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SliderItem", slots, []);
	let sliderData = "";
	let localSliderData = [];
	let isValidationOK = true;
	let target_id = "";
	let { xml } = $$props;
	let { getChildXml } = $$props;
	let state = {};

	let authordata = writable({
		xml: {},
		acorrect: {},
		adefault: {},
		aanswer: {},
		astep: {},
		formkey: ""
	});

	const unsubscribe = authordata.subscribe(items => {
		$$invalidate(3, state = items);
	});

	onMount(() => {
		$$invalidate(3, state.xml = xml, state);
		loadModule(xml);
	});

	// loads the module and update the xml
	function loadModule(loadXml) {
		// contains the json data of xml
		loadXml = XMLToJSON(loadXml);

		// parses the xml and updates the sliders elements value
		parseXMLAuthoring(loadXml);
	}

	// parses the xml and updates the values of sliders elements
	function parseXMLAuthoring(SLIDERXML) {
		// contains array of slider object
		sliderData = SLIDERXML.smxml.slider;

		// empties an array firstly for storing the data to update the values of sliders elements
		$$invalidate(0, localSliderData = []);

		if (sliderData) {
			if (Array.isArray(sliderData) == false) {
				// creates an array
				sliderData = [];

				// assign the value of slider key at index zero
				sliderData[0] = SLIDERXML.smxml.slider;
			}
		}

		for (let i = 0; i < sliderData.length; i++) {
			localSliderData.push({
				sliderid: sliderData[i]._key,
				// used to set the id of the range element at index 'i'
				sliderid1: "a_" + sliderData[i]._key,
				// used to set the value of range and of the element have class slideroutput  at index 'i'
				anskey: sliderData[i]._anskey,
				// used to set the title value of the slider at index 'i'
				title_val: sliderData[i]._title,
				// used to set the step value of the slider at index 'i'
				step_val: sliderData[i]._step,
				// used to set the default value of the slider at index 'i'
				defaultans: sliderData[i]._defaultans,
				// used to set the id of default element of the slider at index 'i'
				defaultans_id: "defaultans" + sliderData[i]._key,
				// used to set the id of title element of the slider at index 'i'
				title_id: "title" + sliderData[i]._key,
				// used to set the id of step element of the slider at index 'i'
				step_id: "step" + sliderData[i]._key,
				// used to set the id and name of the hidden element have class sliderans of the slider at index 'i'
				sliderans: "slider" + sliderData[i]._key,
				// used to set the id of delete button of the slider at index 'i'
				remove_item: "remove_item" + sliderData[i]._key,
				// used to set the id of min element of the slider at index 'i'
				minid: "min" + sliderData[i]._key,
				// used to set the id of max element of the slider at index 'i'
				maxid: "max" + sliderData[i]._key,
				// used to set the id of correct element of the slider at index 'i'
				sliderop: "sliderop" + sliderData[i]._key,
				// used to set the min value of the slider at index 'i'
				minval: sliderData[i]._minmax.split(",")[0],
				// used to set the max value of the slider at index 'i'
				maxval: sliderData[i]._minmax.split(",")[1]
			});

			$$invalidate(0, localSliderData);
		}
	}

	// updates the xml when the value of any elements changed
	function updateXmlValue(eve) {
		let index = eve.detail.index;
		let e = eve.detail.value;
		let selector = eve.detail.func;

		// contains the target element's value
		let value = eve.detail.value.target.value;

		// contains the json data of state xml
		let xml = XMLToJSON(state.xml);

		// assign the value of slider key of xml json into variable sliderData
		sliderData = xml.smxml.slider;

		if (sliderData) {
			if (Array.isArray(sliderData) == false) {
				// creates an array for key slider of xml json
				xml.smxml.slider = [];

				// assign the value of index zero of slider key array of xml json
				xml.smxml.slider[0] = sliderData;
			}
		} else if (typeof sliderData == "string") {
			// makes the value of slider key of xml json to empty
			xml.smxml.slider = [];
		}

		switch (selector) {
			case "setTitle":
				// sets the value of title key at given index of slider key of xml json 
				xml.smxml.slider[index]._title = value;
				break;
			case "setStep":
				// sets the value of step key at given index of slider key of xml json 
				xml.smxml.slider[index]._step = value;
				break;
			case "setDefault":
				let target_value_current = parseInt(eve.detail.value.target.value);
				// sets the value of defaultans key at given index of slider key of xml json after converting the target element's value in integer 
				xml.smxml.slider[index]._defaultans = target_value_current;
				break;
			case "setDefaultOnBlur":
			case "setMinOnBlur":
			case "setMaxOnBlur":
				$$invalidate(1, isValidationOK = true);
				$$invalidate(2, target_id = "");
				// contains the value of target element after converting it into integer
				let target_value = parseInt(eve.detail.value.target.value);
				// contains the min value of target element after converting it into integer
				let target_min = parseInt(eve.detail.value.target.min);
				// contains the max value of target element after converting it into integer
				let target_max = parseInt(eve.detail.value.target.max);
				if (target_value > target_max || target_value < target_min) {
					//eve.detail.value.target.focus();
					//AH.select('#'+eve.detail.value.target.id).focus();
					// shows the warning message if value exceeds it's max value
					AH.alert("Value must be greater than or equal to " + target_min + " and less than or equal to " + target_max);

					$$invalidate(1, isValidationOK = false);
					$$invalidate(2, target_id = eve.detail.value.target.id);
				} else {
					// array containing min and max value at index 0 and 1 of slider at given index
					let minmax_data = xml.smxml.slider[index]._minmax.split(",");

					// contains min value after parsing it into integer
					let min_data = parseInt(minmax_data[0]);

					// contains max value after parsing it into integer
					let max_data = parseInt(minmax_data[1]);

					// contains defaultans value of slider at given index after parsing it into integer
					let default_data = parseInt(AH.select("#defaultansID" + index).value);

					if (selector == "setMinOnBlur" && min_data > max_data) {
						// focus the min field
						//eve.detail.value.target.focus();
						//AH.select('#'+eve.detail.value.target.id).focus();
						// warning message if min field value is greater than max field value of slider at given index
						AH.alert("Minimum value must be less than or equal to the maximum value.");

						$$invalidate(1, isValidationOK = false);
						$$invalidate(2, target_id = eve.detail.value.target.id);
					} else if (selector == "setMaxOnBlur" && min_data > max_data) {
						// focus the max field
						//eve.detail.value.target.focus();
						//AH.select('#'+eve.detail.value.target.id).focus();
						// warning message if max field value is less than min field value of slider at given index
						AH.alert("Max value must be greater than or equal to min value");

						$$invalidate(1, isValidationOK = false);
						$$invalidate(2, target_id = eve.detail.value.target.id);
					} else if (min_data <= max_data && (default_data > max_data || default_data < min_data)) {
						// warning message if min and max field value is ok but the value of defaultans field of slider at given index is either greater than th value of max or less than the value of min field
						AH.alert("Value must be greater than or equal to " + min_data + " and less than or equal to " + max_data);

						// focus the defaultans field of slider at given index
						AH.select("#defaultansID" + index).focus();

						$$invalidate(1, isValidationOK = false);
						$$invalidate(2, target_id = "defaultansID" + index);
					}
				}
				break;
			case "setMin":
			case "setMax":
				// contains the value of target element after parsing it into integer
				value = parseInt(eve.detail.value.target.value);
				// array containing min and max value at index 0 and 1 of slider at given index
				let minmax = xml.smxml.slider[index]._minmax.split(",");
				if (selector == "setMin") {
					// assign the value of min field at index 0 of array minmax
					minmax[0] = value;
				} else {
					// assign the value of max field at index 1 of array minmax
					minmax[1] = value;
				}
				// joins the minmax array into string separated by comma
				minmax = minmax.join(",");
				// assign the value of minmax string into the value of minmax key of slider key at given index of xml json
				xml.smxml.slider[index]._minmax = minmax;
				break;
			case "delete":
				// close the delete confirmation dialog box
				AH.getBS("#delete_modal", "Modal").hide();
				if (xml.smxml.slider.length > 1) {
					// removes given index slider from slider key array of xml json
					xml.smxml.slider.splice(index, 1);

					// used for reset the id of the Sliders
					for (let index_no = 0; index_no < xml.smxml.slider.length; index_no += 1) {
						xml.smxml.slider[index_no]._key = "ID" + index_no;
					}
				} else {
					AH.alert("You can not delete the default slider");
				}
				break;
			case "add":
				if (xml.smxml.slider.length < 10) {
					// adds the slider at index 'xml.smxml.slider.length' in slider key array of json xml
					xml.smxml.slider[parseInt(xml.smxml.slider.length)] = {
						"_key": "ID" + xml.smxml.slider.length,
						"_minmax": "0,100",
						"_step": "1",
						"_title": "",
						"_anskey": "0",
						"_defaultans": "0"
					};
				} else {
					AH.alert("You can not add more than 10 sliders");
				}
				break;
			case "setAnswer":
				// sets the value for correct answer of the slider at given index in slider key array of json xml
				xml.smxml.slider[index]._anskey = value;
		}

		// update the xml after converting json xml into xml
		getChildXml(JSONToXML(xml));
	}

	const writable_props = ["xml", "getChildXml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliderItem> was created with unknown prop '${key}'`);
	});

	const click_handler = i => {
		isValidationOK && $$invalidate(3, state.formkey = i, state);
		AH.getBS("#delete_modal", "Modal").show();
	};

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(5, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(6, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		onMount,
		l: language,
		InputItem,
		writable,
		XMLToJSON,
		AH,
		JSONToXML,
		SliderButton,
		sliderData,
		localSliderData,
		isValidationOK,
		target_id,
		xml,
		getChildXml,
		state,
		authordata,
		unsubscribe,
		loadModule,
		parseXMLAuthoring,
		updateXmlValue
	});

	$$self.$inject_state = $$props => {
		if ("sliderData" in $$props) sliderData = $$props.sliderData;
		if ("localSliderData" in $$props) $$invalidate(0, localSliderData = $$props.localSliderData);
		if ("isValidationOK" in $$props) $$invalidate(1, isValidationOK = $$props.isValidationOK);
		if ("target_id" in $$props) $$invalidate(2, target_id = $$props.target_id);
		if ("xml" in $$props) $$invalidate(5, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(6, getChildXml = $$props.getChildXml);
		if ("state" in $$props) $$invalidate(3, state = $$props.state);
		if ("authordata" in $$props) authordata = $$props.authordata;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*xml, state*/ 40) {
			 {
				if (xml != state.xml) {
					$$invalidate(3, state.xml = xml, state);
					loadModule(xml);
				}
			}
		}
	};

	return [
		localSliderData,
		isValidationOK,
		target_id,
		state,
		updateXmlValue,
		xml,
		getChildXml,
		click_handler
	];
}

class SliderItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { xml: 5, getChildXml: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SliderItem",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[5] === undefined && !("xml" in props)) {
			console.warn("<SliderItem> was created without expected prop 'xml'");
		}

		if (/*getChildXml*/ ctx[6] === undefined && !("getChildXml" in props)) {
			console.warn("<SliderItem> was created without expected prop 'getChildXml'");
		}
	}

	get xml() {
		throw new Error("<SliderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<SliderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<SliderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<SliderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default SliderItem;
//# sourceMappingURL=SliderItem-f0069fa0.js.map
