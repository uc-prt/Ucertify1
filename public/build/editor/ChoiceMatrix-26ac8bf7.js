
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, C as validate_each_argument, v as validate_slots, a7 as afterUpdate, o as onMount, A as AH, X as XMLToJSON, w as writable, a5 as Lang, h as text, k as add_location, n as insert_dev, B as noop, x as detach_dev, z as empty, K as destroy_each, f as space, j as attr_dev, $ as null_to_empty, l as set_style, q as listen_dev, E as is_function, G as prop_dev, H as run_all, Y as select_option } from './main-ad414885.js';
import { p as parseCSV } from './parseCSV-e4eb209c.js';

/* clsSMChoiceMatrix/ChoiceMatrix.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMChoiceMatrix/ChoiceMatrix.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-jbhpzi-style";
	style.textContent = ".fa-check.svelte-jbhpzi{color:#46A546}.fa-close.svelte-jbhpzi{color:#A80000}.fa-close.svelte-jbhpzi,.fa-check.svelte-jbhpzi{margin-left:9px;font-size:18px}.fa-close.svelte-jbhpzi,.fa-check.svelte-jbhpzi,.middle_align.svelte-jbhpzi{vertical-align:middle!important}.middle_align.svelte-jbhpzi{width:164px;min-width:164px}.topic_input.svelte-jbhpzi{min-width:257px}.preview_header.svelte-jbhpzi{font-size:16pt;font-weight:bold;vertical-align:middle}.adjust_width.svelte-jbhpzi{width:12%;text-align:center}.width180.svelte-jbhpzi{width:180px}.width150.svelte-jbhpzi{width:150px}.full_day.svelte-jbhpzi{background-color:#eee !important;color:#000 !important}.width90.svelte-jbhpzi{width:90px}.width20.svelte-jbhpzi{width:20px}.relative.svelte-jbhpzi{position:relative}.min_height_38.svelte-jbhpzi{min-height:38px}.min_width_200.svelte-jbhpzi{min-width:200px !important}.min_width_125.svelte-jbhpzi{min-width:125px}.max_width_150.svelte-jbhpzi{max-width:150px !important}.height34.svelte-jbhpzi{height:34px !important}.width96.svelte-jbhpzi{width:96%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hvaWNlTWF0cml4LnN2ZWx0ZSIsInNvdXJjZXMiOlsiQ2hvaWNlTWF0cml4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG4gKiAgRmlsZSBOYW1lICAgOiBDaG9pY2VNYXRyaXguc3ZlbHRlXG4gKiAgRGVzY3JpcHRpb24gOiBEZWNpZGVkIHRoZSBcIlRlcm1cIiAmIFwiT3B0aW9uXCJcbiAqICBBdXRob3IgICAgICA6IFN1bmRhcmFtIFRyaXBhdGhpXG4gKiAgUGFja2FnZSAgICAgOiBwZS1pdGVtc1xuICogIExhc3QgdXBkYXRlIDogMDUtTWF5LTIwMjFcbiAqICBMYXN0IFVwZGF0ZWQgQnkgOiBQcmFkZWVwIFlhZGF2XG4tLT5cbjxzdmVsdGU6aGVhZD5cblx0PGxpbmsgaHJlZj1cIi4vY2hvaWNlTWF0cml4LmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIiAvPlxuPC9zdmVsdGU6aGVhZD5cblxuPHNjcmlwdD4gIFxuXHRpbXBvcnQgeyBvbk1vdW50LGFmdGVyVXBkYXRlIH0gZnJvbSBcInN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcblx0aW1wb3J0IGwgZnJvbSAnLi4vc3JjL2xpYnMvTGFuZy5qcydcblx0aW1wb3J0IGxpYjEgZnJvbSAnLi9wYXJzZUNTVi5qcyc7XG5cdGltcG9ydCB7WE1MVG9KU09OLCBBSH0gZnJvbSBcIi4uL2hlbHBlci9IZWxwZXJBSS5zdmVsdGVcIjtcblx0ZXhwb3J0IGxldCBnZXRDaGlsZFhtbDtcblx0ZXhwb3J0IGxldCB4bWw7XG5cblx0Ly8gdmFyaWFibGUgZGVjbGFyYXRpb25cblx0bGV0IHRoZW1lT3B0aW9uID0gWydsaWdodF9ibHVlJywnZGFya19ibHVlJywncGVhY2gnLCdncmVlbicsJ3B1cnBsZSddO1xuXHRsZXQgd2lkdGhWYWwgPSBcIlwiO1xuXHRsZXQgaWNvbl9jbGFzcyA9IFwiaWNvbW9vbi1uZXctMjRweC1kZWxldGUtMSBzM1wiO1xuXHRsZXQgbGFzdEFjdGlvbjtcblx0bGV0IHN0YXRlID0ge307XG5cdGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7IFxuXHRcdGNkYXRhIFx0XHQ6IFwiXCIsXG5cdFx0c3RlbVx0XHQ6IFwiXCIsXG5cdFx0eG1sXHRcdFx0OiBcIlwiLFxuXHRcdHRoZW1lXHRcdDogXCJcIixcblx0XHRmb250XHRcdDogXCJcIixcblx0XHRtYXhXaWR0aFx0OiBcIlwiLFxuXHR9KTtcblx0Y29uc3QgdW5zdWJzY3JpYmUgPSBzdGF0ZURhdGEuc3Vic2NyaWJlKChpdGVtcykgPT4ge1xuXHRcdHN0YXRlID0gaXRlbXM7XG5cdH0pXG5cblx0XHQvLy8vLy8vLy8vLy8gICAgRXhlY3R1aW5nIGVhY2ggdGltZSB0aGUgeG1sIHdpbGwgY2hhbmdlIC8vLy8vLy8vLy8vLy8vXG5cblx0YWZ0ZXJVcGRhdGUoKCkgPT4ge1xuXHRcdGlmICh4bWwhPXN0YXRlLnhtbCkge1xuXHRcdFx0c3RhdGUueG1sID0geG1sO1xuXHRcdFx0bG9hZE1vZHVsZSh4bWwpOyBcdFxuXHRcdH1cblx0fSlcblx0XG4gICAgb25Nb3VudCgoKSA9PiB7XHRcdFxuXHRcdEFILmxpc3Rlbihkb2N1bWVudCwna2V5ZG93bicsJ3RleHRhcmVhJyxmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHtcblx0XHQgICAgXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdCAgICB9XG5cdFx0fSlcblx0XHRcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYWRkX3N0ZW0sIC5hZGRfc3RlbScpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0pO1xuXHRcdC8vIHRyeSBjYXRjaCBibG9jayBpbiBlcnJvciBoYW5kbGluZ1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBjaGVjayBpZiB4bWwgaXMgbm90IGJsYW5rXG4gICAgICAgICAgICBpZiAoeG1sKSB7XG5cdFx0XHRcdC8vIGxvYWQgdGhlIG1vZHVsZSBvbiB0aGUgYmFzaXMgb2YgeG1sIFxuXHRcdFx0XHRsb2FkTW9kdWxlKHhtbCk7XG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgY2RhdGEgYWNjb3JkaW5nbHlcblx0XHRcdFx0cmV2ZXJzZVhtbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHtFcnJvcjplLm1lc3NhZ2UsIEZpbGU6XCJjaG9pY2VNYXRyaXhcIiwgTGluZTpcIjY1XCJ9KTtcblx0XHR9XG5cdFx0XG5cdFx0QUgubGlzdGVuKGRvY3VtZW50LCdrZXlkb3duJywnLmRlbGV0ZV9jb2x1bW4nLCBmdW5jdGlvbihfdGhpcywgZXZlbnQpIHtcblx0XHRcdGlmICgoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC53aGljaCA9PSAxMykpIHtcblx0XHRcdC8vIGNsaWNrIHRoZSBlbGVtZW50IHdoaWNoIGN1cnJlbnRseSBnZXQgdGhlIGZvY3VzIGFuZCBlbnRlciBrZXkgaXMgZG93blxuXHRcdFx0QUgudHJpZ2dlcihfdGhpcywgJ2NsaWNrJyk7XG5cdFx0XHQvL190aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiY2xpY2tcIikpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdEFILmxpc3Rlbihkb2N1bWVudCwna2V5ZG93bicsJy5kZWxldGVfcm93JywgZnVuY3Rpb24oX3RoaXMsZXZlbnQpIHtcblx0XHRcdGlmICgoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC53aGljaCA9PSAxMykpIHtcblx0XHRcdC8vIGNsaWNrIHRoZSBlbGVtZW50IHdoaWNoIGN1cnJlbnRseSBnZXQgdGhlIGZvY3VzIGFuZCBlbnRlciBrZXkgaXMgZG93blxuXHRcdFx0X3RoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJjbGlja1wiKSk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0pXG5cblx0fSlcblxuXHQvLyBpdCBsb2FkIHRoZSBtb2R1bGUgXG5cdGZ1bmN0aW9uIGxvYWRNb2R1bGUobG9hZFhtbCkge1xuXHRcdC8vIGNvbnZlcnQgdGhlIHhtbCBpbnRvIGpzb24gYW5kIHBhc3MgaXQgaW4gdGhlIHBhcnNlWE1MQXV0aG9yaW5nIGZ1bmN0aW9uIHRvIHBhcnNlIHRoZSB4bWxcblx0XHRsb2FkWG1sID0gWE1MVG9KU09OKGxvYWRYbWwpO1xuXHRcdHBhcnNlWE1MQXV0aG9yaW5nKGxvYWRYbWwpO1xuXHR9XG5cblx0Ly8gaXQgaXMgdXNlZCBmb3IgcGFyc2luZyB0aGUgeG1sIGZvciBhdXRob3JpbmcgYXJlYVxuXHRmdW5jdGlvbiBwYXJzZVhNTEF1dGhvcmluZyhNWVhNTCkge1xuICAgICAgICBsZXQgZm9ybWF0dGVkRGF0YSA9IGxpYjEucGFyc2VDU1ZGb3JtYXQoTVlYTUwuc214bWwuX19jZGF0YSk7XG5cdFx0bGV0IGNkYXRhID0gZm9ybWF0dGVkRGF0YTtcblx0XHRsZXQgcmF3RGF0YSA9IFtdO1xuXHRcdC8vIGNvcHlpbmcgdGhlIEpTT04gZGF0YSBpbiB0aGUgcmF3RGF0YSBhbmQgbWFrZSBpdCBhcnJheSBcblx0XHRcblx0ICAgIHJhd0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNkYXRhKSk7XG5cdFx0c3RhdGUuY2RhdGEgPSByYXdEYXRhO1xuXHRcdHN0YXRlLnN0ZW0gPSByYXdEYXRhLnN0ZW07XG5cdFx0c3RhdGUudGhlbWUgPSBNWVhNTC5zbXhtbC5fdGhlbWU7XG5cdFx0c3RhdGUuZm9udCA9IE1ZWE1MLnNteG1sLl9mb250O1xuXHRcdHN0YXRlLm1heFdpZHRoID0gKChNWVhNTC5zbXhtbC5fbWF4d2lkdGgpP3BhcnNlSW50KE1ZWE1MLnNteG1sLl9tYXh3aWR0aCk6ODAwKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvL2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXNnXCIpLnZhbHVlID0gcmF3RGF0YVsnc3RlbSddO1xuXHRcdFx0Ly9qUXVlcnkoJyNtc2cnKS52YWwocmF3RGF0YS5zdGVtKTsgLy8gTmVlZCBUTyBGSVhcblx0XHRcdFxuXHRcdFxuXG5cdFx0Ly9cdGZvciBjaGVja2luZyB0aGUgcmFkaW8gYnRuIGFjY29yZGluZyB0byB0aGUgeG1sXG5cdFx0LypcdGxldCB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeShcIi5wcmV2aWV3X3JhZGlvXCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0alF1ZXJ5KHRoaXMpWzBdLmNoZWNrZWQgPSAoKGpRdWVyeSh0aGlzKS5hdHRyKCd2YWx1ZScpID09IGpRdWVyeSh0aGlzKS5hdHRyKCdkYXRhLWNvcnJlY3QnKSkgPyB0cnVlIDogZmFsc2UpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdH0uYmluZCh0aGlzKSwyMDApIC8vIFJlcGxhY2VkIFxuXHRcdCovXG5cblx0XHRsZXQgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0bGV0IHJhZGlvX2xlbjEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwcmV2aWV3X3JhZGlvJyk7XG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpPHJhZGlvX2xlbjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cmFkaW9fbGVuMVtpXS5jaGVja2VkID0gKChyYWRpb19sZW4xW2ldLmdldEF0dHJpYnV0ZSgndmFsdWUnKSA9PSByYWRpb19sZW4xW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3JyZWN0JykpID8gdHJ1ZSA6IGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdH0sMjAwKVxuXHR9XG5cblx0Ly8gY2FsbHMgb24gY2hhbmdlIGluIHRoZSBzdGVtIHRleHRhcmVhXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0ZW0oZSkge1xuICAgICAgICBzdGF0ZS5zdGVtID0gZS50YXJnZXQudmFsdWVcblx0XHRzdGF0ZS5jZGF0YS5zdGVtID0gZS50YXJnZXQudmFsdWU7XG5cdFx0Ly8gdXBkYWluZyB0aGUgY2RhdGFcblx0XHRyZXZlcnNlWG1sKCk7XG5cdH1cblxuXHQvLy8vLy8vLy8vLy8gVXBkYXRlIHRoZSBjZGF0YSAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cdGZ1bmN0aW9uIHJldmVyc2VYbWwoKSB7XG5cdFx0bGV0IGNzdlJldmVyc2UgPSByZXZlcnNlQ1NWRm9ybWF0KHN0YXRlLmNkYXRhKTtcblx0XHRjc3ZSZXZlcnNlID0gY3N2UmV2ZXJzZS5yZXBsYWNlKC9cXOKAmXxcXOKAsi9nLFwiJ1wiKS5yZXBsYWNlKC9cXOKAs3xcXOKAnHxcXOKAnS9nLFwiXFxcIlwiKTtcblx0XHRsZXQgdXBkYXRlZFhtbCA9IGA8c214bWwgdHlwZT1cIjI3XCIgbmFtZT1cIkNob2ljZU1hdHJpeFwiIHRoZW1lPVwiJHtzdGF0ZS50aGVtZX1cIiBmb250PVwiJHtzdGF0ZS5mb250fVwiIG1heHdpZHRoPVwiJHtzdGF0ZS5tYXhXaWR0aH1cIj48IS0tW0NEQVRBWyR7Y3N2UmV2ZXJzZX1dXS0tPjwvc214bWw+YDtcblx0XHRnZXRDaGlsZFhtbCh1cGRhdGVkWG1sKTsgICAgXG5cdH1cblxuXG5cdC8vIGl0IGZvcm1hdCB0aGUgY2RhdGFcblx0ZnVuY3Rpb24gcmV2ZXJzZUNTVkZvcm1hdChkYXRhKSB7XG5cdFx0Ly8gdmFsdWUgb2Ygc3RlbVxuXHRcdGxldCBjc3ZGb3JtYXQgPSBkYXRhLnN0ZW0rXCIsXCI7XG5cdFx0Ly8gZ2V0dGluZyB2YWx1ZXMgb2Ygb3B0aW9uIGFuZCBhcHBlbmRpbmcgaXQgdG8gdGhlIGNzdkZvcm1hdFxuXHRcdGRhdGEub3B0aW9uLm1hcCgodmFsMSk9PiB7XG5cdFx0XHRjc3ZGb3JtYXQgKz0gdmFsMS50ZXh0K1wiLFwiO1xuXHRcdH0pO1xuXHRcdGNzdkZvcm1hdCArPSBcIlxcblwiO1xuXG5cdFx0ZGF0YS50ZXJtLm1hcCgodmFsMixqKT0+IHtcblx0XHRcdC8vIGFkZGluZyB0aGUgdGV4dCBvZiB0ZXJtXG5cdFx0XHRjc3ZGb3JtYXQgKz0gdmFsMi50ZXh0K1wiLFwiO1xuXG5cdFx0XHQvLyBhZGRpbmcgMSwwIG4gdGhlIGJhc2lzIG9mIHJhZGlvIGlzIGNoZWNrZWQgb3Igbm90XG5cdFx0XHRkYXRhLm9wdGlvbi5tYXAoKHZhbDEpPT4ge1xuXHRcdFx0XHRjc3ZGb3JtYXQgKz0gKCAodmFsMi5jb3JyZWN0ID09IHZhbDEuaWQpID8gXCIxLFwiIDogXCIwLFwiICk7XG5cdFx0XHR9KTtcblx0XHRcdGNzdkZvcm1hdCArPSBcIlxcblwiO1xuXHRcdH0pO1xuXG5cdFx0Ly8gcmV0dXJuaW5nIGFsbCB0aGUgYXBwZW5kZWQgZGF0YVxuXHRcdHJldHVybiBjc3ZGb3JtYXQ7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVUZXJtVmFsdWUoZSkge1xuXHRcdC8vaXQgdXBkYXRlIHRoZSB0ZXh0IG9mIHRoYXQgcGFydGljdWxhciB0ZXJtIGJ5IGZpbmRpbmcgdGhlIGlkIG9mIHRoZSBjaGFuZ2VkIHRlcm0gdGV4dGFyZWFcblx0XHRzdGF0ZS5jZGF0YSAmJiAoc3RhdGUuY2RhdGEudGVybS5tYXAoZnVuY3Rpb24oZGF0YSwgaSkge1xuXHRcdFx0aWYgKGRhdGEuaWQgPT0gZS50YXJnZXQuaWQpIHtcblx0XHRcdFx0ZGF0YS50ZXh0ID0gZS50YXJnZXQudmFsdWU7XG5cdFx0XHR9XG5cdFx0fSkpO1xuXHRcdC8vIHVwZGF0ZSB0aGUgY2RhdGFcblx0XHRyZXZlcnNlWG1sKCk7XG5cdH1cblxuXHQvLy8vLy8vLy8vLy8vLyB1cGRhdGluZyB0aGUgb3B0aW9uIC8vLy8vLy8vLy8vLy8vL1xuXHRmdW5jdGlvbiB1cGRhdGVPcHRpb25WYWx1ZShlKSB7XG5cdFx0Ly9pdCB1cGRhdGUgdGhlIHRleHQgb2YgdGhhdCBwYXJ0aWN1bGFyIG9wdGlvbiBieSBmaW5kaW5nIHRoZSBpZCBvZiB0aGUgY2hhbmdlZCBvcHRpb24gdGV4dGFyZWFcblx0XHRzdGF0ZS5jZGF0YSAmJiAoc3RhdGUuY2RhdGEub3B0aW9uLm1hcChmdW5jdGlvbihkYXRhLCBpKSB7XG5cdFx0XHRpZiAoZGF0YS5pZCA9PSBlLnRhcmdldC5pZCkge1xuXHRcdFx0XHRkYXRhLnRleHQgPSBlLnRhcmdldC52YWx1ZTtcblx0XHRcdH1cblx0XHR9KSk7XG5cdFx0Ly8gdXBkYXRlIHRoZSBjZGF0YVxuXHRcdHJldmVyc2VYbWwoKTtcblx0fVxuXG5cdC8vLy8vLy8vLy8vICBBZGRlZCByb3cgcm93cyAgLy8vLy8vLy8vLy8vLy8vLy9cblx0ZnVuY3Rpb24gYWRkU3RlbSgpIHtcblx0XHRsZXQgaWQgPSAoc3RhdGUuY2RhdGEudGVybS5sZW5ndGggKyAxKTtcblx0XHRpZiAoaWQgPD0gNikge1xuXHRcdFx0c3RhdGUuY2RhdGEudGVybS5wdXNoKHtpZDogXCJ0XCIgKyBpZCwgY29ycmVjdDogXCJcIiwgdGV4dDogXCJUZXJtIFNhbXBsZSB0ZXh0XCJ9KTtcblx0XHRcdHJldmVyc2VYbWwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QUguYWxlcnQoJ01heGltdW0gcG9zc2libGUgdmFsdWUgb2Ygcm93cyBhcmUgNi4nKTtcblx0XHR9XG5cdH1cblxuXHQvLy8vLy8vLy8gIFRoaXMgZnVuY3Rpb24gaXMgYWRkZWQgdGhlIGNvbHVtbiAgLy8vLy8vLy8vLy8vLy8vXG5cdGZ1bmN0aW9uIGFkZE9wdGlvbigpIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YXRlLmNkYXRhLm9wdGlvbi5sZW5ndGggKyAxKTtcblx0XHRpZiAoaWQgPD0gNCkge1xuXHRcdFx0c3RhdGUuY2RhdGEub3B0aW9uLnB1c2goe2lkOiBcIm9cIiArIGlkLCB0ZXh0OiBcIk9wdGlvblwifSk7XG5cdFx0XHRyZXZlcnNlWG1sKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFILmFsZXJ0KCdNYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9mIGNvbHVtbnMgYXJlIDQuJyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8vLy8vLy8vLy8vIFRoaXMgZnVuY3Rpb24gZGVsZXRlIHRoZSByb3dzIC8vLy8vLy8vLy8vLy9cblx0ZnVuY3Rpb24gcmVtb3ZlVGVybShpZCkge1xuXHRcdGlmKHN0YXRlLmNkYXRhLnRlcm0ubGVuZ3RoID4gMikge1xuXHRcdFx0bGV0IG5ld1Rlcm0gPSBbXTtcblx0XHRcdGxldCBjb3VudCA9IDE7XG5cdFx0XHRzdGF0ZS5jZGF0YS50ZXJtLm1hcChmdW5jdGlvbihkYXRhLGkpIHtcblx0XHRcdFx0aWYoZGF0YS5pZCA9PSBpZCkge1xuXHRcdFx0XHRcdHN0YXRlLmNkYXRhLnRlcm0uc3BsaWNlKGksMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pOyBcblx0XHRcdHN0YXRlLmNkYXRhLnRlcm0ubWFwKGZ1bmN0aW9uKGRhdGEsaSkge1xuXHRcdFx0XHRcdG5ld1Rlcm0ucHVzaCh7XG5cdFx0XHRcdFx0XHRpZDpcInRcIitjb3VudCxcblx0XHRcdFx0XHRcdGNvcnJlY3Q6ZGF0YS5jb3JyZWN0LFxuXHRcdFx0XHRcdFx0dGV4dDpkYXRhLnRleHRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH0pO1xuXG5cdFx0XHRzdGF0ZS5jZGF0YS50ZXJtID0gbmV3VGVybTtcblxuXHRcdFx0bGV0IHJhZGlvX2xlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3ByZXZpZXdfcmFkaW8nKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmFkaW9fbGVuOyBpKyspIHtcblx0XHRcdFx0cmFkaW9fbGVuW2ldLmNoZWNrZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vdXBkYXRpbmcgdGhlIGNkYXRhXG5cdFx0XHRyZXZlcnNlWG1sKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFILnNob3dtc2coXCJZb3UgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byByb3dzLlwiKTsgIFxuXHRcdH1cblx0fVxuXG5cdC8vIHdoZW4gZGVsZXRlIGJ0biBvZiBvcHRpb24gaXMgY2xpa2VkXG5cdGZ1bmN0aW9uIHJlbW92ZU9wdGlvbihpZCkge1xuXHRcdC8vIGNoZWNraW5nIG1pbiBubyBvZiBvcHRpb24gXG5cdFx0aWYgKHN0YXRlLmNkYXRhLm9wdGlvbi5sZW5ndGggPiAyKSB7XG5cdFx0XHRsZXQgbmV3T3B0aW9uID0gW107XG5cdFx0XHRsZXQgY291bnQgPSAxO1xuXHRcdFx0Ly8gcmVtb3ZpbmcgdGhhdCBwYXJ0aWN1bGFyIG9wdGlvblxuXHRcdFx0c3RhdGUuY2RhdGEub3B0aW9uLm1hcChmdW5jdGlvbihkYXRhLGkpIHtcblx0XHRcdFx0aWYgKGRhdGEuaWQgPT0gaWQpIHtcblx0XHRcdFx0XHRzdGF0ZS5jZGF0YS5vcHRpb24uc3BsaWNlKGksMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRzdGF0ZS5jZGF0YS5vcHRpb24ubWFwKGZ1bmN0aW9uKGRhdGEsaSkge1xuXHRcdFx0XHRuZXdPcHRpb24ucHVzaCh7XG5cdFx0XHRcdFx0aWQ6XCJvXCIrY291bnQsXG5cdFx0XHRcdFx0dGV4dDpkYXRhLnRleHRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIHRoZSBjb3JyZWN0IGFuc3dlclxuXHRcdFx0cmVtb3ZlQ29ycmVjdEFucygpO1xuXG5cdFx0XHRzdGF0ZS5jZGF0YS5vcHRpb24gPSBuZXdPcHRpb247XG5cdFx0XHQvLyB1cGRhdGVzIHRoZSB4bWxcblx0XHRcdHJldmVyc2VYbWwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QUguYWxlcnQoXCJZb3UgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBjb2x1bW5zLlwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyBmb3IgcmVtb3ZpbmcgdGhlIGNvcnJlY3QgYW5zXG5cdGZ1bmN0aW9uIHJlbW92ZUNvcnJlY3RBbnMoKSB7XG5cdFx0c3RhdGUuY2RhdGEgJiYgKHN0YXRlLmNkYXRhLnRlcm0ubWFwKGZ1bmN0aW9uKGRhdGEsaSkge1xuXHRcdFx0ZGF0YS5jb3JyZWN0ID0gXCJcIjtcblx0XHR9KSk7XG5cdH1cblxuXHQvLyBmb3Igc2V0dGluZyB0aGUgY29ycmVjdCBhbnN3ZXJcblx0ZnVuY3Rpb24gc2V0Q29ycmVjdEFucyhlKSB7XG5cdFx0Ly8gZ2V0dGluZyBuYW1lIG9mIHRoZSBjbGlja2VkIHJhZGlvIGJ0biB0byBmaW5kIHRoZSBpbmRleFxuXHRcdGxldCBybmFtZSA9IGUudGFyZ2V0Lm5hbWU7XG5cdFx0bGV0IHJpbmRleCA9IHJuYW1lIC0gMTtcblx0XHQvLyBzdG9yZSB0aGUgdmFsdWUgb2YgdGFyZ2V0IGluIGNvcnJlY3Qga2V5IG9mIHRoZSB0ZXJtIGF0IHRoYXQgaW5kZXggXG5cdFx0c3RhdGUuY2RhdGEudGVybVtyaW5kZXhdLmNvcnJlY3QgPSBlLnRhcmdldC52YWx1ZTtcblx0XHRyZXZlcnNlWG1sKCk7XG5cdH1cblxuXG5cdC8vLy8vLyBUaGlzIGZ1bmN0aW9uIGlzIGZpcmVkIHRoZW4gY2hhbmdlIHRoZW1lIC8vLy8vLy8vLy8vL1xuXHRmdW5jdGlvbiBjaGFuZ2VUaGVtZShlKSB7XG5cdFx0Ly8gdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICBzdGF0ZS50aGVtZSA9IGUudGFyZ2V0LnZhbHVlO1xuXHRcdC8vIHVwZGF0ZSB0aGUgY2RhdGFcblx0XHRyZXZlcnNlWG1sKCk7IC8vIFJlbW92ZSBzZXRUaW1lb3V0IGluIHRoaXMgcGxhY2Vcblx0fVxuXG5cdC8vIHdoZW4gdGhlcmUgaXMgY2hhbmdlIGluIHRhYmxlXG5cdGZ1bmN0aW9uIGhhbmRsZU1heHdpZHRoKCkge1xuXHRcdC8vIGdldHRpbmcgdGhlIHZhbHVlIG9mIHdpZHRoXG5cdFx0d2lkdGhWYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY3VzdG9tV2lkdGgnKS52YWx1ZTtcblx0XHQvLyBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgdGFibGVcblx0Ly9cdGpRdWVyeSgnI3Rlc3RfdGFibGUnKS53aWR0aCh3aWR0aFZhbCtcInB4XCIpOyAvLyBSZXBsYWNlZFxuXHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdF90YWJsZScpLnN0eWxlLndpZHRoID0gd2lkdGhWYWwgKydweCc7XG5cblx0XHQvLyBjaGVjayBmb3IgdGggdGltZW91dCBpZiBleGlzdCBjbGVhciB0aGUgdGltZW91dCB0byBzYXZlIG1lbW9yeVxuXHRcdChsYXN0QWN0aW9uKSA/IGNsZWFyVGltZW91dChsYXN0QWN0aW9uKSA6IFwiXCI7XG5cdFx0bGFzdEFjdGlvbiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IFxuXHRcdFx0Ly8gY2hlY2tpbmcgY29uZGl0aW9uIHRoYXQgdGhlIHRhYmxlIHdpZHRoIG11c3QgYmV0d2VlbiB0aGUgNTAwIGFuZCAxMDAwXG5cdFx0XHRcblx0XHRcdGlmICh3aWR0aFZhbCA8IDUwMCkgeyAgLy8vLyBqUXVlcnkoJyNjdXN0b21XaWR0aCcpLnZhbCgpIHJlbW92ZSB0aGlzXG4gICAgICAgICAgICAgICAgc3RhdGUubWF4V2lkdGggPSA1MDA7XG5cdFx0XHRcdGxldCB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldmVyc2VYbWwoKTsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSwxMDApOyAgLy8gIEZpeGVkXG5cdFx0XHRcdHN3YWwoXCJXaWR0aCBzaG91bGQgbm90IGJlIGxlc3MgdGhhbiA1MDBweFwiKTtcblx0XHRcdH1cblx0XHRcdGlmICh3aWR0aFZhbCA+IDEwMDApIHsgLy8vLyBqUXVlcnkoJyNjdXN0b21XaWR0aCcpLnZhbCgpIHJlbW92ZSB0aGlzXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RhdGUubWF4V2lkdGggPSAxMDAwO1xuXHRcdFx0XHRsZXQgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXZlcnNlWG1sKCk7IGNsZWFyVGltZW91dCh0aW1lcik7IH0sMTAwKTsgIC8vIEZpeGVkXG5cdFx0XHRcdHN3YWwoXCJXaWR0aCBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMDAwcHhcIik7XG5cdFx0XHR9IFxuXHRcdH0sMTUwMCk7XG5cdFx0Ly8gdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICBzdGF0ZS5tYXhXaWR0aCA9IHdpZHRoVmFsO1xuXHRcdC8vIHVwZGF0ZSB0aGUgY2RhdGFcblx0XHRyZXZlcnNlWG1sKCk7IFxuXHR9XG48L3NjcmlwdD5cblxuPG1haW4+XG4gICAgPGRpdj5cbiAgICAgICAgPGRpdiBpZCA9IFwiYXV0aG9yaW5nXCIgY2xhc3MgPSBcInAtMiBib3JkZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3MgPSBcImNvbC0xMiBjb2wtbGctMTIgcC0wXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFwiZm9ybS1ncm91cCByb3cgZnVsbF9kYXkgbXgtMCBwdC0yIHBiLTEgdy0xMDBcIj5cblx0XHRcdFx0PCEtLSA8bGFiZWwgZm9yID0gXCJzZWxlY3RfdGhlbWVzXCIgY2xhc3MgPSBcIm1iLTAgcGwtMSBtdC0yIG1yLTJcIj57bC50aGVtZXN9PC9sYWJlbD4gLS0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3MgPSBcImZsb2F0LWxlZnQgbWItMSBwci0yIFwiPlxuXHRcdFx0XHRcdFx0PGxhYmVsIFxuXHRcdFx0XHRcdFx0XHRmb3IgPSBcInNlbGVjdF90aGVtZXNcIiBcblx0XHRcdFx0XHRcdFx0Y2xhc3MgPSBcIm1iLTAgcGwtMSBtdC0yIG1yLTIgZmxvYXQtbGVmdFwiXG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHtsLnRoZW1lc31cblx0XHRcdFx0XHRcdDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IG9uOmNsaWNrID0ge2NoYW5nZVRoZW1lfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtzdGF0ZS50aGVtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1tZCBweC0yIGVucm9sbF9kYXRlX3RkIHdpZHRoMTUwIGZsb2F0LWxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJzZWxlY3RfdGhlbWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJzZWxlY3RfdGhlbWVzXCJcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyNlYWNoIHRoZW1lT3B0aW9uIGFzIHRoZW1lLCBpfVxuXHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWUgPSBcInRoZW1leysraX1cIj57bFt0aGVtZV19PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdHsvZWFjaH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PiBcblx0XHRcdFx0XHRcdDxsYWJlbCBmb3IgPSBcImN1c3RvbVdpZHRoXCIgY2xhc3MgPSBcIm1iLTAgbXQtMiBtci0yIG1sLTIgZmxvYXQtbGVmdFwiPntsLnRhYmxlX3dpZHRofTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgXG5cdFx0XHRcdFx0XHRcdGNsYXNzID0gXCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLW1kIHB4LTIgd2lkdGg5MCBmbG9hdC1sZWZ0XCIgXG5cdFx0XHRcdFx0XHRcdHN0ZXAgPSBcIjEwXCIgXG5cdFx0XHRcdFx0XHRcdG1pbiA9IFwiNTAwXCIgXG5cdFx0XHRcdFx0XHRcdG1heCA9IFwiMTAwMFwiIFxuXHRcdFx0XHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIiBcblx0XHRcdFx0XHRcdFx0dmFsdWU9e3BhcnNlSW50KHN0YXRlLm1heFdpZHRoKX0gXG5cdFx0XHRcdFx0XHRcdGlkID0gXCJjdXN0b21XaWR0aFwiIFxuXHRcdFx0XHRcdFx0XHRvbjprZXl1cCA9IHtoYW5kbGVNYXh3aWR0aC5iaW5kKHRoaXMpfSBcblx0XHRcdFx0XHRcdFx0b246Y2hhbmdlID0ge2hhbmRsZU1heHdpZHRoLmJpbmQodGhpcyl9IFxuXHRcdFx0XHRcdFx0Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzID0nZC1pbmxpbmUtYmxvY2sgbXQtc20gcHQtc20gbWwtMSB3aWR0aDIwIGZsb2F0LWxlZnQnPnB4PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzID0gXCJ0YWJsZS1yZXNwb25zaXZlIG10LTQgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3MgPSBcInRhYmxlIHRhYmxlLWJvcmRlcmVkIHJlbGF0aXZlIHctNzUgbWwtMCBtdC0wXCIgaWQgPSBcIm15X3RhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzID0gXCJ0YWJsZS1oZWFkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzID0gXCJ0b3BpY19pbnB1dCB0ZXh0LWNlbnRlclwiIFxuXHRcdFx0XHRcdFx0XHRcdFx0aWQgPSBcImhlbGxvXCIgXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjp7KChzdGF0ZS50aGVtZSA9PSAndGhlbWUxJykgPyBcIiM1QjlCRDVcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWUyJykgPyBcIiMzQjY3QkNcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWUzJykgPyBcIiNGNkMzQTJcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWU0JykgPyBcIiM3MEFENDdcIjogXCIjNzQ1OTk4XCIpKSkpfVwiXG5cdFx0XHRcdFx0XHRcdFx0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlID0ge3VwZGF0ZVN0ZW19IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge3N0YXRlLnN0ZW19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtbWQgcHgtMiBtaW5faGVpZ2h0XzM4IHRleHQtZGFya1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7J291dGxpbmU6bm9uZTsnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHM9XCIxNVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cz1cIjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHN0YXRlLmNkYXRhfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHN0YXRlLmNkYXRhLm9wdGlvbiBhcyBkYXRhLGl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHtpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSB7XCJtaWRkbGVfYWxpZ24gdGV4dC1jZW50ZXIgXCIgKyBkYXRhLmlkfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjogeygoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMScpID8gXCIjNUI5QkQ1XCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMicpID8gXCIjM0I2N0JDXCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMycpID8gXCIjRjZDM0EyXCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lNCcpID8gXCIjNzBBRDQ3XCI6IFwiIzc0NTk5OFwiKSkpKX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFwiZmxvYXQtbGVmdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0ge2RhdGEuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlID0ge3VwZGF0ZU9wdGlvblZhbHVlfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtkYXRhLnRleHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtbWQgcHgtMiBtaW5faGVpZ2h0XzM4IHRleHQtZGFya1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29scyA9XCIxMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cyA9XCIxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZsb2F0LWxlZnQgcG9pbnRlciBwdC0xIG1sLTIgZGVsZXRlX2NvbHVtbiBoZWlnaHQzNSB0b3AxIHBvc2l0aW9uLXJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0ge3JlbW92ZU9wdGlvbi5iaW5kKHRoaXMsZGF0YS5pZCl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YWItaW5kZXggPSBcIjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcyA9IHtpY29uX2NsYXNzfT48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5jZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHN0YXRlLmNkYXRhLnRlcm0gYXMgZGF0YSxpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGtleT17aX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkICBjbGFzcyA9IHtcIm1pbl93aWR0aF8yMDAgaC1hdXRvIFwiICsgZGF0YS5pZH0gc3R5bGUgPSBcImZvbnQtd2VpZ2h0OiBib2xkOyBiYWNrZ3JvdW5kLWNvbG9yOnsoKChpICUgMikgPT0gMCk/KChzdGF0ZS50aGVtZSA9PSAndGhlbWUxJykgPyBcIiNERUVBRjZcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWUyJykgPyBcIiNENERFRjFcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWUzJykgPyBcIiNGQUUwQ0ZcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWU0JykgPyBcIiNFMkVGRDlcIjogXCIjRTFEQUU5XCIpKSkpOiBcIiNGRkZcIil9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0ge2RhdGEuaWR9ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmlucHV0ID0ge3VwZGF0ZVRlcm1WYWx1ZX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtkYXRhLnRleHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1tZCB3aWR0aDk2IGZsb2F0LWxlZnQgbWluX2hlaWdodF8zOFwiIHN0eWxlID0gXCJvdXRsaW5lOiBub25lO2hlaWdodDogMzhweDtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwicG9pbnRlciBwdC0xIG10LXNtMiBtbC0yIGRlbGV0ZV9yb3cgaGVpZ2h0MzRcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0ge3JlbW92ZVRlcm0uYmluZCh0aGlzLGRhdGEuaWQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiLWluZGV4ID0gXCIwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3MgPSB7aWNvbl9jbGFzc30+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCBzdGF0ZS5jZGF0YS5vcHRpb24gYXMgZGF0YTIsan1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDx0ZCBjbGFzcyA9IFwidGV4dC1jZW50ZXIgYWxpZ24tbWlkZGxlIGgtYXV0byBtaW5fd2lkdGhfMTI1IG1heF93aWR0aF8xNTBcIiBrZXk9e2p9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjp7KCgoaSAlIDIpID09IDApPygoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMScpID8gXCIjREVFQUY2XCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMicpID8gXCIjRDRERUYxXCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMycpID8gXCIjRkFFMENGXCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lNCcpID8gXCIjRTJFRkQ5XCI6IFwiI0UxREFFOVwiKSkpKTogXCIjRkZGXCIpfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzID0gXCJsYWJlbF9jaG9pY2UgcG9pbnRlciBkLWJsb2NrIHctMTAwIG1iLTBcIiBmb3I9eydhJysoaSkrKGopfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwicmFkaW9cIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzID0gXCJwcmV2aWV3X3JhZGlvIGFsaWduLW1pZGRsZVwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7ZGF0YTIuaWR9ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB7aSsxfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0geydhJysoaSkrKGopfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7c2V0Q29ycmVjdEFuc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtY29ycmVjdCA9IHtkYXRhLmNvcnJlY3R9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcyA9IFwidGV4dC1kYW5nZXIgZm9udDEzXCI+PHN0cm9uZz4qIHtsLm5vdGVfbGFiZWx9PC9zdHJvbmc+IHtsLmNvbW1lbnRfY2hvaWNlTWF0cml4fTwvc21hbGw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFwidGV4dC1jZW50ZXJcIiBzdHlsZSA9IHsnd2lkdGg6ODAlOyd9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJidXR0b25cIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGFkZF9zdGVtIHByLW1kIG1sLTIgcHgtMlwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJidG5cIiBcblx0XHRcdFx0XHRcdFx0b246Y2xpY2sgPSB7YWRkU3RlbX1cblx0XHRcdFx0XHRcdFx0c3R5bGUgPSB7J3dpZHRoOiAxNzFweDsnfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsLmFkZF9yb3d9XG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblxuXHRcdFx0XHRcdFx0PGJ1dHRvbiAgXG5cdFx0XHRcdFx0XHR0eXBlID0gXCJidXR0b25cIiBcblx0XHRcdFx0XHRcdGNsYXNzID0gXCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeSBidG4tc20gYWRkX29wdGlvbiBwci1tZCBtbC0yIHB4LTJcIiBcblx0XHRcdFx0XHRcdGlkID0gXCJidG5fb3B0XCIgXG5cdFx0XHRcdFx0XHRvbjpjbGljayA9IHthZGRPcHRpb259XG5cdFx0XHRcdFx0XHRzdHlsZSA9IHsnd2lkdGg6IDE3MXB4Oyd9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0e2wuYWRkX2NvbHVtbn1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFxuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+ICAgXG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9tYWluPlxuPHN0eWxlPlxuXG4uZmEtY2hlY2sge1xuXHRjb2xvcjogIzQ2QTU0Njtcbn1cblxuLmZhLWNsb3NlIHtcblx0Y29sb3I6ICNBODAwMDA7XG59XG5cbi5mYS1jbG9zZSxcbi5mYS1jaGVjayB7XG5cdG1hcmdpbi1sZWZ0OiA5cHg7XG5cdGZvbnQtc2l6ZTogMThweDtcbn1cblxuLmZhLWNsb3NlLFxuLmZhLWNoZWNrLFxuLm1pZGRsZV9hbGlnbiB7XG5cdHZlcnRpY2FsLWFsaWduOiBtaWRkbGUhaW1wb3J0YW50O1xufVxuXG4ubWlkZGxlX2FsaWduIHtcblx0d2lkdGg6IDE2NHB4O1xuXHRtaW4td2lkdGg6IDE2NHB4O1xufVxuXG4udG9waWNfaW5wdXQge1xuXHRtaW4td2lkdGg6IDI1N3B4O1xufVxuXG4ucHJldmlld19oZWFkZXIge1xuXHRmb250LXNpemU6IDE2cHQ7XG5cdGZvbnQtd2VpZ2h0OiBib2xkO1xuXHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xufVxuXG4uYWRqdXN0X3dpZHRoIHtcbiAgICB3aWR0aDogMTIlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuLndpZHRoMTgwIHtcblx0d2lkdGg6IDE4MHB4O1xufVxuXG4ud2lkdGgxNTAge1xuXHR3aWR0aDogMTUwcHg7XG59XG5cbi5mdWxsX2RheSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNlZWUgIWltcG9ydGFudDtcblx0Y29sb3I6ICMwMDAgIWltcG9ydGFudDtcbn1cblxuXG4ud2lkdGg5MCAge1xuXHR3aWR0aDogOTBweDtcbn1cblxuLndpZHRoMjAge1xuXHR3aWR0aDogMjBweDtcbn1cblxuLnJlbGF0aXZlIHsgXG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLm1pbl9oZWlnaHRfMzgge1xuXHRtaW4taGVpZ2h0OiAzOHB4O1xufVxuXG4ubWluX3dpZHRoXzIwMCAge1xuXHRtaW4td2lkdGg6IDIwMHB4ICFpbXBvcnRhbnQ7XG59XG5cbi5taW5fd2lkdGhfMTI1ICB7XG5cdG1pbi13aWR0aDogMTI1cHg7XG59XG5cbi5tYXhfd2lkdGhfMTUwIHsgIFxuXHRtYXgtd2lkdGg6IDE1MHB4ICFpbXBvcnRhbnQ7XG59XG5cbi5oZWlnaHQzNCAge1xuXHRoZWlnaHQ6IDM0cHggIWltcG9ydGFudDtcbn1cblxuLndpZHRoOTYge1xuXHR3aWR0aDogOTYlO1xufVxuXG5cblxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc2ZBLFNBQVMsY0FBQyxDQUFDLEFBQ1YsS0FBSyxDQUFFLE9BQU8sQUFDZixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsQUFDVixLQUFLLENBQUUsT0FBTyxBQUNmLENBQUMsQUFFRCx1QkFBUyxDQUNULFNBQVMsY0FBQyxDQUFDLEFBQ1YsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsU0FBUyxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVELHVCQUFTLENBQ1QsdUJBQVMsQ0FDVCxhQUFhLGNBQUMsQ0FBQyxBQUNkLGNBQWMsQ0FBRSxNQUFNLFVBQVUsQUFDakMsQ0FBQyxBQUVELGFBQWEsY0FBQyxDQUFDLEFBQ2QsS0FBSyxDQUFFLEtBQUssQ0FDWixTQUFTLENBQUUsS0FBSyxBQUNqQixDQUFDLEFBRUQsWUFBWSxjQUFDLENBQUMsQUFDYixTQUFTLENBQUUsS0FBSyxBQUNqQixDQUFDLEFBRUQsZUFBZSxjQUFDLENBQUMsQUFDaEIsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsSUFBSSxDQUNqQixjQUFjLENBQUUsTUFBTSxBQUN2QixDQUFDLEFBRUQsYUFBYSxjQUFDLENBQUMsQUFDWCxLQUFLLENBQUUsR0FBRyxDQUNWLFVBQVUsQ0FBRSxNQUFNLEFBQ3RCLENBQUMsQUFFRCxTQUFTLGNBQUMsQ0FBQyxBQUNWLEtBQUssQ0FBRSxLQUFLLEFBQ2IsQ0FBQyxBQUVELFNBQVMsY0FBQyxDQUFDLEFBQ1YsS0FBSyxDQUFFLEtBQUssQUFDYixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsQUFDVixnQkFBZ0IsQ0FBRSxJQUFJLENBQUMsVUFBVSxDQUNqQyxLQUFLLENBQUUsSUFBSSxDQUFDLFVBQVUsQUFDdkIsQ0FBQyxBQUdELFFBQVEsY0FBRSxDQUFDLEFBQ1YsS0FBSyxDQUFFLElBQUksQUFDWixDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDVCxLQUFLLENBQUUsSUFBSSxBQUNaLENBQUMsQUFFRCxTQUFTLGNBQUMsQ0FBQyxBQUNWLFFBQVEsQ0FBRSxRQUFRLEFBQ25CLENBQUMsQUFFRCxjQUFjLGNBQUMsQ0FBQyxBQUNmLFVBQVUsQ0FBRSxJQUFJLEFBQ2pCLENBQUMsQUFFRCxjQUFjLGNBQUUsQ0FBQyxBQUNoQixTQUFTLENBQUUsS0FBSyxDQUFDLFVBQVUsQUFDNUIsQ0FBQyxBQUVELGNBQWMsY0FBRSxDQUFDLEFBQ2hCLFNBQVMsQ0FBRSxLQUFLLEFBQ2pCLENBQUMsQUFFRCxjQUFjLGNBQUMsQ0FBQyxBQUNmLFNBQVMsQ0FBRSxLQUFLLENBQUMsVUFBVSxBQUM1QixDQUFDLEFBRUQsU0FBUyxjQUFFLENBQUMsQUFDWCxNQUFNLENBQUUsSUFBSSxDQUFDLFVBQVUsQUFDeEIsQ0FBQyxBQUVELFFBQVEsY0FBQyxDQUFDLEFBQ1QsS0FBSyxDQUFFLEdBQUcsQUFDWCxDQUFDIn0= */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	child_ctx[28] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

// (364:7) {#each themeOption as theme, i}
function create_each_block_3(ctx) {
	let option;
	let t_value = Lang[/*theme*/ ctx[30]] + "";
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = "theme" + ++/*i*/ ctx[25];
			option.value = option.__value;
			add_location(option, file, 364, 8, 10555);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(364:7) {#each themeOption as theme, i}",
		ctx
	});

	return block;
}

// (401:32) {#if state.cdata}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value_2 = /*state*/ ctx[0].cdata.option;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, removeOption, icon_class, updateOptionValue*/ 549) {
				each_value_2 = /*state*/ ctx[0].cdata.option;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(401:32) {#if state.cdata}",
		ctx
	});

	return block;
}

// (402:36) {#each state.cdata.option as data,i}
function create_each_block_2(ctx) {
	let th;
	let div0;
	let textarea;
	let textarea_id_value;
	let textarea_value_value;
	let t0;
	let div1;
	let span;
	let span_class_value;
	let t1;
	let th_key_value;
	let th_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			th = element("th");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			div1 = element("div");
			span = element("span");
			t1 = space();
			attr_dev(textarea, "id", textarea_id_value = /*data*/ ctx[23].id);
			textarea.value = textarea_value_value = /*data*/ ctx[23].text;
			attr_dev(textarea, "class", "form-control form-control-md px-2 min_height_38 text-dark svelte-jbhpzi");
			attr_dev(textarea, "cols", "10");
			attr_dev(textarea, "rows", "1");
			add_location(textarea, file, 408, 48, 13068);
			attr_dev(div0, "class", "float-left");
			add_location(div0, file, 407, 44, 12993);
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*icon_class*/ ctx[2]) + " svelte-jbhpzi"));
			add_location(span, file, 422, 48, 14048);
			attr_dev(div1, "class", "float-left pointer pt-1 ml-2 delete_column height35 top1 position-relative");
			attr_dev(div1, "tab-index", "0");
			add_location(div1, file, 417, 44, 13694);
			attr_dev(th, "key", th_key_value = /*i*/ ctx[25]);
			attr_dev(th, "class", th_class_value = "" + (null_to_empty("middle_align text-center " + /*data*/ ctx[23].id) + " svelte-jbhpzi"));

			set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
			? "#5B9BD5"
			: /*state*/ ctx[0].theme == "theme2"
				? "#3B67BC"
				: /*state*/ ctx[0].theme == "theme3"
					? "#F6C3A2"
					: /*state*/ ctx[0].theme == "theme4"
						? "#70AD47"
						: "#745998");

			add_location(th, file, 402, 40, 12540);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, div0);
			append_dev(div0, textarea);
			append_dev(th, t0);
			append_dev(th, div1);
			append_dev(div1, span);
			append_dev(th, t1);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", /*updateOptionValue*/ ctx[5], false, false, false),
					listen_dev(
						div1,
						"click",
						function () {
							if (is_function(/*removeOption*/ ctx[9].bind(this, /*data*/ ctx[23].id))) /*removeOption*/ ctx[9].bind(this, /*data*/ ctx[23].id).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 1 && textarea_id_value !== (textarea_id_value = /*data*/ ctx[23].id)) {
				attr_dev(textarea, "id", textarea_id_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[23].text)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1 && th_class_value !== (th_class_value = "" + (null_to_empty("middle_align text-center " + /*data*/ ctx[23].id) + " svelte-jbhpzi"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
				? "#5B9BD5"
				: /*state*/ ctx[0].theme == "theme2"
					? "#3B67BC"
					: /*state*/ ctx[0].theme == "theme3"
						? "#F6C3A2"
						: /*state*/ ctx[0].theme == "theme4"
							? "#70AD47"
							: "#745998");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(402:36) {#each state.cdata.option as data,i}",
		ctx
	});

	return block;
}

// (431:28) {#if state.cdata}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*state*/ ctx[0].cdata.term;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, setCorrectAns, removeTerm, icon_class, updateTermValue*/ 1301) {
				each_value = /*state*/ ctx[0].cdata.term;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(431:28) {#if state.cdata}",
		ctx
	});

	return block;
}

// (450:40) {#each state.cdata.option as data2,j}
function create_each_block_1(ctx) {
	let td;
	let label;
	let input;
	let input_value_value;
	let input_name_value;
	let input_id_value;
	let input_data_correct_value;
	let label_for_value;
	let td_key_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			label = element("label");
			input = element("input");
			attr_dev(input, "type", "radio");
			attr_dev(input, "class", "preview_radio align-middle");
			input.value = input_value_value = /*data2*/ ctx[26].id;
			attr_dev(input, "name", input_name_value = /*i*/ ctx[25] + 1);
			attr_dev(input, "id", input_id_value = "a" + /*i*/ ctx[25] + /*j*/ ctx[28]);
			attr_dev(input, "data-correct", input_data_correct_value = /*data*/ ctx[23].correct);
			add_location(input, file, 454, 56, 16525);
			attr_dev(label, "class", "label_choice pointer d-block w-100 mb-0");
			attr_dev(label, "for", label_for_value = "a" + /*i*/ ctx[25] + /*j*/ ctx[28]);
			add_location(label, file, 453, 52, 16393);
			attr_dev(td, "class", "text-center align-middle h-auto min_width_125 max_width_150 svelte-jbhpzi");
			attr_dev(td, "key", td_key_value = /*j*/ ctx[28]);

			set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
			? /*state*/ ctx[0].theme == "theme1"
				? "#DEEAF6"
				: /*state*/ ctx[0].theme == "theme2"
					? "#D4DEF1"
					: /*state*/ ctx[0].theme == "theme3"
						? "#FAE0CF"
						: /*state*/ ctx[0].theme == "theme4"
							? "#E2EFD9"
							: "#E1DAE9"
			: "#FFF");

			add_location(td, file, 450, 12, 16005);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, label);
			append_dev(label, input);

			if (!mounted) {
				dispose = listen_dev(input, "click", /*setCorrectAns*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = /*data2*/ ctx[26].id)) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*state*/ 1 && input_data_correct_value !== (input_data_correct_value = /*data*/ ctx[23].correct)) {
				attr_dev(input, "data-correct", input_data_correct_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
				? /*state*/ ctx[0].theme == "theme1"
					? "#DEEAF6"
					: /*state*/ ctx[0].theme == "theme2"
						? "#D4DEF1"
						: /*state*/ ctx[0].theme == "theme3"
							? "#FAE0CF"
							: /*state*/ ctx[0].theme == "theme4"
								? "#E2EFD9"
								: "#E1DAE9"
				: "#FFF");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(450:40) {#each state.cdata.option as data2,j}",
		ctx
	});

	return block;
}

// (432:32) {#each state.cdata.term as data,i}
function create_each_block(ctx) {
	let tr;
	let td;
	let textarea;
	let textarea_id_value;
	let textarea_value_value;
	let t0;
	let div;
	let span;
	let span_class_value;
	let td_class_value;
	let t1;
	let t2;
	let tr_key_value;
	let mounted;
	let dispose;
	let each_value_1 = /*state*/ ctx[0].cdata.option;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");
			td = element("td");
			textarea = element("textarea");
			t0 = space();
			div = element("div");
			span = element("span");
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			attr_dev(textarea, "id", textarea_id_value = /*data*/ ctx[23].id);
			textarea.value = textarea_value_value = /*data*/ ctx[23].text;
			attr_dev(textarea, "class", "form-control form-control-md width96 float-left min_height_38 svelte-jbhpzi");
			set_style(textarea, "outline", "none");
			set_style(textarea, "height", "38px");
			add_location(textarea, file, 434, 44, 14904);
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*icon_class*/ ctx[2]) + " svelte-jbhpzi"));
			add_location(span, file, 446, 48, 15783);
			attr_dev(div, "class", "pointer pt-1 mt-sm2 ml-2 delete_row height34 svelte-jbhpzi");
			attr_dev(div, "tab-index", "0");
			add_location(div, file, 441, 44, 15424);
			attr_dev(td, "class", td_class_value = "" + (null_to_empty("min_width_200 h-auto " + /*data*/ ctx[23].id) + " svelte-jbhpzi"));
			set_style(td, "font-weight", "bold");

			set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
			? /*state*/ ctx[0].theme == "theme1"
				? "#DEEAF6"
				: /*state*/ ctx[0].theme == "theme2"
					? "#D4DEF1"
					: /*state*/ ctx[0].theme == "theme3"
						? "#FAE0CF"
						: /*state*/ ctx[0].theme == "theme4"
							? "#E2EFD9"
							: "#E1DAE9"
			: "#FFF");

			add_location(td, file, 433, 40, 14563);
			attr_dev(tr, "key", tr_key_value = /*i*/ ctx[25]);
			add_location(tr, file, 432, 36, 14510);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			append_dev(td, textarea);
			append_dev(td, t0);
			append_dev(td, div);
			append_dev(div, span);
			append_dev(tr, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t2);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*updateTermValue*/ ctx[4], false, false, false),
					listen_dev(
						div,
						"click",
						function () {
							if (is_function(/*removeTerm*/ ctx[8].bind(this, /*data*/ ctx[23].id))) /*removeTerm*/ ctx[8].bind(this, /*data*/ ctx[23].id).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 1 && textarea_id_value !== (textarea_id_value = /*data*/ ctx[23].id)) {
				attr_dev(textarea, "id", textarea_id_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[23].text)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1 && td_class_value !== (td_class_value = "" + (null_to_empty("min_width_200 h-auto " + /*data*/ ctx[23].id) + " svelte-jbhpzi"))) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
				? /*state*/ ctx[0].theme == "theme1"
					? "#DEEAF6"
					: /*state*/ ctx[0].theme == "theme2"
						? "#D4DEF1"
						: /*state*/ ctx[0].theme == "theme3"
							? "#FAE0CF"
							: /*state*/ ctx[0].theme == "theme4"
								? "#E2EFD9"
								: "#E1DAE9"
				: "#FFF");
			}

			if (dirty[0] & /*state, setCorrectAns*/ 1025) {
				each_value_1 = /*state*/ ctx[0].cdata.option;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(432:32) {#each state.cdata.term as data,i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let link;
	let t0;
	let main;
	let div6;
	let div5;
	let div4;
	let div1;
	let div0;
	let label0;
	let t2;
	let select;
	let select_value_value;
	let t3;
	let label1;
	let t5;
	let input;
	let input_value_value;
	let t6;
	let span;
	let t8;
	let div2;
	let table;
	let thead;
	let tr;
	let th;
	let textarea;
	let textarea_value_value;
	let textarea_style_value;
	let t9;
	let t10;
	let tbody;
	let t11;
	let small;
	let strong;
	let t14;
	let t15_value = Lang.comment_choiceMatrix + "";
	let t15;
	let t16;
	let div3;
	let button0;
	let button0_style_value;
	let t18;
	let button1;
	let button1_style_value;
	let div3_style_value;
	let mounted;
	let dispose;
	let each_value_3 = /*themeOption*/ ctx[1];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let if_block0 = /*state*/ ctx[0].cdata && create_if_block_1(ctx);
	let if_block1 = /*state*/ ctx[0].cdata && create_if_block(ctx);

	const block = {
		c: function create() {
			link = element("link");
			t0 = space();
			main = element("main");
			div6 = element("div");
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = `${Lang.themes}`;
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			label1 = element("label");
			label1.textContent = `${Lang.table_width}`;
			t5 = space();
			input = element("input");
			t6 = space();
			span = element("span");
			span.textContent = "px";
			t8 = space();
			div2 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th = element("th");
			textarea = element("textarea");
			t9 = space();
			if (if_block0) if_block0.c();
			t10 = space();
			tbody = element("tbody");
			if (if_block1) if_block1.c();
			t11 = space();
			small = element("small");
			strong = element("strong");
			strong.textContent = `* ${Lang.note_label}`;
			t14 = space();
			t15 = text(t15_value);
			t16 = space();
			div3 = element("div");
			button0 = element("button");
			button0.textContent = `${Lang.add_row}`;
			t18 = space();
			button1 = element("button");
			button1.textContent = `${Lang.add_column}`;
			attr_dev(link, "href", "./choiceMatrix.css");
			attr_dev(link, "rel", "stylesheet");
			add_location(link, file, 9, 1, 239);
			attr_dev(label0, "for", "select_themes");
			attr_dev(label0, "class", "mb-0 pl-1 mt-2 mr-2 float-left");
			add_location(label0, file, 351, 6, 10058);
			attr_dev(select, "class", "form-control form-control-md px-2 enroll_date_td width150 float-left svelte-jbhpzi");
			attr_dev(select, "id", "select_themes");
			attr_dev(select, "name", "select_themes");
			add_location(select, file, 357, 24, 10209);
			attr_dev(label1, "for", "customWidth");
			attr_dev(label1, "class", "mb-0 mt-2 mr-2 ml-2 float-left");
			add_location(label1, file, 367, 6, 10660);
			attr_dev(input, "class", "form-control form-control-md px-2 width90 float-left svelte-jbhpzi");
			attr_dev(input, "step", "10");
			attr_dev(input, "min", "500");
			attr_dev(input, "max", "1000");
			attr_dev(input, "type", "number");
			input.value = input_value_value = parseInt(/*state*/ ctx[0].maxWidth);
			attr_dev(input, "id", "customWidth");
			add_location(input, file, 368, 24, 10776);
			attr_dev(span, "class", "d-inline-block mt-sm pt-sm ml-1 width20 float-left svelte-jbhpzi");
			add_location(span, file, 379, 24, 11136);
			attr_dev(div0, "class", "float-left mb-1 pr-2 ");
			add_location(div0, file, 350, 20, 10014);
			attr_dev(div1, "class", "form-group row full_day mx-0 pt-2 pb-1 w-100 svelte-jbhpzi");
			add_location(div1, file, 348, 16, 9842);
			textarea.value = textarea_value_value = /*state*/ ctx[0].stem;
			attr_dev(textarea, "class", "form-control form-control-md px-2 min_height_38 text-dark svelte-jbhpzi");
			attr_dev(textarea, "style", textarea_style_value = "outline:none;");
			attr_dev(textarea, "cols", "15");
			attr_dev(textarea, "rows", "1");
			add_location(textarea, file, 391, 36, 11889);
			attr_dev(th, "class", "topic_input text-center svelte-jbhpzi");
			attr_dev(th, "id", "hello");

			set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
			? "#5B9BD5"
			: /*state*/ ctx[0].theme == "theme2"
				? "#3B67BC"
				: /*state*/ ctx[0].theme == "theme3"
					? "#F6C3A2"
					: /*state*/ ctx[0].theme == "theme4"
						? "#70AD47"
						: "#745998");

			add_location(th, file, 386, 32, 11559);
			attr_dev(tr, "class", "table-head");
			add_location(tr, file, 385, 28, 11501);
			add_location(thead, file, 384, 24, 11465);
			add_location(tbody, file, 429, 24, 14353);
			attr_dev(table, "class", "table table-bordered relative w-75 ml-0 mt-0 svelte-jbhpzi");
			attr_dev(table, "id", "my_table");
			add_location(table, file, 383, 20, 11362);
			attr_dev(div2, "class", "table-responsive mt-4 d-flex align-items-center");
			add_location(div2, file, 382, 16, 11278);
			add_location(strong, file, 472, 52, 17593);
			attr_dev(small, "class", "text-danger font13");
			add_location(small, file, 472, 16, 17557);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-outline-primary btn-sm add_stem pr-md ml-2 px-2");
			attr_dev(button0, "id", "btn");
			attr_dev(button0, "style", button0_style_value = "width: 171px;");
			add_location(button0, file, 474, 24, 17751);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm add_option pr-md ml-2 px-2");
			attr_dev(button1, "id", "btn_opt");
			attr_dev(button1, "style", button1_style_value = "width: 171px;");
			add_location(button1, file, 484, 6, 18090);
			attr_dev(div3, "class", "text-center");
			attr_dev(div3, "style", div3_style_value = "width:80%;");
			add_location(div3, file, 473, 16, 17676);
			attr_dev(div4, "class", "col-12 col-lg-12 p-0");
			add_location(div4, file, 347, 12, 9789);
			attr_dev(div5, "id", "authoring");
			attr_dev(div5, "class", "p-2 border");
			add_location(div5, file, 346, 8, 9733);
			add_location(div6, file, 345, 4, 9719);
			add_location(main, file, 344, 0, 9708);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			append_dev(document_1.head, link);
			insert_dev(target, t0, anchor);
			insert_dev(target, main, anchor);
			append_dev(main, div6);
			append_dev(div6, div5);
			append_dev(div5, div4);
			append_dev(div4, div1);
			append_dev(div1, div0);
			append_dev(div0, label0);
			append_dev(div0, t2);
			append_dev(div0, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*state*/ ctx[0].theme);
			append_dev(div0, t3);
			append_dev(div0, label1);
			append_dev(div0, t5);
			append_dev(div0, input);
			append_dev(div0, t6);
			append_dev(div0, span);
			append_dev(div4, t8);
			append_dev(div4, div2);
			append_dev(div2, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th);
			append_dev(th, textarea);
			append_dev(tr, t9);
			if (if_block0) if_block0.m(tr, null);
			append_dev(table, t10);
			append_dev(table, tbody);
			if (if_block1) if_block1.m(tbody, null);
			append_dev(div4, t11);
			append_dev(div4, small);
			append_dev(small, strong);
			append_dev(small, t14);
			append_dev(small, t15);
			append_dev(div4, t16);
			append_dev(div4, div3);
			append_dev(div3, button0);
			append_dev(div3, t18);
			append_dev(div3, button1);

			if (!mounted) {
				dispose = [
					listen_dev(select, "click", /*changeTheme*/ ctx[11], false, false, false),
					listen_dev(input, "keyup", /*handleMaxwidth*/ ctx[12].bind(this), false, false, false),
					listen_dev(input, "change", /*handleMaxwidth*/ ctx[12].bind(this), false, false, false),
					listen_dev(textarea, "change", /*updateStem*/ ctx[3], false, false, false),
					listen_dev(button0, "click", /*addStem*/ ctx[6], false, false, false),
					listen_dev(button1, "click", /*addOption*/ ctx[7], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*themeOption*/ 2) {
				each_value_3 = /*themeOption*/ ctx[1];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			if (dirty[0] & /*state*/ 1 && select_value_value !== (select_value_value = /*state*/ ctx[0].theme)) {
				select_option(select, /*state*/ ctx[0].theme);
			}

			if (dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = parseInt(/*state*/ ctx[0].maxWidth))) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[0].stem)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
				? "#5B9BD5"
				: /*state*/ ctx[0].theme == "theme2"
					? "#3B67BC"
					: /*state*/ ctx[0].theme == "theme3"
						? "#F6C3A2"
						: /*state*/ ctx[0].theme == "theme4"
							? "#70AD47"
							: "#745998");
			}

			if (/*state*/ ctx[0].cdata) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(tr, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*state*/ ctx[0].cdata) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(tbody, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			detach_dev(link);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(main);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function reverseCSVFormat(data) {
	// value of stem
	let csvFormat = data.stem + ",";

	// getting values of option and appending it to the csvFormat
	data.option.map(val1 => {
		csvFormat += val1.text + ",";
	});

	csvFormat += "\n";

	data.term.map((val2, j) => {
		// adding the text of term
		csvFormat += val2.text + ",";

		// adding 1,0 n the basis of radio is checked or not
		data.option.map(val1 => {
			csvFormat += val2.correct == val1.id ? "1," : "0,";
		});

		csvFormat += "\n";
	});

	// returning all the appended data
	return csvFormat;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ChoiceMatrix", slots, []);
	let { getChildXml } = $$props;
	let { xml } = $$props;

	// variable declaration
	let themeOption = ["light_blue", "dark_blue", "peach", "green", "purple"];

	let widthVal = "";
	let icon_class = "icomoon-new-24px-delete-1 s3";
	let lastAction;
	let state = {};

	let stateData = writable({
		cdata: "",
		stem: "",
		xml: "",
		theme: "",
		font: "",
		maxWidth: ""
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	////////////    Exectuing each time the xml will change //////////////
	afterUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			loadModule(xml);
		}
	});

	onMount(() => {
		AH.listen(document, "keydown", "textarea", function (event) {
			if (event.keyCode == 13) {
				event.preventDefault();
			}
		});

		document.querySelector(".add_stem, .add_stem").addEventListener("click", function (event) {
			event.preventDefault();
		});

		// try catch block in error handling
		try {
			// check if xml is not blank
			if (xml) {
				// load the module on the basis of xml 
				loadModule(xml);

				// update the cdata accordingly
				reverseXml();
			}
		} catch(e) {
			console.log({
				Error: e.message,
				File: "choiceMatrix",
				Line: "65"
			});
		}

		AH.listen(document, "keydown", ".delete_column", function (_this, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// click the element which currently get the focus and enter key is down
				AH.trigger(_this, "click");

				//_this.dispatchEvent(new Event("click"));
				event.preventDefault();
			}
		});

		AH.listen(document, "keydown", ".delete_row", function (_this, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// click the element which currently get the focus and enter key is down
				_this.dispatchEvent(new Event("click"));

				event.preventDefault();
			}
		});
	});

	// it load the module 
	function loadModule(loadXml) {
		// convert the xml into json and pass it in the parseXMLAuthoring function to parse the xml
		loadXml = XMLToJSON(loadXml);

		parseXMLAuthoring(loadXml);
	}

	// it is used for parsing the xml for authoring area
	function parseXMLAuthoring(MYXML) {
		let formattedData = parseCSV.parseCSVFormat(MYXML.smxml.__cdata);
		let cdata = formattedData;
		let rawData = [];

		// copying the JSON data in the rawData and make it array 
		rawData = JSON.parse(JSON.stringify(cdata));

		$$invalidate(0, state.cdata = rawData, state);
		$$invalidate(0, state.stem = rawData.stem, state);
		$$invalidate(0, state.theme = MYXML.smxml._theme, state);
		$$invalidate(0, state.font = MYXML.smxml._font, state);

		$$invalidate(
			0,
			state.maxWidth = MYXML.smxml._maxwidth
			? parseInt(MYXML.smxml._maxwidth)
			: 800,
			state
		);

		//document.getElementById("msg").value = rawData['stem'];
		//jQuery('#msg').val(rawData.stem); // Need TO FIX
		//	for checking the radio btn according to the xml
		/*	let timer = setTimeout(function() {
		jQuery(".preview_radio").each(function() {
			jQuery(this)[0].checked = ((jQuery(this).attr('value') == jQuery(this).attr('data-correct')) ? true : false);
		});
		clearTimeout(timer);
	}.bind(this),200) // Replaced 
*/
		let timer = setTimeout(
			function () {
				let radio_len1 = document.getElementsByClassName("preview_radio");

				for (let i = 0; i < radio_len1.length; i++) {
					radio_len1[i].checked = radio_len1[i].getAttribute("value") == radio_len1[i].getAttribute("data-correct")
					? true
					: false;
				}

				clearTimeout(timer);
			},
			200
		);
	}

	// calls on change in the stem textarea
	function updateStem(e) {
		$$invalidate(0, state.stem = e.target.value, state);
		$$invalidate(0, state.cdata.stem = e.target.value, state);

		// updaing the cdata
		reverseXml();
	}

	//////////// Update the cdata ///////////////////
	function reverseXml() {
		let csvReverse = reverseCSVFormat(state.cdata);
		csvReverse = csvReverse.replace(/\|\/g, "'").replace(/\|\|\/g, "\"");
		let updatedXml = `<smxml type="27" name="ChoiceMatrix" theme="${state.theme}" font="${state.font}" maxwidth="${state.maxWidth}"><!--[CDATA[${csvReverse}]]--></smxml>`;
		getChildXml(updatedXml);
	}

	function updateTermValue(e) {
		//it update the text of that particular term by finding the id of the changed term textarea
		state.cdata && state.cdata.term.map(function (data, i) {
			if (data.id == e.target.id) {
				data.text = e.target.value;
			}
		});

		// update the cdata
		reverseXml();
	}

	////////////// updating the option ///////////////
	function updateOptionValue(e) {
		//it update the text of that particular option by finding the id of the changed option textarea
		state.cdata && state.cdata.option.map(function (data, i) {
			if (data.id == e.target.id) {
				data.text = e.target.value;
			}
		});

		// update the cdata
		reverseXml();
	}

	///////////  Added row rows  /////////////////
	function addStem() {
		let id = state.cdata.term.length + 1;

		if (id <= 6) {
			state.cdata.term.push({
				id: "t" + id,
				correct: "",
				text: "Term Sample text"
			});

			reverseXml();
		} else {
			AH.alert("Maximum possible value of rows are 6.");
		}
	}

	/////////  This function is added the column  ///////////////
	function addOption() {
		let id = state.cdata.option.length + 1;

		if (id <= 4) {
			state.cdata.option.push({ id: "o" + id, text: "Option" });
			reverseXml();
		} else {
			AH.alert("Maximum possible value of columns are 4.");
		}
	}

	//////////// This function delete the rows /////////////
	function removeTerm(id) {
		if (state.cdata.term.length > 2) {
			let newTerm = [];
			let count = 1;

			state.cdata.term.map(function (data, i) {
				if (data.id == id) {
					state.cdata.term.splice(i, 1);
				}
			});

			state.cdata.term.map(function (data, i) {
				newTerm.push({
					id: "t" + count,
					correct: data.correct,
					text: data.text
				});

				count++;
			});

			$$invalidate(0, state.cdata.term = newTerm, state);
			let radio_len = document.getElementsByClassName("preview_radio");

			for (let i = 0; i < radio_len; i++) {
				radio_len[i].checked = false;
			}

			//updating the cdata
			reverseXml();
		} else {
			AH.showmsg("You must have at least two rows.");
		}
	}

	// when delete btn of option is cliked
	function removeOption(id) {
		// checking min no of option 
		if (state.cdata.option.length > 2) {
			let newOption = [];
			let count = 1;

			// removing that particular option
			state.cdata.option.map(function (data, i) {
				if (data.id == id) {
					state.cdata.option.splice(i, 1);
				}
			});

			state.cdata.option.map(function (data, i) {
				newOption.push({ id: "o" + count, text: data.text });
				count++;
			});

			// remove the correct answer
			removeCorrectAns();

			$$invalidate(0, state.cdata.option = newOption, state);

			// updates the xml
			reverseXml();
		} else {
			AH.alert("You must have at least two columns.");
		}
	}

	// for removing the correct ans
	function removeCorrectAns() {
		state.cdata && state.cdata.term.map(function (data, i) {
			data.correct = "";
		});
	}

	// for setting the correct answer
	function setCorrectAns(e) {
		// getting name of the clicked radio btn to find the index
		let rname = e.target.name;

		let rindex = rname - 1;

		// store the value of target in correct key of the term at that index 
		$$invalidate(0, state.cdata.term[rindex].correct = e.target.value, state);

		reverseXml();
	}

	////// This function is fired then change theme ////////////
	function changeTheme(e) {
		// update the state
		$$invalidate(0, state.theme = e.target.value, state);

		// update the cdata
		reverseXml(); // Remove setTimeout in this place
	}

	// when there is change in table
	function handleMaxwidth() {
		// getting the value of width
		widthVal = document.querySelector("#customWidth").value;

		// setting the width of the table
		//	jQuery('#test_table').width(widthVal+"px"); // Replaced
		document.getElementById("test_table").style.width = widthVal + "px";

		// check for th timeout if exist clear the timeout to save memory
		lastAction ? clearTimeout(lastAction) : "";

		lastAction = setTimeout(
			function () {
				// checking condition that the table width must between the 500 and 1000
				if (widthVal < 500) {
					//// jQuery('#customWidth').val() remove this
					$$invalidate(0, state.maxWidth = 500, state);

					let timer = setTimeout(
						function () {
							reverseXml();
							clearTimeout(timer);
						},
						100
					); //  Fixed

					swal("Width should not be less than 500px");
				}

				if (widthVal > 1000) {
					//// jQuery('#customWidth').val() remove this
					$$invalidate(0, state.maxWidth = 1000, state);

					let timer = setTimeout(
						function () {
							reverseXml();
							clearTimeout(timer);
						},
						100
					); // Fixed

					swal("Width should not be greater than 1000px");
				}
			},
			1500
		);

		// update the state
		$$invalidate(0, state.maxWidth = widthVal, state);

		// update the cdata
		reverseXml();
	}

	const writable_props = ["getChildXml", "xml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<ChoiceMatrix> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("getChildXml" in $$props) $$invalidate(13, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		writable,
		l: Lang,
		lib1: parseCSV,
		XMLToJSON,
		AH,
		getChildXml,
		xml,
		themeOption,
		widthVal,
		icon_class,
		lastAction,
		state,
		stateData,
		unsubscribe,
		loadModule,
		parseXMLAuthoring,
		updateStem,
		reverseXml,
		reverseCSVFormat,
		updateTermValue,
		updateOptionValue,
		addStem,
		addOption,
		removeTerm,
		removeOption,
		removeCorrectAns,
		setCorrectAns,
		changeTheme,
		handleMaxwidth
	});

	$$self.$inject_state = $$props => {
		if ("getChildXml" in $$props) $$invalidate(13, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
		if ("themeOption" in $$props) $$invalidate(1, themeOption = $$props.themeOption);
		if ("widthVal" in $$props) widthVal = $$props.widthVal;
		if ("icon_class" in $$props) $$invalidate(2, icon_class = $$props.icon_class);
		if ("lastAction" in $$props) lastAction = $$props.lastAction;
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("stateData" in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		themeOption,
		icon_class,
		updateStem,
		updateTermValue,
		updateOptionValue,
		addStem,
		addOption,
		removeTerm,
		removeOption,
		setCorrectAns,
		changeTheme,
		handleMaxwidth,
		getChildXml,
		xml
	];
}

class ChoiceMatrix extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-jbhpzi-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { getChildXml: 13, xml: 14 }, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChoiceMatrix",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[13] === undefined && !("getChildXml" in props)) {
			console_1.warn("<ChoiceMatrix> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[14] === undefined && !("xml" in props)) {
			console_1.warn("<ChoiceMatrix> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<ChoiceMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ChoiceMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<ChoiceMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ChoiceMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ChoiceMatrix;
//# sourceMappingURL=ChoiceMatrix-26ac8bf7.js.map
