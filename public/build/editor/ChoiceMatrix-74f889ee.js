
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, C as validate_each_argument, v as validate_slots, a9 as afterUpdate, o as onMount, A as AH, X as XMLToJSON, w as writable, a7 as Lang, h as text, k as add_location, n as insert_dev, B as noop, x as detach_dev, z as empty, K as destroy_each, f as space, j as attr_dev, $ as null_to_empty, l as set_style, q as listen_dev, E as is_function, G as prop_dev, H as run_all, Y as select_option } from './main-6ec656b8.js';
import { p as parseCSV } from './parseCSV-b8df5647.js';

/* clsSMChoiceMatrix\ChoiceMatrix.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMChoiceMatrix\\ChoiceMatrix.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-12kbld3-style";
	style.textContent = ".fa-check.svelte-12kbld3{color:#46A546}.fa-close.svelte-12kbld3{color:#A80000}.fa-close.svelte-12kbld3,.fa-check.svelte-12kbld3{margin-left:9px;font-size:18px}.fa-close.svelte-12kbld3,.fa-check.svelte-12kbld3,.middle_align.svelte-12kbld3{vertical-align:middle!important}.middle_align.svelte-12kbld3{width:164px;min-width:164px}.topic_input.svelte-12kbld3{min-width:257px}.preview_header.svelte-12kbld3{font-size:16pt;font-weight:bold;vertical-align:middle}.adjust_width.svelte-12kbld3{width:12%;text-align:center}.width180.svelte-12kbld3{width:180px}.width150.svelte-12kbld3{width:150px}.full_day.svelte-12kbld3{background-color:#eee !important;color:#000 !important}.width90.svelte-12kbld3{width:90px}.width20.svelte-12kbld3{width:20px}.relative.svelte-12kbld3{position:relative}.min_height_38.svelte-12kbld3{min-height:38px}.min_width_200.svelte-12kbld3{min-width:200px !important}.min_width_125.svelte-12kbld3{min-width:125px}.max_width_150.svelte-12kbld3{max-width:150px !important}.height34.svelte-12kbld3{height:34px !important}.width_90.svelte-12kbld3{width:90%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hvaWNlTWF0cml4LnN2ZWx0ZSIsInNvdXJjZXMiOlsiQ2hvaWNlTWF0cml4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXHJcbiAqICBGaWxlIE5hbWUgICA6IENob2ljZU1hdHJpeC5zdmVsdGVcclxuICogIERlc2NyaXB0aW9uIDogRGVjaWRlZCB0aGUgXCJUZXJtXCIgJiBcIk9wdGlvblwiXHJcbiAqICBBdXRob3IgICAgICA6IFN1bmRhcmFtIFRyaXBhdGhpXHJcbiAqICBQYWNrYWdlICAgICA6IHN2ZWx0ZV9pdGVtc1xyXG4gKiAgTGFzdCB1cGRhdGUgOiAwNS1NYXktMjAyMVxyXG4gKiAgTGFzdCBVcGRhdGVkIEJ5IDogUHJhZGVlcCBZYWRhdlxyXG4tLT5cclxuXHJcbjxzY3JpcHQ+ICBcclxuXHRpbXBvcnQgeyBvbk1vdW50LGFmdGVyVXBkYXRlIH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG5cdGltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xyXG5cdGltcG9ydCBsIGZyb20gJy4uL3NyYy9saWJzL0xhbmcuanMnXHJcblx0aW1wb3J0IGxpYjEgZnJvbSAnLi9wYXJzZUNTVi5qcyc7XHJcblx0aW1wb3J0IHtYTUxUb0pTT04sIEFIfSBmcm9tIFwiLi4vaGVscGVyL0hlbHBlckFJLnN2ZWx0ZVwiO1xyXG5cdGV4cG9ydCBsZXQgZ2V0Q2hpbGRYbWw7XHJcblx0ZXhwb3J0IGxldCB4bWw7XHJcblxyXG5cdC8vIHZhcmlhYmxlIGRlY2xhcmF0aW9uXHJcblx0bGV0IHRoZW1lT3B0aW9uID0gWydsaWdodF9ibHVlJywnZGFya19ibHVlJywncGVhY2gnLCdncmVlbicsJ3B1cnBsZSddO1xyXG5cdGxldCB3aWR0aFZhbCA9IFwiXCI7XHJcblx0bGV0IGljb25fY2xhc3MgPSBcImljb21vb24tbmV3LTI0cHgtZGVsZXRlLTEgczNcIjtcclxuXHRsZXQgbGFzdEFjdGlvbjtcclxuXHRsZXQgc3RhdGUgPSB7fTtcclxuXHRsZXQgc3RhdGVEYXRhID0gd3JpdGFibGUoeyBcclxuXHRcdGNkYXRhIFx0XHQ6IFwiXCIsXHJcblx0XHRzdGVtXHRcdDogXCJcIixcclxuXHRcdHhtbFx0XHRcdDogXCJcIixcclxuXHRcdHRoZW1lXHRcdDogXCJcIixcclxuXHRcdGZvbnRcdFx0OiBcIlwiLFxyXG5cdFx0bWF4V2lkdGhcdDogXCJcIixcclxuXHR9KTtcclxuXHRjb25zdCB1bnN1YnNjcmliZSA9IHN0YXRlRGF0YS5zdWJzY3JpYmUoKGl0ZW1zKSA9PiB7XHJcblx0XHRzdGF0ZSA9IGl0ZW1zO1xyXG5cdH0pXHJcblxyXG5cdFx0Ly8vLy8vLy8vLy8vICAgIEV4ZWN0dWluZyBlYWNoIHRpbWUgdGhlIHhtbCB3aWxsIGNoYW5nZSAvLy8vLy8vLy8vLy8vL1xyXG5cclxuXHRhZnRlclVwZGF0ZSgoKSA9PiB7XHJcblx0XHRpZiAoeG1sIT1zdGF0ZS54bWwpIHtcclxuXHRcdFx0c3RhdGUueG1sID0geG1sO1xyXG5cdFx0XHRsb2FkTW9kdWxlKHhtbCk7IFx0XHJcblx0XHR9XHJcblx0fSlcclxuXHRcclxuICAgIG9uTW91bnQoKCkgPT4ge1x0XHRcclxuXHRcdEFILmxpc3Rlbihkb2N1bWVudCwna2V5ZG93bicsJ3RleHRhcmVhJyxmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykge1xyXG5cdFx0ICAgIFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdCAgICB9XHJcblx0XHR9KVxyXG5cdFx0XHJcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYWRkX3N0ZW0sIC5hZGRfc3RlbScpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9KTtcclxuXHRcdC8vIHRyeSBjYXRjaCBibG9jayBpbiBlcnJvciBoYW5kbGluZ1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gY2hlY2sgaWYgeG1sIGlzIG5vdCBibGFua1xyXG4gICAgICAgICAgICBpZiAoeG1sKSB7XHJcblx0XHRcdFx0Ly8gbG9hZCB0aGUgbW9kdWxlIG9uIHRoZSBiYXNpcyBvZiB4bWwgXHJcblx0XHRcdFx0bG9hZE1vZHVsZSh4bWwpO1xyXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgY2RhdGEgYWNjb3JkaW5nbHlcclxuXHRcdFx0XHRyZXZlcnNlWG1sKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coe0Vycm9yOmUubWVzc2FnZSwgRmlsZTpcImNob2ljZU1hdHJpeFwiLCBMaW5lOlwiNjVcIn0pO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRBSC5saXN0ZW4oZG9jdW1lbnQsJ2tleWRvd24nLCcuZGVsZXRlX2NvbHVtbicsIGZ1bmN0aW9uKF90aGlzLCBldmVudCkge1xyXG5cdFx0XHRpZiAoKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQud2hpY2ggPT0gMTMpKSB7XHJcblx0XHRcdC8vIGNsaWNrIHRoZSBlbGVtZW50IHdoaWNoIGN1cnJlbnRseSBnZXQgdGhlIGZvY3VzIGFuZCBlbnRlciBrZXkgaXMgZG93blxyXG5cdFx0XHRBSC50cmlnZ2VyKF90aGlzLCAnY2xpY2snKTtcclxuXHRcdFx0Ly9fdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNsaWNrXCIpKTtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0QUgubGlzdGVuKGRvY3VtZW50LCdrZXlkb3duJywnLmRlbGV0ZV9yb3cnLCBmdW5jdGlvbihfdGhpcyxldmVudCkge1xyXG5cdFx0XHRpZiAoKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQud2hpY2ggPT0gMTMpKSB7XHJcblx0XHRcdC8vIGNsaWNrIHRoZSBlbGVtZW50IHdoaWNoIGN1cnJlbnRseSBnZXQgdGhlIGZvY3VzIGFuZCBlbnRlciBrZXkgaXMgZG93blxyXG5cdFx0XHRfdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNsaWNrXCIpKTtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHJcblx0fSlcclxuXHJcblx0Ly8gaXQgbG9hZCB0aGUgbW9kdWxlIFxyXG5cdGZ1bmN0aW9uIGxvYWRNb2R1bGUobG9hZFhtbCkge1xyXG5cdFx0Ly8gY29udmVydCB0aGUgeG1sIGludG8ganNvbiBhbmQgcGFzcyBpdCBpbiB0aGUgcGFyc2VYTUxBdXRob3JpbmcgZnVuY3Rpb24gdG8gcGFyc2UgdGhlIHhtbFxyXG5cdFx0bG9hZFhtbCA9IFhNTFRvSlNPTihsb2FkWG1sKTtcclxuXHRcdHBhcnNlWE1MQXV0aG9yaW5nKGxvYWRYbWwpO1xyXG5cdH1cclxuXHJcblx0Ly8gaXQgaXMgdXNlZCBmb3IgcGFyc2luZyB0aGUgeG1sIGZvciBhdXRob3JpbmcgYXJlYVxyXG5cdGZ1bmN0aW9uIHBhcnNlWE1MQXV0aG9yaW5nKE1ZWE1MKSB7XHJcbiAgICAgICAgbGV0IGZvcm1hdHRlZERhdGEgPSBsaWIxLnBhcnNlQ1NWRm9ybWF0KE1ZWE1MLnNteG1sLl9fY2RhdGEpO1xyXG5cdFx0bGV0IGNkYXRhID0gZm9ybWF0dGVkRGF0YTtcclxuXHRcdGxldCByYXdEYXRhID0gW107XHJcblx0XHQvLyBjb3B5aW5nIHRoZSBKU09OIGRhdGEgaW4gdGhlIHJhd0RhdGEgYW5kIG1ha2UgaXQgYXJyYXkgXHJcblx0XHRcclxuXHQgICAgcmF3RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2RhdGEpKTtcclxuXHRcdHN0YXRlLmNkYXRhID0gcmF3RGF0YTtcclxuXHRcdHN0YXRlLnN0ZW0gPSByYXdEYXRhLnN0ZW07XHJcblx0XHRzdGF0ZS50aGVtZSA9IE1ZWE1MLnNteG1sLl90aGVtZTtcclxuXHRcdHN0YXRlLmZvbnQgPSBNWVhNTC5zbXhtbC5fZm9udDtcclxuXHRcdHN0YXRlLm1heFdpZHRoID0gKChNWVhNTC5zbXhtbC5fbWF4d2lkdGgpP3BhcnNlSW50KE1ZWE1MLnNteG1sLl9tYXh3aWR0aCk6ODAwKTtcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHQvL2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXNnXCIpLnZhbHVlID0gcmF3RGF0YVsnc3RlbSddO1xyXG5cdFx0XHQvL2pRdWVyeSgnI21zZycpLnZhbChyYXdEYXRhLnN0ZW0pOyAvLyBOZWVkIFRPIEZJWFxyXG5cdFx0XHRcclxuXHRcdFxyXG5cclxuXHRcdC8vXHRmb3IgY2hlY2tpbmcgdGhlIHJhZGlvIGJ0biBhY2NvcmRpbmcgdG8gdGhlIHhtbFxyXG5cdFx0LypcdGxldCB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0alF1ZXJ5KFwiLnByZXZpZXdfcmFkaW9cIikuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGpRdWVyeSh0aGlzKVswXS5jaGVja2VkID0gKChqUXVlcnkodGhpcykuYXR0cigndmFsdWUnKSA9PSBqUXVlcnkodGhpcykuYXR0cignZGF0YS1jb3JyZWN0JykpID8gdHJ1ZSA6IGZhbHNlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xyXG5cdFx0XHR9LmJpbmQodGhpcyksMjAwKSAvLyBSZXBsYWNlZCBcclxuXHRcdCovXHJcblxyXG5cdFx0bGV0IHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0bGV0IHJhZGlvX2xlbjEgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwcmV2aWV3X3JhZGlvJyk7XHJcblx0XHRcdGZvcihsZXQgaSA9IDA7IGk8cmFkaW9fbGVuMS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHJhZGlvX2xlbjFbaV0uY2hlY2tlZCA9ICgocmFkaW9fbGVuMVtpXS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgPT0gcmFkaW9fbGVuMVtpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29ycmVjdCcpKSA/IHRydWUgOiBmYWxzZSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XHJcblx0XHR9LDIwMClcclxuXHR9XHJcblxyXG5cdC8vIGNhbGxzIG9uIGNoYW5nZSBpbiB0aGUgc3RlbSB0ZXh0YXJlYVxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0ZW0oZSkge1xyXG4gICAgICAgIHN0YXRlLnN0ZW0gPSBlLnRhcmdldC52YWx1ZVxyXG5cdFx0c3RhdGUuY2RhdGEuc3RlbSA9IGUudGFyZ2V0LnZhbHVlO1xyXG5cdFx0Ly8gdXBkYWluZyB0aGUgY2RhdGFcclxuXHRcdHJldmVyc2VYbWwoKTtcclxuXHR9XHJcblxyXG5cdC8vLy8vLy8vLy8vLyBVcGRhdGUgdGhlIGNkYXRhIC8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHRmdW5jdGlvbiByZXZlcnNlWG1sKCkge1xyXG5cdFx0bGV0IGNzdlJldmVyc2UgPSByZXZlcnNlQ1NWRm9ybWF0KHN0YXRlLmNkYXRhKTtcclxuXHRcdGNzdlJldmVyc2UgPSBjc3ZSZXZlcnNlLnJlcGxhY2UoL1xc4oCZfFxc4oCyL2csXCInXCIpLnJlcGxhY2UoL1xc4oCzfFxc4oCcfFxc4oCdL2csXCJcXFwiXCIpO1xyXG5cdFx0bGV0IHVwZGF0ZWRYbWwgPSBgPHNteG1sIHR5cGU9XCIyN1wiIG5hbWU9XCJDaG9pY2VNYXRyaXhcIiB0aGVtZT1cIiR7c3RhdGUudGhlbWV9XCIgZm9udD1cIiR7c3RhdGUuZm9udH1cIiBtYXh3aWR0aD1cIiR7c3RhdGUubWF4V2lkdGh9XCI+PCEtLVtDREFUQVske2NzdlJldmVyc2V9XV0tLT48L3NteG1sPmA7XHJcblx0XHRnZXRDaGlsZFhtbCh1cGRhdGVkWG1sKTsgICAgXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gaXQgZm9ybWF0IHRoZSBjZGF0YVxyXG5cdGZ1bmN0aW9uIHJldmVyc2VDU1ZGb3JtYXQoZGF0YSkge1xyXG5cdFx0Ly8gdmFsdWUgb2Ygc3RlbVxyXG5cdFx0bGV0IGNzdkZvcm1hdCA9IGRhdGEuc3RlbStcIixcIjtcclxuXHRcdC8vIGdldHRpbmcgdmFsdWVzIG9mIG9wdGlvbiBhbmQgYXBwZW5kaW5nIGl0IHRvIHRoZSBjc3ZGb3JtYXRcclxuXHRcdGRhdGEub3B0aW9uLm1hcCgodmFsMSk9PiB7XHJcblx0XHRcdGNzdkZvcm1hdCArPSB2YWwxLnRleHQrXCIsXCI7XHJcblx0XHR9KTtcclxuXHRcdGNzdkZvcm1hdCArPSBcIlxcblwiO1xyXG5cclxuXHRcdGRhdGEudGVybS5tYXAoKHZhbDIsaik9PiB7XHJcblx0XHRcdC8vIGFkZGluZyB0aGUgdGV4dCBvZiB0ZXJtXHJcblx0XHRcdGNzdkZvcm1hdCArPSB2YWwyLnRleHQrXCIsXCI7XHJcblxyXG5cdFx0XHQvLyBhZGRpbmcgMSwwIG4gdGhlIGJhc2lzIG9mIHJhZGlvIGlzIGNoZWNrZWQgb3Igbm90XHJcblx0XHRcdGRhdGEub3B0aW9uLm1hcCgodmFsMSk9PiB7XHJcblx0XHRcdFx0Y3N2Rm9ybWF0ICs9ICggKHZhbDIuY29ycmVjdCA9PSB2YWwxLmlkKSA/IFwiMSxcIiA6IFwiMCxcIiApO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y3N2Rm9ybWF0ICs9IFwiXFxuXCI7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyByZXR1cm5pbmcgYWxsIHRoZSBhcHBlbmRlZCBkYXRhXHJcblx0XHRyZXR1cm4gY3N2Rm9ybWF0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlVGVybVZhbHVlKGUpIHtcclxuXHRcdC8vaXQgdXBkYXRlIHRoZSB0ZXh0IG9mIHRoYXQgcGFydGljdWxhciB0ZXJtIGJ5IGZpbmRpbmcgdGhlIGlkIG9mIHRoZSBjaGFuZ2VkIHRlcm0gdGV4dGFyZWFcclxuXHRcdHN0YXRlLmNkYXRhICYmIChzdGF0ZS5jZGF0YS50ZXJtLm1hcChmdW5jdGlvbihkYXRhLCBpKSB7XHJcblx0XHRcdGlmIChkYXRhLmlkID09IGUudGFyZ2V0LmlkKSB7XHJcblx0XHRcdFx0ZGF0YS50ZXh0ID0gZS50YXJnZXQudmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH0pKTtcclxuXHRcdC8vIHVwZGF0ZSB0aGUgY2RhdGFcclxuXHRcdHJldmVyc2VYbWwoKTtcclxuXHR9XHJcblxyXG5cdC8vLy8vLy8vLy8vLy8vIHVwZGF0aW5nIHRoZSBvcHRpb24gLy8vLy8vLy8vLy8vLy8vXHJcblx0ZnVuY3Rpb24gdXBkYXRlT3B0aW9uVmFsdWUoZSkge1xyXG5cdFx0Ly9pdCB1cGRhdGUgdGhlIHRleHQgb2YgdGhhdCBwYXJ0aWN1bGFyIG9wdGlvbiBieSBmaW5kaW5nIHRoZSBpZCBvZiB0aGUgY2hhbmdlZCBvcHRpb24gdGV4dGFyZWFcclxuXHRcdHN0YXRlLmNkYXRhICYmIChzdGF0ZS5jZGF0YS5vcHRpb24ubWFwKGZ1bmN0aW9uKGRhdGEsIGkpIHtcclxuXHRcdFx0aWYgKGRhdGEuaWQgPT0gZS50YXJnZXQuaWQpIHtcclxuXHRcdFx0XHRkYXRhLnRleHQgPSBlLnRhcmdldC52YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSkpO1xyXG5cdFx0Ly8gdXBkYXRlIHRoZSBjZGF0YVxyXG5cdFx0cmV2ZXJzZVhtbCgpO1xyXG5cdH1cclxuXHJcblx0Ly8vLy8vLy8vLy8gIEFkZGVkIHJvdyByb3dzICAvLy8vLy8vLy8vLy8vLy8vL1xyXG5cdGZ1bmN0aW9uIGFkZFN0ZW0oKSB7XHJcblx0XHRsZXQgaWQgPSAoc3RhdGUuY2RhdGEudGVybS5sZW5ndGggKyAxKTtcclxuXHRcdGlmIChpZCA8PSA2KSB7XHJcblx0XHRcdHN0YXRlLmNkYXRhLnRlcm0ucHVzaCh7aWQ6IFwidFwiICsgaWQsIGNvcnJlY3Q6IFwiXCIsIHRleHQ6IFwiVGVybSBTYW1wbGUgdGV4dFwifSk7XHJcblx0XHRcdHJldmVyc2VYbWwoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEFILmFsZXJ0KCdNYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9mIHJvd3MgYXJlIDYuJyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLy8vLy8vLy8gIFRoaXMgZnVuY3Rpb24gaXMgYWRkZWQgdGhlIGNvbHVtbiAgLy8vLy8vLy8vLy8vLy8vXHJcblx0ZnVuY3Rpb24gYWRkT3B0aW9uKCkge1xyXG4gICAgICAgIGxldCBpZCA9IChzdGF0ZS5jZGF0YS5vcHRpb24ubGVuZ3RoICsgMSk7XHJcblx0XHRpZiAoaWQgPD0gNCkge1xyXG5cdFx0XHRzdGF0ZS5jZGF0YS5vcHRpb24ucHVzaCh7aWQ6IFwib1wiICsgaWQsIHRleHQ6IFwiT3B0aW9uXCJ9KTtcclxuXHRcdFx0cmV2ZXJzZVhtbCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0QUguYWxlcnQoJ01heGltdW0gcG9zc2libGUgdmFsdWUgb2YgY29sdW1ucyBhcmUgNC4nKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vLy8vLy8vLy8vLyBUaGlzIGZ1bmN0aW9uIGRlbGV0ZSB0aGUgcm93cyAvLy8vLy8vLy8vLy8vXHJcblx0ZnVuY3Rpb24gcmVtb3ZlVGVybShpZCkge1xyXG5cdFx0aWYoc3RhdGUuY2RhdGEudGVybS5sZW5ndGggPiAyKSB7XHJcblx0XHRcdGxldCBuZXdUZXJtID0gW107XHJcblx0XHRcdGxldCBjb3VudCA9IDE7XHJcblx0XHRcdHN0YXRlLmNkYXRhLnRlcm0ubWFwKGZ1bmN0aW9uKGRhdGEsaSkge1xyXG5cdFx0XHRcdGlmKGRhdGEuaWQgPT0gaWQpIHtcclxuXHRcdFx0XHRcdHN0YXRlLmNkYXRhLnRlcm0uc3BsaWNlKGksMSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTsgXHJcblx0XHRcdHN0YXRlLmNkYXRhLnRlcm0ubWFwKGZ1bmN0aW9uKGRhdGEsaSkge1xyXG5cdFx0XHRcdFx0bmV3VGVybS5wdXNoKHtcclxuXHRcdFx0XHRcdFx0aWQ6XCJ0XCIrY291bnQsXHJcblx0XHRcdFx0XHRcdGNvcnJlY3Q6ZGF0YS5jb3JyZWN0LFxyXG5cdFx0XHRcdFx0XHR0ZXh0OmRhdGEudGV4dFxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRzdGF0ZS5jZGF0YS50ZXJtID0gbmV3VGVybTtcclxuXHJcblx0XHRcdGxldCByYWRpb19sZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwcmV2aWV3X3JhZGlvJyk7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmFkaW9fbGVuOyBpKyspIHtcclxuXHRcdFx0XHRyYWRpb19sZW5baV0uY2hlY2tlZCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vdXBkYXRpbmcgdGhlIGNkYXRhXHJcblx0XHRcdHJldmVyc2VYbWwoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEFILnNob3dtc2coXCJZb3UgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byByb3dzLlwiKTsgIFxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gd2hlbiBkZWxldGUgYnRuIG9mIG9wdGlvbiBpcyBjbGlrZWRcclxuXHRmdW5jdGlvbiByZW1vdmVPcHRpb24oaWQpIHtcclxuXHRcdC8vIGNoZWNraW5nIG1pbiBubyBvZiBvcHRpb24gXHJcblx0XHRpZiAoc3RhdGUuY2RhdGEub3B0aW9uLmxlbmd0aCA+IDIpIHtcclxuXHRcdFx0bGV0IG5ld09wdGlvbiA9IFtdO1xyXG5cdFx0XHRsZXQgY291bnQgPSAxO1xyXG5cdFx0XHQvLyByZW1vdmluZyB0aGF0IHBhcnRpY3VsYXIgb3B0aW9uXHJcblx0XHRcdHN0YXRlLmNkYXRhLm9wdGlvbi5tYXAoZnVuY3Rpb24oZGF0YSxpKSB7XHJcblx0XHRcdFx0aWYgKGRhdGEuaWQgPT0gaWQpIHtcclxuXHRcdFx0XHRcdHN0YXRlLmNkYXRhLm9wdGlvbi5zcGxpY2UoaSwxKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRcclxuXHRcdFx0c3RhdGUuY2RhdGEub3B0aW9uLm1hcChmdW5jdGlvbihkYXRhLGkpIHtcclxuXHRcdFx0XHRuZXdPcHRpb24ucHVzaCh7XHJcblx0XHRcdFx0XHRpZDpcIm9cIitjb3VudCxcclxuXHRcdFx0XHRcdHRleHQ6ZGF0YS50ZXh0XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyByZW1vdmUgdGhlIGNvcnJlY3QgYW5zd2VyXHJcblx0XHRcdHJlbW92ZUNvcnJlY3RBbnMoKTtcclxuXHJcblx0XHRcdHN0YXRlLmNkYXRhLm9wdGlvbiA9IG5ld09wdGlvbjtcclxuXHRcdFx0Ly8gdXBkYXRlcyB0aGUgeG1sXHJcblx0XHRcdHJldmVyc2VYbWwoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEFILmFsZXJ0KFwiWW91IG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gY29sdW1ucy5cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgcmVtb3ZpbmcgdGhlIGNvcnJlY3QgYW5zXHJcblx0ZnVuY3Rpb24gcmVtb3ZlQ29ycmVjdEFucygpIHtcclxuXHRcdHN0YXRlLmNkYXRhICYmIChzdGF0ZS5jZGF0YS50ZXJtLm1hcChmdW5jdGlvbihkYXRhLGkpIHtcclxuXHRcdFx0ZGF0YS5jb3JyZWN0ID0gXCJcIjtcclxuXHRcdH0pKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBzZXR0aW5nIHRoZSBjb3JyZWN0IGFuc3dlclxyXG5cdGZ1bmN0aW9uIHNldENvcnJlY3RBbnMoZSkge1xyXG5cdFx0Ly8gZ2V0dGluZyBuYW1lIG9mIHRoZSBjbGlja2VkIHJhZGlvIGJ0biB0byBmaW5kIHRoZSBpbmRleFxyXG5cdFx0bGV0IHJuYW1lID0gZS50YXJnZXQubmFtZTtcclxuXHRcdGxldCByaW5kZXggPSBybmFtZSAtIDE7XHJcblx0XHQvLyBzdG9yZSB0aGUgdmFsdWUgb2YgdGFyZ2V0IGluIGNvcnJlY3Qga2V5IG9mIHRoZSB0ZXJtIGF0IHRoYXQgaW5kZXggXHJcblx0XHRzdGF0ZS5jZGF0YS50ZXJtW3JpbmRleF0uY29ycmVjdCA9IGUudGFyZ2V0LnZhbHVlO1xyXG5cdFx0cmV2ZXJzZVhtbCgpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8vLy8vLyBUaGlzIGZ1bmN0aW9uIGlzIGZpcmVkIHRoZW4gY2hhbmdlIHRoZW1lIC8vLy8vLy8vLy8vL1xyXG5cdGZ1bmN0aW9uIGNoYW5nZVRoZW1lKGUpIHtcclxuXHRcdC8vIHVwZGF0ZSB0aGUgc3RhdGVcclxuICAgICAgICBzdGF0ZS50aGVtZSA9IGUudGFyZ2V0LnZhbHVlO1xyXG5cdFx0Ly8gdXBkYXRlIHRoZSBjZGF0YVxyXG5cdFx0cmV2ZXJzZVhtbCgpOyAvLyBSZW1vdmUgc2V0VGltZW91dCBpbiB0aGlzIHBsYWNlXHJcblx0fVxyXG5cclxuXHQvLyB3aGVuIHRoZXJlIGlzIGNoYW5nZSBpbiB0YWJsZVxyXG5cdGZ1bmN0aW9uIGhhbmRsZU1heHdpZHRoKCkge1xyXG5cdFx0Ly8gZ2V0dGluZyB0aGUgdmFsdWUgb2Ygd2lkdGhcclxuXHRcdHdpZHRoVmFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2N1c3RvbVdpZHRoJykudmFsdWU7XHJcblx0XHQvLyBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgdGFibGVcclxuXHQvL1x0alF1ZXJ5KCcjdGVzdF90YWJsZScpLndpZHRoKHdpZHRoVmFsK1wicHhcIik7IC8vIFJlcGxhY2VkXHJcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlc3RfdGFibGUnKS5zdHlsZS53aWR0aCA9IHdpZHRoVmFsICsncHgnO1xyXG5cclxuXHRcdC8vIGNoZWNrIGZvciB0aCB0aW1lb3V0IGlmIGV4aXN0IGNsZWFyIHRoZSB0aW1lb3V0IHRvIHNhdmUgbWVtb3J5XHJcblx0XHQobGFzdEFjdGlvbikgPyBjbGVhclRpbWVvdXQobGFzdEFjdGlvbikgOiBcIlwiO1xyXG5cdFx0bGFzdEFjdGlvbiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IFxyXG5cdFx0XHQvLyBjaGVja2luZyBjb25kaXRpb24gdGhhdCB0aGUgdGFibGUgd2lkdGggbXVzdCBiZXR3ZWVuIHRoZSA1MDAgYW5kIDEwMDBcclxuXHRcdFx0XHJcblx0XHRcdGlmICh3aWR0aFZhbCA8IDUwMCkgeyAgLy8vLyBqUXVlcnkoJyNjdXN0b21XaWR0aCcpLnZhbCgpIHJlbW92ZSB0aGlzXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYXhXaWR0aCA9IDUwMDtcclxuXHRcdFx0XHRsZXQgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXZlcnNlWG1sKCk7IGNsZWFyVGltZW91dCh0aW1lcik7IH0sMTAwKTsgIC8vICBGaXhlZFxyXG5cdFx0XHRcdHN3YWwoXCJXaWR0aCBzaG91bGQgbm90IGJlIGxlc3MgdGhhbiA1MDBweFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAod2lkdGhWYWwgPiAxMDAwKSB7IC8vLy8galF1ZXJ5KCcjY3VzdG9tV2lkdGgnKS52YWwoKSByZW1vdmUgdGhpc1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYXhXaWR0aCA9IDEwMDA7XHJcblx0XHRcdFx0bGV0IHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgcmV2ZXJzZVhtbCgpOyBjbGVhclRpbWVvdXQodGltZXIpOyB9LDEwMCk7ICAvLyBGaXhlZFxyXG5cdFx0XHRcdHN3YWwoXCJXaWR0aCBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMDAwcHhcIik7XHJcblx0XHRcdH0gXHJcblx0XHR9LDE1MDApO1xyXG5cdFx0Ly8gdXBkYXRlIHRoZSBzdGF0ZVxyXG4gICAgICAgIHN0YXRlLm1heFdpZHRoID0gd2lkdGhWYWw7XHJcblx0XHQvLyB1cGRhdGUgdGhlIGNkYXRhXHJcblx0XHRyZXZlcnNlWG1sKCk7IFxyXG5cdH1cclxuPC9zY3JpcHQ+XHJcblxyXG48bWFpbj5cclxuICAgIDxkaXY+XHJcbiAgICAgICAgPGRpdiBpZCA9IFwiYXV0aG9yaW5nXCIgY2xhc3MgPSBcInAtMiBib3JkZXJcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFwiY29sLTEyIGNvbC1sZy0xMiBwLTBcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3MgPSBcImZvcm0tZ3JvdXAgcm93IGZ1bGxfZGF5IG14LTAgcHQtMiBwYi0xIHctMTAwXCI+XHJcblx0XHRcdFx0PCEtLSA8bGFiZWwgZm9yID0gXCJzZWxlY3RfdGhlbWVzXCIgY2xhc3MgPSBcIm1iLTAgcGwtMSBtdC0yIG1yLTJcIj57bC50aGVtZXN9PC9sYWJlbD4gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFwiZmxvYXQtbGVmdCBtYi0xIHByLTIgXCI+XHJcblx0XHRcdFx0XHRcdDxsYWJlbCBcclxuXHRcdFx0XHRcdFx0XHRmb3IgPSBcInNlbGVjdF90aGVtZXNcIiBcclxuXHRcdFx0XHRcdFx0XHRjbGFzcyA9IFwibWItMCBwbC0xIG10LTIgbXItMiBmbG9hdC1sZWZ0XCJcclxuXHRcdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRcdHtsLnRoZW1lc31cclxuXHRcdFx0XHRcdFx0PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBvbjpjbGljayA9IHtjaGFuZ2VUaGVtZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtzdGF0ZS50aGVtZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzID0gXCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLW1kIHB4LTIgZW5yb2xsX2RhdGVfdGQgd2lkdGgxNTAgZmxvYXQtbGVmdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IFwic2VsZWN0X3RoZW1lc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJzZWxlY3RfdGhlbWVzXCJcclxuXHRcdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRcdHsjZWFjaCB0aGVtZU9wdGlvbiBhcyB0aGVtZSwgaX1cclxuXHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWUgPSBcInRoZW1leysraX1cIj57bFt0aGVtZV19PC9vcHRpb24+XHJcblx0XHRcdFx0XHRcdFx0ey9lYWNofVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD4gXHJcblx0XHRcdFx0XHRcdDxsYWJlbCBmb3IgPSBcImN1c3RvbVdpZHRoXCIgY2xhc3MgPSBcIm1iLTAgbXQtMiBtci0yIG1sLTIgZmxvYXQtbGVmdFwiPntsLnRhYmxlX3dpZHRofTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBcclxuXHRcdFx0XHRcdFx0XHRjbGFzcyA9IFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1tZCBweC0yIHdpZHRoOTAgZmxvYXQtbGVmdFwiIFxyXG5cdFx0XHRcdFx0XHRcdHN0ZXAgPSBcIjEwXCIgXHJcblx0XHRcdFx0XHRcdFx0bWluID0gXCI1MDBcIiBcclxuXHRcdFx0XHRcdFx0XHRtYXggPSBcIjEwMDBcIiBcclxuXHRcdFx0XHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIiBcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZT17cGFyc2VJbnQoc3RhdGUubWF4V2lkdGgpfSBcclxuXHRcdFx0XHRcdFx0XHRpZCA9IFwiY3VzdG9tV2lkdGhcIiBcclxuXHRcdFx0XHRcdFx0XHRvbjprZXl1cCA9IHtoYW5kbGVNYXh3aWR0aC5iaW5kKHRoaXMpfSBcclxuXHRcdFx0XHRcdFx0XHRvbjpjaGFuZ2UgPSB7aGFuZGxlTWF4d2lkdGguYmluZCh0aGlzKX0gXHJcblx0XHRcdFx0XHRcdC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzID0nZC1pbmxpbmUtYmxvY2sgbXQtMiBtbC0xIHdpZHRoMjAgZmxvYXQtbGVmdCc+cHg8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3MgPSBcInRhYmxlLXJlc3BvbnNpdmUgbXQtNCBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzID0gXCJ0YWJsZSB0YWJsZS1ib3JkZXJlZCByZWxhdGl2ZSB3LTEwMCBtbC0wIG10LTBcIiBpZCA9IFwibXlfdGFibGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzID0gXCJ0YWJsZS1oZWFkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzcyA9IFwidG9waWNfaW5wdXQgdGV4dC1jZW50ZXJcIiBcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWQgPSBcImhlbGxvXCIgXHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlID0gXCJiYWNrZ3JvdW5kLWNvbG9yOnsoKHN0YXRlLnRoZW1lID09ICd0aGVtZTEnKSA/IFwiIzVCOUJENVwiOiAoKHN0YXRlLnRoZW1lID09ICd0aGVtZTInKSA/IFwiIzNCNjdCQ1wiOiAoKHN0YXRlLnRoZW1lID09ICd0aGVtZTMnKSA/IFwiI0Y2QzNBMlwiOiAoKHN0YXRlLnRoZW1lID09ICd0aGVtZTQnKSA/IFwiIzcwQUQ0N1wiOiBcIiM3NDU5OThcIikpKSl9XCJcclxuXHRcdFx0XHRcdFx0XHRcdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2UgPSB7dXBkYXRlU3RlbX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtzdGF0ZS5zdGVtfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtbWQgcHgtMiBtaW5faGVpZ2h0XzM4IHRleHQtZGFya1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsnb3V0bGluZTpub25lOyd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xzPVwiMTVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cz1cIjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHN0YXRlLmNkYXRhfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggc3RhdGUuY2RhdGEub3B0aW9uIGFzIGRhdGEsaX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHtpfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IHtcIm1pZGRsZV9hbGlnbiB0ZXh0LWNlbnRlciBcIiArIGRhdGEuaWR9IFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3R5bGUgPSBcImJhY2tncm91bmQtY29sb3I6IHsoKHN0YXRlLnRoZW1lID09ICd0aGVtZTEnKSA/IFwiIzVCOUJENVwiOiAoKHN0YXRlLnRoZW1lID09ICd0aGVtZTInKSA/IFwiIzNCNjdCQ1wiOiAoKHN0YXRlLnRoZW1lID09ICd0aGVtZTMnKSA/IFwiI0Y2QzNBMlwiOiAoKHN0YXRlLnRoZW1lID09ICd0aGVtZTQnKSA/IFwiIzcwQUQ0N1wiOiBcIiM3NDU5OThcIikpKSl9XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzID0gXCJmbG9hdC1sZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0ge2RhdGEuaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2UgPSB7dXBkYXRlT3B0aW9uVmFsdWV9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7ZGF0YS50ZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtbWQgcHgtMiBtaW5faGVpZ2h0XzM4IHRleHQtZGFya1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xzID1cIjEwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MgPVwiMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZsb2F0LWxlZnQgcG9pbnRlciBwdC0xIG1sLTIgZGVsZXRlX2NvbHVtbiBoZWlnaHQzNSB0b3AxIHBvc2l0aW9uLXJlbGF0aXZlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7cmVtb3ZlT3B0aW9uLmJpbmQodGhpcyxkYXRhLmlkKX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGFiLWluZGV4ID0gXCIwXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzID0ge2ljb25fY2xhc3N9Pjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5jZGF0YX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggc3RhdGUuY2RhdGEudGVybSBhcyBkYXRhLGl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBrZXk9e2l9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkICBjbGFzcyA9IHtcIm1pbl93aWR0aF8yMDAgaC1hdXRvIFwiICsgZGF0YS5pZH0gc3R5bGUgPSBcImZvbnQtd2VpZ2h0OiBib2xkOyBiYWNrZ3JvdW5kLWNvbG9yOnsoKChpICUgMikgPT0gMCk/KChzdGF0ZS50aGVtZSA9PSAndGhlbWUxJykgPyBcIiNERUVBRjZcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWUyJykgPyBcIiNENERFRjFcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWUzJykgPyBcIiNGQUUwQ0ZcIjogKChzdGF0ZS50aGVtZSA9PSAndGhlbWU0JykgPyBcIiNFMkVGRDlcIjogXCIjRTFEQUU5XCIpKSkpOiBcIiNGRkZcIil9XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHtkYXRhLmlkfSAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmlucHV0ID0ge3VwZGF0ZVRlcm1WYWx1ZX0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge2RhdGEudGV4dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtbWQgd2lkdGhfOTAgZmxvYXQtbGVmdCBtaW5faGVpZ2h0XzM4IG1yLTJcIiBzdHlsZSA9IFwib3V0bGluZTogbm9uZTtoZWlnaHQ6IDM4cHg7XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwicG9pbnRlciBwdC0xIG10LXNtMiBtbC0yIGRlbGV0ZV9yb3cgaGVpZ2h0MzRcIiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7cmVtb3ZlVGVybS5iaW5kKHRoaXMsZGF0YS5pZCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYi1pbmRleCA9IFwiMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcyA9IHtpY29uX2NsYXNzfT48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHN0YXRlLmNkYXRhLm9wdGlvbiBhcyBkYXRhMixqfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8dGQgY2xhc3MgPSBcInRleHQtY2VudGVyIGFsaWduLW1pZGRsZSBoLWF1dG8gbWluX3dpZHRoXzEyNSBtYXhfd2lkdGhfMTUwXCIga2V5PXtqfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjp7KCgoaSAlIDIpID09IDApPygoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMScpID8gXCIjREVFQUY2XCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMicpID8gXCIjRDRERUYxXCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lMycpID8gXCIjRkFFMENGXCI6ICgoc3RhdGUudGhlbWUgPT0gJ3RoZW1lNCcpID8gXCIjRTJFRkQ5XCI6IFwiI0UxREFFOVwiKSkpKTogXCIjRkZGXCIpfVwiXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcyA9IFwibGFiZWxfY2hvaWNlIHBvaW50ZXIgZC1ibG9jayB3LTEwMCBtYi0wXCIgZm9yPXsnYScrKGkpKyhqKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJyYWRpb1wiIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwicHJldmlld19yYWRpbyBhbGlnbi1taWRkbGVcIiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7ZGF0YTIuaWR9ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHtpKzF9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHsnYScrKGkpKyhqKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7c2V0Q29ycmVjdEFuc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1jb3JyZWN0ID0ge2RhdGEuY29ycmVjdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcyA9IFwidGV4dC1kYW5nZXIgZm9udDEzXCI+PHN0cm9uZz4qIHtsLm5vdGVfbGFiZWx9PC9zdHJvbmc+IHtsLmNvbW1lbnRfY2hvaWNlTWF0cml4fTwvc21hbGw+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzID0gXCJ0ZXh0LWNlbnRlclwiIHN0eWxlID0geyd3aWR0aDoxMDAlOyd9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiYnV0dG9uXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGFkZF9zdGVtIHByLW1kIG1sLTIgcHgtMlwiIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcImJ0blwiIFxyXG5cdFx0XHRcdFx0XHRcdG9uOmNsaWNrID0ge2FkZFN0ZW19XHJcblx0XHRcdFx0XHRcdFx0c3R5bGUgPSB7J3dpZHRoOiAxNzFweDsnfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bC5hZGRfcm93fVxyXG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cclxuXHJcblx0XHRcdFx0XHRcdDxidXR0b24gIFxyXG5cdFx0XHRcdFx0XHR0eXBlID0gXCJidXR0b25cIiBcclxuXHRcdFx0XHRcdFx0Y2xhc3MgPSBcImJ0biBidG4tb3V0bGluZS1wcmltYXJ5IGJ0bi1zbSBhZGRfb3B0aW9uIHByLW1kIG1sLTIgcHgtMlwiIFxyXG5cdFx0XHRcdFx0XHRpZCA9IFwiYnRuX29wdFwiIFxyXG5cdFx0XHRcdFx0XHRvbjpjbGljayA9IHthZGRPcHRpb259XHJcblx0XHRcdFx0XHRcdHN0eWxlID0geyd3aWR0aDogMTcxcHg7J31cclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0e2wuYWRkX2NvbHVtbn1cclxuXHRcdFx0XHRcdDwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0XHRcclxuICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PiAgIFxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvbWFpbj5cclxuPHN0eWxlPlxyXG5cclxuLmZhLWNoZWNrIHtcclxuXHRjb2xvcjogIzQ2QTU0NjtcclxufVxyXG5cclxuLmZhLWNsb3NlIHtcclxuXHRjb2xvcjogI0E4MDAwMDtcclxufVxyXG5cclxuLmZhLWNsb3NlLFxyXG4uZmEtY2hlY2sge1xyXG5cdG1hcmdpbi1sZWZ0OiA5cHg7XHJcblx0Zm9udC1zaXplOiAxOHB4O1xyXG59XHJcblxyXG4uZmEtY2xvc2UsXHJcbi5mYS1jaGVjayxcclxuLm1pZGRsZV9hbGlnbiB7XHJcblx0dmVydGljYWwtYWxpZ246IG1pZGRsZSFpbXBvcnRhbnQ7XHJcbn1cclxuXHJcbi5taWRkbGVfYWxpZ24ge1xyXG5cdHdpZHRoOiAxNjRweDtcclxuXHRtaW4td2lkdGg6IDE2NHB4O1xyXG59XHJcblxyXG4udG9waWNfaW5wdXQge1xyXG5cdG1pbi13aWR0aDogMjU3cHg7XHJcbn1cclxuXHJcbi5wcmV2aWV3X2hlYWRlciB7XHJcblx0Zm9udC1zaXplOiAxNnB0O1xyXG5cdGZvbnQtd2VpZ2h0OiBib2xkO1xyXG5cdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XHJcbn1cclxuXHJcbi5hZGp1c3Rfd2lkdGgge1xyXG4gICAgd2lkdGg6IDEyJTtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxufVxyXG5cclxuLndpZHRoMTgwIHtcclxuXHR3aWR0aDogMTgwcHg7XHJcbn1cclxuXHJcbi53aWR0aDE1MCB7XHJcblx0d2lkdGg6IDE1MHB4O1xyXG59XHJcblxyXG4uZnVsbF9kYXkge1xyXG5cdGJhY2tncm91bmQtY29sb3I6ICNlZWUgIWltcG9ydGFudDtcclxuXHRjb2xvcjogIzAwMCAhaW1wb3J0YW50O1xyXG59XHJcblxyXG5cclxuLndpZHRoOTAgIHtcclxuXHR3aWR0aDogOTBweDtcclxufVxyXG5cclxuLndpZHRoMjAge1xyXG5cdHdpZHRoOiAyMHB4O1xyXG59XHJcblxyXG4ucmVsYXRpdmUgeyBcclxuXHRwb3NpdGlvbjogcmVsYXRpdmU7XHJcbn1cclxuXHJcbi5taW5faGVpZ2h0XzM4IHtcclxuXHRtaW4taGVpZ2h0OiAzOHB4O1xyXG59XHJcblxyXG4ubWluX3dpZHRoXzIwMCAge1xyXG5cdG1pbi13aWR0aDogMjAwcHggIWltcG9ydGFudDtcclxufVxyXG5cclxuLm1pbl93aWR0aF8xMjUgIHtcclxuXHRtaW4td2lkdGg6IDEyNXB4O1xyXG59XHJcblxyXG4ubWF4X3dpZHRoXzE1MCB7ICBcclxuXHRtYXgtd2lkdGg6IDE1MHB4ICFpbXBvcnRhbnQ7XHJcbn1cclxuXHJcbi5oZWlnaHQzNCAge1xyXG5cdGhlaWdodDogMzRweCAhaW1wb3J0YW50O1xyXG59XHJcblxyXG4ud2lkdGhfOTAge1xyXG5cdHdpZHRoOiA5MCU7XHJcbn1cclxuXHJcblxyXG5cclxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbWZBLFNBQVMsZUFBQyxDQUFDLEFBQ1YsS0FBSyxDQUFFLE9BQU8sQUFDZixDQUFDLEFBRUQsU0FBUyxlQUFDLENBQUMsQUFDVixLQUFLLENBQUUsT0FBTyxBQUNmLENBQUMsQUFFRCx3QkFBUyxDQUNULFNBQVMsZUFBQyxDQUFDLEFBQ1YsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsU0FBUyxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVELHdCQUFTLENBQ1Qsd0JBQVMsQ0FDVCxhQUFhLGVBQUMsQ0FBQyxBQUNkLGNBQWMsQ0FBRSxNQUFNLFVBQVUsQUFDakMsQ0FBQyxBQUVELGFBQWEsZUFBQyxDQUFDLEFBQ2QsS0FBSyxDQUFFLEtBQUssQ0FDWixTQUFTLENBQUUsS0FBSyxBQUNqQixDQUFDLEFBRUQsWUFBWSxlQUFDLENBQUMsQUFDYixTQUFTLENBQUUsS0FBSyxBQUNqQixDQUFDLEFBRUQsZUFBZSxlQUFDLENBQUMsQUFDaEIsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsSUFBSSxDQUNqQixjQUFjLENBQUUsTUFBTSxBQUN2QixDQUFDLEFBRUQsYUFBYSxlQUFDLENBQUMsQUFDWCxLQUFLLENBQUUsR0FBRyxDQUNWLFVBQVUsQ0FBRSxNQUFNLEFBQ3RCLENBQUMsQUFFRCxTQUFTLGVBQUMsQ0FBQyxBQUNWLEtBQUssQ0FBRSxLQUFLLEFBQ2IsQ0FBQyxBQUVELFNBQVMsZUFBQyxDQUFDLEFBQ1YsS0FBSyxDQUFFLEtBQUssQUFDYixDQUFDLEFBRUQsU0FBUyxlQUFDLENBQUMsQUFDVixnQkFBZ0IsQ0FBRSxJQUFJLENBQUMsVUFBVSxDQUNqQyxLQUFLLENBQUUsSUFBSSxDQUFDLFVBQVUsQUFDdkIsQ0FBQyxBQUdELFFBQVEsZUFBRSxDQUFDLEFBQ1YsS0FBSyxDQUFFLElBQUksQUFDWixDQUFDLEFBRUQsUUFBUSxlQUFDLENBQUMsQUFDVCxLQUFLLENBQUUsSUFBSSxBQUNaLENBQUMsQUFFRCxTQUFTLGVBQUMsQ0FBQyxBQUNWLFFBQVEsQ0FBRSxRQUFRLEFBQ25CLENBQUMsQUFFRCxjQUFjLGVBQUMsQ0FBQyxBQUNmLFVBQVUsQ0FBRSxJQUFJLEFBQ2pCLENBQUMsQUFFRCxjQUFjLGVBQUUsQ0FBQyxBQUNoQixTQUFTLENBQUUsS0FBSyxDQUFDLFVBQVUsQUFDNUIsQ0FBQyxBQUVELGNBQWMsZUFBRSxDQUFDLEFBQ2hCLFNBQVMsQ0FBRSxLQUFLLEFBQ2pCLENBQUMsQUFFRCxjQUFjLGVBQUMsQ0FBQyxBQUNmLFNBQVMsQ0FBRSxLQUFLLENBQUMsVUFBVSxBQUM1QixDQUFDLEFBRUQsU0FBUyxlQUFFLENBQUMsQUFDWCxNQUFNLENBQUUsSUFBSSxDQUFDLFVBQVUsQUFDeEIsQ0FBQyxBQUVELFNBQVMsZUFBQyxDQUFDLEFBQ1YsS0FBSyxDQUFFLEdBQUcsQUFDWCxDQUFDIn0= */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	child_ctx[28] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

// (361:7) {#each themeOption as theme, i}
function create_each_block_3(ctx) {
	let option;
	let t_value = Lang[/*theme*/ ctx[30]] + "";
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = "theme" + ++/*i*/ ctx[25];
			option.value = option.__value;
			add_location(option, file, 361, 8, 10838);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(361:7) {#each themeOption as theme, i}",
		ctx
	});

	return block;
}

// (398:32) {#if state.cdata}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value_2 = /*state*/ ctx[0].cdata.option;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, removeOption, icon_class, updateOptionValue*/ 549) {
				each_value_2 = /*state*/ ctx[0].cdata.option;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(398:32) {#if state.cdata}",
		ctx
	});

	return block;
}

// (399:36) {#each state.cdata.option as data,i}
function create_each_block_2(ctx) {
	let th;
	let div0;
	let textarea;
	let textarea_id_value;
	let textarea_value_value;
	let t0;
	let div1;
	let span;
	let span_class_value;
	let t1;
	let th_key_value;
	let th_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			th = element("th");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			div1 = element("div");
			span = element("span");
			t1 = space();
			attr_dev(textarea, "id", textarea_id_value = /*data*/ ctx[23].id);
			textarea.value = textarea_value_value = /*data*/ ctx[23].text;
			attr_dev(textarea, "class", "form-control form-control-md px-2 min_height_38 text-dark svelte-12kbld3");
			attr_dev(textarea, "cols", "10");
			attr_dev(textarea, "rows", "1");
			add_location(textarea, file, 405, 48, 13389);
			attr_dev(div0, "class", "float-left");
			add_location(div0, file, 404, 44, 13313);
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*icon_class*/ ctx[2]) + " svelte-12kbld3"));
			add_location(span, file, 419, 48, 14383);
			attr_dev(div1, "class", "float-left pointer pt-1 ml-2 delete_column height35 top1 position-relative");
			attr_dev(div1, "tab-index", "0");
			add_location(div1, file, 414, 44, 14024);
			attr_dev(th, "key", th_key_value = /*i*/ ctx[25]);
			attr_dev(th, "class", th_class_value = "" + (null_to_empty("middle_align text-center " + /*data*/ ctx[23].id) + " svelte-12kbld3"));

			set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
			? "#5B9BD5"
			: /*state*/ ctx[0].theme == "theme2"
				? "#3B67BC"
				: /*state*/ ctx[0].theme == "theme3"
					? "#F6C3A2"
					: /*state*/ ctx[0].theme == "theme4"
						? "#70AD47"
						: "#745998");

			add_location(th, file, 399, 40, 12855);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, div0);
			append_dev(div0, textarea);
			append_dev(th, t0);
			append_dev(th, div1);
			append_dev(div1, span);
			append_dev(th, t1);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", /*updateOptionValue*/ ctx[5], false, false, false),
					listen_dev(
						div1,
						"click",
						function () {
							if (is_function(/*removeOption*/ ctx[9].bind(this, /*data*/ ctx[23].id))) /*removeOption*/ ctx[9].bind(this, /*data*/ ctx[23].id).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 1 && textarea_id_value !== (textarea_id_value = /*data*/ ctx[23].id)) {
				attr_dev(textarea, "id", textarea_id_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[23].text)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1 && th_class_value !== (th_class_value = "" + (null_to_empty("middle_align text-center " + /*data*/ ctx[23].id) + " svelte-12kbld3"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
				? "#5B9BD5"
				: /*state*/ ctx[0].theme == "theme2"
					? "#3B67BC"
					: /*state*/ ctx[0].theme == "theme3"
						? "#F6C3A2"
						: /*state*/ ctx[0].theme == "theme4"
							? "#70AD47"
							: "#745998");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(399:36) {#each state.cdata.option as data,i}",
		ctx
	});

	return block;
}

// (428:28) {#if state.cdata}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*state*/ ctx[0].cdata.term;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, setCorrectAns, removeTerm, icon_class, updateTermValue*/ 1301) {
				each_value = /*state*/ ctx[0].cdata.term;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(428:28) {#if state.cdata}",
		ctx
	});

	return block;
}

// (447:40) {#each state.cdata.option as data2,j}
function create_each_block_1(ctx) {
	let td;
	let label;
	let input;
	let input_value_value;
	let input_name_value;
	let input_id_value;
	let input_data_correct_value;
	let label_for_value;
	let td_key_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			label = element("label");
			input = element("input");
			attr_dev(input, "type", "radio");
			attr_dev(input, "class", "preview_radio align-middle");
			input.value = input_value_value = /*data2*/ ctx[26].id;
			attr_dev(input, "name", input_name_value = /*i*/ ctx[25] + 1);
			attr_dev(input, "id", input_id_value = "a" + /*i*/ ctx[25] + /*j*/ ctx[28]);
			attr_dev(input, "data-correct", input_data_correct_value = /*data*/ ctx[23].correct);
			add_location(input, file, 451, 56, 16898);
			attr_dev(label, "class", "label_choice pointer d-block w-100 mb-0");
			attr_dev(label, "for", label_for_value = "a" + /*i*/ ctx[25] + /*j*/ ctx[28]);
			add_location(label, file, 450, 52, 16765);
			attr_dev(td, "class", "text-center align-middle h-auto min_width_125 max_width_150 svelte-12kbld3");
			attr_dev(td, "key", td_key_value = /*j*/ ctx[28]);

			set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
			? /*state*/ ctx[0].theme == "theme1"
				? "#DEEAF6"
				: /*state*/ ctx[0].theme == "theme2"
					? "#D4DEF1"
					: /*state*/ ctx[0].theme == "theme3"
						? "#FAE0CF"
						: /*state*/ ctx[0].theme == "theme4"
							? "#E2EFD9"
							: "#E1DAE9"
			: "#FFF");

			add_location(td, file, 447, 12, 16374);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, label);
			append_dev(label, input);

			if (!mounted) {
				dispose = listen_dev(input, "click", /*setCorrectAns*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = /*data2*/ ctx[26].id)) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*state*/ 1 && input_data_correct_value !== (input_data_correct_value = /*data*/ ctx[23].correct)) {
				attr_dev(input, "data-correct", input_data_correct_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
				? /*state*/ ctx[0].theme == "theme1"
					? "#DEEAF6"
					: /*state*/ ctx[0].theme == "theme2"
						? "#D4DEF1"
						: /*state*/ ctx[0].theme == "theme3"
							? "#FAE0CF"
							: /*state*/ ctx[0].theme == "theme4"
								? "#E2EFD9"
								: "#E1DAE9"
				: "#FFF");
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(447:40) {#each state.cdata.option as data2,j}",
		ctx
	});

	return block;
}

// (429:32) {#each state.cdata.term as data,i}
function create_each_block(ctx) {
	let tr;
	let td;
	let textarea;
	let textarea_id_value;
	let textarea_value_value;
	let t0;
	let div;
	let span;
	let span_class_value;
	let td_class_value;
	let t1;
	let t2;
	let tr_key_value;
	let mounted;
	let dispose;
	let each_value_1 = /*state*/ ctx[0].cdata.option;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");
			td = element("td");
			textarea = element("textarea");
			t0 = space();
			div = element("div");
			span = element("span");
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			attr_dev(textarea, "id", textarea_id_value = /*data*/ ctx[23].id);
			textarea.value = textarea_value_value = /*data*/ ctx[23].text;
			attr_dev(textarea, "class", "form-control form-control-md width_90 float-left min_height_38 mr-2 svelte-12kbld3");
			set_style(textarea, "outline", "none");
			set_style(textarea, "height", "38px");
			add_location(textarea, file, 431, 44, 15251);
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*icon_class*/ ctx[2]) + " svelte-12kbld3"));
			add_location(span, file, 443, 48, 16148);
			attr_dev(div, "class", "pointer pt-1 mt-sm2 ml-2 delete_row height34 svelte-12kbld3");
			attr_dev(div, "tab-index", "0");
			add_location(div, file, 438, 44, 15784);
			attr_dev(td, "class", td_class_value = "" + (null_to_empty("min_width_200 h-auto " + /*data*/ ctx[23].id) + " svelte-12kbld3"));
			set_style(td, "font-weight", "bold");

			set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
			? /*state*/ ctx[0].theme == "theme1"
				? "#DEEAF6"
				: /*state*/ ctx[0].theme == "theme2"
					? "#D4DEF1"
					: /*state*/ ctx[0].theme == "theme3"
						? "#FAE0CF"
						: /*state*/ ctx[0].theme == "theme4"
							? "#E2EFD9"
							: "#E1DAE9"
			: "#FFF");

			add_location(td, file, 430, 40, 14909);
			attr_dev(tr, "key", tr_key_value = /*i*/ ctx[25]);
			add_location(tr, file, 429, 36, 14855);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			append_dev(td, textarea);
			append_dev(td, t0);
			append_dev(td, div);
			append_dev(div, span);
			append_dev(tr, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t2);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*updateTermValue*/ ctx[4], false, false, false),
					listen_dev(
						div,
						"click",
						function () {
							if (is_function(/*removeTerm*/ ctx[8].bind(this, /*data*/ ctx[23].id))) /*removeTerm*/ ctx[8].bind(this, /*data*/ ctx[23].id).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 1 && textarea_id_value !== (textarea_id_value = /*data*/ ctx[23].id)) {
				attr_dev(textarea, "id", textarea_id_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[23].text)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1 && td_class_value !== (td_class_value = "" + (null_to_empty("min_width_200 h-auto " + /*data*/ ctx[23].id) + " svelte-12kbld3"))) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(td, "background-color", /*i*/ ctx[25] % 2 == 0
				? /*state*/ ctx[0].theme == "theme1"
					? "#DEEAF6"
					: /*state*/ ctx[0].theme == "theme2"
						? "#D4DEF1"
						: /*state*/ ctx[0].theme == "theme3"
							? "#FAE0CF"
							: /*state*/ ctx[0].theme == "theme4"
								? "#E2EFD9"
								: "#E1DAE9"
				: "#FFF");
			}

			if (dirty[0] & /*state, setCorrectAns*/ 1025) {
				each_value_1 = /*state*/ ctx[0].cdata.option;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(429:32) {#each state.cdata.term as data,i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div6;
	let div5;
	let div4;
	let div1;
	let div0;
	let label0;
	let t1;
	let select;
	let select_value_value;
	let t2;
	let label1;
	let t4;
	let input;
	let input_value_value;
	let t5;
	let span;
	let t7;
	let div2;
	let table;
	let thead;
	let tr;
	let th;
	let textarea;
	let textarea_value_value;
	let textarea_style_value;
	let t8;
	let t9;
	let tbody;
	let t10;
	let small;
	let strong;
	let t13;
	let t14_value = Lang.comment_choiceMatrix + "";
	let t14;
	let t15;
	let div3;
	let button0;
	let button0_style_value;
	let t17;
	let button1;
	let button1_style_value;
	let div3_style_value;
	let mounted;
	let dispose;
	let each_value_3 = /*themeOption*/ ctx[1];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let if_block0 = /*state*/ ctx[0].cdata && create_if_block_1(ctx);
	let if_block1 = /*state*/ ctx[0].cdata && create_if_block(ctx);

	const block = {
		c: function create() {
			main = element("main");
			div6 = element("div");
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = `${Lang.themes}`;
			t1 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			label1 = element("label");
			label1.textContent = `${Lang.table_width}`;
			t4 = space();
			input = element("input");
			t5 = space();
			span = element("span");
			span.textContent = "px";
			t7 = space();
			div2 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th = element("th");
			textarea = element("textarea");
			t8 = space();
			if (if_block0) if_block0.c();
			t9 = space();
			tbody = element("tbody");
			if (if_block1) if_block1.c();
			t10 = space();
			small = element("small");
			strong = element("strong");
			strong.textContent = `* ${Lang.note_label}`;
			t13 = space();
			t14 = text(t14_value);
			t15 = space();
			div3 = element("div");
			button0 = element("button");
			button0.textContent = `${Lang.add_row}`;
			t17 = space();
			button1 = element("button");
			button1.textContent = `${Lang.add_column}`;
			attr_dev(label0, "for", "select_themes");
			attr_dev(label0, "class", "mb-0 pl-1 mt-2 mr-2 float-left");
			add_location(label0, file, 348, 6, 10328);
			attr_dev(select, "class", "form-control form-control-md px-2 enroll_date_td width150 float-left svelte-12kbld3");
			attr_dev(select, "id", "select_themes");
			attr_dev(select, "name", "select_themes");
			add_location(select, file, 354, 24, 10485);
			attr_dev(label1, "for", "customWidth");
			attr_dev(label1, "class", "mb-0 mt-2 mr-2 ml-2 float-left");
			add_location(label1, file, 364, 6, 10946);
			attr_dev(input, "class", "form-control form-control-md px-2 width90 float-left svelte-12kbld3");
			attr_dev(input, "step", "10");
			attr_dev(input, "min", "500");
			attr_dev(input, "max", "1000");
			attr_dev(input, "type", "number");
			input.value = input_value_value = parseInt(/*state*/ ctx[0].maxWidth);
			attr_dev(input, "id", "customWidth");
			add_location(input, file, 365, 24, 11063);
			attr_dev(span, "class", "d-inline-block mt-2 ml-1 width20 float-left svelte-12kbld3");
			add_location(span, file, 376, 24, 11434);
			attr_dev(div0, "class", "float-left mb-1 pr-2 ");
			add_location(div0, file, 347, 20, 10283);
			attr_dev(div1, "class", "form-group row full_day mx-0 pt-2 pb-1 w-100 svelte-12kbld3");
			add_location(div1, file, 345, 16, 10109);
			textarea.value = textarea_value_value = /*state*/ ctx[0].stem;
			attr_dev(textarea, "class", "form-control form-control-md px-2 min_height_38 text-dark svelte-12kbld3");
			attr_dev(textarea, "style", textarea_style_value = "outline:none;");
			attr_dev(textarea, "cols", "15");
			attr_dev(textarea, "rows", "1");
			add_location(textarea, file, 388, 36, 12193);
			attr_dev(th, "class", "topic_input text-center svelte-12kbld3");
			attr_dev(th, "id", "hello");

			set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
			? "#5B9BD5"
			: /*state*/ ctx[0].theme == "theme2"
				? "#3B67BC"
				: /*state*/ ctx[0].theme == "theme3"
					? "#F6C3A2"
					: /*state*/ ctx[0].theme == "theme4"
						? "#70AD47"
						: "#745998");

			add_location(th, file, 383, 32, 11858);
			attr_dev(tr, "class", "table-head");
			add_location(tr, file, 382, 28, 11799);
			add_location(thead, file, 381, 24, 11762);
			add_location(tbody, file, 426, 24, 14695);
			attr_dev(table, "class", "table table-bordered relative w-100 ml-0 mt-0 svelte-12kbld3");
			attr_dev(table, "id", "my_table");
			add_location(table, file, 380, 20, 11657);
			attr_dev(div2, "class", "table-responsive mt-4 d-flex align-items-center");
			add_location(div2, file, 379, 16, 11572);
			add_location(strong, file, 469, 52, 17984);
			attr_dev(small, "class", "text-danger font13");
			add_location(small, file, 469, 16, 17948);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-outline-primary btn-sm add_stem pr-md ml-2 px-2");
			attr_dev(button0, "id", "btn");
			attr_dev(button0, "style", button0_style_value = "width: 171px;");
			add_location(button0, file, 471, 24, 18145);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm add_option pr-md ml-2 px-2");
			attr_dev(button1, "id", "btn_opt");
			attr_dev(button1, "style", button1_style_value = "width: 171px;");
			add_location(button1, file, 481, 6, 18494);
			attr_dev(div3, "class", "text-center");
			attr_dev(div3, "style", div3_style_value = "width:100%;");
			add_location(div3, file, 470, 16, 18068);
			attr_dev(div4, "class", "col-12 col-lg-12 p-0");
			add_location(div4, file, 344, 12, 10055);
			attr_dev(div5, "id", "authoring");
			attr_dev(div5, "class", "p-2 border");
			add_location(div5, file, 343, 8, 9998);
			add_location(div6, file, 342, 4, 9983);
			add_location(main, file, 341, 0, 9971);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div6);
			append_dev(div6, div5);
			append_dev(div5, div4);
			append_dev(div4, div1);
			append_dev(div1, div0);
			append_dev(div0, label0);
			append_dev(div0, t1);
			append_dev(div0, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*state*/ ctx[0].theme);
			append_dev(div0, t2);
			append_dev(div0, label1);
			append_dev(div0, t4);
			append_dev(div0, input);
			append_dev(div0, t5);
			append_dev(div0, span);
			append_dev(div4, t7);
			append_dev(div4, div2);
			append_dev(div2, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th);
			append_dev(th, textarea);
			append_dev(tr, t8);
			if (if_block0) if_block0.m(tr, null);
			append_dev(table, t9);
			append_dev(table, tbody);
			if (if_block1) if_block1.m(tbody, null);
			append_dev(div4, t10);
			append_dev(div4, small);
			append_dev(small, strong);
			append_dev(small, t13);
			append_dev(small, t14);
			append_dev(div4, t15);
			append_dev(div4, div3);
			append_dev(div3, button0);
			append_dev(div3, t17);
			append_dev(div3, button1);

			if (!mounted) {
				dispose = [
					listen_dev(select, "click", /*changeTheme*/ ctx[11], false, false, false),
					listen_dev(input, "keyup", /*handleMaxwidth*/ ctx[12].bind(this), false, false, false),
					listen_dev(input, "change", /*handleMaxwidth*/ ctx[12].bind(this), false, false, false),
					listen_dev(textarea, "change", /*updateStem*/ ctx[3], false, false, false),
					listen_dev(button0, "click", /*addStem*/ ctx[6], false, false, false),
					listen_dev(button1, "click", /*addOption*/ ctx[7], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*themeOption*/ 2) {
				each_value_3 = /*themeOption*/ ctx[1];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			if (dirty[0] & /*state*/ 1 && select_value_value !== (select_value_value = /*state*/ ctx[0].theme)) {
				select_option(select, /*state*/ ctx[0].theme);
			}

			if (dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = parseInt(/*state*/ ctx[0].maxWidth))) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[0].stem)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(th, "background-color", /*state*/ ctx[0].theme == "theme1"
				? "#5B9BD5"
				: /*state*/ ctx[0].theme == "theme2"
					? "#3B67BC"
					: /*state*/ ctx[0].theme == "theme3"
						? "#F6C3A2"
						: /*state*/ ctx[0].theme == "theme4"
							? "#70AD47"
							: "#745998");
			}

			if (/*state*/ ctx[0].cdata) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(tr, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*state*/ ctx[0].cdata) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(tbody, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function reverseCSVFormat(data) {
	// value of stem
	let csvFormat = data.stem + ",";

	// getting values of option and appending it to the csvFormat
	data.option.map(val1 => {
		csvFormat += val1.text + ",";
	});

	csvFormat += "\n";

	data.term.map((val2, j) => {
		// adding the text of term
		csvFormat += val2.text + ",";

		// adding 1,0 n the basis of radio is checked or not
		data.option.map(val1 => {
			csvFormat += val2.correct == val1.id ? "1," : "0,";
		});

		csvFormat += "\n";
	});

	// returning all the appended data
	return csvFormat;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ChoiceMatrix", slots, []);
	let { getChildXml } = $$props;
	let { xml } = $$props;

	// variable declaration
	let themeOption = ["light_blue", "dark_blue", "peach", "green", "purple"];

	let widthVal = "";
	let icon_class = "icomoon-new-24px-delete-1 s3";
	let lastAction;
	let state = {};

	let stateData = writable({
		cdata: "",
		stem: "",
		xml: "",
		theme: "",
		font: "",
		maxWidth: ""
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	////////////    Exectuing each time the xml will change //////////////
	afterUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			loadModule(xml);
		}
	});

	onMount(() => {
		AH.listen(document, "keydown", "textarea", function (event) {
			if (event.keyCode == 13) {
				event.preventDefault();
			}
		});

		document.querySelector(".add_stem, .add_stem").addEventListener("click", function (event) {
			event.preventDefault();
		});

		// try catch block in error handling
		try {
			// check if xml is not blank
			if (xml) {
				// load the module on the basis of xml 
				loadModule(xml);

				// update the cdata accordingly
				reverseXml();
			}
		} catch(e) {
			console.log({
				Error: e.message,
				File: "choiceMatrix",
				Line: "65"
			});
		}

		AH.listen(document, "keydown", ".delete_column", function (_this, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// click the element which currently get the focus and enter key is down
				AH.trigger(_this, "click");

				//_this.dispatchEvent(new Event("click"));
				event.preventDefault();
			}
		});

		AH.listen(document, "keydown", ".delete_row", function (_this, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// click the element which currently get the focus and enter key is down
				_this.dispatchEvent(new Event("click"));

				event.preventDefault();
			}
		});
	});

	// it load the module 
	function loadModule(loadXml) {
		// convert the xml into json and pass it in the parseXMLAuthoring function to parse the xml
		loadXml = XMLToJSON(loadXml);

		parseXMLAuthoring(loadXml);
	}

	// it is used for parsing the xml for authoring area
	function parseXMLAuthoring(MYXML) {
		let formattedData = parseCSV.parseCSVFormat(MYXML.smxml.__cdata);
		let cdata = formattedData;
		let rawData = [];

		// copying the JSON data in the rawData and make it array 
		rawData = JSON.parse(JSON.stringify(cdata));

		$$invalidate(0, state.cdata = rawData, state);
		$$invalidate(0, state.stem = rawData.stem, state);
		$$invalidate(0, state.theme = MYXML.smxml._theme, state);
		$$invalidate(0, state.font = MYXML.smxml._font, state);

		$$invalidate(
			0,
			state.maxWidth = MYXML.smxml._maxwidth
			? parseInt(MYXML.smxml._maxwidth)
			: 800,
			state
		);

		//document.getElementById("msg").value = rawData['stem'];
		//jQuery('#msg').val(rawData.stem); // Need TO FIX
		//	for checking the radio btn according to the xml
		/*	let timer = setTimeout(function() {
		jQuery(".preview_radio").each(function() {
			jQuery(this)[0].checked = ((jQuery(this).attr('value') == jQuery(this).attr('data-correct')) ? true : false);
		});
		clearTimeout(timer);
	}.bind(this),200) // Replaced 
*/
		let timer = setTimeout(
			function () {
				let radio_len1 = document.getElementsByClassName("preview_radio");

				for (let i = 0; i < radio_len1.length; i++) {
					radio_len1[i].checked = radio_len1[i].getAttribute("value") == radio_len1[i].getAttribute("data-correct")
					? true
					: false;
				}

				clearTimeout(timer);
			},
			200
		);
	}

	// calls on change in the stem textarea
	function updateStem(e) {
		$$invalidate(0, state.stem = e.target.value, state);
		$$invalidate(0, state.cdata.stem = e.target.value, state);

		// updaing the cdata
		reverseXml();
	}

	//////////// Update the cdata ///////////////////
	function reverseXml() {
		let csvReverse = reverseCSVFormat(state.cdata);
		csvReverse = csvReverse.replace(/\’|\′/g, "'").replace(/\″|\“|\”/g, "\"");
		let updatedXml = `<smxml type="27" name="ChoiceMatrix" theme="${state.theme}" font="${state.font}" maxwidth="${state.maxWidth}"><!--[CDATA[${csvReverse}]]--></smxml>`;
		getChildXml(updatedXml);
	}

	function updateTermValue(e) {
		//it update the text of that particular term by finding the id of the changed term textarea
		state.cdata && state.cdata.term.map(function (data, i) {
			if (data.id == e.target.id) {
				data.text = e.target.value;
			}
		});

		// update the cdata
		reverseXml();
	}

	////////////// updating the option ///////////////
	function updateOptionValue(e) {
		//it update the text of that particular option by finding the id of the changed option textarea
		state.cdata && state.cdata.option.map(function (data, i) {
			if (data.id == e.target.id) {
				data.text = e.target.value;
			}
		});

		// update the cdata
		reverseXml();
	}

	///////////  Added row rows  /////////////////
	function addStem() {
		let id = state.cdata.term.length + 1;

		if (id <= 6) {
			state.cdata.term.push({
				id: "t" + id,
				correct: "",
				text: "Term Sample text"
			});

			reverseXml();
		} else {
			AH.alert("Maximum possible value of rows are 6.");
		}
	}

	/////////  This function is added the column  ///////////////
	function addOption() {
		let id = state.cdata.option.length + 1;

		if (id <= 4) {
			state.cdata.option.push({ id: "o" + id, text: "Option" });
			reverseXml();
		} else {
			AH.alert("Maximum possible value of columns are 4.");
		}
	}

	//////////// This function delete the rows /////////////
	function removeTerm(id) {
		if (state.cdata.term.length > 2) {
			let newTerm = [];
			let count = 1;

			state.cdata.term.map(function (data, i) {
				if (data.id == id) {
					state.cdata.term.splice(i, 1);
				}
			});

			state.cdata.term.map(function (data, i) {
				newTerm.push({
					id: "t" + count,
					correct: data.correct,
					text: data.text
				});

				count++;
			});

			$$invalidate(0, state.cdata.term = newTerm, state);
			let radio_len = document.getElementsByClassName("preview_radio");

			for (let i = 0; i < radio_len; i++) {
				radio_len[i].checked = false;
			}

			//updating the cdata
			reverseXml();
		} else {
			AH.showmsg("You must have at least two rows.");
		}
	}

	// when delete btn of option is cliked
	function removeOption(id) {
		// checking min no of option 
		if (state.cdata.option.length > 2) {
			let newOption = [];
			let count = 1;

			// removing that particular option
			state.cdata.option.map(function (data, i) {
				if (data.id == id) {
					state.cdata.option.splice(i, 1);
				}
			});

			state.cdata.option.map(function (data, i) {
				newOption.push({ id: "o" + count, text: data.text });
				count++;
			});

			// remove the correct answer
			removeCorrectAns();

			$$invalidate(0, state.cdata.option = newOption, state);

			// updates the xml
			reverseXml();
		} else {
			AH.alert("You must have at least two columns.");
		}
	}

	// for removing the correct ans
	function removeCorrectAns() {
		state.cdata && state.cdata.term.map(function (data, i) {
			data.correct = "";
		});
	}

	// for setting the correct answer
	function setCorrectAns(e) {
		// getting name of the clicked radio btn to find the index
		let rname = e.target.name;

		let rindex = rname - 1;

		// store the value of target in correct key of the term at that index 
		$$invalidate(0, state.cdata.term[rindex].correct = e.target.value, state);

		reverseXml();
	}

	////// This function is fired then change theme ////////////
	function changeTheme(e) {
		// update the state
		$$invalidate(0, state.theme = e.target.value, state);

		// update the cdata
		reverseXml(); // Remove setTimeout in this place
	}

	// when there is change in table
	function handleMaxwidth() {
		// getting the value of width
		widthVal = document.querySelector("#customWidth").value;

		// setting the width of the table
		//	jQuery('#test_table').width(widthVal+"px"); // Replaced
		document.getElementById("test_table").style.width = widthVal + "px";

		// check for th timeout if exist clear the timeout to save memory
		lastAction ? clearTimeout(lastAction) : "";

		lastAction = setTimeout(
			function () {
				// checking condition that the table width must between the 500 and 1000
				if (widthVal < 500) {
					//// jQuery('#customWidth').val() remove this
					$$invalidate(0, state.maxWidth = 500, state);

					let timer = setTimeout(
						function () {
							reverseXml();
							clearTimeout(timer);
						},
						100
					); //  Fixed

					swal("Width should not be less than 500px");
				}

				if (widthVal > 1000) {
					//// jQuery('#customWidth').val() remove this
					$$invalidate(0, state.maxWidth = 1000, state);

					let timer = setTimeout(
						function () {
							reverseXml();
							clearTimeout(timer);
						},
						100
					); // Fixed

					swal("Width should not be greater than 1000px");
				}
			},
			1500
		);

		// update the state
		$$invalidate(0, state.maxWidth = widthVal, state);

		// update the cdata
		reverseXml();
	}

	const writable_props = ["getChildXml", "xml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<ChoiceMatrix> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("getChildXml" in $$props) $$invalidate(13, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		writable,
		l: Lang,
		lib1: parseCSV,
		XMLToJSON,
		AH,
		getChildXml,
		xml,
		themeOption,
		widthVal,
		icon_class,
		lastAction,
		state,
		stateData,
		unsubscribe,
		loadModule,
		parseXMLAuthoring,
		updateStem,
		reverseXml,
		reverseCSVFormat,
		updateTermValue,
		updateOptionValue,
		addStem,
		addOption,
		removeTerm,
		removeOption,
		removeCorrectAns,
		setCorrectAns,
		changeTheme,
		handleMaxwidth
	});

	$$self.$inject_state = $$props => {
		if ("getChildXml" in $$props) $$invalidate(13, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
		if ("themeOption" in $$props) $$invalidate(1, themeOption = $$props.themeOption);
		if ("widthVal" in $$props) widthVal = $$props.widthVal;
		if ("icon_class" in $$props) $$invalidate(2, icon_class = $$props.icon_class);
		if ("lastAction" in $$props) lastAction = $$props.lastAction;
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("stateData" in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		themeOption,
		icon_class,
		updateStem,
		updateTermValue,
		updateOptionValue,
		addStem,
		addOption,
		removeTerm,
		removeOption,
		setCorrectAns,
		changeTheme,
		handleMaxwidth,
		getChildXml,
		xml
	];
}

class ChoiceMatrix extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-12kbld3-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { getChildXml: 13, xml: 14 }, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChoiceMatrix",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[13] === undefined && !("getChildXml" in props)) {
			console_1.warn("<ChoiceMatrix> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[14] === undefined && !("xml" in props)) {
			console_1.warn("<ChoiceMatrix> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<ChoiceMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ChoiceMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<ChoiceMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ChoiceMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ChoiceMatrix;
//# sourceMappingURL=ChoiceMatrix-74f889ee.js.map
