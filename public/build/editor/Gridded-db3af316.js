
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, C as validate_each_argument, v as validate_slots, L as beforeUpdate, o as onMount, A as AH, a7 as afterUpdate, y as language, w as writable, X as XMLToJSON, M as JSONToXML, z as empty, n as insert_dev, x as detach_dev, c as create_component, f as space, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, j as attr_dev, k as add_location, K as destroy_each, l as set_style, q as listen_dev, r as group_outros, u as check_outros, G as prop_dev, H as run_all, B as noop, h as text } from './main-f818ac0f.js';
import { G as GriddedHelper } from './GriddedHelper-3457493d.js';

/* clsSMGridded/Gridded.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMGridded/Gridded.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1wrfq8n-style";
	style.textContent = ".custom_checkbox_new.svelte-1wrfq8n.svelte-1wrfq8n{display:block;position:relative;width:20px;height:20px;margin-bottom:0;cursor:pointer;font-size:18px}.layoutHeading{font-weight:bold;font-size:16px;color:#1877b1}.items_element:hover{border:1.2px solid #777}.moreOptions{-webkit-box-shadow:3px 4px 6px #c4c5c5;-moz-box-shadow:3px 4px 6px #c4c5c5;box-shadow:3px 4px 6px #c4c5c5;background-color:#f0f0f0;border-top:1px solid #1877b1;border-bottom:1px solid #1877b1}.moreOptionDetails{background-color:#f7f7f7}.input_col{position:relative;left:5px}.layoutheading{padding:5px;font-size:20px;font-weight:bold}.numbr_range{position:relative;left:130px}.numbr_range_txt{position:relative;left:200px}.plus_minus_fraction{position:relative;top:20px}.floating_fraction{position:relative;top:27px}.plus_minus_span{position:relative;left:5px}.floating_decimal{float:right;margin-right:45px}.fontStyle{width:100px;float:right;margin-right:60px}.fraction_slash{position:relative;left:177px}.minus_tab,\n.plus_tab,\n.slash_tab{text-align:center}.gridded_tab.svelte-1wrfq8n.svelte-1wrfq8n{background-color:#f0f0f0;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.font_size_label{position:relative;left:198px}.font_size{position:relative;left:225px}.decimal_col{position:relative;left:208px;width:90px}.correct_color{background-color:#E9FFE9}.fixed_decimal_check{position:relative;top:26px;left:13px}.correct_incorrect_icon_fill{position:relative;width:19px;height:19px;right:121px;top:-55px;background:white;border-radius:50%}.row_column_decimal{position:relative;top:30px;left:5px}.fixed_point_class{position:relative;left:7px}.row_column{position:relative;left:5px}.answer_icon{position:absolute;top:3px;right:34px}.col_range{width:205px}.posSize{position:relative;left:7px}.fontSmall{font-size:12px;text-align:center}.fontNormal{font-size:14px;text-align:center}.fontLarge{font-size:24px;text-align:center}.fontExtraLarge{font-size:26px;text-align:center}.grid{position:relative;top:10px;box-shadow:10px 5px 10px #000}.items_element{border:1px solid #8080807a;padding:6px 10px;border-radius:50%;background-color:white}.griddedModule .active{color:white;transition:1s;background:#696969;border:2px solid #fff}.sla_point{padding:6px 11px}.griddedModule.svelte-1wrfq8n table tr td.svelte-1wrfq8n:last-child{border-right:1px solid #ccc !important}.griddedModule.svelte-1wrfq8n .lastGrid tr:last-child td.svelte-1wrfq8n{border-bottom:1px solid #ccc !important}.griddedModule td{border:1px solid #f0f0f0 !important;border-left:1px solid #ccc !important}.token:hover{border:1px solid #000 !important}.bla .token:hover{border:1px solid #fff !important}.token_selected{background-color:#64bb63;color:#fff}.bla .token_highlight_heading{color:#000 !important}.griddedModule .expandIcon{font-size:27px;font-weight:bold;color:#1877b1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZGRlZC5zdmVsdGUiLCJzb3VyY2VzIjpbIkdyaWRkZWQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS0gXG4gKiAgRmlsZSBOYW1lICAgOiBHcmlkZGVkLmpzXG4gKiAgRGVzY3JpcHRpb24gOiBMYXlvdXQgZGVjaWRlZCBmb3IgZ3JpZGRlZCBzaGVldFxuICogIEF1dGhvciAgICAgIDogU3VuZGFyYW0gVHJpcGF0aGlcbiAqICBWZXJzaW9uICAgICA6IDEuMFxuICogIFBhY2thZ2UgICAgIDogcGUtZ29sZFxuICogIExhc3QgdXBkYXRlIDogMTQtTWFyY2gtMjAyMSAgLS0+XG5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0IGwgZnJvbSAnLi4vc3JjL2xpYnMvZWRpdG9yTGliL2xhbmd1YWdlLmpzJztcbiAgICBpbXBvcnQge3dyaXRhYmxlfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuICAgIGltcG9ydCB7QUgsWE1MVG9KU09OLEpTT05Ub1hNTH0gZnJvbSBcIi4uL2hlbHBlci9IZWxwZXJBSS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50LCBhZnRlclVwZGF0ZSwgYmVmb3JlVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgR3JpZGRlZEhlbHBlciBmcm9tICcuL0dyaWRkZWRIZWxwZXIuc3ZlbHRlJztcblxuXG5cbiAgICBsZXQgc3RhdGUgPSB7fTtcbiAgICBleHBvcnQgbGV0IGdldENoaWxkWG1sO1xuICAgIGxldCBjb3JyZWN0QW5zID0gW107XG5cbiAgICBleHBvcnQgbGV0IHhtbDtcblxuICAgIGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7XG4gICAgICAgICAgICByb3dOdW0gICAgICAgICAgICAgICAgICA6IDQsXG4gICAgICAgICAgICBjb2xOdW0gICAgICAgICAgICAgICAgICA6IDQsXG4gICAgICAgICAgICB0YWJsZU5hbWUgICAgICAgICAgICAgICA6IFwiR3JpZGRlZCBTeXN0ZW1cIixcbiAgICAgICAgICAgIHBsdXNfbWludXMgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHNsYXNoX3ZhbCAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGRlY2ltYWxfdmFsICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHhtbCAgICAgICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICB0ZXh0U2l6ZSAgICAgICAgICAgICAgICA6IDE0LFxuICAgICAgICAgICAgcmVzQW5zICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIGNvcnJlY3RBbnMgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBsaXN0QW5zICAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgcmVzICAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIGZpeGVkX2RlY2ltYWxfdmFsICAgICAgIDogMCxcbiAgICAgICAgICAgIGRlY2ltYWxfcG9pbnQgICAgICAgICAgIDogMCxcbiAgICB9KVxuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdGF0ZURhdGEuc3Vic2NyaWJlKChpdGVtcyk9PntcbiAgICAgICAgc3RhdGUgPSBpdGVtcztcbiAgICB9KVxuXG4gICAgXG5cbiAgICBiZWZvcmVVcGRhdGUoKCk9PntcblxuICAgICAgICBBSS5zZWxlY3RBbGwoJy50ZEZvbnQnLCdjc3MnLHtcbiAgICAgICAgICAgIGZvbnRTaXplOicxNHB4J1xuICAgICAgICB9KVxuICAgIFxuICAgIH0pXG5cblxuICAgIG9uTW91bnQoKCk9PntcbiAgICAgICAgQUgubGlzdGVuKCdib2R5Jywna2V5ZG93bicsJy50ZF9kYXRhJywoKF90aGlzLGUpPT57XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkV2bnRzID0+IFwiLGUpO1xuICAgICAgICAgICAgaWYoZS53aGljaCA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSlcbiAgICB9KVxuXG4gICAgYWZ0ZXJVcGRhdGUoKCk9PntcbiAgICAgICAgXG4gICAgICAgIGlmICh4bWwgIT0gc3RhdGUueG1sKSB7XG4gICAgICAgICAgICBzdGF0ZS54bWwgPSB4bWw7XG4gICAgICAgICAgICBsb2FkTW9kdWxlKHhtbCk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RSb3dJdGVtKCk7XG4gICAgICAgIHNsYXNoRnVuYygpO1xuICAgICAgICBkZWNpbWFsRmxvYXRpbmcoKTtcbiAgICAgICAgcGx1c01pbnVzU2lnbigpO1xuICAgICAgICBjcmVhdGVkU2hlZXRSb3coKTtcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gbG9hZE1vZHVsZShsb2FkWG1sKSB7XG4gICAgICAgIGxvYWRYbWwgPSBYTUxUb0pTT04obG9hZFhtbCk7XG4gICAgICAgIHBhcnNlWE1MQXV0aG9yaW5nKGxvYWRYbWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlWE1MQXV0aG9yaW5nKE1ZWE1MKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucm93TnVtID0gTVlYTUwuc214bWwuX3JvdztcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb2xOdW0gPSBNWVhNTC5zbXhtbC5fY29sO1xuICAgICAgICAgICAgICAgIHN0YXRlLnNsYXNoX3ZhbCA9ICBNWVhNTC5zbXhtbC5fc2xhc2g7XG4gICAgICAgICAgICAgICAgc3RhdGUucGx1c19taW51cyA9IE1ZWE1MLnNteG1sLl9wbHVzbWludXM7XG4gICAgICAgICAgICAgICAgc3RhdGUuZGVjaW1hbF92YWwgPSAgTVlYTUwuc214bWwuX2RlY2ltYWw7XG4gICAgICAgICAgICAgICAgc3RhdGUudGV4dFNpemUgPSBNWVhNTC5zbXhtbC5fZm9udDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb3JyZWN0QW5zID0gIE1ZWE1MLnNteG1sLl9jb3JyZWN0QW5zO1xuICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBnZXRDaGlsZFhtbChKU09OVG9YTUwoTVlYTUwpKTtcbiAgICAgICAgICAgICAgICBpZiAoTVlYTUwuc214bWwuX3BsdXNtaW51cyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbHVzX21pbnVzX2NoZWNrYm94JykuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNWVhNTC5zbXhtbC5fc2xhc2ggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJhY3Rpb25fc2xhc2hfY2hlY2tib3gnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1ZWE1MLnNteG1sLl9kZWNpbWFsID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Zsb2F0aW5nX2RlY2ltYWxfY2hlY2tib3gnKS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChldmVudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oe1xuICAgICAgICAgICAgICAgICdlcnJvcic6IGV2ZW50cy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICdmdW5jdGlvbiBuYW1lJzogJ3BhcnNlWE1MQXV0aG9yaW5nJyxcbiAgICAgICAgICAgICAgICAnRmlsZSBuYW1lJzogJ0dyaWRkZWQuanMnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGJvb2xlYW4gdmFsdWUgaW4gcGx1cy9taW51c1xuICAgIGZ1bmN0aW9uIHBsdXNNaW51c1NldFZhbCgpIHtcbiAgICAgICAgc3RhdGUucGx1c19taW51cyA9IChzdGF0ZS5wbHVzX21pbnVzID09IDApID8gMSA6IDA7XG4gICAgICAgIHVwZGF0ZVhtbCgpO1xuICAgIH1cblxuICAgIC8vIHNsYXNoIGZ1bmN0aW9uIHNldCB2YWx1ZSB0cnVlIG9yIGZhbHNlXG4gICAgZnVuY3Rpb24gc2xhc2hGdW5jU2V0VmFsKGV2ZW50KSB7XG4gICAgICAgIHN0YXRlLnNsYXNoX3ZhbCA9IChzdGF0ZS5zbGFzaF92YWwgPT0gMCkgPyAxIDogMDtcbiAgICAgICAgICAgIHVwZGF0ZVhtbCgpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZGlzYWJsZSBkZWNpbWFsIGlucHV0IGJveFxuICAgIGZ1bmN0aW9uIGZpeGVkRnVuYyhldmVudCkge1xuICAgICAgICBpZiAoc3RhdGUuZml4ZWRfZGVjaW1hbF92YWwgPT0gMCkge1xuICAgICAgICAgICAgc3RhdGUuZml4ZWRfZGVjaW1hbF92YWwgPSAxO1xuICAgICAgICAgICAgbGV0IGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnRml4ZWRfZGVjaW1hbF9jb2x1bW4nKTtcbiAgICAgICAgICAgIGVsZW0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuZml4ZWRfZGVjaW1hbF92YWwgPSAwO1xuICAgICAgICAgICAgc3RhdGUuZGVjaW1hbF9wb2ludCA9IDAgO1xuXG4gICAgICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdGaXhlZF9kZWNpbWFsX2NvbHVtbicpO1xuICAgICAgICAgICAgZWxlbS52YWx1ZSA9IFwiIFwiO1xuICAgICAgICAgICAgZWxlbS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB1cGRhdGVYbWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcblxuICAgIC8vIFNldCB2YWx1ZSBkZWNpbWFsIGZsb2F0aW5nXG4gICAgZnVuY3Rpb24gZGVjaW1hbEZ1bmNTZXRWYWwgKGV2ZW50KSB7XG4gICAgICAgIHN0YXRlLmRlY2ltYWxfdmFsID0gKHN0YXRlLmRlY2ltYWxfdmFsID09IDApID8gMSA6IDA7XG4gICAgICAgIHVwZGF0ZVhtbCgpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZGVjaWRlZCB0byByb3cgb3IgY29sdW1uIGZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gY2hhbmdlUm93Q29sKGV2ZW50KSB7XG4gICAgICAgIGlmKChldmVudC50YXJnZXQudmFsdWUpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIEFILmFsZXJ0KCdhY2NlcHQgb25seSBzaW5nbGUgdmFsdWUnKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ2NoZWNrJyk7XG5cbiAgICAgICAgbGV0IHZhbCA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKCEodmFsID4gMCAmJiB2YWwgPD0gMTApKSB7XG4gICAgICAgICAgICBBSC5hbGVydChsLmdyaWRfb25lX3RvX3Rlbik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5uYW1lID09IFwiY29sX25tYnJcIikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICBBSC5hbGVydChsLmNvbF9sZXNzX29uZSk7XG4gICAgICAgICAgICAgICAgZXZhXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA+IDYpIHtcbiAgICAgICAgICAgICAgICBBSC5hbGVydChsLnR5cGVfb25lX3RvX3NldmVuKTtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmNvbE51bSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQudmFsdWUgPCAxKSB7XG4gICAgICAgICAgICBBSC5hbGVydChsLnJvd19sZXNzX29uZSk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQudmFsdWUgPiAxMCkge1xuICAgICAgICAgICAgICAgIEFILmFsZXJ0KGwudHlwZV9vbmVfdG9fdGVuKTtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnJvd051bSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVYbWwoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhlZERlY2ltYWxQb2ludHMoZXZlbnQpIHtcbiAgICAgICAgbGV0IGRlY2ltYWxQb3NpdGlvbiA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYoKGV2ZW50LnRhcmdldC52YWx1ZSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgQUguYWxlcnQoJ2FjY2VwdCBvbmx5IHNpbmdsZSB2YWx1ZScpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgICAgIGRlY2ltYWxQb3NpdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC50YXJnZXQudmFsdWUubGVuZ3RoID4gMSB8fCBldmVudC50YXJnZXQudmFsdWUgPCAxIHx8IHN0YXRlLmNvbE51bSA8PSBldmVudC50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIGRlY2ltYWxQb3NpdGlvbiA9IDE7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSAxO1xuICAgICAgICAgICAgQUguYWxlcnQobC5kZWNpbWFsX3Bvc2l0aW9uKyhzdGF0ZS5jb2xOdW0tMSkrXCIuXCIpO1xuICAgICAgICAgICAgLy8kKFwiLnNhLWluZm9cIikuc2hvdygpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNhLWluZm8nKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kZWNpbWFsX3BvaW50ID0gZGVjaW1hbFBvc2l0aW9uO1xuICAgICAgICB1cGRhdGVYbWwoKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSB4bWxcbiAgICBmdW5jdGlvbiB1cGRhdGVYbWwoKSB7XG4gICAgICAgIC8vIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgdXBkYXRlZFhtbCA9ICc8c214bWwgdHlwZT1cIjU2XCIgbmFtZT1cIkdyaWRkZWRcIiBwbHVzbWludXM9XCInK3N0YXRlLnBsdXNfbWludXMrJ1wiIHNsYXNoPVwiJytzdGF0ZS5zbGFzaF92YWwrJ1wiIGRlY2ltYWw9XCInK3N0YXRlLmRlY2ltYWxfdmFsKydcIiBmaXhlZF9wb2ludD1cIicrc3RhdGUuZGVjaW1hbF9wb2ludCsnXCIgZm9udD1cIicrc3RhdGUudGV4dFNpemUrJ1wiIHJvdz1cIicrc3RhdGUucm93TnVtKydcIiBjb2w9XCInK3N0YXRlLmNvbE51bSsnXCIgY29ycmVjdEFucz1cIicrc3RhdGUucmVzKydcIiA+PCEtLVtDREFUQVtdXS0tPjwvc214bWw+JztcbiAgICAgICAgICAgIGdldENoaWxkWG1sKHVwZGF0ZWRYbWwpO1xuICAgICAgICAgICAgXG4gICAgICAgIC8vIH0sIDUwMCk7XG4gICAgICAgIFxuICAgIH1cblxuXG4gICAgXG5cbiAgICAvLyBDcmVhdGUgYSBzaGVldCBhY2NvcmRpbmcgdG8gcmFuZ2VcbiAgICBsZXQgdG90YWxSb3dzID0gW10sdG90YWxDb2xzID0gW107XG4gICAgZnVuY3Rpb24gY3JlYXRlZFNoZWV0Um93KCkge1xuICAgICAgICBBSC5zZWxlY3QoJy50ZEZvbnQnLCdjc3MnLHtmb250U2l6ZTpzdGF0ZS50ZXh0U2l6ZX0pXG4gICAgICAgIHRvdGFsUm93cyA9IFtdO1xuICAgICAgICBsZXQgZGVjX3BvaW50ID0gc3RhdGUuZGVjaW1hbF9wb2ludDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5yb3dOdW07IGkrKykge1xuICAgICAgICAgICAgdG90YWxDb2xzID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQ29scyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OlwiY29sXCIraStqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxDb2xzLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxDb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjb2xcIitpK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqICsgXCItXCIgKyBpICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxSb3dzID0gW1xuICAgICAgICAgICAgICAgIC4uLnRvdGFsUm93cyx7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJyb3dcIitpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICBcbiAgICBcbn07XG5cbiBcblxuICAgIC8vIGNyZWF0ZWQgYSBzbGFzaCByb3cgaW4gZ3JpZGRlZCBzaGVldFxuICAgIGxldCBDb2xzX3NsYXNoO1xuICAgIGZ1bmN0aW9uIHNsYXNoRnVuYyhldmVudCkge1xuICAgICAgICBDb2xzX3NsYXNoID0gW107XG4gICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLmNvbE51bTsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgQ29sc19zbGFzaCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19zbGFzaCx7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiY29sXCIraixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKENvbHNfc2xhc2gubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgICAgICAgQ29sc19zbGFzaCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19zbGFzaCx7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0ZFwiICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGRlY2ltYWwgZmxvYXRpbmcgcm93XG4gICAgbGV0IENvbHNfZGVjaW1hbDtcbiAgICBmdW5jdGlvbiBkZWNpbWFsRmxvYXRpbmcoZXZlbnQpIHtcbiAgICAgICAgQ29sc19kZWNpbWFsID0gW107XG4gICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLmNvbE51bTsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwICkge1xuICAgICAgICAgICAgICAgIENvbHNfZGVjaW1hbCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19kZWNpbWFsLHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjb2xcIitqLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbHNfZGVjaW1hbC5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgQ29sc19kZWNpbWFsLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29sc19kZWNpbWFsID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX2RlY2ltYWwse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidGRcIiArIGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICBcbiAgICB9XG5cbiAgICAgLy8gY3JlYXRlIHBsdXMgYW5kIG1pbnVzIHJvd1xuICAgIGxldCBDb2xzX01pbnVzID0gW10sQ29scyA9IFtdOyBcbiAgICBmdW5jdGlvbiBwbHVzTWludXNTaWduKGV2ZW50KSAge1xuICAgICAgICAgICAgbGV0IFJvd3MgPSBbXTtcbiAgICAgICAgICAgIENvbHMgPSBbXTtcbiAgICAgICAgICAgIENvbHNfTWludXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBSb3dzX01pbnVzID0gW107XG4gICAgICAgICAgICBsZXQgZGVjX3BvaW50ID0gc3RhdGUuZGVjaW1hbF9wb2ludDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBDb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLkNvbHMse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0ZFwiICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ29scy5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb2xzX01pbnVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLkNvbHNfTWludXMse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0ZFwiICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ29sc19NaW51cy5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2xzX01pbnVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX01pbnVzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cblxuICAgIC8vIENyZWF0ZSB2ZXJ5IGZpcnN0IHJvdyBhbmQgc3RvcmUgZGF0YSBhY2NvcmRpbmcgdG8gY2xpY2tcbiAgICBsZXQgQ29sc0ZpcnN0Um93ID0gW107XG4gICAgZnVuY3Rpb24gZmlyc3RSb3dJdGVtKCkge1xuICAgICAgICBsZXQgUm93cyA9IFtdO1xuICAgICAgICBDb2xzRmlyc3RSb3cgPSBbXTtcbiAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqID09PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwICkge1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgQ29sc0ZpcnN0Um93ID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzRmlyc3RSb3cse1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbHNGaXJzdFJvdy5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgQ29sc0ZpcnN0Um93ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc0ZpcnN0Um93LHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3RkJytqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgIFxuICAgIH1cblxuICAgICAvLyBDaGVjayB2YWxpZGF0aW9uIGZpcnN0IHJvdyBpbnB1dCB0eXBlXG4gICAgZnVuY3Rpb24gcm93VmFsaWRhdGlvbihldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnbnVtYmVyJyArIHN0YXRlLnBsdXNfbWludXMpO1xuICAgICAgICBsZXQgYSA9IHN0YXRlLnJvd051bS0xO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIEFILmFsZXJ0KGwuZG91YmxlX2RpZ2l0KTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIEFILmFsZXJ0KGwubGVzc19vbmUpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICggYSA8IGV2ZW50LnRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgQUguYWxlcnQobC5udW1iZXJfZnJvbSArIGEpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUucGx1c19taW51cyA9PSAwICYmICBldmVudC50YXJnZXQudmFsdWUgPT0gXCIrXCIgfHwgZXZlbnQudGFyZ2V0LnZhbHVlID09IFwiLVwiKSB7XG4gICAgICAgICAgICBBSC5hbGVydCgnUGx6IHNlbGVjdCBwbHVzIGFuZCBtaW51cyBvcHRpb24nKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc2xhc2hfdmFsID09IDAgJiYgIGV2ZW50LnRhcmdldC52YWx1ZSA9PSBcIi9cIikge1xuICAgICAgICAgICAgQUguYWxlcnQoJ1BseiBzZWxlY3Qgc2xhc2ggb3B0aW9uJyk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlY2ltYWxfdmFsID09IDAgJiYgIGV2ZW50LnRhcmdldC52YWx1ZSA9PSBcIi5cIikge1xuICAgICAgICAgICAgQUguYWxlcnQoJ1BseiBzZWxlY3QgZGVjaW1hbCBvcHRpb24nKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgbGV0IGF0dHJpYnV0ZSA9IGV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS10YWcnKS52YWx1ZTtcbiAgICAgICAgY29ycmVjdEFuc1thdHRyaWJ1dGVdID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29ycmVjdEFucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoY29ycmVjdEFuc1tpXSkgPT0gJ3VuZGVmaW5lZCcgfHwgY29ycmVjdEFuc1tpXT09XCJcIikge1xuICAgICAgICAgICAgICAgIGNvcnJlY3RBbnNbaV0gPSBcIiVibGFuayVcIjtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGNvcnJlY3RBbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JyZWN0QW5zWyhjb3JyZWN0QW5zLmxlbmd0aCktMV0gPT0gXCIlYmxhbmslXCIpIHtcbiAgICAgICAgICAgIGNvcnJlY3RBbnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICBzdGF0ZS5saXN0QW5zID0gY29ycmVjdEFucztcbiAgICAgICAgXG4gICAgICAgIHN0YXRlLnJlcyA9IHN0YXRlLmxpc3RBbnMudG9TdHJpbmcoKTtcbiAgICAgICAgdXBkYXRlWG1sKCk7XG4gICAgfVxuXG4gICAgIC8vIENoYW5nZSBjb2xvciBpbiBzaGVldCBhY2NvcmRpbmcgdG8gdXNlciBpbnB1dFxuICAgIGZ1bmN0aW9uIGhpZ2hMaWdodChldmVudCkge1xuICAgICAgICBsZXQgY2VsbF9jbGFzcyA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgbGV0IGNvbHVtbl9pbmRleCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGNlbGxfY2xhc3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5pbm5lckhUTUwgPT0gZXZlbnQudGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgbGV0IGNlbGxfY2xhc3MgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgIGxldCBjb2x1bW5faW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShjZWxsX2NsYXNzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5faW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgIGxldCB0YXJnZXRfaWQgPSBldmVudC50YXJnZXQuaWQ7XG4gICAgICAgIGxldCB0YXJnZXRfdG9fZGlzcGxheSA9IHRhcmdldF9pZC5zcGxpdChcIi1cIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldF90b19kaXNwbGF5WzBdKS52YWx1ZSA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XG5cbiAgICAgICAgbGV0IGF0dHJpYnV0ZSA9IGV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS10YWcnKS52YWx1ZTtcbiAgICAgICAgY29ycmVjdEFuc1thdHRyaWJ1dGVdID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcnJlY3RBbnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGNvcnJlY3RBbnNbaV0pID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29ycmVjdEFuc1tpXSA9IFwiJWJsYW5rJVwiO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coY29ycmVjdEFucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN0YXRlLmxpc3RBbnMgPSBjb3JyZWN0QW5zO1xuICAgICAgICBcbiAgICAgICAgc3RhdGUucmVzID0gc3RhdGUubGlzdEFucy50b1N0cmluZygpO1xuICAgICAgICB1cGRhdGVYbWwoKTtcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgYSBkYXRhIGluIHRvcCByb3cgYWNjb3JkaW5nIHRvIGNsaWNrICBhbmQgY2hhbmdlIGNvbG9yc1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrQ29tYm8oZXZlbnQpIHtcbiAgICAgICAgLy9sZXQgY2VsbF9jbGFzcyA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgbGV0IGNlbGxfY2xhc3MgPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgbGV0IGNvbHVtbl9pbmRleCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGNlbGxfY2xhc3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoZXZlbnQuZGV0YWlsLnRhcmdldCkuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgbGV0IHRhcmdldF9pZCA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pZDtcbiAgICAgICAgbGV0IHRhcmdldF90b19kaXNwbGF5ID0gdGFyZ2V0X2lkLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0X3RvX2Rpc3BsYXlbMF0pLnZhbHVlID0gKGV2ZW50LmRldGFpbC50YXJnZXQpLmlubmVySFRNTDtcblxuICAgICAgICAvL2xldCBhdHRyaWJ1dGUgPSBldmVudC50YXJnZXQuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtdGFnJykudmFsdWU7XG4gICAgICAgIGxldCBhdHRyaWJ1dGUgPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtdGFnJykudmFsdWU7XG4gICAgICAgIGNvcnJlY3RBbnNbYXR0cmlidXRlXSA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pbm5lckhUTUw7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3JyZWN0QW5zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihjb3JyZWN0QW5zW2ldKSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvcnJlY3RBbnNbaV0gPSBcIiVibGFuayVcIjtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGNvcnJlY3RBbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdGF0ZS5saXN0QW5zID0gY29ycmVjdEFucztcbiAgICAgICAgXG4gICAgICAgIHN0YXRlLnJlcyA9IHN0YXRlLmxpc3RBbnMudG9TdHJpbmcoKTtcbiAgICAgICAgdXBkYXRlWG1sKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3BvaW50cycpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZWxbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgZWxbaV0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuPC9zY3JpcHQ+XG48bWFpbj5cbiAgICA8ZGl2IGNsYXNzPVwiZ3JpZGRlZE1vZHVsZVwiPlxuICAgICAgICA8dGFibGUgYm9yZGVyPVwiMVwiIGlkPVwidGFiMlwiIGNsYXNzPVwidGFiMlwiIHN0eWxlPXsnYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTt0ZXh0LWFsaWduOiBjZW50ZXI7JyB9ID5cbiAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBDb2xzRmlyc3RSb3cgYXMgdmFsLGl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHZhbC5kZWNwb2ludCA9PSB0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHN0eWxlPSd3aWR0aDo1MHB4O3RleHQtYWxpZ246Y2VudGVyOycgIHZhbHVlPVwiLlwiIGNsYXNzPVwidGRGb250XCIgZGlzYWJsZWQ9XCJ0cnVlXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9e3ZhbC5pZH0gbmFtZT17dmFsLm5hbWV9IGRhdGEtdGFnPXt2YWwuZGF0YVRhZ30gc3R5bGU9eyd3aWR0aDo1MHB4O3RleHQtYWxpZ246Y2VudGVyOyd9IG9uOmNoYW5nZT17cm93VmFsaWRhdGlvbn0gb246aW5wdXQ9e2hpZ2hMaWdodH0gY2xhc3M9XCJ0ZEZvbnQgZm9cIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICA8L3RhYmxlPlxuICAgICAgICB7I2lmIHN0YXRlLnBsdXNfbWludXMgPT0gMX1cbiAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxuICAgICAgICAgICAgICAgIG9uOmhhbmRsZUNsaWNrQ29tYm89e2hhbmRsZUNsaWNrQ29tYm99XG4gICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzfVxuICAgICAgICAgICAgICAgIGNsYXNzMSA9IFwidGRGb250IHBsdXNfdGFiIHBvaW50c1wiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250IHBsdXNfdGFiIGl0ZW1zX2VsZW1lbnRcIlxuICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwicGx1c19taW51c190YWJcIlxuICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3MgPVwicGx1c19taW51c190YWIgZ3JpZGRlZF90YWIgbXQtMCBteVBcIlxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIrXCJcbiAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XG4gICAgICAgICAgICA8R3JpZGRlZEhlbHBlciBcbiAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvPXtoYW5kbGVDbGlja0NvbWJvfVxuICAgICAgICAgICAgICAgIGxvb3AgPSB7Q29sc19NaW51c31cbiAgICAgICAgICAgICAgICBjbGFzczEgPSBcInRkRm9udCBwbHVzX3RhYlwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250IG1pbnVzX3BvaW50IHRleHQtY2VudGVyIGl0ZW1zX2VsZW1lbnRcIlxuICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwicGx1c19taW51c190YWJcIlxuICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3MgPVwicGx1c19taW51c190YWIgZ3JpZGRlZF90YWIgbXQtMCBteVBcIlxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCItXCJcbiAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgc3RhdGUuZGVjaW1hbF92YWwgPT0gMX1cbiAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxuICAgICAgICAgICAgICAgIG9uOmhhbmRsZUNsaWNrQ29tYm89e2hhbmRsZUNsaWNrQ29tYm99XG4gICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX3NsYXNofVxuICAgICAgICAgICAgICAgIGNsYXNzMSA9IFwidGRGb250IHBvaW50c1wiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250IHRleHQtY2VudGVyIGl0ZW1zX2VsZW1lbnQgZGVjbF9wb2ludFwiXG4gICAgICAgICAgICAgICAgdGFibGVJZCA9XCJzbGFzaF90YWJcIlxuICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3MgPVwic2xhc2hfdGFiIGdyaWRkZWRfdGFiIG10LTAgbXlQXCJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiLlwiXG4gICAgICAgICAgICA+PC9HcmlkZGVkSGVscGVyPlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIHN0YXRlLnNsYXNoX3ZhbCA9PSAxfVxuICAgICAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxuICAgICAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvPXtoYW5kbGVDbGlja0NvbWJvfVxuICAgICAgICAgICAgICAgICAgICBsb29wID0ge0NvbHNfc2xhc2h9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzMSA9IFwidGRGb250IHBvaW50c1wiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRkRm9udCB0ZXh0LWNlbnRlciBpdGVtc19lbGVtZW50IHNsYV9wb2ludFwiXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwic2xhc2hfdGFiXCJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJzbGFzaF90YWIgZ3JpZGRlZF90YWIgbXQtMCBteVBcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiL1wiXG4gICAgICAgICAgICAgICAgPjwvR3JpZGRlZEhlbHBlcj5cbiAgICAgICAgey9pZn1cblxuICAgICAgICA8dGFibGUgaWQ9XCJncmlkZGVkX3NoZWV0XCIgY2xhc3M9XCJncmlkZGVkX3RhYiBsYXN0R3JpZCBtdC0wIG15UFwiPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgeyNlYWNoIHRvdGFsUm93cyBhcyBkYXRhLCBub31cbiAgICAgICAgICAgICAgICAgICAgPHRyIGtleT1cInJvd3tub31cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCB0b3RhbENvbHMgYXMgdmFsLCBpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgdmFsLmRlY3BvaW50ID09IHRydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGtleT17dmFsLmtleX0gY2xhc3MgPSd0ZEZvbnQgdGV4dC1jZW50ZXIgcG9pbnRzJyAgd2lkdGg9XCI1MFwiIGRpc2FibGVkPVwidHJ1ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHdpZHRoPVwiNTBcIiBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiB0YWJJbmRleD17MH0ga2V5PXt2YWwua2V5fSBuYW1lPXt2YWwubmFtZX0gZGF0YS10YWc9e3ZhbC5uYW1lfSBjbGFzcyA9J3RkRm9udCB0ZF9kYXRhIHRleHQtY2VudGVyIGl0ZW1zX2VsZW1lbnQnIGlkPXt2YWwuaWR9ICBvbjpjbGljaz17aGFuZGxlQ2xpY2t9Pnsrbm99PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICBcbiAgICAgICAgPC90YWJsZT5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWNjb3JkaW9uIG10LTVcIiBpZD1cImFjY29yZGlvbkV4YW1wbGVcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6I0YwRjBGMDtcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhY2NvcmRpb24taXRlbVwiPlxuICAgICAgICAgICAgPGgyIGNsYXNzPVwiYWNjb3JkaW9uLWhlYWRlciBtdC0wXCIgaWQ9XCJoZWFkaW5nT25lXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImFjY29yZGlvbi1idXR0b24gY29sbGFwc2VkIHB5LTBcIiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiIGRhdGEtYnMtdGFyZ2V0PVwiI2NvbGxhcHNlT25lXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCIgYXJpYS1jb250cm9scz1cImNvbGxhcHNlT25lXCI+XG4gICAgICAgICAgICAgICAgICAgIHtsLmxheW91dF9vcHRpb25zfVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJjb2xsYXBzZU9uZVwiIGNsYXNzPVwiYWNjb3JkaW9uLWNvbGxhcHNlIGNvbGxhcHNlXCIgYXJpYS1sYWJlbGxlZGJ5PVwiaGVhZGluZ09uZVwiIGRhdGEtYnMtcGFyZW50PVwiI2FjY29yZGlvbkV4YW1wbGVcIiBzdHlsZT1cIlwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhY2NvcmRpb24tYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb250LXdlaWdodC1ib2xkXCI+e2wucm93X2NvdW50fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPVwiMVwiIG1heD1cIjEwXCIgIHZhbHVlPXtzdGF0ZS5yb3dOdW19IG5hbWU9XCJjb2xfcmFuZ2VcIiBpZD1cImNvbF9yYW5nZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sICBpbmxpbmUtYmxvY2tcIiBkYXRhLWxhYmVsPVwiTnVtYmVyIG9mIHJvd3NcIiBvbjpjaGFuZ2U9e2NoYW5nZVJvd0NvbH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS02XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvbnQtd2VpZ2h0LWJvbGRcIj57bC5jb2xfY291bnR9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49XCIxXCIgbWF4PVwiNlwiICB2YWx1ZT17c3RhdGUuY29sTnVtfSBuYW1lPVwiY29sX25tYnJcIiBpZD1cImNvbF9yYW5nZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sICBpbmxpbmUtYmxvY2tcIiBkYXRhLWxhYmVsPVwiTnVtYmVyIG9mIHJvd3NcIiBvbjpjaGFuZ2U9e2NoYW5nZVJvd0NvbH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgZm9ybS1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS02XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiY3VzdG9tX2NoZWNrYm94X25ldyBmbG9hdC1sZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcInBsdXNfbWludXNfY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFByb3BzPXt7ICdhcmlhLWxhYmVsJzogJ1BsdXMvTWludXMgQ29sdW1uJyB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljayA9IHtwbHVzTWludXNTZXRWYWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPjxsYWJlbCBmb3I9XCJwbHVzX21pbnVzX2NoZWNrYm94XCIgY2xhc3M9XCJwbC0xXCI+UGx1cy9NaW51cyBDb2x1bW48L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQgPSBcImZyYWN0aW9uX3NsYXNoX2NoZWNrYm94XCIgY2xhc3M9XCJjdXN0b21fY2hlY2tib3hfbmV3IGZsb2F0LWxlZnRcIiBpbnB1dFByb3BzPXt7ICdhcmlhLWxhYmVsJzogJ0ZyYWN0aW9uL1NsYXNoJyB9fSBvbjpjbGljayA9IHtzbGFzaEZ1bmNTZXRWYWx9IC8+PGxhYmVsIGZvciA9IFwiZnJhY3Rpb25fc2xhc2hfY2hlY2tib3hcIiBjbGFzcz1cInBsLTFcIj5GcmFjdGlvbi9TbGFzaDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBmb3JtLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlubGluZS1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQgPSBcImZpeGVkX2RlY2ltYWxfY2hlY2tib3hcIiBjbGFzcz1cImN1c3RvbV9jaGVja2JveF9uZXcgZmxvYXQtbGVmdFwiIGlucHV0UHJvcHM9e3sgJ2FyaWEtbGFiZWwnOiAnRml4ZWQgRGVjaW1hbCcgfX0gb246Y2xpY2sgPSB7Zml4ZWRGdW5jfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPiA8bGFiZWwgZm9yPVwiZml4ZWRfZGVjaW1hbF9jaGVja2JveFwiIGNsYXNzPVwicGwtMVwiPiBGaXhlZCBEZWNpbWFsPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS02XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkID0gXCJmbG9hdGluZ19kZWNpbWFsX2NoZWNrYm94XCIgY2xhc3M9XCJjdXN0b21fY2hlY2tib3hfbmV3IGZsb2F0LWxlZnRcIiBpbnB1dFByb3BzPXt7ICdhcmlhLWxhYmVsJzogJ0Zsb2F0aW5nIERlY2ltYWwnIH19IG9uOmNsaWNrID0ge2RlY2ltYWxGdW5jU2V0VmFsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+PGxhYmVsIGZvcj1cImZsb2F0aW5nX2RlY2ltYWxfY2hlY2tib3hcIiBjbGFzcz1cInBsLTFcIj5GbG9hdGluZyBEZWNpbWFsPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTYgaW5saW5lLWJsb2NrIHBsLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPVwiMVwiIG1heD1cIjdcIiAgbmFtZT1cIkZpeGVkX2RlY2ltYWxfY29sdW1uXCIgaWQ9XCJGaXhlZF9kZWNpbWFsX2NvbHVtblwiIGNsYXNzPVwiZm9ybS1jb250cm9sICBpbmxpbmUtYmxvY2tcIiBwbGFjZWhvbGRlcj1cIkZpeGVkIGRlY2ltYWwgY29sdW1uXCIgc3R5bGU9eydkaXNwbGF5OiBub25lJ30gZGF0YS1sYWJlbD1cIkZpeGVkIGRlY2ltYWwgY29sdW1uXCIgZGlzYWJsZWQ9XCJ0cnVlXCIgb246Y2hhbmdlPXtmaXhlZERlY2ltYWxQb2ludHN9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L21haW4+XG48c3R5bGU+XG4gICAgLmN1c3RvbV9jaGVja2JveF9uZXcge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMjBweDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICB9XG5cbjpnbG9iYWwoLmxheW91dEhlYWRpbmcpIHtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgY29sb3I6ICMxODc3YjE7XG59XG5cbjpnbG9iYWwoLml0ZW1zX2VsZW1lbnQ6aG92ZXIpIHtcbiAgICBib3JkZXI6IDEuMnB4IHNvbGlkICM3Nzc7XG59XG5cbjpnbG9iYWwoLm1vcmVPcHRpb25zKSB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiAzcHggNHB4IDZweCAjYzRjNWM1O1xuICAgIC1tb3otYm94LXNoYWRvdzogM3B4IDRweCA2cHggI2M0YzVjNTtcbiAgICBib3gtc2hhZG93OiAzcHggNHB4IDZweCAjYzRjNWM1O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICMxODc3YjE7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICMxODc3YjE7XG59XG5cbjpnbG9iYWwoLm1vcmVPcHRpb25EZXRhaWxzKSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcbn1cblxuOmdsb2JhbCguaW5wdXRfY29sKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGxlZnQ6IDVweDtcbn1cblxuOmdsb2JhbCgubGF5b3V0aGVhZGluZykge1xuICAgIHBhZGRpbmc6IDVweDtcbiAgICBmb250LXNpemU6IDIwcHg7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG59XG5cblxuOmdsb2JhbCgubnVtYnJfcmFuZ2UpIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbGVmdDogMTMwcHg7XG59XG5cbjpnbG9iYWwoLm51bWJyX3JhbmdlX3R4dCkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsZWZ0OiAyMDBweDtcbn1cblxuOmdsb2JhbCgucGx1c19taW51c19mcmFjdGlvbikge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB0b3A6IDIwcHg7XG59XG5cbjpnbG9iYWwoLmZsb2F0aW5nX2ZyYWN0aW9uKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHRvcDogMjdweDtcbn1cblxuOmdsb2JhbCgucGx1c19taW51c19zcGFuKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGxlZnQ6IDVweDtcbn1cblxuOmdsb2JhbCguZmxvYXRpbmdfZGVjaW1hbCkge1xuICAgIGZsb2F0OiByaWdodDtcbiAgICBtYXJnaW4tcmlnaHQ6IDQ1cHg7XG59XG5cbjpnbG9iYWwoLmZvbnRTdHlsZSkge1xuICAgIHdpZHRoOiAxMDBweDtcbiAgICBmbG9hdDogcmlnaHQ7XG4gICAgbWFyZ2luLXJpZ2h0OiA2MHB4O1xufVxuXG46Z2xvYmFsKC5mcmFjdGlvbl9zbGFzaCkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsZWZ0OiAxNzdweDtcbn1cblxuOmdsb2JhbCgubWludXNfdGFiLFxuLnBsdXNfdGFiLFxuLnNsYXNoX3RhYikge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuLmdyaWRkZWRfdGFiIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmMGYwO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG59XG5cbjpnbG9iYWwoLmZvbnRfc2l6ZV9sYWJlbCkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsZWZ0OiAxOThweDtcbn1cblxuOmdsb2JhbCguZm9udF9zaXplKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGxlZnQ6IDIyNXB4O1xufVxuXG5cbjpnbG9iYWwoLmRlY2ltYWxfY29sKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGxlZnQ6IDIwOHB4O1xuICAgIHdpZHRoOiA5MHB4O1xufVxuXG46Z2xvYmFsKC5jb3JyZWN0X2NvbG9yKSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0U5RkZFOTtcbn1cblxuOmdsb2JhbCguZml4ZWRfZGVjaW1hbF9jaGVjaykge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB0b3A6IDI2cHg7XG4gICAgbGVmdDogMTNweDtcbn1cblxuOmdsb2JhbCguY29ycmVjdF9pbmNvcnJlY3RfaWNvbl9maWxsKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxOXB4O1xuICAgIGhlaWdodDogMTlweDtcbiAgICByaWdodDogMTIxcHg7XG4gICAgdG9wOiAtNTVweDtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG5cbjpnbG9iYWwoLnJvd19jb2x1bW5fZGVjaW1hbCkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB0b3A6IDMwcHg7XG4gICAgbGVmdDogNXB4O1xuXG59XG5cbjpnbG9iYWwoLmZpeGVkX3BvaW50X2NsYXNzKSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGxlZnQ6IDdweDtcbn1cblxuOmdsb2JhbCgucm93X2NvbHVtbikge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsZWZ0OiA1cHg7XG59XG5cbjpnbG9iYWwoLmFuc3dlcl9pY29uKSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogM3B4O1xuICAgIHJpZ2h0OiAzNHB4O1xufVxuXG4ubXlQIHRib2R5IHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbjpnbG9iYWwoLmNvbF9yYW5nZSkge1xuICAgIHdpZHRoOiAyMDVweDtcbn1cblxuOmdsb2JhbCgucG9zU2l6ZSkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsZWZ0OiA3cHg7XG59XG5cbjpnbG9iYWwoLmZvbnRTbWFsbCkge1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbjpnbG9iYWwoLmZvbnROb3JtYWwpIHtcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG46Z2xvYmFsKC5mb250TGFyZ2UpIHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG46Z2xvYmFsKC5mb250RXh0cmFMYXJnZSkge1xuICAgIGZvbnQtc2l6ZTogMjZweDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbjpnbG9iYWwoLmdyaWQpIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdG9wOiAxMHB4O1xuICAgIGJveC1zaGFkb3c6IDEwcHggNXB4IDEwcHggIzAwMDtcbn1cblxuOmdsb2JhbCguaXRlbXNfZWxlbWVudCkge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICM4MDgwODA3YTtcbiAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG59XG5cbjpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgLmFjdGl2ZSkge1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICB0cmFuc2l0aW9uOiAxcztcbiAgICBiYWNrZ3JvdW5kOiAjNjk2OTY5O1xuICAgIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XG59XG5cbi5taW51c19wb2ludCxcbi5kZWNsX3BvaW50IHtcbiAgICBwYWRkaW5nOiA2cHggMTJweDtcbn1cblxuOmdsb2JhbCguc2xhX3BvaW50KSB7XG4gICAgcGFkZGluZzogNnB4IDExcHg7XG59XG5cbi5ncmlkZGVkTW9kdWxlIHRhYmxlIHRyIHRkOmxhc3QtY2hpbGQge1xuICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNjY2MgIWltcG9ydGFudDtcbn1cblxuLmdyaWRkZWRNb2R1bGUgLmxhc3RHcmlkIHRyOmxhc3QtY2hpbGQgdGQge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjICFpbXBvcnRhbnQ7XG59XG5cbjpnbG9iYWwoLmdyaWRkZWRNb2R1bGUgdGQpIHtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZjBmMGYwICFpbXBvcnRhbnQ7XG4gICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjY2NjICFpbXBvcnRhbnQ7XG59XG5cbjpnbG9iYWwoLnRva2VuOmhvdmVyKSB7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzAwMCAhaW1wb3J0YW50O1xufVxuXG46Z2xvYmFsKC5ibGEgLnRva2VuOmhvdmVyKSB7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZiAhaW1wb3J0YW50O1xufVxuXG46Z2xvYmFsKC50b2tlbl9zZWxlY3RlZCkge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM2NGJiNjM7XG4gICAgY29sb3I6ICNmZmY7XG59XG5cbjpnbG9iYWwoLmJsYSAudG9rZW5faGlnaGxpZ2h0X2hlYWRpbmcpIHtcbiAgICBjb2xvcjogIzAwMCAhaW1wb3J0YW50O1xufVxuXG46Z2xvYmFsKC5ncmlkZGVkTW9kdWxlIC5leHBhbmRJY29uKSB7XG4gICAgZm9udC1zaXplOiAyN3B4O1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIGNv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 */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[32] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

// (565:24) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_id_value;
	let input_name_value;
	let input_data_tag_value;
	let input_style_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = /*val*/ ctx[33].id);
			attr_dev(input, "name", input_name_value = /*val*/ ctx[33].name);
			attr_dev(input, "data-tag", input_data_tag_value = /*val*/ ctx[33].dataTag);
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");
			attr_dev(input, "class", "tdFont fo");
			add_location(input, file, 565, 32, 18728);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*rowValidation*/ ctx[13], false, false, false),
					listen_dev(input, "input", highLight, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsFirstRow*/ 64 && input_id_value !== (input_id_value = /*val*/ ctx[33].id)) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty[0] & /*ColsFirstRow*/ 64 && input_name_value !== (input_name_value = /*val*/ ctx[33].name)) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty[0] & /*ColsFirstRow*/ 64 && input_data_tag_value !== (input_data_tag_value = /*val*/ ctx[33].dataTag)) {
				attr_dev(input, "data-tag", input_data_tag_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(565:24) {:else}",
		ctx
	});

	return block;
}

// (563:24) {#if val.decpoint == true}
function create_if_block_4(ctx) {
	let input;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			set_style(input, "width", "50px");
			set_style(input, "text-align", "center");
			input.value = ".";
			attr_dev(input, "class", "tdFont");
			input.disabled = "true";
			add_location(input, file, 563, 28, 18562);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(563:24) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (562:20) {#each ColsFirstRow as val,i}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*val*/ ctx[33].decpoint == true) return create_if_block_4;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(562:20) {#each ColsFirstRow as val,i}",
		ctx
	});

	return block;
}

// (572:8) {#if state.plus_minus == 1}
function create_if_block_3(ctx) {
	let griddedhelper0;
	let t;
	let griddedhelper1;
	let current;

	griddedhelper0 = new GriddedHelper({
			props: {
				loop: /*Cols*/ ctx[5],
				class1: "tdFont plus_tab points",
				className: "tdFont plus_tab items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "+"
			},
			$$inline: true
		});

	griddedhelper0.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	griddedhelper1 = new GriddedHelper({
			props: {
				loop: /*Cols_Minus*/ ctx[4],
				class1: "tdFont plus_tab",
				className: "tdFont minus_point text-center items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "-"
			},
			$$inline: true
		});

	griddedhelper1.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(griddedhelper0.$$.fragment);
			t = space();
			create_component(griddedhelper1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(griddedhelper1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper0_changes = {};
			if (dirty[0] & /*Cols*/ 32) griddedhelper0_changes.loop = /*Cols*/ ctx[5];
			griddedhelper0.$set(griddedhelper0_changes);
			const griddedhelper1_changes = {};
			if (dirty[0] & /*Cols_Minus*/ 16) griddedhelper1_changes.loop = /*Cols_Minus*/ ctx[4];
			griddedhelper1.$set(griddedhelper1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper0.$$.fragment, local);
			transition_in(griddedhelper1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper0.$$.fragment, local);
			transition_out(griddedhelper1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(griddedhelper1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(572:8) {#if state.plus_minus == 1}",
		ctx
	});

	return block;
}

// (592:8) {#if state.decimal_val == 1}
function create_if_block_2(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[3],
				class1: "tdFont points",
				className: "tdFont text-center items_element decl_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 myP",
				value: "."
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 8) griddedhelper_changes.loop = /*Cols_slash*/ ctx[3];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(592:8) {#if state.decimal_val == 1}",
		ctx
	});

	return block;
}

// (603:8) {#if state.slash_val == 1}
function create_if_block_1(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[3],
				class1: "tdFont points",
				className: "tdFont text-center items_element sla_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 myP",
				value: "/"
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 8) griddedhelper_changes.loop = /*Cols_slash*/ ctx[3];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(603:8) {#if state.slash_val == 1}",
		ctx
	});

	return block;
}

// (624:28) {:else}
function create_else_block(ctx) {
	let td;
	let span;
	let t_value = +/*no*/ ctx[32] + "";
	let t;
	let span_tabindex_value;
	let span_key_value;
	let span_name_value;
	let span_data_tag_value;
	let span_id_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "tabindex", span_tabindex_value = 0);
			attr_dev(span, "key", span_key_value = /*val*/ ctx[33].key);
			attr_dev(span, "name", span_name_value = /*val*/ ctx[33].name);
			attr_dev(span, "data-tag", span_data_tag_value = /*val*/ ctx[33].name);
			attr_dev(span, "class", "tdFont td_data text-center items_element");
			attr_dev(span, "id", span_id_value = /*val*/ ctx[33].id);
			add_location(span, file, 625, 36, 21369);
			attr_dev(td, "width", "50");
			attr_dev(td, "class", "text-center svelte-1wrfq8n");
			add_location(td, file, 624, 32, 21297);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*handleClick*/ ctx[14], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 4 && span_key_value !== (span_key_value = /*val*/ ctx[33].key)) {
				attr_dev(span, "key", span_key_value);
			}

			if (dirty[0] & /*totalCols*/ 4 && span_name_value !== (span_name_value = /*val*/ ctx[33].name)) {
				attr_dev(span, "name", span_name_value);
			}

			if (dirty[0] & /*totalCols*/ 4 && span_data_tag_value !== (span_data_tag_value = /*val*/ ctx[33].name)) {
				attr_dev(span, "data-tag", span_data_tag_value);
			}

			if (dirty[0] & /*totalCols*/ 4 && span_id_value !== (span_id_value = /*val*/ ctx[33].id)) {
				attr_dev(span, "id", span_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(624:28) {:else}",
		ctx
	});

	return block;
}

// (620:28) {#if val.decpoint == true}
function create_if_block(ctx) {
	let td;
	let td_key_value;

	const block = {
		c: function create() {
			td = element("td");
			attr_dev(td, "key", td_key_value = /*val*/ ctx[33].key);
			attr_dev(td, "class", "tdFont text-center points svelte-1wrfq8n");
			attr_dev(td, "width", "50");
			attr_dev(td, "disabled", "true");
			add_location(td, file, 620, 28, 21080);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 4 && td_key_value !== (td_key_value = /*val*/ ctx[33].key)) {
				attr_dev(td, "key", td_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(620:28) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (619:24) {#each totalCols as val, i}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*val*/ ctx[33].decpoint == true) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(619:24) {#each totalCols as val, i}",
		ctx
	});

	return block;
}

// (617:16) {#each totalRows as data, no}
function create_each_block(ctx) {
	let tr;
	let t;
	let tr_key_value;
	let each_value_1 = /*totalCols*/ ctx[2];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "key", tr_key_value = "row" + /*no*/ ctx[32]);
			add_location(tr, file, 617, 20, 20926);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols, handleClick*/ 16388) {
				each_value_1 = /*totalCols*/ ctx[2];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(617:16) {#each totalRows as data, no}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div23;
	let table0;
	let tbody;
	let tr;
	let table0_style_value;
	let t0;
	let t1;
	let t2;
	let t3;
	let table1;
	let t4;
	let div22;
	let div21;
	let h2;
	let button;
	let t6;
	let div20;
	let div19;
	let div6;
	let div2;
	let div0;
	let t8;
	let div1;
	let input0;
	let input0_value_value;
	let t9;
	let div5;
	let div3;
	let t11;
	let div4;
	let input1;
	let input1_value_value;
	let t12;
	let div11;
	let div8;
	let div7;
	let input2;
	let input2_inputprops_value;
	let label0;
	let t14;
	let div10;
	let div9;
	let input3;
	let input3_inputprops_value;
	let label1;
	let t16;
	let div16;
	let div13;
	let div12;
	let input4;
	let input4_inputprops_value;
	let t17;
	let label2;
	let t19;
	let div15;
	let div14;
	let input5;
	let input5_inputprops_value;
	let label3;
	let t21;
	let div18;
	let div17;
	let input6;
	let input6_style_value;
	let current;
	let mounted;
	let dispose;
	let each_value_2 = /*ColsFirstRow*/ ctx[6];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block0 = /*state*/ ctx[0].plus_minus == 1 && create_if_block_3(ctx);
	let if_block1 = /*state*/ ctx[0].decimal_val == 1 && create_if_block_2(ctx);
	let if_block2 = /*state*/ ctx[0].slash_val == 1 && create_if_block_1(ctx);
	let each_value = /*totalRows*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			main = element("main");
			div23 = element("div");
			table0 = element("table");
			tbody = element("tbody");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			table1 = element("table");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div22 = element("div");
			div21 = element("div");
			h2 = element("h2");
			button = element("button");
			button.textContent = `${language.layout_options}`;
			t6 = space();
			div20 = element("div");
			div19 = element("div");
			div6 = element("div");
			div2 = element("div");
			div0 = element("div");
			div0.textContent = `${language.row_count}`;
			t8 = space();
			div1 = element("div");
			input0 = element("input");
			t9 = space();
			div5 = element("div");
			div3 = element("div");
			div3.textContent = `${language.col_count}`;
			t11 = space();
			div4 = element("div");
			input1 = element("input");
			t12 = space();
			div11 = element("div");
			div8 = element("div");
			div7 = element("div");
			input2 = element("input");
			label0 = element("label");
			label0.textContent = "Plus/Minus Column";
			t14 = space();
			div10 = element("div");
			div9 = element("div");
			input3 = element("input");
			label1 = element("label");
			label1.textContent = "Fraction/Slash";
			t16 = space();
			div16 = element("div");
			div13 = element("div");
			div12 = element("div");
			input4 = element("input");
			t17 = space();
			label2 = element("label");
			label2.textContent = "Fixed Decimal";
			t19 = space();
			div15 = element("div");
			div14 = element("div");
			input5 = element("input");
			label3 = element("label");
			label3.textContent = "Floating Decimal";
			t21 = space();
			div18 = element("div");
			div17 = element("div");
			input6 = element("input");
			add_location(tr, file, 560, 16, 18428);
			add_location(tbody, file, 559, 12, 18404);
			attr_dev(table0, "border", "1");
			attr_dev(table0, "id", "tab2");
			attr_dev(table0, "class", "tab2");
			attr_dev(table0, "style", table0_style_value = "border-collapse: collapse;text-align: center;");
			add_location(table0, file, 558, 8, 18292);
			attr_dev(table1, "id", "gridded_sheet");
			attr_dev(table1, "class", "gridded_tab lastGrid mt-0 myP svelte-1wrfq8n");
			add_location(table1, file, 614, 8, 20782);
			attr_dev(button, "class", "accordion-button collapsed py-0");
			attr_dev(button, "type", "button");
			attr_dev(button, "data-bs-toggle", "collapse");
			attr_dev(button, "data-bs-target", "#collapseOne");
			attr_dev(button, "aria-expanded", "false");
			attr_dev(button, "aria-controls", "collapseOne");
			add_location(button, file, 637, 16, 21934);
			attr_dev(h2, "class", "accordion-header mt-0");
			attr_dev(h2, "id", "headingOne");
			add_location(h2, file, 636, 12, 21867);
			attr_dev(div0, "class", "font-weight-bold");
			add_location(div0, file, 646, 28, 22516);
			attr_dev(input0, "type", "number");
			attr_dev(input0, "min", "1");
			attr_dev(input0, "max", "10");
			input0.value = input0_value_value = /*state*/ ctx[0].rowNum;
			attr_dev(input0, "name", "col_range");
			attr_dev(input0, "id", "col_range");
			attr_dev(input0, "class", "form-control  inline-block");
			attr_dev(input0, "data-label", "Number of rows");
			add_location(input0, file, 648, 32, 22632);
			add_location(div1, file, 647, 28, 22594);
			attr_dev(div2, "class", "col-sm-6");
			add_location(div2, file, 645, 24, 22465);
			attr_dev(div3, "class", "font-weight-bold");
			add_location(div3, file, 652, 28, 22956);
			attr_dev(input1, "type", "number");
			attr_dev(input1, "min", "1");
			attr_dev(input1, "max", "6");
			input1.value = input1_value_value = /*state*/ ctx[0].colNum;
			attr_dev(input1, "name", "col_nmbr");
			attr_dev(input1, "id", "col_range");
			attr_dev(input1, "class", "form-control  inline-block");
			attr_dev(input1, "data-label", "Number of rows");
			add_location(input1, file, 654, 32, 23072);
			add_location(div4, file, 653, 28, 23034);
			attr_dev(div5, "class", "col-sm-6");
			add_location(div5, file, 651, 24, 22905);
			attr_dev(div6, "class", "row form-group");
			add_location(div6, file, 643, 20, 22395);
			attr_dev(input2, "type", "checkbox");
			attr_dev(input2, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input2, "id", "plus_minus_checkbox");
			attr_dev(input2, "inputprops", input2_inputprops_value = { "aria-label": "Plus/Minus Column" });
			add_location(input2, file, 662, 36, 23554);
			attr_dev(label0, "for", "plus_minus_checkbox");
			attr_dev(label0, "class", "pl-1");
			add_location(label0, file, 666, 38, 23893);
			attr_dev(div7, "class", "inline-block");
			add_location(div7, file, 661, 28, 23491);
			attr_dev(div8, "class", "col-sm-6");
			add_location(div8, file, 660, 24, 23440);
			attr_dev(input3, "type", "checkbox");
			attr_dev(input3, "id", "fraction_slash_checkbox");
			attr_dev(input3, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input3, "inputprops", input3_inputprops_value = { "aria-label": "Fraction/Slash" });
			add_location(input3, file, 671, 36, 24169);
			attr_dev(label1, "for", "fraction_slash_checkbox");
			attr_dev(label1, "class", "pl-1");
			add_location(label1, file, 671, 208, 24341);
			attr_dev(div9, "class", "inline-block");
			add_location(div9, file, 670, 28, 24106);
			attr_dev(div10, "class", "col-sm-6");
			add_location(div10, file, 669, 24, 24055);
			attr_dev(div11, "class", "row form-group");
			add_location(div11, file, 659, 20, 23387);
			attr_dev(input4, "type", "checkbox");
			attr_dev(input4, "id", "fixed_decimal_checkbox");
			attr_dev(input4, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input4, "inputprops", input4_inputprops_value = { "aria-label": "Fixed Decimal" });
			add_location(input4, file, 679, 32, 24685);
			attr_dev(label2, "for", "fixed_decimal_checkbox");
			attr_dev(label2, "class", "pl-1");
			add_location(label2, file, 680, 35, 24882);
			attr_dev(div12, "class", "inline-block");
			add_location(div12, file, 678, 24, 24626);
			attr_dev(div13, "class", "col-sm-6");
			add_location(div13, file, 677, 20, 24579);
			attr_dev(input5, "type", "checkbox");
			attr_dev(input5, "id", "floating_decimal_checkbox");
			attr_dev(input5, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input5, "inputprops", input5_inputprops_value = { "aria-label": "Floating Decimal" });
			add_location(input5, file, 685, 28, 25134);
			attr_dev(label3, "for", "floating_decimal_checkbox");
			attr_dev(label3, "class", "pl-1");
			add_location(label3, file, 686, 30, 25340);
			attr_dev(div14, "class", "inline-block");
			add_location(div14, file, 684, 24, 25079);
			attr_dev(div15, "class", "col-sm-6");
			add_location(div15, file, 683, 20, 25032);
			attr_dev(div16, "class", "row form-group");
			add_location(div16, file, 676, 16, 24530);
			attr_dev(input6, "type", "number");
			attr_dev(input6, "min", "1");
			attr_dev(input6, "max", "7");
			attr_dev(input6, "name", "Fixed_decimal_column");
			attr_dev(input6, "id", "Fixed_decimal_column");
			attr_dev(input6, "class", "form-control  inline-block");
			attr_dev(input6, "placeholder", "Fixed decimal column");
			attr_dev(input6, "style", input6_style_value = "display: none");
			attr_dev(input6, "data-label", "Fixed decimal column");
			input6.disabled = "true";
			add_location(input6, file, 692, 24, 25605);
			add_location(div17, file, 691, 20, 25575);
			attr_dev(div18, "class", "col-sm-6 inline-block pl-0");
			add_location(div18, file, 690, 16, 25514);
			attr_dev(div19, "class", "accordion-body");
			add_location(div19, file, 642, 16, 22346);
			attr_dev(div20, "id", "collapseOne");
			attr_dev(div20, "class", "accordion-collapse collapse");
			attr_dev(div20, "aria-labelledby", "headingOne");
			attr_dev(div20, "data-bs-parent", "#accordionExample");
			add_location(div20, file, 641, 12, 22198);
			attr_dev(div21, "class", "accordion-item");
			add_location(div21, file, 635, 12, 21826);
			attr_dev(div22, "class", "accordion mt-5");
			attr_dev(div22, "id", "accordionExample");
			set_style(div22, "background-color", "#F0F0F0");
			add_location(div22, file, 634, 8, 21729);
			attr_dev(div23, "class", "griddedModule svelte-1wrfq8n");
			add_location(div23, file, 557, 4, 18256);
			add_location(main, file, 556, 0, 18245);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div23);
			append_dev(div23, table0);
			append_dev(table0, tbody);
			append_dev(tbody, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(div23, t0);
			if (if_block0) if_block0.m(div23, null);
			append_dev(div23, t1);
			if (if_block1) if_block1.m(div23, null);
			append_dev(div23, t2);
			if (if_block2) if_block2.m(div23, null);
			append_dev(div23, t3);
			append_dev(div23, table1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(table1, null);
			}

			append_dev(div23, t4);
			append_dev(div23, div22);
			append_dev(div22, div21);
			append_dev(div21, h2);
			append_dev(h2, button);
			append_dev(div21, t6);
			append_dev(div21, div20);
			append_dev(div20, div19);
			append_dev(div19, div6);
			append_dev(div6, div2);
			append_dev(div2, div0);
			append_dev(div2, t8);
			append_dev(div2, div1);
			append_dev(div1, input0);
			append_dev(div6, t9);
			append_dev(div6, div5);
			append_dev(div5, div3);
			append_dev(div5, t11);
			append_dev(div5, div4);
			append_dev(div4, input1);
			append_dev(div19, t12);
			append_dev(div19, div11);
			append_dev(div11, div8);
			append_dev(div8, div7);
			append_dev(div7, input2);
			append_dev(div7, label0);
			append_dev(div11, t14);
			append_dev(div11, div10);
			append_dev(div10, div9);
			append_dev(div9, input3);
			append_dev(div9, label1);
			append_dev(div19, t16);
			append_dev(div19, div16);
			append_dev(div16, div13);
			append_dev(div13, div12);
			append_dev(div12, input4);
			append_dev(div12, t17);
			append_dev(div12, label2);
			append_dev(div16, t19);
			append_dev(div16, div15);
			append_dev(div15, div14);
			append_dev(div14, input5);
			append_dev(div14, label3);
			append_dev(div19, t21);
			append_dev(div19, div18);
			append_dev(div18, div17);
			append_dev(div17, input6);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "change", /*changeRowCol*/ ctx[11], false, false, false),
					listen_dev(input1, "change", /*changeRowCol*/ ctx[11], false, false, false),
					listen_dev(input2, "click", /*plusMinusSetVal*/ ctx[7], false, false, false),
					listen_dev(input3, "click", /*slashFuncSetVal*/ ctx[8], false, false, false),
					listen_dev(input4, "click", /*fixedFunc*/ ctx[9], false, false, false),
					listen_dev(input5, "click", /*decimalFuncSetVal*/ ctx[10], false, false, false),
					listen_dev(input6, "change", /*fixedDecimalPoints*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsFirstRow, rowValidation*/ 8256) {
				each_value_2 = /*ColsFirstRow*/ ctx[6];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (/*state*/ ctx[0].plus_minus == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*state*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div23, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[0].decimal_val == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*state*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div23, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[0].slash_val == 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*state*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div23, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*totalCols, handleClick, totalRows*/ 16390) {
				each_value = /*totalRows*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(table1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*state*/ 1 && input0_value_value !== (input0_value_value = /*state*/ ctx[0].rowNum)) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (!current || dirty[0] & /*state*/ 1 && input1_value_value !== (input1_value_value = /*state*/ ctx[0].colNum)) {
				prop_dev(input1, "value", input1_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_each(each_blocks_1, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function highLight(event) {
	let cell_class = event.target.getAttribute("name");
	let column_index = document.getElementsByName(cell_class);

	for (let i = 1; i < column_index.length; i++) {
		if (column_index[i].classList.contains("active")) {
			column_index[i].classList.remove("active");
		}

		if (column_index[i].innerHTML == event.target.value) {
			column_index[i].classList.add("active");
		}
	}
}

function removeClass() {
	let el = document.getElementsByClassName("points");

	for (let i = 0; i < el.length; i++) {
		if (el[i].classList.contains("active")) {
			el[i].classList.remove("active");
		}
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Gridded", slots, []);
	let state = {};
	let { getChildXml } = $$props;
	let correctAns = [];
	let { xml } = $$props;

	let stateData = writable({
		rowNum: 4,
		colNum: 4,
		tableName: "Gridded System",
		plus_minus: 0,
		slash_val: 0,
		decimal_val: 0,
		xml: "",
		textSize: 14,
		resAns: "",
		correctAns: [],
		listAns: [],
		res: "",
		fixed_decimal_val: 0,
		decimal_point: 0
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	beforeUpdate(() => {
		AI.selectAll(".tdFont", "css", { fontSize: "14px" });
	});

	onMount(() => {
		AH.listen("body", "keydown", ".td_data", (_this, e) => {
			console.log("Evnts => ", e);

			if (e.which === 13) {
				_this.click();
			}
		});
	});

	afterUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			loadModule(xml);
		}

		firstRowItem();
		slashFunc();
		decimalFloating();
		plusMinusSign();
		createdSheetRow();
	});

	function loadModule(loadXml) {
		loadXml = XMLToJSON(loadXml);
		parseXMLAuthoring(loadXml);
	}

	function parseXMLAuthoring(MYXML) {
		try {
			$$invalidate(0, state.rowNum = MYXML.smxml._row, state);
			$$invalidate(0, state.colNum = MYXML.smxml._col, state);
			$$invalidate(0, state.slash_val = MYXML.smxml._slash, state);
			$$invalidate(0, state.plus_minus = MYXML.smxml._plusminus, state);
			$$invalidate(0, state.decimal_val = MYXML.smxml._decimal, state);
			$$invalidate(0, state.textSize = MYXML.smxml._font, state);
			$$invalidate(0, state.correctAns = MYXML.smxml._correctAns, state);
			getChildXml(JSONToXML(MYXML));

			if (MYXML.smxml._plusminus == 1) {
				document.getElementById("plus_minus_checkbox").checked = true;
			}

			if (MYXML.smxml._slash == 1) {
				document.getElementById("fraction_slash_checkbox").checked = true;
			}

			if (MYXML.smxml._decimal == 1) {
				document.getElementById("floating_decimal_checkbox").checked = true;
			}
		} catch(events) {
			console.warn({
				"error": events.message,
				"function name": "parseXMLAuthoring",
				"File name": "Gridded.js"
			});
		}
	}

	// Set boolean value in plus/minus
	function plusMinusSetVal() {
		$$invalidate(0, state.plus_minus = state.plus_minus == 0 ? 1 : 0, state);
		updateXml();
	}

	// slash function set value true or false
	function slashFuncSetVal(event) {
		$$invalidate(0, state.slash_val = state.slash_val == 0 ? 1 : 0, state);
		updateXml();
	}

	// This function disable decimal input box
	function fixedFunc(event) {
		if (state.fixed_decimal_val == 0) {
			$$invalidate(0, state.fixed_decimal_val = 1, state);
			let elem = document.getElementById("Fixed_decimal_column");
			elem.disabled = false;
			elem.style.display = "inline-block";
		} else {
			$$invalidate(0, state.fixed_decimal_val = 0, state);
			$$invalidate(0, state.decimal_point = 0, state);
			let elem = document.getElementById("Fixed_decimal_column");
			elem.value = " ";
			elem.disabled = true;
			elem.style.display = "none";
			updateXml();
		}
	}

	// Set value decimal floating
	function decimalFuncSetVal(event) {
		$$invalidate(0, state.decimal_val = state.decimal_val == 0 ? 1 : 0, state);
		updateXml();
	}

	// This function decided to row or column function
	function changeRowCol(event) {
		if (event.target.value.length > 1) {
			AH.alert("accept only single value");
			event.target.value = 4;
			return false;
		}

		console.log("check");
		let val = event.target.value;

		if (!(val > 0 && val <= 10)) {
			AH.alert(language.grid_one_to_ten);
			return false;
		}

		if (event.target.name == "col_nmbr") {
			if (event.target.value < 1) {
				AH.alert(language.col_less_one);
				eva;
				event.target.value = 1;
				return false;
			} else if (event.target.value > 6) {
				AH.alert(language.type_one_to_seven);
				event.target.value = "";
				return false;
			}

			$$invalidate(0, state.colNum = event.target.value, state);
		} else {
			if (event.target.value < 1) {
				AH.alert(language.row_less_one);
				event.target.value = 1;
				return false;
			} else if (event.target.value > 10) {
				AH.alert(language.type_one_to_ten);
				event.target.value = "";
				return false;
			}

			$$invalidate(0, state.rowNum = event.target.value, state);
		}

		updateXml();
	}

	function fixedDecimalPoints(event) {
		let decimalPosition = event.target.value;

		if (event.target.value.length > 1) {
			AH.alert("accept only single value");
			event.target.value = "";
			return false;
		}

		if (event.target.value == "") {
			decimalPosition = "";
		}

		if (event.target.value.length > 1 || event.target.value < 1 || state.colNum <= event.target.value) {
			decimalPosition = 1;
			event.target.value = 1;
			AH.alert(language.decimal_position + (state.colNum - 1) + ".");

			//$(".sa-info").show();
			document.querySelector(".sa-info").style.display = "block";
		}

		$$invalidate(0, state.decimal_point = decimalPosition, state);
		updateXml();
	}

	// Update the xml
	function updateXml() {
		// setTimeout( function() {
		let updatedXml = "<smxml type=\"56\" name=\"Gridded\" plusminus=\"" + state.plus_minus + "\" slash=\"" + state.slash_val + "\" decimal=\"" + state.decimal_val + "\" fixed_point=\"" + state.decimal_point + "\" font=\"" + state.textSize + "\" row=\"" + state.rowNum + "\" col=\"" + state.colNum + "\" correctAns=\"" + state.res + "\" ><!--[CDATA[]]--></smxml>";

		getChildXml(updatedXml);
	} // }, 500);

	// Create a sheet according to range
	let totalRows = [], totalCols = [];

	function createdSheetRow() {
		AH.select(".tdFont", "css", { fontSize: state.textSize });
		$$invalidate(1, totalRows = []);
		let dec_point = state.decimal_point;

		for (let i = 0; i < state.rowNum; i++) {
			$$invalidate(2, totalCols = []);

			for (let j = 0; j < state.colNum; j++) {
				if (j == dec_point - 1 && dec_point != 0) {
					$$invalidate(2, totalCols = [...totalCols, { key: "col" + i + j, decpoint: true }]);
				} else {
					if (totalCols.length < state.colNum) {
						$$invalidate(2, totalCols = [
							...totalCols,
							{
								key: "col" + i + j,
								name: j,
								id: "td" + j + "-" + i + j,
								decpoint: false
							}
						]);
					}
				}
			}

			$$invalidate(1, totalRows = [...totalRows, { key: "row" + i }]);
		}
	}

	

	// created a slash row in gridded sheet
	let Cols_slash;

	function slashFunc(event) {
		$$invalidate(3, Cols_slash = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(3, Cols_slash = [...Cols_slash, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_slash.length < state.colNum) {
					$$invalidate(3, Cols_slash = [
						...Cols_slash,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// Create a decimal floating row
	let Cols_decimal;

	function decimalFloating(event) {
		Cols_decimal = [];
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				Cols_decimal = [...Cols_decimal, { key: "col" + j, decpoint: true }];
			} else {
				if (Cols_decimal.length < state.colNum) {
					Cols_decimal.push(Cols_decimal = [
						...Cols_decimal,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// create plus and minus row
	let Cols_Minus = [], Cols = [];

	function plusMinusSign(event) {
		$$invalidate(5, Cols = []);
		$$invalidate(4, Cols_Minus = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(5, Cols = [
					...Cols,
					{
						id: "td" + j,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols.length < state.colNum) {
					$$invalidate(5, Cols = [
						...Cols,
						{
							id: "td" + j,
							dataTag: j,
							name: j,
							decpoint: false
						}
					]);
				}
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(4, Cols_Minus = [
					...Cols_Minus,
					{
						id: "td" + j,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols_Minus.length < state.colNum) {
					$$invalidate(4, Cols_Minus = [
						...Cols_Minus,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// Create very first row and store data according to click
	let ColsFirstRow = [];

	function firstRowItem() {
		$$invalidate(6, ColsFirstRow = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j === dec_point - 1 && dec_point != 0) {
				$$invalidate(6, ColsFirstRow = [...ColsFirstRow, { decpoint: true }]);
			} else {
				if (ColsFirstRow.length < state.colNum) {
					$$invalidate(6, ColsFirstRow = [
						...ColsFirstRow,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// Check validation first row input type
	function rowValidation(event) {
		console.log("number" + state.plus_minus);
		let a = state.rowNum - 1;

		if (event.target.value.length > 1) {
			AH.alert(language.double_digit);
			event.target.value = "";
			return false;
		} else if (event.target.value < 0) {
			AH.alert(language.less_one);
			event.target.value = "";
			return false;
		} else if (a < event.target.value) {
			AH.alert(language.number_from + a);
			event.target.value = "";
			return false;
		} else if (state.plus_minus == 0 && event.target.value == "+" || event.target.value == "-") {
			AH.alert("Plz select plus and minus option");
			event.target.value = "";
			return false;
		} else if (state.slash_val == 0 && event.target.value == "/") {
			AH.alert("Plz select slash option");
			event.target.value = "";
			return false;
		} else if (state.decimal_val == 0 && event.target.value == ".") {
			AH.alert("Plz select decimal option");
			event.target.value = "";
			return false;
		}

		let attribute = event.target.attributes.getNamedItem("data-tag").value;
		correctAns[attribute] = event.target.value;

		for (let i = 0; i < correctAns.length; i++) {
			if (typeof correctAns[i] == "undefined" || correctAns[i] == "") {
				correctAns[i] = "%blank%";
			} //console.log(correctAns);
		}

		if (correctAns[correctAns.length - 1] == "%blank%") {
			correctAns.pop();
		}

		$$invalidate(0, state.listAns = correctAns, state);
		$$invalidate(0, state.res = state.listAns.toString(), state);
		updateXml();
	}

	function handleClick(event) {
		let cell_class = event.target.getAttribute("name");
		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.target.classList.add("active");
		let target_id = event.target.id;
		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.target.innerHTML;
		let attribute = event.target.attributes.getNamedItem("data-tag").value;
		correctAns[attribute] = event.target.innerHTML;

		for (let i = 0; i < correctAns.length; i++) {
			if (typeof correctAns[i] == "undefined") {
				correctAns[i] = "%blank%";
			} //console.log(correctAns);
		}

		$$invalidate(0, state.listAns = correctAns, state);
		$$invalidate(0, state.res = state.listAns.toString(), state);
		updateXml();
	}

	// Insert a data in top row according to click  and change colors
	function handleClickCombo(event) {
		//let cell_class = event.target.getAttribute('name');
		let cell_class = event.detail.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.detail.target.classList.add("active");
		let target_id = event.detail.target.id;
		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.detail.target.innerHTML;

		//let attribute = event.target.attributes.getNamedItem('data-tag').value;
		let attribute = event.detail.target.attributes.getNamedItem("data-tag").value;

		correctAns[attribute] = event.detail.target.innerHTML;

		for (let i = 0; i < correctAns.length; i++) {
			if (typeof correctAns[i] == "undefined") {
				correctAns[i] = "%blank%";
			} //console.log(correctAns);
		}

		$$invalidate(0, state.listAns = correctAns, state);
		$$invalidate(0, state.res = state.listAns.toString(), state);
		updateXml();
	}

	const writable_props = ["getChildXml", "xml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Gridded> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("getChildXml" in $$props) $$invalidate(16, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(17, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		l: language,
		writable,
		AH,
		XMLToJSON,
		JSONToXML,
		onMount,
		afterUpdate,
		beforeUpdate,
		GriddedHelper,
		state,
		getChildXml,
		correctAns,
		xml,
		stateData,
		unsubscribe,
		loadModule,
		parseXMLAuthoring,
		plusMinusSetVal,
		slashFuncSetVal,
		fixedFunc,
		decimalFuncSetVal,
		changeRowCol,
		fixedDecimalPoints,
		updateXml,
		totalRows,
		totalCols,
		createdSheetRow,
		Cols_slash,
		slashFunc,
		Cols_decimal,
		decimalFloating,
		Cols_Minus,
		Cols,
		plusMinusSign,
		ColsFirstRow,
		firstRowItem,
		rowValidation,
		highLight,
		handleClick,
		handleClickCombo,
		removeClass
	});

	$$self.$inject_state = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("getChildXml" in $$props) $$invalidate(16, getChildXml = $$props.getChildXml);
		if ("correctAns" in $$props) correctAns = $$props.correctAns;
		if ("xml" in $$props) $$invalidate(17, xml = $$props.xml);
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("totalRows" in $$props) $$invalidate(1, totalRows = $$props.totalRows);
		if ("totalCols" in $$props) $$invalidate(2, totalCols = $$props.totalCols);
		if ("Cols_slash" in $$props) $$invalidate(3, Cols_slash = $$props.Cols_slash);
		if ("Cols_decimal" in $$props) Cols_decimal = $$props.Cols_decimal;
		if ("Cols_Minus" in $$props) $$invalidate(4, Cols_Minus = $$props.Cols_Minus);
		if ("Cols" in $$props) $$invalidate(5, Cols = $$props.Cols);
		if ("ColsFirstRow" in $$props) $$invalidate(6, ColsFirstRow = $$props.ColsFirstRow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		totalRows,
		totalCols,
		Cols_slash,
		Cols_Minus,
		Cols,
		ColsFirstRow,
		plusMinusSetVal,
		slashFuncSetVal,
		fixedFunc,
		decimalFuncSetVal,
		changeRowCol,
		fixedDecimalPoints,
		rowValidation,
		handleClick,
		handleClickCombo,
		getChildXml,
		xml
	];
}

class Gridded extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-1wrfq8n-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { getChildXml: 16, xml: 17 }, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gridded",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[16] === undefined && !("getChildXml" in props)) {
			console_1.warn("<Gridded> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[17] === undefined && !("xml" in props)) {
			console_1.warn("<Gridded> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<Gridded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<Gridded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<Gridded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<Gridded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Gridded;
//# sourceMappingURL=Gridded-db3af316.js.map
