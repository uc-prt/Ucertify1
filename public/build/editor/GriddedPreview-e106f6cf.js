
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, C as validate_each_argument, v as validate_slots, o as onMount, A as AH, L as beforeUpdate, y as language, w as writable, X as XMLToJSON, M as JSONToXML, a7 as afterUpdate, z as empty, n as insert_dev, x as detach_dev, c as create_component, f as space, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, j as attr_dev, k as add_location, K as destroy_each, l as set_style, r as group_outros, u as check_outros, $ as null_to_empty, q as listen_dev, G as prop_dev, H as run_all, B as noop, h as text } from './main-ad414885.js';
import { I as ItemHelper } from './ItemHelper-c5a04a61.js';
import { G as GriddedHelper } from './GriddedHelper-9c3c918d.js';

/* clsSMGridded/GriddedPreview.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMGridded/GriddedPreview.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1ersj3w-style";
	style.textContent = ".layoutHeading.svelte-1ersj3w.svelte-1ersj3w{font-weight:bold;font-size:16px;color:#1877b1}.items_element.svelte-1ersj3w.svelte-1ersj3w:hover{border:1.2px solid #777}.moreOptions.svelte-1ersj3w.svelte-1ersj3w{-webkit-box-shadow:3px 4px 6px #c4c5c5;-moz-box-shadow:3px 4px 6px #c4c5c5;box-shadow:3px 4px 6px #c4c5c5;background-color:#f0f0f0;border-top:1px solid #1877b1;border-bottom:1px solid #1877b1}.moreOptionDetails.svelte-1ersj3w.svelte-1ersj3w{background-color:#f7f7f7}.input_col.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:5px}.layoutheading.svelte-1ersj3w.svelte-1ersj3w{padding:5px;font-size:20px;font-weight:bold}.numbr_range.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:130px}.numbr_range_txt.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:200px}.plus_minus_fraction.svelte-1ersj3w.svelte-1ersj3w{position:relative;top:20px}.floating_fraction.svelte-1ersj3w.svelte-1ersj3w{position:relative;top:27px}.plus_minus_span.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:5px}.floating_decimal.svelte-1ersj3w.svelte-1ersj3w{float:right;margin-right:45px}.fontStyle.svelte-1ersj3w.svelte-1ersj3w{width:100px;float:right;margin-right:60px}.fraction_slash.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:177px}.minus_tab.svelte-1ersj3w.svelte-1ersj3w,.plus_tab.svelte-1ersj3w.svelte-1ersj3w,.slash_tab.svelte-1ersj3w.svelte-1ersj3w{text-align:center}.gridded_tab.svelte-1ersj3w.svelte-1ersj3w{background-color:#f0f0f0;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.font_size_label.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:198px}.font_size.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:225px}.decimal_col.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:208px;width:90px}.correct_color.svelte-1ersj3w.svelte-1ersj3w{background-color:#E9FFE9}.fixed_decimal_check.svelte-1ersj3w.svelte-1ersj3w{position:relative;top:26px;left:13px}.correct_incorrect_icon_fill.svelte-1ersj3w.svelte-1ersj3w{position:relative;width:19px;height:19px;right:121px;top:-55px;background:white;border-radius:50%}.row_column_decimal.svelte-1ersj3w.svelte-1ersj3w{position:relative;top:30px;left:5px}.fixed_point_class.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:7px}.row_column.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:5px}.answer_icon.svelte-1ersj3w.svelte-1ersj3w{position:absolute;top:7px;right:34px}.myP.svelte-1ersj3w tbody.svelte-1ersj3w{cursor:pointer}.col_range.svelte-1ersj3w.svelte-1ersj3w{width:205px}.posSize.svelte-1ersj3w.svelte-1ersj3w{position:relative;left:7px}.fontSmall.svelte-1ersj3w.svelte-1ersj3w{font-size:12px;text-align:center}.fontNormal.svelte-1ersj3w.svelte-1ersj3w{font-size:14px;text-align:center}.fontLarge.svelte-1ersj3w.svelte-1ersj3w{font-size:24px;text-align:center}.fontExtraLarge.svelte-1ersj3w.svelte-1ersj3w{font-size:26px;text-align:center}.grid.svelte-1ersj3w.svelte-1ersj3w{position:relative;top:10px;box-shadow:10px 5px 10px #000}.items_element{border:1px solid #8080807a;padding:6px 10px;border-radius:50%;background-color:white}.griddedModule .active{color:white;transition:1s;background:#696969;border:2px solid #fff}.minus_point.svelte-1ersj3w.svelte-1ersj3w,.decl_point.svelte-1ersj3w.svelte-1ersj3w{padding:6px 12px}.sla_point.svelte-1ersj3w.svelte-1ersj3w{padding:6px 11px}.griddedModule.svelte-1ersj3w table tr td.svelte-1ersj3w:last-child{border-right:1px solid #ccc !important}.griddedModule.svelte-1ersj3w .lastGrid tr:last-child td.svelte-1ersj3w{border-bottom:1px solid #ccc !important}.griddedModule.svelte-1ersj3w td.svelte-1ersj3w{border:1px solid #f0f0f0 !important;border-left:1px solid #ccc !important}.token.svelte-1ersj3w.svelte-1ersj3w:hover{border:1px solid #000 !important}.bla .token:hover{border:1px solid #fff !important}.token_selected.svelte-1ersj3w.svelte-1ersj3w{background-color:#64bb63;color:#fff}.bla .token_highlight_heading{color:#000 !important}.griddedModule.svelte-1ersj3w .expandIcon.svelte-1ersj3w{font-size:27px;font-weight:bold;color:#1877b1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZGRlZFByZXZpZXcuc3ZlbHRlIiwic291cmNlcyI6WyJHcmlkZGVkUHJldmlldy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBcbiAqICBGaWxlIE5hbWUgICA6IEdyaWRkZWRQcmV2aWV3LmpzXG4gKiAgRGVzY3JpcHRpb24gOiBTaG93aW5nIHRoZSBncmlkZGVkIHNoZWV0IGZvciBzdHVkZW50XG4gKiAgQXV0aG9yICAgICAgOiBTdW5kYXJhbSBUcmlwYXRoaVxuICogIFZlcnNpb24gICAgIDogMS4wXG4gKiAgUGFja2FnZSAgICAgOiBwZS1nb2xkXG4gKiAgTGFzdCB1cGRhdGUgOiAxNC1NYXJjaC0yMDIxICAtLT5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0IGwgZnJvbSAnLi4vc3JjL2xpYnMvZWRpdG9yTGliL2xhbmd1YWdlLmpzJztcbiAgICBpbXBvcnQgSXRlbUhlbHBlciBmcm9tICcuLi9oZWxwZXIvSXRlbUhlbHBlci5zdmVsdGUnO1xuICAgIGltcG9ydCB7d3JpdGFibGV9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG4gICAgaW1wb3J0IHtBSCxYTUxUb0pTT04sSlNPTlRvWE1MfSBmcm9tIFwiLi4vaGVscGVyL0hlbHBlckFJLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBiZWZvcmVVcGRhdGUsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCBHcmlkZGVkSGVscGVyIGZyb20gJy4vR3JpZGRlZEhlbHBlci5zdmVsdGUnO1xuICAgIFxuXG5cblxuICAgIGV4cG9ydCBsZXQgaXNSZXZpZXc7XG4gICAgZXhwb3J0IGxldCB4bWw7XG4gICAgZXhwb3J0IGxldCBzaG93QW5zO1xuXG4gICAgLy8gRGVjbGFyZSBnbG9iYWwgdmFyaWFibGVzIC8vLy9cblxuICAgIGxldCBib29sID0gJyAnOyBcbiAgICBsZXQgdXNlckFucyA9IFtdO1xuICAgIGxldCBhbnMgPSBbXTtcbiAgICBsZXQgbXlBbnMgPSBbXTtcbiAgICBsZXQgYyA9IDA7XG4gICAgbGV0IGNvcnJlY3RJbmM7XG4gICAgbGV0IGlzQW5zd2VyQ29ycmVjdCA9ICcnO1xuICAgIGxldCBhbnN3ZXJTdGF0dXMgPSAnJztcbiAgICBsZXQgYXV0aEFuc1NwbGl0O1xuICAgIGxldCBpbmNvcnJlY3RDbHMgPSBcIlwiO1xuXG5cblxuICAgIGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7ICBcbiAgICAgICAgcm93TnVtICAgICAgICAgICAgICAgICAgOiA0LFxuICAgICAgICBjb2xOdW0gICAgICAgICAgICAgICAgICA6IDQsXG4gICAgICAgIGl0ZW0gICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICAgICAgcGx1c19taW51cyAgICAgICAgICAgICAgOiAwLFxuICAgICAgICBzbGFzaF92YWwgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIGRlY2ltYWxfdmFsICAgICAgICAgICAgIDogMCxcbiAgICAgICAgeG1sICAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgdGV4dFNpemVQICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICBjb3JyZWN0QW5zICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB1c2VyTGlzdCAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICBpc01hdGhxdWlsbCAgICAgICAgICAgICA6ZmFsc2UsXG4gICAgICAgIHNtQ29udHJvbGxlciAgICAgICAgICAgIDogXCJoXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHMgICAgICAgICAgIDogXCJhdXRvXCIsXG4gICAgICAgIGRlY2ltYWxfcG9pbnQgICAgICAgICAgIDogMCxcbiAgICAgICAgaWNvblZpc2libGUgICAgICAgICAgICAgOiBcImhcIixcbiAgICAgICAgXG4gICAgfSlcblxuICAgIGxldCBzdGF0ZSA9IHt9O1xuICAgIFxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RhdGVEYXRhLnN1YnNjcmliZSgoaXRlbXMpPT57XG4gICAgICAgIHN0YXRlID0gaXRlbXM7XG4gICAgfSlcblxuICAgICQ6e1xuICAgICAgICBpZiAoaXNSZXZpZXcpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXZpZXcoKTsgXG4gICAgICAgICAgICAgICAvLyB0aGlzLmNoZWNrQW5zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdW5zZXRSZXZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91bnQoKCk9PntcbiAgICAgICAgLy8gJCgnYm9keScpLm9uKCdrZXlkb3duJywgJy50ZF9kYXRhJywgZnVuY3Rpb24oZSkgeyBcbiAgICAgICAgLy8gICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAvLyAgICAgICAgICQodGhpcykuY2xpY2soKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfSk7XG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwna2V5ZG93bicsJy50ZF9kYXRhJywoKGUpPT57XG4gICAgICAgICAgICBpZihlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgIGUuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpXG5cbiAgICAgICAgLy8galF1ZXJ5KCcjc21fY29udHJvbGxlciBidXR0b24nKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgIGpRdWVyeSgnI3NtX2NvbnRyb2xsZXIgYnV0dG9uJykucmVtb3ZlQ2xhc3MoXCJhY3RpdmUgYnRuLXNlY29uZGFyeSB0ZXh0LXdoaXRlIGJnLXNlY29uZGFyeVwiKTtcbiAgICAgICAgLy8gICAgIGpRdWVyeSh0aGlzKS5hZGRDbGFzcygnYWN0aXZlIGJ0bi1zZWNvbmRhcnkgdGV4dC13aGl0ZSBiZy1zZWNvbmRhcnknKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcjc21fY29udHJvbGxlciBidXR0b24nLCgoZSk9PntcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnI3NtX2NvbnRyb2xsZXIgYnV0dG9uJywncmVtb3ZlQ2xhc3MnLFsnYWN0aXZlLGJ0bi1zZWNvbmRhcnksdGV4dC13aGl0ZSxiZy1zZWNvbmRhcnknXSk7XG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoZSwnYWRkQ2xhc3MnLFsnYWN0aXZlLGJ0bi1zZWNvbmRhcnksdGV4dC13aGl0ZSxiZy1zZWNvbmRhcnknXSk7XG4gICAgICAgIH0pKVxuXG4gICAgICAgIFxuXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcjc2V0LXJldmlldycsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNldFJldmlldygpO1xuICAgICAgICB9KVxuXG4gICAgICAgIFxuXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcjdW5zZXQtcmV2aWV3JyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgdW5zZXRSZXZpZXcoKTtcbiAgICAgICAgfSlcbiAgICB9KVxuXG4gICAgXG4gICAgZnVuY3Rpb24gbG9hZE1vZHVsZShsb2FkWG1sKSB7XG4gICAgICAgIGxvYWRYbWwgPSBYTUxUb0pTT04obG9hZFhtbCk7XG4gICAgICAgIHBhcnNlWE1MUHJldmlldyhsb2FkWG1sKTsgXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VYTUxQcmV2aWV3KE1ZWE1MKSB7XG5cdCAgICB0cnkge1xuXHRcdFx0XG5cdFx0XHRzdGF0ZS5yb3dOdW0gPSBNWVhNTC5zbXhtbC5fcm93O1xuICAgICAgICAgICAgc3RhdGUuY29sTnVtID0gTVlYTUwuc214bWwuX2NvbDsgIFxuICAgICAgICAgICAgc3RhdGUuc2xhc2hfdmFsID0gTVlYTUwuc214bWwuX3NsYXNoO1xuICAgICAgICAgICAgc3RhdGUucGx1c19taW51cyA9IE1ZWE1MLnNteG1sLl9wbHVzbWludXM7XG4gICAgICAgICAgICBzdGF0ZS5kZWNpbWFsX3ZhbCA9ICBNWVhNTC5zbXhtbC5fZGVjaW1hbDtcbiAgICAgICAgICAgIHN0YXRlLnRleHRTaXplUCA9IE1ZWE1MLnNteG1sLl9mb250O1xuICAgICAgICAgICAgc3RhdGUuY29ycmVjdEFucyA9IE1ZWE1MLnNteG1sLl9jb3JyZWN0QW5zLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBzdGF0ZS5kZWNpbWFsX3BvaW50ID0gTVlYTUwuc214bWwuX2ZpeGVkX3BvaW50O1xuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh3aW5kb3cudWFYTUwpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVVzZXJBbnMod2luZG93LnVhWE1MKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9LDUwKTtcbiAgICAgICAgICAgIH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh7J2Vycm9yJzplcnJvci5tZXNzYWdlLCdmdW5jdGlvbiBuYW1lJzoncGFyc2VYTUxQcmV2aWV3JywnRmlsZSBuYW1lJzonR3JpZGRlZFByZXZpZXcuanMnfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVVzZXJBbnModWFucykge1xuICAgICAgICAgICAgbGV0IHVzZXJBbnN3ZXIgPSBYTUxUb0pTT04odWFucyk7XG4gICAgICAgICAgICBpZiAodXNlckFuc3dlci5zbWFucyAmJiB1c2VyQW5zd2VyLnNtYW5zLmRpdiAmJiB1c2VyQW5zd2VyLnNtYW5zLmRpdi5fdXNlckFucykge1xuICAgICAgICAgICAgICAgIHVzZXJBbnMgPSB1c2VyQW5zd2VyLnNtYW5zLmRpdi5fdXNlckFucy5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgYm9vbCA9IHVzZXJBbnN3ZXIuc21hbnMuZGl2Ll9jb3JyZWN0O1xuICAgICAgICAgICAgICAgLy8gJChcIiNhbnN3ZXJcIikucHJvcChcImNoZWNrZWRcIiwgYm9vbClcbiAgICAgICAgICAgICAgICBhbnMgPSB1c2VyQW5zO1xuICAgICAgICAgICAgICAgIC8vZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVVcGRhdGUoKCk9PntcbiAgICAgICAgaWYgKHhtbCAhPSBzdGF0ZS54bWwpIHtcbiAgICAgICAgICAgIHN0YXRlLnhtbCA9IHhtbDtcbiAgICAgICAgICAgIGxvYWRNb2R1bGUoeG1sKTtcbiAgICAgICAgfSAgXG4gICAgICAgIC8vaWYgKHRoaXMucHJvcHMucmVtZWRTdGF0dXMgIT0gbmV4dFByb3BzLnJlbWVkU3RhdHVzKSB7XG4gICAgICAgICAgIFxuICAgICAgICAvL30gXG4gICAgICAgIGlmICh3aW5kb3cuUVhNTCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3F4bWwnKTtcbiAgICAgICAgfVxuICAgICAgICBmaXJzdFJvd0l0ZW1QcmUoKTtcbiAgICAgICAgZGVjaW1hbEZsb2F0aW5nUHJlKCk7XG4gICAgICAgIHNsYXNoRnVuY1ByZSgpO1xuICAgICAgICBwbHVzTWludXNTaWduUHJlKCk7XG4gICAgICAgIGNyZWF0ZWRTaGVldFJvd1ByZSgpO1xuICAgICAgICBcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vY2hhbmdpbmcgY29sb3IgYWNjb3JkaW5nIHRvIHVzZXIvLy8vLy8vLy9cbiAgICAgICAgbGV0IGNlbGxfY2xhc3MgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICBsZXQgY29sdW1uX2luZGV4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoY2VsbF9jbGFzcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuXG4gICAgICAgICAgLy8vLy8vLy9UaHJvdyB0aGUgc2VsZWN0IGRhdGEgaW4gdG9wIHJvdy8vLy8vLy9cbiAgICAgICAgICAgIGxldCB0YXJnZXRfaWQgPSBldmVudC50YXJnZXQuaWQ7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0X3RvX2Rpc3BsYXkgPSB0YXJnZXRfaWQuc3BsaXQoXCItXCIpOyBcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldF90b19kaXNwbGF5WzBdKS52YWx1ZSA9IGV2ZW50LnRhcmdldC5pbm5lckhUTUw7XG4gICAgICAgICAgICBzZXRVc2VyQW5zKGV2ZW50KTsgLy8vLy8vLy8gQ2FsbCBmdW5jdGlvbiBmb3IgYW5zd2VyIGNoZWNraW5nXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VXNlckFucyAoZXZlbnQpICB7XG4gICAgICAgIGxldCBjb3VudFJlcztcblxuICAgICAgIC8vLy8vLy8vIFRoaXMgY29kZSBzZXQgdGhlIGFuc3dlci8vLy8vLy8vLy8vXG4gICAgICAgIGxldCBhdHRyID0gZXZlbnQudGFyZ2V0LmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLXRhZycpLnZhbHVlO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICAgICAgICAgIHVzZXJBbnNbYXR0cl0gPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIHVzZXJBbnNbYXR0cl0gPSBldmVudC50YXJnZXQuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPHVzZXJBbnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHVzZXJBbnNbaV0pID09ICd1bmRlZmluZWQnIHx8IHVzZXJBbnNbaV0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHVzZXJBbnNbaV0gPSBcIiVibGFuayVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VyQW5zWyh1c2VyQW5zLmxlbmd0aCktMV0gPT0gXCIlYmxhbmslXCIpIHtcbiAgICAgICAgICAgIHVzZXJBbnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgICAgc3RhdGUudXNlckxpc3QgPSB1c2VyQW5zO1xuICAgICAgICBcbiAgICAgICAgICAgIGF1dGhBbnNTcGxpdCA9IHN0YXRlLmNvcnJlY3RBbnM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB1c2VyID0gc3RhdGUudXNlckxpc3Q7XG4gICAgICAgICAgICBpZiAodXNlci5sZW5ndGggPT0gYXV0aEFuc1NwbGl0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXV0aEFuc1NwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyW2ldID09IGF1dGhBbnNTcGxpdFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYysrOyAgXG5cbiAgICAgICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSB1c2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb3VudFJlcyA9IGwuY29ycmVjdFxuICAgICAgICAgICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgICAgICAvL3JldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5pbmNvcnJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIGlzQW5zd2VyQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRSZXMgPSBsLmluY29ycmVjdDtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5RWE1MKSB7XG4gICAgICAgICAgICAgICAgc2hvd0Fucyhjb3VudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQUguc2VsZWN0KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIpLnZhbHVlID0gXCI8c21hbnM+PGRpdiB0eXBlPSc1NicgY29ycmVjdD0nXCIraXNBbnN3ZXJDb3JyZWN0K1wiJyB1c2VyQW5zPSdcIitzdGF0ZS51c2VyTGlzdCtcIic+PC9kaXY+PC9zbWFucz5cIlxuICAgICAgICAgICAgaWYgKGJvb2wgIT0gJyAnICYmIGMgPT0gdXNlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL2pRVWVyeShcIiNhbnN3ZXJcIikucHJvcChcImNoZWNrZWRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KFwiI2Fuc3dlclwiLCdhdHRyJyx7XCJjaGVja2VkXCI6Ym9vbH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2pRdWVyeShcIiNhbnN3ZXJcIikucHJvcChcImNoZWNrZWRcIiwgaXNBbnN3ZXJDb3JyZWN0KTtcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoXCIjYW5zd2VyXCIsJ2F0dHInLHtcImNoZWNrZWRcIjppc0Fuc3dlckNvcnJlY3R9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tDb21ibyhldmVudCkge1xuICAgICAgICBcbiAgICAgICAgLy8vLy8vLy8vLy8vLy9jaGFuZ2luZyBjb2xvciBhY2NvcmRpbmcgdG8gdXNlci8vLy8vLy8vL1xuICAgICAgICBsZXQgY2VsbF9jbGFzcyA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgIGxldCBjb2x1bW5faW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShjZWxsX2NsYXNzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uX2luZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKGV2ZW50LmRldGFpbC50YXJnZXQpLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG5cbiAgICAgICAgICAvLy8vLy8vL1Rocm93IHRoZSBzZWxlY3QgZGF0YSBpbiB0b3Agcm93Ly8vLy8vL1xuICAgICAgICAgICAgbGV0IHRhcmdldF9pZCA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pZDtcbiAgICAgICAgICAgIGxldCB0YXJnZXRfdG9fZGlzcGxheSA9IHRhcmdldF9pZC5zcGxpdChcIi1cIik7IFxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0X3RvX2Rpc3BsYXlbMF0pLnZhbHVlID0gKGV2ZW50LmRldGFpbC50YXJnZXQpLmlubmVySFRNTDtcbiAgICAgICAgICAgIHNldFVzZXJBbnNDb21ibyhldmVudCk7IC8vLy8vLy8vIENhbGwgZnVuY3Rpb24gZm9yIGFuc3dlciBjaGVja2luZ1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFVzZXJBbnNDb21ibyAoZXZlbnQpICB7XG4gICAgICAgIGxldCBjb3VudFJlcztcblxuICAgICAgIC8vLy8vLy8vIFRoaXMgY29kZSBzZXQgdGhlIGFuc3dlci8vLy8vLy8vLy8vXG4gICAgICAgIGxldCBhdHRyID0gKGV2ZW50LmRldGFpbC50YXJnZXQpLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLXRhZycpLnZhbHVlO1xuICAgICAgICBpZiAoKGV2ZW50LmRldGFpbC50YXJnZXQpLmlubmVySFRNTCA9PT0gJycpIHtcbiAgICAgICAgICAgIHVzZXJBbnNbYXR0cl0gPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkudmFsdWU7XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIHVzZXJBbnNbYXR0cl0gPSAoZXZlbnQuZGV0YWlsLnRhcmdldCkuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPHVzZXJBbnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHVzZXJBbnNbaV0pID09ICd1bmRlZmluZWQnIHx8IHVzZXJBbnNbaV0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHVzZXJBbnNbaV0gPSBcIiVibGFuayVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VyQW5zWyh1c2VyQW5zLmxlbmd0aCktMV0gPT0gXCIlYmxhbmslXCIpIHtcbiAgICAgICAgICAgIHVzZXJBbnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgICAgc3RhdGUudXNlckxpc3QgPSB1c2VyQW5zO1xuICAgICAgICBcbiAgICAgICAgICAgIGF1dGhBbnNTcGxpdCA9IHN0YXRlLmNvcnJlY3RBbnM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB1c2VyID0gc3RhdGUudXNlckxpc3Q7XG4gICAgICAgICAgICBpZiAodXNlci5sZW5ndGggPT0gYXV0aEFuc1NwbGl0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXV0aEFuc1NwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyW2ldID09IGF1dGhBbnNTcGxpdFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYysrOyAgXG5cbiAgICAgICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSB1c2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb3VudFJlcyA9IGwuY29ycmVjdFxuICAgICAgICAgICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgICAgICAvL3JldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5pbmNvcnJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIGlzQW5zd2VyQ29ycmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvdW50UmVzID0gbC5pbmNvcnJlY3Q7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuUVhNTCkge1xuICAgICAgICAgICAgICAgIHNob3dBbnMoY291bnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8valF1ZXJ5KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIpLnZhbChcIjxzbWFucz48ZGl2IHR5cGU9JzU2JyBjb3JyZWN0PSdcIitpc0Fuc3dlckNvcnJlY3QrXCInIHVzZXJBbnM9J1wiK3N0YXRlLnVzZXJMaXN0K1wiJz48L2Rpdj48L3NtYW5zPlwiKTtcbiAgICAgICAgICAgIEFILnNlbGVjdChcIiNzcGVjaWFsX21vZHVsZV91c2VyX3htbFwiKS52YWx1ZSA9IFwiPHNtYW5zPjxkaXYgdHlwZT0nNTYnIGNvcnJlY3Q9J1wiK2lzQW5zd2VyQ29ycmVjdCtcIicgdXNlckFucz0nXCIrc3RhdGUudXNlckxpc3QrXCInPjwvZGl2Pjwvc21hbnM+XCJcbiAgICAgICAgICAgIGlmIChib29sICE9ICcgJyAmJiBjID09IHVzZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9qUVVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIEFILnNlbGVjdChcIiNhbnN3ZXJcIiwnYXR0cicse1wiY2hlY2tlZFwiOmJvb2x9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9qUXVlcnkoXCIjYW5zd2VyXCIpLnByb3AoXCJjaGVja2VkXCIsIGlzQW5zd2VyQ29ycmVjdCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KFwiI2Fuc3dlclwiLCdhdHRyJyx7XCJjaGVja2VkXCI6aXNBbnN3ZXJDb3JyZWN0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3dWYWxpZGF0aW9uKGV2ZW50KSB7ICBcbiAgICAgICAgbGV0IGEgPSBzdGF0ZS5yb3dOdW0gLSAxO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIEFILmFsZXJ0KCdEb3VibGUgZGlnaXQgbm90IGFjY2VwdGVkJyk7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfWVsc2UgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIEFILmFsZXJ0KFwiTGVzcyB0aGVuIDEgbm90IGFjY2VwdGVkXCIpO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfWVsc2UgaWYgKCBhIDwgZXZlbnQudGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICBBSC5hbGVydCgnTnVtYmVyIGluc2VydCBvbmx5IDAgdG8gJytzdGF0ZS5yb3dOdW0pO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VXNlckFucyhldmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlnaExpZ2h0KGV2ZW50KSB7ICAgIFxuICAgICAgICBsZXQgY2VsbF9jbGFzcyA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgbGV0IGNvbHVtbl9pbmRleCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGNlbGxfY2xhc3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICBpZiAoY29sdW1uX2luZGV4W2ldLmlubmVySFRNTCA9PSBldmVudC50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH1cblxuXG4gICAgIC8vLy8vLy8vLy8vLy8vLy8vLyBDcmVhdGUgdmVyeSBmaXJzdCByb3cgYW5kIHN0b3JlIGRhdGEgYWNjb3JkaW5nIHRvIGNsaWNrLy8vLy8vLy8vL1xuXG4gICAgbGV0IENvbHNQcmUgPSBbXTtcbiAgICBmdW5jdGlvbiBmaXJzdFJvd0l0ZW1QcmUoKSB7XG4gICAgICAgICAgICBsZXQgUm93cyA9IFtdO1xuICAgICAgICAgICAgQ29sc1ByZSA9IFtdO1xuICAgICAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLmNvbE51bTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuc1tqXSA9PT0gXCIlYmxhbmslXCIpe1xuICAgICAgICAgICAgICAgICAgICBteUFuc1tqXSA9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG15QW5zW2pdID0gYW5zW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHNQcmUgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzUHJlLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb2xzUHJlLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29sc1ByZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzUHJlLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd0JytqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncCcraixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG15QW5zW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuaWQ6IFwidF9cIitqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgfVxuXG5cblxuICAgIGxldCB0b3RhbFJvd3MgPSBbXTtcbiAgICBsZXQgdG90YWxDb2xzID0gW107XG4gICAgZnVuY3Rpb24gY3JlYXRlZFNoZWV0Um93UHJlKCkge1xuICAgICAgICB0b3RhbFJvd3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5yb3dOdW07IGkrKykge1xuICAgICAgICAgICAgICAgIHRvdGFsQ29scyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxDb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjb2xcIitpK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsQ29scy5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbENvbHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjb2xcIitpK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncCcraixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqICsgXCItXCIgKyBpICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL3RvdGFsUm93cy5wdXNoKDx0ciBrZXk9e1wicm93XCIraX0+e3RvdGFsQ29sc308L3RyPik7XG4gICAgICAgICAgICAgICAgdG90YWxSb3dzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi50b3RhbFJvd3Mse1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInJvd1wiK2lcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgQ29sc19zbGFzaCA9IFtdO1xuICAgIGZ1bmN0aW9uIHNsYXNoRnVuY1ByZShldmVudCkge1xuICAgICAgICAgICAgbGV0IFJvd3Nfc2xhc2ggPSBbXTtcbiAgICAgICAgICAgIENvbHNfc2xhc2ggPSBbXTtcbiAgICAgICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb2xzX3NsYXNoID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLkNvbHNfc2xhc2gse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiY29sXCIraixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENvbHNfc2xhc2gubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29sc19zbGFzaCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19zbGFzaCx7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3AnK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IENvbHNfZGVjaW1hbCA9IFtdO1xuICAgIGZ1bmN0aW9uIGRlY2ltYWxGbG9hdGluZ1ByZShldmVudCkge1xuICAgICAgICBsZXQgUm93c19kZWNpbWFsID0gW107XG4gICAgICAgIENvbHNfZGVjaW1hbCA9IFtdO1xuICAgICAgICBsZXQgZGVjX3BvaW50ID0gc3RhdGUuZGVjaW1hbF9wb2ludDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xuICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50LTEgJiYgZGVjX3BvaW50ICE9IDApIHsgXG4gICAgICAgICAgICAgICAgQ29sc19kZWNpbWFsID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX2RlY2ltYWwse1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImNvbFwiK2osXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoQ29sc19kZWNpbWFsLmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xuICAgICAgICAgICAgICAgICAgICBDb2xzX2RlY2ltYWwgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX2RlY2ltYWwse1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRcIiArIGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3AnK2osXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vIFNldCByZXZpZXcgYW5kIHVuc2V0IHJldmlldyBmdW5jdGlvbi8vLy8vLy8vLy8vLy8vXG5cbiAgICBmdW5jdGlvbiBzZXRSZXZpZXcoKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgc3RhdGUuc21Db250cm9sbGVyID0gXCJcIixcbiAgICAgICAgc3RhdGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiXG4gICAgICAgIGlzUmV2aWV3ID0gdHJ1ZTtcbiAgICAgICAgc2hvd0Fuc3dlcihcInlhbnNcIiwgXCJzaG93SWNvblwiKTtcbiAgICAgICAgLy9qUXVlcnkoJyNzbV9jb250cm9sbGVyIC55b3VyLWFucycpLmFkZENsYXNzKFwiYnRuLWxpZ2h0IGFjdGl2ZVwiKTtcblxuICAgICAgICBBSC5zZWxlY3RBbGwoJyNzbV9jb250cm9sbGVyIC55b3VyLWFucycsJ2FkZENsYXNzJyxbJ2J0bi1saWdodCcsJ2FjdGl2ZSddKTtcblxuXG4gICAgICAgIC8valF1ZXJ5KFwiLnRva2VuSGVhZGVyXCIpLmF0dHIoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgICAgIEFILnNlbGVjdEFsbChcIi50b2tlbkhlYWRlclwiLFwiYXR0clwiLHtcInRhYmluZGV4XCI6MH0pXG5cbiAgICAgICAgLy9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRva2VuSGVhZGVyXCIpLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCIwXCIpO1xuICAgICAgICBzZXRUaW1lb3V0KGdldENvcnJlY3QoKSwyMDApOyBcbiAgICAgICAgaWYgKCF3aW5kb3cuUVhNTCkge1xuICAgICAgICAgICAgc2hvd0FucygoaXNBbnN3ZXJDb3JyZWN0KT8obC5jb3JyZWN0KToobC5pbmNvcnJlY3QpKTtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb3JyZWN0KCkge1xuXHQgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5jb3JyZWN0QW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuY29ycmVjdEFuc1tpXSA9PSBzdGF0ZS51c2VyTGlzdFtpXSkge1xuICAgICAgICAgICAgICAgIC8valF1ZXJ5KCcjdF8nK2kpLnJlbW92ZUNsYXNzKFwiaWNvbW9vbi1uZXctMjRweC1jYW5jZWwtY2lyY2xlLTFcIikuYWRkQ2xhc3MoXCJpY29tb29uLW5ldy0yNHB4LWNoZWNrbWFyay1jaXJjbGUtMVwiKTtcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyN0XycraSwncmVtb3ZlQ2xhc3MnLCdpY29tb29uLW5ldy0yNHB4LWNhbmNlbC1jaXJjbGUtMScpO1xuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3RfJytpLCdhZGRDbGFzcycsJ2ljb21vb24tbmV3LTI0cHgtY2hlY2ttYXJrLWNpcmNsZS0xJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8valF1ZXJ5KCcjdF8nK2kpLnJlbW92ZUNsYXNzKFwiaWNvbW9vbi1uZXctMjRweC1jaGVja21hcmstY2lyY2xlLTFcIikuYWRkQ2xhc3MoXCJpY29tb29uLW5ldy0yNHB4LWNhbmNlbC1jaXJjbGUtMVwiKTtcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyN0XycraSwncmVtb3ZlQ2xhc3MnLCdpY29tb29uLW5ldy0yNHB4LWNoZWNrbWFyay1jaXJjbGUtMScpO1xuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3RfJytpLCdhZGRDbGFzcycsJ2ljb21vb24tbmV3LTI0cHgtY2FuY2VsLWNpcmNsZS0xJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcblx0fVxuIFxuICAgIGZ1bmN0aW9uIHVuc2V0UmV2aWV3KCkgeyAgXG4gICAgICAgIHN0YXRlLnNtQ29udHJvbGxlciA9IFwiaFwiLFxuICAgICAgICBzdGF0ZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCJcbiAgICAgICAgaXNSZXZpZXcgPSBmYWxzZTtcbiAgICAgICAgc2hvd0Fuc3dlcihcInlhbnNcIiwgXCJoaWRlSWNvblwiKTtcbiAgICAgICAgLy9qUXVlcnkoXCIudG9rZW5IZWFkZXJcIikucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpO1xuICAgICAgICBBSC5zZWxlY3RBbGwoXCIudG9rZW5IZWFkZXJcIiwgJ3JlbW92ZUF0dHInLCAndGFiaW5kZXgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93QW5zd2VyKHZhbCxpY29uU3RhdGUpIHtcbiAgICAgICAgXG4gICAgICAvL3Nob3cgY29ycmVjdCBpbmNvcnJlY3QgaWNvbiB3aXRoIHJlc3BlY3QgdG8gaWNvblN0YXRlXG4gICAgICAgIGlmIChpY29uU3RhdGUgPT0gXCJzaG93SWNvblwiKSB7XG4gICAgICAgICAgICBzdGF0ZS5pY29uVmlzaWJsZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5pY29uVmlzaWJsZSA9IFwiaFwiO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodmFsID09IFwiY2Fuc1wiKSB7XG4gICAgICAgICAgICBsZXQgZWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZ3JpZGRlZF90YWInKTtcbiAgICAgICAgICAgIGVsZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBhbnMgPSBzdGF0ZS5jb3JyZWN0QW5zO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PSBcInlhbnNcIikge1xuICAgICAgICAgICAgYW5zID0gdXNlckFucztcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBjcmVhdGUgcGx1cyBhbmQgbWludXMgcm93Ly8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IENvbHMgPSBbXTtcbiAgICBsZXQgQ29sc19NaW51cyA9IFtdO1xuICAgIGZ1bmN0aW9uIHBsdXNNaW51c1NpZ25QcmUoZXZlbnQpICB7XG4gICAgICAgIENvbHMgPSBbXTtcbiAgICAgICAgQ29sc19NaW51cyA9IFtdO1xuICAgICAgICBsZXQgZGVjX3BvaW50ID0gc3RhdGUuZGVjaW1hbF9wb2ludDtcbiAgICAgICAgLy9sZXQgYXJyID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqID09IGRlY19wb2ludCAtIDEgJiYgZGVjX3BvaW50ICE9IDApIHtcbiAgICAgICAgICAgICAgICBDb2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkOiBcInRkXCIgKyBqICsgJy0nICsgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbHMubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwJytqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHNfTWludXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX01pbnVzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZDogXCJ0ZFwiICsgaiArICctJyArIGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbHNfTWludXMubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbHNfTWludXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX01pbnVzLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJ0XCIgKyBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwJytqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmV2aWV3KG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT0gJ2MnKSB7XG5cdFx0XHRzaG93QW5zd2VyKFwiY2Fuc1wiLCBcImhpZGVJY29uXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaG93QW5zd2VyKFwieWFuc1wiLCBcInNob3dJY29uXCIpO1xuXHRcdH1cbiAgICB9XG4gICAgLy9sZXQgZGlzcGxheUNsYXNzID0gKChzdGF0ZS5pY29uVmlzaWJsZSA9PSBcIlwiICYmIChzdGF0ZS51c2VyQW5zKS5pbmNsdWRlcyh2YWwuaWQpKSk7XG5cbjwvc2NyaXB0PlxuXG48bWFpbj5cbiAgICA8ZGl2IGNsYXNzPVwiZ3JpZGRlZE1vZHVsZVwiPlxuICAgICAgICA8Y2VudGVyPiBcbiAgICAgICAgICAgIDxJdGVtSGVscGVyIFxuICAgICAgICAgICAgICAgIGhhbmRsZVJldmlld0NsaWNrPXtoYW5kbGVSZXZpZXd9XG4gICAgICAgICAgICAgICAgcmV2aWV3TW9kZT17aXNSZXZpZXd9XG5cdCAgICAgICAgLz5cbiAgICAgICAgPC9jZW50ZXI+XG4gICAgICAgIDx0YWJsZSBib3JkZXI9XCIxXCIgaWQ9XCJ0YWIyXCIgc3R5bGU9eydib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7dGV4dC1hbGlnbjpjZW50ZXInfSA+XG4gICAgICAgICAgICA8dHIgc3R5bGU9XCJkaXNwbGF5OmZsZXg7XCI+XG4gICAgICAgICAgICAgICAgeyNlYWNoIENvbHNQcmUgYXMgdmFsLGl9XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgdmFsLmRlY3BvaW50ID09IHRydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT17J3dpZHRoOjUwcHg7dGV4dC1hbGlnbjpjZW50ZXI7J30gIHZhbHVlPVwiLlwiIGRpc2FibGVkPVwidHJ1ZVwiIGNsYXNzPVwidGRGb250XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9e3ZhbC5pZH0gZGF0YS10YWc9e3ZhbC5kYXRhVGFnfSBuYW1lPXt2YWwubmFtZX0gc3R5bGU9eyd3aWR0aDo1MHB4O3RleHQtYWxpZ246Y2VudGVyOyd9IG9uOmNoYW5nZT17cm93VmFsaWRhdGlvbn0gb246aW5wdXQ9e2hpZ2hMaWdodH0gdmFsdWU9eyhteUFuc1tpXSA9PT0gdW5kZWZpbmVkKT9cIiBcIjpteUFuc1tpXX0gY2xhc3M9XCJ0ZEZvbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICBjbGFzcz17c3RhdGUuaWNvblZpc2libGUrJyByZWxhdGl2ZSd9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD17dmFsLnNwYW5pZH0gY2xhc3M9XCJhbnN3ZXJfaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgPC90YWJsZT5cblxuICAgICAgICAgICAgeyNpZiBzdGF0ZS5wbHVzX21pbnVzID09IDF9XG4gICAgICAgICAgICAgICAgPEdyaWRkZWRIZWxwZXIgXG4gICAgICAgICAgICAgICAgICAgIG9uOmhhbmRsZUNsaWNrQ29tYm8gPSB7aGFuZGxlQ2xpY2tDb21ib31cbiAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzczEgPSBcInRkRm9udCBwbHVzX3RhYlwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRkRm9udFAgcGx1c190YWIgaXRlbXNfZWxlbWVudFwiXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwicGx1c19taW51c190YWJcIlxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzID1cInBsdXNfbWludXNfdGFiIGdyaWRkZWRfdGFiIG10LTAgbXlQXCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIitcIlxuICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XG4gICAgICAgICAgICAgICAgPEdyaWRkZWRIZWxwZXIgXG4gICAgICAgICAgICAgICAgICAgIG9uOmhhbmRsZUNsaWNrQ29tYm8gPSB7aGFuZGxlQ2xpY2tDb21ib31cbiAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX01pbnVzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzczEgPSBcInRkRm9udCBwbHVzX3RhYlwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRkRm9udFAgcGx1c190YWIgaXRlbXNfZWxlbWVudCBtaW51c19wb2ludFwiXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSWQgPVwicGx1c19taW51c190YWJcIlxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzID1cInBsdXNfbWludXNfdGFiIGdyaWRkZWRfdGFiIG10LTAgbXlQXCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIi1cIlxuICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XG4gICAgICAgICAgICB7L2lmfVxuXG4gICAgICAgIHsjaWYgc3RhdGUuZGVjaW1hbF92YWwgPT0gMX1cbiAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxuICAgICAgICAgICAgICAgIG9uOmhhbmRsZUNsaWNrQ29tYm8gPSB7aGFuZGxlQ2xpY2tDb21ib31cbiAgICAgICAgICAgICAgICBsb29wID0ge0NvbHNfZGVjaW1hbH1cbiAgICAgICAgICAgICAgICBjbGFzczEgPSBcInRkRm9udCBwb2ludHNcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRkRm9udFAgdGV4dC1jZW50ZXIgaXRlbXNfZWxlbWVudCBkZWNsX3BvaW50XCJcbiAgICAgICAgICAgICAgICB0YWJsZUlkID1cInNsYXNoX3RhYlwiXG4gICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJzbGFzaF90YWIgZ3JpZGRlZF90YWIgbXQtMCBtYi0wIG15UFwiXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIi5cIlxuICAgICAgICAgICAgPjwvR3JpZGRlZEhlbHBlcj5cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiBzdGF0ZS5zbGFzaF92YWwgPT0gMX1cbiAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyICBcbiAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvID0ge2hhbmRsZUNsaWNrQ29tYm99XG4gICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX3NsYXNofVxuICAgICAgICAgICAgICAgIGNsYXNzMSA9IFwidGRGb250IHBvaW50c1wiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250UCB0ZXh0LWNlbnRlciBpdGVtc19lbGVtZW50IHNsYV9wb2ludFwiXG4gICAgICAgICAgICAgICAgdGFibGVJZCA9XCJ0ZEZvbnRQIHNsYXNoX3RhYlwiXG4gICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJzbGFzaF90YWIgZ3JpZGRlZF90YWIgbXQtMFwiXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIi9cIlxuICAgICAgICAgICAgPjwvR3JpZGRlZEhlbHBlcj5cbiAgICAgICAgey9pZn1cbiAgICAgICBcbiAgICAgICAgPHRhYmxlIGlkPVwiZ3JpZGRlZF9zaGVldFwiIGNsYXNzPVwiZ3JpZGRlZF90YWIgbXQtMCBsYXN0R3JpZCBjcmVhdGVfdGFiIG15UFwiPlxuICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgIHsjZWFjaCB0b3RhbFJvd3MgYXMgZGF0YSxub31cbiAgICAgICAgICAgICAgICAgICAgPHRyIGtleT17ZGF0YS5rZXl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHRvdGFsQ29scyBhcyB2YWwsaX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHZhbC5kZWNwb2ludH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGtleT17dmFsLmtleX0gY2xhc3MgPSd0ZEZvbnQgdGV4dC1jZW50ZXInIHdpZHRoPVwiNTBcIiBkaXNhYmxlZD1cInRydWVcIj4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgd2lkdGg9XCI1MFwiIGNsYXNzPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHRhYmluZGV4PXt2YWwudGFiSW5kZXh9IGtleT17dmFsLmtleX0gbmFtZT17dmFsLm5hbWV9IGRhdGEtdGFnPXt2YWwuZGF0YVRhZ30gY2xhc3M9XCJ0ZEZvbnRQIHRleHQtY2VudGVyIHRkX2RhdGEgYWxnbiBpdGVtc19lbGVtZW50XCIgaWQ9e3ZhbC5pZH0gb246Y2xpY2s9e2hhbmRsZUNsaWNrfT57K25vfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgIDwvdGFibGU+XG5cbiAgICA8L2Rpdj5cbjwvbWFpbj5cblxuPHN0eWxlPlxuICAgIFxuICAgIC5sYXlvdXRIZWFkaW5nIHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgY29sb3I6ICMxODc3YjE7XG4gICAgfVxuXG4gICAgLml0ZW1zX2VsZW1lbnQ6aG92ZXIge1xuICAgICAgICBib3JkZXI6IDEuMnB4IHNvbGlkICM3Nzc7XG4gICAgfVxuXG4gICAgLm1vcmVPcHRpb25zIHtcbiAgICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiAzcHggNHB4IDZweCAjYzRjNWM1O1xuICAgICAgICAtbW96LWJveC1zaGFkb3c6IDNweCA0cHggNnB4ICNjNGM1YzU7XG4gICAgICAgIGJveC1zaGFkb3c6IDNweCA0cHggNnB4ICNjNGM1YzU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjMTg3N2IxO1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzE4NzdiMTtcbiAgICB9XG5cbiAgICAubW9yZU9wdGlvbkRldGFpbHMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmN2Y3O1xuICAgIH1cblxuICAgIC5pbnB1dF9jb2wge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxlZnQ6IDVweDtcbiAgICB9XG5cbiAgICAubGF5b3V0aGVhZGluZyB7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cblxuICAgIC5udW1icl9yYW5nZSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogMTMwcHg7XG4gICAgfVxuXG4gICAgLm51bWJyX3JhbmdlX3R4dCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogMjAwcHg7XG4gICAgfVxuXG4gICAgLnBsdXNfbWludXNfZnJhY3Rpb24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHRvcDogMjBweDtcbiAgICB9XG5cbiAgICAuZmxvYXRpbmdfZnJhY3Rpb24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHRvcDogMjdweDtcbiAgICB9XG5cbiAgICAucGx1c19taW51c19zcGFuIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiA1cHg7XG4gICAgfVxuXG4gICAgLmZsb2F0aW5nX2RlY2ltYWwge1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIG1hcmdpbi1yaWdodDogNDVweDtcbiAgICB9XG5cbiAgICAuZm9udFN0eWxlIHtcbiAgICAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIG1hcmdpbi1yaWdodDogNjBweDtcbiAgICB9XG5cbiAgICAuZnJhY3Rpb25fc2xhc2gge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxlZnQ6IDE3N3B4O1xuICAgIH1cblxuICAgIC5taW51c190YWIsXG4gICAgLnBsdXNfdGFiLFxuICAgIC5zbGFzaF90YWIge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgLmdyaWRkZWRfdGFiIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9XG5cbiAgICAuZm9udF9zaXplX2xhYmVsIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiAxOThweDtcbiAgICB9XG5cbiAgICAuZm9udF9zaXplIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiAyMjVweDtcbiAgICB9XG5cblxuICAgIC5kZWNpbWFsX2NvbCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogMjA4cHg7XG4gICAgICAgIHdpZHRoOiA5MHB4O1xuICAgIH1cblxuICAgIC5jb3JyZWN0X2NvbG9yIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0U5RkZFOTtcbiAgICB9XG5cbiAgICAuZml4ZWRfZGVjaW1hbF9jaGVjayB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgdG9wOiAyNnB4O1xuICAgICAgICBsZWZ0OiAxM3B4O1xuICAgIH1cblxuICAgIC5jb3JyZWN0X2luY29ycmVjdF9pY29uX2ZpbGwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxOXB4O1xuICAgICAgICBoZWlnaHQ6IDE5cHg7XG4gICAgICAgIHJpZ2h0OiAxMjFweDtcbiAgICAgICAgdG9wOiAtNTVweDtcbiAgICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICB9XG5cbiAgICAucm93X2NvbHVtbl9kZWNpbWFsIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB0b3A6IDMwcHg7XG4gICAgICAgIGxlZnQ6IDVweDtcblxuICAgIH1cblxuICAgIC5maXhlZF9wb2ludF9jbGFzcyB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbGVmdDogN3B4O1xuICAgIH1cblxuICAgIC5yb3dfY29sdW1uIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiA1cHg7XG4gICAgfVxuXG4gICAgLmFuc3dlcl9pY29uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDdweDtcbiAgICAgICAgcmlnaHQ6IDM0cHg7XG4gICAgfVxuXG4gICAgLm15UCB0Ym9keSB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5cbiAgICAuY29sX3JhbmdlIHtcbiAgICAgICAgd2lkdGg6IDIwNXB4O1xuICAgIH1cblxuICAgIC5wb3NTaXplIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsZWZ0OiA3cHg7XG4gICAgfVxuXG4gICAgLmZvbnRTbWFsbCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIC5mb250Tm9ybWFsIHtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgLmZvbnRMYXJnZSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIC5mb250RXh0cmFMYXJnZSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMjZweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cblxuICAgIC5ncmlkIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB0b3A6IDEwcHg7XG4gICAgICAgIGJveC1zaGFkb3c6IDEwcHggNXB4IDEwcHggIzAwMDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5pdGVtc19lbGVtZW50KSB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICM4MDgwODA3YTtcbiAgICAgICAgcGFkZGluZzogNnB4IDEwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguZ3JpZGRlZE1vZHVsZSAuYWN0aXZlKSB7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgdHJhbnNpdGlvbjogMXM7XG4gICAgICAgIGJhY2tncm91bmQ6ICM2OTY5Njk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XG4gICAgfVxuXG4gICAgLm1pbnVzX3BvaW50LFxuICAgIC5kZWNsX3BvaW50IHtcbiAgICAgICAgcGFkZGluZzogNnB4IDEycHg7XG4gICAgfVxuXG4gICAgLnNsYV9wb2ludCB7XG4gICAgICAgIHBhZGRpbmc6IDZweCAxMXB4O1xuICAgIH1cblxuICAgIC5ncmlkZGVkTW9kdWxlIHRhYmxlIHRyIHRkOmxhc3QtY2hpbGQge1xuICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjY2NjICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLmdyaWRkZWRNb2R1bGUgLmxhc3RHcmlkIHRyOmxhc3QtY2hpbGQgdGQge1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYyAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5ncmlkZGVkTW9kdWxlIHRkIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2YwZjBmMCAhaW1wb3J0YW50O1xuICAgICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNjY2MgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAudG9rZW46aG92ZXIge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjMDAwICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYmxhIC50b2tlbjpob3Zlcikge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZmZmICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLnRva2VuX3NlbGVjdGVkIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzY0YmI2MztcbiAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYmxhIC50b2tlbl9oaWdobGlnaHRfaGVhZGluZykge1xuICAgICAgICBjb2xvcjogIzAwMCAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5ncmlkZGVkTW9kdWxlIC5leHBhbmRJY29uIHtcbiAgICAgICAgZm9udC1zaXplOiAyN3B4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgY29sb3I6ICMxODc3YjE7XG4gICAgfVxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMHVCSSxjQUFjLDhCQUFDLENBQUMsQUFDWixXQUFXLENBQUUsSUFBSSxDQUNqQixTQUFTLENBQUUsSUFBSSxDQUNmLEtBQUssQ0FBRSxPQUFPLEFBQ2xCLENBQUMsQUFFRCw0Q0FBYyxNQUFNLEFBQUMsQ0FBQyxBQUNsQixNQUFNLENBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEFBQzVCLENBQUMsQUFFRCxZQUFZLDhCQUFDLENBQUMsQUFDVixrQkFBa0IsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQ3ZDLGVBQWUsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQ3BDLFVBQVUsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQy9CLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUM3QixhQUFhLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLEFBQ3BDLENBQUMsQUFFRCxrQkFBa0IsOEJBQUMsQ0FBQyxBQUNoQixnQkFBZ0IsQ0FBRSxPQUFPLEFBQzdCLENBQUMsQUFFRCxVQUFVLDhCQUFDLENBQUMsQUFDUixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxBQUNiLENBQUMsQUFFRCxjQUFjLDhCQUFDLENBQUMsQUFDWixPQUFPLENBQUUsR0FBRyxDQUNaLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLElBQUksQUFDckIsQ0FBQyxBQUdELFlBQVksOEJBQUMsQ0FBQyxBQUNWLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxLQUFLLEFBQ2YsQ0FBQyxBQUVELGdCQUFnQiw4QkFBQyxDQUFDLEFBQ2QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsSUFBSSxDQUFFLEtBQUssQUFDZixDQUFDLEFBRUQsb0JBQW9CLDhCQUFDLENBQUMsQUFDbEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLElBQUksQUFDYixDQUFDLEFBRUQsa0JBQWtCLDhCQUFDLENBQUMsQUFDaEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLElBQUksQUFDYixDQUFDLEFBRUQsZ0JBQWdCLDhCQUFDLENBQUMsQUFDZCxRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxBQUNiLENBQUMsQUFFRCxpQkFBaUIsOEJBQUMsQ0FBQyxBQUNmLEtBQUssQ0FBRSxLQUFLLENBQ1osWUFBWSxDQUFFLElBQUksQUFDdEIsQ0FBQyxBQUVELFVBQVUsOEJBQUMsQ0FBQyxBQUNSLEtBQUssQ0FBRSxLQUFLLENBQ1osS0FBSyxDQUFFLEtBQUssQ0FDWixZQUFZLENBQUUsSUFBSSxBQUN0QixDQUFDLEFBRUQsZUFBZSw4QkFBQyxDQUFDLEFBQ2IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsSUFBSSxDQUFFLEtBQUssQUFDZixDQUFDLEFBRUQsd0NBQVUsQ0FDVix1Q0FBUyxDQUNULFVBQVUsOEJBQUMsQ0FBQyxBQUNSLFVBQVUsQ0FBRSxNQUFNLEFBQ3RCLENBQUMsQUFFRCxZQUFZLDhCQUFDLENBQUMsQUFDVixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLG1CQUFtQixDQUFFLElBQUksQ0FDekIsZ0JBQWdCLENBQUUsSUFBSSxDQUN0QixlQUFlLENBQUUsSUFBSSxBQUN6QixDQUFDLEFBRUQsZ0JBQWdCLDhCQUFDLENBQUMsQUFDZCxRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsS0FBSyxBQUNmLENBQUMsQUFFRCxVQUFVLDhCQUFDLENBQUMsQUFDUixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsS0FBSyxBQUNmLENBQUMsQUFHRCxZQUFZLDhCQUFDLENBQUMsQUFDVixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsS0FBSyxDQUNYLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUVELGNBQWMsOEJBQUMsQ0FBQyxBQUNaLGdCQUFnQixDQUFFLE9BQU8sQUFDN0IsQ0FBQyxBQUVELG9CQUFvQiw4QkFBQyxDQUFDLEFBQ2xCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxJQUFJLENBQ1QsSUFBSSxDQUFFLElBQUksQUFDZCxDQUFDLEFBRUQsNEJBQTRCLDhCQUFDLENBQUMsQUFDMUIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxLQUFLLENBQ1osR0FBRyxDQUFFLEtBQUssQ0FDVixVQUFVLENBQUUsS0FBSyxDQUNqQixhQUFhLENBQUUsR0FBRyxBQUN0QixDQUFDLEFBRUQsbUJBQW1CLDhCQUFDLENBQUMsQUFDakIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLElBQUksQ0FDVCxJQUFJLENBQUUsR0FBRyxBQUViLENBQUMsQUFFRCxrQkFBa0IsOEJBQUMsQ0FBQyxBQUNoQixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxBQUNiLENBQUMsQUFFRCxXQUFXLDhCQUFDLENBQUMsQUFDVCxRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxBQUNiLENBQUMsQUFFRCxZQUFZLDhCQUFDLENBQUMsQUFDVixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsR0FBRyxDQUNSLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUVELG1CQUFJLENBQUMsS0FBSyxlQUFDLENBQUMsQUFDUixNQUFNLENBQUUsT0FBTyxBQUNuQixDQUFDLEFBRUQsVUFBVSw4QkFBQyxDQUFDLEFBQ1IsS0FBSyxDQUFFLEtBQUssQUFDaEIsQ0FBQyxBQUVELFFBQVEsOEJBQUMsQ0FBQyxBQUNOLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxHQUFHLEFBQ2IsQ0FBQyxBQUVELFVBQVUsOEJBQUMsQ0FBQyxBQUNSLFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyxBQUVELFdBQVcsOEJBQUMsQ0FBQyxBQUNULFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyxBQUVELFVBQVUsOEJBQUMsQ0FBQyxBQUNSLFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyxBQUVELGVBQWUsOEJBQUMsQ0FBQyxBQUNiLFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyxBQUVELEtBQUssOEJBQUMsQ0FBQyxBQUNILFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxJQUFJLENBQ1QsVUFBVSxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQUFDbEMsQ0FBQyxBQUVPLGNBQWMsQUFBRSxDQUFDLEFBQ3JCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FDM0IsT0FBTyxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQ2pCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLGdCQUFnQixDQUFFLEtBQUssQUFDM0IsQ0FBQyxBQUVPLHNCQUFzQixBQUFFLENBQUMsQUFDN0IsS0FBSyxDQUFFLEtBQUssQ0FDWixVQUFVLENBQUUsRUFBRSxDQUNkLFVBQVUsQ0FBRSxPQUFPLENBQ25CLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQUFDMUIsQ0FBQyxBQUVELDBDQUFZLENBQ1osV0FBVyw4QkFBQyxDQUFDLEFBQ1QsT0FBTyxDQUFFLEdBQUcsQ0FBQyxJQUFJLEFBQ3JCLENBQUMsQUFFRCxVQUFVLDhCQUFDLENBQUMsQUFDUixPQUFPLENBQUUsR0FBRyxDQUFDLElBQUksQUFDckIsQ0FBQyxBQUVELDZCQUFjLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxpQkFBRSxXQUFXLEFBQUMsQ0FBQyxBQUNuQyxZQUFZLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxBQUMzQyxDQUFDLEFBRUQsNkJBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRSxXQUFXLENBQUMsRUFBRSxlQUFDLENBQUMsQUFDdkMsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQUFDNUMsQ0FBQyxBQUVELDZCQUFjLENBQUMsRUFBRSxlQUFDLENBQUMsQUFDZixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUNwQyxXQUFXLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxBQUMxQyxDQUFDLEFBRUQsb0NBQU0sTUFBTSxBQUFDLENBQUMsQUFDVixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxBQUNyQyxDQUFDLEFBRU8saUJBQWlCLEFBQUUsQ0FBQyxBQUN4QixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxBQUNyQyxDQUFDLEFBRUQsZUFBZSw4QkFBQyxDQUFDLEFBQ2IsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFTyw2QkFBNkIsQUFBRSxDQUFDLEFBQ3BDLEtBQUssQ0FBRSxJQUFJLENBQUMsVUFBVSxBQUMxQixDQUFDLEFBRUQsNkJBQWMsQ0FBQyxXQUFXLGVBQUMsQ0FBQyxBQUN4QixTQUFTLENBQUUsSUFBSSxDQUNmLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLEtBQUssQ0FBRSxPQUFPLEFBQ2xCLENBQUMifQ== */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	child_ctx[46] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[43] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	child_ctx[46] = i;
	return child_ctx;
}

// (665:20) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_id_value;
	let input_data_tag_value;
	let input_name_value;
	let input_style_value;
	let input_value_value;
	let t0;
	let span1;
	let span0;
	let span0_id_value;
	let t1;
	let span1_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			span1 = element("span");
			span0 = element("span");
			t1 = space();
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = /*val*/ ctx[44].id);
			attr_dev(input, "data-tag", input_data_tag_value = /*val*/ ctx[44].dataTag);
			attr_dev(input, "name", input_name_value = /*val*/ ctx[44].name);
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");

			input.value = input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[46]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[46]];

			attr_dev(input, "class", "tdFont");
			add_location(input, file, 666, 28, 22126);
			attr_dev(span0, "id", span0_id_value = /*val*/ ctx[44].spanid);
			attr_dev(span0, "class", "answer_icon svelte-1ersj3w");
			add_location(span0, file, 669, 32, 22476);
			attr_dev(span1, "class", span1_class_value = "" + (null_to_empty(/*state*/ ctx[2].iconVisible + " relative") + " svelte-1ersj3w"));
			add_location(span1, file, 668, 28, 22398);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t1);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*rowValidation*/ ctx[12], false, false, false),
					listen_dev(input, "input", highLight, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsPre*/ 8 && input_id_value !== (input_id_value = /*val*/ ctx[44].id)) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_data_tag_value !== (input_data_tag_value = /*val*/ ctx[44].dataTag)) {
				attr_dev(input, "data-tag", input_data_tag_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_name_value !== (input_name_value = /*val*/ ctx[44].name)) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty[0] & /*myAns*/ 2 && input_value_value !== (input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[46]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[46]]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && span0_id_value !== (span0_id_value = /*val*/ ctx[44].spanid)) {
				attr_dev(span0, "id", span0_id_value);
			}

			if (dirty[0] & /*state*/ 4 && span1_class_value !== (span1_class_value = "" + (null_to_empty(/*state*/ ctx[2].iconVisible + " relative") + " svelte-1ersj3w"))) {
				attr_dev(span1, "class", span1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(665:20) {:else}",
		ctx
	});

	return block;
}

// (663:20) {#if val.decpoint == true}
function create_if_block_4(ctx) {
	let input;
	let input_style_value;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");
			input.value = ".";
			input.disabled = "true";
			attr_dev(input, "class", "tdFont");
			add_location(input, file, 663, 24, 21941);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(663:20) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (662:16) {#each ColsPre as val,i}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*val*/ ctx[44].decpoint == true) return create_if_block_4;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(662:16) {#each ColsPre as val,i}",
		ctx
	});

	return block;
}

// (679:12) {#if state.plus_minus == 1}
function create_if_block_3(ctx) {
	let griddedhelper0;
	let t;
	let griddedhelper1;
	let current;

	griddedhelper0 = new GriddedHelper({
			props: {
				loop: /*Cols*/ ctx[8],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "+"
			},
			$$inline: true
		});

	griddedhelper0.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	griddedhelper1 = new GriddedHelper({
			props: {
				loop: /*Cols_Minus*/ ctx[9],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element minus_point",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "-"
			},
			$$inline: true
		});

	griddedhelper1.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper0.$$.fragment);
			t = space();
			create_component(griddedhelper1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(griddedhelper1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper0_changes = {};
			if (dirty[0] & /*Cols*/ 256) griddedhelper0_changes.loop = /*Cols*/ ctx[8];
			griddedhelper0.$set(griddedhelper0_changes);
			const griddedhelper1_changes = {};
			if (dirty[0] & /*Cols_Minus*/ 512) griddedhelper1_changes.loop = /*Cols_Minus*/ ctx[9];
			griddedhelper1.$set(griddedhelper1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper0.$$.fragment, local);
			transition_in(griddedhelper1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper0.$$.fragment, local);
			transition_out(griddedhelper1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(griddedhelper1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(679:12) {#if state.plus_minus == 1}",
		ctx
	});

	return block;
}

// (700:8) {#if state.decimal_val == 1}
function create_if_block_2(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_decimal*/ ctx[7],
				class1: "tdFont points",
				className: "tdFontP text-center items_element decl_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 mb-0 myP",
				value: "."
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_decimal*/ 128) griddedhelper_changes.loop = /*Cols_decimal*/ ctx[7];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(700:8) {#if state.decimal_val == 1}",
		ctx
	});

	return block;
}

// (711:8) {#if state.slash_val == 1}
function create_if_block_1(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[6],
				class1: "tdFont points",
				className: "tdFontP text-center items_element sla_point",
				tableId: "tdFontP slash_tab",
				tableClass: "slash_tab gridded_tab mt-0",
				value: "/"
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 64) griddedhelper_changes.loop = /*Cols_slash*/ ctx[6];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(711:8) {#if state.slash_val == 1}",
		ctx
	});

	return block;
}

// (731:28) {:else}
function create_else_block(ctx) {
	let td;
	let span;
	let t_value = +/*no*/ ctx[43] + "";
	let t;
	let span_tabindex_value;
	let span_key_value;
	let span_name_value;
	let span_data_tag_value;
	let span_id_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "tabindex", span_tabindex_value = /*val*/ ctx[44].tabIndex);
			attr_dev(span, "key", span_key_value = /*val*/ ctx[44].key);
			attr_dev(span, "name", span_name_value = /*val*/ ctx[44].name);
			attr_dev(span, "data-tag", span_data_tag_value = /*val*/ ctx[44].dataTag);
			attr_dev(span, "class", "tdFontP text-center td_data algn items_element svelte-1ersj3w");
			attr_dev(span, "id", span_id_value = /*val*/ ctx[44].id);
			add_location(span, file, 732, 36, 25097);
			attr_dev(td, "width", "50");
			attr_dev(td, "class", "text-center svelte-1ersj3w");
			add_location(td, file, 731, 32, 25025);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*handleClick*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && span_tabindex_value !== (span_tabindex_value = /*val*/ ctx[44].tabIndex)) {
				attr_dev(span, "tabindex", span_tabindex_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_key_value !== (span_key_value = /*val*/ ctx[44].key)) {
				attr_dev(span, "key", span_key_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_name_value !== (span_name_value = /*val*/ ctx[44].name)) {
				attr_dev(span, "name", span_name_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_data_tag_value !== (span_data_tag_value = /*val*/ ctx[44].dataTag)) {
				attr_dev(span, "data-tag", span_data_tag_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_id_value !== (span_id_value = /*val*/ ctx[44].id)) {
				attr_dev(span, "id", span_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(731:28) {:else}",
		ctx
	});

	return block;
}

// (728:28) {#if val.decpoint}
function create_if_block(ctx) {
	let td;
	let td_key_value;

	const block = {
		c: function create() {
			td = element("td");
			attr_dev(td, "key", td_key_value = /*val*/ ctx[44].key);
			attr_dev(td, "class", "tdFont text-center svelte-1ersj3w");
			attr_dev(td, "width", "50");
			attr_dev(td, "disabled", "true");
			add_location(td, file, 728, 32, 24841);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && td_key_value !== (td_key_value = /*val*/ ctx[44].key)) {
				attr_dev(td, "key", td_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(728:28) {#if val.decpoint}",
		ctx
	});

	return block;
}

// (727:24) {#each totalCols as val,i}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*val*/ ctx[44].decpoint) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(727:24) {#each totalCols as val,i}",
		ctx
	});

	return block;
}

// (725:16) {#each totalRows as data,no}
function create_each_block(ctx) {
	let tr;
	let t;
	let tr_key_value;
	let each_value_1 = /*totalCols*/ ctx[5];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "key", tr_key_value = /*data*/ ctx[41].key);
			add_location(tr, file, 725, 20, 24691);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols, handleClick*/ 1056) {
				each_value_1 = /*totalCols*/ ctx[5];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*totalRows*/ 16 && tr_key_value !== (tr_key_value = /*data*/ ctx[41].key)) {
				attr_dev(tr, "key", tr_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(725:16) {#each totalRows as data,no}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div;
	let center;
	let itemhelper;
	let t0;
	let table0;
	let tr;
	let table0_style_value;
	let t1;
	let t2;
	let t3;
	let t4;
	let table1;
	let tbody;
	let current;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[13],
				reviewMode: /*isReview*/ ctx[0]
			},
			$$inline: true
		});

	let each_value_2 = /*ColsPre*/ ctx[3];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block0 = /*state*/ ctx[2].plus_minus == 1 && create_if_block_3(ctx);
	let if_block1 = /*state*/ ctx[2].decimal_val == 1 && create_if_block_2(ctx);
	let if_block2 = /*state*/ ctx[2].slash_val == 1 && create_if_block_1(ctx);
	let each_value = /*totalRows*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			main = element("main");
			div = element("div");
			center = element("center");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			table0 = element("table");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			table1 = element("table");
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(center, file, 653, 8, 21547);
			set_style(tr, "display", "flex");
			add_location(tr, file, 660, 12, 21802);
			attr_dev(table0, "border", "1");
			attr_dev(table0, "id", "tab2");
			attr_dev(table0, "style", table0_style_value = "border-collapse:collapse;text-align:center");
			add_location(table0, file, 659, 8, 21707);
			attr_dev(tbody, "class", "svelte-1ersj3w");
			add_location(tbody, file, 723, 12, 24618);
			attr_dev(table1, "id", "gridded_sheet");
			attr_dev(table1, "class", "gridded_tab mt-0 lastGrid create_tab myP svelte-1ersj3w");
			add_location(table1, file, 722, 8, 24530);
			attr_dev(div, "class", "griddedModule svelte-1ersj3w");
			add_location(div, file, 652, 4, 21511);
			add_location(main, file, 651, 0, 21500);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div);
			append_dev(div, center);
			mount_component(itemhelper, center, null);
			append_dev(div, t0);
			append_dev(div, table0);
			append_dev(table0, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t4);
			append_dev(div, table1);
			append_dev(table1, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);

			if (dirty[0] & /*ColsPre, state, myAns, rowValidation*/ 4110) {
				each_value_2 = /*ColsPre*/ ctx[3];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (/*state*/ ctx[2].plus_minus == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].decimal_val == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].slash_val == 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*totalRows, totalCols, handleClick*/ 1072) {
				each_value = /*totalRows*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(itemhelper);
			destroy_each(each_blocks_1, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function highLight(event) {
	let cell_class = event.target.getAttribute("name");
	let column_index = document.getElementsByName(cell_class);

	for (let i = 1; i < column_index.length; i++) {
		if (column_index[i].classList.contains("active")) {
			column_index[i].classList.remove("active");
		}

		if (column_index[i].innerHTML == event.target.value) {
			column_index[i].classList.add("active");
		}
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GriddedPreview", slots, []);
	let { isReview } = $$props;
	let { xml } = $$props;
	let { showAns } = $$props;

	// Declare global variables ////
	let bool = " ";

	let userAns = [];
	let ans = [];
	let myAns = [];
	let c = 0;
	let correctInc;
	let isAnswerCorrect = "";
	let answerStatus = "";
	let authAnsSplit;
	let incorrectCls = "";

	let stateData = writable({
		rowNum: 4,
		colNum: 4,
		item: 1,
		plus_minus: 0,
		slash_val: 0,
		decimal_val: 0,
		xml: "",
		textSizeP: 0,
		correctAns: [],
		userList: [],
		isMathquill: false,
		smController: "h",
		pointerEvents: "auto",
		decimal_point: 0,
		iconVisible: "h"
	});

	let state = {};

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(2, state = items);
	});

	onMount(() => {
		// $('body').on('keydown', '.td_data', function(e) { 
		//     if (e.which === 13) {
		//         $(this).click();
		//     }
		// });
		AH.listen(document, "keydown", ".td_data", e => {
			if (e.which === 13) {
				e.click();
			}
		});

		// jQuery('#sm_controller button').click(function() {
		//     jQuery('#sm_controller button').removeClass("active btn-secondary text-white bg-secondary");
		//     jQuery(this).addClass('active btn-secondary text-white bg-secondary');
		// });
		AH.listen(document, "click", "#sm_controller button", e => {
			AH.selectAll("#sm_controller button", "removeClass", ["active,btn-secondary,text-white,bg-secondary"]);
			AH.selectAll(e, "addClass", ["active,btn-secondary,text-white,bg-secondary"]);
		});

		AH.listen(document, "click", "#set-review", function () {
			setReview();
		});

		AH.listen(document, "click", "#unset-review", function () {
			unsetReview();
		});
	});

	function loadModule(loadXml) {
		loadXml = XMLToJSON(loadXml);
		parseXMLPreview(loadXml);
	}

	function parseXMLPreview(MYXML) {
		try {
			$$invalidate(2, state.rowNum = MYXML.smxml._row, state);
			$$invalidate(2, state.colNum = MYXML.smxml._col, state);
			$$invalidate(2, state.slash_val = MYXML.smxml._slash, state);
			$$invalidate(2, state.plus_minus = MYXML.smxml._plusminus, state);
			$$invalidate(2, state.decimal_val = MYXML.smxml._decimal, state);
			$$invalidate(2, state.textSizeP = MYXML.smxml._font, state);
			$$invalidate(2, state.correctAns = MYXML.smxml._correctAns.split(","), state);
			$$invalidate(2, state.decimal_point = MYXML.smxml._fixed_point, state);

			if (window.uaXML) {
				let timer = setTimeout(
					function () {
						parseUserAns(window.uaXML);
						clearTimeout(timer);
					},
					50
				);
			}
		} catch(error) {
			onError = error;

			console.log({
				"error": error.message,
				"function name": "parseXMLPreview",
				"File name": "GriddedPreview.js"
			});
		}
	}

	function parseUserAns(uans) {
		let userAnswer = XMLToJSON(uans);

		if (userAnswer.smans && userAnswer.smans.div && userAnswer.smans.div._userAns) {
			userAns = userAnswer.smans.div._userAns.split(",");
			bool = userAnswer.smans.div._correct;

			// $("#answer").prop("checked", bool)
			ans = userAns;
		} //forceUpdate();
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(2, state.xml = xml, state);
			loadModule(xml);
		}

		//if (this.props.remedStatus != nextProps.remedStatus) {
		//} 
		if (window.QXML) {
			console.log("qxml");
		}

		firstRowItemPre();
		decimalFloatingPre();
		slashFuncPre();
		plusMinusSignPre();
		createdSheetRowPre();
	});

	function handleClick(event) {
		//////////////changing color according to user/////////
		let cell_class = event.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.target.innerHTML;
		setUserAns(event); //////// Call function for answer checking
	}

	function setUserAns(event) {
		let countRes;

		//////// This code set the answer///////////
		let attr = event.target.attributes.getNamedItem("data-tag").value;

		if (event.target.innerHTML === "") {
			userAns[attr] = event.target.value;
		} else {
			userAns[attr] = event.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == "undefined" || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = language.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = language.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = language.incorrect;
		} // return false;

		if (!window.QXML) {
			showAns(countRes);
		}

		AH.select("#special_module_user_xml").value = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != " " && c == user.length) {
			//jQUery("#answer").prop("checked", bool);
			AH.select("#answer", "attr", { "checked": bool });
		} else {
			//jQuery("#answer").prop("checked", isAnswerCorrect);
			AH.select("#answer", "attr", { "checked": isAnswerCorrect });
		}
	}

	function handleClickCombo(event) {
		//////////////changing color according to user/////////
		let cell_class = event.detail.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.detail.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.detail.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.detail.target.innerHTML;
		setUserAnsCombo(event); //////// Call function for answer checking
	}

	function setUserAnsCombo(event) {
		let countRes;

		//////// This code set the answer///////////
		let attr = event.detail.target.attributes.getNamedItem("data-tag").value;

		if (event.detail.target.innerHTML === "") {
			userAns[attr] = event.detail.target.value;
		} else {
			userAns[attr] = event.detail.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == "undefined" || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = language.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = language.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = language.incorrect;
		} // return false;

		if (!window.QXML) {
			showAns(countRes);
		}

		//jQuery("#special_module_user_xml").val("<smans><div type='56' correct='"+isAnswerCorrect+"' userAns='"+state.userList+"'></div></smans>");
		AH.select("#special_module_user_xml").value = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != " " && c == user.length) {
			//jQUery("#answer").prop("checked", bool);
			AH.select("#answer", "attr", { "checked": bool });
		} else {
			//jQuery("#answer").prop("checked", isAnswerCorrect);
			AH.select("#answer", "attr", { "checked": isAnswerCorrect });
		}
	}

	function rowValidation(event) {
		let a = state.rowNum - 1;

		if (event.target.value.length > 1) {
			AH.alert("Double digit not accepted");
			event.target.value = "";
			return false;
		} else if (event.target.value < 0) {
			AH.alert("Less then 1 not accepted");
			event.target.value = "";
			return false;
		} else if (a < event.target.value) {
			AH.alert("Number insert only 0 to " + state.rowNum);
			event.target.value = "";
			return false;
		}

		setUserAns(event);
	}

	////////////////// Create very first row and store data according to click//////////
	let ColsPre = [];

	function firstRowItemPre() {
		$$invalidate(3, ColsPre = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (ans[j] === "%blank%") {
				$$invalidate(1, myAns[j] = " ", myAns);
			} else {
				$$invalidate(1, myAns[j] = ans[j], myAns);
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(3, ColsPre = [...ColsPre, { decpoint: true }]);
			} else {
				if (ColsPre.length < state.colNum) {
					$$invalidate(3, ColsPre = [
						...ColsPre,
						{
							id: "t" + j,
							dataTag: j,
							name: "p" + j,
							value: myAns[j],
							spanid: "t_" + j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	let totalRows = [];
	let totalCols = [];

	function createdSheetRowPre() {
		$$invalidate(4, totalRows = []);
		let dec_point = state.decimal_point;

		for (let i = 0; i < state.rowNum; i++) {
			$$invalidate(5, totalCols = []);

			for (let j = 0; j < state.colNum; j++) {
				if (j == dec_point - 1 && dec_point != 0) {
					$$invalidate(5, totalCols = [...totalCols, { key: "col" + i + j, decpoint: true }]);
				} else {
					if (totalCols.length < state.colNum) {
						$$invalidate(5, totalCols = [
							...totalCols,
							{
								tabIndex: 0,
								key: "col" + i + j,
								name: "p" + j,
								dataTag: j,
								id: "t" + j + "-" + i + j,
								decpoint: false
							}
						]);
					}
				}
			}

			//totalRows.push(<tr key={"row"+i}>{totalCols}</tr>);
			$$invalidate(4, totalRows = [...totalRows, { key: "row" + i }]);
		}
	}

	let Cols_slash = [];

	function slashFuncPre(event) {
		$$invalidate(6, Cols_slash = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(6, Cols_slash = [...Cols_slash, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_slash.length < state.colNum) {
					$$invalidate(6, Cols_slash = [
						...Cols_slash,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	
	let Cols_decimal = [];

	function decimalFloatingPre(event) {
		$$invalidate(7, Cols_decimal = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(7, Cols_decimal = [...Cols_decimal, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_decimal.length < state.colNum) {
					$$invalidate(7, Cols_decimal = [
						...Cols_decimal,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	///////////////// Set review and unset review function//////////////
	function setReview() {
		console.trace();
		($$invalidate(2, state.smController = "", state), $$invalidate(2, state.pointerEvents = "none", state));
		$$invalidate(0, isReview = true);
		showAnswer("yans", "showIcon");

		//jQuery('#sm_controller .your-ans').addClass("btn-light active");
		AH.selectAll("#sm_controller .your-ans", "addClass", ["btn-light", "active"]);

		//jQuery(".tokenHeader").attr("tabindex", "0");
		AH.selectAll(".tokenHeader", "attr", { "tabindex": 0 });

		//document.querySelector(".tokenHeader").setAttribute("tabindex","0");
		setTimeout(getCorrect(), 200);

		if (!window.QXML) {
			showAns(isAnswerCorrect ? language.correct : language.incorrect);
		}
	}

	function getCorrect() {
		for (let i = 0; i < state.correctAns.length; i++) {
			if (state.correctAns[i] == state.userList[i]) {
				//jQuery('#t_'+i).removeClass("icomoon-new-24px-cancel-circle-1").addClass("icomoon-new-24px-checkmark-circle-1");
				AH.select("#t_" + i, "removeClass", "icomoon-new-24px-cancel-circle-1");

				AH.select("#t_" + i, "addClass", "icomoon-new-24px-checkmark-circle-1");
			} else {
				//jQuery('#t_'+i).removeClass("icomoon-new-24px-checkmark-circle-1").addClass("icomoon-new-24px-cancel-circle-1");
				AH.select("#t_" + i, "removeClass", "icomoon-new-24px-checkmark-circle-1");

				AH.select("#t_" + i, "addClass", "icomoon-new-24px-cancel-circle-1");
			}
		}
	}

	function unsetReview() {
		($$invalidate(2, state.smController = "h", state), $$invalidate(2, state.pointerEvents = "auto", state));
		$$invalidate(0, isReview = false);
		showAnswer("yans", "hideIcon");

		//jQuery(".tokenHeader").removeAttr("tabindex");
		AH.selectAll(".tokenHeader", "removeAttr", "tabindex");
	}

	function showAnswer(val, iconState) {
		//show correct incorrect icon with respect to iconState
		if (iconState == "showIcon") {
			$$invalidate(2, state.iconVisible = "", state);
		} else {
			$$invalidate(2, state.iconVisible = "h", state);
		}

		if (val == "cans") {
			let ele = document.getElementsByClassName("gridded_tab");
			ele.disabled = true;
			ans = state.correctAns;
		} else if (val == "yans") {
			ans = userAns;
		}
	}

	///////////////////////////// create plus and minus row//////////////////
	let Cols = [];

	let Cols_Minus = [];

	function plusMinusSignPre(event) {
		$$invalidate(8, Cols = []);
		$$invalidate(9, Cols_Minus = []);
		let dec_point = state.decimal_point;

		//let arr = [];
		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(8, Cols = [
					...Cols,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols.length < state.colNum) {
					$$invalidate(8, Cols = [
						...Cols,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(9, Cols_Minus = [
					...Cols_Minus,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols_Minus.length < state.colNum) {
					$$invalidate(9, Cols_Minus = [
						...Cols_Minus,
						{
							id: "t" + j,
							name: "p" + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	function handleReview(mode) {
		if (mode == "c") {
			showAnswer("cans", "hideIcon");
		} else {
			showAnswer("yans", "showIcon");
		}
	}

	const writable_props = ["isReview", "xml", "showAns"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<GriddedPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
		if ("showAns" in $$props) $$invalidate(15, showAns = $$props.showAns);
	};

	$$self.$capture_state = () => ({
		l: language,
		ItemHelper,
		writable,
		AH,
		XMLToJSON,
		JSONToXML,
		afterUpdate,
		beforeUpdate,
		onMount,
		GriddedHelper,
		isReview,
		xml,
		showAns,
		bool,
		userAns,
		ans,
		myAns,
		c,
		correctInc,
		isAnswerCorrect,
		answerStatus,
		authAnsSplit,
		incorrectCls,
		stateData,
		state,
		unsubscribe,
		loadModule,
		parseXMLPreview,
		parseUserAns,
		handleClick,
		setUserAns,
		handleClickCombo,
		setUserAnsCombo,
		rowValidation,
		highLight,
		ColsPre,
		firstRowItemPre,
		totalRows,
		totalCols,
		createdSheetRowPre,
		Cols_slash,
		slashFuncPre,
		Cols_decimal,
		decimalFloatingPre,
		setReview,
		getCorrect,
		unsetReview,
		showAnswer,
		Cols,
		Cols_Minus,
		plusMinusSignPre,
		handleReview
	});

	$$self.$inject_state = $$props => {
		if ("isReview" in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ("xml" in $$props) $$invalidate(14, xml = $$props.xml);
		if ("showAns" in $$props) $$invalidate(15, showAns = $$props.showAns);
		if ("bool" in $$props) bool = $$props.bool;
		if ("userAns" in $$props) userAns = $$props.userAns;
		if ("ans" in $$props) ans = $$props.ans;
		if ("myAns" in $$props) $$invalidate(1, myAns = $$props.myAns);
		if ("c" in $$props) c = $$props.c;
		if ("correctInc" in $$props) correctInc = $$props.correctInc;
		if ("isAnswerCorrect" in $$props) isAnswerCorrect = $$props.isAnswerCorrect;
		if ("answerStatus" in $$props) answerStatus = $$props.answerStatus;
		if ("authAnsSplit" in $$props) authAnsSplit = $$props.authAnsSplit;
		if ("incorrectCls" in $$props) incorrectCls = $$props.incorrectCls;
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
		if ("ColsPre" in $$props) $$invalidate(3, ColsPre = $$props.ColsPre);
		if ("totalRows" in $$props) $$invalidate(4, totalRows = $$props.totalRows);
		if ("totalCols" in $$props) $$invalidate(5, totalCols = $$props.totalCols);
		if ("Cols_slash" in $$props) $$invalidate(6, Cols_slash = $$props.Cols_slash);
		if ("Cols_decimal" in $$props) $$invalidate(7, Cols_decimal = $$props.Cols_decimal);
		if ("Cols" in $$props) $$invalidate(8, Cols = $$props.Cols);
		if ("Cols_Minus" in $$props) $$invalidate(9, Cols_Minus = $$props.Cols_Minus);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isReview*/ 1) {
			 {
				if (isReview) {
					setReview();
				} else {
					unsetReview(); // this.checkAns();
				}
			}
		}
	};

	return [
		isReview,
		myAns,
		state,
		ColsPre,
		totalRows,
		totalCols,
		Cols_slash,
		Cols_decimal,
		Cols,
		Cols_Minus,
		handleClick,
		handleClickCombo,
		rowValidation,
		handleReview,
		xml,
		showAns
	];
}

class GriddedPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-1ersj3w-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { isReview: 0, xml: 14, showAns: 15 }, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GriddedPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isReview*/ ctx[0] === undefined && !("isReview" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'isReview'");
		}

		if (/*xml*/ ctx[14] === undefined && !("xml" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'xml'");
		}

		if (/*showAns*/ ctx[15] === undefined && !("showAns" in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'showAns'");
		}
	}

	get isReview() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showAns() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default GriddedPreview;
//# sourceMappingURL=GriddedPreview-e106f6cf.js.map
