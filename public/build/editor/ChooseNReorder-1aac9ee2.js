
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { L as JUI, y as l, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, J as append_styles, T as Checkbox, C as validate_each_argument, M as Dialog, N as binding_callbacks, O as bind, v as validate_slots, I as beforeUpdate, X as XMLToJSON, K as JSONToXML, R as Button, w as writable, A as AH$1, e as element, f as space, j as attr_dev, l as set_style, k as add_location, n as insert_dev, p as append_dev, q as listen_dev, D as is_function, F as prop_dev, x as detach_dev, G as run_all, c as create_component, h as text, m as mount_component, Y as add_flush_callback, t as transition_in, a as transition_out, b as destroy_component, H as destroy_each, B as noop } from './main-d284f8db.js';
import './style-inject.es-1c867377.js';
import './choose.min-b9910e9b.js';

/**
 *  Filename    : ValidateItems.js
 *  @Author     : Saquib Ajaz <saquib.ajaz@ucertify.com>
 *  @Version    : 1.0
 *  Last update : 29 May 2020
 *  Last updated by: Dharmendra Mishra
 */
const AH = new JUI();

let smVal = {
  err: {
    q9: l.max_error,
    q27:
      "You have exceeded the module limit. You can only create 6 statement nodes and 4 option nodes.",
    q6_advance: l.max_row_col_error
  },

  processError: function(err, msg) {
    let smErr = {
      error: err,
      message: msg
    };
    return smErr;
  },
  //@TOOD:? @pradeep item-refactor
  validate: function(type, subtype, content_icon) {
    if (type == "q" || type == "u") {
      switch (subtype) {
        case 9:
          return this.validate9(content_icon);
        case 14:
          return this.validate14(content_icon);
        case 6:
          return this.validate6(content_icon);
        case 26:
          return this.validate26(content_icon);
        case 27:
          return this.validate27(content_icon);
      }
    }
  },

  validate9: function(icon) {
    //var len = jQuery("#fillmain").find("[id^=elem]").length;
    let len = AH.selectAll("#fillmain [id^=elem]").length;
    if (len > 6) {
      return this.processError(true, this.err.q9);
    } else {
      return this.processError(false, "valid");
    }
  },

  validate6: function(icon) {
    //var len = jQuery("#choose").find("#sortable li").length;
    let len = AH.selectAll("#choose #sortable li").length;
    console.log("len =>"+len);
    if (len > 5) {
      return this.processError(true, this.err.q9);
    } else {
      return this.processError(false, "valid");
    }
  },

  validate26: function(icon) {
    //var len = jQuery("#mytable >tbody >tr").length;
    let len = AH.selectAll("#mytable >tbody >tr").length;
    //var len1 = jQuery("#mytable >thead >tr >th").length;
    let len1 = AH.selectAll("#mytable >thead >tr >th").length;
    if (len > 5 || len1 > 6) {
      return this.processError(true, this.err.q6_advance);
    } else {
      return this.processError(false, "valid");
    }
  },

  validate14: function(icon) {
    //var len1 = jQuery("#matchListArea [class*='textarea_1']").length;
    let len1  = AH.selectAll("#matchListArea [class*='textarea_1']").length;
    //var len2 = jQuery("#matchListArea [class*='textarea_2']").length;
    let len2 = selectAll("#matchListArea [class*='textarea_2']").length;
    if (len1 > 6 || len2 > 6) {
      return this.processError(true, this.err.q9);
    } else {
      return this.processError(false, "valid");
    }
  },
  validate27: function(icon) {
    //var len1 = jQuery("#choicemain").find(".testmode_table tbody tr").length;
    let len1 = AH.selectAll("#choicemain .testmode_table tbody tr").length;
    //var len2 = jQuery("#choicemain").find(".testmode_table thead tr th").length;
    let len2 = AH.selectAll("#choicemain .testmode_table thead tr th").length;
    if (len1 > 6 || len2 > 5) {
      return this.processError(true, this.err.q27);
    } else {
      return this.processError(false, "valid");
    }
  }
};

/* clsSMChoose\ChooseNReorder.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file = "clsSMChoose\\ChooseNReorder.svelte";

function add_css(target) {
	append_styles(target, "svelte-1afsy3o", ".colorgray{width:56px;background-color:lightgrey}.addbutton.svelte-1afsy3o{position:relative;left:32px;height:31px}.addbuttonplus.svelte-1afsy3o{font-size:24px}.height30.svelte-1afsy3o{height:30px !important}.top1.svelte-1afsy3o{top:1px}.top6{top:6px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hvb3NlTlJlb3JkZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTBoQlksVUFBVSxBQUFFLENBQUMsQUFDakIsTUFBTSxJQUFJLENBQ1YsZ0JBQWdCLENBQUUsU0FBUyxBQUMvQixDQUFDLEFBQ0QsVUFBVSxlQUFDLENBQUMsQUFDUixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsSUFBSSxDQUNWLE1BQU0sQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFDRCxjQUFjLGVBQUMsQ0FBQyxBQUNaLFNBQVMsQ0FBRSxJQUFJLEFBQ25CLENBQUMsQUFFRCxTQUFTLGVBQUUsQ0FBQyxBQUNSLE1BQU0sQ0FBRSxJQUFJLENBQUMsVUFBVSxBQUMzQixDQUFDLEFBRUQsS0FBSyxlQUFDLENBQUMsQUFDSCxHQUFHLENBQUUsR0FBRyxBQUNaLENBQUMsQUFDTyxLQUFLLEFBQUUsQ0FBQyxBQUNmLEdBQUcsQ0FBRSxHQUFHLEFBQ1QsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDaG9vc2VOUmVvcmRlci5zdmVsdGUiXX0= */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i];
	child_ctx[27] = i;
	return child_ctx;
}

// (465:28) <Checkbox on:click={updateSetting} id="allowSort" color="" style="{(state.isParagraph == "1" || state.isSentence == "1")?"cursor: not-allowed":""}" checked = {((state.allowSort == 1)? true : false)}>
function create_default_slot_4(ctx) {
	let t_value = l.allow_sort + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(465:28) <Checkbox on:click={updateSetting} id=\\\"allowSort\\\" color=\\\"\\\" style=\\\"{(state.isParagraph == \\\"1\\\" || state.isSentence == \\\"1\\\")?\\\"cursor: not-allowed\\\":\\\"\\\"}\\\" checked = {((state.allowSort == 1)? true : false)}>",
		ctx
	});

	return block;
}

// (468:32) <Checkbox on:click={updateSetting} id="isSentence" color="primary" checked = {((state.isSentence == 1)? true : false)} >
function create_default_slot_3(ctx) {
	let t_value = l.in_sentence + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(468:32) <Checkbox on:click={updateSetting} id=\\\"isSentence\\\" color=\\\"primary\\\" checked = {((state.isSentence == 1)? true : false)} >",
		ctx
	});

	return block;
}

// (471:32) <Checkbox on:click={updateSetting} id="isParagraph" color="primary" checked = {((state.isParagraph == 1)? true : false)}>
function create_default_slot_2(ctx) {
	let t_value = l.in_paragraph + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(471:32) <Checkbox on:click={updateSetting} id=\\\"isParagraph\\\" color=\\\"primary\\\" checked = {((state.isParagraph == 1)? true : false)}>",
		ctx
	});

	return block;
}

// (477:20) {#each localCData as data, i}
function create_each_block(ctx) {
	let div4;
	let div3;
	let div0;
	let input;
	let input_checked_value;
	let t0;
	let div1;
	let textarea;
	let textarea_value_value;
	let t1;
	let div2;
	let span;
	let div4_key_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[13](/*data*/ ctx[25]);
	}

	const block = {
		c: function create() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			input = element("input");
			t0 = space();
			div1 = element("div");
			textarea = element("textarea");
			t1 = space();
			div2 = element("div");
			span = element("span");
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "id", "check_correct_ans");
			attr_dev(input, "name", "check_correct_ans");
			attr_dev(input, "class", "secure-icon float-end");
			input.checked = input_checked_value = /*data*/ ctx[25].value.charAt(0) == "*" ? true : false;
			set_style(input, "position", "relative");
			set_style(input, "top", "11px");
			set_style(input, "right", "15px");
			add_location(input, file, 480, 36, 19323);
			attr_dev(div0, "class", "col-1");
			add_location(div0, file, 479, 36, 19266);
			attr_dev(textarea, "class", "height32 outline0 mb-1 ms-0 ");

			textarea.value = textarea_value_value = /*data*/ ctx[25].value.charAt(0) == "*"
			? /*data*/ ctx[25].value.slice(1)
			: /*data*/ ctx[25].value;

			add_location(textarea, file, 482, 40, 19672);
			attr_dev(div1, "class", "col");
			add_location(div1, file, 481, 36, 19613);
			attr_dev(span, "class", "remove-item icomoon-24px-delete-1 height30 top1 position-relative float-start svelte-1afsy3o");
			attr_dev(span, "tabindex", "0");
			set_style(span, "right", "39px");
			add_location(span, file, 488, 40, 20115);
			add_location(div2, file, 487, 36, 20068);
			attr_dev(div3, "class", "form-row mt-head");
			add_location(div3, file, 478, 32, 19198);
			attr_dev(div4, "class", "clearfix mt choose_options");
			attr_dev(div4, "key", div4_key_value = /*i*/ ctx[27]);
			add_location(div4, file, 477, 28, 19116);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div3);
			append_dev(div3, div0);
			append_dev(div0, input);
			append_dev(div3, t0);
			append_dev(div3, div1);
			append_dev(div1, textarea);
			append_dev(div3, t1);
			append_dev(div3, div2);
			append_dev(div2, span);

			if (!mounted) {
				dispose = [
					listen_dev(
						input,
						"click",
						function () {
							if (is_function(/*updateCorrect*/ ctx[5].bind(/*data*/ ctx[25].value, /*i*/ ctx[27]))) /*updateCorrect*/ ctx[5].bind(/*data*/ ctx[25].value, /*i*/ ctx[27]).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						textarea,
						"change",
						function () {
							if (is_function(/*editCdata*/ ctx[6].bind(/*data*/ ctx[25].value, /*i*/ ctx[27], /*isCorrect*/ ctx[2][/*i*/ ctx[27]]))) /*editCdata*/ ctx[6].bind(/*data*/ ctx[25].value, /*i*/ ctx[27], /*isCorrect*/ ctx[2][/*i*/ ctx[27]]).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(span, "click", click_handler, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*localCData*/ 1 && input_checked_value !== (input_checked_value = /*data*/ ctx[25].value.charAt(0) == "*" ? true : false)) {
				prop_dev(input, "checked", input_checked_value);
			}

			if (dirty & /*localCData*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[25].value.charAt(0) == "*"
			? /*data*/ ctx[25].value.slice(1)
			: /*data*/ ctx[25].value)) {
				prop_dev(textarea, "value", textarea_value_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(477:20) {#each localCData as data, i}",
		ctx
	});

	return block;
}

// (520:4) <Dialog bind:visible={state.open} on:close={() => {state.open = false}} >
function create_default_slot_1(ctx) {
	let h4;
	let t1;
	let div;
	let span;

	const block = {
		c: function create() {
			h4 = element("h4");
			h4.textContent = "Confirmation";
			t1 = space();
			div = element("div");
			span = element("span");
			span.textContent = "Do you really want to delete?";
			add_location(h4, file, 520, 8, 21802);
			attr_dev(span, "class", "col-md-12 mt-4");
			add_location(span, file, 522, 12, 21864);
			attr_dev(div, "class", "row");
			add_location(div, file, 521, 8, 21833);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, span);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(520:4) <Dialog bind:visible={state.open} on:close={() => {state.open = false}} >",
		ctx
	});

	return block;
}

// (528:12) <Button variant="contained" on:click={removeItem.bind(this,state.data_value,state.data_id)}                  class="bg-primary text-white">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Yes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(528:12) <Button variant=\\\"contained\\\" on:click={removeItem.bind(this,state.data_value,state.data_id)}                  class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (526:8) 
function create_footer_slot(ctx) {
	let div;
	let input;
	let t;
	let button;
	let current;
	let mounted;
	let dispose;

	button = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", function () {
		if (is_function(/*removeItem*/ ctx[7].bind(this, /*state*/ ctx[1].data_value, /*state*/ ctx[1].data_id))) /*removeItem*/ ctx[7].bind(this, /*state*/ ctx[1].data_value, /*state*/ ctx[1].data_id).apply(this, arguments);
	});

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t = space();
			create_component(button.$$.fragment);
			attr_dev(input, "type", "button");
			attr_dev(input, "variant", "contained");
			attr_dev(input, "class", "btn btn-light colorgray");
			input.value = "No";
			add_location(input, file, 526, 12, 22011);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file, 525, 8, 21957);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t);
			mount_component(button, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "click", /*click_handler_1*/ ctx[14], false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};

			if (dirty & /*$$scope*/ 268435456) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(526:8) ",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div9;
	let center;
	let div8;
	let div5;
	let div0;
	let label;
	let t1;
	let input0;
	let input0_value_value;
	let t2;
	let div4;
	let div1;
	let checkbox0;
	let t3;
	let div2;
	let checkbox1;
	let t4;
	let div3;
	let checkbox2;
	let t5;
	let div7;
	let t6;
	let div6;
	let p;
	let t7;
	let b;
	let t9;
	let t10;
	let button;
	let span;
	let t12;
	let t13;
	let input1;
	let t14;
	let input2;
	let input2_defaultvalue_value;
	let t15;
	let dialog;
	let updating_visible;
	let current;
	let mounted;
	let dispose;

	checkbox0 = new Checkbox({
			props: {
				id: "allowSort",
				color: "",
				style: /*state*/ ctx[1].isParagraph == "1" || /*state*/ ctx[1].isSentence == "1"
				? "cursor: not-allowed"
				: "",
				checked: /*state*/ ctx[1].allowSort == 1 ? true : false,
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*updateSetting*/ ctx[4]);

	checkbox1 = new Checkbox({
			props: {
				id: "isSentence",
				color: "primary",
				checked: /*state*/ ctx[1].isSentence == 1 ? true : false,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*updateSetting*/ ctx[4]);

	checkbox2 = new Checkbox({
			props: {
				id: "isParagraph",
				color: "primary",
				checked: /*state*/ ctx[1].isParagraph == 1 ? true : false,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox2.$on("click", /*updateSetting*/ ctx[4]);
	let each_value = /*localCData*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[15](value);
	}

	let dialog_props = {
		$$slots: {
			footer: [create_footer_slot],
			default: [create_default_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[1].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[1].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, 'visible', dialog_visible_binding));
	dialog.$on("close", /*close_handler*/ ctx[16]);

	const block = {
		c: function create() {
			main = element("main");
			div9 = element("div");
			center = element("center");
			div8 = element("div");
			div5 = element("div");
			div0 = element("div");
			label = element("label");
			label.textContent = "Title";
			t1 = space();
			input0 = element("input");
			t2 = space();
			div4 = element("div");
			div1 = element("div");
			create_component(checkbox0.$$.fragment);
			t3 = space();
			div2 = element("div");
			create_component(checkbox1.$$.fragment);
			t4 = space();
			div3 = element("div");
			create_component(checkbox2.$$.fragment);
			t5 = space();
			div7 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t6 = space();
			div6 = element("div");
			p = element("p");
			t7 = text("Add a new item by clicking the ");
			b = element("b");
			b.textContent = "Add Item";
			t9 = text(" button at the bottom-left corner.");
			t10 = space();
			button = element("button");
			span = element("span");
			span.textContent = "+";
			t12 = text(" Â  Add option");
			t13 = space();
			input1 = element("input");
			t14 = space();
			input2 = element("input");
			t15 = space();
			create_component(dialog.$$.fragment);
			attr_dev(label, "for", "headingCorrect");
			attr_dev(label, "class", "mt-1 pt-1");
			add_location(label, file, 453, 24, 17527);
			attr_dev(input0, "id", "headingCorrect");
			attr_dev(input0, "type", "text");
			attr_dev(input0, "class", "sm_input_text mt mb");
			input0.value = input0_value_value = /*state*/ ctx[1].headingCorrect;
			add_location(input0, file, 454, 24, 17612);
			attr_dev(div0, "class", "d-flex ms-2 ps-4");
			add_location(div0, file, 452, 20, 17471);
			attr_dev(div1, "class", "col-md-3 pd-0 float-left");
			add_location(div1, file, 463, 24, 18021);
			attr_dev(div2, "class", "col-md-3 pd-0 float-left");
			add_location(div2, file, 466, 24, 18372);
			attr_dev(div3, "class", "col-md-3 pd-0 float-left");
			add_location(div3, file, 469, 24, 18648);
			attr_dev(div4, "class", "clearfix mt ps-4");
			add_location(div4, file, 462, 20, 17965);
			attr_dev(div5, "class", "choose_head_content px-3 pt-3 pb-0");
			add_location(div5, file, 451, 16, 17401);
			add_location(b, file, 501, 59, 20903);
			attr_dev(p, "class", "mb-md");
			add_location(p, file, 500, 24, 20825);
			attr_dev(div6, "class", "alert alert-info message_content");
			add_location(div6, file, 499, 20, 20753);
			attr_dev(span, "class", "addbuttonplus svelte-1afsy3o");
			add_location(span, file, 510, 44, 21359);
			attr_dev(button, "type", "button");
			attr_dev(button, "id", "add-item");
			attr_dev(button, "class", "btn btn-sm btn-outline-primary btn-sm float-left d-flex align-items-center mt-3 addbutton svelte-1afsy3o");
			add_location(button, file, 504, 20, 21032);
			attr_dev(div7, "class", "choose_item_container mb ps-4");
			add_location(div7, file, 474, 16, 18970);
			attr_dev(input1, "id", "check");
			attr_dev(input1, "type", "hidden");
			attr_dev(input1, "class", "");
			input1.value = "";
			add_location(input1, file, 513, 16, 21490);
			attr_dev(input2, "type", "hidden");
			attr_dev(input2, "name", "special_module_xml");
			attr_dev(input2, "id", "special_module_xml");
			attr_dev(input2, "defaultvalue", input2_defaultvalue_value = /*state*/ ctx[1].xml);
			add_location(input2, file, 514, 16, 21561);
			attr_dev(div8, "id", "main");
			attr_dev(div8, "class", "border");
			add_location(div8, file, 450, 12, 17353);
			add_location(center, file, 449, 8, 17331);
			add_location(div9, file, 448, 4, 17316);
			add_location(main, file, 447, 0, 17304);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div9);
			append_dev(div9, center);
			append_dev(center, div8);
			append_dev(div8, div5);
			append_dev(div5, div0);
			append_dev(div0, label);
			append_dev(div0, t1);
			append_dev(div0, input0);
			append_dev(div5, t2);
			append_dev(div5, div4);
			append_dev(div4, div1);
			mount_component(checkbox0, div1, null);
			append_dev(div4, t3);
			append_dev(div4, div2);
			mount_component(checkbox1, div2, null);
			append_dev(div4, t4);
			append_dev(div4, div3);
			mount_component(checkbox2, div3, null);
			append_dev(div8, t5);
			append_dev(div8, div7);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div7, null);
			}

			append_dev(div7, t6);
			append_dev(div7, div6);
			append_dev(div6, p);
			append_dev(p, t7);
			append_dev(p, b);
			append_dev(p, t9);
			append_dev(div7, t10);
			append_dev(div7, button);
			append_dev(button, span);
			append_dev(button, t12);
			append_dev(div8, t13);
			append_dev(div8, input1);
			append_dev(div8, t14);
			append_dev(div8, input2);
			append_dev(main, t15);
			mount_component(dialog, main, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "change", /*updateSetting*/ ctx[4], false, false, false),
					listen_dev(button, "click", /*addNewItem*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*state*/ 2 && input0_value_value !== (input0_value_value = /*state*/ ctx[1].headingCorrect) && input0.value !== input0_value_value) {
				prop_dev(input0, "value", input0_value_value);
			}

			const checkbox0_changes = {};

			if (dirty & /*state*/ 2) checkbox0_changes.style = /*state*/ ctx[1].isParagraph == "1" || /*state*/ ctx[1].isSentence == "1"
			? "cursor: not-allowed"
			: "";

			if (dirty & /*state*/ 2) checkbox0_changes.checked = /*state*/ ctx[1].allowSort == 1 ? true : false;

			if (dirty & /*$$scope*/ 268435456) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};
			if (dirty & /*state*/ 2) checkbox1_changes.checked = /*state*/ ctx[1].isSentence == 1 ? true : false;

			if (dirty & /*$$scope*/ 268435456) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);
			const checkbox2_changes = {};
			if (dirty & /*state*/ 2) checkbox2_changes.checked = /*state*/ ctx[1].isParagraph == 1 ? true : false;

			if (dirty & /*$$scope*/ 268435456) {
				checkbox2_changes.$$scope = { dirty, ctx };
			}

			checkbox2.$set(checkbox2_changes);

			if (dirty & /*state, localCData, editCdata, isCorrect, updateCorrect*/ 103) {
				each_value = /*localCData*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div7, t6);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*state*/ 2 && input2_defaultvalue_value !== (input2_defaultvalue_value = /*state*/ ctx[1].xml)) {
				attr_dev(input2, "defaultvalue", input2_defaultvalue_value);
			}

			const dialog_changes = {};

			if (dirty & /*$$scope, state*/ 268435458) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty & /*state*/ 2) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[1].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);
			transition_in(checkbox2.$$.fragment, local);
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			transition_out(checkbox2.$$.fragment, local);
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_component(checkbox2);
			destroy_each(each_blocks, detaching);
			destroy_component(dialog);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChooseNReorder', slots, []);
	let localCData = [];
	let oldCData = [];
	let state = {};
	let { xml } = $$props;
	let { getChildXml } = $$props;
	let { changed_advance_xml } = $$props;
	let { editorState } = $$props;
	let { smValidate } = $$props;

	//export uaXML
	/// Declare States
	let stateData = writable({
		xml: "",
		headingCorrect: "",
		allowSort: "",
		isSentence: "",
		isParagraph: "",
		isadvance: false,
		CDATA: "",
		istoggled: false,
		openImageDialog: false,
		openErrorDialog: false,
		row_value: '',
		col_value: '',
		err_message: l.min_row_col_value,
		tomaketable: 'none',
		open: false,
		data_id: '',
		data_value: '',
		stateXMLToJSON: ''
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(1, state = items);
	});

	let isCorrect = [];

	beforeUpdate(() => {
		if (state.xml != xml) {
			$$invalidate(1, state.xml = xml, state);

			// load module with the changed xml
			$$invalidate(1, state.stateXMLToJSON = XMLToJSON(xml), state);

			//loadModule(xml);
			loadModule();
		}
	});

	// this function responsible for loading the module
	function loadModule() {
		//loadXml = XMLToJSON(loadXml);   // convert xml to json using XMLToJSON Function
		parseXMLAuthoring(state.stateXMLToJSON); // xml parsing function
	}

	// xml parsing function
	function parseXMLAuthoring(MYXML) {
		let cdata, oldcdata;

		try {
			$$invalidate(0, localCData = []);
			oldCData = [];

			//this.forceUpdate();
			/* used to check if 'MYXML.smxml.list._oldCData' is set or not */
			if (MYXML.smxml.list._oldCData) {
				oldcdata = MYXML.smxml.list._oldCData.split('###');
			}

			// split the cdata with new line
			cdata = MYXML.smxml.list.__cdata.split("\n");

			// finding the row and col then change the module to multogrid using changed_advance_xml
			if (MYXML.smxml.list._row && MYXML.smxml.list._col) {
				delete MYXML.smxml.list._allowsort;
				delete MYXML.smxml.list._headingAll;
				changed_advance_xml(JSONToXML(MYXML), 26);
			}

			// extracting data in localCData array
			cdata.forEach(function (data, i) {
				if (cdata[i].trim() != "") {
					localCData.push({
						value: cdata[i].replace(/^\s+/g, ""),
						id: i
					});
				}
			});

			if (oldcdata) {
				oldcdata.forEach(function (data, index_no) {
					if (oldcdata[index_no].trim() != "") {
						oldCData.push({
							value: oldcdata[index_no].replace(/^\s+/g, ""),
							id: index_no
						});
					}
				});
			}

			// it update the attribute in lower case
			updateAttrToLower(MYXML);

			// setting state
			$$invalidate(1, state.headingCorrect = MYXML.smxml.list._headingcorrect, state);

			$$invalidate(1, state.allowSort = MYXML.smxml.list._allowsort, state);
			$$invalidate(1, state.isSentence = MYXML.smxml.list._issentence, state);
			$$invalidate(1, state.isParagraph = MYXML.smxml.list._isparagraph, state);
		} catch(error) {
			console.warn({
				error, //forceUpdate();
				'function name': 'parseXMLAuthoring',
				'File name': 'ChooseNReorder.js'
			});
		}
	}

	// Used for Add new option if it passes the limit criteria
	function addNewItem() {
		let len = AH$1.find("#choose", "#sortable li", 'all').length;

		if (len <= 9) {
			addAfterPassedLimitCriteria();
		} else {
			AH$1 && AH$1.alert('Maximum possible value of nodes are 10.');
		}
	}

	// this function is reponsible for updating the xml on the basis of checkbox option
	// selected (sequencing, in sentence, in paragraph) and the change in heading title
	function updateSetting(e) {
		//let xml = XMLToJSON(state.xml);
		let xml = state.stateXMLToJSON;

		switch (e.target.id) {
			case "allowSort":
				// if allowsort is checked
				if (state.isParagraph == "1" || state.isSentence == "1") {
					document.querySelector("#allowSort").checked = true;
				}
				xml.smxml.list._allowsort = e.target.checked == true ? "1" : "0";
				break;
			case "isSentence":
				// if issentence is checked             
				if (e.target.checked == true) {
					if (document.querySelector('#allowSort').checked == false) {
						document.querySelector("#allowSort").click();
						document.querySelector("#allowSort").disabled = true;
					} else {
						document.querySelector('#allowSort').disabled = true;
					}

					$$invalidate(1, state.isSentence = "1", state);
					$$invalidate(1, state.allowSort = "1", state);

					// changing the value of the attribute
					xml.smxml.list._issentence = "1";

					xml.smxml.list._allowSort = "1";
					xml.smxml.list._isparagraph = "0";
				} else {
					// if unchecked
					document.querySelector('#allowSort').disabled = false;

					document.querySelector('#allowSort').click();
					$$invalidate(1, state.isSentence = "0", state);
					$$invalidate(1, state.allowSort = "1", state);

					// updating attributes
					xml.smxml.list._issentence = "0";

					xml.smxml.list._allowSort = "0";
				}
				break;
			case "isParagraph":
				// if isParagraph is checked 
				if (e.target.checked == true) {
					if (document.querySelector("#allowSort").getAttribute("checked") == false) {
						// disable allowshort option when check isSentence and isParagraph
						document.querySelector('#allowSort').click();

						document.querySelector('#allowSort').disabled = true;
					} else {
						document.querySelector("#allowSort").disabled = true;
					}

					$$invalidate(1, state.isParagraph = "1", state);
					$$invalidate(1, state.allowSort = "1", state);

					// updating attributes
					xml.smxml.list._isparagraph = "1";

					xml.smxml.list._allowSort = "1";
					xml.smxml.list._issentence = "0";
				} else {
					// if unchecked
					document.querySelector("#allowSort").disabled = false; // removing disable on allowsort

					document.querySelector("#allowSort").click();
					$$invalidate(1, state.isParagraph = "0", state);
					$$invalidate(1, state.allowSort = "1", state);

					// changing the value of the attribute
					xml.smxml.list._isparagraph = "0";

					xml.smxml.list._allowSort = "0";
				}
				//xml.smxml.list._isparagraph = ((e.target.checked == true)? "1" : "0");
				break;
			case "headingCorrect":
				// if change ocuur in heading
				$$invalidate(1, state.headingCorrect = e.target.value, state);
				// update attribute
				xml.smxml.list._headingCorrect = e.target.value;
				break;
		}

		// updating the xml
		getChildXml(JSONToXML(xml));
	}

	// it update the correct answer on clicking of checkbox button is clicked
	function updateCorrect(i, e) {
		if (e.target.checked == true) {
			// if checkbox is checked that means answer is correct so add * 
			$$invalidate(0, localCData[i].value = "*" + localCData[i].value.trim(), localCData);
		} else {
			$$invalidate(0, localCData[i].value = localCData[i].value.trim().slice(1), localCData);
		}

		// xml to json
		//let xml = XMLToJSON(state.xml);
		let xml = state.stateXMLToJSON;

		var timer = setTimeout(
			(function () {
				let newCData = "\n";

				// storing new data in newCData
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value + "\n";
				});

				// updating attributes
				xml.smxml.list.__cdata = newCData;

				// updating the xml
				getChildXml(JSONToXML(xml));

				clearTimeout(timer);
			}).bind(this),
			200
		);
	}

	// to add new option/item
	function addAfterPassedLimitCriteria() {
		// change the xml to json
		//let xml = XMLToJSON(state.xml);
		let xml = state.stateXMLToJSON;

		// update the cdata with new value
		xml.smxml.list.__cdata = xml.smxml.list.__cdata + "\n*Option value";

		/* It is used for update the data of 'xml.smxml.list._oldCData' after adding the new item to make it visible also in MultiGrid mode */
		if (xml.smxml.list._oldCData) {
			if (xml.smxml.list._oldCData.lastIndexOf('###') == xml.smxml.list._oldCData.length - 3) {
				xml.smxml.list._oldCData += '*Option value';
			} else {
				xml.smxml.list._oldCData += '###*Option value';
			}
		}

		// update and store the xml
		getChildXml(JSONToXML(xml));

		if (!xml.smxml.list._row && !xml.smxml.list._col) {
			var errMsg = smVal.validate(editorState.content_type, editorState.item, editorState.content_icon);
			smValidate(errMsg);
		}
	}

	//// Function call from multigrid item ////////////
	function moveToAdvance(e) {
		if (localCData.length >= 4) {
			if (localCData.length % 2 == 0) {
				$$invalidate(1, state.istoggled = !state.istoggled, state);
				$$invalidate(1, state.openImageDialog = true, state);
			} else {
				var temp = Math.sqrt(localCData.length);

				if (Number.isInteger(temp)) {
					$$invalidate(1, state.istoggled = !state.istoggled, state);
					$$invalidate(1, state.openImageDialog = true, state);
				} else {
					$$invalidate(1, state.istoggled = !state.istoggled, state);
					$$invalidate(1, state.openErrorDialog = true, state);
					$$invalidate(1, state.err_message = l.provide_value_suggestion, state);
				}
			}
		} else {
			$$invalidate(1, state.istoggled = !state.istoggled, state);
			$$invalidate(1, state.openErrorDialog = true, state);
			$$invalidate(1, state.err_message = l.min_row_col_value, state);
		}
	}

	// it update the attribute in lower case
	function updateAttrToLower(data) {
		let xml = data;
		let isLower = false;

		// convert headingCorrect attribute to headingcorrect
		if (xml.smxml.list._headingCorrect) {
			xml.smxml.list._headingcorrect = xml.smxml.list._headingCorrect;
			delete xml.smxml.list._headingCorrect;
			isLower = true;
		}

		// convert allowSort attribute to allowsort
		if (xml.smxml.list._allowSort) {
			xml.smxml.list._allowsort = xml.smxml.list._allowSort;
			delete xml.smxml.list._allowSort;
			isLower = true;
		}

		// convert isParagraph attribute to isparagraph
		if (xml.smxml.list._isParagraph) {
			xml.smxml.list._isparagraph = xml.smxml.list._isParagraph;
			delete xml.smxml.list._isParagraph;
			isLower = true;
		}

		// convert isSentence attribute to issentence
		if (xml.smxml.list._isSentence) {
			xml.smxml.list._issentence = xml.smxml.list._isSentence;
			delete xml.smxml.list._isSentence;
			isLower = true;
		}

		// update ans store the xml
		if (isLower == true) getChildXml(JSONToXML(xml));
	}

	// calls whenever there is change in option value and update the cdata accordingly
	function editCdata(i, isCorr, e) {
		$$invalidate(0, localCData[i].value = e.target.value, localCData);

		try {
			if (oldCData[i]) {
				if (oldCData[i].value.indexOf('##') > 0) {
					oldCData[i].value = oldCData[i].value.split('##')[0] + '##' + e.target.value;
				} else if (oldCData[i].value.indexOf('##') < 1 && oldCData[i].value.indexOf('!') == 0) {
					oldCData[i].value = '!' + e.target.value;
				} else {
					oldCData[i].value = e.target.value;
				}
			}
		} catch(error) {
			console.warn({ error });
		}

		//this.forceUpdate();
		// if answer is correct then add * 
		$$invalidate(
			0,
			localCData[i].value = isCorr == true
			? "*" + localCData[i].value
			: localCData[i].value,
			localCData
		);

		// xml to json
		//let xml = XMLToJSON(state.xml);
		let xml = state.stateXMLToJSON;

		setTimeout(
			(function () {
				let newCData = "\n", newoldCData = '###';

				// getting all values in newCData
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value + "\n";
				});

				if (oldCData) {
					oldCData.forEach(function (data, index_no) {
						if (newoldCData == '') {
							newoldCData += oldCData[index_no].value;
						} else {
							newoldCData += '###' + oldCData[index_no].value;
						}
					});
				}

				// updating it in cdata
				xml.smxml.list.__cdata = newCData;

				/* For update the 'xml.smxml.list._oldCData' when textual data are changed in Normal mode */
				xml.smxml.list._oldCData = newoldCData;

				// update and store the xml
				getChildXml(JSONToXML(xml));
			}).bind(this),
			200
		);
	}

	// calls to remove the item
	function removeItem(data, id) {
		let a = "", newoldcdata_container = "";

		// getting all the values in a except the deleted one
		localCData.forEach(function (data, i) {
			if (localCData[i].id != id) {
				a += localCData[i].value + "\n";
			}
		});

		/* Checks if oldCData exist then after deletion the element it assigned left value in newoldcdata_container variable */
		if (oldCData) {
			oldCData.forEach(function (data, index_no) {
				if (oldCData[index_no].id != id) {
					if (newoldcdata_container == '') {
						newoldcdata_container += oldCData[index_no].value;
					} else {
						newoldcdata_container += '###' + oldCData[index_no].value;
					}
				}
			});
		}

		$$invalidate(1, state.open = false, state);

		// xml to json
		//let xml = XMLToJSON(state.xml);
		let xml = state.stateXMLToJSON;

		// update cdata
		xml.smxml.list.__cdata = a;

		/* For Assigning value in 'xml.smxml.list._oldCData' which is not deleted */
		xml.smxml.list._oldCData = newoldcdata_container;

		// update the cdata
		getChildXml(JSONToXML(xml));
	}

	const writable_props = ['xml', 'getChildXml', 'changed_advance_xml', 'editorState', 'smValidate'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<ChooseNReorder> was created with unknown prop '${key}'`);
	});

	const click_handler = data => {
		($$invalidate(1, state.open = true, state), $$invalidate(1, state.data_value = data.value, state), $$invalidate(1, state.data_id = data.id, state));
	};

	const click_handler_1 = () => {
		$$invalidate(1, state.open = false, state);
	};

	function dialog_visible_binding(value) {
		if ($$self.$$.not_equal(state.open, value)) {
			state.open = value;
			$$invalidate(1, state);
		}
	}

	const close_handler = () => {
		$$invalidate(1, state.open = false, state);
	};

	$$self.$$set = $$props => {
		if ('xml' in $$props) $$invalidate(8, xml = $$props.xml);
		if ('getChildXml' in $$props) $$invalidate(9, getChildXml = $$props.getChildXml);
		if ('changed_advance_xml' in $$props) $$invalidate(10, changed_advance_xml = $$props.changed_advance_xml);
		if ('editorState' in $$props) $$invalidate(11, editorState = $$props.editorState);
		if ('smValidate' in $$props) $$invalidate(12, smValidate = $$props.smValidate);
	};

	$$self.$capture_state = () => ({
		l,
		Button,
		Dialog,
		Checkbox,
		writable,
		AH: AH$1,
		XMLToJSON,
		JSONToXML,
		beforeUpdate,
		smVal,
		localCData,
		oldCData,
		state,
		xml,
		getChildXml,
		changed_advance_xml,
		editorState,
		smValidate,
		stateData,
		unsubscribe,
		isCorrect,
		loadModule,
		parseXMLAuthoring,
		addNewItem,
		updateSetting,
		updateCorrect,
		addAfterPassedLimitCriteria,
		moveToAdvance,
		updateAttrToLower,
		editCdata,
		removeItem
	});

	$$self.$inject_state = $$props => {
		if ('localCData' in $$props) $$invalidate(0, localCData = $$props.localCData);
		if ('oldCData' in $$props) oldCData = $$props.oldCData;
		if ('state' in $$props) $$invalidate(1, state = $$props.state);
		if ('xml' in $$props) $$invalidate(8, xml = $$props.xml);
		if ('getChildXml' in $$props) $$invalidate(9, getChildXml = $$props.getChildXml);
		if ('changed_advance_xml' in $$props) $$invalidate(10, changed_advance_xml = $$props.changed_advance_xml);
		if ('editorState' in $$props) $$invalidate(11, editorState = $$props.editorState);
		if ('smValidate' in $$props) $$invalidate(12, smValidate = $$props.smValidate);
		if ('stateData' in $$props) stateData = $$props.stateData;
		if ('isCorrect' in $$props) $$invalidate(2, isCorrect = $$props.isCorrect);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*localCData*/ 1) {
			 {
				localCData.forEach(function (data, i) {
					$$invalidate(2, isCorrect[i] = data.value.charAt(0) == "*" ? true : false, isCorrect);
				});
			}
		}
	};

	return [
		localCData,
		state,
		isCorrect,
		addNewItem,
		updateSetting,
		updateCorrect,
		editCdata,
		removeItem,
		xml,
		getChildXml,
		changed_advance_xml,
		editorState,
		smValidate,
		click_handler,
		click_handler_1,
		dialog_visible_binding,
		close_handler
	];
}

class ChooseNReorder extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				xml: 8,
				getChildXml: 9,
				changed_advance_xml: 10,
				editorState: 11,
				smValidate: 12
			},
			add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChooseNReorder",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[8] === undefined && !('xml' in props)) {
			console_1.warn("<ChooseNReorder> was created without expected prop 'xml'");
		}

		if (/*getChildXml*/ ctx[9] === undefined && !('getChildXml' in props)) {
			console_1.warn("<ChooseNReorder> was created without expected prop 'getChildXml'");
		}

		if (/*changed_advance_xml*/ ctx[10] === undefined && !('changed_advance_xml' in props)) {
			console_1.warn("<ChooseNReorder> was created without expected prop 'changed_advance_xml'");
		}

		if (/*editorState*/ ctx[11] === undefined && !('editorState' in props)) {
			console_1.warn("<ChooseNReorder> was created without expected prop 'editorState'");
		}

		if (/*smValidate*/ ctx[12] === undefined && !('smValidate' in props)) {
			console_1.warn("<ChooseNReorder> was created without expected prop 'smValidate'");
		}
	}

	get xml() {
		throw new Error("<ChooseNReorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ChooseNReorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<ChooseNReorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ChooseNReorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get changed_advance_xml() {
		throw new Error("<ChooseNReorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set changed_advance_xml(value) {
		throw new Error("<ChooseNReorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ChooseNReorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ChooseNReorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smValidate() {
		throw new Error("<ChooseNReorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smValidate(value) {
		throw new Error("<ChooseNReorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ChooseNReorder;
//# sourceMappingURL=ChooseNReorder-1aac9ee2.js.map
