
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, M as append_styles, W as Checkbox, C as validate_each_argument, V as Button, P as Dialog, Q as binding_callbacks, R as bind, v as validate_slots, o as onMount, X as XMLToJSON, A as AH, L as beforeUpdate, w as writable, y as l, N as JSONToXML, e as element, h as text, f as space, j as attr_dev, k as add_location, n as insert_dev, p as append_dev, q as listen_dev, G as prop_dev, r as group_outros, a as transition_out, u as check_outros, t as transition_in, x as detach_dev, H as run_all, c as create_component, m as mount_component, Z as add_flush_callback, b as destroy_component, K as destroy_each, B as noop, a1 as null_to_empty } from './main-55b2d529.js';

/* clsSMStepAlgo\StepAlgo.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file = "clsSMStepAlgo\\StepAlgo.svelte";

function add_css(target) {
	append_styles(target, "svelte-1ecve1y", ".font18.svelte-1ecve1y{font-size:16px}.fwidth.svelte-1ecve1y{width:100%}.light-cyan-bg.svelte-1ecve1y{background-color:#d4e4ff;color:#333}.top2.svelte-1ecve1y{top:2px}.right5.svelte-1ecve1y{right:5px}.right35.svelte-1ecve1y{right:35px}.step_checkbox.svelte-1ecve1y{width:22%;border:1px solid black;margin-left:10px;position:relative;bottom:1px;cursor:pointer;padding:3px 2px 0}.fixed_ans.svelte-1ecve1y{top:10px;position:relative;float:right;border:1px solid #e0e0e0;background-color:#f5f5f5;border-radius:4px;padding:5px;font-size:15px;font-weight:700}.check_box.svelte-1ecve1y{right:24px;position:relative;width:40px}.inner_inputs.svelte-1ecve1y{margin:0 12px!important}.pointer.svelte-1ecve1y{cursor:pointer !important}.width100.svelte-1ecve1y{width:100px}[id^=\"fillmain\"]{overflow:hidden;text-align:left}[id^=\"fillmain\"] pre{background:none;border:none;font-size:14px!important}[id^=\"fillmain\"] .string{min-height:50px;margin-top:10px;margin-right:10px}[id^=\"fillmain\"] .footerstr{position:relative;margin-top:10px;background-color:#ccc;padding:15px;min-height:60px}[id^=\"fillmain\"] .footerstr .arrow-up{position:absolute;top:-10px;right:50%;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:10px solid #ccc}[id^=\"fillmain\"] .fill-row{padding:6px}[id^=\"fillmain\"] .fillelement, [id^=\"fillmain\"] .drag-resize{height:30px;display:inline-block;position:relative;min-height:30px;margin:1px}#fillmain .drag-resize{height:30px;display:inline-block;position:relative;min-height:30px;margin:1px}#fillmain input[type=\"text\"]{height:99%!important;resize:none;font-size:12px;color:#000;max-width:800px}#fillmain select{height:99%!important;resize:none;font-size:12px;color:#000;max-width:800px}[id^=\"fillmain\"] .drag-resize{vertical-align:middle;border:1px solid #31B731;text-align:center;padding:3px;font-size:14px}[id^=\"fillmain\"] .drag-resize.ui-draggable{cursor:move}[id^=\"fillmain\"] .drop-hover{border:1px dashed red!important;box-shadow:0 0 0 2px yellow inset;outline:1px solid blue}[id^=\"fillmain\"] .fillcheck ul{width:220px}[id^=\"fillmain\"] .fillcheck li.selected{background-color:#E5E5E5}.fillcheck .selected .icomoon-checkmark-3:before{float:left;color:blue;padding:3px;position:relative;right:14px}.fillcheck .icomoon-close-2:before{float:left;color:blue;position:relative;right:14px;font-size:20px}.MathJax_Display{display:inline!important}[id^=\"fillmain\"] .select{font-size:15px}[id^=\"fillmain\"] .textarea{vertical-align:middle;border-radius:3px;background:#ffe;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.ui-draggable-disabled{cursor:no-drop!important;opacity:0.5!important}.colorStyle{background-color:#dee2e6!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

// (568:20) <Checkbox                            id="go_next"                           defaultChecked = {state.gonext ? true: false}                           on:click={(e)=>{goNext("go_next",e)}}                       >
function create_default_slot_8(ctx) {
	let t_value = "Go Next" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(568:20) <Checkbox                            id=\\\"go_next\\\"                           defaultChecked = {state.gonext ? true: false}                           on:click={(e)=>{goNext(\\\"go_next\\\",e)}}                       >",
		ctx
	});

	return block;
}

// (576:20) <Checkbox                            id="fixedans_checkbox"                           defaultChecked = {state.variable_button ? true: false}                           on:click={(e)=>{fixedAnswer("fixedans_checkbox",e)}}                       >
function create_default_slot_7(ctx) {
	let t_value = "Fix Answer" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(576:20) <Checkbox                            id=\\\"fixedans_checkbox\\\"                           defaultChecked = {state.variable_button ? true: false}                           on:click={(e)=>{fixedAnswer(\\\"fixedans_checkbox\\\",e)}}                       >",
		ctx
	});

	return block;
}

// (625:32) {:else}
function create_else_block_2(ctx) {
	let checkbox;
	let current;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[23](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: false
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_3);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(625:32) {:else}",
		ctx
	});

	return block;
}

// (622:32) {#if item._mode == "1"}
function create_if_block_3(ctx) {
	let checkbox;
	let current;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[22](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: true
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_2);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(622:32) {#if item._mode == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (634:24) {#if index == 0}
function create_if_block_1(ctx) {
	let div;
	let span;
	let current_block_type_index;
	let if_block;
	let t0;
	let label;
	let label_for_value;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[38]._sticky == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if_block.c();
			t0 = space();
			label = element("label");
			label.textContent = `${l.sticky}`;
			attr_dev(span, "class", "check_box d-inline-block svelte-1ecve1y");
			add_location(span, file, 635, 32, 25199);
			attr_dev(label, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-1ecve1y");
			attr_dev(label, "for", label_for_value = `sticky_checkbox_${/*index*/ ctx[40]}`);
			add_location(label, file, 644, 32, 26099);
			attr_dev(div, "class", "stick_checkbox d-inline-block");
			add_location(div, file, 634, 28, 25122);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			if_blocks[current_block_type_index].m(span, null);
			append_dev(div, t0);
			append_dev(div, label);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(span, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(634:24) {#if index == 0}",
		ctx
	});

	return block;
}

// (641:36) {:else}
function create_else_block_1(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: false,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], 'fillAuthor_' + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(641:36) {:else}",
		ctx
	});

	return block;
}

// (639:36) {#if item._sticky == "1"}
function create_if_block_2(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: true,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], 'fillAuthor_' + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(639:36) {#if item._sticky == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (587:12) {#each all_steps as item,index}
function create_each_block(ctx) {
	let fieldset;
	let legend;
	let t0_value = /*index*/ ctx[40] + 1 + "";
	let t0;
	let legend_style_value;
	let t1;
	let div1;
	let div0;
	let raw_value = /*item*/ ctx[38].__cdata + "";
	let div0_data_seq_value;
	let div0_id_value;
	let div0_style_value;
	let div0_contenteditable_value;
	let div1_style_value;
	let t2;
	let div8;
	let div2;
	let span0;
	let span0_for_value;
	let t4;
	let span2;
	let span1;
	let input;
	let input_id_value;
	let input_checked_value;
	let t5;
	let label0;
	let label0_for_value;
	let span2_style_value;
	let t7;
	let div4;
	let div3;
	let span3;
	let current_block_type_index;
	let if_block0;
	let t8;
	let label1;
	let label1_for_value;
	let t10;
	let t11;
	let div7;
	let div5;
	let button0;
	let div5_style_value;
	let t13;
	let div6;
	let button1;
	let button1_id_value;
	let div6_style_value;
	let div7_style_value;
	let fieldset_key_value;
	let fieldset_style_value;
	let t15;
	let current;
	let mounted;
	let dispose;

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[20](/*index*/ ctx[40], ...args);
	}

	function change_handler(...args) {
		return /*change_handler*/ ctx[21](/*index*/ ctx[40], ...args);
	}

	const if_block_creators = [create_if_block_3, create_else_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[38]._mode == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*index*/ ctx[40] == 0 && create_if_block_1(ctx);

	function click_handler_4(...args) {
		return /*click_handler_4*/ ctx[24](/*index*/ ctx[40], ...args);
	}

	function click_handler_5(...args) {
		return /*click_handler_5*/ ctx[25](/*index*/ ctx[40], ...args);
	}

	const block = {
		c: function create() {
			fieldset = element("fieldset");
			legend = element("legend");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			t2 = space();
			div8 = element("div");
			div2 = element("div");
			span0 = element("span");
			span0.textContent = `${l.plain_text}`;
			t4 = space();
			span2 = element("span");
			span1 = element("span");
			input = element("input");
			t5 = space();
			label0 = element("label");
			label0.textContent = `${l.interactive}`;
			t7 = space();
			div4 = element("div");
			div3 = element("div");
			span3 = element("span");
			if_block0.c();
			t8 = space();
			label1 = element("label");
			label1.textContent = `${l.no_validation}`;
			t10 = space();
			if (if_block1) if_block1.c();
			t11 = space();
			div7 = element("div");
			div5 = element("div");
			button0 = element("button");
			button0.textContent = `${l.delete}`;
			t13 = space();
			div6 = element("div");
			button1 = element("button");
			button1.textContent = `${l.save}`;
			t15 = space();
			attr_dev(legend, "class", "font18 mb ms-2 pl-1 svelte-1ecve1y");
			attr_dev(legend, "style", legend_style_value = 'width:1em;float:none;');
			add_location(legend, file, 588, 20, 21819);
			attr_dev(div0, "data-seq", div0_data_seq_value = /*index*/ ctx[40]);
			attr_dev(div0, "class", "tinymce-editor-res steps_edit p-1 border fillAuthor");
			attr_dev(div0, "id", div0_id_value = `fillAuthor_${/*index*/ ctx[40]}`);
			attr_dev(div0, "style", div0_style_value = 'padding:0 8px;overflow:auto;outline:none');
			attr_dev(div0, "contenteditable", div0_contenteditable_value = true);
			attr_dev(div0, "data-text", "Enter text here");
			add_location(div0, file, 590, 24, 22034);
			attr_dev(div1, "class", "d-inline-block table_width ms-2 pl-1 pb-2 mb-1");
			attr_dev(div1, "style", div1_style_value = 'width:97%;');
			add_location(div1, file, 589, 20, 21927);
			attr_dev(span0, "class", "pointer d-inline-block plain_text svelte-1ecve1y");
			attr_dev(span0, "data-toggle", "tooltip");
			attr_dev(span0, "title", "Don't use any interactive item!");
			attr_dev(span0, "for", span0_for_value = `viewonly_radio_${/*index*/ ctx[40]}`);
			add_location(span0, file, 604, 24, 22811);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "form-check-input");
			attr_dev(input, "id", input_id_value = "switchElement" + /*index*/ ctx[40]);
			input.checked = input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true;
			attr_dev(input, "color", "primary");
			add_location(input, file, 607, 32, 23183);
			attr_dev(label0, "for", label0_for_value = "switchElement" + /*index*/ ctx[40]);
			add_location(label0, file, 612, 32, 23558);
			attr_dev(span1, "class", "form-check form-switch");
			add_location(span1, file, 606, 28, 23112);
			attr_dev(span2, "class", "stat-percent ms-4");
			attr_dev(span2, "style", span2_style_value = 'display:inline-block;position:relative;');
			add_location(span2, file, 605, 24, 23000);
			attr_dev(div2, "class", "test d-inline-block");
			add_location(div2, file, 603, 20, 22752);
			attr_dev(span3, "class", "check_box d-inline-block svelte-1ecve1y");
			add_location(span3, file, 619, 28, 23920);
			attr_dev(label1, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-1ecve1y");
			attr_dev(label1, "for", label1_for_value = `mode_checkbox_${/*index*/ ctx[40]}`);
			add_location(label1, file, 630, 28, 24843);
			attr_dev(div3, "class", "modes_checkbox d-inline-block ms-2");
			add_location(div3, file, 618, 24, 23842);
			attr_dev(div4, "class", "d-inline-block plain_text ms-3");
			add_location(div4, file, 617, 20, 23771);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-light font12");
			add_location(button0, file, 650, 28, 26581);
			attr_dev(div5, "class", "d-inline-block mr");
			attr_dev(div5, "style", div5_style_value = 'display:inline-block;');
			add_location(div5, file, 649, 24, 26440);
			attr_dev(button1, "id", button1_id_value = `save_step_${/*index*/ ctx[40]}`);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-primary font12 save_button_steps");
			add_location(button1, file, 653, 28, 26811);
			attr_dev(div6, "class", "d-inline-block");
			attr_dev(div6, "style", div6_style_value = 'text-align:right;margin-top:6px;');
			add_location(div6, file, 652, 24, 26710);
			attr_dev(div7, "style", div7_style_value = 'display:inline-block;float:right;');
			attr_dev(div7, "class", "buttons edit_steps");
			add_location(div7, file, 648, 20, 26338);
			attr_dev(div8, "class", "view_checkbox d-inline-block light-cyan-bg px-2 p-1 full-width fwidth svelte-1ecve1y");
			add_location(div8, file, 602, 20, 22647);
			attr_dev(fieldset, "key", fieldset_key_value = /*index*/ ctx[40]);
			attr_dev(fieldset, "style", fieldset_style_value = 'border:1px solid grey');
			attr_dev(fieldset, "class", "new_steps seq_inbox fw shadow-sm mb-2");
			add_location(fieldset, file, 587, 16, 21697);
		},
		m: function mount(target, anchor) {
			insert_dev(target, fieldset, anchor);
			append_dev(fieldset, legend);
			append_dev(legend, t0);
			append_dev(fieldset, t1);
			append_dev(fieldset, div1);
			append_dev(div1, div0);
			div0.innerHTML = raw_value;
			append_dev(fieldset, t2);
			append_dev(fieldset, div8);
			append_dev(div8, div2);
			append_dev(div2, span0);
			append_dev(div2, t4);
			append_dev(div2, span2);
			append_dev(span2, span1);
			append_dev(span1, input);
			append_dev(span1, t5);
			append_dev(span1, label0);
			append_dev(div8, t7);
			append_dev(div8, div4);
			append_dev(div4, div3);
			append_dev(div3, span3);
			if_blocks[current_block_type_index].m(span3, null);
			append_dev(div3, t8);
			append_dev(div3, label1);
			append_dev(div4, t10);
			if (if_block1) if_block1.m(div4, null);
			append_dev(div8, t11);
			append_dev(div8, div7);
			append_dev(div7, div5);
			append_dev(div5, button0);
			append_dev(div7, t13);
			append_dev(div7, div6);
			append_dev(div6, button1);
			insert_dev(target, t15, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "keyup", keyup_handler, false, false, false),
					listen_dev(input, "change", change_handler, false, false, false),
					listen_dev(div5, "click", click_handler_4, false, false, false),
					listen_dev(button1, "click", click_handler_5, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*all_steps*/ 2) && raw_value !== (raw_value = /*item*/ ctx[38].__cdata + "")) div0.innerHTML = raw_value;
			if (!current || dirty[0] & /*all_steps*/ 2 && input_checked_value !== (input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true)) {
				prop_dev(input, "checked", input_checked_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(span3, null);
			}

			if (/*index*/ ctx[40] == 0) if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(fieldset);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t15);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(587:12) {#each all_steps as item,index}",
		ctx
	});

	return block;
}

// (663:12) <Button variant="fab" color="primary" mini aria-label="Add"                  on:click={addEvent.bind(this, 'steps')}                  class="btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30"                  style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>
function create_default_slot_6(ctx) {
	let span;
	let t1;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "+  ";
			t1 = text(" Add Step");
			attr_dev(span, "class", "font18 svelte-1ecve1y");
			add_location(span, file, 666, 16, 27587);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			insert_dev(target, t1, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(663:12) <Button variant=\\\"fab\\\" color=\\\"primary\\\" mini aria-label=\\\"Add\\\"                  on:click={addEvent.bind(this, 'steps')}                  class=\\\"btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30\\\"                  style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>",
		ctx
	});

	return block;
}

// (710:28) {:else}
function create_else_block(ctx) {
	let div5;
	let div1;
	let input;
	let input_id_value;
	let input_style_value;
	let input_auto_focus_value;
	let t0;
	let button0;
	let t1;
	let div0;
	let button1;
	let t2;
	let div2;
	let t4;
	let div3;
	let div3_style_value;
	let t6;
	let div4;
	let div4_style_value;
	let current;

	button0 = new Button({
			props: {
				variant: "contained",
				color: "primary",
				style: 'border:1px solid #4285f4;color:#4285f4;text-transform:none;',
				class: "btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", addEditable);

	button1 = new Button({
			props: {
				id: "latexEdit",
				variant: "contained",
				color: "primary",
				style: 'margin:5px;display:none;',
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*latexEdit*/ ctx[12]);

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			input = element("input");
			t0 = space();
			create_component(button0.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(button1.$$.fragment);
			t2 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t4 = space();
			div3 = element("div");
			div3.textContent = `${l.fill_math_help1}`;
			t6 = space();
			div4 = element("div");
			div4.textContent = `${l.fill_math_help2}`;
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = "input");
			attr_dev(input, "class", "latexInp form-control");
			attr_dev(input, "style", input_style_value = 'margin:5px;width:71%;');
			attr_dev(input, "auto:focus", input_auto_focus_value = true);
			add_location(input, file, 712, 40, 30638);
			attr_dev(div0, "class", "latexEditButton d-inline-block");
			add_location(div0, file, 729, 40, 31794);
			attr_dev(div1, "class", "d-flex");
			add_location(div1, file, 711, 36, 30576);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-1");
			add_location(div2, file, 741, 36, 32577);
			attr_dev(div3, "class", "text-danger ml-1");
			attr_dev(div3, "style", div3_style_value = 'text-indent: 15px;');
			add_location(div3, file, 742, 36, 32675);
			attr_dev(div4, "class", "text-danger ml-1");
			attr_dev(div4, "style", div4_style_value = 'text-indent: 15px;');
			add_location(div4, file, 743, 36, 32797);
			add_location(div5, file, 710, 32, 30533);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, input);
			append_dev(div1, t0);
			mount_component(button0, div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);
			mount_component(button1, div0, null);
			append_dev(div5, t2);
			append_dev(div5, div2);
			append_dev(div5, t4);
			append_dev(div5, div3);
			append_dev(div5, t6);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(710:28) {:else}",
		ctx
	});

	return block;
}

// (689:28) {#if state.fillInTheBlanksChoice == 1}
function create_if_block(ctx) {
	let div5;
	let div1;
	let div0;
	let checkbox;
	let t0;
	let input;
	let input_value_value;
	let input_style_value;
	let input_auto_focus_value;
	let input_placeholder_value;
	let t1;
	let div2;
	let t3;
	let div3;
	let div3_style_value;
	let t5;
	let div4;
	let div4_style_value;
	let current;

	checkbox = new Checkbox({
			props: {
				id: "numeric",
				checked: /*state*/ ctx[0].numeric,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			create_component(checkbox.$$.fragment);
			t0 = space();
			input = element("input");
			t1 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t3 = space();
			div3 = element("div");
			div3.textContent = `${l.fill_text_help1}`;
			t5 = space();
			div4 = element("div");
			div4.textContent = "2. Please do not include space.";
			attr_dev(div0, "class", "width100 svelte-1ecve1y");
			add_location(div0, file, 691, 40, 29136);
			attr_dev(input, "type", "text");
			attr_dev(input, "id", "input1");
			input.value = input_value_value = /*state*/ ctx[0].input_ans;
			attr_dev(input, "class", "form-control mr-4 ml-3");
			attr_dev(input, "style", input_style_value = 'margin:5px');
			attr_dev(input, "auto:focus", input_auto_focus_value = true);

			attr_dev(input, "placeholder", input_placeholder_value = AH.select("#input1").innerHTML != ""
			? l.fill_text_placeholder
			: "");

			add_location(input, file, 695, 44, 29418);
			attr_dev(div1, "class", "d-flex mr-2");
			add_location(div1, file, 690, 36, 29069);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-2 mt-3");
			add_location(div2, file, 705, 36, 30105);
			attr_dev(div3, "class", "text-danger ml-2");
			attr_dev(div3, "style", div3_style_value = 'text-indent:15px');
			add_location(div3, file, 706, 36, 30208);
			attr_dev(div4, "class", "text-danger ml-2");
			attr_dev(div4, "style", div4_style_value = 'text-indent:15px');
			add_location(div4, file, 707, 36, 30328);
			add_location(div5, file, 689, 32, 29026);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, div0);
			mount_component(checkbox, div0, null);
			append_dev(div1, t0);
			append_dev(div1, input);
			append_dev(div5, t1);
			append_dev(div5, div2);
			append_dev(div5, t3);
			append_dev(div5, div3);
			append_dev(div5, t5);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox_changes.checked = /*state*/ ctx[0].numeric;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);

			if (!current || dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = /*state*/ ctx[0].input_ans) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(checkbox);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(689:28) {#if state.fillInTheBlanksChoice == 1}",
		ctx
	});

	return block;
}

// (721:40) <Button                                               variant = "contained"                                               color = "primary"                                              style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                               on:click = {addEditable}                                              class="btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1"                                          >
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add Response");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(721:40) <Button                                               variant = \\\"contained\\\"                                               color = \\\"primary\\\"                                              style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                               on:click = {addEditable}                                              class=\\\"btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1\\\"                                          >",
		ctx
	});

	return block;
}

// (731:44) <Button                                                   id = {"latexEdit"}                                                  variant = "contained"                                                   color = "primary"                                                  style = {'margin:5px;display:none;'}                                                   on:click = {latexEdit}                                                                                 >
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(731:44) <Button                                                   id = {\\\"latexEdit\\\"}                                                  variant = \\\"contained\\\"                                                   color = \\\"primary\\\"                                                  style = {'margin:5px;display:none;'}                                                   on:click = {latexEdit}                                                                                 >",
		ctx
	});

	return block;
}

// (693:44) <Checkbox  id = "numeric" checked = {state.numeric}>
function create_default_slot_3(ctx) {
	let t_value = "Numeric" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(693:44) <Checkbox  id = \\\"numeric\\\" checked = {state.numeric}>",
		ctx
	});

	return block;
}

// (752:24) <Button variant="contained" on:click={handleClose} class="colorStyle" >
function create_default_slot_2(ctx) {
	let t0_value = l.cancel + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(752:24) <Button variant=\\\"contained\\\" on:click={handleClose} class=\\\"colorStyle\\\" >",
		ctx
	});

	return block;
}

// (755:24) <Button variant="contained" on:click={storeAns}                              class="bg-primary text-white">
function create_default_slot_1(ctx) {
	let t_value = l.done + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(755:24) <Button variant=\\\"contained\\\" on:click={storeAns}                              class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (670:8) <Dialog overlayClass="materialOverlay"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width="650" class="row" style={'background-color: #fff;'}>
function create_default_slot(ctx) {
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let t0;
	let div2;
	let button0;
	let t1;
	let button1;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*state*/ ctx[0].fillInTheBlanksChoice == 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button0 = new Button({
			props: {
				variant: "contained",
				class: "colorStyle",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleClose*/ ctx[10]);

	button1 = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*storeAns*/ ctx[13]);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			t0 = space();
			div2 = element("div");
			create_component(button0.$$.fragment);
			t1 = text(",\r\n                        ");
			create_component(button1.$$.fragment);
			attr_dev(div0, "id", "responseDialog");
			add_location(div0, file, 687, 24, 28899);
			add_location(div1, file, 686, 20, 28868);
			attr_dev(div2, "class", "svelteFooter");
			add_location(div2, file, 750, 20, 33046);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, div2, anchor);
			mount_component(button0, div2, null);
			append_dev(div2, t1);
			mount_component(button1, div2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if_blocks[current_block_type_index].d();
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(670:8) <Dialog overlayClass=\\\"materialOverlay\\\"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width=\\\"650\\\" class=\\\"row\\\" style={'background-color: #fff;'}>",
		ctx
	});

	return block;
}

// (676:20) 
function create_title_slot(ctx) {
	let div3;
	let div0;
	let div0_style_value;
	let t1;
	let div2;
	let div1;
	let button0;
	let t2;
	let button0_class_value;
	let button0_value_value;
	let t3;
	let button1;
	let t4;
	let button1_class_value;
	let button1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			div0.textContent = `${l.fill_header}`;
			t1 = space();
			div2 = element("div");
			div1 = element("div");
			button0 = element("button");
			t2 = text("Text");
			t3 = space();
			button1 = element("button");
			t4 = text("Mathematical Equation");
			attr_dev(div0, "class", "mr-lg float-left");
			attr_dev(div0, "style", div0_style_value = 'padding-top:10px;padding-left:13px;font-size:18px;');
			add_location(div0, file, 676, 24, 28131);
			attr_dev(button0, "type", "button");

			attr_dev(button0, "class", button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-1ecve1y"));

			button0.value = button0_value_value = 1;
			add_location(button0, file, 680, 8, 28381);
			attr_dev(button1, "type", "button");

			attr_dev(button1, "class", button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-1ecve1y"));

			button1.value = button1_value_value = 2;
			add_location(button1, file, 681, 8, 28559);
			attr_dev(div1, "class", "btn-group mt-1 row ml-0");
			add_location(div1, file, 679, 7, 28334);
			attr_dev(div2, "class", "float-right mr-4");
			add_location(div2, file, 678, 24, 28295);
			attr_dev(div3, "slot", "title");
			add_location(div3, file, 675, 20, 28087);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div3, t1);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, button0);
			append_dev(button0, t2);
			append_dev(div1, t3);
			append_dev(div1, button1);
			append_dev(button1, t4);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*updateDialog*/ ctx[11].bind(this, 1), false, false, false),
					listen_dev(button1, "click", /*updateDialog*/ ctx[11].bind(this, 2), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1 && button0_class_value !== (button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-1ecve1y"))) {
				attr_dev(button0, "class", button0_class_value);
			}

			if (dirty[0] & /*state*/ 1 && button1_class_value !== (button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-1ecve1y"))) {
				attr_dev(button1, "class", button1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot.name,
		type: "slot",
		source: "(676:20) ",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div7;
	let div4;
	let div0;
	let div0_style_value;
	let t1;
	let div3;
	let div1;
	let checkbox0;
	let t2;
	let div2;
	let checkbox1;
	let div3_style_value;
	let t3;
	let div5;
	let t4;
	let div6;
	let button;
	let t5;
	let dialog;
	let updating_visible;
	let current;

	checkbox0 = new Checkbox({
			props: {
				id: "go_next",
				defaultChecked: /*state*/ ctx[0].gonext ? true : false,
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*click_handler*/ ctx[18]);

	checkbox1 = new Checkbox({
			props: {
				id: "fixedans_checkbox",
				defaultChecked: /*state*/ ctx[0].variable_button ? true : false,
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*click_handler_1*/ ctx[19]);
	let each_value = /*all_steps*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				mini: true,
				"aria-label": "Add",
				class: "btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30",
				style: 'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;',
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addEvent*/ ctx[9].bind(this, 'steps'));

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[26](value);
	}

	let dialog_props = {
		overlayClass: "materialOverlay",
		disableEnforceFocus: true,
		width: "650",
		class: "row",
		style: 'background-color: #fff;',
		$$slots: {
			title: [create_title_slot],
			default: [create_default_slot]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[0].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, 'visible', dialog_visible_binding));
	dialog.$on("close", /*handleClose*/ ctx[10].bind(this));

	const block = {
		c: function create() {
			main = element("main");
			div7 = element("div");
			div4 = element("div");
			div0 = element("div");
			div0.textContent = `${l.create_steps}`;
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			create_component(checkbox0.$$.fragment);
			t2 = space();
			div2 = element("div");
			create_component(checkbox1.$$.fragment);
			t3 = space();
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div6 = element("div");
			create_component(button.$$.fragment);
			t5 = space();
			create_component(dialog.$$.fragment);
			attr_dev(div0, "class", "d-inline-block pt-1 float-start cr_step");
			attr_dev(div0, "style", div0_style_value = 'font-size:20px;position:relative;');
			add_location(div0, file, 563, 12, 20483);
			attr_dev(div1, "class", "modes_checkbox d-inline-block top-checkbox_gonext position-relative top2 svelte-1ecve1y");
			add_location(div1, file, 565, 16, 20650);
			attr_dev(div2, "class", "modes_checkbox d-inline-block m-l top-checkbox_fix position-relative top2 svelte-1ecve1y");
			add_location(div2, file, 574, 16, 21079);
			attr_dev(div3, "style", div3_style_value = {});
			add_location(div3, file, 564, 12, 20616);
			attr_dev(div4, "class", "border-bottom d-flex justify-content-between px-2 pt-1");
			add_location(div4, file, 562, 8, 20401);
			attr_dev(div5, "class", "outer_steps mt-3 mx-3 clear-both");
			add_location(div5, file, 584, 8, 21529);
			attr_dev(div6, "class", "row mx-3 mt-3 pb-3");
			add_location(div6, file, 661, 8, 27173);
			attr_dev(div7, "class", "mt-imp border");
			add_location(div7, file, 561, 4, 20364);
			add_location(main, file, 560, 0, 20352);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div7);
			append_dev(div7, div4);
			append_dev(div4, div0);
			append_dev(div4, t1);
			append_dev(div4, div3);
			append_dev(div3, div1);
			mount_component(checkbox0, div1, null);
			append_dev(div3, t2);
			append_dev(div3, div2);
			mount_component(checkbox1, div2, null);
			append_dev(div7, t3);
			append_dev(div7, div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_dev(div7, t4);
			append_dev(div7, div6);
			mount_component(button, div6, null);
			append_dev(div7, t5);
			mount_component(dialog, div7, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox0_changes.defaultChecked = /*state*/ ctx[0].gonext ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox1_changes.defaultChecked = /*state*/ ctx[0].variable_button ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);

			if (dirty[0] & /*handleSave, deleteEvent, handleChangeCheckbox, all_steps, handleRadio, handleDisable*/ 498) {
				each_value = /*all_steps*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div5, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const button_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const dialog_changes = {};

			if (dirty[0] & /*state*/ 1 | dirty[1] & /*$$scope*/ 1024) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 1) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[0].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(button.$$.fragment, local);
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(button.$$.fragment, local);
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
			destroy_component(dialog);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function replaceVariables(latex_str) {
	let latex_arr = [];
	let latex_arr_check = latex_str;

	if (latex_arr_check.length == undefined && latex_arr_check != "") {
		latex_arr.push(latex_arr_check);
	} else {
		latex_arr = latex_arr_check;
	}

	latex_arr.map(function (item, index) {
		let cdata = item.__cdata;
		let vars = cdata.match(/<{[\s\S]*?}>/gm);

		if (vars) {
			vars.map(function (element) {
				let item = element.match(/<\{(.*?)\}>/g);
				item = item.toString().replace(/<\{|\}>/g, '');
				item = "var:" + item;
				item = item.trim();
				cdata = cdata.replace(element, item);
			});
		}

		latex_arr[index].__cdata = cdata;
	});

	return latex_arr;
}

function reverseHtmlSpecialChars(data) {
	let tags = data.match(/&lt;(.*?)&gt;/gm);
	let tag = '';

	if (tags) {
		for (var i = 0; i < tags.length; i++) {
			tag = tags[i];
			tags[i] = tags[i].replace(/&lt;/g, "<").replace(/&gt;/g, ">");
			data = data.replace(tag, tags[i]);
		}
	}

	return data;
}

function replaceSpaces(data) {
	let matching = data.match(/var:var\d+\s+\s+/g);
	let match;

	if (matching) {
		matching.map(function (item, index) {
			match = item.trim();
			data = data.replace(item, match);
		});
	}

	return data;
}

function addEditable() {
	//let txt = jQuery("#input");
	let txt = document.querySelector("#input");

	//let caretPos = txt[0].selectionStart;
	let caretPos = txt.selectionStart;

	//let textAreaTxt = txt.val();
	let textAreaTxt = txt.value;

	var txtToAdd = "\\MathQuillMathField";
	var txtToAdd = "user Response";

	//txt.val(textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos));
	txt.value = textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos);
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('StepAlgo', slots, []);
	window.spanCounter = 0;

	// window.currentId = "";
	// window.currentInp = "";
	let state = {};

	let new_xml = {};
	var all_steps = [];
	let { stopAuthoringUpdate } = $$props;
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;

	let stateData = writable({
		xml: '',
		fillInTheBlanksChoice: 1,
		opened: false,
		deleteIndex: "",
		remediationToggle: false,
		snackback: false,
		input_ans: '',
		spanCounter: 0,
		currentId: '',
		currentInp: ''
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	onMount(() => {
		if (xml) {
			new_xml = XMLToJSON(xml);
			showItems(new_xml.smxml.step);

			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select("#sticky_checkbox_0").click();

			//setTimeout(function() {
			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select('#sticky_checkbox_0').click();
		} //}, 1000);

		setTimeout(
			function () {
				//jQuery('.save_button_steps').prop('disabled', 'disabled');
				AH.selectAll('.save_button_steps', 'attr', { disabled: 'disabled' });

				initEditor();
			},
			500
		);

		// jQuery(document).on("click touchstart", ".editFill", function() {
		// 	if(jQuery(this).attr("type") == "t") {
		// 		editTextbox(jQuery(this).attr("originalKey"));
		// 	} else if(jQuery(this).attr("type") == "e") {
		// 		editMathbox(jQuery(this).attr("originalKey"));
		// 	}
		// })
		AH.listen(document, 'click', '.editFill', function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});

		AH.listen(document, 'touchstart', '.editFill', function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});
	});

	function editTextbox(key) {
		//console.log('checking');
		key = key.replace(/%{|}%/g, "");

		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";
		$$invalidate(0, state.numeric = ans_type == "n" ? true : false, state);
		$$invalidate(0, state.fillInTheBlanksChoice = 1, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:1});
		//this.setState({open:true});
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//jQuery("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog #customStyleText").value = customStyle[1];

			//jQUery("#input1").val(customStyle[0]);
			//AH.select("#input1").value = customStyle[0];
			$$invalidate(0, state.input_ans = customStyle[0], state);
		} else {
			//jQuery("#input1").val(ans);
			// setTimeout(()=>{
			//     AH.select("#input1").value = ans;
			// },100)
			$$invalidate(0, state.input_ans = ans, state);
		}
	}

	function editMathbox(key) {
		key = key.replace(/%{|}%/g, "");
		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";

		// this.setState({
		//     customStyle:((ans.indexOf("#style#") != -1)?true:false),
		//     fillInTheBlanksChoice:2,
		//     open:true
		// });
		$$invalidate(0, state.customStyle = ans.indexOf("#style#") != -1 ? true : false, state);

		$$invalidate(0, state.fillInTheBlanksChoice = 2, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:2}); ## ALready commented
		//this.setState({open:true}); ## ALready commented
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//$("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog").value = customStyle[1];

			AH.select('#customStyleText').value = customStyle[1];

			//$("#input"+i).val(customStyle[0]);
			AH.select("#input" + i).value = customStyle[0];
		} else {
			//$("#input").val(ans);
			AH.select("#input").value = ans;
		}
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			if (stopAuthoringUpdate === true) return;
			new_xml = XMLToJSON(state.xml);
			showItems(new_xml.smxml.step);
		}
	});

	function showItems(steps) {
		steps = replaceVariables(steps);
		$$invalidate(1, all_steps = steps);
		setToggle(all_steps);
		parseXmlAuthoring(steps);
	}

	function setToggle(steps) {

		steps.map(function (item, index) {
			if (item._viewonly == 1) {
				$$invalidate(1, all_steps[index].toggle = 1, all_steps);
			} else {
				$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			}
		});

		return all_steps;
	}

	function parseXmlAuthoring(steps) {
		steps.map(function (item, index) {
			let cdata = item.__cdata;
			let answerKey = cdata.match(/%{[\s\S]*?}%/gm);
			let answerType = '';

			if (answerKey) {
				//jQuery(answerKey).each(function(i){
				answerKey.forEach(function (data, i) {
					let originalKey = answerKey[i];
					let latexKey = "";
					let editMath = "";
					answerType = answerKey[i].match(/\|(.*?)}%$/gm);
					answerType = answerType ? answerType[0].replace(/\||}%/gm, '') : 't';
					let innerKey = "";
					let icon = "";
					let type = "";

					if (answerType == "t") {
						type = answerType;
						innerKey = "Textbox";
						icon = "icomoon-insert-template";
					} else if (answerType == "n") {
						type = "t";
						innerKey = "Numeric";
						icon = "icomoon-insert-template";
					} else if (answerType == "e") {
						type = answerType;
						innerKey = "Math";
						latexKey = originalKey.replace(/\%\{|\|e\}\%/g, "");
						latexKey = "latex=\"" + latexKey + "\"";
						editMath = "editMath";
						icon = "icomoon-insert-template";
					}

					var regex = new RegExp(RegExp.quote(originalKey));
					cdata = cdata.replace(regex, "<span id=\"latexSpan" + $$invalidate(0, state.spanCounter = $$invalidate(0, ++state.spanCounter, state), state) + "\" " + latexKey + " type='" + type + "' class='alert alert-info editFill " + editMath + "' originalkey='" + originalKey + "' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='" + icon + "'></i>" + innerKey + "</span>");
				});
			}

			$$invalidate(1, all_steps[index].__cdata = cdata, all_steps);
		});
	}

	function goNext(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.gonext = true, state);
			new_xml.smxml._gonext = "1";
		} else {
			$$invalidate(0, state.gonext = false, state);
			new_xml.smxml._gonext = "0";
		}

		updateXML();
	}

	function fixedAnswer(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.variable_button = true, state);
			new_xml.smxml._fixed = "1";
		} else {
			$$invalidate(0, state.variable_button = false, state);
			new_xml.smxml._fixed = "0";
		}

		updateXML();
	}

	function handleChangeCheckbox(id, fillid, e) {
		let name = e.target.name;
		let ref = document.querySelector("#" + name + id);
		let val = "_" + e.target.value;
		let seq = id;

		if (ref.checked) {
			new_xml.smxml.step[seq][val] = "1";
		} else {
			new_xml.smxml.step[seq][val] = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector('#' + fillid).innerHTML;

		updateXML();
	}

	function handleDisable(i) {
		console.log('handle click');

		//jQuery('#save_step_'+i).removeAttr('disabled');
		AH.select('#save_step_' + i, 'removeAttr', 'disabled');
	}

	function handleRadio(index, fillid, event) {
		if (all_steps[index].toggle == 1) {
			$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			new_xml.smxml.step[index]._viewonly = "0";
			new_xml.smxml.step[index]._attempt = "1";
		} else {
			all_steps[index].toggle == 1;
			new_xml.smxml.step[index]._viewonly = "1";
			new_xml.smxml.step[index]._attempt = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector('#' + fillid).innerHTML;

		updateXML();
	}

	function deleteEvent(index, data) {
		let delete_event;

		if (data == 'steps') {
			delete_event = all_steps;

			if (delete_event.length > 2) {
				const add = delete_event.splice(index, 1);
			} else {
				AH.alert("You have atleast 2 steps.");
			}

			$$invalidate(1, all_steps = delete_event);
			updateXML();
		} else if (data == 'algo') {
			$$invalidate(0, state.opened = true, state);
			$$invalidate(0, state.deleteIndex = index, state);
		}

		
	}

	function handleSave(id, fillid) {
		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector('#' + fillid).innerHTML;

		data = data.replace(/&amp;/g, '&'); // replace amp to maintain html entity.
		$$invalidate(1, all_steps[id].__cdata = data, all_steps);

		//jQuery('#save_step_'+id).prop('disabled', 'disabled');
		//document.querySelector('#save_step_'+id).disabled = true;
		AH.select('#save_step_' + id, 'attr', { disabled: 'disabled' });

		updateXML();
	}

	function updateXML() {
		let fixans = new_xml.smxml._fixed;
		let gonext = new_xml.smxml._gonext;
		let xml = '<smxml type="37" fixed="' + fixans + '" gonext="' + gonext + '">';

		all_steps.map(function (element, i) {
			let seq = i + 1;
			let viewonly = element._viewonly;
			let mode = element._mode;
			let attempt = element._attempt;
			let sticky = element._sticky;
			let data = element.__cdata;

			// data = self.reverseReplaceVariables(data);
			data = reverseHtmlSpecialChars(data);

			data = replaceSpaces(data);
			data = data.replace(/&quot;/g, '"').replace(/&nbsp;/g, ' ');
			data = data.replace(/'/g, '"').replace(/\n/g, '');
			let arr = data.match(/<span(.*?)>(.*?)<\/span>/gi);

			if (arr) {
				for (var i = 0; i < arr.length; i++) {
					let originalkey = arr[i].match(/originalkey="%(.*?)%"/g);

					if (originalkey) {
						originalkey = originalkey.toString().replace(/originalkey=/g, '').replace(/"%|%"/g, '%');
						data = data.replace(arr[i], originalkey);
					}
				}
			}

			let cdata = data;

			xml = xml + "<step seq='" + seq + "'" + (attempt != undefined
			? " attempt ='" + attempt + "'"
			: ' ') + (viewonly != undefined
			? " viewonly ='" + viewonly + "'"
			: ' ') + (mode != undefined ? " mode ='" + mode + "'" : ' ') + (sticky != undefined ? " sticky ='" + sticky + "'" : ' ') + "><!--[CDATA[" + cdata + "]]--></step>";
		});

		xml = xml + "</smxml>";
		getChildXml(xml);
	}

	function addEvent(data) {
		let obj = {};
		obj._seq = all_steps.length + 1;
		obj._viewonly = "1";
		obj._attempt = "0";
		obj._mode = "0";
		obj.__cdata = "New Step";
		all_steps.push(obj);
		updateXML();
		$$invalidate(0, state.snackback = true, state);

		var timer = setTimeout(
			function () {
				initEditor();
				clearTimeout(timer);
			},
			500
		);
	}

	function initEditor() {
		// jQuery(document).on("click", ".editMath", function(e){
		//     window.currentId = jQuery(this).attr('id');
		// });
		AH.listen(document, "click", ".editMath", function (_this, e) {
			// window.currentId = _this.getAttribute('id');
			$$invalidate(0, state.currentId = _this.getAttribute('id'), state);
		});

		// jQuery(document).on("click", ".materialOverlay", function(e){
		// 	window.currentId = null;
		//     window.currentInp = null;
		// });
		AH.listen(document, 'click', '.materialOverlay', function (e) {
			//window.currentId = null;
			$$invalidate(0, state.currentId = null, state);

			//window.currentInp = null;
			$$invalidate(0, state.currentInp = null, state);
		});

		tinyMCE.PluginManager.add('res', function (editor, url) {
			editor.addMenuItem('resp', {
				text: "Add response",
				id: 'addToken',
				onclick() {
					handleOpen();
				},
				context: 'insert',
				prependToContext: true
			});
		});

		tinymce.PluginManager.load('equationeditor', themeUrl + 'svelte_items/tinymce/plugins/equationeditor/plugin.min.js');

		tinymce.init({
			selector: '.tinymce-editor-res',
			inline: true,
			theme: 'modern',
			skin: 'skin02',
			min_width: 100,
			resize: true,
			menubar: false,
			toolbar: true,
			elementpath: false,
			statusbar: false,
			force_br_newlines: true,
			remove_trailing_brs: true,
			forced_root_block: false,
			extended_valid_elements: 'span[onClick|contentEditable]',
			valid_elements: "*[*]",
			fixed_toolbar_container: '#toolbar_container',
			extended_valid_elements: 'uc:syntax,uc:ref',
			custom_elements: 'uc:syntax,~uc:ref',
			plugins: [
				"lists link image charmap print preview anchor",
				"searchreplace code fullscreen",
				"insertdatetime media table contextmenu paste res equationeditor "
			],
			content_css: themeUrl + 'svelte_items/src/libs/mathquill.css',
			toolbar: [' bold italic underline | equationeditor'],
			contextmenu: "resp",
			paste_as_text: true
		});
	}

	function handleClose() {
		if (state.fillInTheBlanksChoice == 2) {
			//window.currentId = null;
			$$invalidate(0, state.currentInp = null, state);
		}

		$$invalidate(0, state.open = false, state);
	}

	function updateDialog(targetVal) {
		$$invalidate(0, state.fillInTheBlanksChoice = targetVal, state);
	}

	function latexEdit() {
		$$invalidate(0, state.open = true, state);
	}

	function storeAns() {
		var validate = 0;

		if (state.fillInTheBlanksChoice == 1) {
			//let ans = jQuery("#input1").val();
			let ans = document.querySelector("#input1").value;

			//let numeric = jQuery("#responseDialog #numeric")[0].checked;
			let numeric = document.querySelector("#responseDialog #numeric").checked;

			if (numeric == true) {
				ans += " |n";
			}

			if (ans.trim() == "") {
				validate = 1;
				validate("All fields are required");
			} else {
				tinyMCE.activeEditor.insertContent("<span type='t' class='alert alert-info editFill' originalKey='%{" + ans.trim() + "}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template'></i>" + (numeric == true ? "Numeric" : "Textbox") + "</span>");
			}
		}

		if (state.fillInTheBlanksChoice == 2) {
			//let e = jQuery("#input").val();
			let e = document.querySelector("#input").value;

			if (validate == 0) {
				//document.querySelector("#"+window.currentId).setAttribute("latex",e);
				document.querySelector("#" + state.currentId).setAttribute("latex", e);

				//document.querySelector("#"+window.currentId).setAttribute("originalKey","%{"+e+"|e}%");
				document.querySelector("#" + state.currentId).setAttribute("originalKey", "%{" + e + "|e}%");

				//window.currentId = null;
				$$invalidate(0, state.currentId = null, state);

				//window.currentInp = null;
				$$invalidate(0, state.currentInp = null, state);
			} else {
				validate("All fields are required");
			}
		}

		if (validate == 0) {
			handleClose();
		}
	}

	function handleOpen() {
		// this.setState({
		//     open: true,
		//     codetype: false,
		//     numeric: false
		// });
		$$invalidate(0, state.open = true, state);

		$$invalidate(0, state.codetype = false, state);
		$$invalidate(0, state.numeric = false, state);
	} //this.setState({codetype: false}); #already commented on also react
	//this.setState({numeric: false}); #already commented on also react

	const writable_props = ['stopAuthoringUpdate', 'xml', 'editorState', 'getChildXml'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<StepAlgo> was created with unknown prop '${key}'`);
	});

	const click_handler = e => {
		goNext("go_next");
	};

	const click_handler_1 = e => {
		fixedAnswer("fixedans_checkbox");
	};

	const keyup_handler = (index, e) => {
		handleDisable(index);
	};

	const change_handler = (index, e) => {
		handleRadio(index, 'fillAuthor_' + index);
	};

	const click_handler_2 = (index, e) => {
		handleChangeCheckbox(index, 'fillAuthor_' + index, e);
	};

	const click_handler_3 = (index, e) => {
		handleChangeCheckbox(index, 'fillAuthor_' + index, e);
	};

	const click_handler_4 = (index, e) => {
		deleteEvent(index, 'steps');
	};

	const click_handler_5 = (index, e) => {
		handleSave(index, 'fillAuthor_' + index);
	};

	function dialog_visible_binding(value) {
		if ($$self.$$.not_equal(state.open, value)) {
			state.open = value;
			$$invalidate(0, state);
		}
	}

	$$self.$$set = $$props => {
		if ('stopAuthoringUpdate' in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ('xml' in $$props) $$invalidate(15, xml = $$props.xml);
		if ('editorState' in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ('getChildXml' in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		writable,
		Button,
		Dialog,
		Checkbox,
		l,
		beforeUpdate,
		onMount,
		AH,
		XMLToJSON,
		JSONToXML,
		state,
		new_xml,
		all_steps,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		stateData,
		unsubscribe,
		editTextbox,
		editMathbox,
		showItems,
		setToggle,
		replaceVariables,
		parseXmlAuthoring,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		updateXML,
		reverseHtmlSpecialChars,
		replaceSpaces,
		addEvent,
		initEditor,
		handleClose,
		updateDialog,
		addEditable,
		latexEdit,
		storeAns,
		handleOpen
	});

	$$self.$inject_state = $$props => {
		if ('state' in $$props) $$invalidate(0, state = $$props.state);
		if ('new_xml' in $$props) new_xml = $$props.new_xml;
		if ('all_steps' in $$props) $$invalidate(1, all_steps = $$props.all_steps);
		if ('stopAuthoringUpdate' in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ('xml' in $$props) $$invalidate(15, xml = $$props.xml);
		if ('editorState' in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ('getChildXml' in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
		if ('stateData' in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		all_steps,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		addEvent,
		handleClose,
		updateDialog,
		latexEdit,
		storeAns,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		click_handler,
		click_handler_1,
		keyup_handler,
		change_handler,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		dialog_visible_binding
	];
}

class StepAlgo extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				stopAuthoringUpdate: 14,
				xml: 15,
				editorState: 16,
				getChildXml: 17
			},
			add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StepAlgo",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stopAuthoringUpdate*/ ctx[14] === undefined && !('stopAuthoringUpdate' in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*xml*/ ctx[15] === undefined && !('xml' in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[16] === undefined && !('editorState' in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[17] === undefined && !('getChildXml' in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'getChildXml'");
		}
	}

	get stopAuthoringUpdate() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMMixedItem\ItemPlugin.svelte generated by Svelte v3.40.2 */
const file$1 = "clsSMMixedItem\\ItemPlugin.svelte";

// (13:4) {#if parseInt(editorState.content_icon) == 2}
function create_if_block$1(ctx) {
	let newauthoring;
	let current;

	newauthoring = new StepAlgo({
			props: {
				xml: /*xml*/ ctx[0],
				getChildXml: /*getChildXml*/ ctx[2],
				stopAuthoringUpdate: /*stopAuthoringUpdate*/ ctx[3],
				uxml: /*uxml*/ ctx[4]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(newauthoring.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(newauthoring, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const newauthoring_changes = {};
			if (dirty & /*xml*/ 1) newauthoring_changes.xml = /*xml*/ ctx[0];
			if (dirty & /*getChildXml*/ 4) newauthoring_changes.getChildXml = /*getChildXml*/ ctx[2];
			if (dirty & /*stopAuthoringUpdate*/ 8) newauthoring_changes.stopAuthoringUpdate = /*stopAuthoringUpdate*/ ctx[3];
			if (dirty & /*uxml*/ 16) newauthoring_changes.uxml = /*uxml*/ ctx[4];
			newauthoring.$set(newauthoring_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(newauthoring.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(newauthoring.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(newauthoring, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(13:4) {#if parseInt(editorState.content_icon) == 2}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let main;
	let show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;
	let current;
	let if_block = show_if && create_if_block$1(ctx);

	const block = {
		c: function create() {
			main = element("main");
			if (if_block) if_block.c();
			add_location(main, file$1, 11, 0, 235);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			if (if_block) if_block.m(main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*editorState*/ 2) show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*editorState*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(main, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ItemPlugin', slots, []);
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;
	let { stopAuthoringUpdate } = $$props;
	let { uxml } = $$props;
	const writable_props = ['xml', 'editorState', 'getChildXml', 'stopAuthoringUpdate', 'uxml'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ItemPlugin> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('xml' in $$props) $$invalidate(0, xml = $$props.xml);
		if ('editorState' in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ('getChildXml' in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ('stopAuthoringUpdate' in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ('uxml' in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	$$self.$capture_state = () => ({
		NewAuthoring: StepAlgo,
		xml,
		editorState,
		getChildXml,
		stopAuthoringUpdate,
		uxml
	});

	$$self.$inject_state = $$props => {
		if ('xml' in $$props) $$invalidate(0, xml = $$props.xml);
		if ('editorState' in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ('getChildXml' in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ('stopAuthoringUpdate' in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ('uxml' in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [xml, editorState, getChildXml, stopAuthoringUpdate, uxml];
}

class ItemPlugin extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			xml: 0,
			editorState: 1,
			getChildXml: 2,
			stopAuthoringUpdate: 3,
			uxml: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ItemPlugin",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[0] === undefined && !('xml' in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[1] === undefined && !('editorState' in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[2] === undefined && !('getChildXml' in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'getChildXml'");
		}

		if (/*stopAuthoringUpdate*/ ctx[3] === undefined && !('stopAuthoringUpdate' in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*uxml*/ ctx[4] === undefined && !('uxml' in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'uxml'");
		}
	}

	get xml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stopAuthoringUpdate() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ItemPlugin;
//# sourceMappingURL=ItemPlugin-2fd50d22.js.map
