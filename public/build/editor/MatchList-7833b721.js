
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { a5 as Lang, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, V as Checkbox, C as validate_each_argument, O as Dialog, P as binding_callbacks, Q as bind, v as validate_slots, L as beforeUpdate, X as XMLToJSON, o as onMount, a7 as afterUpdate, w as writable, aa as Loader, A as AH$1, M as JSONToXML, U as Button, z as empty, n as insert_dev, x as detach_dev, f as space, c as create_component, h as text, j as attr_dev, k as add_location, m as mount_component, q as listen_dev, G as prop_dev, W as add_flush_callback, t as transition_in, a as transition_out, b as destroy_component, K as destroy_each, H as run_all, $ as null_to_empty, l as set_style, B as noop, F as set_data_dev } from './main-32dbc3f7.js';

/**
 *  Filename    : ValidateItems.js
 *  @Author     : Saquib Ajaz <saquib.ajaz@ucertify.com>
 *  @Version    : 1.0
 *  Last update : 29 May 2020
 *  Last updated by: Dharmendra Mishra
 */

const smVal = {
    err: {
        q9: Lang.max_error,
        q27:
            "You have exceeded the module limit. You can only create 6 statement nodes and 4 option nodes.",
        q6_advance: Lang.max_row_col_error
    },

    processError: function(err, msg) {
        var smErr = {
        error: err,
        message: msg
        };
        return smErr;
    },
  //@TOOD:? @pradeep item-refactor
    validate: function(type, subtype, content_icon) {
        if (type == "q" || type == "u") {
        switch (subtype) {
            case 9:
            return this.validate9(content_icon);
            case 14:
            return this.validate14(content_icon);
            case 6:
            return this.validate6(content_icon);
            case 26:
            return this.validate26(content_icon);
            case 27:
            return this.validate27(content_icon);
        }
        }
    },

    validate9: function(icon) {
        var len = AH.selectAll("#fillmain [id^=elem]").length;
        if (len > 6) {
        return this.processError(true, this.err.q9);
        } else {
        return this.processError(false, "valid");
        }
    },

    validate6: function(icon) {
         //var len = jQuery("#choose").find("#sortable li").length;
    let len = AH.selectAll("#choose #sortable li").length;
    console.log("len =>"+len);
    if (len > 5) {
      return this.processError(true, this.err.q9);
    } else {
      return this.processError(false, "valid");
    }
    },

    validate26: function(icon) {
         //var len = jQuery("#mytable >tbody >tr").length;
        let len = AH.selectAll("#mytable >tbody >tr").length;
        //var len1 = jQuery("#mytable >thead >tr >th").length;
        let len1 = AH.selectAll("#mytable >thead >tr >th").length;
        if (len > 5 || len1 > 6) {
        return this.processError(true, this.err.q6_advance);
        } else {
        return this.processError(false, "valid");
        }
    },

    validate14: function(icon) {
        var len1 =AI.selectAll("#matchListArea [class*='textarea_1']").length;

        var len2 = AI.selectAll("#matchListArea [class*='textarea_2']").length;
        if (len1 > 6 || len2 > 6) {
        return this.processError(true, this.err.q9);
        } else {
        return this.processError(false, "valid");
        }
    },
    validate27: function(icon) {
        let len1 = AH.selectAll("#choicemain .testmode_table tbody tr").length;
        //var len2 = jQuery("#choicemain").find(".testmode_table thead tr th").length;
        let len2 = AH.selectAll("#choicemain .testmode_table thead tr th").length;
        if (len1 > 6 || len2 > 5) {
          return this.processError(true, this.err.q27);
        } else {
          return this.processError(false, "valid");
        }
    }
};

/* clsSMMatchList\MatchList.svelte generated by Svelte v3.29.0 */

const { document: document_1 } = globals;
const file = "clsSMMatchList\\MatchList.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1kpz00h-style";
	style.textContent = ".colorgray.svelte-1kpz00h{width:56px;background-color:rgb(255, 206, 206)}.colorgray1.svelte-1kpz00h{width:74px;background:#E0E0E0}.font24.svelte-1kpz00h{font-size:22px !important;margin-right:5px}.add_button.svelte-1kpz00h{height:31px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWF0Y2hMaXN0LnN2ZWx0ZSIsInNvdXJjZXMiOlsiTWF0Y2hMaXN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuPCEtLSBcclxuKiAgRmlsZSBOYW1lICAgOiBNYXRjaExpc3Quc3ZlbHRlXHJcbiogIERlc2NyaXB0aW9uIDogTWF0Y2ggdGhlIGxpc3Qgb3B0aW9ucyBhbmQgdHlwZVxyXG4qICBBdXRob3IgICAgICA6IFN1bmRhcmFtIFRyaXBhdGhpXHJcbiogIFZlcnNpb24gICAgIDogMS4wXHJcbiogIFBhY2thZ2UgICAgIDogc3ZlbHRlX2l0ZW1zXHJcbiogIExhc3QgdXBkYXRlIDogIC0tPlxyXG5cclxuPHNjcmlwdD4gXHJcblx0XHJcbiAgICBpbXBvcnQge29uTW91bnQsYWZ0ZXJVcGRhdGUsYmVmb3JlVXBkYXRlfSBmcm9tICdzdmVsdGUnO1xyXG5cdGltcG9ydCB7d3JpdGFibGV9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XHJcblx0aW1wb3J0IExvYWRlciBmcm9tICcuLi9oZWxwZXIvTG9hZGVyLnN2ZWx0ZSc7XHJcblx0aW1wb3J0IHtBSCxYTUxUb0pTT04sSlNPTlRvWE1MfSBmcm9tIFwiLi4vaGVscGVyL0hlbHBlckFJLnN2ZWx0ZVwiO1xyXG4gICAgaW1wb3J0IHtzbVZhbH0gZnJvbSAnLi9saWIvVmFsaWRhdGVJdGVtcyc7XHJcbiAgICBpbXBvcnQgbCBmcm9tICcuLi9zcmMvbGlicy9MYW5nLmpzJ1xyXG4gICAgaW1wb3J0IHsgQnV0dG9uLCBEaWFsb2csIENoZWNrYm94IH0gZnJvbSAnc3ZlbHRlLW11aS9zcmMnO1xyXG5cclxuXHJcblx0Ly8vL2V4cG9ydGluZyB2YWlhYmxlc1xyXG5cdGV4cG9ydCBsZXQgZWRpdG9yU3RhdGU7XHJcbiAgICBleHBvcnQgbGV0IHhtbDtcclxuICAgIGV4cG9ydCBsZXQgZ2V0Q2hpbGRYbWw7XHJcbiAgICBleHBvcnQgbGV0IHNtVmFsaWRhdGU7XHJcblxyXG5cclxuICAgIC8vIHZhcmlhYmxlcyBkZWNscmF0aW9uXHJcbiAgICBsZXQgdGltZXIgPSB7fTtcclxuICAgIGxldCB0ZW1wZGF0YTEgPSBbXTtcclxuICAgIGxldCB0ZW1wZGF0YTIgPSBbXTtcclxuICAgIGxldCBsaXN0aGVhZGluZzEgPSBcIlwiO1xyXG4gICAgbGV0IGxpc3RoZWFkaW5nMiA9IFwiXCI7XHJcbiAgICBsZXQgbXVsdGltYXRjaCA9IFwiXCI7XHJcbiAgICBsZXQgbGlzdDEgPSBbXTtcclxuICAgIGxldCBsaXN0MiA9IFtdO1xyXG4gICAgbGV0IGxvY2FsQ0RhdGEgPSBbXTtcclxuICAgIGxldCBjZGF0YSA9IFwiXCI7XHJcbiAgICBsZXQgZWRpdEZsYWcgPSBmYWxzZTtcclxuICAgIGxldCBlZGl0VmFsdWUgPSBcIlwiO1xyXG4gICAgbGV0IGNsc25hbWUgPSBcIlwiO1xyXG4gICAgbGV0IGNvbHVtbmlkID0gXCJcIjtcclxuICAgIGxldCBjb2x1bW5uYW1lID0gXCJcIjtcclxuICAgIGxldCBpbmRleDtcclxuICAgIGxldCByb3cgPSAwO1xyXG4gICAgbGV0IHN0YXRlID0ge307XHJcblxyXG4vLy8vLy8gSG9sZGluZyBzdGF0ZXMgaW4gd3JpdGFibGUgZm9ybSAvLy8vL1xyXG5cclxuICAgIGxldCBzdGF0ZURhdGEgPSB3cml0YWJsZSh7XHJcbiAgICAgICAgc25hY2tiYWNrICAgICAgICAgICAgICAgOmZhbHNlLFxyXG4gICAgICAgIHhtbCAgICAgICAgICAgICAgICAgICAgIDpcIlwiLFxyXG4gICAgICAgIGxpc3RoZWFkaW5nMSAgICAgICAgICAgIDpcIlwiLFxyXG4gICAgICAgIGxpc3RoZWFkaW5nMiAgICAgICAgICAgIDpcIlwiLFxyXG4gICAgICAgIG11bHRpbWF0Y2ggICAgICAgICAgICAgIDpcIlwiLFxyXG4gICAgICAgIG9wZW5SZXNwb25zZURpYWxvZyAgICAgIDpmYWxzZSxcclxuICAgICAgICBzZXR0aW5nICAgICAgICAgICAgICAgICA6MSxcclxuICAgICAgICBvcGVuSW1hZ2VEaWFsb2cgICAgICAgICA6ZmFsc2UsXHJcbiAgICAgICAgaW1hZ2VDbGFzcyAgICAgICAgICAgICAgOiBcIlwiLFxyXG4gICAgICAgIG1heG5vZGUgICAgICAgICAgICAgICAgIDogMCxcclxuICAgICAgICBjbG5hbWUgICAgICAgICAgICAgICAgICA6XCJcIixcclxuICAgICAgICBhbmNob3JFbCAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgZHJhZ19tb2RlICAgICAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICBvcGVuRGVsZXRlRGlhbG9nICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgIHJvd19pZCAgICAgICAgICAgICAgICAgIDpcIlwiLFxyXG5cdFx0ZGlyXHRcdFx0XHRcdFx0OiBmYWxzZSxcclxuICAgIH0pXHJcblxyXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdGF0ZURhdGEuc3Vic2NyaWJlKChpdGVtcykgPT4ge1xyXG4gICAgICAgIHN0YXRlID0gaXRlbXM7XHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgXHJcbiAgICBiZWZvcmVVcGRhdGUoKCk9PntcclxuXHRcdFxyXG4gICAgICAgIGlmKCBzdGF0ZS54bWwhPSB4bWwgKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnhtbCA9IHhtbDtcclxuXHRcdFx0dGVtcGRhdGExID0gW107XHJcbiAgICBcdFx0dGVtcGRhdGEyID0gW107XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuICAgICAgICAgICAgdmFyIG5ld1htbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xyXG4gICAgICAgICAgICBwYXJzZVhNTEF1dGhvcmluZyhuZXdYbWwpO1xyXG4gICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuXHRmdW5jdGlvbiBsb2FkTGlicygpIHtcclxuICAgICAgICBsZXQgY29uZmlnID0ge1xyXG4gICAgICAgICAgICBwcmVsb2FkOiB0cnVlLFxyXG4gICAgICAgICAgICB0eXBlOiAnc3R5bGVzaGVldCcsXHJcbiAgICAgICAgICAgIGFzOiAnc3R5bGUnXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFILmNyZWF0ZUxpbmsoaXRlbVVybCArICdjbHNTTU1hdGNoTGlzdC9jc3MvbWF0Y2hsaXN0QXV0aC5jc3MnLCBjb25maWcpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTW91bnQoKCk9PntcclxuXHRcdGxvYWRMaWJzKCk7XHJcbiAgICAgICAgLy8gcHJldmVudGluZyB0aGUgZW50ZXIga2V5IGluIHRoZSB0ZXh0YXJlYVxyXG4gICAgICAgIEFJLmxpc3Rlbihkb2N1bWVudCwna2V5ZG93bicsJ3RleHRhcmVhJyxmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBpZihldmVudC5rZXlDb2RlID09IDEzKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcblx0XHR9KTtcclxuXHRcdC8vIGpRdWVyeShkb2N1bWVudCkub2ZmKFwia2V5ZG93blwiLFwidGV4dGFyZWFcIikub24oXCJrZXlkb3duXCIsIFwidGV4dGFyZWFcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdC8vIFx0aWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHtcclxuXHRcdC8vIFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0Ly8gXHR9XHJcblx0XHQvLyB9KTtcclxuXHRcdC8vIGZvciBkZWxldGluZyB0aGUgaW1hZ2VcclxuXHRcdEFJLmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcuaW1hZ2VfZGVsZXRlJywgKF9lbGUpID0+IHtcclxuXHRcdFx0bGV0IG9sZEltYWdlID0gQUkuZmluZChfZWxlLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCwndGV4dGFyZWEnKS52YWx1ZTtcclxuXHRcdFx0bGV0IG5ld1ZhbHVlID0gc3RhdGUueG1sLnJlcGxhY2Uob2xkSW1hZ2UsIFwiaW5zZXJ0IHZhbHVlXCIpO1xyXG5cdFx0XHRnZXRDaGlsZFhtbChuZXdWYWx1ZSk7XHJcblx0XHR9KVxyXG5cclxuXHJcblx0XHQvLyBqUXVlcnkoJyNtYXRjaExpc3RBcmVhJykudG9vbHRpcCh7XHJcblx0XHQvLyBcdHNlbGVjdG9yOiAnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXSdcclxuXHRcdC8vIH0pO1xyXG5cdFx0XHJcblx0XHRcclxuXHRcdEFJLmxpc3Rlbihkb2N1bWVudCwnbW91c2V1cCcsJy51aS1kcm9wcGFibGUnLGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIubWF0Y2hsaXN0LWRlbGV0ZVwiKS5mb3JFYWNoKChfZWxtKSA9PiB7XHJcblx0XHRcdFx0XHRfZWxtLmNsYXNzTGlzdC5hZGQoXCJ0dHNfbm9zcGVha1wiKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9KVxyXG5cdFx0fSlcclxuXHRcdC8valF1ZXJ5KCcuYWxnb19kaXYgc3BhbicpLmNzcygnY29sb3InLCcjMzMzJyk7XHJcblx0XHRsZXQgYWxnb19kaXZfbGVuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5hbGdvX2RpdiBzcGFuXCIpO1xyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IGFsZ29fZGl2X2xlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRhbGdvX2Rpdl9sZW5baV0uc3R5bGUuY29sb3IgPSBcIiMzMzNcIjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBqUXVlcnkoZG9jdW1lbnQpLm9uKCdrZXlkb3duJywgJy5kZWxldGVfbWF0Y2hfbm9kZSwgLmRlbGV0ZV9tYXRjaF9ub2RlX2F1dGgnLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0Ly8gXHRpZiAoKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQud2hpY2ggPT0gMTMpKSB7XHJcblx0XHQvLyBcdC8vIGNsaWNrIHRoZSBlbGVtZW50IHdoaWNoIGN1cnJlbnRseSBnZXQgdGhlIGZvY3VzIGFuZCBlbnRlciBrZXkgaXMgZG93blxyXG5cdFx0Ly8gXHRqUXVlcnkodGhpcykudHJpZ2dlcignY2xpY2snKTtcclxuXHRcdC8vIFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdC8vIFx0fVxyXG5cdFx0Ly8gfSk7XHJcblx0XHRBSS5saXN0ZW4oZG9jdW1lbnQsJ2tleWRvd24nLCcuZGVsZXRlX21hdGNoX25vZGUsIC5kZWxldGVfbWF0Y2hfbm9kZV9hdXRoJywgZnVuY3Rpb24oZGF0YSxldmVudCkge1xyXG5cdFx0XHRpZigoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC53aGljaCA9PSAxMykpIHtcclxuXHRcdFx0XHQvLyBOZWVkIHRpIGZpeCBvbmUgbW9yZSBsaW5lIGhlcmUuLi4uXHJcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuICAgIH0pXHJcblxyXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyB0aGUgeG1sXHJcblx0ZnVuY3Rpb24gcGFyc2VYTUxBdXRob3JpbmcoUVhNTCkge1xyXG5cdFx0bGlzdDEgPSBbXTtcclxuXHRcdGxpc3QyID0gW107XHJcblx0XHRsb2NhbENEYXRhID0gW107XHJcblx0XHQvLyBzZXR0aW5nIHRoZSBzdGF0ZSB3aXRoIHRoZSB2YWx1ZSBpbiB0aGUgeG1sXHJcblx0XHRzdGF0ZS5saXN0aGVhZGluZzEgPSBRWE1MLnNteG1sLm1hdGNobGlzdC5fbGlzdGhlYWRpbmcxO1xyXG5cdFx0c3RhdGUubGlzdGhlYWRpbmcyID0gUVhNTC5zbXhtbC5tYXRjaGxpc3QuX2xpc3RoZWFkaW5nMjtcclxuXHRcdHN0YXRlLm11bHRpbWF0Y2ggPSBRWE1MLnNteG1sLm1hdGNobGlzdC5fbXVsdGltYXRjaDtcclxuXHRcdHN0YXRlLmRyYWdfbW9kZSA9IChRWE1MLnNteG1sLm1hdGNobGlzdC5fbXVsdGltYXRjaCA9PSAyKSA/IHRydWUgOiBmYWxzZVxyXG5cdFx0XHJcblx0XHQvLyBzdG9yaW5nIHRoZSB2YWx1ZXMgaW4gbXVsdGltYXRjaCBhbmQgY2RhdGFcclxuXHRcdG11bHRpbWF0Y2ggPSBRWE1MLnNteG1sLm1hdGNobGlzdC5fbXVsdGltYXRjaDtcclxuXHRcdGNkYXRhID0gUVhNTC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YTtcclxuXHJcblx0XHQvLyBjaGVja2luZyBmb3IgaWYgaXNfYWxnbyBpcyBkZWZpbmVkIGluIHhtbCBvciBub3RcclxuXHRcdGlmIChRWE1MLnNteG1sLm1hdGNobGlzdC5faXNfYWxnbykge1xyXG5cdFx0XHQvLyBpZiBpc19hbGdvIGlzIHRydWUgdGhlbiBwdXQgdGhlIHZhbHVlIGluIGlzYWxnbyBhcyB0cnVlIGVsc2UgZmFsc2VcclxuXHRcdFx0c3RhdGUuaXNhbGdvID0gKFFYTUwuc214bWwubWF0Y2hsaXN0Ll9pc19hbGdvID09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGlmIGlzX2FsZ28gaXMgbm90IGRlZmluZWQgbWVhbnMgaXRzIHZhbHVlIHdpbGwgYmUgZmFsc2VcclxuXHRcdFx0c3RhdGUuaXNhbGdvID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIHRoZSBtYXhpbXVtIG5vIG9mIG5vZGUgaS5lLCBtYXhfbm9kZVxyXG5cdFx0aWYgKFFYTUwuc214bWwubWF0Y2hsaXN0Ll9tYXhfbm9kZSkge1xyXG5cdFx0XHR2YXIgbnVtID0gTnVtYmVyKFFYTUwuc214bWwubWF0Y2hsaXN0Ll9tYXhfbm9kZSk7XHJcblx0XHRcdHN0YXRlLm1heG5vZGUgPSAoIG51bSA+IDAgPyBudW0gOiAwIClcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0YXRlLm1heG5vZGUgPSAnJztcclxuXHRcdH1cclxuXHRcdC8vIHNwbGl0dGluZyB0aGUgY2RhdGEgd2l0aCBuZXcgbGluZVxyXG5cdFx0Y2RhdGEgPSBjZGF0YS5zcGxpdChcIlxcblwiKTtcclxuXHJcblx0XHRcclxuXHRcdC8vIHRyYXZlcnNpbmcgdGhyb3VnaCB0aGUgY2RhdGFcclxuXHRcdC8vIGpRdWVyeShjZGF0YSkuZWFjaCggZnVuY3Rpb24gKGkpIHtcclxuXHRcdGNkYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKSB7XHJcblx0XHRcdGlmIChjZGF0YVtpXS50cmltKCkgIT0gXCJcIikge1xyXG5cdFx0XHRcdC8vIEZpbmRpbmcgdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgYnJhY2tldHMgaW4gY2RhdGFcclxuXHRcdFx0XHRpZiAoY2RhdGFbaV0uaW5kZXhPZihcIltcIikgPj0gMCAmJiBjZGF0YVtpXS5pbmRleE9mKFwiXVwiKSA+PSAwKSB7XHJcblx0XHRcdFx0XHQvLyBleHRyYWN0aW5nIHZhbHVlIDEgYnkgcmVwbGNpbmcgdGhlIGNvbnRlbnQgc3RhcnQgd2l0aCBbIGFuZCBlbmQgd2l0aCBdXHJcblx0XHRcdFx0XHRsZXQgdmFsdWUxID0gY2RhdGFbaV0ucmVwbGFjZShjZGF0YVtpXS5tYXRjaCgvXFxbKC4qPylcXF0vZyksXCJcIikucmVwbGFjZSgvXlxccysvZywgXCJcIik7XHJcblx0XHRcdFx0XHRsZXQgdmFsdWUyID0gY2RhdGFbaV0ubWF0Y2goL1xcWyguKj8pXFxdL2cpWzBdO1xyXG5cdFx0XHRcdFx0Ly8gZmluZGluZyB0aGUgdmFsdWUgMiBieSBmaW5kaW5nIHRoZSB0ZXh0IHN0YXJ0IHdpdGggWyBhbmQgZW5kIHdpdGggXSBhbmQgdGhlIHJlbW92aW5nIHRoZXNlIGJyYWNrZXRzXHJcblx0XHRcdFx0XHR2YWx1ZTIgPSB2YWx1ZTIucmVwbGFjZShcIltcIixcIlwiKS5yZXBsYWNlKFwiXVwiLFwiXCIpO1xyXG5cdFx0XHRcdFx0Ly8gc3RvcmUgdGhlIHZhbHVlIGluIHRoZSBsb2NhbENEYXRhXHJcblx0XHRcdFx0XHQvLyBsb2NhbENEYXRhLnB1c2goe1xyXG5cdFx0XHRcdFx0Ly8gXHR2YWx1ZTE6IHZhbHVlMSxcclxuXHRcdFx0XHRcdC8vIFx0dmFsdWUyOiB2YWx1ZTIsXHJcblx0XHRcdFx0XHQvLyBcdGlkOmlcclxuXHRcdFx0XHRcdC8vIH0pO1xyXG5cdFx0XHRcdFx0bG9jYWxDRGF0YSA9IFtcclxuXHRcdFx0XHRcdFx0Li4ubG9jYWxDRGF0YSwge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlMTogdmFsdWUxLFxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlMjogdmFsdWUyLFxyXG5cdFx0XHRcdFx0XHRcdGlkOmlcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XVxyXG5cdFx0XHRcdFx0bGlzdDJbaV0gPSBjZGF0YVtpXS5yZXBsYWNlKGNkYXRhW2ldLm1hdGNoKC9cXFsoLio/KVxcXS9nKSxcIlwiKS5yZXBsYWNlKC9eXFxzKy9nLCBcIlwiKTsgLy8gdmFsdWUgMVxyXG5cdFx0XHRcdFx0bGlzdDFbaV0gPSBjZGF0YVtpXS5tYXRjaCgvXFxbKC4qPylcXF0vZylbMF07IFxyXG5cdFx0XHRcdFx0bGlzdDFbaV0gPSBsaXN0MVtpXS5yZXBsYWNlKFwiW1wiLFwiXCIpLnJlcGxhY2UoXCJdXCIsXCJcIik7IC8vIHZhbHVlIDJcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZXJyTWVzc2FnZSA9IFwiQnJhY2tldCBpcyBNaXNzaW5nIGluIGxpbmUgbm8uIFwiK2k7XHJcblx0XHRcdFx0XHRzdGF0ZS5zbmFja2JhY2sgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0Ly9mb3JjZVVwZGF0ZSgpO1xyXG4gICAgfSBcclxuICAgIC8vIHRoaXMgZnVuY3Rpb24gY2FsbHMgJiB1cGRhdGVkIHRoZSB4bWwgd2hlbmV2ZXIgdGhlcmUgaXMgY2hhbmdlIGluIGxpc3QgaGVhZGluZyB0ZXh0Ym94ICYgbWF4bm9kZSB0ZXh0Ym94XHJcblx0ZnVuY3Rpb24gdXBkYXRlWG1sKGUpIHtcclxuXHRcdC8vIHVwZGF0aW5nIHRoZSB4bWwgdG8ganNvbiBieSBYTUxUb0pTT04gZnVuY3Rpb25cclxuXHRcdHZhciBuZXdYbWwgPSBYTUxUb0pTT04oc3RhdGUueG1sKTtcclxuXHRcdC8vIGlmIHRoZXJlIGlzIGNoYW5nZSBpbiBsaXN0aGVhZGluZyAxXHJcblx0XHRpZiAoZS50YXJnZXQuaWQgPT0gXCJsaXN0aGVhZGluZzFcIikge1xyXG5cdFx0XHRzdGF0ZS5saXN0aGVhZGluZzEgPSBlLnRhcmdldC52YWx1ZTtcclxuXHRcdH0gZWxzZSBpZiAoZS50YXJnZXQuaWQgPT0gXCJsaXN0aGVhZGluZzJcIikge1xyXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBjaGFuZ2UgaW4gbGlzdGhlYWRpbmcgMlxyXG5cdFx0XHRzdGF0ZS5saXN0aGVhZGluZzIgPSBlLnRhcmdldC52YWx1ZTtcclxuXHRcdH0gZWxzZSBpZiAoZS50YXJnZXQuaWQgPT0gXCJtYXhub2RlXCIpIHtcclxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgY2hhbmdlIGluIG1heG5vZGVcclxuXHRcdFx0aWYgKGlzTmFOKGUudGFyZ2V0LnZhbHVlKSkge1xyXG5cdFx0XHRcdEFJLnNob3dtc2coXHJcblx0XHRcdFx0XHQnRXJyb3IgTWVzc2FnZScsXHJcblx0XHRcdFx0XHQnUGxlYXNlIGVudGVyIG51bWVyaWMgdmFsdWUnLFxyXG5cdFx0XHRcdFx0J2Vycm9yJ1xyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoZS50YXJnZXQudmFsdWUgPiA2KSB7XHJcblx0XHRcdFx0QUkuc2hvd21zZygnUGxlYXNlIGluc2VydCB2YWx1ZSBiZXR3ZWVuIDEgdG8gNicpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXRlLm1heG5vZGUgPSBlLnRhcmdldC52YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGltZXJbJ3VwZGF0ZVhNbDEnXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdC8vIHVwZGF0aW5nIHRoZSBhdHRyaWJ1dGUgdmFsdWVzXHJcblx0XHRcdG5ld1htbC5zbXhtbC5tYXRjaGxpc3QuX2xpc3RoZWFkaW5nMSA9IHN0YXRlLmxpc3RoZWFkaW5nMTtcclxuXHRcdFx0bmV3WG1sLnNteG1sLm1hdGNobGlzdC5fbGlzdGhlYWRpbmcyID0gc3RhdGUubGlzdGhlYWRpbmcyO1xyXG5cdFx0XHRpZiAoc3RhdGUubWF4bm9kZSkge1xyXG5cdFx0XHRcdG5ld1htbC5zbXhtbC5tYXRjaGxpc3QuX21heF9ub2RlID0gc3RhdGUubWF4bm9kZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBkZWxldGluZyBtYXhfbm9kZSBpZiBpdCBpcyBub3QgaW4gdXNlXHJcblx0XHRcdFx0ZGVsZXRlIG5ld1htbC5zbXhtbC5tYXRjaGxpc3QuX21heF9ub2RlO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHVwZGF0ZSBhbmQgc3RvcmUgdGhlIHhtbCBcclxuXHRcdFx0Z2V0Q2hpbGRYbWwoSlNPTlRvWE1MKG5ld1htbCkpO1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXJbJ3VwZGF0ZVhNbDEnXSk7XHJcblx0XHR9LCAyMDApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyB3aGVuZXZlciBhZGQgYnV0dG9uIGlzIGNsaWNrZWRcclxuXHRmdW5jdGlvbiB1cGRhdGVDRGF0YSgpIHtcclxuXHRcdC8vdmFyIHJvd0luRmlyc3RDb2x1bW4gPSBqUXVlcnkoXCIjbWF0Y2hMaXN0QXJlYSBbY2xhc3MqPSd0ZXh0YXJlYV8xJ11cIikubGVuZ3RoO1xyXG5cdFx0dmFyIHJvd0luRmlyc3RDb2x1bW4gPSBBSS5zZWxlY3RBbGwoXCIjbWF0Y2hMaXN0QXJlYSBbY2xhc3MqPSd0ZXh0YXJlYV8xJ11cIikubGVuZ3RoO1xyXG5cdFx0XHJcblx0XHQvL3ZhciByb3dJblNlY29uZkNvbHVtbiA9IGpRdWVyeShcIiNtYXRjaExpc3RBcmVhIFtjbGFzcyo9J3RleHRhcmVhXzInXVwiKS5sZW5ndGg7XHJcblx0XHR2YXIgcm93SW5TZWNvbmZDb2x1bW4gPSBBSS5zZWxlY3RBbGwoXCIjbWF0Y2hMaXN0QXJlYSBbY2xhc3MqPSd0ZXh0YXJlYV8yJ11cIikubGVuZ3RoO1xyXG5cdFx0aWYgKHJvd0luRmlyc3RDb2x1bW4gPiAxOSB8fCByb3dJblNlY29uZkNvbHVtbiA+IDE5KSB7XHJcblx0XHRcdEFJICYmIEFJLnNob3dtc2coJ01heGltdW0gcG9zc2libGUgb3B0aW9ucyBhcmUgMjAnKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJvdysrO1xyXG5cdFx0XHQvLyBjb252ZXJ0aW5nIHRoZSB4bWwgaW4ganNvbiB1c2luZyB0aGUgZnVuY3Rpb24gWE1MVG9KU09OIFxyXG5cdFx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XHJcblx0XHRcdC8vIHVwZGF0aW5nIHRoZSBjZGF0YVxyXG5cdFx0XHR4bWwuc214bWwubWF0Y2hsaXN0Ll9fY2RhdGEgPSB4bWwuc214bWwubWF0Y2hsaXN0Ll9fY2RhdGEgKyBgXFxuT3B0aW9uIDIgVmFsdWUgb2Ygcm93ICR7cm93fVtPcHRpb24gMSB2YWx1ZSBvZiByb3cgJHtyb3d9XVxcbmA7XHJcblx0XHRcdC8vIHVwZGF0ZSBhbmQgc3RvcmUgdGhlIHhtbCBcclxuXHRcdFx0Z2V0Q2hpbGRYbWwoSlNPTlRvWE1MKHhtbCkpO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBlcnIgPSBzbVZhbC52YWxpZGF0ZShlZGl0b3JTdGF0ZS5jb250ZW50X3R5cGUsIGVkaXRvclN0YXRlLml0ZW0sIGVkaXRvclN0YXRlLmNvbnRlbnRfaWNvbik7XHJcblx0XHRcdFx0c21WYWxpZGF0ZShlcnIpO1xyXG5cdFx0XHR9LCAyMDApO1xyXG5cdFx0fSBcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gb3Blbk1lZGlhRGlhbG9nKCkge1xyXG5cdFx0Ly9qUXVlcnkoXCIjbW9kYWwtbWVkaWEtdXBsb2FkXCIpLm1vZGFsKFwic2hvd1wiKTtcclxuXHRcdEFILmdldEJTKFwiI21vZGFsLW1lZGlhLXVwbG9hZFwiLCBcIk1vZGFsXCIpLnNob3coKTtcclxuXHR9XHJcblxyXG5cdFxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIGNhbGxzIG9uY2hhbmdlIG9mIHRoZSB0ZXh0YXJlYSBpbiB3aGljaCBvcHRpb24gdmFsdWUgaXMgZ2l2ZW4gaWYgaXNhbGdvIGlzIG9mZlxyXG5cdGZ1bmN0aW9uIGVkaXRDRGF0YSh2YWwxLCB2YWwyLCBpLCBlKSB7XHJcblx0XHRpZiAoIWUudGFyZ2V0LnZhbHVlKSByZXR1cm47XHJcblx0XHRpZiAoZS50YXJnZXQuaWQgPT0gXCJtYXRjaExpc3QxXCIpIHtcclxuXHRcdFx0bG9jYWxDRGF0YVtpXS52YWx1ZTEgPSBlLnRhcmdldC52YWx1ZS5yZXBsYWNlKC9cXG4vZ20sXCJcIik7XHJcblx0XHRcdC8vZm9yY2VVcGRhdGUoKTtcclxuXHRcdH0gZWxzZSBpZiAoZS50YXJnZXQuaWQgPT0gXCJtYXRjaExpc3QyXCIpIHtcclxuXHRcdFx0bG9jYWxDRGF0YVtpXS52YWx1ZTIgPSBlLnRhcmdldC52YWx1ZS5yZXBsYWNlKC9cXG4vZ20sXCJcIik7XHJcblx0XHRcdC8vZm9yY2VVcGRhdGUoKTtcclxuXHRcdH1cclxuXHRcdC8vIGNvbnZlcnRpbmcgdGhlIHhtbCB0byBqc29uIFxyXG5cdFx0bGV0IHhtbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xyXG5cdFx0dGltZXJbJ2VkaXRDZGF0YSddID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgXHJcblx0XHRcdGxldCBuZXdDRGF0YSA9IFwiXFxuXCI7XHJcblx0XHRcdC8vIGpRdWVyeShsb2NhbENEYXRhKS5lYWNoKGZ1bmN0aW9uKGkpIHsgLy8gUmVwbGFjZWRcclxuXHRcdFx0XHRsb2NhbENEYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKXtcclxuXHRcdFx0XHRuZXdDRGF0YSArPSBsb2NhbENEYXRhW2ldLnZhbHVlMStcIltcIitsb2NhbENEYXRhW2ldLnZhbHVlMitcIl1cXG5cIjtcclxuXHRcdFx0fSk7XHJcblx0XHRcdC8vIHVwZGF0aW5nIHRoZSBjZGF0YVxyXG5cdFx0XHR4bWwuc214bWwubWF0Y2hsaXN0Ll9fY2RhdGEgPSBuZXdDRGF0YTtcclxuXHRcdFx0Ly8gdXBkYXRpbmcgdGhlIHhtbFxyXG5cdFx0XHRnZXRDaGlsZFhtbChKU09OVG9YTUwoeG1sKSk7XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lclsnZWRpdENkYXRhJ10pO1xyXG5cdFx0fSwgNTAwKTtcclxuXHR9XHJcbiAgICBcclxuICAgIC8vIGZ1bmN0aW9uIGNhbGxzIG9uY2hhbmdlIG9mIHRoZSB0ZXh0YXJlYSBpbiB3aGljaCBvcHRpb24gdmFsdWUgaXMgZ2l2ZW4gaWYgaXNhbGdvIGlzIG9uXHJcblx0ZnVuY3Rpb24gZWRpdGFsZ29DRGF0YSh2YWwxLCBpLCBwbGFjZUluZGV4LCBlKSB7XHJcblx0XHRpZiAoIWUudGFyZ2V0LnZhbHVlKSByZXR1cm47XHJcblx0XHRpZiAoZS50YXJnZXQuaWQgPT0gXCJtYXRjaExpc3QxXCIpIHtcclxuXHRcdFx0bGV0IHBsYWNlaW5kZXgyID0gcGxhY2VJbmRleC5zcGxpdChcIl9cIilbMV07XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbG9jYWxDRGF0YS5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGlmICgoKGorMSkgPT0gKGkrMSkpKSB7XHJcblx0XHRcdFx0XHRsZXQgc3RyID0gbG9jYWxDRGF0YVtpXS52YWx1ZTE7XHJcblx0XHRcdFx0XHR2YXIgc3RyYXJyID0gc3RyLnNwbGl0KFwiJSVcIik7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHN0cmFyci5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoayA9PSBwbGFjZWluZGV4Mikge1xyXG5cdFx0XHRcdFx0XHRcdHN0cmFycltrXSA9IGUudGFyZ2V0LnZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHRcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRzdHJhcnIgPSBzdHJhcnIuam9pbihcIiUlXCIpO1xyXG5cdFx0XHRsb2NhbENEYXRhW2ldLnZhbHVlMSA9IHN0cmFycjtcclxuXHRcdFx0Ly9mb3JjZVVwZGF0ZSgpO1xyXG5cdFx0fSBlbHNlIGlmIChlLnRhcmdldC5pZCA9PSBcIm1hdGNoTGlzdDJcIikge1xyXG5cdFx0XHRsZXQgcGxhY2VpbmRleDIgPSBwbGFjZUluZGV4LnNwbGl0KFwiX1wiKVsxXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsb2NhbENEYXRhLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0aWYgKCgoaisxKSA9PSAoaSsxKSkpIHtcclxuXHRcdFx0XHRcdGxldCBzdHIgPSBsb2NhbENEYXRhW2ldLnZhbHVlMjtcclxuXHRcdFx0XHRcdHZhciBzdHJhcnIgPSBzdHIuc3BsaXQoXCIlJVwiKTtcclxuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc3RyYXJyLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChrID09IHBsYWNlaW5kZXgyKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyYXJyW2tdID0gZS50YXJnZXQudmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cdFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHN0cmFyciA9IHN0cmFyci5qb2luKFwiJSVcIik7XHJcblx0XHRcdGxvY2FsQ0RhdGFbaV0udmFsdWUyID0gc3RyYXJyO1xyXG5cdFx0XHQvL2ZvcmNlVXBkYXRlKCk7XHJcblx0XHR9XHJcblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XHJcblx0XHR0aW1lclsnYWxnbyddID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0bGV0IG5ld0NEYXRhID0gXCJcXG5cIjtcclxuXHRcdFx0Ly8galF1ZXJ5KGxvY2FsQ0RhdGEpLmVhY2goZnVuY3Rpb24oaSkgeyAvLyBSZXBsYWNlZFxyXG5cdFx0XHRsb2NhbENEYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKXtcclxuXHRcdFx0XHRuZXdDRGF0YSArPSBsb2NhbENEYXRhW2ldLnZhbHVlMStcIltcIitsb2NhbENEYXRhW2ldLnZhbHVlMitcIl1cXG5cIjtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YSA9IG5ld0NEYXRhO1xyXG5cdFx0XHRnZXRDaGlsZFhtbChKU09OVG9YTUwoeG1sKSk7XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lclsnYWxnbyddKTtcclxuXHRcdH0sIDUwMCk7XHRcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gZm9yIGRlbGV0aW5nIHRoZSBjdXJyZW50IG9wdGlvblxyXG5cdGZ1bmN0aW9uIHJlbW92ZUNEYXRhKGxpc3QxVmFsLCBsaXN0MlZhbCwgaWQpIHtcclxuXHRcdC8vQUguYWxlcnQoXCJjaGVja2luZ1wiKVxyXG5cdFx0c3RhdGUub3BlbkRlbGV0ZURpYWxvZyA9IHRydWU7XHJcblx0XHRzdGF0ZS5yb3dfaWQgPSBpZDtcclxuXHRcdFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGNhbGxzIHdoZW4gdGhlIHNldHRpbmcgYnRuIG9wdGlvbiBpcyBjbGlja2VkXHJcblx0ZnVuY3Rpb24gY2hhbmdlU2V0dGluZyh2YWx1ZSkge1xyXG5cdFx0bGV0IHhtbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xyXG5cdFx0Ly8gaWYgTm9ybWFsIG9wdGlvbnMgaXMgc2VsZWN0ZWRcclxuXHRcdGlmICh2YWx1ZSA9PSAyKSB7XHJcblx0XHRcdGlmIChzdGF0ZS5kcmFnX21vZGUpIHtcclxuXHRcdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fbXVsdGltYXRjaCA9IDA7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX211bHRpbWF0Y2ggPSAyO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHZhbHVlID09IDMpIHtcclxuXHRcdFx0Ly8gZm9yIHN3YXAgbGlzdFxyXG5cdFx0XHRsZXQgdGVtcEFyciA9IHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YS5zcGxpdCgnXFxuJyk7XHJcblx0XHRcdGxldCBzd2FwZWRDZGF0YSA9IFwiXCI7XHJcblx0XHRcdHRlbXBBcnIubWFwKChpdGVtcyxpKT0+e1xyXG5cdFx0XHRcdGxldCB0ZW1wTGlzdCA9IGl0ZW1zLnNwbGl0KC9cXFsoLio/KVxcXS8pO1xyXG5cdFx0XHRcdGlmICh0ZW1wTGlzdC5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRzd2FwZWRDZGF0YSArPSBgJHt0ZW1wTGlzdFsxXX1bJHt0ZW1wTGlzdFswXS50cmltKCl9XVxcbmA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhID0gc3dhcGVkQ2RhdGE7XHJcblx0XHR9XHJcblx0XHQvLyB1cGRhdGluZyBhbmQgc3RvcmluZyB0aGUgeG1sXHJcblx0XHRnZXRDaGlsZFhtbChKU09OVG9YTUwoeG1sKSk7XHJcblx0XHRoYW5kbGVNZW51Q2xvc2UoKTtcclxuICAgIH1cclxuICAgIFxyXG5cdC8vIHdoZW5ldmVyIHRoZSBpbWFnZSBpY29uIGlzIGNsaWNrZWQgdGhpcyBmdW5jdGlvbiBjYWxsc1xyXG5cdGZ1bmN0aW9uIG9wZW5JbWFnZURpYWxvZyhjbGFzc19uYW1lKSB7XHJcblx0XHRzdGF0ZS5vcGVuSW1hZ2VEaWFsb2cgPSB0cnVlO1xyXG5cdFx0c3RhdGUuaW1hZ2VDbGFzcyA9IGNsYXNzX25hbWU7XHJcblx0XHQvLyBleHRyY3RpbmcgaW1hZ2UgZGV0YWlsc1xyXG5cdFx0bGV0IGltYWdlID0ge307XHJcblxyXG5cclxuXHRcdGlmKEFILnNlbGVjdCgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykubm9kZU5hbWUpIHtcclxuXHRcdFx0aW1hZ2UubmFtZSA9IEFILnNlbGVjdCgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuZ2V0QXR0cmlidXRlKFwic3JjXCIpLnNwbGl0KCcvJykucG9wKCk7XHJcblx0XHRcdGltYWdlLmFsdCA9IEFILnNlbGVjdCgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuZ2V0QXR0cmlidXRlKFwiYWx0XCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW1hZ2UubmFtZSA9IFwiXCI7XHJcblx0XHRcdGltYWdlLmFsdCA9IFwiXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2hvdyB2YWx1ZSBpbiB0aGUgb3BlbmVkIGRhaWxvZ1xyXG5cdFx0dGltZXJbJ2ltYWdlJ10gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRBSC5zZWxlY3QoJyNNYXRjaGxpc3RJbWcnKS52YWx1ZSA9IGltYWdlLm5hbWU7XHJcblx0XHRcdEFILnNlbGVjdCgnI01hdGNobGlzdEFsdCcpLnZhbHVlID0gaW1hZ2UuYWx0O1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXJbJ2ltYWdlJ10pO1xyXG5cdFx0fSwyMDApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBjYWxscyB3aGVuIGltYWdlIGljb24gaXMgY2xpY2tlZCBhbmQgaXNfYWxnbyBpcyB0cnVlIFxyXG5cdGZ1bmN0aW9uIG9wZW5JbWFnZURpYWxvZ0FsZ28oY2xhc3NfbmFtZSwgaWRzLCBpLCBjbG5hbWUpIHtcclxuXHRcdHN0YXRlLm9wZW5JbWFnZURpYWxvZyA9IHRydWU7XHJcblx0XHRjbHNuYW1lID0gY2xhc3NfbmFtZTtcclxuXHRcdGluZGV4ID0gaWRzO1xyXG5cdFx0Y29sdW1uaWQgPSBpO1xyXG5cdFx0Y29sdW1ubmFtZSA9IGNsbmFtZTtcclxuXHRcclxuXHJcblx0XHRzdGF0ZS5pbWFnZUNsYXNzID0gY2xhc3NfbmFtZTtcclxuXHRcdHN0YXRlLmNsbmFtZSA9IGNsbmFtZTtcclxuXHRcdC8vIGV4dHJjdGluZyBpbWFnZSBkZXRhaWxzXHJcblx0XHRsZXQgaW1hZ2UgPSB7fTtcclxuXHRcdC8vaW1hZ2UubmFtZSA9IChqUXVlcnkoJy4nK2NsYXNzX25hbWUrJyArIGltZycpLmF0dHIoXCJzcmNcIikpID8galF1ZXJ5KCcuJytjbGFzc19uYW1lKycgKyBpbWcnKS5hdHRyKFwic3JjXCIpLnNwbGl0KCcvJykucG9wKCkgOiBcIlwiO1xyXG5cdFx0aWYoQUguc2VsZWN0KCcuJytjbGFzc19uYW1lLCcgKyBpbWcnKS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9IG51bGwpIHtcclxuXHRcdFx0aW1hZ2UubmFtZSA9IEFILnNlbGVjdCgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuZ2V0QXR0cmlidXRlKFwic3JjXCIpLnNwbGl0KCcvJykucG9wKCk7XHJcblx0XHRcdGltYWdlLmFsdCA9IEFILnNlbGVjdCgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuZ2V0QXR0cmlidXRlKFwiYWx0XCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW1hZ2UubmFtZSA9IFwiXCI7XHJcblx0XHRcdGltYWdlLmFsdCA9IFwiXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9pbWFnZS5hbHQgPSAoalF1ZXJ5KCcuJytjbGFzc19uYW1lKycgKyBpbWcnKS5hdHRyKFwiYWx0XCIpKSA/IGpRdWVyeSgnLicrY2xhc3NfbmFtZSsnICsgaW1nJykuYXR0cihcImFsdFwiKTogXCJcIjtcclxuXHJcblx0XHRcclxuXHRcdFxyXG5cdFx0Ly8gc2hvdyB2YWx1ZSBpbiB0aGUgb3BlbmVkIGRhaWxvZ1xyXG5cdFx0dGltZXJbJ2FsZ29JbWFnZSddID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0Ly9qUXVlcnkoJyNNYXRjaGxpc3RJbWcnKS52YWwoaW1hZ2UubmFtZSk7XHJcblx0XHRcdEFILnNlbGVjdCgnI01hdGNobGlzdEltZycpLnZhbHVlID0gaW1hZ2UubmFtZTtcclxuXHJcblx0XHRcdC8valF1ZXJ5KCcjTWF0Y2hsaXN0QWx0JykudmFsKGltYWdlLmFsdCk7XHJcblx0XHRcdEFILnNlbGVjdCgnI01hdGNobGlzdEFsdCcpLnZhbHVlID0gaW1hZ2UuYWx0O1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXJbJ2FsZ29JbWFnZSddKTtcclxuXHRcdH0sNTAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvbiBjbGljayBvZiBjYW5jZWwgYnRuIG9mIGltYWdlIGRpYWxvZyB0aGlzIGZ1bmN0aW9uIGNhbGxlZFxyXG5cdGZ1bmN0aW9uIGNsb3NlSW1hZ2VEaWFsb2coKSB7XHJcblx0XHRzdGF0ZS5vcGVuSW1hZ2VEaWFsb2cgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gb24gY2xpY2sgb2YgZG9uZSBidG4gb2YgaW1hZ2UgZGlhbG9nIHRoaXMgZnVuY3Rpb24gY2FsbGVkXHJcblx0ZnVuY3Rpb24gaW5zZXJ0SW1hZ2UoKSB7XHJcblx0XHRpZiAoc3RhdGUuaXNhbGdvID09IHRydWUpIHtcdFxyXG5cdFx0XHQvLyBAcHJhZGVlcCBzaXIgOiBpbiBib3RoIGNvbmRpdGlvbiBzYW1lIGNvZGUgaXMgd3JpdHRlbiBjYW4gd2UgbWFrZSBpdCBpbiBvbmVcclxuXHRcdFx0aWYgKChzdGF0ZS5jbG5hbWUgPT0gXCJtYXRjaGxpc3QyXCIpIHx8IChzdGF0ZS5jbG5hbWUgPT0gXCJtYXRjaGxpc3QxXCIpKSB7XHJcblx0XHRcdFx0bGV0IGltYWdlID0ge307XHJcblx0XHRcdFx0Ly8gZ2V0dGluZyB0aGUgaW1hZ2UgaW5mb3JtYXRpb25cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpbWFnZS5uYW1lID0gQUguc2VsZWN0KFwiI01hdGNobGlzdEltZ1wiKS52YWx1ZTtcclxuXHRcdFx0XHRpbWFnZS5hbHQgPSBBSC5zZWxlY3QoJyNNYXRjaGxpc3RBbHQnKS52YWx1ZTtcclxuXHRcdFx0XHRpbWFnZS5vbGRWYWx1ZSA9IEFILnNlbGVjdCgnLicrc3RhdGUuaW1hZ2VDbGFzcykudmFsdWU7XHJcblx0XHRcdFx0c3RhdGUub3BlbkltYWdlRGlhbG9nID0gZmFsc2U7XHJcblx0XHRcdFx0Ly8gcmVwbGFjZSB3aXRoIG5ldyB2YWx1ZSBpbiB0aGUgeG1sXHJcblx0XHRcdFx0aW1hZ2UubmV3VmFsdWUgPSBzdGF0ZS54bWwucmVwbGFjZShpbWFnZS5vbGRWYWx1ZSwnKicraW1hZ2UubmFtZSsnIyMnK2ltYWdlLmFsdCk7XHJcblx0XHRcdFx0Ly8gdXBkYXRlcyB0aGUgeG1sXHJcblx0XHRcdFx0Z2V0Q2hpbGRYbWwoaW1hZ2UubmV3VmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBmaW5kaW5nIHRoZSBjZGF0YVxyXG5cdFx0XHRsZXQgY2RhdGFBcnIgPSAoL1xcPFxcIVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXFxdXFxdXFw+L2dpKS5leGVjKHN0YXRlLnhtbCk7XHJcblx0XHRcdGxldCBjZGF0YSA9IFwiXCI7XHJcblx0XHRcdGxldCBrZXlJbmRleCA9IHBhcnNlSW50KChzdGF0ZS5pbWFnZUNsYXNzKS5tYXRjaCgvXFxkKyQvZykpO1xyXG5cdFx0XHRsZXQgaW1hZ2UgPSB7fTtcclxuXHRcdFx0Ly8gZ2V0dGluZyBpbWFnZSBpbmZvcm1hdGlvblxyXG5cdFx0XHQvL2ltYWdlLm5hbWUgPSBqUXVlcnkoJyNNYXRjaGxpc3RJbWcnKS52YWwoKTtcclxuXHRcdFx0aW1hZ2UubmFtZSA9IEFILnNlbGVjdChcIiNNYXRjaGxpc3RJbWdcIikudmFsdWU7XHJcblx0XHRcdC8vaW1hZ2UuYWx0ID0galF1ZXJ5KCcjTWF0Y2hsaXN0QWx0JykudmFsKCk7XHJcblx0XHRcdGltYWdlLmFsdCA9IEFILnNlbGVjdCgnI01hdGNobGlzdEFsdCcpLnZhbHVlO1xyXG5cdFx0XHQvL2ltYWdlLm9sZFZhbHVlID0galF1ZXJ5KCcuJytzdGF0ZS5pbWFnZUNsYXNzKS52YWwoKTtcclxuXHRcdFx0aW1hZ2Uub2xkVmFsdWUgPSBBSC5zZWxlY3QoJy4nK3N0YXRlLmltYWdlQ2xhc3MpLnZhbHVlO1xyXG5cdFx0XHRzdGF0ZS5vcGVuSW1hZ2VEaWFsb2cgPSBmYWxzZTtcclxuXHRcdFx0aWYgKGNkYXRhQXJyKSB7XHJcblx0XHRcdFx0Y2RhdGEgPSBjZGF0YUFyclsxXTtcclxuXHRcdFx0XHQvLyByZXBsYWNpbmcgdHdvIG5ld2xpbmVzIHdpdGggc2luZ2xpbmUgbmV3bGluZSBhbmQgc3BsaXRpbmcgaXQgd2l0aCBuZXdsaW5lXHJcblx0XHRcdFx0Y2RhdGEgPSAoY2RhdGEucmVwbGFjZShcIlxcblxcblwiLFwiXFxuXCIpKS50cmltKCk7XHJcblx0XHRcdFx0Y2RhdGFBcnIgPSBjZGF0YS5zcGxpdChcIlxcblwiKTtcclxuXHRcdFx0XHQvLyBhZGRpbmcgbmV3IGltYWdlIGRldGFpbHNcclxuXHRcdFx0XHRjZGF0YUFycltrZXlJbmRleF0gPSBjZGF0YUFycltrZXlJbmRleF0ucmVwbGFjZShpbWFnZS5vbGRWYWx1ZSwnKicraW1hZ2UubmFtZSsnIyMnK2ltYWdlLmFsdCk7XHJcblx0XHRcdFx0Ly8gam9pbiBjZGF0YUFyciB3aXRoIG5lZWxpbmVcclxuXHRcdFx0XHRjZGF0YSA9IGNkYXRhQXJyLmpvaW4oXCJcXG5cIik7XHJcblx0XHRcdFx0Ly8gcmVwbGFjZSB0aGUgY2RhdGEgd2l0aCBuZXcgdmFsdWVcclxuXHRcdFx0XHRpbWFnZS5uZXdWYWx1ZSA9IHhtbC5yZXBsYWNlKC9cXDxcXCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF1cXD4vZ2ksXCI8IVtDREFUQVtcXG5cIitjZGF0YStcIlxcbl1dPlwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBhZGRpbmcgbmV3IGltYWdlIGRldGFpbHNcclxuXHRcdFx0XHRpbWFnZS5uZXdWYWx1ZSA9IHhtbC5yZXBsYWNlKGltYWdlLm9sZFZhbHVlLCcqJytpbWFnZS5uYW1lKycjIycraW1hZ2UuYWx0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIHhtbFxyXG5cdFx0XHRnZXRDaGlsZFhtbChpbWFnZS5uZXdWYWx1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG4gICAgXHJcbiAgICAvLyBjYWxsZWQgd2hlbiBhbGdvcml0aG1pYyBjaGVja2JveCBzdGF0ZSBpcyBjaGFuZ2VkIChvbiBjbGljaylcclxuXHRmdW5jdGlvbiBjaGFuZ2Vpc2FsZ28oZSkge1xyXG5cdFx0XHJcblx0XHQvLyBjb252ZXJ0IHhtbCB0byBqc29uXHJcblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XHJcblx0XHRzdGF0ZS5pc2FsZ28gPSBlLnRhcmdldC5jaGVja2VkO1xyXG5cdFx0Ly8gaWYgY2hlY2tib3ggaXMgY2hlY2tlZCBcclxuXHRcdC8vIGlmIChlLnRhcmdldC5jaGVja2VkKSB7XHJcblx0XHQvLyBcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX2lzX2FsZ28gPSB0cnVlOyBcclxuXHRcdC8vIH0gZWxzZSB7XHJcblx0XHQvLyBcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX2lzX2FsZ28gPSBmYWxzZTtcclxuXHRcdC8vIH1cclxuXHRcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX2lzX2FsZ28gPSBlLnRhcmdldC5jaGVja2VkO1xyXG5cdFx0Ly8gdXBkYXRlcyB0aGUgeG1sXHJcblx0XHRnZXRDaGlsZFhtbChKU09OVG9YTUwoeG1sKSk7XHJcblx0fVxyXG5cclxuICAgIC8vIG9uIGNsaWNrIG9mIGRlbGV0ZSBpY29uIHdoaWNoIGlzIGFkanVzZW50IHRvIHRoZSBvcHRpb24gYnRuIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXHJcblx0ZnVuY3Rpb24gcmVtb3ZldGV4dGJveChpZHMsIHBsYWNlSW5kZXgsIHRlc3QsIGksIGUpIHtcclxuXHRcdGlmICh0ZXN0ID09IFwibWF0Y2hsaXN0MVwiKSB7XHJcblx0XHRcdHZhciBzdHJhcnI7XHJcblx0XHRcdGxldCBwbGFjZWluZGV4MiA9IHBsYWNlSW5kZXguc3BsaXQoXCJfXCIpWzFdO1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxvY2FsQ0RhdGEubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoKChqKzEpID09IChpKzEpKSkge1xyXG5cdFx0XHRcdFx0bGV0IHN0ciA9IGxvY2FsQ0RhdGFbaV0udmFsdWUxO1xyXG5cdFx0XHRcdFx0c3RyYXJyID0gc3RyLnNwbGl0KFwiJSVcIik7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHN0cmFyci5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoayA9PSBwbGFjZWluZGV4Mikge1xyXG5cdFx0XHRcdFx0XHRcdHN0cmFyci5zcGxpY2UoaywgMSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cdFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHN0cmFyciA9IHN0cmFyci5qb2luKFwiJSVcIik7XHJcblx0XHRcdGxvY2FsQ0RhdGFbaV0udmFsdWUxID0gc3RyYXJyO1xyXG5cdFx0XHRpZiAobG9jYWxDRGF0YVtpXS52YWx1ZTEgPT0gJycgfHwgbG9jYWxDRGF0YVtpXS52YWx1ZTEgPT0gJ3VuZGVmaW5lZCcgKSB7XHJcblx0XHRcdFx0bG9jYWxDRGF0YVtpXS52YWx1ZTEgPSAnaW5zZXJ0IHZhbHVlJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHRlc3QgPT0gXCJtYXRjaGxpc3QyXCIpIHtcclxuXHRcdFx0dmFyIHN0cmFycjtcclxuXHRcdFx0bGV0IHBsYWNlaW5kZXgyID0gcGxhY2VJbmRleC5zcGxpdChcIl9cIilbMV07XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbG9jYWxDRGF0YS5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGlmICgoKGorMSkgPT0gKGkrMSkpKSB7XHJcblx0XHRcdFx0XHRsZXQgc3RyID0gbG9jYWxDRGF0YVtpXS52YWx1ZTI7XHJcblx0XHRcdFx0XHRzdHJhcnIgPSBzdHIuc3BsaXQoXCIlJVwiKTtcclxuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc3RyYXJyLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChrID09IHBsYWNlaW5kZXgyKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyYXJyLnNwbGljZShrLCAxKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVx0XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0c3RyYXJyID0gc3RyYXJyLmpvaW4oXCIlJVwiKTtcclxuXHRcdFx0bG9jYWxDRGF0YVtpXS52YWx1ZTIgPSBzdHJhcnI7XHJcblx0XHRcdGlmIChsb2NhbENEYXRhW2ldLnZhbHVlMiA9PSAnJyB8fCBsb2NhbENEYXRhW2ldLnZhbHVlMiA9PSAndW5kZWZpbmVkJyApIHtcclxuXHRcdFx0XHRsb2NhbENEYXRhW2ldLnZhbHVlMiA9ICdpbnNlcnQgdmFsdWUnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XHJcblx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRsZXQgbmV3Q0RhdGEgPSBcIlxcblwiO1xyXG5cdFx0XHQvL2pRdWVyeShsb2NhbENEYXRhKS5lYWNoKGZ1bmN0aW9uKGkpIHsgLy8gUmVwbGFjZWRcclxuXHRcdFx0bG9jYWxDRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsaSkge1xyXG5cdFx0XHRcdG5ld0NEYXRhICs9IGxvY2FsQ0RhdGFbaV0udmFsdWUxK1wiW1wiK2xvY2FsQ0RhdGFbaV0udmFsdWUyK1wiXVxcblwiO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhID0gbmV3Q0RhdGE7XHJcblx0XHRcdGdldENoaWxkWG1sKEpTT05Ub1hNTCh4bWwpKTtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHRcdH0sIDUwMCk7XHJcblx0XHRzdGF0ZS5kaXIgPSAhc3RhdGUuZGlyO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBhZGRMaXN0SXRlbShpbmRleCkge1xyXG5cdFx0Ly8gY29udmVydCB4bWwgdG8ganNvbiBcclxuXHRcdGxldCB4bWwgPSBYTUxUb0pTT04oc3RhdGUueG1sKTtcclxuXHRcdC8vIHNwbGl0dGluZyBjZGF0YSB3aXRoIG5ld2xpbmUgYW5kIHN0b3JyaW5nIGl0IGluIHZhcmlhYmxlIG5ld0FyclxyXG5cdFx0bGV0IG5ld0FyciA9IHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YS5zcGxpdCgnXFxuJyk7XHJcblx0XHRpZiAobmV3QXJyWyhuZXdBcnIubGVuZ3RoIC0gMSldID09IFwiXCIpIHtcclxuXHRcdFx0bmV3QXJyLnBvcCgpO1xyXG5cdFx0XHRuZXdBcnIudW5zaGlmdChcIlwiKTtcclxuXHRcdH0gXHJcblx0XHRpZiAoKG5ld0FyclswXSA9PSBcIlwiKSAmJiAobmV3QXJyWzFdID09IFwiXCIpKSB7XHJcblx0XHRcdG5ld0Fyci5zaGlmdCgpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gZ2V0dG5nIHRoZSBpbmRleCBvZiB0aGUgb3B0aW9uIFxyXG5cdFx0bGV0IHN0ciA9IG5ld0FycltwYXJzZUludChpbmRleCsxKV07XHJcblx0XHQvLyBleHRyYWN0aW5nIHZhbHVlIDFcclxuXHRcdGxldCB2YWx1ZTEgPSBzdHIucmVwbGFjZShzdHIubWF0Y2goL1xcWyguKj8pXFxdL2cpLFwiXCIpLnJlcGxhY2UoL15cXHMrL2csIFwiXCIpO1xyXG5cdFx0bGV0IHZhbHVlMiA9IHN0ci5tYXRjaCgvXFxbKC4qPylcXF0vZylbMF07XHJcblx0XHR2YWx1ZTIgPSB2YWx1ZTIuc3Vic3RyaW5nKDEsIHZhbHVlMi5sZW5ndGgtMSk7XHJcblx0XHQvLyBleHRyYWN0aW5nIHZhbHVlIDJcclxuXHRcdHZhbHVlMiA9ICdbJyt2YWx1ZTIrJ10nO1xyXG5cdFx0Ly8gYWRkaW5nIG5ldyBvcHRpb24gdmFsdWVcclxuXHRcdHZhbHVlMSA9IHZhbHVlMSsnJSVPcHRpb24gMiBWYWx1ZSc7XHJcblx0XHQvLyBzdG9yZSB0aGUgZmluYWwgc3RyaW5nIGF0IHRoYXQgaW5kZXhcclxuXHRcdGxldCBmU3RyID0gdmFsdWUxK3ZhbHVlMjtcclxuXHRcdG5ld0FycltwYXJzZUludChpbmRleCsxKV0gPSBmU3RyO1xyXG5cdFx0Ly8gam9pbiB0aGUgYXJyYXlcclxuXHRcdG5ld0FyciA9IG5ld0Fyci5qb2luKCdcXG4nKTtcclxuXHRcdC8vIHVwZGF0ZSB0aGUgY2RhdGFcclxuXHRcdHhtbC5zbXhtbC5tYXRjaGxpc3QuX19jZGF0YSA9IG5ld0FycjtcclxuXHRcdC8vIHN0b3JlcyBhbmQgdXBkYXRlIHRoZSB4bWwgdXNpbmcgdGhlIGZ1bmN0aW9uIGdldENoaWxkWG1sXHJcblx0XHRnZXRDaGlsZFhtbChKU09OVG9YTUwoeG1sKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIGNhbGxlZCB3aGVuIGRyb3Bkb3duIGlzIG9wZW4gXHJcblx0ZnVuY3Rpb24gaGFuZGxlTWVudU9wZW4oZXZlbnQpIHtcclxuXHRcdHN0YXRlLmFuY2hvckVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gY2FsbGVkIHdoZW4gZHJvcGRvd24gaXMgY2xvc2UgXHJcblx0ZnVuY3Rpb24gaGFuZGxlTWVudUNsb3NlKCkge1xyXG5cdFx0c3RhdGUuYW5jaG9yRWwgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiByZW1vdmVSb3coKSB7XHJcblx0XHRcclxuXHRcdHN0YXRlLm9wZW5EZWxldGVEaWFsb2cgPSBmYWxzZTtcclxuXHRcdFxyXG5cdFx0bGV0IG5vdF9tYXRjaGVkX2RhdGEgPSBcIlwiO1xyXG5cdFx0Ly8gc3RvcmluZyB0aGUgdmFsdWVzIG9mIHRoZSBvcHRpb24gaW4gYSBleGNlcHQgdGhlIGRlbGV0ZWQgb25lXHJcblx0XHQvLyBqUXVlcnkobG9jYWxDRGF0YSkuZWFjaChmdW5jdGlvbihpbmRleF9ubykgeyAvLyBSZXBsYWNlZFxyXG5cdFx0bG9jYWxDRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsaW5kZXhfbm8pIHtcclxuXHRcdFx0Ly8gY2hlY2sgbWluIG5vIG9mIG9wdGlvbnNcclxuXHRcdFx0aWYgKGxvY2FsQ0RhdGEubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdGlmIChsb2NhbENEYXRhW2luZGV4X25vXS5pZCAhPSBzdGF0ZS5yb3dfaWQpIHtcclxuXHRcdFx0XHRcdG5vdF9tYXRjaGVkX2RhdGEgKz0gbG9jYWxDRGF0YVtpbmRleF9ub10udmFsdWUxICsgXCJbXCIgKyBsb2NhbENEYXRhW2luZGV4X25vXS52YWx1ZTIgKyBcIl1cXG5cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0QUkuc2hvd21zZygnQXQgbGVhc3Qgb25lIGZpZWxkIHJlcXVpcmVkLicpO1xyXG5cdFx0XHRcdG5vdF9tYXRjaGVkX2RhdGEgKz0gbG9jYWxDRGF0YVtpbmRleF9ub10udmFsdWUxICsgXCJbXCIgKyBsb2NhbENEYXRhW2luZGV4X25vXS52YWx1ZTIgKyBcIl1cXG5cIjtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHQvLyBjb252ZXJ0IHhtbCB0byBqc29uXHJcblx0XHRsZXQgeG1sID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XHJcblx0XHQvLyB1cGRhdGluZyBjZGF0YVxyXG5cdFx0eG1sLnNteG1sLm1hdGNobGlzdC5fX2NkYXRhID0gJ1xcbicgKyBub3RfbWF0Y2hlZF9kYXRhO1xyXG5cdFx0Ly8gdXBkYXRpbmcgdGhlIHhtbFxyXG5cdFx0Z2V0Q2hpbGRYbWwoSlNPTlRvWE1MKHhtbCkpO1xyXG5cdH1cclxuXHRcclxuXHRcclxuICAgIFxyXG5cclxuXHQvLyB0ZW1wZGF0YTEgPSBbXTtcclxuXHQvLyB0ZW1wZGF0YTIgPSBbXTtcclxuXHJcblx0Ly8gJDp7XHJcblx0Ly8gXHRsb2NhbENEYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKXtcclxuXHQvLyBcdFx0aWYoc3RhdGUuaXNhbGdvID09IHRydWUpIHtcclxuXHQvLyBcdFx0XHR0ZW1wZGF0YTEgPSBkYXRhLnZhbHVlMS5zcGxpdChcIiUlXCIpXHJcbiAgICAvLyAgICAgICAgIFx0dGVtcGRhdGEyID0gZGF0YS52YWx1ZTIuc3BsaXQoXCIlJVwiKVxyXG5cdC8vIFx0XHR9XHJcblx0Ly8gXHR9KVxyXG5cdC8vIH1cclxuXHJcblxyXG48L3NjcmlwdD5cclxuXHJcbjxtYWluPlxyXG4gICAgPGNlbnRlcj5cclxuICAgICAgICA8ZGl2IGlkPVwiZml4ZWRNYXRjaExpc3RcIiBjbGFzcz1cImJvcmRlciBoLWF1dG8gZndpZHRoXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYi0xXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm9yZGVyLWJvdHRvbSB3LTEwMCBkLWlubGluZS1ibG9jayBwYi0wIHB4LTMgcHQtM1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXggcm93XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNiBwci0xXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwibGlzdGhlYWRpbmcxXCIgY2xhc3M9XCJtYi0wIGZsb2F0LWxlZnRcIj57bC5tYXRjaGxpc3RfaGVhZGluZzF9PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwibGlzdGhlYWRpbmcxXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBvbjpjaGFuZ2U9e3VwZGF0ZVhtbH0gdmFsdWU9e3N0YXRlLmxpc3RoZWFkaW5nMX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNiBwbC0xXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwibGlzdGhlYWRpbmcyXCIgY2xhc3M9XCJtYi0wIGZsb2F0LWxlZnRcIj57bC5tYXRjaGxpc3RfaGVhZGluZzJ9PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwibGlzdGhlYWRpbmcyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBvbjpjaGFuZ2U9e3VwZGF0ZVhtbH0gdmFsdWU9e3N0YXRlLmxpc3RoZWFkaW5nMn0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCB3aWR0aDEgZmxvYXQtbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaCBmbG9hdC1sZWZ0IHctc20gbXItMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cIm1heG5vZGVcIiBjbGFzcz1cIm1iLTAgZmxvYXQtbGVmdFwiPk1heG5vZGU6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwibWF4bm9kZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcGxhY2Vob2xkZXI9XCJFbnRlciBudW1iZXIgb25seSAxIHRvIDZcIiBvbjpjaGFuZ2U9e3VwZGF0ZVhtbH0gdmFsdWU9e3N0YXRlLm1heG5vZGV9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTIgZC1mbGV4XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDaGVja2JveFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17c3RhdGUuZHJhZ19tb2RlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7KGUpPT57Y2hhbmdlU2V0dGluZyhcIjJcIixlKX19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cImlzRHJhZ0Ryb3BcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJwcmltYXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcdCAgICAgICAgICAgIHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmU7cmlnaHQ6MTBweDtcIj4gXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICBEcmFnICYgRHJvcDwvQ2hlY2tib3g+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrID0geyhlKT0+e2NoYW5nZVNldHRpbmcoXCIzXCIsZSl9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJpc1N3YXBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJwcmltYXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlN3YXAgTGlzdDwvQ2hlY2tib3g+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHsoc3RhdGUuaXNhbGdvID09IHRydWUgPyB0cnVlIDogZmFsc2UpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7Y2hhbmdlaXNhbGdvfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB7XCJpc2FsZ29cIn0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHtcImlzYWxnb1wifVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJwcmltYXJ5XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPkFsZ29yaXRobWljIDwvQ2hlY2tib3g+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJtYXRjaExpc3RBcmVhXCIgY2xhc3M9XCJyb3ctZmx1aWQgcC0yIGNsZWFyLWJvdGhcIj5cclxuXHRcdFx0XHRcclxuICAgICAgICAgICAgICAgIHsjZWFjaCBsb2NhbENEYXRhIGFzIGRhdGEsIGl9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5pc2FsZ28gPT09IHRydWV9XHJcblx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImgtaW1wXCI+XHJcblx0XHRcdFx0XHRcdFx0XHR7dGVtcGRhdGExID0gZGF0YS52YWx1ZTEuc3BsaXQoXCIlJVwiKX1cclxuXHRcdFx0XHRcdFx0XHRcdHt0ZW1wZGF0YTIgPSBkYXRhLnZhbHVlMi5zcGxpdChcIiUlXCIpfVxyXG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBtYi0yXCIgZGlyPXtzdGF0ZS5kaXJ9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtaW5saW5lLWJsb2NrIGNsZWFyLWJvdGggcG9pbnRlciBsaWdodC1jeWFuLWJnIG14LTAgbXktMSBwLTIgd2lkdGgxMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbG9hdC1sZWZ0IGNsZWFyLWJvdGhcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCB0ZW1wZGF0YTIgYXMgdGVtcCwgan1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInB1bGwtbGVmdCB3b3JkX2JyZWFrIHdpZHRoMjAwIHAtMSBtYXhfd2lkdGhfMzAwXCIgc3R5bGU9eydib3JkZXItcmFkaXVzOjNweDsnfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSByb3dzPVwiM1wiIGNvbHM9XCIyMFwiIHN0eWxlPXtcInJlc2l6ZTpub25lO1wifSBjbGFzcz17KHRlbXAuY2hhckF0KDApID09IFwiKlwiKSA/IFwiaCBmb3JtLWNvbnRyb2wgdGV4dGFyZWFfMl9cIitpK1wiX1wiK2ogOiBcImZvcm0tY29udHJvbCB0ZXh0YXJlYV8yX1wiK2krXCJfXCIran0gaWQ9XCJtYXRjaExpc3QyXCIgb246Y2hhbmdlID0geyhlKT0+e2VkaXRhbGdvQ0RhdGEodGVtcCxpLGkrJ18nK2osZSl9fSB2YWx1ZT17dGVtcH0vPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiB0ZW1wLmNoYXJBdCgwKSA9PSBcIipcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwiYXV0aG9yaW5nSW1hZ2VcIiBzcmM9e1wiLy9zMy5hbWF6b25hd3MuY29tL2ppZ3lhYXNhX2NvbnRlbnRfc3RhdGljL1wiK3RlbXAuc3Vic3RyKDEpLnNwbGl0KFwiIyNcIilbMF19IGFsdD17KHRlbXAuc3BsaXQoXCIjI1wiKVsxXSkgPyB0ZW1wLnNwbGl0KFwiIyNcIilbMV0gOm51bGx9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHRlbXAuY2hhckF0KDApID09IFwiKlwifSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWNvbW9vbi1jbG9zZS0yIHM0IGltYWdlX2RlbGV0ZVwiIGRhdGEtYnMtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtYnMtcGxhY2VtZW50PVwicmlnaHRcIiB0aXRsZT1cIkRlbGV0ZSBJbWFnZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJkLWJsb2NrIGJ0biBidG4tb3V0bGluZS1wcmltYXJ5IGJ0bi1zbSBlZGl0X2J0biBiZy13aGl0ZSBtYi0xXCIgb246Y2xpY2s9eyhlKT0+e29wZW5JbWFnZURpYWxvZ0FsZ28oXCJ0ZXh0YXJlYV8yX1wiK2krXCJfXCIraixpK1wiX1wiK2osaSxcIm1hdGNobGlzdDJcIixlKX19PjxzcGFuIGNsYXNzPVwiaWNvbW9vbi1pbWFnZXMgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBwdC1zbTEgcGItc20xXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiQWRkIEltYWdlXCI+PC9zcGFuPjwvYnV0dG9uPlx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1wcmltYXJ5IGJ0bi1zbSBlZGl0X2J0biB0ZXh0ZGVsIGJnLXdoaXRlXCIgb246Y2xpY2s9eyhlKT0+e3JlbW92ZXRleHRib3goXCJ0ZXh0YXJlYV8yX1wiK2krXCJfXCIraixpK1wiX1wiK2osXCJtYXRjaGxpc3QyXCIsaSxlKX19IHN0eWxlPXsgc3RhdGUuaXNhbGdvID8geyBkaXNwbGF5OidibG9jayd9IDoge2Rpc3BsYXkgOiAnbm9uZSd9IH0+PHNwYW4gY2xhc3M9XCJpY29tb29uLTI0cHgtZGVsZXRlLTEgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBwdC1zbTEgcGItc20xXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiRGVsZXRlXCI+PC9zcGFuPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbG9hdC1sZWZ0IG1zLTFcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz17XCJhZGRfYnV0dG9uIHB4LTEgYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGJnLXdoaXRlIGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXIgcHItMiBcIitcImxpc3RpdGVtXCIraX0gb246Y2xpY2s9e2FkZExpc3RJdGVtLmJpbmQodGhpcyxpKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZvbnQyNFwiPiYjNDM7PC9zcGFuPkFkZCBpdGVtPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLXJpZ2h0XCI+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggdGVtcGRhdGExIGFzIHRlbXAxLCBrfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHVsbC1sZWZ0IHdvcmRfYnJlYWsgd2lkdGgyMDAgcC0xIG1heF93aWR0aF8zMDBcIiBzdHlsZT17XCJib3JkZXItcmFkaXVzOjNweDtcIn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgcm93cz1cIjNcIiBjb2xzPVwiMjBcIiBzdHlsZT17XCJyZXNpemU6bm9uZTtcIn0gY2xhc3M9eyh0ZW1wMS5jaGFyQXQoMCkgPT0gXCIqXCIpID8gXCJoIGZvcm0tY29udHJvbCB0ZXh0YXJlYV8xX1wiK2krXCJfXCIrayA6IFwiZm9ybS1jb250cm9sIHRleHRhcmVhXzFfXCIraStcIl9cIitrfSBpZD1cIm1hdGNoTGlzdDFcIiBvbjpjaGFuZ2U9eyhlKT0+e2VkaXRhbGdvQ0RhdGEodGVtcDEsaSxpKydfJytrLGUpfX0gdmFsdWU9e3RlbXAxfS8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHRlbXAxLmNoYXJBdCgwKSA9PSBcIipcIn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwiYXV0aG9yaW5nSW1hZ2VcIiBzcmM9e1wiLy9zMy5hbWF6b25hd3MuY29tL2ppZ3lhYXNhX2NvbnRlbnRfc3RhdGljL1wiK3RlbXAxLnN1YnN0cigxKS5zcGxpdChcIiMjXCIpWzBdfSBhbHQ9eyh0ZW1wMS5zcGxpdChcIiMjXCIpWzFdKSA/IHRlbXAxLnNwbGl0KFwiIyNcIilbMV0gOm51bGx9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHVsbC1yaWdodFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiB0ZW1wMS5jaGFyQXQoMCkgPT0gXCIqXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb21vb24tY2xvc2UtMiBzNCBpbWFnZV9kZWxldGVcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJEZWxldGUgSW1hZ2VcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImQtYmxvY2sgYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGVkaXRfYnRuIGJnLXdoaXRlIG1iLTFcIiBvbjpjbGljaz17KGUpPT57b3BlbkltYWdlRGlhbG9nQWxnbyhcInRleHRhcmVhXzFfXCIraStcIl9cIitrLGkrXCJfXCIrayxpLFwibWF0Y2hsaXN0MVwiLGUpfX0+PHNwYW4gY2xhc3M9XCJpY29tb29uLWltYWdlcyBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHB0LXNtMSBwYi1zbTFcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJBZGQgSW1hZ2VcIj48L3NwYW4+PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1wcmltYXJ5IGJ0bi1zbSBlZGl0X2J0biB0ZXh0ZGVsIGJnLXdoaXRlXCIgb246Y2xpY2s9eyhlKT0+e3JlbW92ZXRleHRib3goXCJ0ZXh0YXJlYV8yX1wiK2krXCJfXCIrayxpK1wiX1wiK2ssXCJtYXRjaGxpc3QxXCIsaSxlKX19IHN0eWxlPXsgc3RhdGUuaXNhbGdvID8gJ2Rpc3BsYXk6YmxvY2s7JyA6ICdkaXNwbGF5IDogbm9uZScgfT48c3BhbiBjbGFzcz1cImljb21vb24tMjRweC1kZWxldGUtMSBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHB0LXNtMSBwYi1zbTFcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJEZWxldGVcIj48L3NwYW4+PC9idXR0b24+IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid2lkdGgxIGZsb2F0LXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgb246Y2xpY2s9eygpPT57cmVtb3ZlQ0RhdGEoZGF0YS52YWx1ZTEsZGF0YS52YWx1ZTIsZGF0YS5pZCl9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJkZWxldGVfbWF0Y2hfbm9kZV9hdXRoIGljb21vb24gaWNvbW9vbi1uZXctMjRweC1kZWxldGUtMSBzMyBweS0xXCIgdGFiaW5kZXg9XCIwXCIgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCIgZGF0YS1icy1wbGFjZW1lbnQ9XCJyaWdodFwiIHRpdGxlPVwiRGVsZXRlXCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBtYi0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb2ludGVyIGQtaW5saW5lLWJsb2NrIGNsZWFyLWJvdGggbGlnaHQtY3lhbi1iZyBteC0wIG15LTEgcC0yIHdpZHRoMTBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLWxlZnQgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLWxlZnQgd29yZF9icmVhayB3aWR0aDIwMCBwLTEgbWF4X3dpZHRoXzMwMFwiIHN0eWxlPXsnYm9yZGVyUmFkaXVzOjNweDsnfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIHJvd3M9XCIzXCIgY29scz1cIjIwXCIgc3R5bGU9e1wicmVzaXplOm5vbmU7XCJ9IGNsYXNzPXsoZGF0YS52YWx1ZTIuY2hhckF0KDApID09IFwiKlwiKSA/IFwiaCBmb3JtLWNvbnRyb2wgdGV4dGFyZWFfMl9cIitpIDogXCJmb3JtLWNvbnRyb2wgdGV4dGFyZWFfMl9cIitpfSBpZD1cIm1hdGNoTGlzdDJcIiBvbjpjaGFuZ2U9eyhlKT0+e2VkaXRDRGF0YShkYXRhLnZhbHVlMixkYXRhLnZhbHVlMixpLGUpfX0gdmFsdWU9e2RhdGEudmFsdWUyfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBkYXRhLnZhbHVlMi5jaGFyQXQoMCkgPT0gXCIqXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwiYXV0aG9yaW5nSW1hZ2VcIiBzcmM9e1wiLy9zMy5hbWF6b25hd3MuY29tL2ppZ3lhYXNhX2NvbnRlbnRfc3RhdGljL1wiK2RhdGEudmFsdWUyLnN1YnN0cigxKS5zcGxpdChcIiMjXCIpWzBdLnNwbGl0KCclJScpWzBdfSBhbHQ9eyhkYXRhLnZhbHVlMi5zcGxpdChcIiMjXCIpWzFdKSA/IGRhdGEudmFsdWUyLnNwbGl0KFwiIyNcIilbMV0gOm51bGx9IC8+IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInB1bGwtcmlnaHQgbXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBkYXRhLnZhbHVlMi5jaGFyQXQoMCkgPT0gXCIqXCJ9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb21vb24tY2xvc2UtMiBzNCBpbWFnZV9kZWxldGVcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJEZWxldGUgSW1hZ2VcIj48L2Rpdj4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGVkaXRfYnRuIGJnLXdoaXRlXCIgb246Y2xpY2s9eygpPT57b3BlbkltYWdlRGlhbG9nKFwidGV4dGFyZWFfMl9cIitpKX19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29tb29uLWltYWdlcyBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHB0LXNtMSBwYi1zbTFcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJBZGQgSW1hZ2VcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLXJpZ2h0IGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHVsbC1sZWZ0IHdvcmRfYnJlYWsgd2lkdGgyMDAgcC0xIG1heF93aWR0aF8zMDBcIiBzdHlsZT17XCJib3JkZXItcmFkaXVzOjNweFwifX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSByb3dzPVwiM1wiIGNvbHM9XCIyMFwiIHN0eWxlPXtcInJlc2l6ZTpub25lO1wifSBjbGFzcz17KGRhdGEudmFsdWUxLmNoYXJBdCgwKSA9PSBcIipcIikgPyBcImggZm9ybS1jb250cm9sIHRleHRhcmVhXzFfXCIraSA6IFwiZm9ybS1jb250cm9sIHRleHRhcmVhXzFfXCIraX0gaWQ9XCJtYXRjaExpc3QxXCIgb246Y2hhbmdlPXsoZSk9PntlZGl0Q0RhdGEoZGF0YS52YWx1ZTEsZGF0YS52YWx1ZTIsaSxlKX19IHZhbHVlPXtkYXRhLnZhbHVlMX0gLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZGF0YS52YWx1ZTEuY2hhckF0KDApID09IFwiKlwifVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cImF1dGhvcmluZ0ltYWdlXCIgc3JjPXtcIi8vczMuYW1hem9uYXdzLmNvbS9qaWd5YWFzYV9jb250ZW50X3N0YXRpYy9cIitkYXRhLnZhbHVlMS5zdWJzdHIoMSkuc3BsaXQoXCIjI1wiKVswXS5zcGxpdCgnJSUnKVswXX0gYWx0PXsoZGF0YS52YWx1ZTEuc3BsaXQoXCIjI1wiKVsxXSkgPyBkYXRhLnZhbHVlMS5zcGxpdChcIiMjXCIpWzFdIDpudWxsfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwdWxsLXJpZ2h0IG10XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZGF0YS52YWx1ZTEuY2hhckF0KDApID09IFwiKlwifVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb21vb24tY2xvc2UtMiBzNCBpbWFnZV9kZWxldGVcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJEZWxldGUgSW1hZ2VcIj48L2Rpdj4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGVkaXRfYnRuIGJnLXdoaXRlXCIgb246Y2xpY2s9eygpPT57b3BlbkltYWdlRGlhbG9nKFwidGV4dGFyZWFfMV9cIitpKX19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29tb29uLWltYWdlcyBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHB0LXNtMSBwYi1zbTFcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJBZGQgSW1hZ2VcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwid2lkdGgxIGZsb2F0LXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBvbjpjbGljaz17KCk9PntyZW1vdmVDRGF0YShkYXRhLnZhbHVlMSxkYXRhLnZhbHVlMixkYXRhLmlkKX19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwiaWNvbW9vbiBpY29tb29uLW5ldy0yNHB4LWRlbGV0ZS0xIHMzIGRlbGV0ZV9tYXRjaF9ub2RlIHB5LTFcIiB0YWJpbmRleD1cIjBcIiBkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLWJzLXBsYWNlbWVudD1cInJpZ2h0XCIgdGl0bGU9XCJEZWxldGVcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1sZWZ0IG1sLTIgcGItM1wiPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IFwiYWRkX25vZGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWwgPSBcIkFkZCBub2RlXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzcyA9IFwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgYnRuLXNtIGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXIgcHItbWQgYWRkX2J1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPXt1cGRhdGVDRGF0YX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb250MjRcIj4mIzQzOzwvc3Bhbj5BZGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG5cdDwvY2VudGVyPlxyXG5cdDxEaWFsb2cgYmluZDp2aXNpYmxlPXtzdGF0ZS5vcGVuSW1hZ2VEaWFsb2d9IGRpc2FibGVFbmZvcmNlRm9jdXM9e3RydWV9IHN0eWxlPXsnd2lkdGg6NjAwcHg7J30+XHJcblx0XHRcdFx0PGRpdiBzdHlsZT1cInRleHQtYWxpZ246IGxlZnQ7Zm9udC13ZWlnaHQ6Ym9sZDtcIiBjbGFzcz1cIm1iLTVcIj5cclxuXHRcdFx0XHRcdDxkaXY+QWRkIEltYWdlPC9kaXY+XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHQgICAgICAgIFx0PGRpdj5cclxuXHRcdCAgICAgICAgXHRcdDxkaXYgY2xhc3M9XCJpbWFnZURpYWxvZ1wiPlxyXG5cdFx0XHRcdCAgICAgICAgXHQ8ZGl2IGNsYXNzPVwicm93IG14LTBcIj5cclxuXHRcdFx0XHRcdFx0ICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTYgcHgtMVwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWwgZm9udC13ZWlnaHQtbm9ybWFsIG1iLTBcIiBmb3I9XCJNYXRjaGxpc3RJbWdcIj5CYWNrZ3JvdW5kIEltYWdlPC9sYWJlbD5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtbWRcIiBpZD1cIk1hdGNobGlzdEltZ1wiIHBsYWNlaG9sZGVyPVwiSW1hZ2UgdXJsXCIgLz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdCAgICAgICAgPC9kaXY+XHJcblx0XHRcdFx0XHRcdCAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02IHB4LTFcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsIGZvbnQtd2VpZ2h0LW5vcm1hbCBtYi0wXCIgZm9yPVwiTWF0Y2hsaXN0QWx0XCI+QmFja2dyb3VuZCBBbHQ8L2xhYmVsPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1tZFwiIGlkPVwiTWF0Y2hsaXN0QWx0XCIgcGxhY2Vob2xkZXI9XCJCYWNrZ3JvdW5kIGFsdCB0ZXh0XCIgLz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdCAgICAgICAgPC9kaXY+XHJcblx0XHRcdFx0XHRcdCAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02IHB4LTFcIj5cclxuXHRcdFx0XHRcdFx0ICAgIFx0XHQ8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnlcIiBvbjpjbGljaz17b3Blbk1lZGlhRGlhbG9nfT5VcGxvYWQgSW1hZ2U8L2J1dHRvbj5cclxuXHRcdFx0XHRcdFx0ICAgIFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdCAgICA8L2Rpdj5cclxuXHRcdFx0XHQgICAgICAgIDwvZGl2PlxyXG5cdFx0ICAgICAgICBcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IHNsb3Q9XCJmb290ZXJcIiBjbGFzcz1cInN2ZWx0ZUZvb3RlclwiPlxyXG5cdFx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjYW5jZWxfYnRuX3BvcCBidG4gYnRuLWxpZ2h0IGNvbG9yZ3JheTFcIiB2YXJpYW50PVwiY29udGFpbmVkXCIgb246Y2xpY2s9e2Nsb3NlSW1hZ2VEaWFsb2d9IHZhbHVlPXtsLmNhbmNlbH0gLz5cclxuXHRcdFx0XHRcdFx0XHQ8QnV0dG9uIHZhcmlhbnQ9XCJjb250YWluZWRcIiBpZD1cImNkYXRhXCIgb246Y2xpY2s9e2luc2VydEltYWdlfSBjbGFzcz1cInRleHQtd2hpdGUgYmctcHJpbWFyeVwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0RG9uZVxyXG5cdFx0XHRcdFx0XHRcdDwvQnV0dG9uPlxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L0RpYWxvZz5cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQ8RGlhbG9nXHJcblx0XHRcdFx0XHRiaW5kOnZpc2libGU9e3N0YXRlLm9wZW5EZWxldGVEaWFsb2d9XHJcblx0XHRcdFx0XHRzdHlsZT17J3dpZHRoOjUwMHB4Oyd9XHJcblx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0PGRpdiBzdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGQ7XCI+e2wuc2F2ZV9oZWFkZXJ9PC9kaXY+XHJcblx0XHRcdFx0XHQ8ZGl2PlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwicm93XCI+XHJcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiY29sLW1kLTEyXCIgc3R5bGU9eydtYXJnaW4tdG9wOjQwcHg7bWFyZ2luLWJvdHRvbTo0MHB4Oyd9PntsLmRlbF9jb25maXJtYXRpb259PC9zcGFuPlxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFxyXG5cclxuXHRcdFx0XHRcdDxkaXYgc2xvdD1cImZvb3RlclwiIGNsYXNzPVwic3ZlbHRlRm9vdGVyXCI+XHJcblx0XHRcdFx0XHRcdDxCdXR0b24gdmFyaWFudD1cImNvbnRhaW5lZFwiIG9uOmNsaWNrPXtyZW1vdmVSb3d9XHJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJiZy1wcmltYXJ5IHRleHQtd2hpdGVcIj4gWWVzIDwvQnV0dG9uPlxyXG5cdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhcmlhbnQ9XCJjb250YWluZWRcIiBvbjpjbGljaz17KCkgPT4ge3N0YXRlLm9wZW5EZWxldGVEaWFsb2cgPSBmYWxzZTt9fSBjbGFzcz1cImJ0biBidG4tbGlnaHQgY29sb3JncmF5XCIgdmFsdWU9XCJOb1wiIC8+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdDwvRGlhbG9nPlxyXG48L21haW4+XHJcbjxzdHlsZT5cclxuXHJcblx0XHJcblxyXG5cdC5jb2xvcmdyYXkge1xyXG4gICAgICAgIHdpZHRoOjU2cHg7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSwgMjA2LCAyMDYpO1xyXG4gICAgfVxyXG5cdC5jb2xvcmdyYXkxIHtcclxuXHRcdHdpZHRoOjc0cHg7XHJcblx0XHRiYWNrZ3JvdW5kOiAjRTBFMEUwO1xyXG5cdH1cclxuXHJcblx0LmZvbnQyNCB7XHJcblx0XHRmb250LXNpemU6IDIycHggIWltcG9ydGFudDtcclxuXHRcdG1hcmdpbi1yaWdodDogNXB4O1xyXG4gICAgfVxyXG5cclxuXHQuYWRkX2J1dHRvbiB7XHJcblx0XHRoZWlnaHQ6MzFweDtcclxuXHR9XHJcblxyXG5cdFxyXG48L3N0eWxlPiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF1NkJDLFVBQVUsZUFBQyxDQUFDLEFBQ0wsTUFBTSxJQUFJLENBQ1YsZ0JBQWdCLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDeEMsQ0FBQyxBQUNKLFdBQVcsZUFBQyxDQUFDLEFBQ1osTUFBTSxJQUFJLENBQ1YsVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQyxBQUVELE9BQU8sZUFBQyxDQUFDLEFBQ1IsU0FBUyxDQUFFLElBQUksQ0FBQyxVQUFVLENBQzFCLFlBQVksQ0FBRSxHQUFHLEFBQ2YsQ0FBQyxBQUVKLFdBQVcsZUFBQyxDQUFDLEFBQ1osT0FBTyxJQUFJLEFBQ1osQ0FBQyJ9 */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[63] = list[i];
	child_ctx[65] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[66] = list[i];
	child_ctx[68] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[60] = list[i];
	child_ctx[62] = i;
	return child_ctx;
}

// (713:36) <Checkbox                                          checked={state.drag_mode}                                          on:click = {(e)=>{changeSetting("2",e)}}                                          id="isDragDrop"                                          color="primary"                                         style="position:relative;right:10px;">
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Drag & Drop");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(713:36) <Checkbox                                          checked={state.drag_mode}                                          on:click = {(e)=>{changeSetting(\\\"2\\\",e)}}                                          id=\\\"isDragDrop\\\"                                          color=\\\"primary\\\"                                         style=\\\"position:relative;right:10px;\\\">",
		ctx
	});

	return block;
}

// (721:36) <Checkbox                                                                                    on:click = {(e)=>{changeSetting("3",e)}}                                          id="isSwap"                                          color="primary"                                      >
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Swap List");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(721:36) <Checkbox                                                                                    on:click = {(e)=>{changeSetting(\\\"3\\\",e)}}                                          id=\\\"isSwap\\\"                                          color=\\\"primary\\\"                                      >",
		ctx
	});

	return block;
}

// (731:36) <Checkbox                                           defaultChecked = {(state.isalgo == true ? true : false)}                                          on:click = {changeisalgo}                                           name = {"isalgo"}                                           id = {"isalgo"}                                          color="primary"                                      >
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Algorithmic");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(731:36) <Checkbox                                           defaultChecked = {(state.isalgo == true ? true : false)}                                          on:click = {changeisalgo}                                           name = {\\\"isalgo\\\"}                                           id = {\\\"isalgo\\\"}                                          color=\\\"primary\\\"                                      >",
		ctx
	});

	return block;
}

// (814:24) {:else}
function create_else_block(ctx) {
	let div8;
	let div6;
	let div2;
	let div0;
	let textarea0;
	let textarea0_style_value;
	let textarea0_class_value;
	let textarea0_value_value;
	let t0;
	let show_if_3 = /*data*/ ctx[60].value2.charAt(0) == "*";
	let div0_style_value;
	let t1;
	let div1;
	let show_if_2 = /*data*/ ctx[60].value2.charAt(0) == "*";
	let t2;
	let button0;
	let span0;
	let t3;
	let div5;
	let div3;
	let textarea1;
	let textarea1_style_value;
	let textarea1_class_value;
	let textarea1_value_value;
	let t4;
	let show_if_1 = /*data*/ ctx[60].value1.charAt(0) == "*";
	let div3_style_value;
	let t5;
	let div4;
	let show_if = /*data*/ ctx[60].value1.charAt(0) == "*";
	let t6;
	let button1;
	let span1;
	let t7;
	let div7;
	let a;
	let span2;
	let t8;
	let div8_key_value;
	let mounted;
	let dispose;

	function change_handler_2(...args) {
		return /*change_handler_2*/ ctx[32](/*data*/ ctx[60], /*i*/ ctx[62], ...args);
	}

	let if_block0 = show_if_3 && create_if_block_8(ctx);
	let if_block1 = show_if_2 && create_if_block_7(ctx);

	function click_handler_7(...args) {
		return /*click_handler_7*/ ctx[33](/*i*/ ctx[62], ...args);
	}

	function change_handler_3(...args) {
		return /*change_handler_3*/ ctx[34](/*data*/ ctx[60], /*i*/ ctx[62], ...args);
	}

	let if_block2 = show_if_1 && create_if_block_6(ctx);
	let if_block3 = show_if && create_if_block_5(ctx);

	function click_handler_8(...args) {
		return /*click_handler_8*/ ctx[35](/*i*/ ctx[62], ...args);
	}

	function click_handler_9(...args) {
		return /*click_handler_9*/ ctx[36](/*data*/ ctx[60], ...args);
	}

	const block = {
		c: function create() {
			div8 = element("div");
			div6 = element("div");
			div2 = element("div");
			div0 = element("div");
			textarea0 = element("textarea");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			button0 = element("button");
			span0 = element("span");
			t3 = space();
			div5 = element("div");
			div3 = element("div");
			textarea1 = element("textarea");
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			div4 = element("div");
			if (if_block3) if_block3.c();
			t6 = space();
			button1 = element("button");
			span1 = element("span");
			t7 = space();
			div7 = element("div");
			a = element("a");
			span2 = element("span");
			t8 = space();
			attr_dev(textarea0, "rows", "3");
			attr_dev(textarea0, "cols", "20");
			attr_dev(textarea0, "style", textarea0_style_value = "resize:none;");

			attr_dev(textarea0, "class", textarea0_class_value = "" + (null_to_empty(/*data*/ ctx[60].value2.charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62]
			: "form-control textarea_2_" + /*i*/ ctx[62]) + " svelte-1kpz00h"));

			attr_dev(textarea0, "id", "matchList2");
			textarea0.value = textarea0_value_value = /*data*/ ctx[60].value2;
			add_location(textarea0, file, 819, 48, 32985);
			attr_dev(div0, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div0, "style", div0_style_value = "borderRadius:3px;");
			add_location(div0, file, 818, 44, 32846);
			attr_dev(span0, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span0, "data-bs-toggle", "tooltip");
			attr_dev(span0, "data-bs-placement", "right");
			attr_dev(span0, "title", "Add Image");
			add_location(span0, file, 830, 52, 34373);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-outline-primary btn-sm edit_btn bg-white");
			add_location(button0, file, 829, 48, 34190);
			attr_dev(div1, "class", "pull-right mt");
			add_location(div1, file, 825, 44, 33795);
			attr_dev(div2, "class", "pull-left d-flex align-items-center");
			add_location(div2, file, 817, 40, 32751);
			attr_dev(textarea1, "rows", "3");
			attr_dev(textarea1, "cols", "20");
			attr_dev(textarea1, "style", textarea1_style_value = "resize:none;");

			attr_dev(textarea1, "class", textarea1_class_value = "" + (null_to_empty(/*data*/ ctx[60].value1.charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62]
			: "form-control textarea_1_" + /*i*/ ctx[62]) + " svelte-1kpz00h"));

			attr_dev(textarea1, "id", "matchList1");
			textarea1.value = textarea1_value_value = /*data*/ ctx[60].value1;
			add_location(textarea1, file, 837, 48, 35009);
			attr_dev(div3, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div3, "style", div3_style_value = "" + ("border-radius:3px" + "}"));
			add_location(div3, file, 836, 44, 34869);
			attr_dev(span1, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Add Image");
			add_location(span1, file, 848, 52, 36334);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm edit_btn bg-white");
			add_location(button1, file, 847, 48, 36151);
			attr_dev(div4, "class", "pull-right mt");
			add_location(div4, file, 843, 44, 35757);
			attr_dev(div5, "class", "pull-right d-flex align-items-center");
			add_location(div5, file, 835, 40, 34773);
			attr_dev(div6, "class", "pointer d-inline-block clear-both light-cyan-bg mx-0 my-1 p-2 width10");
			add_location(div6, file, 816, 36, 32626);
			attr_dev(span2, "aria-hidden", "true");
			attr_dev(span2, "class", "icomoon icomoon-new-24px-delete-1 s3 delete_match_node py-1");
			attr_dev(span2, "tabindex", "0");
			attr_dev(span2, "data-bs-toggle", "tooltip");
			attr_dev(span2, "data-bs-placement", "right");
			attr_dev(span2, "title", "Delete");
			add_location(span2, file, 855, 44, 36905);
			add_location(a, file, 854, 40, 36794);
			attr_dev(div7, "class", "width1 float-right");
			add_location(div7, file, 853, 36, 36720);
			attr_dev(div8, "key", div8_key_value = /*i*/ ctx[62]);
			attr_dev(div8, "class", "d-flex align-items-center mb-2");
			add_location(div8, file, 815, 32, 32536);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div8, anchor);
			append_dev(div8, div6);
			append_dev(div6, div2);
			append_dev(div2, div0);
			append_dev(div0, textarea0);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, button0);
			append_dev(button0, span0);
			append_dev(div6, t3);
			append_dev(div6, div5);
			append_dev(div5, div3);
			append_dev(div3, textarea1);
			append_dev(div3, t4);
			if (if_block2) if_block2.m(div3, null);
			append_dev(div5, t5);
			append_dev(div5, div4);
			if (if_block3) if_block3.m(div4, null);
			append_dev(div4, t6);
			append_dev(div4, button1);
			append_dev(button1, span1);
			append_dev(div8, t7);
			append_dev(div8, div7);
			append_dev(div7, a);
			append_dev(a, span2);
			append_dev(div8, t8);

			if (!mounted) {
				dispose = [
					listen_dev(textarea0, "change", change_handler_2, false, false, false),
					listen_dev(button0, "click", click_handler_7, false, false, false),
					listen_dev(textarea1, "change", change_handler_3, false, false, false),
					listen_dev(button1, "click", click_handler_8, false, false, false),
					listen_dev(a, "click", click_handler_9, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*localCData*/ 4 && textarea0_class_value !== (textarea0_class_value = "" + (null_to_empty(/*data*/ ctx[60].value2.charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62]
			: "form-control textarea_2_" + /*i*/ ctx[62]) + " svelte-1kpz00h"))) {
				attr_dev(textarea0, "class", textarea0_class_value);
			}

			if (dirty[0] & /*localCData*/ 4 && textarea0_value_value !== (textarea0_value_value = /*data*/ ctx[60].value2)) {
				prop_dev(textarea0, "value", textarea0_value_value);
			}

			if (dirty[0] & /*localCData*/ 4) show_if_3 = /*data*/ ctx[60].value2.charAt(0) == "*";

			if (show_if_3) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*localCData*/ 4) show_if_2 = /*data*/ ctx[60].value2.charAt(0) == "*";

			if (show_if_2) {
				if (if_block1) ; else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*localCData*/ 4 && textarea1_class_value !== (textarea1_class_value = "" + (null_to_empty(/*data*/ ctx[60].value1.charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62]
			: "form-control textarea_1_" + /*i*/ ctx[62]) + " svelte-1kpz00h"))) {
				attr_dev(textarea1, "class", textarea1_class_value);
			}

			if (dirty[0] & /*localCData*/ 4 && textarea1_value_value !== (textarea1_value_value = /*data*/ ctx[60].value1)) {
				prop_dev(textarea1, "value", textarea1_value_value);
			}

			if (dirty[0] & /*localCData*/ 4) show_if_1 = /*data*/ ctx[60].value1.charAt(0) == "*";

			if (show_if_1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_6(ctx);
					if_block2.c();
					if_block2.m(div3, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty[0] & /*localCData*/ 4) show_if = /*data*/ ctx[60].value1.charAt(0) == "*";

			if (show_if) {
				if (if_block3) ; else {
					if_block3 = create_if_block_5(ctx);
					if_block3.c();
					if_block3.m(div4, t6);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div8);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(814:24) {:else}",
		ctx
	});

	return block;
}

// (747:24) {#if state.isalgo === true}
function create_if_block(ctx) {
	let div0;
	let t0_value = (/*tempdata1*/ ctx[0] = /*data*/ ctx[60].value1.split("%%")) + "";
	let t0;
	let t1;
	let t2_value = (/*tempdata2*/ ctx[1] = /*data*/ ctx[60].value2.split("%%")) + "";
	let t2;
	let t3;
	let div6;
	let div4;
	let div2;
	let t4;
	let div1;
	let button;
	let span0;
	let t6;
	let button_class_value;
	let t7;
	let div3;
	let t8;
	let div5;
	let a;
	let span1;
	let t9;
	let div6_key_value;
	let div6_dir_value;
	let mounted;
	let dispose;
	let each_value_2 = /*tempdata2*/ ctx[1];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = /*tempdata1*/ ctx[0];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	function click_handler_6(...args) {
		return /*click_handler_6*/ ctx[31](/*data*/ ctx[60], ...args);
	}

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			div6 = element("div");
			div4 = element("div");
			div2 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t4 = space();
			div1 = element("div");
			button = element("button");
			span0 = element("span");
			span0.textContent = "+";
			t6 = text("Add item");
			t7 = space();
			div3 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t8 = space();
			div5 = element("div");
			a = element("a");
			span1 = element("span");
			t9 = space();
			attr_dev(div0, "class", "h-imp");
			add_location(div0, file, 748, 7, 25210);
			attr_dev(span0, "class", "font24 svelte-1kpz00h");
			add_location(span0, file, 781, 52, 28824);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", button_class_value = "" + (null_to_empty("add_button px-1 btn btn-outline-primary btn-sm bg-white d-flex align-items-center pr-2 " + "listitem" + /*i*/ ctx[62]) + " svelte-1kpz00h"));
			add_location(button, file, 780, 13, 28601);
			attr_dev(div1, "class", "float-left ms-1");
			add_location(div1, file, 779, 48, 28557);
			attr_dev(div2, "class", "float-left clear-both");
			add_location(div2, file, 756, 44, 25651);
			attr_dev(div3, "class", "pull-right");
			add_location(div3, file, 784, 44, 29028);
			attr_dev(div4, "class", "d-inline-block clear-both pointer light-cyan-bg mx-0 my-1 p-2 width10");
			add_location(div4, file, 755, 40, 25522);
			attr_dev(span1, "aria-hidden", "true");
			attr_dev(span1, "class", "delete_match_node_auth icomoon icomoon-new-24px-delete-1 s3 py-1");
			attr_dev(span1, "tabindex", "0");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Delete");
			add_location(span1, file, 809, 48, 32113);
			add_location(a, file, 808, 44, 31998);
			attr_dev(div5, "class", "width1 float-right");
			add_location(div5, file, 807, 40, 31920);
			attr_dev(div6, "key", div6_key_value = /*i*/ ctx[62]);
			attr_dev(div6, "class", "d-flex align-items-center mb-2");
			attr_dev(div6, "dir", div6_dir_value = /*state*/ ctx[3].dir);
			add_location(div6, file, 754, 36, 25412);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, t0);
			append_dev(div0, t1);
			append_dev(div0, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, div6, anchor);
			append_dev(div6, div4);
			append_dev(div4, div2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div2, null);
			}

			append_dev(div2, t4);
			append_dev(div2, div1);
			append_dev(div1, button);
			append_dev(button, span0);
			append_dev(button, t6);
			append_dev(div4, t7);
			append_dev(div4, div3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div3, null);
			}

			append_dev(div6, t8);
			append_dev(div6, div5);
			append_dev(div5, a);
			append_dev(a, span1);
			append_dev(div6, t9);

			if (!mounted) {
				dispose = [
					listen_dev(button, "click", /*addListItem*/ ctx[17].bind(this, /*i*/ ctx[62]), false, false, false),
					listen_dev(a, "click", click_handler_6, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*tempdata1, localCData*/ 5 && t0_value !== (t0_value = (/*tempdata1*/ ctx[0] = /*data*/ ctx[60].value1.split("%%")) + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*tempdata2, localCData*/ 6 && t2_value !== (t2_value = (/*tempdata2*/ ctx[1] = /*data*/ ctx[60].value2.split("%%")) + "")) set_data_dev(t2, t2_value);

			if (dirty[0] & /*state, removetextbox, openImageDialogAlgo, tempdata2, editalgoCData*/ 69898) {
				each_value_2 = /*tempdata2*/ ctx[1];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div2, t4);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (dirty[0] & /*state, removetextbox, openImageDialogAlgo, tempdata1, editalgoCData*/ 69897) {
				each_value_1 = /*tempdata1*/ ctx[0];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*state*/ 8 && div6_dir_value !== (div6_dir_value = /*state*/ ctx[3].dir)) {
				attr_dev(div6, "dir", div6_dir_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div6);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(747:24) {#if state.isalgo === true}",
		ctx
	});

	return block;
}

// (822:48) {#if data.value2.charAt(0) == "*"}
function create_if_block_8(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value2.substr(1).split("##")[0].split("%%")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*data*/ ctx[60].value2.split("##")[1]
			? /*data*/ ctx[60].value2.split("##")[1]
			: null);

			add_location(img, file, 822, 52, 33424);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*localCData*/ 4 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value2.substr(1).split("##")[0].split("%%")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*localCData*/ 4 && img_alt_value !== (img_alt_value = /*data*/ ctx[60].value2.split("##")[1]
			? /*data*/ ctx[60].value2.split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(822:48) {#if data.value2.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (827:48) {#if data.value2.charAt(0) == "*"}
function create_if_block_7(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 827, 52, 33961);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(827:48) {#if data.value2.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (840:48) {#if data.value1.charAt(0) == "*"}
function create_if_block_6(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value1.substr(1).split("##")[0].split("%%")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*data*/ ctx[60].value1.split("##")[1]
			? /*data*/ ctx[60].value1.split("##")[1]
			: null);

			add_location(img, file, 840, 52, 35400);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*localCData*/ 4 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*data*/ ctx[60].value1.substr(1).split("##")[0].split("%%")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*localCData*/ 4 && img_alt_value !== (img_alt_value = /*data*/ ctx[60].value1.split("##")[1]
			? /*data*/ ctx[60].value1.split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(840:48) {#if data.value1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (845:48) {#if data.value1.charAt(0) == "*"}
function create_if_block_5(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 845, 52, 35922);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(845:48) {#if data.value1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (764:64) {#if temp.charAt(0) == "*"}
function create_if_block_4(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp*/ ctx[66].substr(1).split("##")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*temp*/ ctx[66].split("##")[1]
			? /*temp*/ ctx[66].split("##")[1]
			: null);

			add_location(img, file, 764, 68, 26501);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*tempdata2*/ 2 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp*/ ctx[66].substr(1).split("##")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*tempdata2*/ 2 && img_alt_value !== (img_alt_value = /*temp*/ ctx[66].split("##")[1]
			? /*temp*/ ctx[66].split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(764:64) {#if temp.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (770:64) {#if temp.charAt(0) == "*"}
function create_if_block_3(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 770, 68, 27137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(770:64) {#if temp.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (759:48) {#each tempdata2 as temp, j}
function create_each_block_2(ctx) {
	let div2;
	let div0;
	let textarea;
	let textarea_style_value;
	let textarea_class_value;
	let textarea_value_value;
	let t0;
	let show_if_1 = /*temp*/ ctx[66].charAt(0) == "*";
	let div0_style_value;
	let t1;
	let div1;
	let show_if = /*temp*/ ctx[66].charAt(0) == "*";
	let t2;
	let button0;
	let span0;
	let t3;
	let button1;
	let span1;
	let button1_style_value;
	let mounted;
	let dispose;

	function change_handler(...args) {
		return /*change_handler*/ ctx[25](/*temp*/ ctx[66], /*i*/ ctx[62], /*j*/ ctx[68], ...args);
	}

	let if_block0 = show_if_1 && create_if_block_4(ctx);
	let if_block1 = show_if && create_if_block_3(ctx);

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[26](/*i*/ ctx[62], /*j*/ ctx[68], ...args);
	}

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[27](/*i*/ ctx[62], /*j*/ ctx[68], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			button0 = element("button");
			span0 = element("span");
			t3 = space();
			button1 = element("button");
			span1 = element("span");
			attr_dev(textarea, "rows", "3");
			attr_dev(textarea, "cols", "20");
			attr_dev(textarea, "style", textarea_style_value = "resize:none;");

			attr_dev(textarea, "class", textarea_class_value = "" + (null_to_empty(/*temp*/ ctx[66].charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]
			: "form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]) + " svelte-1kpz00h"));

			attr_dev(textarea, "id", "matchList2");
			textarea.value = textarea_value_value = /*temp*/ ctx[66];
			add_location(textarea, file, 762, 64, 26095);
			attr_dev(div0, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div0, "style", div0_style_value = "border-radius:3px;");
			add_location(div0, file, 761, 60, 25939);
			attr_dev(span0, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span0, "data-bs-toggle", "tooltip");
			attr_dev(span0, "data-bs-placement", "right");
			attr_dev(span0, "title", "Add Image");
			add_location(span0, file, 773, 242, 27641);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "d-block btn btn-outline-primary btn-sm edit_btn bg-white mb-1");
			add_location(button0, file, 773, 64, 27463);
			attr_dev(span1, "class", "icomoon-24px-delete-1 d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Delete");
			add_location(span1, file, 774, 296, 28106);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm edit_btn textdel bg-white");

			attr_dev(button1, "style", button1_style_value = /*state*/ ctx[3].isalgo
			? { display: "block" }
			: { display: "none" });

			add_location(button1, file, 774, 64, 27874);
			attr_dev(div1, "class", "pull-right");
			add_location(div1, file, 768, 60, 26949);
			attr_dev(div2, "class", "d-flex align-items-center");
			add_location(div2, file, 760, 56, 25838);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, textarea);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, button0);
			append_dev(button0, span0);
			append_dev(div1, t3);
			append_dev(div1, button1);
			append_dev(button1, span1);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", change_handler, false, false, false),
					listen_dev(button0, "click", click_handler_2, false, false, false),
					listen_dev(button1, "click", click_handler_3, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*tempdata2*/ 2 && textarea_class_value !== (textarea_class_value = "" + (null_to_empty(/*temp*/ ctx[66].charAt(0) == "*"
			? "h form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]
			: "form-control textarea_2_" + /*i*/ ctx[62] + "_" + /*j*/ ctx[68]) + " svelte-1kpz00h"))) {
				attr_dev(textarea, "class", textarea_class_value);
			}

			if (dirty[0] & /*tempdata2*/ 2 && textarea_value_value !== (textarea_value_value = /*temp*/ ctx[66])) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*tempdata2*/ 2) show_if_1 = /*temp*/ ctx[66].charAt(0) == "*";

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*tempdata2*/ 2) show_if = /*temp*/ ctx[66].charAt(0) == "*";

			if (show_if) {
				if (if_block1) ; else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*state*/ 8 && button1_style_value !== (button1_style_value = /*state*/ ctx[3].isalgo
			? { display: "block" }
			: { display: "none" })) {
				attr_dev(button1, "style", button1_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(759:48) {#each tempdata2 as temp, j}",
		ctx
	});

	return block;
}

// (792:64) {#if temp1.charAt(0) == "*"}
function create_if_block_2(ctx) {
	let img;
	let img_src_value;
	let img_alt_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "authoringImage");
			if (img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp1*/ ctx[63].substr(1).split("##")[0])) attr_dev(img, "src", img_src_value);

			attr_dev(img, "alt", img_alt_value = /*temp1*/ ctx[63].split("##")[1]
			? /*temp1*/ ctx[63].split("##")[1]
			: null);

			add_location(img, file, 792, 68, 29918);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*tempdata1*/ 1 && img.src !== (img_src_value = "//s3.amazonaws.com/jigyaasa_content_static/" + /*temp1*/ ctx[63].substr(1).split("##")[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*tempdata1*/ 1 && img_alt_value !== (img_alt_value = /*temp1*/ ctx[63].split("##")[1]
			? /*temp1*/ ctx[63].split("##")[1]
			: null)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(792:64) {#if temp1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (798:64) {#if temp1.charAt(0) == "*"}
function create_if_block_1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "icomoon-close-2 s4 image_delete");
			attr_dev(div, "data-bs-toggle", "tooltip");
			attr_dev(div, "data-bs-placement", "right");
			attr_dev(div, "title", "Delete Image");
			add_location(div, file, 798, 68, 30544);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(798:64) {#if temp1.charAt(0) == \\\"*\\\"}",
		ctx
	});

	return block;
}

// (787:48) {#each tempdata1 as temp1, k}
function create_each_block_1(ctx) {
	let div2;
	let div0;
	let textarea;
	let textarea_style_value;
	let textarea_class_value;
	let textarea_value_value;
	let t0;
	let show_if_1 = /*temp1*/ ctx[63].charAt(0) == "*";
	let div0_style_value;
	let t1;
	let div1;
	let show_if = /*temp1*/ ctx[63].charAt(0) == "*";
	let t2;
	let button0;
	let span0;
	let t3;
	let button1;
	let span1;
	let button1_style_value;
	let t4;
	let mounted;
	let dispose;

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[28](/*temp1*/ ctx[63], /*i*/ ctx[62], /*k*/ ctx[65], ...args);
	}

	let if_block0 = show_if_1 && create_if_block_2(ctx);
	let if_block1 = show_if && create_if_block_1(ctx);

	function click_handler_4(...args) {
		return /*click_handler_4*/ ctx[29](/*i*/ ctx[62], /*k*/ ctx[65], ...args);
	}

	function click_handler_5(...args) {
		return /*click_handler_5*/ ctx[30](/*i*/ ctx[62], /*k*/ ctx[65], ...args);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			t2 = space();
			button0 = element("button");
			span0 = element("span");
			t3 = space();
			button1 = element("button");
			span1 = element("span");
			t4 = space();
			attr_dev(textarea, "rows", "3");
			attr_dev(textarea, "cols", "20");
			attr_dev(textarea, "style", textarea_style_value = "resize:none;");

			attr_dev(textarea, "class", textarea_class_value = "" + (null_to_empty(/*temp1*/ ctx[63].charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]
			: "form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]) + " svelte-1kpz00h"));

			attr_dev(textarea, "id", "matchList1");
			textarea.value = textarea_value_value = /*temp1*/ ctx[63];
			add_location(textarea, file, 790, 64, 29510);
			attr_dev(div0, "class", "pull-left word_break width200 p-1 max_width_300");
			attr_dev(div0, "style", div0_style_value = "border-radius:3px;");
			add_location(div0, file, 789, 60, 29354);
			attr_dev(span0, "class", "icomoon-images d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span0, "data-bs-toggle", "tooltip");
			attr_dev(span0, "data-bs-placement", "right");
			attr_dev(span0, "title", "Add Image");
			add_location(span0, file, 800, 242, 30982);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "d-block btn btn-outline-primary btn-sm edit_btn bg-white mb-1");
			add_location(button0, file, 800, 64, 30804);
			attr_dev(span1, "class", "icomoon-24px-delete-1 d-flex align-items-center pt-sm1 pb-sm1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "right");
			attr_dev(span1, "title", "Delete");
			add_location(span1, file, 801, 292, 31430);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm edit_btn textdel bg-white");

			attr_dev(button1, "style", button1_style_value = /*state*/ ctx[3].isalgo
			? "display:block;"
			: "display : none");

			add_location(button1, file, 801, 64, 31202);
			attr_dev(div1, "class", "pull-right");
			add_location(div1, file, 796, 60, 30356);
			attr_dev(div2, "class", "d-flex align-items-center");
			add_location(div2, file, 788, 56, 29253);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div0, textarea);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, button0);
			append_dev(button0, span0);
			append_dev(div1, t3);
			append_dev(div1, button1);
			append_dev(button1, span1);
			append_dev(div2, t4);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", change_handler_1, false, false, false),
					listen_dev(button0, "click", click_handler_4, false, false, false),
					listen_dev(button1, "click", click_handler_5, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*tempdata1*/ 1 && textarea_class_value !== (textarea_class_value = "" + (null_to_empty(/*temp1*/ ctx[63].charAt(0) == "*"
			? "h form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]
			: "form-control textarea_1_" + /*i*/ ctx[62] + "_" + /*k*/ ctx[65]) + " svelte-1kpz00h"))) {
				attr_dev(textarea, "class", textarea_class_value);
			}

			if (dirty[0] & /*tempdata1*/ 1 && textarea_value_value !== (textarea_value_value = /*temp1*/ ctx[63])) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*tempdata1*/ 1) show_if_1 = /*temp1*/ ctx[63].charAt(0) == "*";

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*tempdata1*/ 1) show_if = /*temp1*/ ctx[63].charAt(0) == "*";

			if (show_if) {
				if (if_block1) ; else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*state*/ 8 && button1_style_value !== (button1_style_value = /*state*/ ctx[3].isalgo
			? "display:block;"
			: "display : none")) {
				attr_dev(button1, "style", button1_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(787:48) {#each tempdata1 as temp1, k}",
		ctx
	});

	return block;
}

// (745:16) {#each localCData as data, i}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*state*/ ctx[3].isalgo === true) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(745:16) {#each localCData as data, i}",
		ctx
	});

	return block;
}

// (904:7) <Button variant="contained" id="cdata" on:click={insertImage} class="text-white bg-primary">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Done");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(904:7) <Button variant=\\\"contained\\\" id=\\\"cdata\\\" on:click={insertImage} class=\\\"text-white bg-primary\\\">",
		ctx
	});

	return block;
}

// (902:6) <div slot="footer" class="svelteFooter">
function create_footer_slot_1(ctx) {
	let div;
	let input;
	let input_value_value;
	let t;
	let button;
	let current;
	let mounted;
	let dispose;

	button = new Button({
			props: {
				variant: "contained",
				id: "cdata",
				class: "text-white bg-primary",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*insertImage*/ ctx[14]);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t = space();
			create_component(button.$$.fragment);
			attr_dev(input, "type", "button");
			attr_dev(input, "class", "cancel_btn_pop btn btn-light colorgray1 svelte-1kpz00h");
			attr_dev(input, "variant", "contained");
			input.value = input_value_value = Lang.cancel;
			add_location(input, file, 902, 7, 39066);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file, 901, 6, 39017);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t);
			mount_component(button, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "click", /*closeImageDialog*/ ctx[13], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot_1.name,
		type: "slot",
		source: "(902:6) <div slot=\\\"footer\\\" class=\\\"svelteFooter\\\">",
		ctx
	});

	return block;
}

// (877:1) <Dialog bind:visible={state.openImageDialog} disableEnforceFocus={true} style={'width:600px;'}>
function create_default_slot_2(ctx) {
	let div1;
	let div0;
	let t1;
	let div9;
	let div8;
	let div7;
	let div3;
	let div2;
	let label0;
	let t3;
	let input0;
	let t4;
	let div5;
	let div4;
	let label1;
	let t6;
	let input1;
	let t7;
	let div6;
	let button;
	let t9;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Add Image";
			t1 = space();
			div9 = element("div");
			div8 = element("div");
			div7 = element("div");
			div3 = element("div");
			div2 = element("div");
			label0 = element("label");
			label0.textContent = "Background Image";
			t3 = space();
			input0 = element("input");
			t4 = space();
			div5 = element("div");
			div4 = element("div");
			label1 = element("label");
			label1.textContent = "Background Alt";
			t6 = space();
			input1 = element("input");
			t7 = space();
			div6 = element("div");
			button = element("button");
			button.textContent = "Upload Image";
			t9 = space();
			add_location(div0, file, 878, 5, 37980);
			set_style(div1, "text-align", "left");
			set_style(div1, "font-weight", "bold");
			attr_dev(div1, "class", "mb-5");
			add_location(div1, file, 877, 4, 37912);
			attr_dev(label0, "class", "control-label font-weight-normal mb-0");
			attr_dev(label0, "for", "MatchlistImg");
			add_location(label0, file, 885, 10, 38196);
			attr_dev(input0, "type", "text");
			attr_dev(input0, "class", "form-control form-control-md");
			attr_dev(input0, "id", "MatchlistImg");
			attr_dev(input0, "placeholder", "Image url");
			add_location(input0, file, 886, 10, 38304);
			attr_dev(div2, "class", "form-group");
			add_location(div2, file, 884, 9, 38160);
			attr_dev(div3, "class", "col-md-6 px-1");
			add_location(div3, file, 883, 14, 38122);
			attr_dev(label1, "class", "control-label font-weight-normal mb-0");
			attr_dev(label1, "for", "MatchlistAlt");
			add_location(label1, file, 891, 10, 38533);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "class", "form-control form-control-md");
			attr_dev(input1, "id", "MatchlistAlt");
			attr_dev(input1, "placeholder", "Background alt text");
			add_location(input1, file, 892, 10, 38639);
			attr_dev(div4, "class", "form-group");
			add_location(div4, file, 890, 9, 38497);
			attr_dev(div5, "class", "col-md-6 px-1");
			add_location(div5, file, 889, 14, 38459);
			attr_dev(button, "class", "btn btn-outline-primary");
			add_location(button, file, 896, 12, 38845);
			attr_dev(div6, "class", "col-md-6 px-1");
			add_location(div6, file, 895, 14, 38804);
			attr_dev(div7, "class", "row mx-0");
			add_location(div7, file, 882, 13, 38084);
			attr_dev(div8, "class", "imageDialog");
			add_location(div8, file, 881, 12, 38044);
			add_location(div9, file, 880, 11, 38025);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div9, anchor);
			append_dev(div9, div8);
			append_dev(div8, div7);
			append_dev(div7, div3);
			append_dev(div3, div2);
			append_dev(div2, label0);
			append_dev(div2, t3);
			append_dev(div2, input0);
			append_dev(div7, t4);
			append_dev(div7, div5);
			append_dev(div5, div4);
			append_dev(div4, label1);
			append_dev(div4, t6);
			append_dev(div4, input1);
			append_dev(div7, t7);
			append_dev(div7, div6);
			append_dev(div6, button);
			insert_dev(target, t9, anchor);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*openMediaDialog*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div9);
			if (detaching) detach_dev(t9);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(877:1) <Dialog bind:visible={state.openImageDialog} disableEnforceFocus={true} style={'width:600px;'}>",
		ctx
	});

	return block;
}

// (923:6) <Button variant="contained" on:click={removeRow}         class="bg-primary text-white">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Yes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(923:6) <Button variant=\\\"contained\\\" on:click={removeRow}         class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (922:5) <div slot="footer" class="svelteFooter">
function create_footer_slot(ctx) {
	let div;
	let button;
	let t;
	let input;
	let current;
	let mounted;
	let dispose;

	button = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*removeRow*/ ctx[18]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t = space();
			input = element("input");
			attr_dev(input, "type", "button");
			attr_dev(input, "variant", "contained");
			attr_dev(input, "class", "btn btn-light colorgray svelte-1kpz00h");
			input.value = "No";
			add_location(input, file, 924, 6, 39863);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file, 921, 5, 39706);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			append_dev(div, t);
			append_dev(div, input);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "click", /*click_handler_10*/ ctx[38], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(922:5) <div slot=\\\"footer\\\" class=\\\"svelteFooter\\\">",
		ctx
	});

	return block;
}

// (910:4) <Dialog       bind:visible={state.openDeleteDialog}       style={'width:500px;'}      >
function create_default_slot(ctx) {
	let div0;
	let t1;
	let div2;
	let div1;
	let span;
	let span_style_value;
	let t3;

	const block = {
		c: function create() {
			div0 = element("div");
			div0.textContent = `${Lang.save_header}`;
			t1 = space();
			div2 = element("div");
			div1 = element("div");
			span = element("span");
			span.textContent = `${Lang.del_confirmation}`;
			t3 = space();
			set_style(div0, "font-weight", "bold");
			add_location(div0, file, 913, 5, 39470);
			attr_dev(span, "class", "col-md-12");
			attr_dev(span, "style", span_style_value = "margin-top:40px;margin-bottom:40px;");
			add_location(span, file, 916, 6, 39567);
			attr_dev(div1, "class", "row");
			add_location(div1, file, 915, 6, 39542);
			add_location(div2, file, 914, 5, 39529);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, span);
			insert_dev(target, t3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
			if (detaching) detach_dev(t3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(910:4) <Dialog       bind:visible={state.openDeleteDialog}       style={'width:500px;'}      >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let center;
	let div12;
	let div9;
	let div8;
	let div2;
	let div0;
	let label0;
	let t1;
	let input0;
	let input0_value_value;
	let t2;
	let div1;
	let label1;
	let t4;
	let input1;
	let input1_value_value;
	let t5;
	let div4;
	let div3;
	let label2;
	let t7;
	let input2;
	let input2_value_value;
	let t8;
	let div7;
	let div5;
	let checkbox0;
	let t9;
	let checkbox1;
	let t10;
	let div6;
	let checkbox2;
	let t11;
	let div10;
	let t12;
	let div11;
	let button;
	let span;
	let t14;
	let t15;
	let dialog0;
	let updating_visible;
	let t16;
	let dialog1;
	let updating_visible_1;
	let current;
	let mounted;
	let dispose;

	checkbox0 = new Checkbox({
			props: {
				checked: /*state*/ ctx[3].drag_mode,
				id: "isDragDrop",
				color: "primary",
				style: "position:relative;right:10px;",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*click_handler*/ ctx[23]);

	checkbox1 = new Checkbox({
			props: {
				id: "isSwap",
				color: "primary",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*click_handler_1*/ ctx[24]);

	checkbox2 = new Checkbox({
			props: {
				defaultChecked: /*state*/ ctx[3].isalgo == true ? true : false,
				name: "isalgo",
				id: "isalgo",
				color: "primary",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox2.$on("click", /*changeisalgo*/ ctx[15]);
	let each_value = /*localCData*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function dialog0_visible_binding(value) {
		/*dialog0_visible_binding*/ ctx[37].call(null, value);
	}

	let dialog0_props = {
		disableEnforceFocus: true,
		style: "width:600px;",
		$$slots: {
			default: [create_default_slot_2],
			footer: [create_footer_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[3].openImageDialog !== void 0) {
		dialog0_props.visible = /*state*/ ctx[3].openImageDialog;
	}

	dialog0 = new Dialog({ props: dialog0_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog0, "visible", dialog0_visible_binding));

	function dialog1_visible_binding(value) {
		/*dialog1_visible_binding*/ ctx[39].call(null, value);
	}

	let dialog1_props = {
		style: "width:500px;",
		$$slots: {
			default: [create_default_slot],
			footer: [create_footer_slot]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[3].openDeleteDialog !== void 0) {
		dialog1_props.visible = /*state*/ ctx[3].openDeleteDialog;
	}

	dialog1 = new Dialog({ props: dialog1_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog1, "visible", dialog1_visible_binding));

	const block = {
		c: function create() {
			main = element("main");
			center = element("center");
			div12 = element("div");
			div9 = element("div");
			div8 = element("div");
			div2 = element("div");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = `${Lang.matchlist_heading1}`;
			t1 = space();
			input0 = element("input");
			t2 = space();
			div1 = element("div");
			label1 = element("label");
			label1.textContent = `${Lang.matchlist_heading2}`;
			t4 = space();
			input1 = element("input");
			t5 = space();
			div4 = element("div");
			div3 = element("div");
			label2 = element("label");
			label2.textContent = "Maxnode:";
			t7 = space();
			input2 = element("input");
			t8 = space();
			div7 = element("div");
			div5 = element("div");
			create_component(checkbox0.$$.fragment);
			t9 = space();
			create_component(checkbox1.$$.fragment);
			t10 = space();
			div6 = element("div");
			create_component(checkbox2.$$.fragment);
			t11 = space();
			div10 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t12 = space();
			div11 = element("div");
			button = element("button");
			span = element("span");
			span.textContent = "+";
			t14 = text("Add node");
			t15 = space();
			create_component(dialog0.$$.fragment);
			t16 = space();
			create_component(dialog1.$$.fragment);
			attr_dev(label0, "for", "listheading1");
			attr_dev(label0, "class", "mb-0 float-left");
			add_location(label0, file, 695, 28, 22296);
			attr_dev(input0, "type", "text");
			attr_dev(input0, "id", "listheading1");
			attr_dev(input0, "class", "form-control");
			input0.value = input0_value_value = /*state*/ ctx[3].listheading1;
			add_location(input0, file, 696, 28, 22406);
			attr_dev(div0, "class", "col-md-6 pr-1");
			add_location(div0, file, 694, 24, 22239);
			attr_dev(label1, "for", "listheading2");
			attr_dev(label1, "class", "mb-0 float-left");
			add_location(label1, file, 699, 28, 22630);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", "listheading2");
			attr_dev(input1, "class", "form-control");
			input1.value = input1_value_value = /*state*/ ctx[3].listheading2;
			add_location(input1, file, 700, 28, 22740);
			attr_dev(div1, "class", "col-md-6 pl-1");
			add_location(div1, file, 698, 24, 22573);
			attr_dev(div2, "class", "d-flex row");
			add_location(div2, file, 693, 20, 22189);
			attr_dev(label2, "for", "maxnode");
			attr_dev(label2, "class", "mb-0 float-left");
			add_location(label2, file, 705, 28, 23061);
			attr_dev(input2, "type", "text");
			attr_dev(input2, "id", "maxnode");
			attr_dev(input2, "class", "form-control");
			attr_dev(input2, "placeholder", "Enter number only 1 to 6");
			input2.value = input2_value_value = /*state*/ ctx[3].maxnode;
			add_location(input2, file, 706, 28, 23152);
			attr_dev(div3, "class", "h float-left w-sm mr-2");
			add_location(div3, file, 704, 24, 22995);
			attr_dev(div4, "class", "d-flex width1 float-left");
			add_location(div4, file, 703, 20, 22931);
			attr_dev(div5, "class", "mt-2 d-flex");
			add_location(div5, file, 710, 24, 23442);
			attr_dev(div6, "class", "mt-2");
			add_location(div6, file, 728, 24, 24365);
			attr_dev(div7, "class", "d-flex justify-content-between");
			add_location(div7, file, 709, 20, 23372);
			attr_dev(div8, "class", "border-bottom w-100 d-inline-block pb-0 px-3 pt-3");
			add_location(div8, file, 692, 16, 22104);
			attr_dev(div9, "class", "mb-1");
			add_location(div9, file, 691, 12, 22068);
			attr_dev(div10, "id", "matchListArea");
			attr_dev(div10, "class", "row-fluid p-2 clear-both");
			add_location(div10, file, 742, 12, 25011);
			attr_dev(span, "class", "font24 svelte-1kpz00h");
			add_location(span, file, 871, 20, 37692);
			attr_dev(button, "id", "add_node");
			attr_dev(button, "aria-label", "Add node");
			attr_dev(button, "class", "btn btn-outline-primary btn-sm d-flex align-items-center pr-md add_button svelte-1kpz00h");
			add_location(button, file, 866, 16, 37429);
			attr_dev(div11, "class", "text-left ml-2 pb-3");
			add_location(div11, file, 865, 12, 37378);
			attr_dev(div12, "id", "fixedMatchList");
			attr_dev(div12, "class", "border h-auto fwidth");
			add_location(div12, file, 690, 8, 22000);
			add_location(center, file, 689, 4, 21982);
			add_location(main, file, 688, 0, 21970);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, center);
			append_dev(center, div12);
			append_dev(div12, div9);
			append_dev(div9, div8);
			append_dev(div8, div2);
			append_dev(div2, div0);
			append_dev(div0, label0);
			append_dev(div0, t1);
			append_dev(div0, input0);
			append_dev(div2, t2);
			append_dev(div2, div1);
			append_dev(div1, label1);
			append_dev(div1, t4);
			append_dev(div1, input1);
			append_dev(div8, t5);
			append_dev(div8, div4);
			append_dev(div4, div3);
			append_dev(div3, label2);
			append_dev(div3, t7);
			append_dev(div3, input2);
			append_dev(div8, t8);
			append_dev(div8, div7);
			append_dev(div7, div5);
			mount_component(checkbox0, div5, null);
			append_dev(div5, t9);
			mount_component(checkbox1, div5, null);
			append_dev(div7, t10);
			append_dev(div7, div6);
			mount_component(checkbox2, div6, null);
			append_dev(div12, t11);
			append_dev(div12, div10);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div10, null);
			}

			append_dev(div12, t12);
			append_dev(div12, div11);
			append_dev(div11, button);
			append_dev(button, span);
			append_dev(button, t14);
			append_dev(main, t15);
			mount_component(dialog0, main, null);
			append_dev(main, t16);
			mount_component(dialog1, main, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "change", /*updateXml*/ ctx[4], false, false, false),
					listen_dev(input1, "change", /*updateXml*/ ctx[4], false, false, false),
					listen_dev(input2, "change", /*updateXml*/ ctx[4], false, false, false),
					listen_dev(button, "click", /*updateCData*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*state*/ 8 && input0_value_value !== (input0_value_value = /*state*/ ctx[3].listheading1) && input0.value !== input0_value_value) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (!current || dirty[0] & /*state*/ 8 && input1_value_value !== (input1_value_value = /*state*/ ctx[3].listheading2) && input1.value !== input1_value_value) {
				prop_dev(input1, "value", input1_value_value);
			}

			if (!current || dirty[0] & /*state*/ 8 && input2_value_value !== (input2_value_value = /*state*/ ctx[3].maxnode) && input2.value !== input2_value_value) {
				prop_dev(input2, "value", input2_value_value);
			}

			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 8) checkbox0_changes.checked = /*state*/ ctx[3].drag_mode;

			if (dirty[2] & /*$$scope*/ 128) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);
			const checkbox2_changes = {};
			if (dirty[0] & /*state*/ 8) checkbox2_changes.defaultChecked = /*state*/ ctx[3].isalgo == true ? true : false;

			if (dirty[2] & /*$$scope*/ 128) {
				checkbox2_changes.$$scope = { dirty, ctx };
			}

			checkbox2.$set(checkbox2_changes);

			if (dirty[0] & /*state, removeCData, localCData, tempdata1, removetextbox, openImageDialogAlgo, editalgoCData, addListItem, tempdata2, openImageDialog, editCData*/ 203663) {
				each_value = /*localCData*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div10, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const dialog0_changes = {};

			if (dirty[2] & /*$$scope*/ 128) {
				dialog0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 8) {
				updating_visible = true;
				dialog0_changes.visible = /*state*/ ctx[3].openImageDialog;
				add_flush_callback(() => updating_visible = false);
			}

			dialog0.$set(dialog0_changes);
			const dialog1_changes = {};

			if (dirty[0] & /*state*/ 8 | dirty[2] & /*$$scope*/ 128) {
				dialog1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_1 && dirty[0] & /*state*/ 8) {
				updating_visible_1 = true;
				dialog1_changes.visible = /*state*/ ctx[3].openDeleteDialog;
				add_flush_callback(() => updating_visible_1 = false);
			}

			dialog1.$set(dialog1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);
			transition_in(checkbox2.$$.fragment, local);
			transition_in(dialog0.$$.fragment, local);
			transition_in(dialog1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			transition_out(checkbox2.$$.fragment, local);
			transition_out(dialog0.$$.fragment, local);
			transition_out(dialog1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_component(checkbox2);
			destroy_each(each_blocks, detaching);
			destroy_component(dialog0);
			destroy_component(dialog1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("MatchList", slots, []);
	let { editorState } = $$props;
	let { xml } = $$props;
	let { getChildXml } = $$props;
	let { smValidate } = $$props;

	// variables declration
	let timer = {};

	let tempdata1 = [];
	let tempdata2 = [];
	let listheading1 = "";
	let listheading2 = "";
	let multimatch = "";
	let list1 = [];
	let list2 = [];
	let localCData = [];
	let cdata = "";
	let editFlag = false;
	let editValue = "";
	let clsname = "";
	let columnid = "";
	let columnname = "";
	let index;
	let row = 0;
	let state = {};

	////// Holding states in writable form /////
	let stateData = writable({
		snackback: false,
		xml: "",
		listheading1: "",
		listheading2: "",
		multimatch: "",
		openResponseDialog: false,
		setting: 1,
		openImageDialog: false,
		imageClass: "",
		maxnode: 0,
		clname: "",
		anchorEl: null,
		drag_mode: false,
		openDeleteDialog: false,
		row_id: "",
		dir: false
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(3, state = items);
	});

	beforeUpdate(() => {
		if (state.xml != xml) {
			$$invalidate(3, state.xml = xml, state);
			$$invalidate(0, tempdata1 = []);
			$$invalidate(1, tempdata2 = []);
			var newXml = XMLToJSON(state.xml);
			parseXMLAuthoring(newXml);
		}
	});

	function loadLibs() {
		let config = {
			preload: true,
			type: "stylesheet",
			as: "style"
		};

		AH$1.createLink(itemUrl + "clsSMMatchList/css/matchlistAuth.css", config);
	}

	onMount(() => {
		loadLibs();

		// preventing the enter key in the textarea
		AI.listen(document, "keydown", "textarea", function (event) {
			if (event.keyCode == 13) {
				event.preventDefault();
			}
		});

		// jQuery(document).off("keydown","textarea").on("keydown", "textarea", function(event) {
		// 	if (event.keyCode == 13) {
		// 		event.preventDefault();
		// 	}
		// });
		// for deleting the image
		AI.listen(document, "click", ".image_delete", _ele => {
			let oldImage = AI.find(_ele.parentElement.parentElement, "textarea").value;
			let newValue = state.xml.replace(oldImage, "insert value");
			getChildXml(newValue);
		});

		// jQuery('#matchListArea').tooltip({
		// 	selector: '[data-toggle="tooltip"]'
		// });
		AI.listen(document, "mouseup", ".ui-droppable", function () {
			setTimeout(function () {
				document.querySelectorAll(".matchlist-delete").forEach(_elm => {
					_elm.classList.add("tts_nospeak");
				});
			});
		});

		//jQuery('.algo_div span').css('color','#333');
		let algo_div_len = document.querySelectorAll(".algo_div span");

		for (let i = 0; i < algo_div_len.length; i++) {
			algo_div_len[i].style.color = "#333";
		}

		// jQuery(document).on('keydown', '.delete_match_node, .delete_match_node_auth', function(event) {
		// 	if ((event.keyCode == 13 || event.which == 13)) {
		// 	// click the element which currently get the focus and enter key is down
		// 	jQuery(this).trigger('click');
		// 	event.preventDefault();
		// 	}
		// });
		AI.listen(document, "keydown", ".delete_match_node, .delete_match_node_auth", function (data, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// Need ti fix one more line here....
				event.preventDefault();
			}
		});
	});

	// this function is responsible for parsing the xml
	function parseXMLAuthoring(QXML) {
		list1 = [];
		list2 = [];
		$$invalidate(2, localCData = []);

		// setting the state with the value in the xml
		$$invalidate(3, state.listheading1 = QXML.smxml.matchlist._listheading1, state);

		$$invalidate(3, state.listheading2 = QXML.smxml.matchlist._listheading2, state);
		$$invalidate(3, state.multimatch = QXML.smxml.matchlist._multimatch, state);
		$$invalidate(3, state.drag_mode = QXML.smxml.matchlist._multimatch == 2 ? true : false, state);

		// storing the values in multimatch and cdata
		multimatch = QXML.smxml.matchlist._multimatch;

		cdata = QXML.smxml.matchlist.__cdata;

		// checking for if is_algo is defined in xml or not
		if (QXML.smxml.matchlist._is_algo) {
			// if is_algo is true then put the value in isalgo as true else false
			$$invalidate(3, state.isalgo = QXML.smxml.matchlist._is_algo == "true" ? true : false, state);
		} else {
			// if is_algo is not defined means its value will be false
			$$invalidate(3, state.isalgo = false, state);
		}

		// for the maximum no of node i.e, max_node
		if (QXML.smxml.matchlist._max_node) {
			var num = Number(QXML.smxml.matchlist._max_node);
			$$invalidate(3, state.maxnode = num > 0 ? num : 0, state);
		} else {
			$$invalidate(3, state.maxnode = "", state);
		}

		// splitting the cdata with new line
		cdata = cdata.split("\n");

		// traversing through the cdata
		// jQuery(cdata).each( function (i) {
		cdata.forEach(function (data, i) {
			if (cdata[i].trim() != "") {
				// Finding the opening and closing brackets in cdata
				if (cdata[i].indexOf("[") >= 0 && cdata[i].indexOf("]") >= 0) {
					// extracting value 1 by replcing the content start with [ and end with ]
					let value1 = cdata[i].replace(cdata[i].match(/\[(.*?)\]/g), "").replace(/^\s+/g, "");

					let value2 = cdata[i].match(/\[(.*?)\]/g)[0];

					// finding the value 2 by finding the text start with [ and end with ] and the removing these brackets
					value2 = value2.replace("[", "").replace("]", "");

					// store the value in the localCData
					// localCData.push({
					// 	value1: value1,
					// 	value2: value2,
					// 	id:i
					// });
					$$invalidate(2, localCData = [...localCData, { value1, value2, id: i }]);

					list2[i] = cdata[i].replace(cdata[i].match(/\[(.*?)\]/g), "").replace(/^\s+/g, ""); // value 1
					list1[i] = cdata[i].match(/\[(.*?)\]/g)[0];
					list1[i] = list1[i].replace("[", "").replace("]", ""); // value 2
				} else {
					errMessage = "Bracket is Missing in line no. " + i;
					$$invalidate(3, state.snackback = true, state);
				}
			}
		});
	} //forceUpdate();

	// this function calls & updated the xml whenever there is change in list heading textbox & maxnode textbox
	function updateXml(e) {
		// updating the xml to json by XMLToJSON function
		var newXml = XMLToJSON(state.xml);

		// if there is change in listheading 1
		if (e.target.id == "listheading1") {
			$$invalidate(3, state.listheading1 = e.target.value, state);
		} else if (e.target.id == "listheading2") {
			// if there is change in listheading 2
			$$invalidate(3, state.listheading2 = e.target.value, state);
		} else if (e.target.id == "maxnode") {
			// if there is change in maxnode
			if (isNaN(e.target.value)) {
				AI.showmsg("Error Message", "Please enter numeric value", "error");
			} else if (e.target.value > 6) {
				AI.showmsg("Please insert value between 1 to 6");
			} else {
				$$invalidate(3, state.maxnode = e.target.value, state);
			}
		}

		timer["updateXMl1"] = setTimeout(
			function () {
				// updating the attribute values
				newXml.smxml.matchlist._listheading1 = state.listheading1;

				newXml.smxml.matchlist._listheading2 = state.listheading2;

				if (state.maxnode) {
					newXml.smxml.matchlist._max_node = state.maxnode;
				} else {
					// deleting max_node if it is not in use
					delete newXml.smxml.matchlist._max_node;
				}

				// update and store the xml 
				getChildXml(JSONToXML(newXml));

				clearTimeout(timer["updateXMl1"]);
			},
			200
		);
	}

	// whenever add button is clicked
	function updateCData() {
		//var rowInFirstColumn = jQuery("#matchListArea [class*='textarea_1']").length;
		var rowInFirstColumn = AI.selectAll("#matchListArea [class*='textarea_1']").length;

		//var rowInSeconfColumn = jQuery("#matchListArea [class*='textarea_2']").length;
		var rowInSeconfColumn = AI.selectAll("#matchListArea [class*='textarea_2']").length;

		if (rowInFirstColumn > 19 || rowInSeconfColumn > 19) {
			AI && AI.showmsg("Maximum possible options are 20");
		} else {
			row++;

			// converting the xml in json using the function XMLToJSON 
			let xml = XMLToJSON(state.xml);

			// updating the cdata
			xml.smxml.matchlist.__cdata = xml.smxml.matchlist.__cdata + `\nOption 2 Value of row ${row}[Option 1 value of row ${row}]\n`;

			// update and store the xml 
			getChildXml(JSONToXML(xml));

			setTimeout(
				function () {
					var err = smVal.validate(editorState.content_type, editorState.item, editorState.content_icon);
					smValidate(err);
				},
				200
			);
		}
	}

	function openMediaDialog() {
		//jQuery("#modal-media-upload").modal("show");
		AH$1.getBS("#modal-media-upload", "Modal").show();
	}

	// function calls onchange of the textarea in which option value is given if isalgo is off
	function editCData(val1, val2, i, e) {
		if (!e.target.value) return;

		if (e.target.id == "matchList1") {
			$$invalidate(2, localCData[i].value1 = e.target.value.replace(/\n/gm, ""), localCData);
		} else if (e.target.id == "matchList2") {
			$$invalidate(2, localCData[i].value2 = e.target.value.replace(/\n/gm, ""), localCData); //forceUpdate();
		} //forceUpdate();

		// converting the xml to json 
		let xml = XMLToJSON(state.xml);

		timer["editCdata"] = setTimeout(
			function () {
				let newCData = "\n";

				// jQuery(localCData).each(function(i) { // Replaced
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value1 + "[" + localCData[i].value2 + "]\n";
				});

				// updating the cdata
				xml.smxml.matchlist.__cdata = newCData;

				// updating the xml
				getChildXml(JSONToXML(xml));

				clearTimeout(timer["editCdata"]);
			},
			500
		);
	}

	// function calls onchange of the textarea in which option value is given if isalgo is on
	function editalgoCData(val1, i, placeIndex, e) {
		if (!e.target.value) return;

		if (e.target.id == "matchList1") {
			let placeindex2 = placeIndex.split("_")[1];

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value1;
					var strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr[k] = e.target.value;
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value1 = strarr, localCData);
		} else if (e.target.id == "matchList2") {
			let placeindex2 = placeIndex.split("_")[1]; //forceUpdate();

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value2;
					var strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr[k] = e.target.value;
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value2 = strarr, localCData);
		} //forceUpdate();

		let xml = XMLToJSON(state.xml);

		timer["algo"] = setTimeout(
			function () {
				let newCData = "\n";

				// jQuery(localCData).each(function(i) { // Replaced
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value1 + "[" + localCData[i].value2 + "]\n";
				});

				xml.smxml.matchlist.__cdata = newCData;
				getChildXml(JSONToXML(xml));
				clearTimeout(timer["algo"]);
			},
			500
		);
	}

	// for deleting the current option
	function removeCData(list1Val, list2Val, id) {
		//AH.alert("checking")
		$$invalidate(3, state.openDeleteDialog = true, state);

		$$invalidate(3, state.row_id = id, state);
	}

	// this function calls when the setting btn option is clicked
	function changeSetting(value) {
		let xml = XMLToJSON(state.xml);

		// if Normal options is selected
		if (value == 2) {
			if (state.drag_mode) {
				xml.smxml.matchlist._multimatch = 0;
			} else {
				xml.smxml.matchlist._multimatch = 2;
			}
		} else if (value == 3) {
			// for swap list
			let tempArr = xml.smxml.matchlist.__cdata.split("\n");

			let swapedCdata = "";

			tempArr.map((items, i) => {
				let tempList = items.split(/\[(.*?)\]/);

				if (tempList.length > 1) {
					swapedCdata += `${tempList[1]}[${tempList[0].trim()}]\n`;
				}
			});

			xml.smxml.matchlist.__cdata = swapedCdata;
		}

		// updating and storing the xml
		getChildXml(JSONToXML(xml));

		handleMenuClose();
	}

	// whenever the image icon is clicked this function calls
	function openImageDialog(class_name) {
		$$invalidate(3, state.openImageDialog = true, state);
		$$invalidate(3, state.imageClass = class_name, state);

		// extrcting image details
		let image = {};

		if (AH$1.select("." + class_name + " + img").nodeName) {
			image.name = AH$1.select("." + class_name + " + img").getAttribute("src").split("/").pop();
			image.alt = AH$1.select("." + class_name + " + img").getAttribute("alt");
		} else {
			image.name = "";
			image.alt = "";
		}

		// show value in the opened dailog
		timer["image"] = setTimeout(
			function () {
				AH$1.select("#MatchlistImg").value = image.name;
				AH$1.select("#MatchlistAlt").value = image.alt;
				clearTimeout(timer["image"]);
			},
			200
		);
	}

	// calls when image icon is clicked and is_algo is true 
	function openImageDialogAlgo(class_name, ids, i, clname) {
		$$invalidate(3, state.openImageDialog = true, state);
		clsname = class_name;
		index = ids;
		columnid = i;
		columnname = clname;
		$$invalidate(3, state.imageClass = class_name, state);
		$$invalidate(3, state.clname = clname, state);

		// extrcting image details
		let image = {};

		//image.name = (jQuery('.'+class_name+' + img').attr("src")) ? jQuery('.'+class_name+' + img').attr("src").split('/').pop() : "";
		if (AH$1.select("." + class_name, " + img").getAttribute("src") != null) {
			image.name = AH$1.select("." + class_name + " + img").getAttribute("src").split("/").pop();
			image.alt = AH$1.select("." + class_name + " + img").getAttribute("alt");
		} else {
			image.name = "";
			image.alt = "";
		}

		//image.alt = (jQuery('.'+class_name+' + img').attr("alt")) ? jQuery('.'+class_name+' + img').attr("alt"): "";
		// show value in the opened dailog
		timer["algoImage"] = setTimeout(
			function () {
				//jQuery('#MatchlistImg').val(image.name);
				AH$1.select("#MatchlistImg").value = image.name;

				//jQuery('#MatchlistAlt').val(image.alt);
				AH$1.select("#MatchlistAlt").value = image.alt;

				clearTimeout(timer["algoImage"]);
			},
			500
		);
	}

	// on click of cancel btn of image dialog this function called
	function closeImageDialog() {
		$$invalidate(3, state.openImageDialog = false, state);
	}

	// on click of done btn of image dialog this function called
	function insertImage() {
		if (state.isalgo == true) {
			// @pradeep sir : in both condition same code is written can we make it in one
			if (state.clname == "matchlist2" || state.clname == "matchlist1") {
				let image = {};

				// getting the image information
				image.name = AH$1.select("#MatchlistImg").value;

				image.alt = AH$1.select("#MatchlistAlt").value;
				image.oldValue = AH$1.select("." + state.imageClass).value;
				$$invalidate(3, state.openImageDialog = false, state);

				// replace with new value in the xml
				image.newValue = state.xml.replace(image.oldValue, "*" + image.name + "##" + image.alt);

				// updates the xml
				getChildXml(image.newValue);
			}
		} else {
			// finding the cdata
			let cdataArr = (/\<\!\[CDATA\[([\s\S]*?)\]\]\>/gi).exec(state.xml);

			let cdata = "";
			let keyIndex = parseInt(state.imageClass.match(/\d+$/g));
			let image = {};

			// getting image information
			//image.name = jQuery('#MatchlistImg').val();
			image.name = AH$1.select("#MatchlistImg").value;

			//image.alt = jQuery('#MatchlistAlt').val();
			image.alt = AH$1.select("#MatchlistAlt").value;

			//image.oldValue = jQuery('.'+state.imageClass).val();
			image.oldValue = AH$1.select("." + state.imageClass).value;

			$$invalidate(3, state.openImageDialog = false, state);

			if (cdataArr) {
				cdata = cdataArr[1];

				// replacing two newlines with singline newline and spliting it with newline
				cdata = cdata.replace("\n\n", "\n").trim();

				cdataArr = cdata.split("\n");

				// adding new image details
				cdataArr[keyIndex] = cdataArr[keyIndex].replace(image.oldValue, "*" + image.name + "##" + image.alt);

				// join cdataArr with neeline
				cdata = cdataArr.join("\n");

				// replace the cdata with new value
				image.newValue = xml.replace(/\<\!\[CDATA\[[\s\S]*?\]\]\>/gi, "<![CDATA[\n" + cdata + "\n]]>");
			} else {
				// adding new image details
				image.newValue = xml.replace(image.oldValue, "*" + image.name + "##" + image.alt);
			}

			// update the xml
			getChildXml(image.newValue);
		}
	}

	// called when algorithmic checkbox state is changed (on click)
	function changeisalgo(e) {
		// convert xml to json
		let xml = XMLToJSON(state.xml);

		$$invalidate(3, state.isalgo = e.target.checked, state);

		// if checkbox is checked 
		// if (e.target.checked) {
		// 	xml.smxml.matchlist._is_algo = true; 
		// } else {
		// 	xml.smxml.matchlist._is_algo = false;
		// }
		xml.smxml.matchlist._is_algo = e.target.checked;

		// updates the xml
		getChildXml(JSONToXML(xml));
	}

	// on click of delete icon which is adjusent to the option btn this function is called
	function removetextbox(ids, placeIndex, test, i, e) {
		if (test == "matchlist1") {
			var strarr;
			let placeindex2 = placeIndex.split("_")[1];

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value1;
					strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr.splice(k, 1);
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value1 = strarr, localCData);

			if (localCData[i].value1 == "" || localCData[i].value1 == "undefined") {
				$$invalidate(2, localCData[i].value1 = "insert value", localCData);
			}
		}

		if (test == "matchlist2") {
			var strarr;
			let placeindex2 = placeIndex.split("_")[1];

			for (var j = 0; j < localCData.length; j++) {
				if (j + 1 == i + 1) {
					let str = localCData[i].value2;
					strarr = str.split("%%");

					for (var k = 0; k < strarr.length; k++) {
						if (k == placeindex2) {
							strarr.splice(k, 1);
							break;
						}
					}

					break;
				}
			}

			strarr = strarr.join("%%");
			$$invalidate(2, localCData[i].value2 = strarr, localCData);

			if (localCData[i].value2 == "" || localCData[i].value2 == "undefined") {
				$$invalidate(2, localCData[i].value2 = "insert value", localCData);
			}
		}

		let xml = XMLToJSON(state.xml);

		var timer = setTimeout(
			function () {
				let newCData = "\n";

				//jQuery(localCData).each(function(i) { // Replaced
				localCData.forEach(function (data, i) {
					newCData += localCData[i].value1 + "[" + localCData[i].value2 + "]\n";
				});

				xml.smxml.matchlist.__cdata = newCData;
				getChildXml(JSONToXML(xml));
				clearTimeout(timer);
			},
			500
		);

		$$invalidate(3, state.dir = !state.dir, state);
	}

	function addListItem(index) {
		// convert xml to json 
		let xml = XMLToJSON(state.xml);

		// splitting cdata with newline and storring it in variable newArr
		let newArr = xml.smxml.matchlist.__cdata.split("\n");

		if (newArr[newArr.length - 1] == "") {
			newArr.pop();
			newArr.unshift("");
		}

		if (newArr[0] == "" && newArr[1] == "") {
			newArr.shift();
		}

		// gettng the index of the option 
		let str = newArr[parseInt(index + 1)];

		// extracting value 1
		let value1 = str.replace(str.match(/\[(.*?)\]/g), "").replace(/^\s+/g, "");

		let value2 = str.match(/\[(.*?)\]/g)[0];
		value2 = value2.substring(1, value2.length - 1);

		// extracting value 2
		value2 = "[" + value2 + "]";

		// adding new option value
		value1 = value1 + "%%Option 2 Value";

		// store the final string at that index
		let fStr = value1 + value2;

		newArr[parseInt(index + 1)] = fStr;

		// join the array
		newArr = newArr.join("\n");

		// update the cdata
		xml.smxml.matchlist.__cdata = newArr;

		// stores and update the xml using the function getChildXml
		getChildXml(JSONToXML(xml));
	}

	// called when dropdown is open 
	function handleMenuOpen(event) {
		$$invalidate(3, state.anchorEl = event.currentTarget, state);
	}

	// called when dropdown is close 
	function handleMenuClose() {
		$$invalidate(3, state.anchorEl = null, state);
	}

	function removeRow() {
		$$invalidate(3, state.openDeleteDialog = false, state);
		let not_matched_data = "";

		// storing the values of the option in a except the deleted one
		// jQuery(localCData).each(function(index_no) { // Replaced
		localCData.forEach(function (data, index_no) {
			// check min no of options
			if (localCData.length > 1) {
				if (localCData[index_no].id != state.row_id) {
					not_matched_data += localCData[index_no].value1 + "[" + localCData[index_no].value2 + "]\n";
				}
			} else {
				AI.showmsg("At least one field required.");
				not_matched_data += localCData[index_no].value1 + "[" + localCData[index_no].value2 + "]\n";
			}
		});

		// convert xml to json
		let xml = XMLToJSON(state.xml);

		// updating cdata
		xml.smxml.matchlist.__cdata = "\n" + not_matched_data;

		// updating the xml
		getChildXml(JSONToXML(xml));
	}

	const writable_props = ["editorState", "xml", "getChildXml", "smValidate"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MatchList> was created with unknown prop '${key}'`);
	});

	const click_handler = e => {
		changeSetting("2");
	};

	const click_handler_1 = e => {
		changeSetting("3");
	};

	const change_handler = (temp, i, j, e) => {
		editalgoCData(temp, i, i + "_" + j, e);
	};

	const click_handler_2 = (i, j, e) => {
		openImageDialogAlgo("textarea_2_" + i + "_" + j, i + "_" + j, i, "matchlist2");
	};

	const click_handler_3 = (i, j, e) => {
		removetextbox("textarea_2_" + i + "_" + j, i + "_" + j, "matchlist2", i);
	};

	const change_handler_1 = (temp1, i, k, e) => {
		editalgoCData(temp1, i, i + "_" + k, e);
	};

	const click_handler_4 = (i, k, e) => {
		openImageDialogAlgo("textarea_1_" + i + "_" + k, i + "_" + k, i, "matchlist1");
	};

	const click_handler_5 = (i, k, e) => {
		removetextbox("textarea_2_" + i + "_" + k, i + "_" + k, "matchlist1", i);
	};

	const click_handler_6 = data => {
		removeCData(data.value1, data.value2, data.id);
	};

	const change_handler_2 = (data, i, e) => {
		editCData(data.value2, data.value2, i, e);
	};

	const click_handler_7 = i => {
		openImageDialog("textarea_2_" + i);
	};

	const change_handler_3 = (data, i, e) => {
		editCData(data.value1, data.value2, i, e);
	};

	const click_handler_8 = i => {
		openImageDialog("textarea_1_" + i);
	};

	const click_handler_9 = data => {
		removeCData(data.value1, data.value2, data.id);
	};

	function dialog0_visible_binding(value) {
		state.openImageDialog = value;
		$$invalidate(3, state);
	}

	const click_handler_10 = () => {
		$$invalidate(3, state.openDeleteDialog = false, state);
	};

	function dialog1_visible_binding(value) {
		state.openDeleteDialog = value;
		$$invalidate(3, state);
	}

	$$self.$$set = $$props => {
		if ("editorState" in $$props) $$invalidate(19, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(20, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(21, getChildXml = $$props.getChildXml);
		if ("smValidate" in $$props) $$invalidate(22, smValidate = $$props.smValidate);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		beforeUpdate,
		writable,
		Loader,
		AH: AH$1,
		XMLToJSON,
		JSONToXML,
		smVal,
		l: Lang,
		Button,
		Dialog,
		Checkbox,
		editorState,
		xml,
		getChildXml,
		smValidate,
		timer,
		tempdata1,
		tempdata2,
		listheading1,
		listheading2,
		multimatch,
		list1,
		list2,
		localCData,
		cdata,
		editFlag,
		editValue,
		clsname,
		columnid,
		columnname,
		index,
		row,
		state,
		stateData,
		unsubscribe,
		loadLibs,
		parseXMLAuthoring,
		updateXml,
		updateCData,
		openMediaDialog,
		editCData,
		editalgoCData,
		removeCData,
		changeSetting,
		openImageDialog,
		openImageDialogAlgo,
		closeImageDialog,
		insertImage,
		changeisalgo,
		removetextbox,
		addListItem,
		handleMenuOpen,
		handleMenuClose,
		removeRow
	});

	$$self.$inject_state = $$props => {
		if ("editorState" in $$props) $$invalidate(19, editorState = $$props.editorState);
		if ("xml" in $$props) $$invalidate(20, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(21, getChildXml = $$props.getChildXml);
		if ("smValidate" in $$props) $$invalidate(22, smValidate = $$props.smValidate);
		if ("timer" in $$props) timer = $$props.timer;
		if ("tempdata1" in $$props) $$invalidate(0, tempdata1 = $$props.tempdata1);
		if ("tempdata2" in $$props) $$invalidate(1, tempdata2 = $$props.tempdata2);
		if ("listheading1" in $$props) listheading1 = $$props.listheading1;
		if ("listheading2" in $$props) listheading2 = $$props.listheading2;
		if ("multimatch" in $$props) multimatch = $$props.multimatch;
		if ("list1" in $$props) list1 = $$props.list1;
		if ("list2" in $$props) list2 = $$props.list2;
		if ("localCData" in $$props) $$invalidate(2, localCData = $$props.localCData);
		if ("cdata" in $$props) cdata = $$props.cdata;
		if ("editFlag" in $$props) editFlag = $$props.editFlag;
		if ("editValue" in $$props) editValue = $$props.editValue;
		if ("clsname" in $$props) clsname = $$props.clsname;
		if ("columnid" in $$props) columnid = $$props.columnid;
		if ("columnname" in $$props) columnname = $$props.columnname;
		if ("index" in $$props) index = $$props.index;
		if ("row" in $$props) row = $$props.row;
		if ("state" in $$props) $$invalidate(3, state = $$props.state);
		if ("stateData" in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		tempdata1,
		tempdata2,
		localCData,
		state,
		updateXml,
		updateCData,
		openMediaDialog,
		editCData,
		editalgoCData,
		removeCData,
		changeSetting,
		openImageDialog,
		openImageDialogAlgo,
		closeImageDialog,
		insertImage,
		changeisalgo,
		removetextbox,
		addListItem,
		removeRow,
		editorState,
		xml,
		getChildXml,
		smValidate,
		click_handler,
		click_handler_1,
		change_handler,
		click_handler_2,
		click_handler_3,
		change_handler_1,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		change_handler_2,
		click_handler_7,
		change_handler_3,
		click_handler_8,
		click_handler_9,
		dialog0_visible_binding,
		click_handler_10,
		dialog1_visible_binding
	];
}

class MatchList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-1kpz00h-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				editorState: 19,
				xml: 20,
				getChildXml: 21,
				smValidate: 22
			},
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MatchList",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*editorState*/ ctx[19] === undefined && !("editorState" in props)) {
			console.warn("<MatchList> was created without expected prop 'editorState'");
		}

		if (/*xml*/ ctx[20] === undefined && !("xml" in props)) {
			console.warn("<MatchList> was created without expected prop 'xml'");
		}

		if (/*getChildXml*/ ctx[21] === undefined && !("getChildXml" in props)) {
			console.warn("<MatchList> was created without expected prop 'getChildXml'");
		}

		if (/*smValidate*/ ctx[22] === undefined && !("smValidate" in props)) {
			console.warn("<MatchList> was created without expected prop 'smValidate'");
		}
	}

	get editorState() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smValidate() {
		throw new Error("<MatchList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smValidate(value) {
		throw new Error("<MatchList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default MatchList;
//# sourceMappingURL=MatchList-7833b721.js.map
