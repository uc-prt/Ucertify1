
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, J as append_styles, C as validate_each_argument, v as validate_slots, o as onMount, A as AH, I as beforeUpdate, y as l, w as writable, X as XMLToJSON, K as JSONToXML, a2 as onUserAnsChange, aa as afterUpdate, z as empty, n as insert_dev, x as detach_dev, c as create_component, f as space, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, e as element, j as attr_dev, k as add_location, p as append_dev, H as destroy_each, l as set_style, r as group_outros, u as check_outros, a3 as null_to_empty, q as listen_dev, F as prop_dev, G as run_all, B as noop, h as text } from './main-51d25123.js';
import { I as ItemHelper } from './ItemHelper-2dc48856.js';
import { G as GriddedHelper } from './GriddedHelper-07f0c479.js';

/* clsSMGridded\GriddedPreview.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file = "clsSMGridded\\GriddedPreview.svelte";

function add_css(target) {
	append_styles(target, "svelte-u3ss6a", ".layoutHeading{font-weight:bold;font-size:16px;color:#1877b1}.items_element:hover{border:1.2px solid #777}.moreOptions{-webkit-box-shadow:3px 4px 6px #c4c5c5;-moz-box-shadow:3px 4px 6px #c4c5c5;box-shadow:3px 4px 6px #c4c5c5;background-color:#f0f0f0;border-top:1px solid #1877b1;border-bottom:1px solid #1877b1}.moreOptionDetails{background-color:#f7f7f7}.input_col{position:relative;left:5px}.layoutheading{padding:5px;font-size:20px;font-weight:bold}.numbr_range{position:relative;left:130px}.numbr_range_txt{position:relative;left:200px}.plus_minus_fraction{position:relative;top:20px}.floating_fraction{position:relative;top:27px}.plus_minus_span{position:relative;left:5px}.floating_decimal{float:right;margin-right:45px}.fontStyle{width:100px;float:right;margin-right:60px}.fraction_slash{position:relative;left:177px}.minus_tab,.plus_tab.svelte-u3ss6a,.slash_tab.svelte-u3ss6a{text-align:center}.gridded_tab{background-color:#f0f0f0!important;user-select:none!important;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.font_size_label{position:relative;left:198px}.font_size{position:relative;left:225px}.decimal_col{position:relative;left:208px;width:90px}.correct_color{background-color:#E9FFE9}.fixed_decimal_check{position:relative;top:26px;left:13px}.correct_incorrect_icon_fill{position:relative;width:19px;height:19px;right:121px;top:-55px;background:white;border-radius:50%}.row_column_decimal{position:relative;top:30px;left:5px}.fixed_point_class{position:relative;left:7px}.row_column{position:relative;left:5px}.answer_icon{position:absolute;top:7px;right:34px}.myP tbody{cursor:pointer}.col_range{width:205px}.posSize{position:relative;left:7px}.fontSmall{font-size:12px;text-align:center}.fontNormal{font-size:14px;text-align:center}.fontLarge{font-size:24px;text-align:center}.fontExtraLarge{font-size:26px;text-align:center}.grid{position:relative;top:10px;box-shadow:10px 5px 10px #000}.items_element{border:1px solid #8080807a;padding:6px 10px;border-radius:50%;background-color:white}.griddedModule .active{color:white;transition:1s;background:#696969;border:2px solid #fff}.minus_point,.decl_point.svelte-u3ss6a{padding:6px 12px}.sla_point{padding:6px 11px}.griddedModule table tr td:last-child{border-right:1px solid #ccc !important}.griddedModule .lastGrid tr:last-child td{border-bottom:1px solid #ccc !important}.griddedModule td{border:1px solid #f0f0f0 !important;border-left:1px solid #ccc !important}.token:hover{border:1px solid #000 !important}.bla .token:hover{border:1px solid #fff !important}.token_selected{background-color:#64bb63;color:#fff}.bla .token_highlight_heading{color:#000 !important}.griddedModule .expandIcon{font-size:27px;font-weight:bold;color:#1877b1}table td{padding:.5rem .5rem!important;vertical-align:top!important;border-top:1px solid #dee2e6!important}table th{padding:.5rem .5rem!important;vertical-align:top!important;border-top:1px solid #dee2e6!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[45] = list[i];
	child_ctx[47] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	child_ctx[50] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	child_ctx[50] = i;
	return child_ctx;
}

// (664:24) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_id_value;
	let input_data_tag_value;
	let input_name_value;
	let input_style_value;
	let input_value_value;
	let t0;
	let span1;
	let span0;
	let span0_id_value;
	let t1;
	let span1_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			span1 = element("span");
			span0 = element("span");
			t1 = space();
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = /*val*/ ctx[48].id);
			attr_dev(input, "data-tag", input_data_tag_value = /*val*/ ctx[48].dataTag);
			attr_dev(input, "name", input_name_value = /*val*/ ctx[48].name);
			attr_dev(input, "style", input_style_value = 'width:50px;text-align:center;');

			input.value = input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[50]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[50]];

			attr_dev(input, "class", "tdFont");
			add_location(input, file, 665, 32, 22180);
			attr_dev(span0, "id", span0_id_value = /*val*/ ctx[48].spanid);
			attr_dev(span0, "class", "answer_icon");
			add_location(span0, file, 668, 36, 22545);
			attr_dev(span1, "class", span1_class_value = "" + (null_to_empty(/*state*/ ctx[2].iconVisible + ' relative') + " svelte-u3ss6a"));
			add_location(span1, file, 667, 32, 22462);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span1, t1);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*rowValidation*/ ctx[13], false, false, false),
					listen_dev(input, "input", highLight, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsPre*/ 8 && input_id_value !== (input_id_value = /*val*/ ctx[48].id)) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_data_tag_value !== (input_data_tag_value = /*val*/ ctx[48].dataTag)) {
				attr_dev(input, "data-tag", input_data_tag_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && input_name_value !== (input_name_value = /*val*/ ctx[48].name)) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty[0] & /*myAns*/ 2 && input_value_value !== (input_value_value = /*myAns*/ ctx[1][/*i*/ ctx[50]] === undefined
			? " "
			: /*myAns*/ ctx[1][/*i*/ ctx[50]]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*ColsPre*/ 8 && span0_id_value !== (span0_id_value = /*val*/ ctx[48].spanid)) {
				attr_dev(span0, "id", span0_id_value);
			}

			if (dirty[0] & /*state*/ 4 && span1_class_value !== (span1_class_value = "" + (null_to_empty(/*state*/ ctx[2].iconVisible + ' relative') + " svelte-u3ss6a"))) {
				attr_dev(span1, "class", span1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(span1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(664:24) {:else}",
		ctx
	});

	return block;
}

// (662:24) {#if val.decpoint == true}
function create_if_block_4(ctx) {
	let input;
	let input_style_value;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			attr_dev(input, "style", input_style_value = 'width:50px;text-align:center;');
			input.value = ".";
			input.disabled = "true";
			attr_dev(input, "class", "tdFont");
			add_location(input, file, 662, 28, 21980);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(662:24) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (661:20) {#each ColsPre as val,i}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*val*/ ctx[48].decpoint == true) return create_if_block_4;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(661:20) {#each ColsPre as val,i}",
		ctx
	});

	return block;
}

// (678:16) {#if state.plus_minus == 1}
function create_if_block_3(ctx) {
	let griddedhelper0;
	let t;
	let griddedhelper1;
	let current;

	griddedhelper0 = new GriddedHelper({
			props: {
				loop: /*Cols*/ ctx[8],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "+"
			},
			$$inline: true
		});

	griddedhelper0.$on("handleClickCombo", /*handleClickCombo*/ ctx[12]);

	griddedhelper1 = new GriddedHelper({
			props: {
				loop: /*Cols_Minus*/ ctx[9],
				class1: "tdFont plus_tab",
				className: "tdFontP plus_tab items_element minus_point",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "-"
			},
			$$inline: true
		});

	griddedhelper1.$on("handleClickCombo", /*handleClickCombo*/ ctx[12]);

	const block = {
		c: function create() {
			create_component(griddedhelper0.$$.fragment);
			t = space();
			create_component(griddedhelper1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(griddedhelper1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper0_changes = {};
			if (dirty[0] & /*Cols*/ 256) griddedhelper0_changes.loop = /*Cols*/ ctx[8];
			griddedhelper0.$set(griddedhelper0_changes);
			const griddedhelper1_changes = {};
			if (dirty[0] & /*Cols_Minus*/ 512) griddedhelper1_changes.loop = /*Cols_Minus*/ ctx[9];
			griddedhelper1.$set(griddedhelper1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper0.$$.fragment, local);
			transition_in(griddedhelper1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper0.$$.fragment, local);
			transition_out(griddedhelper1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(griddedhelper1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(678:16) {#if state.plus_minus == 1}",
		ctx
	});

	return block;
}

// (699:16) {#if state.slash_val == 1}
function create_if_block_2(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[6],
				class1: "tdFont points",
				className: "tdFontP text-center items_element sla_point",
				tableId: "tdFontP slash_tab",
				tableClass: "slash_tab gridded_tab mt-0",
				value: "/"
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[12]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 64) griddedhelper_changes.loop = /*Cols_slash*/ ctx[6];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(699:16) {#if state.slash_val == 1}",
		ctx
	});

	return block;
}

// (711:16) {#if state.decimal_val == 1}
function create_if_block_1(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_decimal*/ ctx[7],
				class1: "tdFont points",
				className: "tdFontP text-center items_element decl_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 mb-0 myP",
				value: "."
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[12]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_decimal*/ 128) griddedhelper_changes.loop = /*Cols_decimal*/ ctx[7];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(711:16) {#if state.decimal_val == 1}",
		ctx
	});

	return block;
}

// (732:32) {:else}
function create_else_block(ctx) {
	let td;
	let span;
	let t_value = +/*no*/ ctx[47] + "";
	let t;
	let span_tabindex_value;
	let span_key_value;
	let span_name_value;
	let span_data_tag_value;
	let span_id_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "tabindex", span_tabindex_value = /*val*/ ctx[48].tabIndex);
			attr_dev(span, "key", span_key_value = /*val*/ ctx[48].key);
			attr_dev(span, "name", span_name_value = /*val*/ ctx[48].name);
			attr_dev(span, "data-tag", span_data_tag_value = /*val*/ ctx[48].dataTag);
			attr_dev(span, "class", "tdFontP text-center td_data algn items_element");
			attr_dev(span, "id", span_id_value = /*val*/ ctx[48].id);
			add_location(span, file, 733, 40, 25574);
			attr_dev(td, "width", "50");
			attr_dev(td, "class", "text-center");
			add_location(td, file, 732, 36, 25497);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*handleClick*/ ctx[11], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && span_tabindex_value !== (span_tabindex_value = /*val*/ ctx[48].tabIndex)) {
				attr_dev(span, "tabindex", span_tabindex_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_key_value !== (span_key_value = /*val*/ ctx[48].key)) {
				attr_dev(span, "key", span_key_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_name_value !== (span_name_value = /*val*/ ctx[48].name)) {
				attr_dev(span, "name", span_name_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_data_tag_value !== (span_data_tag_value = /*val*/ ctx[48].dataTag)) {
				attr_dev(span, "data-tag", span_data_tag_value);
			}

			if (dirty[0] & /*totalCols*/ 32 && span_id_value !== (span_id_value = /*val*/ ctx[48].id)) {
				attr_dev(span, "id", span_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(732:32) {:else}",
		ctx
	});

	return block;
}

// (729:32) {#if val.decpoint}
function create_if_block(ctx) {
	let td;
	let td_key_value;

	const block = {
		c: function create() {
			td = element("td");
			attr_dev(td, "key", td_key_value = /*val*/ ctx[48].key);
			attr_dev(td, "class", "tdFont text-center");
			attr_dev(td, "width", "50");
			attr_dev(td, "disabled", "true");
			add_location(td, file, 729, 36, 25298);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 32 && td_key_value !== (td_key_value = /*val*/ ctx[48].key)) {
				attr_dev(td, "key", td_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(729:32) {#if val.decpoint}",
		ctx
	});

	return block;
}

// (728:28) {#each totalCols as val,i}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*val*/ ctx[48].decpoint) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(728:28) {#each totalCols as val,i}",
		ctx
	});

	return block;
}

// (726:20) {#each totalRows as data,no}
function create_each_block(ctx) {
	let tr;
	let t;
	let tr_key_value;
	let each_value_1 = /*totalCols*/ ctx[5];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "key", tr_key_value = /*data*/ ctx[45].key);
			add_location(tr, file, 726, 24, 25133);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols, handleClick*/ 2080) {
				each_value_1 = /*totalCols*/ ctx[5];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*totalRows*/ 16 && tr_key_value !== (tr_key_value = /*data*/ ctx[45].key)) {
				attr_dev(tr, "key", tr_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(726:20) {#each totalRows as data,no}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let center1;
	let div;
	let center0;
	let itemhelper;
	let t0;
	let table0;
	let tr;
	let table0_style_value;
	let t1;
	let t2;
	let t3;
	let t4;
	let table1;
	let tbody;
	let current;

	itemhelper = new ItemHelper({
			props: {
				handleReviewClick: /*handleReview*/ ctx[14],
				reviewMode: /*isReview*/ ctx[0],
				customReviewMode: /*customIsReview*/ ctx[10]
			},
			$$inline: true
		});

	let each_value_2 = /*ColsPre*/ ctx[3];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block0 = /*state*/ ctx[2].plus_minus == 1 && create_if_block_3(ctx);
	let if_block1 = /*state*/ ctx[2].slash_val == 1 && create_if_block_2(ctx);
	let if_block2 = /*state*/ ctx[2].decimal_val == 1 && create_if_block_1(ctx);
	let each_value = /*totalRows*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			main = element("main");
			center1 = element("center");
			div = element("div");
			center0 = element("center");
			create_component(itemhelper.$$.fragment);
			t0 = space();
			table0 = element("table");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			table1 = element("table");
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(center0, file, 651, 12, 21469);
			set_style(tr, "display", "flex");
			set_style(tr, "padding", "0");
			add_location(tr, file, 659, 16, 21817);
			attr_dev(table0, "border", "1");
			attr_dev(table0, "id", "tab2");
			attr_dev(table0, "style", table0_style_value = 'border-collapse:collapse;text-align:center');
			add_location(table0, file, 658, 12, 21717);
			add_location(tbody, file, 724, 16, 25050);
			attr_dev(table1, "id", "gridded_sheet");
			attr_dev(table1, "class", "gridded_tab mt-0 lastGrid create_tab myP");
			add_location(table1, file, 723, 12, 24957);
			attr_dev(div, "class", "griddedModule");
			add_location(div, file, 650, 8, 21428);
			add_location(center1, file, 649, 4, 21410);
			add_location(main, file, 648, 0, 21398);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, center1);
			append_dev(center1, div);
			append_dev(div, center0);
			mount_component(itemhelper, center0, null);
			append_dev(div, t0);
			append_dev(div, table0);
			append_dev(table0, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t4);
			append_dev(div, table1);
			append_dev(table1, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const itemhelper_changes = {};
			if (dirty[0] & /*isReview*/ 1) itemhelper_changes.reviewMode = /*isReview*/ ctx[0];
			itemhelper.$set(itemhelper_changes);

			if (dirty[0] & /*ColsPre, state, myAns, rowValidation*/ 8206) {
				each_value_2 = /*ColsPre*/ ctx[3];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (/*state*/ ctx[2].plus_minus == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].slash_val == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].decimal_val == 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*totalRows, totalCols, handleClick*/ 2096) {
				each_value = /*totalRows*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemhelper.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemhelper.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(itemhelper);
			destroy_each(each_blocks_1, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function highLight(event) {
	let cell_class = event.target.getAttribute('name');
	let column_index = document.getElementsByName(cell_class);

	for (let i = 1; i < column_index.length; i++) {
		if (column_index[i].classList.contains("active")) {
			column_index[i].classList.remove("active");
		}

		if (column_index[i].innerHTML == event.target.value) {
			column_index[i].classList.add("active");
		}
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('GriddedPreview', slots, []);
	let { isReview } = $$props;
	let { xml } = $$props;
	let { showAns } = $$props;
	let { uxml } = $$props;
	let { editorState } = $$props;

	// Declare global variables ////
	let customIsReview = isReview;

	let bool = ' ';
	let userAns = [];
	let ans = [];
	let myAns = [];
	let c = 0;
	let correctInc;
	let isAnswerCorrect = '';
	let answerStatus = '';
	let authAnsSplit;
	let incorrectCls = "";
	let userXML;

	let stateData = writable({
		rowNum: 4,
		colNum: 4,
		item: 1,
		plus_minus: 0,
		slash_val: 0,
		decimal_val: 0,
		xml: '',
		textSizeP: 0,
		correctAns: [],
		userList: [],
		isMathquill: false,
		smController: "h",
		pointerEvents: "auto",
		decimal_point: 0,
		iconVisible: "h"
	});

	let state = {};

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(2, state = items);
	});

	onMount(() => {
		AH.listen(document, 'keydown', '.td_data', (data, e) => {
			if (e.which === 13) {
				data.click();
			}
		});

		AH.listen(document, 'click', '#sm_controller button', e => {
			AH.selectAll('#sm_controller button', 'removeClass', ['active,btn-secondary,text-white,bg-secondary']);
			AH.selectAll(e, 'addClass', ['active,btn-secondary,text-white,bg-secondary']);
		});

		AH.listen(document, 'click', '#set-review', function () {
			setReview();
		});

		AH.listen(document, 'click', '#unset-review', function () {
			unsetReview();
		});
	});

	function loadModule(loadXml) {
		loadXml = XMLToJSON(loadXml);
		parseXMLPreview(loadXml);
	}

	function parseXMLPreview(MYXML) {
		try {
			$$invalidate(2, state.rowNum = MYXML.smxml._row, state);
			$$invalidate(2, state.colNum = MYXML.smxml._col, state);
			$$invalidate(2, state.slash_val = MYXML.smxml._slash, state);
			$$invalidate(2, state.plus_minus = MYXML.smxml._plusminus, state);
			$$invalidate(2, state.decimal_val = MYXML.smxml._decimal, state);
			$$invalidate(2, state.textSizeP = MYXML.smxml._font, state);
			$$invalidate(2, state.correctAns = MYXML.smxml._correctAns.split(','), state);
			$$invalidate(2, state.decimal_point = MYXML.smxml._fixed_point, state);

			//if (window.uaXML) {
			if (uxml) {
				parseUserAns(uxml);
			}
		} catch(error) {

			console.log({
				'error': error.message,
				'function name': 'parseXMLPreview',
				'File name': 'GriddedPreview.js'
			});
		}
	}

	function parseUserAns(uans) {
		let userAnswer = XMLToJSON(uans);

		if (userAnswer.smans && userAnswer.smans.div && userAnswer.smans.div._userAns) {
			userAns = userAnswer.smans.div._userAns.split(",");
			bool = userAnswer.smans.div._correct;

			// $("#answer").prop("checked", bool)
			ans = userAns;
		} //forceUpdate();
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(2, state.xml = xml, state);
			loadModule(xml);
		}

		if (xml) {
			console.log('qxml');
		}

		firstRowItemPre();
		decimalFloatingPre();
		slashFuncPre();
		plusMinusSignPre();
		createdSheetRowPre();
	});

	function handleClick(event) {
		//////////////changing color according to user/////////
		let cell_class = event.target.getAttribute('name');

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.target.innerHTML;
		setUserAns(event); //////// Call function for answer checking
	}

	function setUserAns(event) {
		let countRes;
		let resNew;
		let ansBool;

		//////// This code set the answer///////////
		let attr = event.target.attributes.getNamedItem('data-tag').value;

		if (event.target.innerHTML === '') {
			userAns[attr] = event.target.value;
		} else {
			userAns[attr] = event.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == 'undefined' || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = l.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = l.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = l.incorrect;
		} // return false;

		// if (!window.QXML) {
		if (editorState) {
			showAns(countRes);
		}

		ansBool = countRes == "correct" ? true : false;
		userXML = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		//AH.select("#special_module_user_xml").value = userXML
		resNew = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != ' ' && c == user.length) {
			AH.select("#answer", 'attr', { "checked": bool });
		} else {
			AH.select("#answer", 'attr', { "checked": isAnswerCorrect });
		}

		$$invalidate(15, uxml = userXML);
		onUserAnsChange({ uXml: resNew, ans: ansBool });
	}

	function handleClickCombo(event) {
		//////////////changing color according to user/////////
		let cell_class = event.detail.target.getAttribute('name');

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.detail.target.classList.add("active");

		////////Throw the select data in top row///////
		let target_id = event.detail.target.id;

		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.detail.target.innerHTML;
		setUserAnsCombo(event); //////// Call function for answer checking
	}

	function setUserAnsCombo(event) {
		let countRes;
		let resNew;
		let ansBool;

		//////// This code set the answer///////////
		let attr = event.detail.target.attributes.getNamedItem('data-tag').value;

		if (event.detail.target.innerHTML === '') {
			userAns[attr] = event.detail.target.value;
		} else {
			userAns[attr] = event.detail.target.innerHTML;
		}

		for (let i = 0; i < userAns.length; i++) {
			if (typeof userAns[i] == 'undefined' || userAns[i] == "") {
				userAns[i] = "%blank%";
			}
		}

		if (userAns[userAns.length - 1] == "%blank%") {
			userAns.pop();
		}

		$$invalidate(2, state.userList = userAns, state);
		authAnsSplit = state.correctAns;
		let user = state.userList;

		if (user.length == authAnsSplit.length) {
			for (let i = 0; i < authAnsSplit.length; i++) {
				if (user[i] == authAnsSplit[i]) {
					c++;
				}
			}

			if (c == user.length) {
				countRes = l.correct;
				isAnswerCorrect = true;
				c = 0;
			} else {
				countRes = l.incorrect; //return true;
				isAnswerCorrect = false;
				c = 0;
			} //return false;
		} else {
			countRes = l.incorrect;
		} // return false;

		//if (!window.QXML) {
		if (editorState) {
			showAns(countRes);
		}

		ansBool = countRes == "Correct" ? true : false;

		// AH.select("#special_module_user_xml").value = "<smans><div type='56' correct='"+isAnswerCorrect+"' userAns='"+state.userList+"'></div></smans>"
		userXML = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		resNew = "<smans><div type='56' correct='" + isAnswerCorrect + "' userAns='" + state.userList + "'></div></smans>";

		if (bool != ' ' && c == user.length) {
			AH.select("#answer", 'attr', { "checked": bool });
		} else {
			AH.select("#answer", 'attr', { "checked": isAnswerCorrect });
		}

		$$invalidate(15, uxml = userXML);
		onUserAnsChange({ uXml: resNew, ans: ansBool });
	}

	function rowValidation(event) {
		let a = state.rowNum - 1;

		if (event.target.value.length > 1) {
			AH.alert('Double digit not accepted');
			event.target.value = '';
			return false;
		} else if (event.target.value < 0) {
			AH.alert("Less then 1 not accepted");
			event.target.value = "";
			return false;
		} else if (a < event.target.value) {
			AH.alert('Number insert only 0 to ' + state.rowNum);
			event.target.value = '';
			return false;
		}

		setUserAns(event);
	}

	////////////////// Create very first row and store data according to click//////////
	let ColsPre = [];

	function firstRowItemPre() {
		$$invalidate(3, ColsPre = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (ans[j] === "%blank%") {
				$$invalidate(1, myAns[j] = " ", myAns);
			} else {
				$$invalidate(1, myAns[j] = ans[j], myAns);
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(3, ColsPre = [...ColsPre, { decpoint: true }]);
			} else {
				if (ColsPre.length < state.colNum) {
					$$invalidate(3, ColsPre = [
						...ColsPre,
						{
							id: 't' + j,
							dataTag: j,
							name: 'p' + j,
							value: myAns[j],
							spanid: "t_" + j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	let totalRows = [];
	let totalCols = [];

	function createdSheetRowPre() {
		$$invalidate(4, totalRows = []);
		let dec_point = state.decimal_point;

		for (let i = 0; i < state.rowNum; i++) {
			$$invalidate(5, totalCols = []);

			for (let j = 0; j < state.colNum; j++) {
				if (j == dec_point - 1 && dec_point != 0) {
					$$invalidate(5, totalCols = [...totalCols, { key: "col" + i + j, decpoint: true }]);
				} else {
					if (totalCols.length < state.colNum) {
						$$invalidate(5, totalCols = [
							...totalCols,
							{
								tabIndex: 0,
								key: "col" + i + j,
								name: 'p' + j,
								dataTag: j,
								id: "t" + j + "-" + i + j,
								decpoint: false
							}
						]);
					}
				}
			}

			$$invalidate(4, totalRows = [...totalRows, { key: "row" + i }]);
		}
	}

	let Cols_slash = [];

	function slashFuncPre(event) {
		$$invalidate(6, Cols_slash = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(6, Cols_slash = [...Cols_slash, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_slash.length < state.colNum) {
					$$invalidate(6, Cols_slash = [
						...Cols_slash,
						{
							id: "t" + j,
							name: 'p' + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	
	let Cols_decimal = [];

	function decimalFloatingPre(event) {
		$$invalidate(7, Cols_decimal = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(7, Cols_decimal = [...Cols_decimal, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_decimal.length < state.colNum) {
					$$invalidate(7, Cols_decimal = [
						...Cols_decimal,
						{
							id: "t" + j,
							name: 'p' + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	///////////////// Set review and unset review function//////////////
	function setReview() {
		console.trace();
		($$invalidate(2, state.smController = "", state), $$invalidate(2, state.pointerEvents = "none", state));
		$$invalidate(0, isReview = true);
		showAnswer("yans", "showIcon");
		AH.selectAll('#sm_controller .your-ans', 'addClass', ['btn-light', 'active']);
		AH.selectAll(".tokenHeader", "attr", { "tabindex": 0 });
		setTimeout(getCorrect(), 200);

		// if (!window.QXML) {
		if (editorState) {
			showAns(isAnswerCorrect ? l.correct : l.incorrect);
		}
	}

	function getCorrect() {
		for (let i = 0; i < state.correctAns.length; i++) {
			if (state.correctAns[i] == state.userList[i]) {
				AH.select('#t_' + i, 'removeClass', 'icomoon-new-24px-cancel-circle-1');
				AH.select('#t_' + i, 'addClass', 'icomoon-new-24px-checkmark-circle-1');
			} else {
				AH.select('#t_' + i, 'removeClass', 'icomoon-new-24px-checkmark-circle-1');
				AH.select('#t_' + i, 'addClass', 'icomoon-new-24px-cancel-circle-1');
			}
		}
	}

	function unsetReview() {
		($$invalidate(2, state.smController = "h", state), $$invalidate(2, state.pointerEvents = "auto", state));
		$$invalidate(0, isReview = false);
		showAnswer("yans", "hideIcon");
		AH.selectAll(".tokenHeader", 'removeAttr', 'tabindex');
	}

	function showAnswer(val, iconState) {
		//show correct incorrect icon with respect to iconState
		if (iconState == "showIcon") {
			$$invalidate(2, state.iconVisible = "", state);
		} else {
			$$invalidate(2, state.iconVisible = "h", state);
		}

		if (val == "cans") {
			let ele = document.getElementsByClassName('gridded_tab');
			ele.disabled = true;
			ans = state.correctAns;
		} else if (val == "yans") {
			ans = userAns;
		}
	}

	///////////////////////////// create plus and minus row//////////////////
	let Cols = [];

	let Cols_Minus = [];

	function plusMinusSignPre(event) {
		$$invalidate(8, Cols = []);
		$$invalidate(9, Cols_Minus = []);
		let dec_point = state.decimal_point;

		//let arr = [];
		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(8, Cols = [
					...Cols,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols.length < state.colNum) {
					$$invalidate(8, Cols = [
						...Cols,
						{
							id: "t" + j,
							name: 'p' + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(9, Cols_Minus = [
					...Cols_Minus,
					{
						// id: "td" + j + '-' + i,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols_Minus.length < state.colNum) {
					$$invalidate(9, Cols_Minus = [
						...Cols_Minus,
						{
							id: "t" + j,
							name: 'p' + j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	

	function handleReview(mode) {
		if (mode == 'c') {
			showAnswer("cans", "hideIcon");
		} else {
			showAnswer("yans", "showIcon");
		}
	}

	const writable_props = ['isReview', 'xml', 'showAns', 'uxml', 'editorState'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<GriddedPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('isReview' in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ('xml' in $$props) $$invalidate(16, xml = $$props.xml);
		if ('showAns' in $$props) $$invalidate(17, showAns = $$props.showAns);
		if ('uxml' in $$props) $$invalidate(15, uxml = $$props.uxml);
		if ('editorState' in $$props) $$invalidate(18, editorState = $$props.editorState);
	};

	$$self.$capture_state = () => ({
		l,
		ItemHelper,
		writable,
		AH,
		XMLToJSON,
		JSONToXML,
		onUserAnsChange,
		afterUpdate,
		beforeUpdate,
		onMount,
		GriddedHelper,
		isReview,
		xml,
		showAns,
		uxml,
		editorState,
		customIsReview,
		bool,
		userAns,
		ans,
		myAns,
		c,
		correctInc,
		isAnswerCorrect,
		answerStatus,
		authAnsSplit,
		incorrectCls,
		userXML,
		stateData,
		state,
		unsubscribe,
		loadModule,
		parseXMLPreview,
		parseUserAns,
		handleClick,
		setUserAns,
		handleClickCombo,
		setUserAnsCombo,
		rowValidation,
		highLight,
		ColsPre,
		firstRowItemPre,
		totalRows,
		totalCols,
		createdSheetRowPre,
		Cols_slash,
		slashFuncPre,
		Cols_decimal,
		decimalFloatingPre,
		setReview,
		getCorrect,
		unsetReview,
		showAnswer,
		Cols,
		Cols_Minus,
		plusMinusSignPre,
		handleReview
	});

	$$self.$inject_state = $$props => {
		if ('isReview' in $$props) $$invalidate(0, isReview = $$props.isReview);
		if ('xml' in $$props) $$invalidate(16, xml = $$props.xml);
		if ('showAns' in $$props) $$invalidate(17, showAns = $$props.showAns);
		if ('uxml' in $$props) $$invalidate(15, uxml = $$props.uxml);
		if ('editorState' in $$props) $$invalidate(18, editorState = $$props.editorState);
		if ('customIsReview' in $$props) $$invalidate(10, customIsReview = $$props.customIsReview);
		if ('bool' in $$props) bool = $$props.bool;
		if ('userAns' in $$props) userAns = $$props.userAns;
		if ('ans' in $$props) ans = $$props.ans;
		if ('myAns' in $$props) $$invalidate(1, myAns = $$props.myAns);
		if ('c' in $$props) c = $$props.c;
		if ('correctInc' in $$props) correctInc = $$props.correctInc;
		if ('isAnswerCorrect' in $$props) isAnswerCorrect = $$props.isAnswerCorrect;
		if ('answerStatus' in $$props) answerStatus = $$props.answerStatus;
		if ('authAnsSplit' in $$props) authAnsSplit = $$props.authAnsSplit;
		if ('incorrectCls' in $$props) incorrectCls = $$props.incorrectCls;
		if ('userXML' in $$props) userXML = $$props.userXML;
		if ('stateData' in $$props) stateData = $$props.stateData;
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
		if ('ColsPre' in $$props) $$invalidate(3, ColsPre = $$props.ColsPre);
		if ('totalRows' in $$props) $$invalidate(4, totalRows = $$props.totalRows);
		if ('totalCols' in $$props) $$invalidate(5, totalCols = $$props.totalCols);
		if ('Cols_slash' in $$props) $$invalidate(6, Cols_slash = $$props.Cols_slash);
		if ('Cols_decimal' in $$props) $$invalidate(7, Cols_decimal = $$props.Cols_decimal);
		if ('Cols' in $$props) $$invalidate(8, Cols = $$props.Cols);
		if ('Cols_Minus' in $$props) $$invalidate(9, Cols_Minus = $$props.Cols_Minus);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*isReview*/ 1) {
			 {
				if (isReview) {
					setReview();
				} else {
					unsetReview();
				}
			}
		}
	};

	return [
		isReview,
		myAns,
		state,
		ColsPre,
		totalRows,
		totalCols,
		Cols_slash,
		Cols_decimal,
		Cols,
		Cols_Minus,
		customIsReview,
		handleClick,
		handleClickCombo,
		rowValidation,
		handleReview,
		uxml,
		xml,
		showAns,
		editorState
	];
}

class GriddedPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				isReview: 0,
				xml: 16,
				showAns: 17,
				uxml: 15,
				editorState: 18
			},
			add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GriddedPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*isReview*/ ctx[0] === undefined && !('isReview' in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'isReview'");
		}

		if (/*xml*/ ctx[16] === undefined && !('xml' in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'xml'");
		}

		if (/*showAns*/ ctx[17] === undefined && !('showAns' in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'showAns'");
		}

		if (/*uxml*/ ctx[15] === undefined && !('uxml' in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'uxml'");
		}

		if (/*editorState*/ ctx[18] === undefined && !('editorState' in props)) {
			console_1.warn("<GriddedPreview> was created without expected prop 'editorState'");
		}
	}

	get isReview() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showAns() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<GriddedPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<GriddedPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default GriddedPreview;
//# sourceMappingURL=GriddedPreview-5019d66e.js.map
