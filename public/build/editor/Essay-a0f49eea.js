
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, V as Checkbox, P as binding_callbacks, Q as bind, v as validate_slots, o as onMount, A as AH, X as XMLToJSON, L as beforeUpdate, h as text, f as space, j as attr_dev, k as add_location, n as insert_dev, q as listen_dev, F as set_data_dev, G as prop_dev, x as detach_dev, H as run_all, c as create_component, m as mount_component, W as add_flush_callback, t as transition_in, a as transition_out, b as destroy_component } from './main-9d98459d.js';
import { s as sunEditor, p as plugins } from './index-1c557af6.js';

/* clsSMEssay/Essay.svelte generated by Svelte v3.29.0 */

const { console: console_1 } = globals;
const file = "clsSMEssay/Essay.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-fldz30-style";
	style.textContent = ".hero-unit.svelte-fldz30.svelte-fldz30{border:1px solid #ccc;width:84%;padding:18px!important;font-size:15px!important;margin-bottom:30px;font-weight:200;line-height:30px;color:inherit;background-color:#eeeeee;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}#essay_editorAuth.svelte-fldz30.svelte-fldz30{max-height:250px;height:250px;background-color:white;border-collapse:separate;border:1px solid rgb(204, 204, 204);padding:4px;box-sizing:content-box;-webkit-box-shadow:rgba(0, 0, 0, 0.0745098) 0px 1px 1px 0px inset;box-shadow:rgba(0, 0, 0, 0.0745098) 0px 1px 1px 0px inset;border-top-right-radius:3px;border-bottom-right-radius:3px;border-bottom-left-radius:3px;border-top-left-radius:3px;overflow:scroll;outline:none}.essay-container .upload-area.svelte-fldz30 #files_number.svelte-fldz30{width:115px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXNzYXkuc3ZlbHRlIiwic291cmNlcyI6WyJFc3NheS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBiZWZvcmVVcGRhdGUsb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBBSCwgWE1MVG9KU09OIH0gZnJvbSBcIi4uL2hlbHBlci9IZWxwZXJBSS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgU1VORURJVE9SIGZyb20gJ3N1bmVkaXRvcic7XG4gICAgaW1wb3J0IHBsdWdpbnMgZnJvbSAnc3VuRWRpdG9yL3NyYy9wbHVnaW5zJztcbiAgICBpbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJ3N2ZWx0ZS1tdWkvc3JjJztcbiAgICBleHBvcnQgbGV0IHhtbDtcbiAgICBleHBvcnQgbGV0IGdldENoaWxkWG1sO1xuICAgIGV4cG9ydCBsZXQgbDtcbiAgICBsZXQgaXNVcGxvYWQgPSBmYWxzZTtcbiAgICBsZXQgYXV0aG9yX3htbDtcbiAgICBjb25zdCBoZWFkaW5nQXJyYXkgPSBbe1wiZm9udFwiOiBcImZvbnRTaXplIDZcIixcInRleHRcIjogXCJIZWFkaW5nIDFcIn0sIHtcImZvbnRcIjogXCJmb250U2l6ZSA1XCIsXCJ0ZXh0XCI6IFwiSGVhZGluZyAyXCJ9LCB7XCJmb250XCI6IFwiZm9udFNpemUgNFwiLFwidGV4dFwiOiBcIkhlYWRpbmcgM1wifSx7XCJmb250XCI6IFwiZm9udFNpemUgM1wiLFwidGV4dFwiOiBcIkhlYWRpbmcgNFwifSx7XCJmb250XCI6IFwiZm9udFNpemUgMlwiLFwidGV4dFwiOiBcIkhlYWRpbmcgNVwifSx7XCJmb250XCI6IFwiZm9udFNpemUgMVwiLFwidGV4dFwiOiBcIkhlYWRpbmcgNlwifV07XG4gICAgbGV0IGVzc2F5QXV0aEVkaXRvcjtcbiAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgIGxldCBzdGF0ZSA9IHtcbiAgICAgICAgZmlsZXNfbnVtYmVyIDogMSxcbiAgICAgICAgY2RhdGEgOiB0cnVlLFxuICAgIH07XG4gICAgXG4gICAgb25Nb3VudCgoKT0+IHtcbiAgICAgICAgaW5pdEVkaXQoKTtcbiAgICAgICAgbGV0IGxpc3RlbnJUYXJnZXQgPSBBSC5maW5kKCcjU01fZXNzYXknLCAnYSxidXR0b24saW5wdXQsc2VsZWN0Jyk7XG4gICAgICAgIEFILmxpc3RlbkFsbChsaXN0ZW5yVGFyZ2V0LCBcImJsdXJcIiwgKGUpPT4geyBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHVwZGF0ZVhNTCg1MDApOyBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFILmxpc3RlbkFsbChsaXN0ZW5yVGFyZ2V0LCBcImtleXVwXCIsICgpPT4geyB1cGRhdGVYTUwoNTAwKTsgfSk7XG4gICAgICAgIC8vIEFILmxpc3RlbkFsbChsaXN0ZW5yVGFyZ2V0LCBcImtleWRvd25cIiwgKCk9PiB7IHVwZGF0ZVhNTCg1MDApOyB9KTtcblxuICAgICAgICBBSC5iaW5kKFwiI2ZpbGVzX251bWJlclwiLCAna2V5ZG93bicsIChlKT0+IHtcbiAgICAgICAgICAgIGlmIChlLndoaWNoICE9IDggJiYgZS53aGljaCAhPSAwICYmIChlLndoaWNoIDwgNDggfHwgZS53aGljaCA+IDU3KSkge1xuICAgICAgICAgICAgICAgIEFILnNlbGVjdChcIiNlcnJfdHh0XCIpLmlubmVySFRNTCA9IFwiRGlnaXRzIE9ubHlcIjtcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3RBbGwoXCIjZXJyX3R4dFwiLCAnc2hvdycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgKChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFIFwiKSA+IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnQvXCIpKSA+IC0xKSB7XG4gICAgICAgIC8vICAgICBqUXVlcnkoJyN1cGxvYWRDaGsnKS5rZXl1cChmdW5jdGlvbihlKSB7IGlmIChlLmtleUNvZGUgPT0gMzIpIHRoaXMuY2xpY2soKSB9KTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGxldCBwYXJzZWRYbWxOb2RlID0gQUgucGFyc2VIdG1sKHhtbCk7XG4gICAgICAgIGlmIChBSC5maW5kKHBhcnNlZFhtbE5vZGUsICdkZWZhdWx0JykgJiYgQUguZmluZChwYXJzZWRYbWxOb2RlLCAnZGVmYXVsdCcpLmdldEF0dHJpYnV0ZSgndHlwZScpID09IDEpIHtcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnVwbG9hZC1hcmVhJywgJ3JlbW92ZUNsYXNzJywgJ2gnKTtcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI3VwbG9hZENoaycpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coQUguZmluZChwYXJzZWRYbWxOb2RlLCAnZGVmYXVsdCcpLmdldEF0dHJpYnV0ZSgnZmlsZVR5cGVFeHRzJykpO1xuICAgICAgICAgICAgQUguc2VsZWN0KGAjY2hvb3NlX2V4dCBvcHRpb25bdmFsdWU9XCIke0FILmZpbmQocGFyc2VkWG1sTm9kZSwgJ2RlZmF1bHQnKS5nZXRBdHRyaWJ1dGUoJ2ZpbGVUeXBlRXh0cycpfVwiXWAsICdhdHRyJyx7c2VsZWN0ZWQ6ICdzZWxlY3RlZCd9KTtcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI2ZpbGVzX251bWJlcicpLnZhbHVlID0gQUguZmluZChwYXJzZWRYbWxOb2RlLCAnZGVmYXVsdCcpLmdldEF0dHJpYnV0ZSgnbGltaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRlWE1MKCk7XG4gICAgICAgIHBhcnNlWG1sKHhtbCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpbml0RWRpdCgpIHtcbiAgICAgICAgZXNzYXlBdXRoRWRpdG9yID0gU1VORURJVE9SLmNyZWF0ZSgnZXNzYXlfZWRpdG9yQXV0aCcsIHsgXG4gICAgICAgICAgICB3aWR0aDogJ2F1dG8nLFxuICAgICAgICAgICAgdG9vbGJhckNvbnRhaW5lcjogXCIjZXNzYXlUb29sYmFyXCIsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJXcml0ZSB0ZXh0IGhlcmUuXCIsXG4gICAgICAgICAgICBwbHVnaW5zOiBwbHVnaW5zLCBcbiAgICAgICAgICAgIHJlc2l6aW5nQmFyOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRoTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgYnV0dG9uTGlzdDogW1xuICAgICAgICAgICAgICAgIFsnZm9ybWF0QmxvY2snXSxcbiAgICAgICAgICAgICAgICBbJ2JvbGQnLCAnaXRhbGljJywgJ3VuZGVybGluZSddLFxuICAgICAgICAgICAgICAgIFsnbGluayddLFxuICAgICAgICAgICAgICAgIFsnbGlzdCcsICdvdXRkZW50JywgJ2luZGVudCcsICdhbGlnbiddLFxuICAgICAgICAgICAgICAgIFsncmVtb3ZlRm9ybWF0J10sXG4gICAgICAgICAgICBdIFxuICAgICAgICB9KTtcblxuICAgICAgICBlc3NheUF1dGhFZGl0b3Iub25DaGFuZ2UgPSAoY29udGVudCwgY29yZSk9PiB7XG4gICAgICAgICAgICB1cGRhdGVYTUwoMTAwMCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZXNzYXlBdXRoRWRpdG9yLm9uS2V5RG93biA9IChlLCBjb3JlKT0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gODYgfHwgZS5rZXlDb2RlID09IDY3KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlWE1MKDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC8vIGl0IGRldGVjdHMgYW55IGNoYW5nZSBpbiB4bWwuXG4gICAgLy8gYmVmb3JlVXBkYXRlKCgpPT4ge1xuICAgIC8vICAgICBpZiAoeG1sICE9IGF1dGhvcl94bWwpIHtcbiAgICAvLyAgICAgICAgIGF1dGhvcl94bWwgPSB4bWw7XG4gICAgLy8gICAgICAgICBwYXJzZVhtbCh4bWwpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfSk7XG4gICAgXG5cbiAgICAvLyBpZiB4bWwgY2hhbmdlIHRoZSBpdCB1cGRhdGVzIGNkYXRhXG4gICAgZnVuY3Rpb24gcGFyc2VYbWwoeG1sKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jZGF0YSkge1xuICAgICAgICAgICAgc3RhdGUuY2RhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBxeG1sID0gWE1MVG9KU09OKHhtbCk7XG4gICAgICAgICAgICBpZiAoIEFJLmlzVmFsaWQocXhtbCkgJiYgQUkuaXNWYWxpZChxeG1sLnNteG1sLmRlZmF1bHQpICkge1xuICAgICAgICAgICAgICAgIGVzc2F5QXV0aEVkaXRvci5zZXRDb250ZW50cyhxeG1sLnNteG1sLmRlZmF1bHQuX19jZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpdCBjaGVja3MgdGhlIG5vIC5vZiBmaWxlcyBmb3IgdXBsb2FkLiBcbiAgICBmdW5jdGlvbiBtYXhMZW5ndGhDaGVjayhlLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgc3RhdGUuZmlsZXNfbnVtYmVyID0gZS52YWx1ZTtcbiAgICAgICAgaWYgKGUud2hpY2ggIT0gOCAmJiBlLndoaWNoICE9IDAgJiYgKGUud2hpY2ggPCA0OCB8fCBlLndoaWNoID4gNTcpKSB7XG4gICAgICAgICAgICBBSC5zZWxlY3QoXCIjZXJyX3R4dFwiKS5pbm5lckhUTUwgPSBcIkRpZ2l0cyBPbmx5XCI7XG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoXCIjZXJyX3R4dFwiLCAnc2hvdycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXQgdXBkYXRlcyB0aGUgeG1sO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVhNTCh0aW1lLCBjb250ZW50KSB7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gY29udGVudCB8fCBlc3NheUF1dGhFZGl0b3IuZ2V0Q29udGVudHMoKTtcbiAgICAgICAgICAgIGxldCB4bWxEb20gPSBBSC5wYXJzZUh0bWwoeG1sKTtcbiAgICAgICAgICAgIGxldCBjaG9vc2VFeHRPcHQgPSBBSC5zZWxlY3RBbGwoXCIjY2hvb3NlX2V4dCBvcHRpb25cIiwgXCJzZWxlY3RlZFwiKVswXTtcbiAgICAgICAgICAgIGxldCBkZWZhdWx0RG9tID0geG1sRG9tLnF1ZXJ5U2VsZWN0b3IoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIGlmIChBSC5zZWxlY3QoXCIjdXBsb2FkQ2hrXCIpLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdERvbSkge1xuICAgICAgICAgICAgICAgICAgICBBSC5zZXRBdHRyKGRlZmF1bHREb20sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxlVHlwZUV4dHMnOiAoY2hvb3NlRXh0T3B0ID8gY2hvb3NlRXh0T3B0LnZhbHVlIDogXCJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGltaXQnOiBBSC5zZWxlY3QoJyNmaWxlc19udW1iZXInKS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVmSHRtbCA9IEFILnBhcnNlSHRtbChgPGRlZmF1bHQgdHlwZT1cIjFcIiBmaWxlVHlwZUV4dHM9XCIke2Nob29zZUV4dE9wdCA/IGNob29zZUV4dE9wdC52YWx1ZSA6ICcnfVwiIGxpbWl0PVwiJHtBSC5zZWxlY3QoJyNmaWxlc19udW1iZXInKS52YWx1ZX1cIj48L2RlZmF1bHQ+YCk7XG4gICAgICAgICAgICAgICAgICAgIHhtbERvbS5hcHBlbmRDaGlsZChkZWZIdG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHREb20pIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RG9tLnNldEF0dHJpYnV0ZSgndHlwZScsIDApXG4gICAgICAgICAgICAgICAgZGVmYXVsdERvbS5yZW1vdmVBdHRyaWJ1dGUoLi4uWydmaWxlVHlwZUV4dHMnLCAnbGltaXQnXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWZhdWx0RG9tKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdERvbS5pbm5lckhUTUwgPSBgPCEtLVtDREFUQVske3ZhbH1dXS0tPmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkZWZIdG1sID0gQUgucGFyc2VIdG1sKGA8ZGVmYXVsdCB0eXBlPVwiMFwiPjwhLS1bQ0RBVEFbJHt2YWx9XV0tLT48L2RlZmF1bHQ+YCk7XG4gICAgICAgICAgICAgICAgeG1sRG9tLmFwcGVuZENoaWxkKGRlZkh0bWwpO1xuICAgICAgICAgICAgICAgIC8veG1sRG9tLnF1ZXJ5U2VsZWN0b3IoJ2RlZmF1bHQnKS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coeG1sRG9tKTtcbiAgICAgICAgICAgIGF1dGhvcl94bWwgPSBmb3JtYXRYbWwoeG1sRG9tLm91dGVySFRNTCk7XG4gICAgICAgICAgICBnZXRDaGlsZFhtbChhdXRob3JfeG1sKTtcbiAgICAgICAgfSwgdGltZSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxtYWluIGlkPVwiU01fZXNzYXlcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaGVyby11bml0XCI+XG4gICAgICAgIDxkaXYgaWQ9XCJlc3NheVRvb2xiYXJcIiBjbGFzcz1cInN1bi1lZGl0b3JcIj48L2Rpdj5cbiAgICAgICAgPHRleHRhcmVhIGlkPVwiZXNzYXlfZWRpdG9yQXV0aFwiIGNsYXNzPVwidGV4dC1sZWZ0IGVkaXRvciBzdW4tZWRpdG9yLWVkaXRhYmxlXCI+PC90ZXh0YXJlYT5cbiAgICAgICAgPENoZWNrYm94IFx0XG4gICAgICAgICAgICBiaW5kOmNoZWNrZWQ9e2lzVXBsb2FkfVxuICAgICAgICAgICAgb246Y2xpY2s9e3VwZGF0ZVhNTH1cbiAgICAgICAgICAgIGlkPVwidXBsb2FkQ2hrXCJcbiAgICAgICAgICAgIG5hbWU9XCJ1cGxvYWRDaGtcIlxuICAgICAgICAgICAgY29sb3I9XCJwcmltYXJ5XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4+VXBsb2FkPC9zcGFuPlxuICAgICAgICA8L0NoZWNrYm94PlxuICAgICAgICB7I2lmIGlzVXBsb2FkfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVwbG9hZC1hcmVhIG10LTMgdGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJjaG9vc2VfZXh0XCIgY2xhc3M9XCJtYi0wIHB0LXNtMSBmb250MTRcIj57bC5maWxlX2V4dGVuc2lvbl90ZXh0fSA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS04XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IG5hbWU9XCJjaG9vc2VfZXh0XCIgaWQ9XCJjaG9vc2VfZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLW1kXCIgb246Ymx1cj1cInsoKT0+IHVwZGF0ZVhNTCg1MDApfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIqLnR4dCwqLmRvYywqLmRvY3gsKi5wZGYsKi5qcGcsKi5wbmcsKi5naWYsKi5ibXAsKi5qcGVnXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiPkFsbCgqLiopPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIioudHh0XCI+Ki50eHQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiKi5wZGZcIj4qLnBkZjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIqLmRvYywqLmRvY3hcIj4qLmRvYywqLmRvY3g8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiKi5kb2MsKi5kb2N4LCoucGRmXCI+Ki5kb2MsKi5kb2N4LCoucGRmPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiouanBnLCoucG5nLCouZ2lmLCouYm1wLCouanBlZ1wiPiouanBnLCoucG5nLCouZ2lmLCouYm1wLCouanBlZzwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgbXQtMlwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJmaWxlc19udW1iZXJcIiBjbGFzcz1cIm1iLTAgZm9udDE0IHB0LTFcIj57bC5udW1iZXJfb2ZfZmlsZXN9IDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLThcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLW1kIGZsb2F0LWxlZnQgZmlsZW51bWJlclwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJmaWxlc19udW1iZXJcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cImZpbGVzX251bWJlclwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzdGF0ZS5maWxlc19udW1iZXJ9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA9XCIxXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluPVwiMVwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heD1cIjEwXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlPXttYXhMZW5ndGhDaGVjay5iaW5kKHRoaXMsIDIpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZD1cInJlcXVpcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb250MTFcIj57bC55b3VfY2FuX3VwbG9hZH08L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuPC9tYWluPlxuPHN0eWxlPlxuICAgIC5oZXJvLXVuaXQge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xuICAgICAgICB3aWR0aDogODQlO1xuICAgICAgICBwYWRkaW5nOiAxOHB4IWltcG9ydGFudDtcbiAgICAgICAgZm9udC1zaXplOiAxNXB4IWltcG9ydGFudDtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMzBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDIwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDMwcHg7XG4gICAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlZWVlO1xuICAgICAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgICAgLW1vei1ib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICB9XG4gICAgI2Vzc2F5X2VkaXRvckF1dGgge1xuICAgICAgICBtYXgtaGVpZ2h0OiAyNTBweDtcbiAgICAgICAgaGVpZ2h0OiAyNTBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlci1jb2xsYXBzZTogc2VwYXJhdGU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYigyMDQsIDIwNCwgMjA0KTtcbiAgICAgICAgcGFkZGluZzogNHB4O1xuICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMDc0NTA5OCkgMHB4IDFweCAxcHggMHB4IGluc2V0O1xuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMDc0NTA5OCkgMHB4IDFweCAxcHggMHB4IGluc2V0O1xuICAgICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogM3B4O1xuICAgICAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogM3B4O1xuICAgICAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzcHg7XG4gICAgICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDNweDtcbiAgICAgICAgb3ZlcmZsb3c6IHNjcm9sbDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG4gICAgLmVzc2F5LWJ0biwgLmVzc2F5LWJ0bi1hZGQge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBhZGRpbmc6IDRweCA4cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBjb2xvcjogIzMzMzMzMztcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMXB4IDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNWY1O1xuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICNmZmZmZmYsICNlNmU2ZTYpO1xuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWdyYWRpZW50KGxpbmVhciwgMCAwLCAwIDEwMCUsIGZyb20oI2ZmZmZmZiksIHRvKCNlNmU2ZTYpKTtcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAjZmZmZmZmLCAjZTZlNmU2KTtcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgI2ZmZmZmZiwgI2U2ZTZlNik7XG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICNmZmZmZmYsICNlNmU2ZTYpO1xuICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXg7XG4gICAgICAgIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmZmZmZmZicsIGVuZENvbG9yc3RyPScjZmZlNmU2ZTYnLCBHcmFkaWVudFR5cGU9MCk7XG4gICAgICAgIGJvcmRlci1jb2xvcjogI2U2ZTZlNiAjZTZlNmU2ICNiZmJmYmY7XG4gICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpIHJnYmEoMCwgMCwgMCwgMC4xKSByZ2JhKDAsIDAsIDAsIDAuMjUpO1xuICAgICAgICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkID0gZmFsc2UpO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICBib3JkZXItYm90dG9tLWNvbG9yOiAjYjNiM2IzO1xuICAgICAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgLW1vei1ib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgLXdlYmtpdC1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAwIHJnYmEoMjU1LDI1NSwyNTUsLjIpLCAwIDFweCAycHggcmdiYSgwLDAsMCwuMDUpO1xuICAgICAgICAtbW96LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgyNTUsMjU1LDI1NSwuMiksIDAgMXB4IDJweCByZ2JhKDAsMCwwLC4wNSk7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgcmdiYSgyNTUsMjU1LDI1NSwuMiksIDAgMXB4IDJweCByZ2JhKDAsMCwwLC4wNSk7XG4gICAgfVxuICAgIC5kcm9wZG93bi1pdGVtIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBwYWRkaW5nOiA0cHggMTJweDtcbiAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGNvbG9yOiAjMjEyNTI5O1xuICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgYm9yZGVyOiAwO1xuICAgIH1cbiAgICAuZXNzYXktYnRuIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMTVweDtcbiAgICB9XG4gICAgLmVzc2F5LWNvbnRhaW5lciAudXBsb2FkLWFyZWEgI2ZpbGVzX251bWJlciB7XG4gICAgICAgIHdpZHRoOiAxMTVweDtcbiAgICB9XG4gICAgLmVzc2F5LWNvbnRhaW5lciB7XG4gICAgICAgIHdpZHRoOiA4OSU7XG4gICAgfVxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNk1JLFVBQVUsNEJBQUMsQ0FBQyxBQUNSLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDdEIsS0FBSyxDQUFFLEdBQUcsQ0FDVixPQUFPLENBQUUsSUFBSSxVQUFVLENBQ3ZCLFNBQVMsQ0FBRSxJQUFJLFVBQVUsQ0FDekIsYUFBYSxDQUFFLElBQUksQ0FDbkIsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsV0FBVyxDQUFFLElBQUksQ0FDakIsS0FBSyxDQUFFLE9BQU8sQ0FDZCxnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLHFCQUFxQixDQUFFLEdBQUcsQ0FDMUIsa0JBQWtCLENBQUUsR0FBRyxDQUN2QixhQUFhLENBQUUsR0FBRyxBQUN0QixDQUFDLEFBQ0QsaUJBQWlCLDRCQUFDLENBQUMsQUFDZixVQUFVLENBQUUsS0FBSyxDQUNqQixNQUFNLENBQUUsS0FBSyxDQUNiLGdCQUFnQixDQUFFLEtBQUssQ0FDdkIsZUFBZSxDQUFFLFFBQVEsQ0FDekIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDcEMsT0FBTyxDQUFFLEdBQUcsQ0FDWixVQUFVLENBQUUsV0FBVyxDQUN2QixrQkFBa0IsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQ2xFLFVBQVUsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQzFELHVCQUF1QixDQUFFLEdBQUcsQ0FDNUIsMEJBQTBCLENBQUUsR0FBRyxDQUMvQix5QkFBeUIsQ0FBRSxHQUFHLENBQzlCLHNCQUFzQixDQUFFLEdBQUcsQ0FDM0IsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLElBQUksQUFDakIsQ0FBQyxBQThDRCxnQkFBZ0IsQ0FBQywwQkFBWSxDQUFDLGFBQWEsY0FBQyxDQUFDLEFBQ3pDLEtBQUssQ0FBRSxLQUFLLEFBQ2hCLENBQUMifQ== */";
	append_dev(document.head, style);
}

// (155:8) <Checkbox               bind:checked={isUpload}             on:click={updateXML}             id="uploadChk"             name="uploadChk"             color="primary"         >
function create_default_slot(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Upload";
			add_location(span, file, 161, 12, 6223);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(155:8) <Checkbox               bind:checked={isUpload}             on:click={updateXML}             id=\\\"uploadChk\\\"             name=\\\"uploadChk\\\"             color=\\\"primary\\\"         >",
		ctx
	});

	return block;
}

// (164:8) {#if isUpload}
function create_if_block(ctx) {
	let div6;
	let div2;
	let div0;
	let label0;
	let t0_value = /*l*/ ctx[0].file_extension_text + "";
	let t0;
	let t1;
	let div1;
	let select;
	let option0;
	let option1;
	let option2;
	let option3;
	let option4;
	let option5;
	let t8;
	let div5;
	let div3;
	let label1;
	let t9_value = /*l*/ ctx[0].number_of_files + "";
	let t9;
	let t10;
	let div4;
	let input;
	let input_value_value;
	let t11;
	let small;
	let t12_value = /*l*/ ctx[0].you_can_upload + "";
	let t12;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div6 = element("div");
			div2 = element("div");
			div0 = element("div");
			label0 = element("label");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			select = element("select");
			option0 = element("option");
			option0.textContent = "All(*.*)";
			option1 = element("option");
			option1.textContent = "*.txt";
			option2 = element("option");
			option2.textContent = "*.pdf";
			option3 = element("option");
			option3.textContent = "*.doc,*.docx";
			option4 = element("option");
			option4.textContent = "*.doc,*.docx,*.pdf";
			option5 = element("option");
			option5.textContent = "*.jpg,*.png,*.gif,*.bmp,*.jpeg";
			t8 = space();
			div5 = element("div");
			div3 = element("div");
			label1 = element("label");
			t9 = text(t9_value);
			t10 = space();
			div4 = element("div");
			input = element("input");
			t11 = space();
			small = element("small");
			t12 = text(t12_value);
			attr_dev(label0, "for", "choose_ext");
			attr_dev(label0, "class", "mb-0 pt-sm1 font14");
			add_location(label0, file, 167, 24, 6440);
			attr_dev(div0, "class", "col-sm-3");
			add_location(div0, file, 166, 20, 6393);
			option0.__value = "*.txt,*.doc,*.docx,*.pdf,*.jpg,*.png,*.gif,*.bmp,*.jpeg";
			option0.value = option0.__value;
			option0.selected = "selected";
			add_location(option0, file, 171, 28, 6758);
			option1.__value = "*.txt";
			option1.value = option1.__value;
			add_location(option1, file, 172, 28, 6896);
			option2.__value = "*.pdf";
			option2.value = option2.__value;
			add_location(option2, file, 173, 28, 6961);
			option3.__value = "*.doc,*.docx";
			option3.value = option3.__value;
			add_location(option3, file, 174, 28, 7026);
			option4.__value = "*.doc,*.docx,*.pdf";
			option4.value = option4.__value;
			add_location(option4, file, 175, 28, 7105);
			option5.__value = "*.jpg,*.png,*.gif,*.bmp,*.jpeg";
			option5.value = option5.__value;
			add_location(option5, file, 176, 28, 7196);
			attr_dev(select, "name", "choose_ext");
			attr_dev(select, "id", "choose_ext");
			attr_dev(select, "class", "form-control form-control-md");
			add_location(select, file, 170, 24, 6618);
			attr_dev(div1, "class", "col-sm-8");
			add_location(div1, file, 169, 20, 6571);
			attr_dev(div2, "class", "row");
			add_location(div2, file, 165, 16, 6355);
			attr_dev(label1, "for", "files_number");
			attr_dev(label1, "class", "mb-0 font14 pt-1");
			add_location(label1, file, 182, 24, 7473);
			attr_dev(div3, "class", "col-sm-3");
			add_location(div3, file, 181, 20, 7426);
			attr_dev(input, "type", "number");
			attr_dev(input, "class", "form-control form-control-md float-left filenumber svelte-fldz30");
			attr_dev(input, "name", "files_number");
			attr_dev(input, "id", "files_number");
			input.value = input_value_value = /*state*/ ctx[2].files_number;
			attr_dev(input, "step", "1");
			attr_dev(input, "min", "1");
			attr_dev(input, "max", "10");
			input.required = "required";
			add_location(input, file, 185, 24, 7647);
			attr_dev(small, "class", "font11");
			add_location(small, file, 197, 24, 8220);
			attr_dev(div4, "class", "col-sm-8");
			add_location(div4, file, 184, 20, 7600);
			attr_dev(div5, "class", "row mt-2");
			add_location(div5, file, 180, 16, 7383);
			attr_dev(div6, "class", "upload-area mt-3 text-left svelte-fldz30");
			add_location(div6, file, 164, 12, 6298);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div6, anchor);
			append_dev(div6, div2);
			append_dev(div2, div0);
			append_dev(div0, label0);
			append_dev(label0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, select);
			append_dev(select, option0);
			append_dev(select, option1);
			append_dev(select, option2);
			append_dev(select, option3);
			append_dev(select, option4);
			append_dev(select, option5);
			append_dev(div6, t8);
			append_dev(div6, div5);
			append_dev(div5, div3);
			append_dev(div3, label1);
			append_dev(label1, t9);
			append_dev(div5, t10);
			append_dev(div5, div4);
			append_dev(div4, input);
			append_dev(div4, t11);
			append_dev(div4, small);
			append_dev(small, t12);

			if (!mounted) {
				dispose = [
					listen_dev(select, "blur", /*blur_handler*/ ctx[8], false, false, false),
					listen_dev(input, "change", /*maxLengthCheck*/ ctx[3].bind(this, 2), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*l*/ 1 && t0_value !== (t0_value = /*l*/ ctx[0].file_extension_text + "")) set_data_dev(t0, t0_value);
			if (dirty & /*l*/ 1 && t9_value !== (t9_value = /*l*/ ctx[0].number_of_files + "")) set_data_dev(t9, t9_value);

			if (dirty & /*state*/ 4 && input_value_value !== (input_value_value = /*state*/ ctx[2].files_number)) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty & /*l*/ 1 && t12_value !== (t12_value = /*l*/ ctx[0].you_can_upload + "")) set_data_dev(t12, t12_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div6);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(164:8) {#if isUpload}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div1;
	let div0;
	let t0;
	let textarea;
	let t1;
	let checkbox;
	let updating_checked;
	let t2;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[7].call(null, value);
	}

	let checkbox_props = {
		id: "uploadChk",
		name: "uploadChk",
		color: "primary",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*isUpload*/ ctx[1] !== void 0) {
		checkbox_props.checked = /*isUpload*/ ctx[1];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
	checkbox.$on("click", /*updateXML*/ ctx[4]);
	let if_block = /*isUpload*/ ctx[1] && create_if_block(ctx);

	const block = {
		c: function create() {
			main = element("main");
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			textarea = element("textarea");
			t1 = space();
			create_component(checkbox.$$.fragment);
			t2 = space();
			if (if_block) if_block.c();
			attr_dev(div0, "id", "essayToolbar");
			attr_dev(div0, "class", "sun-editor");
			add_location(div0, file, 152, 8, 5882);
			attr_dev(textarea, "id", "essay_editorAuth");
			attr_dev(textarea, "class", "text-left editor sun-editor-editable svelte-fldz30");
			add_location(textarea, file, 153, 8, 5939);
			attr_dev(div1, "class", "hero-unit svelte-fldz30");
			add_location(div1, file, 151, 4, 5850);
			attr_dev(main, "id", "SM_essay");
			add_location(main, file, 150, 0, 5825);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div1);
			append_dev(div1, div0);
			append_dev(div1, t0);
			append_dev(div1, textarea);
			append_dev(div1, t1);
			mount_component(checkbox, div1, null);
			append_dev(div1, t2);
			if (if_block) if_block.m(div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const checkbox_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked && dirty & /*isUpload*/ 2) {
				updating_checked = true;
				checkbox_changes.checked = /*isUpload*/ ctx[1];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);

			if (/*isUpload*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Essay", slots, []);
	let { xml } = $$props;
	let { getChildXml } = $$props;
	let { l } = $$props;
	let isUpload = false;
	let author_xml;

	const headingArray = [
		{
			"font": "fontSize 6",
			"text": "Heading 1"
		},
		{
			"font": "fontSize 5",
			"text": "Heading 2"
		},
		{
			"font": "fontSize 4",
			"text": "Heading 3"
		},
		{
			"font": "fontSize 3",
			"text": "Heading 4"
		},
		{
			"font": "fontSize 2",
			"text": "Heading 5"
		},
		{
			"font": "fontSize 1",
			"text": "Heading 6"
		}
	];

	let essayAuthEditor;
	let timer = null;
	let state = { files_number: 1, cdata: true };

	onMount(() => {
		initEdit();
		let listenrTarget = AH.find("#SM_essay", "a,button,input,select");

		AH.listenAll(listenrTarget, "blur", e => {
			console.log(e.target);
			updateXML(500);
		});

		// AH.listenAll(listenrTarget, "keyup", ()=> { updateXML(500); });
		// AH.listenAll(listenrTarget, "keydown", ()=> { updateXML(500); });
		AH.bind("#files_number", "keydown", e => {
			if (e.which != 8 && e.which != 0 && (e.which < 48 || e.which > 57)) {
				AH.select("#err_txt").innerHTML = "Digits Only";
				AH.selectAll("#err_txt", "show");
				return false;
			}
		});

		// if ((navigator.userAgent.indexOf("MSIE ") > -1 || navigator.userAgent.indexOf("Trident/")) > -1) {
		//     jQuery('#uploadChk').keyup(function(e) { if (e.keyCode == 32) this.click() });
		// }
		let parsedXmlNode = AH.parseHtml(xml);

		if (AH.find(parsedXmlNode, "default") && AH.find(parsedXmlNode, "default").getAttribute("type") == 1) {
			AH.selectAll(".upload-area", "removeClass", "h");
			AH.select("#uploadChk").checked = true;
			console.log(AH.find(parsedXmlNode, "default").getAttribute("fileTypeExts"));
			AH.select(`#choose_ext option[value="${AH.find(parsedXmlNode, "default").getAttribute("fileTypeExts")}"]`, "attr", { selected: "selected" });
			AH.select("#files_number").value = AH.find(parsedXmlNode, "default").getAttribute("limit");
		}

		//updateXML();
		parseXml(xml);
	});

	function initEdit() {
		essayAuthEditor = sunEditor.create("essay_editorAuth", {
			width: "auto",
			toolbarContainer: "#essayToolbar",
			placeholder: "Write text here.",
			plugins,
			resizingBar: false,
			showPathLabel: false,
			buttonList: [
				["formatBlock"],
				["bold", "italic", "underline"],
				["link"],
				["list", "outdent", "indent", "align"],
				["removeFormat"]
			]
		});

		essayAuthEditor.onChange = (content, core) => {
			updateXML(1000, content);
		};

		essayAuthEditor.onKeyDown = (e, core) => {
			if (e.keyCode == 86 || e.keyCode == 67) {
				updateXML(1000);
			}
		};
	}

	// // it detects any change in xml.
	// beforeUpdate(()=> {
	//     if (xml != author_xml) {
	//         author_xml = xml;
	//         parseXml(xml);
	//     }
	// });
	// if xml change the it updates cdata
	function parseXml(xml) {
		if (state.cdata) {
			$$invalidate(2, state.cdata = false, state);
			let qxml = XMLToJSON(xml);

			if (AI.isValid(qxml) && AI.isValid(qxml.smxml.default)) {
				essayAuthEditor.setContents(qxml.smxml.default.__cdata);
			}
		}
	}

	// it checks the no .of files for upload. 
	function maxLengthCheck(e, maxLength) {
		$$invalidate(2, state.files_number = e.value, state);

		if (e.which != 8 && e.which != 0 && (e.which < 48 || e.which > 57)) {
			AH.select("#err_txt").innerHTML = "Digits Only";
			AH.selectAll("#err_txt", "show");
			return false;
		}
	}

	// it updates the xml;
	function updateXML(time, content) {
		if (timer) {
			clearTimeout(timer);
		}

		timer = setTimeout(
			function () {
				let val = content || essayAuthEditor.getContents();
				let xmlDom = AH.parseHtml(xml);
				let chooseExtOpt = AH.selectAll("#choose_ext option", "selected")[0];
				let defaultDom = xmlDom.querySelector("default");

				if (AH.select("#uploadChk").checked) {
					if (defaultDom) {
						AH.setAttr(defaultDom, {
							"type": 1,
							"fileTypeExts": chooseExtOpt ? chooseExtOpt.value : "",
							"limit": AH.select("#files_number").value
						});
					} else {
						let defHtml = AH.parseHtml(`<default type="1" fileTypeExts="${chooseExtOpt ? chooseExtOpt.value : ""}" limit="${AH.select("#files_number").value}"></default>`);
						xmlDom.appendChild(defHtml);
					}
				} else if (defaultDom) {
					defaultDom.setAttribute("type", 0);
					defaultDom.removeAttribute(...["fileTypeExts", "limit"]);
				}

				if (defaultDom) {
					defaultDom.innerHTML = `<!--[CDATA[${val}]]-->`;
				} else {
					let defHtml = AH.parseHtml(`<default type="0"><!--[CDATA[${val}]]--></default>`);
					xmlDom.appendChild(defHtml);
				} //xmlDom.querySelector('default').innerHTML = '';

				//console.log(xmlDom);
				author_xml = formatXml(xmlDom.outerHTML);

				getChildXml(author_xml);
			},
			time
		);
	}

	const writable_props = ["xml", "getChildXml", "l"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Essay> was created with unknown prop '${key}'`);
	});

	function checkbox_checked_binding(value) {
		isUpload = value;
		$$invalidate(1, isUpload);
	}

	const blur_handler = () => updateXML(500);

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(5, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(6, getChildXml = $$props.getChildXml);
		if ("l" in $$props) $$invalidate(0, l = $$props.l);
	};

	$$self.$capture_state = () => ({
		beforeUpdate,
		onMount,
		AH,
		XMLToJSON,
		SUNEDITOR: sunEditor,
		plugins,
		Checkbox,
		xml,
		getChildXml,
		l,
		isUpload,
		author_xml,
		headingArray,
		essayAuthEditor,
		timer,
		state,
		initEdit,
		parseXml,
		maxLengthCheck,
		updateXML
	});

	$$self.$inject_state = $$props => {
		if ("xml" in $$props) $$invalidate(5, xml = $$props.xml);
		if ("getChildXml" in $$props) $$invalidate(6, getChildXml = $$props.getChildXml);
		if ("l" in $$props) $$invalidate(0, l = $$props.l);
		if ("isUpload" in $$props) $$invalidate(1, isUpload = $$props.isUpload);
		if ("author_xml" in $$props) author_xml = $$props.author_xml;
		if ("essayAuthEditor" in $$props) essayAuthEditor = $$props.essayAuthEditor;
		if ("timer" in $$props) timer = $$props.timer;
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		l,
		isUpload,
		state,
		maxLengthCheck,
		updateXML,
		xml,
		getChildXml,
		checkbox_checked_binding,
		blur_handler
	];
}

class Essay extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-fldz30-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { xml: 5, getChildXml: 6, l: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Essay",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[5] === undefined && !("xml" in props)) {
			console_1.warn("<Essay> was created without expected prop 'xml'");
		}

		if (/*getChildXml*/ ctx[6] === undefined && !("getChildXml" in props)) {
			console_1.warn("<Essay> was created without expected prop 'getChildXml'");
		}

		if (/*l*/ ctx[0] === undefined && !("l" in props)) {
			console_1.warn("<Essay> was created without expected prop 'l'");
		}
	}

	get xml() {
		throw new Error("<Essay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<Essay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<Essay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<Essay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get l() {
		throw new Error("<Essay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<Essay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Essay;
//# sourceMappingURL=Essay-a0f49eea.js.map
