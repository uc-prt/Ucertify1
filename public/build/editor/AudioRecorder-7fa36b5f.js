
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, v as validate_slots, o as onMount, A as AH, a8 as afterUpdate, X as XMLToJSON, I as beforeUpdate, y as l, e as element, f as space, h as text, j as attr_dev, k as add_location, U as src_url_equal, n as insert_dev, p as append_dev, a0 as select_option, q as listen_dev, F as prop_dev, B as noop, x as detach_dev, G as run_all } from './main-5eb2d8a9.js';

/* clsSMAudioRecorder\AudioRecorder.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file = "clsSMAudioRecorder\\AudioRecorder.svelte";

function create_fragment(ctx) {
	let div14;
	let div13;
	let div0;
	let b0;
	let t1;
	let t2_value = l.recording_warning + "";
	let t2;
	let t3;
	let div2;
	let div1;
	let b1;
	let t5;
	let textarea;
	let textarea_value_value;
	let textarea_aria_label_value;
	let t6;
	let div5;
	let div3;
	let label0;
	let b2;
	let t8;
	let select;
	let option0;
	let option1;
	let option2;
	let option3;
	let option4;
	let option5;
	let select_value_value;
	let t15;
	let div4;
	let input;
	let input_checked_value;
	let t16;
	let label1;
	let t18;
	let div12;
	let div11;
	let div6;
	let b3;
	let t20;
	let div9;
	let span0;
	let t22;
	let div7;
	let img0;
	let img0_src_value;
	let t23;
	let div8;
	let img1;
	let img1_src_value;
	let t24;
	let div10;
	let button0;
	let span1;
	let span1_title_value;
	let button0_aria_label_value;
	let t25;
	let button1;
	let span2;
	let button1_disabled_value;
	let button1_aria_label_value;
	let t26;
	let button2;
	let span3;
	let button2_disabled_value;
	let t27;
	let div21;
	let div20;
	let div19;
	let div18;
	let div15;
	let h4;
	let t29;
	let button3;
	let t31;
	let div16;
	let t32_value = l.modal_data + "";
	let t32;
	let t33;
	let div17;
	let button4;
	let t35;
	let button5;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div14 = element("div");
			div13 = element("div");
			div0 = element("div");
			b0 = element("b");
			b0.textContent = `${l.note_label}`;
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			div2 = element("div");
			div1 = element("div");
			b1 = element("b");
			b1.textContent = `${l.spoken_label}`;
			t5 = space();
			textarea = element("textarea");
			t6 = space();
			div5 = element("div");
			div3 = element("div");
			label0 = element("label");
			b2 = element("b");
			b2.textContent = `${l.select_lang}`;
			t8 = space();
			select = element("select");
			option0 = element("option");
			option0.textContent = `${l.english_us}`;
			option1 = element("option");
			option1.textContent = `${l.hindi_lang}`;
			option2 = element("option");
			option2.textContent = `${l.svenska}`;
			option3 = element("option");
			option3.textContent = `${l.suomi}`;
			option4 = element("option");
			option4.textContent = `${l.italiano}`;
			option5 = element("option");
			option5.textContent = `${l.english_in}`;
			t15 = space();
			div4 = element("div");
			input = element("input");
			t16 = space();
			label1 = element("label");
			label1.textContent = `${l.show_transcript}`;
			t18 = space();
			div12 = element("div");
			div11 = element("div");
			div6 = element("div");
			b3 = element("b");
			b3.textContent = `${l.audio_recorder}`;
			t20 = space();
			div9 = element("div");
			span0 = element("span");
			span0.textContent = `${l.starting_message}`;
			t22 = space();
			div7 = element("div");
			img0 = element("img");
			t23 = space();
			div8 = element("div");
			img1 = element("img");
			t24 = space();
			div10 = element("div");
			button0 = element("button");
			span1 = element("span");
			t25 = space();
			button1 = element("button");
			span2 = element("span");
			t26 = space();
			button2 = element("button");
			span3 = element("span");
			t27 = space();
			div21 = element("div");
			div20 = element("div");
			div19 = element("div");
			div18 = element("div");
			div15 = element("div");
			h4 = element("h4");
			h4.textContent = `${l.confirm_label}`;
			t29 = space();
			button3 = element("button");
			button3.textContent = "×";
			t31 = space();
			div16 = element("div");
			t32 = text(t32_value);
			t33 = space();
			div17 = element("div");
			button4 = element("button");
			button4.textContent = `${l.no_label}`;
			t35 = space();
			button5 = element("button");
			button5.textContent = `${l.yes_label}`;
			attr_dev(b0, "class", "noteColor bolder");
			add_location(b0, file, 415, 12, 20398);
			attr_dev(div0, "class", "col-12");
			attr_dev(div0, "tabindex", "0");
			attr_dev(div0, "aria-label", "Recording will end after 15 sec");
			add_location(div0, file, 414, 8, 20306);
			add_location(b1, file, 419, 30, 20566);
			attr_dev(div1, "class", "pb-2");
			add_location(div1, file, 419, 12, 20548);
			attr_dev(textarea, "id", "data_container");
			textarea.disabled = "disabled";
			attr_dev(textarea, "name", "cdata");
			attr_dev(textarea, "class", "form-control");
			attr_dev(textarea, "rows", "3");
			attr_dev(textarea, "cols", "75");
			textarea.value = textarea_value_value = /*state*/ ctx[3].cdata;

			attr_dev(textarea, "aria-label", textarea_aria_label_value = l.spoken_label + " " + (/*state*/ ctx[3].cdata != ""
			? /*state*/ ctx[3].cdata
			: "Nothing"));

			add_location(textarea, file, 420, 12, 20609);
			attr_dev(div2, "class", "col-6 py-2 mb-1");
			add_location(div2, file, 418, 8, 20505);
			add_location(b2, file, 424, 45, 21003);
			attr_dev(label0, "for", "language_select");
			add_location(label0, file, 424, 16, 20974);
			attr_dev(div3, "class", "select_label_container");
			add_location(div3, file, 423, 12, 20920);
			option0.__value = "en-US";
			option0.value = option0.__value;
			attr_dev(option0, "aria-label", "English United States");
			add_location(option0, file, 436, 16, 22085);
			option1.__value = "hi-IN";
			option1.value = option1.__value;
			attr_dev(option1, "aria-label", "Hindi");
			add_location(option1, file, 437, 16, 22183);
			option2.__value = "sv-SE";
			option2.value = option2.__value;
			attr_dev(option2, "aria-label", "Swedish");
			add_location(option2, file, 438, 16, 22265);
			option3.__value = "fi-FI";
			option3.value = option3.__value;
			attr_dev(option3, "aria-label", "Finnish");
			add_location(option3, file, 439, 16, 22346);
			option4.__value = "it-IT";
			option4.value = option4.__value;
			attr_dev(option4, "aria-label", "Italian");
			add_location(option4, file, 440, 16, 22425);
			option5.__value = "en-IN";
			option5.value = option5.__value;
			attr_dev(option5, "aria-label", "English UK");
			add_location(option5, file, 441, 16, 22507);
			attr_dev(select, "id", "language_select");
			attr_dev(select, "name", "language");
			attr_dev(select, "class", "disability_apply form-select form-control-sm");
			attr_dev(select, "aria-label", "Select the language for Recording");
			add_location(select, file, 426, 12, 21067);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "name", "showTranscript");
			attr_dev(input, "id", "showTranscript");
			attr_dev(input, "tabindex", "0");
			attr_dev(input, "class", "form-check-input");
			input.checked = input_checked_value = /*state*/ ctx[3].showTranscript;
			add_location(input, file, 444, 16, 22699);
			attr_dev(label1, "for", "showTranscript");
			attr_dev(label1, "class", "form-check-label");
			add_location(label1, file, 454, 16, 23091);
			attr_dev(div4, "class", "form-check form-check-inline transcript_container mt-3");
			add_location(div4, file, 443, 12, 22613);
			attr_dev(div5, "class", "col-6 py-2 mb-1");
			add_location(div5, file, 422, 8, 20877);
			add_location(b3, file, 460, 20, 23433);
			attr_dev(div6, "class", "p-2 tokenfield bg-light mb-3");
			attr_dev(div6, "aria-label", "Audio Recorder");
			attr_dev(div6, "tabindex", "0");
			add_location(div6, file, 459, 16, 23328);
			attr_dev(span0, "class", "align-self-center mx-auto authInitialState tokenfield");
			attr_dev(span0, "aria-label", "Click on record to start recording");
			attr_dev(span0, "tabindex", "0");
			add_location(span0, file, 463, 20, 23605);
			if (!src_url_equal(img0.src, img0_src_value = "//s3.amazonaws.com/jigyaasa_content_static/6ba174bf48e9b6dc8d8bd19d13c9caa9_000Awg.gif")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "recording is on");
			attr_dev(img0, "class", "w-100 h-100 img_fit");
			add_location(img0, file, 465, 24, 23905);
			attr_dev(div7, "class", "h authRecordingOn w-100 h-100 tokenfield");
			attr_dev(div7, "aria-label", "recording is on");
			attr_dev(div7, "tabindex", "0");
			add_location(div7, file, 464, 20, 23783);
			if (!src_url_equal(img1.src, img1_src_value = "//s3.amazonaws.com/jigyaasa_content_static/giphy_000AYi.gif")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "audio is playing");
			attr_dev(img1, "class", "w-100 h-100 img_fit");
			add_location(img1, file, 468, 24, 24228);
			attr_dev(div8, "class", "h authAudioPlaying w-100 h-100 tokenfield");
			attr_dev(div8, "aria-label", "Audio is playing");
			attr_dev(div8, "tabindex", "0");
			add_location(div8, file, 467, 20, 24104);
			attr_dev(div9, "class", "mx-auto text-danger recording_status initialState mb-3 d-flex mx-auto");
			add_location(div9, file, 462, 16, 23500);
			attr_dev(span1, "class", "icomoon-circle-2 s2 text-danger position-relative top1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "top");

			attr_dev(span1, "title", span1_title_value = /*state*/ ctx[3].status == "recording"
			? "Stop Recording"
			: "Start Recording");

			add_location(span1, file, 480, 24, 24881);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "name", "recordButton");
			attr_dev(button0, "id", "recordButton");
			attr_dev(button0, "class", "btn btn-light py-0");
			attr_dev(button0, "aria-label", button0_aria_label_value = "Click for " + /*areaLabelForRecordButton*/ ctx[2]);
			add_location(button0, file, 472, 20, 24511);
			attr_dev(span2, "class", "icomoon-24px-autoplay-4 position-relative top1");
			attr_dev(span2, "data-bs-toggle", "tooltip");
			attr_dev(span2, "data-bs-placement", "top");
			attr_dev(span2, "title", "Play Audio");
			add_location(span2, file, 491, 24, 25552);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "name", "stopButton");
			attr_dev(button1, "id", "stopButton");
			button1.disabled = button1_disabled_value = /*state*/ ctx[3].disabled;
			attr_dev(button1, "class", "btn btn-light py-0");
			attr_dev(button1, "aria-label", button1_aria_label_value = "Click for " + /*areaLabelForStopButton*/ ctx[0]);
			add_location(button1, file, 482, 20, 25137);
			attr_dev(span3, "class", "icomoon-new-24px-reset-1 position-relative top1");
			attr_dev(span3, "data-bs-toggle", "tooltip");
			attr_dev(span3, "data-bs-placement", "top");
			attr_dev(span3, "title", "Reset Data");
			add_location(span3, file, 504, 24, 26287);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "name", "resetButton");
			attr_dev(button2, "id", "resetButton");
			attr_dev(button2, "class", "btn btn-light py-0");
			button2.disabled = button2_disabled_value = /*state*/ ctx[3].isReset;
			attr_dev(button2, "data-bs-toggle", "modal");
			attr_dev(button2, "data-bs-target", "#authoring_confirm_modal");
			attr_dev(button2, "aria-label", "Click on this button for override the previous recording");
			add_location(button2, file, 493, 20, 25741);
			attr_dev(div10, "id", "controls_container");
			attr_dev(div10, "class", "bg-light text-center w-100 p-2");
			add_location(div10, file, 471, 16, 24421);
			attr_dev(div11, "class", "border rounded shadow-sm");
			add_location(div11, file, 458, 12, 23272);
			attr_dev(div12, "class", "col-12 col-md-8 offset-md-2");
			add_location(div12, file, 457, 8, 23217);
			attr_dev(div13, "class", "row");
			add_location(div13, file, 413, 4, 20279);
			attr_dev(div14, "id", "authoring_container");
			attr_dev(div14, "class", "container");
			add_location(div14, file, 412, 0, 20225);
			attr_dev(h4, "class", "modal-title tokenfield");
			attr_dev(h4, "aria-label", "Confirmation Dialog box");
			attr_dev(h4, "tabindex", "0");
			add_location(h4, file, 516, 20, 26819);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "class", "close");
			attr_dev(button3, "data-bs-dismiss", "modal");
			attr_dev(button3, "tabindex", "0");
			attr_dev(button3, "aria-label", "Click on this button for close the confirmation dialog box");
			add_location(button3, file, 517, 20, 26948);
			attr_dev(div15, "class", "modal-header");
			add_location(div15, file, 515, 16, 26771);
			attr_dev(div16, "class", "modal-body tokenfield");
			attr_dev(div16, "tabindex", "0");
			attr_dev(div16, "aria-label", /*areaLabelForModalContent*/ ctx[1]);
			attr_dev(div16, "id", "dialogBody");
			attr_dev(div16, "name", "dialogBody");
			add_location(div16, file, 519, 16, 27151);
			attr_dev(button4, "type", "button");
			attr_dev(button4, "class", "authoring_dismiss_modal btn btn-light pr-2");
			attr_dev(button4, "data-bs-dismiss", "modal");
			attr_dev(button4, "tabindex", "0");
			attr_dev(button4, "aria-label", "Click on this button for neglecte to override previous recording");
			add_location(button4, file, 523, 20, 27397);
			attr_dev(button5, "type", "button");
			attr_dev(button5, "class", "authoring_dismiss_done btn btn-primary");
			attr_dev(button5, "data-bs-dismiss", "modal");
			attr_dev(button5, "tabindex", "0");
			attr_dev(button5, "aria-label", "Click on this button for override the previous recording");
			add_location(button5, file, 524, 20, 27653);
			attr_dev(div17, "class", "modal-footer");
			add_location(div17, file, 522, 16, 27349);
			attr_dev(div18, "class", "modal-content");
			add_location(div18, file, 514, 12, 26726);
			attr_dev(div19, "class", "modal-dialog modal-md modal-dialog-centered");
			add_location(div19, file, 513, 8, 26655);
			attr_dev(div20, "class", "modal fade");
			attr_dev(div20, "id", "authoring_confirm_modal");
			add_location(div20, file, 512, 4, 26592);
			attr_dev(div21, "class", "authoring_modal_container container");
			add_location(div21, file, 511, 0, 26537);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div14, anchor);
			append_dev(div14, div13);
			append_dev(div13, div0);
			append_dev(div0, b0);
			append_dev(div0, t1);
			append_dev(div0, t2);
			append_dev(div13, t3);
			append_dev(div13, div2);
			append_dev(div2, div1);
			append_dev(div1, b1);
			append_dev(div2, t5);
			append_dev(div2, textarea);
			append_dev(div13, t6);
			append_dev(div13, div5);
			append_dev(div5, div3);
			append_dev(div3, label0);
			append_dev(label0, b2);
			append_dev(div5, t8);
			append_dev(div5, select);
			append_dev(select, option0);
			append_dev(select, option1);
			append_dev(select, option2);
			append_dev(select, option3);
			append_dev(select, option4);
			append_dev(select, option5);
			select_option(select, /*state*/ ctx[3].language);
			append_dev(div5, t15);
			append_dev(div5, div4);
			append_dev(div4, input);
			append_dev(div4, t16);
			append_dev(div4, label1);
			append_dev(div13, t18);
			append_dev(div13, div12);
			append_dev(div12, div11);
			append_dev(div11, div6);
			append_dev(div6, b3);
			append_dev(div11, t20);
			append_dev(div11, div9);
			append_dev(div9, span0);
			append_dev(div9, t22);
			append_dev(div9, div7);
			append_dev(div7, img0);
			append_dev(div9, t23);
			append_dev(div9, div8);
			append_dev(div8, img1);
			append_dev(div11, t24);
			append_dev(div11, div10);
			append_dev(div10, button0);
			append_dev(button0, span1);
			append_dev(div10, t25);
			append_dev(div10, button1);
			append_dev(button1, span2);
			append_dev(div10, t26);
			append_dev(div10, button2);
			append_dev(button2, span3);
			insert_dev(target, t27, anchor);
			insert_dev(target, div21, anchor);
			append_dev(div21, div20);
			append_dev(div20, div19);
			append_dev(div19, div18);
			append_dev(div18, div15);
			append_dev(div15, h4);
			append_dev(div15, t29);
			append_dev(div15, button3);
			append_dev(div18, t31);
			append_dev(div18, div16);
			append_dev(div16, t32);
			append_dev(div18, t33);
			append_dev(div18, div17);
			append_dev(div17, button4);
			append_dev(div17, t35);
			append_dev(div17, button5);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", /*handleChange*/ ctx[5], false, false, false),
					listen_dev(select, "change", /*handleChange*/ ctx[5], false, false, false),
					listen_dev(select, "blur", /*handleChange*/ ctx[5], false, false, false),
					listen_dev(input, "click", /*handleCheck*/ ctx[4], false, false, false),
					listen_dev(input, "keyup", /*adaKeyupCheckbox*/ ctx[11], false, false, false),
					listen_dev(button0, "click", /*startRecording*/ ctx[6], false, false, false),
					listen_dev(button1, "click", /*playRecording*/ ctx[8], false, false, false),
					listen_dev(button2, "click", /*setData*/ ctx[7], false, false, false),
					listen_dev(button4, "click", /*modalResponse*/ ctx[10], false, false, false),
					listen_dev(button5, "click", /*manageData*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*state*/ 8 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[3].cdata)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty & /*state*/ 8 && textarea_aria_label_value !== (textarea_aria_label_value = l.spoken_label + " " + (/*state*/ ctx[3].cdata != ""
			? /*state*/ ctx[3].cdata
			: "Nothing"))) {
				attr_dev(textarea, "aria-label", textarea_aria_label_value);
			}

			if (dirty & /*state*/ 8 && select_value_value !== (select_value_value = /*state*/ ctx[3].language)) {
				select_option(select, /*state*/ ctx[3].language);
			}

			if (dirty & /*state*/ 8 && input_checked_value !== (input_checked_value = /*state*/ ctx[3].showTranscript)) {
				prop_dev(input, "checked", input_checked_value);
			}

			if (dirty & /*state*/ 8 && span1_title_value !== (span1_title_value = /*state*/ ctx[3].status == "recording"
			? "Stop Recording"
			: "Start Recording")) {
				attr_dev(span1, "title", span1_title_value);
			}

			if (dirty & /*areaLabelForRecordButton*/ 4 && button0_aria_label_value !== (button0_aria_label_value = "Click for " + /*areaLabelForRecordButton*/ ctx[2])) {
				attr_dev(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty & /*state*/ 8 && button1_disabled_value !== (button1_disabled_value = /*state*/ ctx[3].disabled)) {
				prop_dev(button1, "disabled", button1_disabled_value);
			}

			if (dirty & /*areaLabelForStopButton*/ 1 && button1_aria_label_value !== (button1_aria_label_value = "Click for " + /*areaLabelForStopButton*/ ctx[0])) {
				attr_dev(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty & /*state*/ 8 && button2_disabled_value !== (button2_disabled_value = /*state*/ ctx[3].isReset)) {
				prop_dev(button2, "disabled", button2_disabled_value);
			}

			if (dirty & /*areaLabelForModalContent*/ 2) {
				attr_dev(div16, "aria-label", /*areaLabelForModalContent*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div14);
			if (detaching) detach_dev(t27);
			if (detaching) detach_dev(div21);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AudioRecorder', slots, []);
	let { getChildXml } = $$props;
	let { xml } = $$props;
	let recognition;
	let synth;
	let resetClicked = 'no';
	let areaLabelForStopButton;
	let areaLabelForModalContent;
	let areaLabelForRecordButton;
	let timeForRecording = 15;
	let manageTimer, voiceForSpeech;

	let state = {
		language: '',
		cdata: '',
		disabled: true,
		xml: '',
		status: '',
		isReset: true,
		showTranscript: false,
		counter: 0
	};

	onMount(() => {
		AH.enableBsAll("[data-bs-toggle='tooltip']", 'Tooltip', { container: 'body' });

		// stores the xml value in xml state
		$$invalidate(3, state.xml = xml, state);

		loadModule(xml);
	});

	// $: {
	//     if ((xml != state.xml)) {
	//         // stores the xml value in xml state
	// 		state.xml = xml;
	//         loadModule(xml);
	//     }
	// }
	afterUpdate(() => {
		if (xml != state.xml) {
			// stores the xml value in xml state
			$$invalidate(3, state.xml = xml, state);

			loadModule(xml);
		}
	});

	// load the module according to the value of xml
	function loadModule(loadXml) {
		// contains json data of xml
		let newXml = XMLToJSON(loadXml);

		// parses the xml data and update the xml
		parseXMLAuthoring(newXml);
	}

	// parses the xml data and update the xml
	function parseXMLAuthoring(MYXML) {
		try {
			// used to set the value of the state language from the value of language key of xml json
			($$invalidate(3, state.language = MYXML.smxml._language, state), $$invalidate(
				3,
				// used to set the value of the state cdata from the value of cdata key of xml json
				state.cdata = MYXML.smxml.__cdata,
				state
			), $$invalidate(
				3,
				// used to set the value of the state status from the value of status key of xml json
				state.status = MYXML.smxml._status,
				state
			), $$invalidate(
				3,
				// used to sets the value of the state disabled to false if the value of 'status' key of xml json is 'recordingStopped' otherwise 'true' 
				state.disabled = MYXML.smxml._status == 'recordingStopped' ? false : true,
				state
			), $$invalidate(
				3,
				// used to set the value of the state isReset from the value of isReset key of xml json
				state.isReset = MYXML.smxml._isReset == 'true' ? true : false,
				state
			), $$invalidate(
				3,
				// used to set the value of the state showTranscript from the value of showTranscript key of xml json
				state.showTranscript = MYXML.smxml._showTranscript == 'true' ? true : false,
				state
			));

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();
		} catch(event) {
			console.warn({
				'error': event.message,
				'function name': 'parseXMLAuthoring',
				'File name': 'AudioRecorder.svelte'
			});
		}
	}

	// assign the value of 'showTranscript' state to target elements checked value
	function handleCheck(event) {
		$$invalidate(3, state.showTranscript = event.target.checked, state);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();
	}

	// used for update the xml and disabled the element for language selection and to show the transcript checkbox
	function checkState() {
		//let state_timer = setTimeout(function() {
		// creates the xml according to the value of states: status, language, isReset, showTranscript and cdata
		let xml = '<smxml type="43" name="AudioRecorder" status="' + state.status + '" language="' + state.language + '" isReset="' + state.isReset + '" showTranscript="' + state.showTranscript + '"><!--[CDATA[' + state.cdata + ']]--></smxml>';

		// update the xml
		updateData(xml);

		state.status != ''
		? // disabled the show transcript checkbox and language select dropdown
			(AH.select('.disability_apply, #showTranscript').disabled = 'disabled', // makes label of language select and show transcript to look like disabled
			AH.selectAll('.transcript_container, .select_label_container label', 'addClass', 'disabledState'), // disabled transcript option
			AH.selectAll('.transcript_container,#showTranscript')[1].disabled = true)
		: // enables the show transcript checkbox and language select dropdown
			(AH.select('.disability_apply, #showTranscript').disabled = '', // makes label of language select and show transcript to look like active
			AH.selectAll('.transcript_container, .select_label_container label', 'removeClass', 'disabledState'), // enable transcript option
			AH.selectAll('.transcript_container,#showTranscript')[1].disabled = false);

		// used for screen reader to read the message when user reached on play button
		$$invalidate(0, areaLabelForStopButton = AH.select('#authoring_container #stopButton span').getAttribute('data-original-title'));

		// used for screen reader to read the message when user reached on record button
		$$invalidate(2, areaLabelForRecordButton = AH.select('#authoring_container #recordButton span').getAttribute('data-original-title'));

		// used for screen reader to read the message when user open the reset modalbox
		$$invalidate(1, areaLabelForModalContent = AH.select('#dialogBody').innerText);
	} // clear the previously set timeout
	//    clearTimeout(state_timer);

	//}, 100);
	// updates the xml
	function updateData(xml) {
		getChildXml(xml);
	}

	// used for handle the states value
	function handleChange(event) {
		$$invalidate(3, state[event.target.name] = event.target.value, state);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();
	}

	// starts the recording
	function startRecording() {
		switch (state.status) {
			case 'recording':
				// stops the recording when stop recording button clicked
				stopRecording();
				break;
			case 'recordingStopped':
				// for show the reset modalbox when start recording button clicked and recording is done previously
				AH.getBS('#authoring_confirm_modal', 'Modal').show();
				// focus on reset modalbox for screen reader purpose
				AH.select('.modal-body').focus();
				break;
			default:
				dictate();
				$$invalidate(3, state.status = 'recording', state);
				$$invalidate(3, state.isReset = false, state);
				// used for count the second after recording start
				$$invalidate(3, state.counter = 0, state);
				// used for automatically end the recording after 15 sec
				timeForRecording = 15;
				// ends recording after 15 sec
				manageTime();
				// used for update the xml and disabled the element for language selection and to show the transcript checkbox
				checkState();
				// adds the stop recording icon to record button
				AH.selectAll('#recordButton span', 'removeClass', ['icomoon-circle-2', 's2', 'text-danger']);
				AH.selectAll('#recordButton span', 'addClass', 'icomoon-24px-stop');
		}
	}

	//check that reset button is clicked or not
	function setData() {
		resetClicked = 'yes';
	}

	// called for speak the recorded text
	function playRecording() {
		if (window.speechSynthesis) {
			synth = window.speechSynthesis;

			if (state.cdata != '') {
				// hides the initial state image of the audio container and recording gif
				AH.selectAll('.authRecordingOn, .authInitialState', 'addClass', 'h');

				// shows the play gif
				AH.selectAll('.authAudioPlaying', 'removeClass', 'h');

				$$invalidate(3, state.disabled = true, state);

				// used for update the xml and disabled the element for language selection and to show the transcript checkbox
				checkState();

				// removes all utterances from the utterance queue.
				//synth.cancel();
				// speak the recorded text after defining some properties value and adding event
				isSpeechSynthesisSupported();
			} else {
				// hides the play and recording gif
				AH.selectAll('.authRecordingOn, .authAudioPaused', 'addClass', 'h');

				// shows the initial state image of the audio container
				AH.selectAll('.authInitialState', 'removeClass', 'h');

				// message for no data recorded
				AH.alert(l.no_data_msg);
			}
		} else {
			// message for not supported speechSynthesis
			AH.alert(l.browser_support_msg);

			return;
		}
	}

	// speak the text after defining some properties value and adding event
	function isSpeechSynthesisSupported() {
		// Returns a new SpeechSynthesisUtterance object instance
		let utterThis = new SpeechSynthesisUtterance(state.cdata);

		// sets the voice name according to the value of language state
		let voice_name = state.language == 'de-DE'
		? "Google Deutsch"
		: state.language == 'fr-FR'
			? "Google français"
			: state.language == 'es-ES'
				? "Google español"
				: state.language == 'hi-IN'
					? "Google हिन्दी"
					: state.language == 'ja-JP'
						? "Google 日本語"
						: state.language == 'ko-KR'
							? "Google 한국의"
							: state.language == 'it-IT'
								? "Google italiano"
								: "Google US English";

		// event listener fired when the utterance has finished being spoken.
		utterThis.addEventListener('end', function () {
			// hides the gif of recording and play
			AH.selectAll('.authAudioPlaying, .authRecordingOn', 'addClass', 'h');

			// shows the initial state image of the audio container
			AH.selectAll('.authInitialState', 'removeClass', 'h');

			// enables the play button
			$$invalidate(3, state.disabled = false, state);

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();

			// removes all utterances from the utterance queue.
			synth.cancel();
		});

		// array of available voices
		setTimeout(
			function () {
				voiceForSpeech = synth.getVoices();

				for (let index_no = 0; index_no < voiceForSpeech.length; index_no++) {
					if (voiceForSpeech[index_no].name == voice_name) {
						//  sets the voice that will be used to speak the utterance.
						utterThis.voice = voiceForSpeech[index_no];

						// sets the pitch at which the utterance will be spoken at.
						utterThis.pitch = 1;

						// sets the speed at which the utterance will be spoken at.
						utterThis.rate = 1;

						// sets the language of the utterance
						utterThis.lang = state.language;

						// adds an utterance to the utterance queue; it will be spoken when any other utterances queued before it have been spoken.
						synth.speak(utterThis);
					}
				}
			},
			10
		);
	}

	// stops capturing incoming audio
	function stopRecording() {
		// handles with gif of recording and play and icon of record button
		manageStopStatus();

		// clears the timeout which is started when recording stared
		clearTimeout(manageTimer);

		// change the value of status state
		$$invalidate(3, state.status = 'recordingStopped', state);

		// change the value of disabled state to false that enables the play button
		$$invalidate(3, state.disabled = false, state);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();

		// shows the initial view of the audio container
		AH.select('.authInitialState', 'removeClass', 'h');

		/* stops the speech recognition service from listening to incoming audio, and attempts to return a SpeechRecognitionResult using the audio captured so far. */
		recognition.stop();
	}

	// handles with gif of recording and play and icon of record button
	function manageStopStatus() {
		// hides the gif of recording and playing
		AH.selectAll('.authAudioPlaying, .authRecordingOn', 'addClass', 'h');

		// shows the initial state image of the audio container
		AH.selectAll('.authInitialState', 'removeClass', 'h');

		// removes the stop icon from recording button and adds start recording icon
		AH.selectAll('#recordButton span', 'removeClass', 'icomoon-24px-stop');

		AH.selectAll('#recordButton span', 'addClass', ['icomoon-circle-2', 's2', 'text-danger']);
	}

	// reset the previous recorded data
	function manageData() {
		// when reset modalbox open after click on reset button
		if (resetClicked == 'yes') {
			// reset the previously recorded data
			resetAudioData();

			resetClicked = 'no';
		} else {
			// when reset modalbox open after click on record button
			($$invalidate(3, state.cdata = '', state), $$invalidate(
				3,
				// disabled the play button
				state.disabled = true,
				state
			), $$invalidate(3, state.status = '', state));

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();

			let manage_data_timer = setTimeout(
				function () {
					// called for start the recording
					startRecording();

					// clear the timeout
					clearTimeout(manage_data_timer);
				},
				120
			);
		}
	}

	// checks if SpeechRecognition supported then defines some properties value of SpeechRecogniton and adds  some event listener as well
	function isSpeechRecognitionSupported() {
		if (window.webkitSpeechRecognition || window.SpeechRecognition) {
			window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;

			// creates new recognition object
			recognition = new SpeechRecognition();

			//Controls whether continuous results are returned for each recognition
			recognition.continuous = true;

			// returns interim results 
			recognition.interimResults = true;

			//  sets the language of the current SpeechRecognition
			recognition.lang = state.language;

			// used for globally access the recogniton 
			window.recognitionData = recognition;

			recognition.addEventListener('end', function () {
				if (!state.isReset) {
					// clears the timeout which is started when recording stared
					clearTimeout(manageTimer);

					// shows message that recording ended
					AH.alert(l.recording_ended);

					// handles with gif of recording and play and icon of record button
					manageStopStatus();

					// shows the initial state image of the audio container
					AH.selectAll('.authInitialState', 'removeClass', 'h');

					$$invalidate(3, state.status = 'recordingStopped', state);

					// enables the play button
					$$invalidate(3, state.disabled = false, state);

					// used for update the xml and disabled the element for language selection and to show the transcript checkbox
					checkState();
				}
			});
		} else {
			// shows the message that SpeechRecognition not supported
			AH.alert(l.browser_support_msg);

			return;
		}
	}

	// ends recording after 15 sec
	function manageTime() {
		timeForRecording = timeForRecording - 1;
		$$invalidate(3, state.counter = state.counter + 1, state);

		manageTimer = setTimeout(
			function () {
				if (timeForRecording > 0) {
					// calls again the method manageTime for counting the second value
					manageTime();
				} else {
					// stops the recording
					stopRecording();
				}
			},
			1000
		);
	}

	// start the listening to incoming audio, enables reset button, stores the recognised data to cdata state and update the xml 
	function dictate() {
		// checks if SpeechRecognition supported then defines some properties value of SpeechRecogniton and adds  some event listener as well
		isSpeechRecognitionSupported();

		/* starts the speech recognition service listening to incoming audio with intent to recognize grammars associated with the current SpeechRecognition. */
		recognition.start();

		// enables reset button
		AH.select('#resetButton').disabled = '';

		// hides the initial state image of the audio container and play gif
		AH.selectAll('.authAudioPlaying, .authInitialState', 'addClass', 'h');

		// shows recording gif
		AH.selectAll('.authRecordingOn', 'removeClass', 'h');

		/* The onresult property of the SpeechRecognition interface represents an event handler that will run when the speech recognition service returns a result — a word or phrase has been positively recognized and this has been communicated back to the app */
		recognition.onresult = event => {
			let speechToText = '';

			for (let index_no = 0; index_no < event.results.length; index_no = index_no + 1) {
				speechToText += event.results[index_no][0].transcript;
			}

			// sets the value of textual data into cdata state that is recognised by SpeechRecognition
			$$invalidate(3, state.cdata = speechToText.trim(), state);

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();
		};
	}

	// disabled the reset and play button and blanks the value of cdata and xml of state
	function resetAudioData() {
		// handles with gif of recording and play and icon of record button
		manageStopStatus();

		if (state.status == 'recording') {
			/* stops the speech recognition service from listening to incoming audio, and attempts to return a SpeechRecognitionResult using the audio captured so far. */
			recognition.stop();
		}

		$$invalidate(3, state.language = '', state);
		$$invalidate(3, state.cdata = '', state);
		$$invalidate(3, state.disabled = true, state);
		$$invalidate(3, state.xml = '', state);
		$$invalidate(3, state.status = '', state);
		$$invalidate(3, state.isReset = true, state);

		// clears the timeout which is started when recording stared
		clearTimeout(manageTimer);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();
	}

	// reset the data of 'resetClicked' to 'no' when no button is clicked in modalbox
	function modalResponse() {
		resetClicked = 'no';
	}

	// for ada checkbox
	function adaKeyupCheckbox(e) {
		if (e.keyCode == 13) {
			handleCheck(e);
		}
	}

	const writable_props = ['getChildXml', 'xml'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<AudioRecorder> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('getChildXml' in $$props) $$invalidate(12, getChildXml = $$props.getChildXml);
		if ('xml' in $$props) $$invalidate(13, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		beforeUpdate,
		XMLToJSON,
		AH,
		l,
		getChildXml,
		xml,
		recognition,
		synth,
		resetClicked,
		areaLabelForStopButton,
		areaLabelForModalContent,
		areaLabelForRecordButton,
		timeForRecording,
		manageTimer,
		voiceForSpeech,
		state,
		loadModule,
		parseXMLAuthoring,
		handleCheck,
		checkState,
		updateData,
		handleChange,
		startRecording,
		setData,
		playRecording,
		isSpeechSynthesisSupported,
		stopRecording,
		manageStopStatus,
		manageData,
		isSpeechRecognitionSupported,
		manageTime,
		dictate,
		resetAudioData,
		modalResponse,
		adaKeyupCheckbox
	});

	$$self.$inject_state = $$props => {
		if ('getChildXml' in $$props) $$invalidate(12, getChildXml = $$props.getChildXml);
		if ('xml' in $$props) $$invalidate(13, xml = $$props.xml);
		if ('recognition' in $$props) recognition = $$props.recognition;
		if ('synth' in $$props) synth = $$props.synth;
		if ('resetClicked' in $$props) resetClicked = $$props.resetClicked;
		if ('areaLabelForStopButton' in $$props) $$invalidate(0, areaLabelForStopButton = $$props.areaLabelForStopButton);
		if ('areaLabelForModalContent' in $$props) $$invalidate(1, areaLabelForModalContent = $$props.areaLabelForModalContent);
		if ('areaLabelForRecordButton' in $$props) $$invalidate(2, areaLabelForRecordButton = $$props.areaLabelForRecordButton);
		if ('timeForRecording' in $$props) timeForRecording = $$props.timeForRecording;
		if ('manageTimer' in $$props) manageTimer = $$props.manageTimer;
		if ('voiceForSpeech' in $$props) voiceForSpeech = $$props.voiceForSpeech;
		if ('state' in $$props) $$invalidate(3, state = $$props.state);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		areaLabelForStopButton,
		areaLabelForModalContent,
		areaLabelForRecordButton,
		state,
		handleCheck,
		handleChange,
		startRecording,
		setData,
		playRecording,
		manageData,
		modalResponse,
		adaKeyupCheckbox,
		getChildXml,
		xml
	];
}

class AudioRecorder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { getChildXml: 12, xml: 13 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AudioRecorder",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[12] === undefined && !('getChildXml' in props)) {
			console_1.warn("<AudioRecorder> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[13] === undefined && !('xml' in props)) {
			console_1.warn("<AudioRecorder> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<AudioRecorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<AudioRecorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<AudioRecorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<AudioRecorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default AudioRecorder;
//# sourceMappingURL=AudioRecorder-7fa36b5f.js.map
