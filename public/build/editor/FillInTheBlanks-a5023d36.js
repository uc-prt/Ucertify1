
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, P as Dialog, Q as binding_callbacks, R as bind, T as Snackbar, v as validate_slots, o as onMount, A as AH, a8 as onDestroy, X as XMLToJSON, V as Button, W as Checkbox, w as writable, e as element, f as space, c as create_component, j as attr_dev, k as add_location, l as set_style, n as insert_dev, p as append_dev, m as mount_component, q as listen_dev, Z as add_flush_callback, t as transition_in, a as transition_out, x as detach_dev, b as destroy_component, h as text, G as prop_dev, F as set_data_dev, C as validate_each_argument, K as destroy_each, a0 as set_input_value, H as run_all, r as group_outros, u as check_outros, E as is_function, z as empty, B as noop } from './main-f4f051c9.js';

/* clsSMFill\FillInTheBlanks.svelte generated by Svelte v3.40.2 */

const { Object: Object_1, console: console_1 } = globals;
const file = "clsSMFill\\FillInTheBlanks.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i];
	child_ctx[59] = list;
	child_ctx[60] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i];
	child_ctx[60] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i];
	child_ctx[62] = list;
	child_ctx[60] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i];
	child_ctx[63] = list;
	child_ctx[60] = i;
	return child_ctx;
}

// (1180:3) {#if state.fillInTheBlanksChoice == 1}
function create_if_block_6(ctx) {
	let div5;
	let div0;
	let checkbox0;
	let t0;
	let checkbox1;
	let t1;
	let input0;
	let input0_type_value;
	let input0_placeholder_value;
	let input0_value_value;
	let t2;
	let div1;
	let checkbox2;
	let t3;
	let input1;
	let input1_disabled_value;
	let input1_rowsmax_value;
	let input1_value_value;
	let t4;
	let div2;
	let t6;
	let div3;
	let t7_value = /*l*/ ctx[0].fill_text_help1 + "";
	let t7;
	let t8;
	let div4;
	let t9_value = /*l*/ ctx[0].fill_text_help2 + "";
	let t9;
	let current;

	checkbox0 = new Checkbox({
			props: {
				checked: /*state*/ ctx[2].codetype,
				id: "codetype",
				color: "primary",
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*click_handler*/ ctx[20]);

	checkbox1 = new Checkbox({
			props: {
				checked: /*state*/ ctx[2].numeric,
				id: "numeric",
				color: "primary",
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*click_handler_1*/ ctx[21]);

	checkbox2 = new Checkbox({
			props: {
				checked: /*state*/ ctx[2].customStyle,
				id: "customStyle",
				color: "primary",
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox2.$on("click", /*click_handler_2*/ ctx[22]);

	const block = {
		c: function create() {
			div5 = element("div");
			div0 = element("div");
			create_component(checkbox0.$$.fragment);
			t0 = space();
			create_component(checkbox1.$$.fragment);
			t1 = space();
			input0 = element("input");
			t2 = space();
			div1 = element("div");
			create_component(checkbox2.$$.fragment);
			t3 = space();
			input1 = element("input");
			t4 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t6 = space();
			div3 = element("div");
			t7 = text(t7_value);
			t8 = space();
			div4 = element("div");
			t9 = text(t9_value);
			attr_dev(div0, "class", "d-flex justify-content-start height36");
			add_location(div0, file, 1181, 5, 40037);
			attr_dev(input0, "id", "input1");
			set_style(input0, "margin", "5px");
			set_style(input0, "width", "99%");
			attr_dev(input0, "type", input0_type_value = /*state*/ ctx[2].numeric ? "number" : "text");

			attr_dev(input0, "placeholder", input0_placeholder_value = AH.select("#input1").innerHTML != ""
			? /*l*/ ctx[0].fill_text_placeholder
			: "");

			attr_dev(input0, "class", "form-control");
			input0.value = input0_value_value = /*state*/ ctx[2].input1;
			add_location(input0, file, 1199, 5, 40536);
			attr_dev(div1, "class", "d-flex justify-content-start ml-1 height36");
			add_location(div1, file, 1207, 5, 40815);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "multiline", "");
			attr_dev(input1, "id", "customStyleText");
			input1.disabled = input1_disabled_value = !/*state*/ ctx[2].customStyle;
			attr_dev(input1, "rowsmax", input1_rowsmax_value = 4);
			set_style(input1, "width", "99%");
			set_style(input1, "margin", "5px");
			attr_dev(input1, "class", "form-control ml-1");
			attr_dev(input1, "placeholder", "Custom Style");
			input1.value = input1_value_value = /*state*/ ctx[2].customStyleData;
			add_location(input1, file, 1217, 5, 41122);
			attr_dev(div2, "class", "text-danger font-weight-bold");
			add_location(div2, file, 1228, 5, 41410);
			attr_dev(div3, "class", "text-danger");
			set_style(div3, "padding-left", "15px");
			add_location(div3, file, 1229, 5, 41472);
			attr_dev(div4, "class", "text-danger");
			set_style(div4, "padding-left", "15px");
			add_location(div4, file, 1230, 5, 41555);
			add_location(div5, file, 1180, 4, 40025);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div0);
			mount_component(checkbox0, div0, null);
			append_dev(div0, t0);
			mount_component(checkbox1, div0, null);
			append_dev(div5, t1);
			append_dev(div5, input0);
			append_dev(div5, t2);
			append_dev(div5, div1);
			mount_component(checkbox2, div1, null);
			append_dev(div5, t3);
			append_dev(div5, input1);
			append_dev(div5, t4);
			append_dev(div5, div2);
			append_dev(div5, t6);
			append_dev(div5, div3);
			append_dev(div3, t7);
			append_dev(div5, t8);
			append_dev(div5, div4);
			append_dev(div4, t9);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 4) checkbox0_changes.checked = /*state*/ ctx[2].codetype;

			if (dirty[2] & /*$$scope*/ 4) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};
			if (dirty[0] & /*state*/ 4) checkbox1_changes.checked = /*state*/ ctx[2].numeric;

			if (dirty[2] & /*$$scope*/ 4) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);

			if (!current || dirty[0] & /*state*/ 4 && input0_type_value !== (input0_type_value = /*state*/ ctx[2].numeric ? "number" : "text")) {
				attr_dev(input0, "type", input0_type_value);
			}

			if (!current || dirty[0] & /*l*/ 1 && input0_placeholder_value !== (input0_placeholder_value = AH.select("#input1").innerHTML != ""
			? /*l*/ ctx[0].fill_text_placeholder
			: "")) {
				attr_dev(input0, "placeholder", input0_placeholder_value);
			}

			if (!current || dirty[0] & /*state*/ 4 && input0_value_value !== (input0_value_value = /*state*/ ctx[2].input1) && input0.value !== input0_value_value) {
				prop_dev(input0, "value", input0_value_value);
			}

			const checkbox2_changes = {};
			if (dirty[0] & /*state*/ 4) checkbox2_changes.checked = /*state*/ ctx[2].customStyle;

			if (dirty[2] & /*$$scope*/ 4) {
				checkbox2_changes.$$scope = { dirty, ctx };
			}

			checkbox2.$set(checkbox2_changes);

			if (!current || dirty[0] & /*state*/ 4 && input1_disabled_value !== (input1_disabled_value = !/*state*/ ctx[2].customStyle)) {
				prop_dev(input1, "disabled", input1_disabled_value);
			}

			if (!current || dirty[0] & /*state*/ 4 && input1_value_value !== (input1_value_value = /*state*/ ctx[2].customStyleData) && input1.value !== input1_value_value) {
				prop_dev(input1, "value", input1_value_value);
			}

			if ((!current || dirty[0] & /*l*/ 1) && t7_value !== (t7_value = /*l*/ ctx[0].fill_text_help1 + "")) set_data_dev(t7, t7_value);
			if ((!current || dirty[0] & /*l*/ 1) && t9_value !== (t9_value = /*l*/ ctx[0].fill_text_help2 + "")) set_data_dev(t9, t9_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);
			transition_in(checkbox2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			transition_out(checkbox2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_component(checkbox2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(1180:3) {#if state.fillInTheBlanksChoice == 1}",
		ctx
	});

	return block;
}

// (1183:6) <Checkbox           checked={state.codetype}         id="codetype"         color="primary"         on:click={()=> {state.codetype = !state.codetype }}        >
function create_default_slot_16(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Code Type";
			add_location(span, file, 1188, 7, 40264);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(1183:6) <Checkbox           checked={state.codetype}         id=\\\"codetype\\\"         color=\\\"primary\\\"         on:click={()=> {state.codetype = !state.codetype }}        >",
		ctx
	});

	return block;
}

// (1191:6) <Checkbox           checked={state.numeric}         id="numeric"         on:click={()=> {state.numeric = !state.numeric }}         color="primary"        >
function create_default_slot_15(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Numeric";
			add_location(span, file, 1196, 7, 40477);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(1191:6) <Checkbox           checked={state.numeric}         id=\\\"numeric\\\"         on:click={()=> {state.numeric = !state.numeric }}         color=\\\"primary\\\"        >",
		ctx
	});

	return block;
}

// (1209:6) <Checkbox           checked={state.customStyle}         id="customStyle"         on:click={()=> {state.customStyle = !state.customStyle}}         color="primary"        >
function create_default_slot_14(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "Enable Style";
			add_location(span, file, 1214, 7, 41058);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(1209:6) <Checkbox           checked={state.customStyle}         id=\\\"customStyle\\\"         on:click={()=> {state.customStyle = !state.customStyle}}         color=\\\"primary\\\"        >",
		ctx
	});

	return block;
}

// (1234:3) {#if state.fillInTheBlanksChoice == 2}
function create_if_block_5(ctx) {
	let div5;
	let t0;
	let div0;
	let button;
	let t1;
	let br;
	let t2;
	let div1;
	let t4;
	let div2;
	let t5_value = /*l*/ ctx[0].fill_dropdown_help1 + "";
	let t5;
	let t6;
	let div3;
	let t7_value = /*l*/ ctx[0].fill_dropdown_help2 + "";
	let t7;
	let t8;
	let div4;
	let t9_value = /*l*/ ctx[0].fill_dropdown_help3 + "";
	let t9;
	let current;
	let each_value_3 = /*state*/ ctx[2].fillDropDown;
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				"aria-label": "Add",
				class: "btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm float-right",
				style: "width: 120px; height: 30px; border: 1px solid #4285f4; color: #4285f4;text-transform: none;",
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addDropDownOption*/ ctx[4]);

	const block = {
		c: function create() {
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div0 = element("div");
			create_component(button.$$.fragment);
			t1 = space();
			br = element("br");
			t2 = space();
			div1 = element("div");
			div1.textContent = "* Note:";
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			div3 = element("div");
			t7 = text(t7_value);
			t8 = space();
			div4 = element("div");
			t9 = text(t9_value);
			attr_dev(div0, "class", "float-left mt-3 ml-1");
			add_location(div0, file, 1273, 5, 42793);
			add_location(br, file, 1285, 5, 43230);
			attr_dev(div1, "class", "text-danger mt-5 font-weight-bold ml-1");
			add_location(div1, file, 1286, 5, 43243);
			attr_dev(div2, "class", "text-danger ml-1");
			set_style(div2, "padding-left", "15px");
			add_location(div2, file, 1287, 5, 43315);
			attr_dev(div3, "class", "text-danger ml-1");
			set_style(div3, "padding-left", "15px");
			add_location(div3, file, 1288, 5, 43408);
			attr_dev(div4, "class", "text-danger ml-1");
			set_style(div4, "padding-left", "15px");
			add_location(div4, file, 1289, 5, 43501);
			add_location(div5, file, 1234, 4, 41702);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_dev(div5, t0);
			append_dev(div5, div0);
			mount_component(button, div0, null);
			append_dev(div5, t1);
			append_dev(div5, br);
			append_dev(div5, t2);
			append_dev(div5, div1);
			append_dev(div5, t4);
			append_dev(div5, div2);
			append_dev(div2, t5);
			append_dev(div5, t6);
			append_dev(div5, div3);
			append_dev(div3, t7);
			append_dev(div5, t8);
			append_dev(div5, div4);
			append_dev(div4, t9);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*removeDropDown, l, state*/ 2053) {
				each_value_3 = /*state*/ ctx[2].fillDropDown;
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div5, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			if ((!current || dirty[0] & /*l*/ 1) && t5_value !== (t5_value = /*l*/ ctx[0].fill_dropdown_help1 + "")) set_data_dev(t5, t5_value);
			if ((!current || dirty[0] & /*l*/ 1) && t7_value !== (t7_value = /*l*/ ctx[0].fill_dropdown_help2 + "")) set_data_dev(t7, t7_value);
			if ((!current || dirty[0] & /*l*/ 1) && t9_value !== (t9_value = /*l*/ ctx[0].fill_dropdown_help3 + "")) set_data_dev(t9, t9_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(1234:3) {#if state.fillInTheBlanksChoice == 2}",
		ctx
	});

	return block;
}

// (1236:5) {#each state.fillDropDown as data, i}
function create_each_block_3(ctx) {
	let div1;
	let div0;
	let input0;
	let input0_id_value;
	let input0_checked_value;
	let input0_value_value;
	let t0;
	let input1;
	let input1_id_value;
	let input1_placeholder_value;
	let input1_data_correct_value;
	let t1;
	let span;
	let div1_key_value;
	let mounted;
	let dispose;

	function input1_input_handler() {
		/*input1_input_handler*/ ctx[23].call(input1, /*each_value_3*/ ctx[63], /*i*/ ctx[60]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			input0 = element("input");
			t0 = space();
			input1 = element("input");
			t1 = space();
			span = element("span");
			attr_dev(input0, "type", "radio");
			attr_dev(input0, "id", input0_id_value = "correct" + /*i*/ ctx[60]);
			attr_dev(input0, "name", "dropdownCorrectAns");
			input0.checked = input0_checked_value = /*data*/ ctx[58].checked;
			input0.value = input0_value_value = /*data*/ ctx[58].value;
			add_location(input0, file, 1246, 8, 41992);
			set_style(div0, "float", "left");
			set_style(div0, "position", "relative");
			set_style(div0, "top", "10px");
			set_style(div0, "padding", "4px 8px 2px 0");
			set_style(div0, "border-radius", "4px");
			add_location(div0, file, 1237, 7, 41801);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", input1_id_value = "dropDown" + /*i*/ ctx[60]);
			set_style(input1, "margin", "5px");
			set_style(input1, "left", "8px");
			attr_dev(input1, "placeholder", input1_placeholder_value = /*l*/ ctx[0].fill_dropdown_placeholder);
			attr_dev(input1, "data-correct", input1_data_correct_value = "correct" + /*i*/ ctx[60]);
			attr_dev(input1, "class", "width10 form-control");
			add_location(input1, file, 1254, 7, 42185);
			attr_dev(span, "class", "icomoon-24px-delete-1 text-dark pointer position-relative s3 mt-2 pt-2 drop_down_delete");
			set_style(span, "height", "32px");
			set_style(span, "bottom", "1px");
			attr_dev(span, "data-bs-toggle", "tooltip");
			attr_dev(span, "title", "Delete");
			attr_dev(span, "tabindex", "0");
			add_location(span, file, 1263, 7, 42458);
			attr_dev(div1, "key", div1_key_value = /*i*/ ctx[60]);
			attr_dev(div1, "class", "d-flex ml-1");
			add_location(div1, file, 1236, 6, 41759);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, input0);
			append_dev(div1, t0);
			append_dev(div1, input1);
			set_input_value(input1, /*data*/ ctx[58].value);
			append_dev(div1, t1);
			append_dev(div1, span);

			if (!mounted) {
				dispose = [
					listen_dev(input1, "input", input1_input_handler),
					listen_dev(span, "click", /*removeDropDown*/ ctx[11].bind(this, /*i*/ ctx[60]), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 4 && input0_checked_value !== (input0_checked_value = /*data*/ ctx[58].checked)) {
				prop_dev(input0, "checked", input0_checked_value);
			}

			if (dirty[0] & /*state*/ 4 && input0_value_value !== (input0_value_value = /*data*/ ctx[58].value)) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (dirty[0] & /*l*/ 1 && input1_placeholder_value !== (input1_placeholder_value = /*l*/ ctx[0].fill_dropdown_placeholder)) {
				attr_dev(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty[0] & /*state*/ 4 && input1.value !== /*data*/ ctx[58].value) {
				set_input_value(input1, /*data*/ ctx[58].value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(1236:5) {#each state.fillDropDown as data, i}",
		ctx
	});

	return block;
}

// (1275:6) <Button          variant="fab"          color="primary"         aria-label="Add"         on:click={addDropDownOption}         class="btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm float-right"         style="width: 120px; height: 30px; border: 1px solid #4285f4; color: #4285f4;text-transform: none;"        >
function create_default_slot_13(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(1275:6) <Button          variant=\\\"fab\\\"          color=\\\"primary\\\"         aria-label=\\\"Add\\\"         on:click={addDropDownOption}         class=\\\"btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm float-right\\\"         style=\\\"width: 120px; height: 30px; border: 1px solid #4285f4; color: #4285f4;text-transform: none;\\\"        >",
		ctx
	});

	return block;
}

// (1293:3) {#if state.fillInTheBlanksChoice == 3}
function create_if_block_4(ctx) {
	let div8;
	let div1;
	let div0;
	let input;
	let t0;
	let label;
	let t1_value = /*l*/ ctx[0].drag_single + "";
	let t1;
	let t2;
	let t3;
	let div2;
	let button;
	let t4;
	let div3;
	let t6;
	let div4;
	let t7_value = /*l*/ ctx[0].fill_dragdrop_help1 + "";
	let t7;
	let t8;
	let div5;
	let t9_value = /*l*/ ctx[0].fill_dragdrop_help2 + "";
	let t9;
	let t10;
	let div6;
	let t11_value = /*l*/ ctx[0].fill_dragdrop_help3 + "";
	let t11;
	let t12;
	let div7;
	let t13_value = /*l*/ ctx[0].fill_dragdrop_help4 + "";
	let t13;
	let current;
	let mounted;
	let dispose;
	let each_value_2 = /*state*/ ctx[2].fillDragDrop;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				mini: true,
				"aria-label": "Add",
				class: "btn btn-outline-primary rounded position-relative bg-white shadow-sm float-right bottom0",
				style: "width: 120px;border: 1px solid #4285f4; color: #4285f4;text-transform: none; height:30px;",
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addDragDropOption*/ ctx[5].bind(this));

	const block = {
		c: function create() {
			div8 = element("div");
			div1 = element("div");
			div0 = element("div");
			input = element("input");
			t0 = space();
			label = element("label");
			t1 = text(t1_value);
			t2 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			div2 = element("div");
			create_component(button.$$.fragment);
			t4 = space();
			div3 = element("div");
			div3.textContent = "* Note:";
			t6 = space();
			div4 = element("div");
			t7 = text(t7_value);
			t8 = space();
			div5 = element("div");
			t9 = text(t9_value);
			t10 = space();
			div6 = element("div");
			t11 = text(t11_value);
			t12 = space();
			div7 = element("div");
			t13 = text(t13_value);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "name", "dragDropCorrectAns");
			attr_dev(input, "id", "drag_single");
			add_location(input, file, 1296, 7, 43829);
			attr_dev(div0, "class", "position-relative float-left rounded");
			set_style(div0, "top", "8px");
			set_style(div0, "padding", "4px 8px 2px 0");
			add_location(div0, file, 1295, 6, 43729);
			attr_dev(label, "for", "drag_single");
			attr_dev(label, "class", "font-weight-normal mb-0 form-check-label relative w-75");
			set_style(label, "top", "11px");
			set_style(label, "left", "5px");
			add_location(label, file, 1303, 6, 43991);
			set_style(div1, "clear", "both");
			attr_dev(div1, "class", "mb-3");
			add_location(div1, file, 1294, 5, 43683);
			attr_dev(div2, "class", "float-left mt-3");
			add_location(div2, file, 1335, 5, 45163);
			attr_dev(div3, "class", "text-danger mt-5 pt-3 font-weight-bold");
			add_location(div3, file, 1348, 5, 45617);
			attr_dev(div4, "class", "text-danger");
			set_style(div4, "padding-left", "15px");
			add_location(div4, file, 1349, 5, 45689);
			attr_dev(div5, "class", "text-danger");
			set_style(div5, "padding-left", "15px");
			add_location(div5, file, 1350, 5, 45777);
			attr_dev(div6, "class", "text-danger");
			set_style(div6, "padding-left", "15px");
			add_location(div6, file, 1351, 5, 45865);
			attr_dev(div7, "class", "text-danger");
			set_style(div7, "padding-left", "15px");
			add_location(div7, file, 1352, 5, 45953);
			attr_dev(div8, "class", "ml-1");
			add_location(div8, file, 1293, 4, 43658);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div8, anchor);
			append_dev(div8, div1);
			append_dev(div1, div0);
			append_dev(div0, input);
			input.checked = /*dragSingle*/ ctx[3];
			append_dev(div1, t0);
			append_dev(div1, label);
			append_dev(label, t1);
			append_dev(div8, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div8, null);
			}

			append_dev(div8, t3);
			append_dev(div8, div2);
			mount_component(button, div2, null);
			append_dev(div8, t4);
			append_dev(div8, div3);
			append_dev(div8, t6);
			append_dev(div8, div4);
			append_dev(div4, t7);
			append_dev(div8, t8);
			append_dev(div8, div5);
			append_dev(div5, t9);
			append_dev(div8, t10);
			append_dev(div8, div6);
			append_dev(div6, t11);
			append_dev(div8, t12);
			append_dev(div8, div7);
			append_dev(div7, t13);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[24]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*dragSingle*/ 8) {
				input.checked = /*dragSingle*/ ctx[3];
			}

			if ((!current || dirty[0] & /*l*/ 1) && t1_value !== (t1_value = /*l*/ ctx[0].drag_single + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*removeDragDrop, l, state*/ 1029) {
				each_value_2 = /*state*/ ctx[2].fillDragDrop;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div8, t3);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			if ((!current || dirty[0] & /*l*/ 1) && t7_value !== (t7_value = /*l*/ ctx[0].fill_dragdrop_help1 + "")) set_data_dev(t7, t7_value);
			if ((!current || dirty[0] & /*l*/ 1) && t9_value !== (t9_value = /*l*/ ctx[0].fill_dragdrop_help2 + "")) set_data_dev(t9, t9_value);
			if ((!current || dirty[0] & /*l*/ 1) && t11_value !== (t11_value = /*l*/ ctx[0].fill_dragdrop_help3 + "")) set_data_dev(t11, t11_value);
			if ((!current || dirty[0] & /*l*/ 1) && t13_value !== (t13_value = /*l*/ ctx[0].fill_dragdrop_help4 + "")) set_data_dev(t13, t13_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div8);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(1293:3) {#if state.fillInTheBlanksChoice == 3}",
		ctx
	});

	return block;
}

// (1306:5) {#each state.fillDragDrop as data, i}
function create_each_block_2(ctx) {
	let div1;
	let div0;
	let input0;
	let input0_checked_value;
	let input0_id_value;
	let input0_value_value;
	let t0;
	let input1;
	let input1_id_value;
	let input1_placeholder_value;
	let input1_data_correct_value;
	let t1;
	let span;
	let div1_key_value;
	let mounted;
	let dispose;

	function input1_input_handler_1() {
		/*input1_input_handler_1*/ ctx[25].call(input1, /*each_value_2*/ ctx[62], /*i*/ ctx[60]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			input0 = element("input");
			t0 = space();
			input1 = element("input");
			t1 = space();
			span = element("span");
			attr_dev(input0, "type", "checkbox");
			input0.checked = input0_checked_value = /*data*/ ctx[58].checked;
			attr_dev(input0, "name", "dragDropCorrectAns");
			attr_dev(input0, "id", input0_id_value = "correctDrag" + /*i*/ ctx[60]);
			input0.value = input0_value_value = /*data*/ ctx[58].value;
			add_location(input0, file, 1308, 8, 44344);
			attr_dev(div0, "class", "position-relative float-left rounded");
			set_style(div0, "top", "10px");
			set_style(div0, "padding", "4px 8px 2px 0");
			add_location(div0, file, 1307, 7, 44243);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "id", input1_id_value = "dragDrop" + /*i*/ ctx[60]);
			set_style(input1, "margin", "5px");
			set_style(input1, "left", "8px");
			attr_dev(input1, "placeholder", input1_placeholder_value = /*l*/ ctx[0].fill_dropdown_placeholder);
			attr_dev(input1, "class", "width10 form-control");
			attr_dev(input1, "data-correct", input1_data_correct_value = "correctDrag" + /*i*/ ctx[60]);
			add_location(input1, file, 1316, 7, 44543);
			attr_dev(span, "class", "icomoon-24px-delete-1 text-dark pointer position-relative s3 mt-2 pt-2 drag_drop_delete height32 bottom1");
			attr_dev(span, "data-bs-toggle", "tooltip");
			attr_dev(span, "data-bs-placement", "top");
			attr_dev(span, "title", "Delete");
			attr_dev(span, "tabindex", "0");
			add_location(span, file, 1325, 7, 44819);
			attr_dev(div1, "key", div1_key_value = /*i*/ ctx[60]);
			attr_dev(div1, "class", "d-flex clear-both");
			add_location(div1, file, 1306, 6, 44195);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, input0);
			append_dev(div1, t0);
			append_dev(div1, input1);
			set_input_value(input1, /*data*/ ctx[58].value);
			append_dev(div1, t1);
			append_dev(div1, span);

			if (!mounted) {
				dispose = [
					listen_dev(input1, "input", input1_input_handler_1),
					listen_dev(span, "click", /*removeDragDrop*/ ctx[10].bind(this, /*i*/ ctx[60]), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 4 && input0_checked_value !== (input0_checked_value = /*data*/ ctx[58].checked)) {
				prop_dev(input0, "checked", input0_checked_value);
			}

			if (dirty[0] & /*state*/ 4 && input0_value_value !== (input0_value_value = /*data*/ ctx[58].value)) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (dirty[0] & /*l*/ 1 && input1_placeholder_value !== (input1_placeholder_value = /*l*/ ctx[0].fill_dropdown_placeholder)) {
				attr_dev(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty[0] & /*state*/ 4 && input1.value !== /*data*/ ctx[58].value) {
				set_input_value(input1, /*data*/ ctx[58].value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(1306:5) {#each state.fillDragDrop as data, i}",
		ctx
	});

	return block;
}

// (1337:6) <Button          variant="fab"          color="primary"         mini         aria-label="Add"         on:click={addDragDropOption.bind(this)}         class="btn btn-outline-primary rounded position-relative bg-white shadow-sm float-right bottom0"         style="width: 120px;border: 1px solid #4285f4; color: #4285f4;text-transform: none; height:30px;"        >
function create_default_slot_12(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(1337:6) <Button          variant=\\\"fab\\\"          color=\\\"primary\\\"         mini         aria-label=\\\"Add\\\"         on:click={addDragDropOption.bind(this)}         class=\\\"btn btn-outline-primary rounded position-relative bg-white shadow-sm float-right bottom0\\\"         style=\\\"width: 120px;border: 1px solid #4285f4; color: #4285f4;text-transform: none; height:30px;\\\"        >",
		ctx
	});

	return block;
}

// (1356:3) {#if state.fillInTheBlanksChoice == 4}
function create_if_block_3(ctx) {
	let div;
	let h2;

	const block = {
		c: function create() {
			div = element("div");
			h2 = element("h2");
			h2.textContent = "Under Development";
			add_location(h2, file, 1356, 9, 46110);
			add_location(div, file, 1356, 4, 46105);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h2);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(1356:3) {#if state.fillInTheBlanksChoice == 4}",
		ctx
	});

	return block;
}

// (1359:3) {#if state.fillInTheBlanksChoice == 5}
function create_if_block_2(ctx) {
	let div4;
	let div3;
	let div0;
	let label0;
	let t1;
	let input0;
	let input0_placeholder_value;
	let input0_value_value;
	let t2;
	let div1;
	let label1;
	let t4;
	let input1;
	let input1_placeholder_value;
	let input1_value_value;
	let t5;
	let div2;
	let label2;
	let t7;
	let input2;
	let input2_placeholder_value;
	let input2_value_value;
	let t8;
	let each_value_1 = /*state*/ ctx[2].fillMultiLine;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = "Default Answer";
			t1 = space();
			input0 = element("input");
			t2 = space();
			div1 = element("div");
			label1 = element("label");
			label1.textContent = "Row";
			t4 = space();
			input1 = element("input");
			t5 = space();
			div2 = element("div");
			label2 = element("label");
			label2.textContent = "Column";
			t7 = space();
			input2 = element("input");
			t8 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(label0, "class", "mb-0 ml-2");
			attr_dev(label0, "for", "defaultMultiAns");
			add_location(label0, file, 1362, 7, 46294);
			attr_dev(input0, "type", "text");
			attr_dev(input0, "id", "defaultMultiAns");
			set_style(input0, "margin", "5px");
			set_style(input0, "width", "100%");

			attr_dev(input0, "placeholder", input0_placeholder_value = AH.select("#defaultMultiAns").innerHTML != ""
			? /*l*/ ctx[0].default_answer
			: "Default Answer");

			attr_dev(input0, "class", "form-control");
			input0.value = input0_value_value = /*state*/ ctx[2].fillMultiAttr.defaultAns;
			add_location(input0, file, 1363, 7, 46372);
			set_style(div0, "margin-right", "11px");
			set_style(div0, "width", "69%");
			add_location(div0, file, 1361, 6, 46241);
			attr_dev(label1, "class", "mb-0 ml-2");
			attr_dev(label1, "for", "rows");
			add_location(label1, file, 1373, 7, 46704);
			attr_dev(input1, "id", "rows");
			attr_dev(input1, "type", "number");
			attr_dev(input1, "min", "1");
			set_style(input1, "margin", "5px");
			set_style(input1, "width", "100px");

			attr_dev(input1, "placeholder", input1_placeholder_value = AH.select("#rows").innerHTML != ""
			? /*l*/ ctx[0].rows
			: "Rows");

			attr_dev(input1, "class", "form-control");
			input1.value = input1_value_value = /*state*/ ctx[2].fillMultiAttr.rows;
			add_location(input1, file, 1374, 7, 46760);
			add_location(div1, file, 1372, 6, 46690);
			attr_dev(label2, "class", "mb-0 ml-2");
			attr_dev(label2, "for", "cols");
			add_location(label2, file, 1385, 7, 47092);
			attr_dev(input2, "id", "cols");
			attr_dev(input2, "type", "number");
			attr_dev(input2, "min", "1");
			set_style(input2, "margin", "5px");
			set_style(input2, "width", "100px");

			attr_dev(input2, "placeholder", input2_placeholder_value = AH.select("#cols").innerHTML != ""
			? /*l*/ ctx[0].cols
			: "Cols");

			attr_dev(input2, "class", "form-control");
			input2.value = input2_value_value = /*state*/ ctx[2].fillMultiAttr.cols;
			add_location(input2, file, 1386, 7, 47151);
			attr_dev(div2, "class", "mr-sm2");
			add_location(div2, file, 1384, 6, 47063);
			attr_dev(div3, "class", "d-flex");
			add_location(div3, file, 1360, 5, 46213);
			add_location(div4, file, 1359, 4, 46201);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div3);
			append_dev(div3, div0);
			append_dev(div0, label0);
			append_dev(div0, t1);
			append_dev(div0, input0);
			append_dev(div3, t2);
			append_dev(div3, div1);
			append_dev(div1, label1);
			append_dev(div1, t4);
			append_dev(div1, input1);
			append_dev(div3, t5);
			append_dev(div3, div2);
			append_dev(div2, label2);
			append_dev(div2, t7);
			append_dev(div2, input2);
			append_dev(div4, t8);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div4, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 1 && input0_placeholder_value !== (input0_placeholder_value = AH.select("#defaultMultiAns").innerHTML != ""
			? /*l*/ ctx[0].default_answer
			: "Default Answer")) {
				attr_dev(input0, "placeholder", input0_placeholder_value);
			}

			if (dirty[0] & /*state*/ 4 && input0_value_value !== (input0_value_value = /*state*/ ctx[2].fillMultiAttr.defaultAns) && input0.value !== input0_value_value) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (dirty[0] & /*l*/ 1 && input1_placeholder_value !== (input1_placeholder_value = AH.select("#rows").innerHTML != ""
			? /*l*/ ctx[0].rows
			: "Rows")) {
				attr_dev(input1, "placeholder", input1_placeholder_value);
			}

			if (dirty[0] & /*state*/ 4 && input1_value_value !== (input1_value_value = /*state*/ ctx[2].fillMultiAttr.rows)) {
				prop_dev(input1, "value", input1_value_value);
			}

			if (dirty[0] & /*l*/ 1 && input2_placeholder_value !== (input2_placeholder_value = AH.select("#cols").innerHTML != ""
			? /*l*/ ctx[0].cols
			: "Cols")) {
				attr_dev(input2, "placeholder", input2_placeholder_value);
			}

			if (dirty[0] & /*state*/ 4 && input2_value_value !== (input2_value_value = /*state*/ ctx[2].fillMultiAttr.cols)) {
				prop_dev(input2, "value", input2_value_value);
			}

			if (dirty[0] & /*state, l*/ 5) {
				each_value_1 = /*state*/ ctx[2].fillMultiLine;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div4, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(1359:3) {#if state.fillInTheBlanksChoice == 5}",
		ctx
	});

	return block;
}

// (1398:5) {#each state.fillMultiLine as data,i}
function create_each_block_1(ctx) {
	let div;
	let input;
	let input_value_value;
	let input_placeholder_value;
	let t;
	let div_key_value;

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t = space();
			attr_dev(input, "type", "text");
			attr_dev(input, "id", "multiLineCorrect");
			attr_dev(input, "multiline", "");
			set_style(input, "margin", "5px");
			set_style(input, "width", "98%");
			input.value = input_value_value = /*data*/ ctx[58].value;
			attr_dev(input, "placeholder", input_placeholder_value = /*l*/ ctx[0].fill_text_placeholder);
			attr_dev(input, "class", "form-control");
			add_location(input, file, 1399, 7, 47523);
			attr_dev(div, "key", div_key_value = /*i*/ ctx[60]);
			add_location(div, file, 1398, 6, 47501);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4 && input_value_value !== (input_value_value = /*data*/ ctx[58].value) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*l*/ 1 && input_placeholder_value !== (input_placeholder_value = /*l*/ ctx[0].fill_text_placeholder)) {
				attr_dev(input, "placeholder", input_placeholder_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(1398:5) {#each state.fillMultiLine as data,i}",
		ctx
	});

	return block;
}

// (1413:3) {#if state.fillInTheBlanksChoice == 6}
function create_if_block_1(ctx) {
	let div5;
	let t0;
	let div0;
	let button;
	let t1;
	let div1;
	let t3;
	let div2;
	let t4_value = /*l*/ ctx[0].fill_math_help1 + "";
	let t4;
	let t5;
	let div3;
	let t6_value = /*l*/ ctx[0].fill_math_help2 + "";
	let t6;
	let t7;
	let div4;
	let t8_value = /*l*/ ctx[0].fill_math_help3 + "";
	let t8;
	let current;
	let each_value = /*state*/ ctx[2].fillEquation;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				"aria-label": "Add",
				class: "rounded btn btn-outline-primary top5 position-relative bg-white shadow-sm float-right p-0",
				style: "width: 120px; height:30px; text-transform: none; border: 1px solid #4285f4; color: #4285f4;",
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addMathEquation*/ ctx[6]);

	const block = {
		c: function create() {
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div0 = element("div");
			create_component(button.$$.fragment);
			t1 = space();
			div1 = element("div");
			div1.textContent = "* Note:";
			t3 = space();
			div2 = element("div");
			t4 = text(t4_value);
			t5 = space();
			div3 = element("div");
			t6 = text(t6_value);
			t7 = space();
			div4 = element("div");
			t8 = text(t8_value);
			attr_dev(div0, "class", "float-left mt-2 ml-1");
			add_location(div0, file, 1464, 5, 49646);
			attr_dev(div1, "class", "text-danger mt-5 pt-4 font-weight-bold ml-1");
			add_location(div1, file, 1476, 5, 50084);
			attr_dev(div2, "class", "text-danger");
			set_style(div2, "padding-left", "15px");
			add_location(div2, file, 1477, 5, 50161);
			attr_dev(div3, "class", "text-danger");
			set_style(div3, "padding-left", "15px");
			add_location(div3, file, 1478, 5, 50245);
			attr_dev(div4, "class", "text-danger");
			set_style(div4, "padding-left", "15px");
			add_location(div4, file, 1479, 5, 50329);
			add_location(div5, file, 1413, 4, 47856);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_dev(div5, t0);
			append_dev(div5, div0);
			mount_component(button, div0, null);
			append_dev(div5, t1);
			append_dev(div5, div1);
			append_dev(div5, t3);
			append_dev(div5, div2);
			append_dev(div2, t4);
			append_dev(div5, t5);
			append_dev(div5, div3);
			append_dev(div3, t6);
			append_dev(div5, t7);
			append_dev(div5, div4);
			append_dev(div4, t8);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*removeMathEquation, state, latexEdit, addEditable, l*/ 28677) {
				each_value = /*state*/ ctx[2].fillEquation;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div5, t0);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			if ((!current || dirty[0] & /*l*/ 1) && t4_value !== (t4_value = /*l*/ ctx[0].fill_math_help1 + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty[0] & /*l*/ 1) && t6_value !== (t6_value = /*l*/ ctx[0].fill_math_help2 + "")) set_data_dev(t6, t6_value);
			if ((!current || dirty[0] & /*l*/ 1) && t8_value !== (t8_value = /*l*/ ctx[0].fill_math_help3 + "")) set_data_dev(t8, t8_value);
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(1413:3) {#if state.fillInTheBlanksChoice == 6}",
		ctx
	});

	return block;
}

// (1427:8) <Button            variant="fab"            color="primary"           aria-label="Response"           on:click={addEditable.bind(this,i)}           class="rounded btn btn-outline-primary top5 position-relative bg-white shadow-sm float-right p-0"           style="width: 120px; height:30px; text-transform: none; border: 1px solid #4285f4; color: #4285f4;"          >
function create_default_slot_11(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("+ Response");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(1427:8) <Button            variant=\\\"fab\\\"            color=\\\"primary\\\"           aria-label=\\\"Response\\\"           on:click={addEditable.bind(this,i)}           class=\\\"rounded btn btn-outline-primary top5 position-relative bg-white shadow-sm float-right p-0\\\"           style=\\\"width: 120px; height:30px; text-transform: none; border: 1px solid #4285f4; color: #4285f4;\\\"          >",
		ctx
	});

	return block;
}

// (1415:5) {#each state.fillEquation as data, i}
function create_each_block(ctx) {
	let div5;
	let div0;
	let input;
	let input_id_value;
	let input_placeholder_value;
	let t0;
	let div1;
	let button;
	let t1;
	let div3;
	let div2;
	let span0;
	let span0_id_value;
	let t2;
	let div4;
	let span1;
	let div5_key_value;
	let current;
	let mounted;
	let dispose;

	function input_input_handler() {
		/*input_input_handler*/ ctx[26].call(input, /*each_value*/ ctx[59], /*i*/ ctx[60]);
	}

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				"aria-label": "Response",
				class: "rounded btn btn-outline-primary top5 position-relative bg-white shadow-sm float-right p-0",
				style: "width: 120px; height:30px; text-transform: none; border: 1px solid #4285f4; color: #4285f4;",
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addEditable*/ ctx[13].bind(this, /*i*/ ctx[60]));

	const block = {
		c: function create() {
			div5 = element("div");
			div0 = element("div");
			input = element("input");
			t0 = space();
			div1 = element("div");
			create_component(button.$$.fragment);
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			span0 = element("span");
			t2 = space();
			div4 = element("div");
			span1 = element("span");
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = "input" + /*i*/ ctx[60]);
			attr_dev(input, "class", "form-control latexInp position-relative top3 width-xl1 ml-1");
			attr_dev(input, "placeholder", input_placeholder_value = /*l*/ ctx[0].fill_text_placeholder);
			add_location(input, file, 1417, 8, 47994);
			attr_dev(div0, "class", "col-sm-7 pl-0");
			add_location(div0, file, 1416, 7, 47957);
			attr_dev(div1, "class", "col-sm-3 pt-1");
			add_location(div1, file, 1425, 7, 48243);
			attr_dev(span0, "id", span0_id_value = "latexEdit" + /*i*/ ctx[60]);
			attr_dev(span0, "variant", "contained");
			attr_dev(span0, "class", "icomoon-24px-edit-1 text-dark pointer position-relative s3 bottom1");
			attr_dev(span0, "data-bs-toggle", "tooltip");
			attr_dev(span0, "data-bs-placement", "top");
			attr_dev(span0, "title", "Edit");
			add_location(span0, file, 1439, 9, 48836);
			attr_dev(div2, "class", "latexEditButton d-inline-block");
			attr_dev(div2, "tabindex", "0");
			set_style(div2, "height", "28px");
			add_location(div2, file, 1438, 8, 48747);
			attr_dev(div3, "class", "col-sm-1 pt-2");
			add_location(div3, file, 1437, 7, 48710);
			attr_dev(span1, "class", "icomoon-24px-delete-1 text-dark pointer position-relative s3 mathematical_delete");
			set_style(span1, "height", "28px");
			set_style(span1, "bottom", "1px");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-bs-placement", "top");
			attr_dev(span1, "title", "Delete");
			attr_dev(span1, "tabindex", "0");
			add_location(span1, file, 1452, 8, 49250);
			attr_dev(div4, "class", "col-sm-1 pt-2");
			add_location(div4, file, 1451, 7, 49213);
			attr_dev(div5, "key", div5_key_value = /*i*/ ctx[60]);
			attr_dev(div5, "class", "row ml-0 mb-2");
			add_location(div5, file, 1415, 6, 47913);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div0);
			append_dev(div0, input);
			set_input_value(input, /*data*/ ctx[58].value);
			append_dev(div5, t0);
			append_dev(div5, div1);
			mount_component(button, div1, null);
			append_dev(div5, t1);
			append_dev(div5, div3);
			append_dev(div3, div2);
			append_dev(div2, span0);
			append_dev(div5, t2);
			append_dev(div5, div4);
			append_dev(div4, span1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", input_input_handler),
					listen_dev(span0, "click", /*latexEdit*/ ctx[14].bind(this, /*i*/ ctx[60]), false, false, false),
					listen_dev(
						span1,
						"click",
						function () {
							if (is_function(/*removeMathEquation*/ ctx[12].bind(this, /*data*/ ctx[58].id))) /*removeMathEquation*/ ctx[12].bind(this, /*data*/ ctx[58].id).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*l*/ 1 && input_placeholder_value !== (input_placeholder_value = /*l*/ ctx[0].fill_text_placeholder)) {
				attr_dev(input, "placeholder", input_placeholder_value);
			}

			if (dirty[0] & /*state*/ 4 && input.value !== /*data*/ ctx[58].value) {
				set_input_value(input, /*data*/ ctx[58].value);
			}

			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(button);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(1415:5) {#each state.fillEquation as data, i}",
		ctx
	});

	return block;
}

// (1466:6) <Button          variant="fab"          color="primary"         aria-label="Add"         on:click={addMathEquation}         class="rounded btn btn-outline-primary top5 position-relative bg-white shadow-sm float-right p-0"         style="width: 120px; height:30px; text-transform: none; border: 1px solid #4285f4; color: #4285f4;"        >
function create_default_slot_10(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("+ Add option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(1466:6) <Button          variant=\\\"fab\\\"          color=\\\"primary\\\"         aria-label=\\\"Add\\\"         on:click={addMathEquation}         class=\\\"rounded btn btn-outline-primary top5 position-relative bg-white shadow-sm float-right p-0\\\"         style=\\\"width: 120px; height:30px; text-transform: none; border: 1px solid #4285f4; color: #4285f4;\\\"        >",
		ctx
	});

	return block;
}

// (1164:1) <Dialog class="remove_right_margin" width="700" bind:visible={state.open} style="background-color:#fff; border-radius: 5px;">
function create_default_slot_9(ctx) {
	let h4;
	let div1;
	let div0;
	let t0_value = /*l*/ ctx[0].fill_header + "";
	let t0;
	let t1;
	let div3;
	let div2;
	let button0;
	let t2;
	let button0_class_value;
	let button0_value_value;
	let t3;
	let button1;
	let t4;
	let button1_class_value;
	let button1_value_value;
	let t5;
	let button2;
	let t6;
	let button2_class_value;
	let button2_value_value;
	let t7;
	let button3;
	let t8;
	let button3_class_value;
	let button3_value_value;
	let t9;
	let button4;
	let t10;
	let button4_class_value;
	let button4_value_value;
	let t11;
	let div4;
	let t12;
	let t13;
	let t14;
	let t15;
	let t16;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*state*/ ctx[2].fillInTheBlanksChoice == 1 && create_if_block_6(ctx);
	let if_block1 = /*state*/ ctx[2].fillInTheBlanksChoice == 2 && create_if_block_5(ctx);
	let if_block2 = /*state*/ ctx[2].fillInTheBlanksChoice == 3 && create_if_block_4(ctx);
	let if_block3 = /*state*/ ctx[2].fillInTheBlanksChoice == 4 && create_if_block_3(ctx);
	let if_block4 = /*state*/ ctx[2].fillInTheBlanksChoice == 5 && create_if_block_2(ctx);
	let if_block5 = /*state*/ ctx[2].fillInTheBlanksChoice == 6 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			h4 = element("h4");
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			button0 = element("button");
			t2 = text("Text");
			t3 = space();
			button1 = element("button");
			t4 = text("Drop downs");
			t5 = space();
			button2 = element("button");
			t6 = text("Drag & drop");
			t7 = space();
			button3 = element("button");
			t8 = text("Multiline");
			t9 = space();
			button4 = element("button");
			t10 = text("Mathematical equations");
			t11 = space();
			div4 = element("div");
			if (if_block0) if_block0.c();
			t12 = space();
			if (if_block1) if_block1.c();
			t13 = space();
			if (if_block2) if_block2.c();
			t14 = space();
			if (if_block3) if_block3.c();
			t15 = space();
			if (if_block4) if_block4.c();
			t16 = space();
			if (if_block5) if_block5.c();
			add_location(div0, file, 1166, 4, 38846);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file, 1165, 3, 38796);
			attr_dev(button0, "type", "button");

			attr_dev(button0, "class", button0_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 1
			? 'active'
			: ''));

			button0.value = button0_value_value = 1;
			add_location(button0, file, 1170, 5, 38972);
			attr_dev(button1, "type", "button");

			attr_dev(button1, "class", button1_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 2
			? 'active'
			: ''));

			button1.value = button1_value_value = 2;
			add_location(button1, file, 1171, 5, 39143);
			attr_dev(button2, "type", "button");

			attr_dev(button2, "class", button2_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 3
			? 'active'
			: ''));

			button2.value = button2_value_value = 3;
			add_location(button2, file, 1172, 5, 39320);
			attr_dev(button3, "type", "button");

			attr_dev(button3, "class", button3_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 5
			? 'active'
			: ''));

			button3.value = button3_value_value = 5;
			add_location(button3, file, 1173, 5, 39498);
			attr_dev(button4, "type", "button");

			attr_dev(button4, "class", button4_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 6
			? 'active'
			: ''));

			button4.value = button4_value_value = 6;
			add_location(button4, file, 1174, 5, 39674);
			attr_dev(div2, "class", "btn-group mt-2 ml-0");
			add_location(div2, file, 1169, 4, 38932);
			attr_dev(div3, "class", "left10 position-relative");
			add_location(div3, file, 1168, 3, 38888);
			attr_dev(h4, "class", "mt-0 font21");
			add_location(h4, file, 1164, 2, 38767);
			attr_dev(div4, "id", "responseDialog");
			set_style(div4, "height", "320px");
			set_style(div4, "overflow-y", "auto");
			set_style(div4, "padding-right", "20px");
			add_location(div4, file, 1178, 2, 39892);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, div1);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(h4, t1);
			append_dev(h4, div3);
			append_dev(div3, div2);
			append_dev(div2, button0);
			append_dev(button0, t2);
			append_dev(div2, t3);
			append_dev(div2, button1);
			append_dev(button1, t4);
			append_dev(div2, t5);
			append_dev(div2, button2);
			append_dev(button2, t6);
			append_dev(div2, t7);
			append_dev(div2, button3);
			append_dev(button3, t8);
			append_dev(div2, t9);
			append_dev(div2, button4);
			append_dev(button4, t10);
			insert_dev(target, t11, anchor);
			insert_dev(target, div4, anchor);
			if (if_block0) if_block0.m(div4, null);
			append_dev(div4, t12);
			if (if_block1) if_block1.m(div4, null);
			append_dev(div4, t13);
			if (if_block2) if_block2.m(div4, null);
			append_dev(div4, t14);
			if (if_block3) if_block3.m(div4, null);
			append_dev(div4, t15);
			if (if_block4) if_block4.m(div4, null);
			append_dev(div4, t16);
			if (if_block5) if_block5.m(div4, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*updateDialog*/ ctx[7].bind(this, 1), false, false, false),
					listen_dev(button1, "click", /*updateDialog*/ ctx[7].bind(this, 2), false, false, false),
					listen_dev(button2, "click", /*updateDialog*/ ctx[7].bind(this, 3), false, false, false),
					listen_dev(button3, "click", /*updateDialog*/ ctx[7].bind(this, 5), false, false, false),
					listen_dev(button4, "click", /*updateDialog*/ ctx[7].bind(this, 6), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*l*/ 1) && t0_value !== (t0_value = /*l*/ ctx[0].fill_header + "")) set_data_dev(t0, t0_value);

			if (!current || dirty[0] & /*state*/ 4 && button0_class_value !== (button0_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 1
			? 'active'
			: ''))) {
				attr_dev(button0, "class", button0_class_value);
			}

			if (!current || dirty[0] & /*state*/ 4 && button1_class_value !== (button1_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 2
			? 'active'
			: ''))) {
				attr_dev(button1, "class", button1_class_value);
			}

			if (!current || dirty[0] & /*state*/ 4 && button2_class_value !== (button2_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 3
			? 'active'
			: ''))) {
				attr_dev(button2, "class", button2_class_value);
			}

			if (!current || dirty[0] & /*state*/ 4 && button3_class_value !== (button3_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 5
			? 'active'
			: ''))) {
				attr_dev(button3, "class", button3_class_value);
			}

			if (!current || dirty[0] & /*state*/ 4 && button4_class_value !== (button4_class_value = "btn btn-light px-2 " + (/*state*/ ctx[2].fillInTheBlanksChoice == 6
			? 'active'
			: ''))) {
				attr_dev(button4, "class", button4_class_value);
			}

			if (/*state*/ ctx[2].fillInTheBlanksChoice == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div4, t12);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].fillInTheBlanksChoice == 2) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div4, t13);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].fillInTheBlanksChoice == 3) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_4(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div4, t14);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[2].fillInTheBlanksChoice == 4) {
				if (if_block3) ; else {
					if_block3 = create_if_block_3(ctx);
					if_block3.c();
					if_block3.m(div4, t15);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*state*/ ctx[2].fillInTheBlanksChoice == 5) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_2(ctx);
					if_block4.c();
					if_block4.m(div4, t16);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*state*/ ctx[2].fillInTheBlanksChoice == 6) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*state*/ 4) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_1(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(div4, null);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block5);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block5);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t11);
			if (detaching) detach_dev(div4);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(1164:1) <Dialog class=\\\"remove_right_margin\\\" width=\\\"700\\\" bind:visible={state.open} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (1485:3) <Button      on:click={handleClose}      unelevated={true}      outlined={true}      class="text-capitalize"      color="#ccc"     >
function create_default_slot_8(ctx) {
	let t_value = /*l*/ ctx[0].cancel + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 1 && t_value !== (t_value = /*l*/ ctx[0].cancel + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(1485:3) <Button      on:click={handleClose}      unelevated={true}      outlined={true}      class=\\\"text-capitalize\\\"      color=\\\"#ccc\\\"     >",
		ctx
	});

	return block;
}

// (1492:3) <Button      on:click={storeAns}      unelevated={true}      outlined={true}      class="text-capitalize"      color="primary"     >
function create_default_slot_7(ctx) {
	let t_value = /*l*/ ctx[0].done + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 1 && t_value !== (t_value = /*l*/ ctx[0].done + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(1492:3) <Button      on:click={storeAns}      unelevated={true}      outlined={true}      class=\\\"text-capitalize\\\"      color=\\\"primary\\\"     >",
		ctx
	});

	return block;
}

// (1484:2) 
function create_footer_slot_1(ctx) {
	let div;
	let button0;
	let t;
	let button1;
	let current;

	button0 = new Button({
			props: {
				unelevated: true,
				outlined: true,
				class: "text-capitalize",
				color: "#ccc",
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleClose*/ ctx[8]);

	button1 = new Button({
			props: {
				unelevated: true,
				outlined: true,
				class: "text-capitalize",
				color: "primary",
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*storeAns*/ ctx[9]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file, 1483, 2, 50442);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t);
			mount_component(button1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[0] & /*l*/ 1 | dirty[2] & /*$$scope*/ 4) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[0] & /*l*/ 1 | dirty[2] & /*$$scope*/ 4) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot_1.name,
		type: "slot",
		source: "(1484:2) ",
		ctx
	});

	return block;
}

// (1509:3) <Checkbox       checked = {state.case_sensetive}      on:click={handleSetting.bind(this, "1")}      color="primary"     >
function create_default_slot_6(ctx) {
	let span;
	let t_value = /*l*/ ctx[0].case_sensetive + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file, 1513, 4, 51228);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 1 && t_value !== (t_value = /*l*/ ctx[0].case_sensetive + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(1509:3) <Checkbox       checked = {state.case_sensetive}      on:click={handleSetting.bind(this, \\\"1\\\")}      color=\\\"primary\\\"     >",
		ctx
	});

	return block;
}

// (1517:3) <Checkbox       checked = {state.ignore_spcl_char}      on:click={handleSetting.bind(this, "2")}      color="primary"     >
function create_default_slot_5(ctx) {
	let span;
	let t_value = /*l*/ ctx[0].ignore_spcl_char + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file, 1521, 4, 51411);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 1 && t_value !== (t_value = /*l*/ ctx[0].ignore_spcl_char + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(1517:3) <Checkbox       checked = {state.ignore_spcl_char}      on:click={handleSetting.bind(this, \\\"2\\\")}      color=\\\"primary\\\"     >",
		ctx
	});

	return block;
}

// (1525:3) <Checkbox       checked = {state.multisetting}      on:click={handleSetting.bind(this, "3")}      color="primary"     >
function create_default_slot_4(ctx) {
	let span;
	let t_value = /*l*/ ctx[0].multi + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file, 1529, 4, 51592);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*l*/ 1 && t_value !== (t_value = /*l*/ ctx[0].multi + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(1525:3) <Checkbox       checked = {state.multisetting}      on:click={handleSetting.bind(this, \\\"3\\\")}      color=\\\"primary\\\"     >",
		ctx
	});

	return block;
}

// (1502:1) <Dialog class="remove_right_margin" width="600" bind:visible={state.settingmenuopen} style="background-color:#fff; border-radius: 5px;">
function create_default_slot_3(ctx) {
	let h4;
	let div1;
	let div0;
	let t1;
	let div2;
	let checkbox0;
	let t2;
	let checkbox1;
	let t3;
	let checkbox2;
	let t4;
	let span;
	let b;
	let t6;
	let current;

	checkbox0 = new Checkbox({
			props: {
				checked: /*state*/ ctx[2].case_sensetive,
				color: "primary",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*handleSetting*/ ctx[16].bind(this, "1"));

	checkbox1 = new Checkbox({
			props: {
				checked: /*state*/ ctx[2].ignore_spcl_char,
				color: "primary",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*handleSetting*/ ctx[16].bind(this, "2"));

	checkbox2 = new Checkbox({
			props: {
				checked: /*state*/ ctx[2].multisetting,
				color: "primary",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox2.$on("click", /*handleSetting*/ ctx[16].bind(this, "3"));

	const block = {
		c: function create() {
			h4 = element("h4");
			div1 = element("div");
			div0 = element("div");
			div0.textContent = "Settings";
			t1 = space();
			div2 = element("div");
			create_component(checkbox0.$$.fragment);
			t2 = space();
			create_component(checkbox1.$$.fragment);
			t3 = space();
			create_component(checkbox2.$$.fragment);
			t4 = space();
			span = element("span");
			b = element("b");
			b.textContent = "Note:";
			t6 = text(" All the above options are applicable to Fill in the Blanks (with text) and Fill in the Blanks (with multiline).");
			add_location(div0, file, 1504, 4, 51048);
			attr_dev(div1, "class", "d-flex justify-content-between");
			add_location(div1, file, 1503, 3, 50998);
			attr_dev(h4, "class", "mt-1 font21 mb-4");
			add_location(h4, file, 1502, 2, 50964);
			add_location(b, file, 1532, 4, 51667);
			attr_dev(span, "class", "text-danger");
			add_location(span, file, 1531, 3, 51635);
			add_location(div2, file, 1507, 2, 51091);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, div1);
			append_dev(div1, div0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
			mount_component(checkbox0, div2, null);
			append_dev(div2, t2);
			mount_component(checkbox1, div2, null);
			append_dev(div2, t3);
			mount_component(checkbox2, div2, null);
			append_dev(div2, t4);
			append_dev(div2, span);
			append_dev(span, b);
			append_dev(span, t6);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 4) checkbox0_changes.checked = /*state*/ ctx[2].case_sensetive;

			if (dirty[0] & /*l*/ 1 | dirty[2] & /*$$scope*/ 4) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};
			if (dirty[0] & /*state*/ 4) checkbox1_changes.checked = /*state*/ ctx[2].ignore_spcl_char;

			if (dirty[0] & /*l*/ 1 | dirty[2] & /*$$scope*/ 4) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);
			const checkbox2_changes = {};
			if (dirty[0] & /*state*/ 4) checkbox2_changes.checked = /*state*/ ctx[2].multisetting;

			if (dirty[0] & /*l*/ 1 | dirty[2] & /*$$scope*/ 4) {
				checkbox2_changes.$$scope = { dirty, ctx };
			}

			checkbox2.$set(checkbox2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);
			transition_in(checkbox2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			transition_out(checkbox2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_component(checkbox2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(1502:1) <Dialog class=\\\"remove_right_margin\\\" width=\\\"600\\\" bind:visible={state.settingmenuopen} style=\\\"background-color:#fff; border-radius: 5px;\\\">",
		ctx
	});

	return block;
}

// (1537:3) <Button      on:click={openSetting}      color="primary"      unelevated={true}      outlined={true}     >
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("OK");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(1537:3) <Button      on:click={openSetting}      color=\\\"primary\\\"      unelevated={true}      outlined={true}     >",
		ctx
	});

	return block;
}

// (1536:2) 
function create_footer_slot(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				color: "primary",
				unelevated: true,
				outlined: true,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*openSetting*/ ctx[15]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			add_location(div, file, 1535, 2, 51817);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(1536:2) ",
		ctx
	});

	return block;
}

// (1548:2) {:else}
function create_else_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Some Error occured during this process.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(1548:2) {:else}",
		ctx
	});

	return block;
}

// (1546:2) {#if message}
function create_if_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*message*/ ctx[1]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*message*/ 2) set_data_dev(t, /*message*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(1546:2) {#if message}",
		ctx
	});

	return block;
}

// (1545:1) <Snackbar bind:visible={state.snackback} bg="#f44336" bottom={true} timeout={4000} style="position:fixed; bottom:50px;z-index:99999">
function create_default_slot_1(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*message*/ ctx[1]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(1545:1) <Snackbar bind:visible={state.snackback} bg=\\\"#f44336\\\" bottom={true} timeout={4000} style=\\\"position:fixed; bottom:50px;z-index:99999\\\">",
		ctx
	});

	return block;
}

// (1552:3) <Button color="#ff0" on:click={() => (state.snackback = false)}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Close");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(1552:3) <Button color=\\\"#ff0\\\" on:click={() => (state.snackback = false)}>",
		ctx
	});

	return block;
}

// (1551:2) 
function create_action_slot(ctx) {
	let span;
	let button;
	let current;

	button = new Button({
			props: {
				color: "#ff0",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler_3*/ ctx[29]);

	const block = {
		c: function create() {
			span = element("span");
			create_component(button.$$.fragment);
			attr_dev(span, "slot", "action");
			add_location(span, file, 1550, 2, 52237);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(button, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_action_slot.name,
		type: "slot",
		source: "(1551:2) ",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div6;
	let div4;
	let span;
	let t0;
	let div3;
	let div2;
	let div1;
	let div0;
	let t1;
	let div5;
	let div5_contenteditable_value;
	let t2;
	let dialog0;
	let updating_visible;
	let t3;
	let dialog1;
	let updating_visible_1;
	let t4;
	let snackbar;
	let updating_visible_2;
	let current;
	let mounted;
	let dispose;

	function dialog0_visible_binding(value) {
		/*dialog0_visible_binding*/ ctx[27](value);
	}

	let dialog0_props = {
		class: "remove_right_margin",
		width: "700",
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot_1],
			default: [create_default_slot_9]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[2].open !== void 0) {
		dialog0_props.visible = /*state*/ ctx[2].open;
	}

	dialog0 = new Dialog({ props: dialog0_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog0, 'visible', dialog0_visible_binding));

	function dialog1_visible_binding(value) {
		/*dialog1_visible_binding*/ ctx[28](value);
	}

	let dialog1_props = {
		class: "remove_right_margin",
		width: "600",
		style: "background-color:#fff; border-radius: 5px;",
		$$slots: {
			footer: [create_footer_slot],
			default: [create_default_slot_3]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[2].settingmenuopen !== void 0) {
		dialog1_props.visible = /*state*/ ctx[2].settingmenuopen;
	}

	dialog1 = new Dialog({ props: dialog1_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog1, 'visible', dialog1_visible_binding));

	function snackbar_visible_binding(value) {
		/*snackbar_visible_binding*/ ctx[30](value);
	}

	let snackbar_props = {
		bg: "#f44336",
		bottom: true,
		timeout: 4000,
		style: "position:fixed; bottom:50px;z-index:99999",
		$$slots: {
			action: [create_action_slot],
			default: [create_default_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[2].snackback !== void 0) {
		snackbar_props.visible = /*state*/ ctx[2].snackback;
	}

	snackbar = new Snackbar({ props: snackbar_props, $$inline: true });
	binding_callbacks.push(() => bind(snackbar, 'visible', snackbar_visible_binding));

	const block = {
		c: function create() {
			div6 = element("div");
			div4 = element("div");
			span = element("span");
			t0 = space();
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t1 = space();
			div5 = element("div");
			t2 = space();
			create_component(dialog0.$$.fragment);
			t3 = space();
			create_component(dialog1.$$.fragment);
			t4 = space();
			create_component(snackbar.$$.fragment);
			attr_dev(span, "class", "icomoon-new-24px-gear-1 s3 text-dark pointer");
			attr_dev(span, "data-bs-toggle", "tooltip");
			attr_dev(span, "title", "Setting");
			add_location(span, file, 1141, 2, 37997);
			attr_dev(div0, "class", "modal-body modal_items_fill");
			add_location(div0, file, 1150, 5, 38340);
			attr_dev(div1, "class", "modal-content");
			add_location(div1, file, 1149, 4, 38306);
			attr_dev(div2, "class", "modal-dialog");
			add_location(div2, file, 1148, 3, 38274);
			attr_dev(div3, "class", "modal left_second table_fill fade");
			attr_dev(div3, "id", "items_list_fill");
			attr_dev(div3, "role", "dialog");
			set_style(div3, "z-index", "9998", 1);
			add_location(div3, file, 1147, 2, 38155);
			attr_dev(div4, "class", "py-2 px-2 text-right");
			set_style(div4, "background-color", "#d9e7fd");
			add_location(div4, file, 1140, 1, 37926);
			attr_dev(div5, "class", "tinymce-editor-res fillAuthor");
			attr_dev(div5, "id", "fillAuthor");
			set_style(div5, "height", "300px");
			set_style(div5, "border", "solid 2px #d9e7fd");
			set_style(div5, "padding", "8px");
			set_style(div5, "overflow", "auto");
			set_style(div5, "outline", "none");
			attr_dev(div5, "contenteditable", div5_contenteditable_value = true);
			add_location(div5, file, 1156, 1, 38441);
			add_location(div6, file, 1139, 0, 37918);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div6, anchor);
			append_dev(div6, div4);
			append_dev(div4, span);
			append_dev(div4, t0);
			append_dev(div4, div3);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div6, t1);
			append_dev(div6, div5);
			append_dev(div6, t2);
			mount_component(dialog0, div6, null);
			append_dev(div6, t3);
			mount_component(dialog1, div6, null);
			append_dev(div6, t4);
			mount_component(snackbar, div6, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(span, "click", /*openSetting*/ ctx[15], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const dialog0_changes = {};

			if (dirty[0] & /*l, state, dragSingle*/ 13 | dirty[2] & /*$$scope*/ 4) {
				dialog0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 4) {
				updating_visible = true;
				dialog0_changes.visible = /*state*/ ctx[2].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog0.$set(dialog0_changes);
			const dialog1_changes = {};

			if (dirty[0] & /*state, l*/ 5 | dirty[2] & /*$$scope*/ 4) {
				dialog1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_1 && dirty[0] & /*state*/ 4) {
				updating_visible_1 = true;
				dialog1_changes.visible = /*state*/ ctx[2].settingmenuopen;
				add_flush_callback(() => updating_visible_1 = false);
			}

			dialog1.$set(dialog1_changes);
			const snackbar_changes = {};

			if (dirty[0] & /*state, message*/ 6 | dirty[2] & /*$$scope*/ 4) {
				snackbar_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible_2 && dirty[0] & /*state*/ 4) {
				updating_visible_2 = true;
				snackbar_changes.visible = /*state*/ ctx[2].snackback;
				add_flush_callback(() => updating_visible_2 = false);
			}

			snackbar.$set(snackbar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dialog0.$$.fragment, local);
			transition_in(dialog1.$$.fragment, local);
			transition_in(snackbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dialog0.$$.fragment, local);
			transition_out(dialog1.$$.fragment, local);
			transition_out(snackbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div6);
			destroy_component(dialog0);
			destroy_component(dialog1);
			destroy_component(snackbar);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function htmlSpecialChars(data) {
	// find all the opening and closing tag
	let tags = data.match(/<[^>]*>/gm);

	let tag = '';

	// if match found
	if (tags) {
		// itterating through the length
		for (let i = 0; i < tags.length; i++) {
			//Checking table and converting < , > symbol with &lt; & &gt; respectively
			if (!tags[i].match(/<thead|<\/thead|<tbody|<\/tbody|<th|<\/th|<td|<\/td|<tr|<\/tr|<table|<\/table|<span|<\/span|<caption>|<\/caption>|<br>|<i|<\/i/gm)) {
				tag = tags[i];
				tags[i] = tags[i].replace(/</g, "&lt;").replace(/>/g, "&gt;");
				data = data.replace(tag, tags[i]);
			}
		}
	}

	// returning the converted data
	return data;
}

// this function is opposite of htmlSpecialChars function i.e., change the html entities back to html symbol
function reverseHtmlSpecialChars(data) {
	// for matching the text start with &lt; & end with &gt;
	let tags = data.match(/&lt;([\s\S]*?)&gt;/gm);

	let tag = '';

	// if match found
	if (tags) {
		for (let i = 0; i < tags.length; i++) {
			tag = tags[i];

			// replace &lt; & &gt; with < & > 
			tags[i] = tags[i].replace(/&lt;/g, "<").replace(/&gt;/g, ">");

			data = data.replace(tag, tags[i]);
		}
	}

	// retrun the converted data
	return data;
}

// function is responsible for adding the event NOT IN USE @pradeep_sir Please verify
function addEvent(node, eventName, func) {
	if ("undefined" == typeof node || null == node) ; else {
		if (!node.ownerDocument.addEventListener && node.ownerDocument.attachEvent) {
			node.attachEvent('on' + eventName, func);
		} else node.addEventListener(eventName, func, false);
	}
}

// if type = reverse then convert &apos; with #apos# else #apos# with &apos;
function replaceCharactersFunc(str, replaceCharacters, type) {
	for (var i in replaceCharacters) {
		if (type == 'reverse') {
			// convert &apos; with #apos#
			str = str.replace(new RegExp(i, 'g'), replaceCharacters[i]);
		} else {
			// convert #apos# with &apos;
			str = str.replace(new RegExp(replaceCharacters[i], 'g'), i);
		}
	}

	return str;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FillInTheBlanks', slots, []);
	let { xml } = $$props;
	let { editorState } = $$props;
	let { l } = $$props;
	let { getChildXml } = $$props;

	// variable declararion
	let cmTime = {};

	let math_eq_count = 0;
	let multiline_count = 0;
	let drag_drop_count = 0;
	let drop_down_count = 0;
	window.spanCounter = 0;
	window.currentId = "";
	window.currentInp = "";
	let timer = {};
	let replaceCharacters = { '&apos;': '#apos#' };
	let message = "";
	let state = {};
	let dragSingle = false;

	let hdd = writable({
		snackback: false,
		matchtype: "",
		ignoretype: "",
		open: false,
		settingmenuopen: false,
		fillInTheBlanksChoice: 1,
		multi: "",
		valueMultiple: [],
		codetype: false,
		numeric: false,
		customStyle: false,
		customStyleData: "",
		input1: "",
		fillMultiAttr: {},
		fillDropDown: [{ value: "", id: "0", checked: "" }],
		fillDragDrop: [{ value: "", id: "0", checked: "checked" }],
		fillMultiLine: [{ value: "", id: "0" }],
		fillEquation: [{ value: "", id: "0" }],
		anchorEl: null,
		case_sensetive: false,
		ignore_spcl_char: false,
		multisetting: false
	});

	const unsubscribe = hdd.subscribe(items => {
		$$invalidate(2, state = items);
	});

	// this function loaded before the rendering and check that it has xml or not . If it has then calls the reverseXml function.
	onMount(() => {
		didMount();

		// for handling the error
		try {
			// checking if there is any xml in the xml props
			if (xml) {
				AH.select('#authoringLoadComponent').focus();

				// updates the cdata
				reverseXml();
			}
		} catch(e) {
			console.log({
				Error: e,
				File: "FillInTheBlanks",
				Line: "116"
			});
		}
	}); // used to show the tooltip
	// $(document).ready(function() {
	// 	$('[data-bs-toggle="tooltip"]').tooltip(); 
	// });

	onDestroy(() => {
		tinymce.remove('.tinymce-editor-res');
	});

	// this function is responsible for loading the module
	function loadModule(loadXml) {
		// Here first xml is converted into the JSON with the function XMLToJSON 
		let newXml = XMLToJSON(loadXml);

		// passing the xml in parsing function which parse the xml
		parseXmlAuthoring(newXml);
	}

	// this function is called to parse the xml initially
	function parseXmlAuthoring(MYXML) {
		// taking data from the xml
		let cdata = MYXML.smxml.text.__cdata;

		// if MYXML.smxml.text._matchtype is 0 then case_sensetive will be true otherwis false
		let case_sensetive = MYXML.smxml.text._matchtype == 0 ? true : false;

		// if MYXML.smxml.text._ignoretype  is 1 then ignore_spcl_char will be true otherwis false
		let ignore_spcl_char = MYXML.smxml.text._ignoretype == 1 ? true : false;

		// if there is in xml multiple=multiple then multisetting value will be true
		let multisetting = MYXML.smxml.text._multiple == 'multiple' ? true : false;

		// setting state of the attributes
		$$invalidate(2, state.matchtype = MYXML.smxml.text._matchtype, state);

		$$invalidate(
			2,
			state.ignoretype = MYXML.smxml.text._ignoretype
			? MYXML.smxml.text._ignoretype
			: "",
			state
		);

		$$invalidate(
			2,
			state.multi = MYXML.smxml.text._multiple
			? MYXML.smxml.text._multiple
			: "",
			state
		);

		$$invalidate(2, state.case_sensetive = case_sensetive, state);
		$$invalidate(2, state.ignore_spcl_char = ignore_spcl_char, state);
		$$invalidate(2, state.multisetting = multisetting, state);

		// taking correct ans from the cdata and storing it in variable answerKey
		let answerKey = cdata.match(/%{[\s\S]*?}%/gm);

		let answerType = '';

		// checking if there is any correct ans set
		if (answerKey) {
			// iterating through each answerkey
			answerKey.forEach((v, i) => {
				let originalKey = answerKey[i];
				let latexKey = "";
				let editMath = "";

				// here fimding the answerType by matching finding the text between | and }%
				answerType = answerKey[i].match(/\|(.*?)}%$/gm);

				// if there is any answerType exists then save it o0therwise its type will be t
				answerType = answerType ? answerType[0].replace(/\||}%/gm, '') : 't';

				let innerKey = "";
				let icon = "";
				let type = "";

				// in case of textbox
				if (answerType == "t") {
					type = answerType;
					innerKey = "Textbox";
					icon = "icomoon-insert-template";
				} else if (answerType == "c") {
					// in case  of codeType
					type = answerType;

					innerKey = "Textbox";
					icon = "icomoon-insert-template";
				} else if (answerType == "n") {
					// in case of numeric
					type = "t";

					innerKey = "Numeric";
					icon = "icomoon-insert-template";
				} else if (answerType == "s") {
					// in case of dropdown
					type = answerType;

					innerKey = "Dropdown";
					icon = "icomoon-fill-drop-down";
				} else if (answerType == "d" || answerType == "ds") {
					// in case of drag & drop (d), drag single (ds)
					type = answerType;

					innerKey = "Drag & Drop";
					icon = "icomoon-fill-drag-drop";
				} else if (answerType == "e") {
					// in case of mathmatical expressions
					type = answerType;

					innerKey = "Math";

					// removing the symbol %{ , |e}% from the answerKey
					latexKey = originalKey.replace(/\%\{|\|e\}\%/g, "");

					latexKey = "latex=\"" + latexKey + "\"";
					editMath = "editMath";
					icon = "icomoon-insert-template";
				} else if (answerType.indexOf("{" == 0) || answerType.indexOf("{" == 1)) {
					// in case of multiline
					type = "m";

					innerKey = "Multiline";
					icon = "icomoon-insert-template";
				}

				let regex = new RegExp("(?=[^'])" + RegExp.quote(originalKey) + "(?=[^'])", "gmi"); //@updesh  added for more than one same originalKey value

				// convert &apos; with #apos#
				originalKey = replaceCharactersFunc(originalKey, replaceCharacters, "reverse");

				cdata = cdata.replace(regex, "<span id=\"latexSpan" + ++window.spanCounter + "\" " + latexKey + " type='" + type + "' class='alert alert-info editFill " + editMath + "' originalKey='" + originalKey + "' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='" + icon + "'></i>" + innerKey + "</span>");
			});
		}

		// added into the authoring section
		AH.select("#fillAuthor").innerHTML = cdata;
	}

	// this function updates the xml
	function reverseXml() {
		// get the content of the authoring area (.fillAuthor) with tinyMCE Plugin 
		let data = tinyMCE.activeEditor.getContent({ format: 'raw' });

		// reverse the html special char
		data = reverseHtmlSpecialChars(data);

		// replacing the html entity of &quot; & &nbsp;
		data = data.replace(/&quot;/g, '"').replace(/&nbsp;/g, ' ');

		// finding the data with span tag
		let arr = data.match(/<span([\s\S]*?)>([\s\S]*?)<\/span>/gi);

		// if match found
		if (arr) {
			for (let i = 0; i < arr.length; i++) {
				// finding the attribute originalkey and its value
				let originalkey = arr[i].match(/originalkey="%([\s\S]*?)%"/g);

				// if match found
				if (originalkey) {
					// extracting the value of the originalkey attribute
					originalkey = originalkey.toString().replace(/originalkey=/g, '').replace(/"%|%"/g, '%');

					data = data.replace(arr[i], originalkey);
				}
			}
		}

		// convert #apos# with &apos;
		data = replaceCharactersFunc(data, replaceCharacters);

		// converting the #pipe into the html entities
		data ? data = data.replace(/#pipe/g, "&#124;") : null;

		// updating the xml
		let xml = '<smxml xmlns="http://www.w3.org/1999/xhtml" type="9" name="FillInTheBlank"><text matchtype="' + state.matchtype + '" ignoretype="' + state.ignoretype + '" multiple="' + state.multi + '" ><!--[CDATA[' + data + ']]--></text></smxml>';

		// update and store the xml using the function getChildXml
		getChildXml(xml);
	}

	// this function loaded just after rendering
	function didMount() {
		initEditor();

		// calls just after rendering , and initiallizes the tinyMCE Plugin and its events
		// binding event with the fillAuthor
		AH.bind("#fillAuthor", "keyup", reverseXml.bind(this));

		AH.bind("#fillAuthor", "mouseup", reverseXml.bind(this));
		AH.bind("#fillAuthor", "change", reverseXml.bind(this));

		// binding event on the response box "click touchstart"
		AH.listen(document, "click", ".editFill", (_this, event) => {
			let key = _this.getAttribute("originalKey");

			// convert #apos# with &apos;
			key = replaceCharactersFunc(key, replaceCharacters);

			// if type is textbox or codetype
			if (_this.getAttribute("type") == "t" || _this.getAttribute("type") == "c") {
				// for filling the value when dialog is open
				editTextbox(key);
			} else if (_this.getAttribute("type") == "e") {
				// if the type is mathmetical expressions
				editMathbox(key); // for filling the value when dialog is open
			} else if (_this.getAttribute("type") == "d" || _this.getAttribute("type") == "ds") {
				// if the type is drag & drop or drag single
				editDragDrop(key);
			} else if (_this.getAttribute("type") == "s") {
				// for the dropdown
				editSelectbox(key);
			} else if (_this.getAttribute("type") == "m") {
				// for the multiline
				editMultiline(key);
			}
		});

		// for setting the current state of the item
		setFillType(editorState.itemXML);

		// for loading the moduke
		loadModule(xml);

		cmTime = {};

		AH.listen(document, 'touchstart', '#fillAuthor', () => {
			cmTime.s = new Date().getTime();
		});

		AH.listen(document, 'touchend', '#fillAuthor', () => {
			cmTime.e = new Date().getTime() - cmTime.s;

			if (cmTime.e / 1000 > 1) {
				handleOpen();
				cmTime = {};
			}
		});

		AH.listen(document, 'keydown', '.drop_down_delete, .drag_drop_delete, .mathematical_delete, .latexEditButton', (_this, event) => {
			if (event.keyCode == 13 || event.which == 13) {
				// click the element which currently get the focus and enter key is down
				_this.click();
			}
		});
	}

	// This function responsible for setting the state for the fillInTheBlanksChoice
	function setFillType(type) {
		switch (type) {
			case "editor_item_1.xml":
				// for mathemetcial expression
				$$invalidate(2, state.fillInTheBlanksChoice = 6, state);
				break;
			case "editor_item_5.xml":
				// for textbox
				$$invalidate(2, state.fillInTheBlanksChoice = 1, state);
				break;
			case "editor_item_7.xml":
				// for drag & drop , drag single
				$$invalidate(2, state.fillInTheBlanksChoice = 3, state);
				break;
			case "editor_item_6.xml":
				// for dropdown
				$$invalidate(2, state.fillInTheBlanksChoice = 2, state);
				break;
			case "editor_item_3.xml":
				// for multiline
				$$invalidate(2, state.fillInTheBlanksChoice = 5, state);
				break;
		}
	}

	// calls just after rendering , and initiallizes the tinyMCE Plugin and its events
	function initEditor() {
		AH.listen(document, "click", ".editMath", (_this, e) => {
			window.currentId = _this.getAttribute('id');
		});

		tinyMCE.PluginManager.add('res', function (editor, url) {
			editor.addMenuItem('resp', {
				text: l.add_response,
				id: 'addToken',
				onclick: () => {
					handleOpen();
				},
				context: 'insert',
				prependToContext: true
			});
		});

		tinymce.PluginManager.load('equationeditor', themeUrl + 'svelte_items/tinymce/plugins/equationeditor/plugin.min.js');

		tinymce.init({
			selector: '.tinymce-editor-res',
			inline: true,
			theme: 'modern',
			skin: 'skin02',
			min_width: 100,
			resize: true,
			menubar: false,
			toolbar: true,
			elementpath: false,
			statusbar: false,
			force_br_newlines: true,
			remove_trailing_brs: true,
			forced_root_block: false,
			extended_valid_elements: 'span[onClick|contentEditable]',
			valid_elements: "*[*]",
			fixed_toolbar_container: '#toolbar_container',
			extended_valid_elements: 'uc:syntax,uc:ref',
			custom_elements: 'uc:syntax,~uc:ref',
			setup(editor) {
				editor.addButton('tabl', {
					text: 'Table',
					onclick() {
						createTableHtml();

						AH.listen('.modal_items_fill', 'click', '.item_int_fill', (_this, event) => {
							createTables(_this, editor, tinyMCE);
						});
					}
				});

				editor.addButton('custom-alignleft', {
					icon: "alignleft",
					onclick() {
						if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == tinyMCE.activeEditor.selection.getNode().innerHTML) {
							if (tinyMCE.activeEditor.selection.getNode().classList.contains("ebook_item_text")) {
								AH.showmsg(l.align_content_message);
							} else {
								editor.execCommand('mceToggleFormat', false, 'alignleft');
							}
						} else {
							AH.showmsg(l.align_content_message);
						}
					}
				});

				editor.addButton('custom-aligncenter', {
					icon: "aligncenter",
					onclick() {
						if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == tinyMCE.activeEditor.selection.getNode().innerHTML) {
							if (tinyMCE.activeEditor.selection.getNode().classList.contains("ebook_item_text")) {
								AH.showmsg(l.align_content_message);
							} else {
								editor.execCommand('mceToggleFormat', false, 'aligncenter');
							}
						} else {
							AH.showmsg(l.align_content_message);
						}
					}
				});

				editor.addButton('custom-alignright', {
					icon: "alignright",
					onclick() {
						if (tinyMCE.activeEditor.selection.getSel().anchorNode.parentElement.innerHTML == tinyMCE.activeEditor.selection.getNode().innerHTML) {
							if (tinyMCE.activeEditor.selection.getNode().classList.contains("ebook_item_text")) {
								AH.showmsg(l.align_content_message);
							} else {
								editor.execCommand('mceToggleFormat', false, 'alignright');
							}
						} else {
							AH.showmsg(l.align_content_message);
						}
					}
				});

				editor.on('change', function (e) {
					e.target.focus(); // shifting focus first to node.
					timer['tinyChange'] && clearTimeout(timer['tinyChange']);

					timer['tinyChange'] = setTimeout(
						function () {
							if (e.target.id == tinyMCE.activeEditor.id) {
								reverseXml();
							} else {
								console.warn({
									Error: "Please click first on table",
									target: e.target.id,
									active: tinyMCE.activeEditor.id
								});

								AH.showmsg("Please click the table first then manipulate.");
							}
						},
						500
					);
				});

				editor.on('mouseup', function () {
					tinymce.activeEditor.execCommand('mceDirectionLTR');
					window.selecteddata = tinymce.activeEditor.selection.getContent();
				});
			},
			plugins: [
				"lists link image charmap print preview anchor",
				"searchreplace code fullscreen",
				"insertdatetime media table contextmenu paste res equationeditor "
			],
			content_css: themeUrl + 'svelte_items/src/libs/mathquill.css',
			toolbar: [
				' bold italic underline | equationeditor | tabl | custom-alignleft custom-aligncenter custom-alignright '
			],
			contextmenu: "resp",
			paste_as_text: true
		});
	}

	function createTableHtml() {
		AH.selectAll('.modal_items_fill', 'html', ' ');
		let o = interactive_item[0].table;

		Object.keys(o).forEach(key => {
			let item = o[key];

			if (item.hide != true) {
				AH.insert('.modal_items_fill', `<div id="${item.label}" data-html="${item.html}" data-type="${key}" class="${key} item_int_fill thumbnail btn col-sm-5" style="max-width:100%;height:130px;background-image:url(${item.default_image});background-size:contain;background-position:center;background-repeat:no-repeat;overflow:hidden;"><div class="item_labelClass">${item.label}</div></div>`, 'beforeend');
			}
		});

		AH.getBS("#items_list_fill", 'Modal').show();
	}

	function createTables(_this, editor, tinyMCE) {
		let table_html = _this.getAttribute('data-html');
		let tab_html = "";
		tab_html = table_html.replace("<div class='ebook_item_text'>", " ").replace("</div>", " ");
		editor.focus();
		tinyMCE.activeEditor.execCommand("mceInsertContent", false, tab_html);
		AH.getBS("#items_list_fill", 'Modal').hide();
	}

	// this function change the value of the attribute matchtype, ignoretype and multiple in xml
	function storeAttr() {
		$$invalidate(2, state.matchtype = "1", state);
		$$invalidate(2, state.ignoretype = "0", state);
		$$invalidate(2, state.multi = "", state);

		for (let i = 0; i < state.valueMultiple.length; i++) {
			if (state.valueMultiple[i] == "1") {
				$$invalidate(2, state.matchtype = "0", state);
				break;
			}
		}

		for (let i = 0; i < state.valueMultiple.length; i++) {
			if (state.valueMultiple[i] == "2") {
				$$invalidate(2, state.ignoretype = "1", state);
				break;
			}
		}

		for (let i = 0; i < state.valueMultiple.length; i++) {
			if (state.valueMultiple[i] == "3") {
				$$invalidate(2, state.multi = "multiple", state);
				break;
			}
		}

		AH.select("#fillAuthor").focus();

		// updating the cdata 
		reverseXml();
	}

	/*
** These function responsible for adding the options
*/
	function addDropDownOption() {
		drop_down_count++;
		let tempArr = state.fillDropDown;

		tempArr.push({
			value: "",
			id: drop_down_count,
			checked: ""
		});

		$$invalidate(2, state.fillDropDown = tempArr, state);
	}

	function addDragDropOption() {
		drag_drop_count++;
		let tempArr = state.fillDragDrop;

		tempArr.push({
			value: "",
			id: drag_drop_count,
			checked: "checked"
		});

		$$invalidate(2, state.fillDragDrop = tempArr, state);
	}

	function addMultiLineOption() {
		multiline_count++;
		let tempArr = state.fillMultiLine;
		tempArr.push({ value: "", id: multiline_count });
		$$invalidate(2, state.fillMultiLine = tempArr, state);
	}

	function addMathEquation() {
		math_eq_count++;

		//let tempArr = state.fillEquation;
		let tempArr = { value: "", id: math_eq_count };

		$$invalidate(2, state.fillEquation = [...state.fillEquation, tempArr], state);
	}

	/*---------End of the function-------------*/
	// for updating the dialog
	function updateDialog(getValue) {
		$$invalidate(2, state.fillInTheBlanksChoice = getValue, state);
	}

	function handleOpen() {
		/*Open Response Dialog Box*/
		$$invalidate(2, state.open = true, state);

		$$invalidate(2, state.codetype = false, state);
		$$invalidate(2, state.numeric = false, state);
	}

	// for handling cancel button
	function handleClose() {
		/*Unset editFlag for textbox*/
		if (state.fillInTheBlanksChoice == 1) ;

		/*END*/
		/*Restore default dropdown option*/
		if (state.fillInTheBlanksChoice == 2) {
			$$invalidate(2, state.fillDropDown = [], state);
			state.fillDropDown.push({ value: "", id: "", checked: "" });
		}

		/*END*/
		/*Restore Default Drag Drop Option*/
		if (state.fillInTheBlanksChoice == 3) {
			$$invalidate(2, state.fillDragDrop = [], state);
			state.fillDragDrop.push({ value: "", id: "", checked: "checked" });
		}

		/*END*/
		/*Restore Default MultiLine Option*/
		if (state.fillInTheBlanksChoice == 5) {
			$$invalidate(2, state.fillMultiLine = [], state);
			state.fillMultiLine.push({ value: "", id: "" });
		}

		/*END*/
		/*Restore Default MathEquation Option*/
		if (state.fillInTheBlanksChoice == 6) {
			window.currentId = null;
			$$invalidate(2, state.fillEquation = [{ value: "a+b", id: "0" }], state);
		}

		/*END*/
		$$invalidate(2, state.open = false, state); /*Open Response Dialog*/
	}

	/*
** These function reponsible for entering details when the response box is clicked
*/
	function editTextbox(key) {
		// removing the symbol '%{' & '}%' in the key 
		key = key.replace(/%{|}%/g, "");

		key = key.split("|");

		// store the split key 0 index which contains the ans of that textbox
		let ans = key[0].trim();

		// extracting ans_type
		let ans_type = key[1] ? key[1].trim() : "";

		// setting state 
		$$invalidate(2, state.codetype = ans_type == "c" ? true : false, state);

		$$invalidate(2, state.numeric = ans_type == "n" ? true : false, state);
		$$invalidate(2, state.customStyle = ans.indexOf("#style#") != -1 ? true : false, state);
		$$invalidate(2, state.fillInTheBlanksChoice = 1, state);
		$$invalidate(2, state.open = true, state);

		// if there is #style# found that means if there is styling given then 
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			// for filling the style value in the style textbox
			//AH.select("#responseDialog #customStyleText").value = customStyle[1];
			$$invalidate(2, state.customStyleData = customStyle[1], state);

			// for filling the correct ans
			//AH.select("#input1").value = customStyle[0];
			$$invalidate(2, state.input1 = customStyle[0], state);
		} else {
			// if styling not given then ans will contain the correct ans
			//AH.select("#input1").value = ans;
			$$invalidate(2, state.input1 = ans, state);
		}
	}

	function editMathbox(key) {
		$$invalidate(2, state.fillEquation = [], state);

		// removing the %{,}% symbol from the key
		key = key.replace(/%{|}%/g, "");

		// splitting the key on pipe symbol
		key = key.split("|");

		// contain the ans
		let ans = key[0].trim();

		let anskey = ans.split("##");

		// getting ans_type
		let ans_type = key[1] ? key[1].trim() : "";

		// open thr dialog
		$$invalidate(2, state.customStyle = ans.indexOf("#style#") != -1 ? true : false, state);

		$$invalidate(2, state.fillInTheBlanksChoice = 6, state);
		$$invalidate(2, state.open = true, state);
		let tempEqArr = {};
		let latexEdit = {};

		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");
			AH.select("#responseDialog #customStyleText").value = customStyle[1];
			AH.select("#input" + i).value = customStyle[0];
		} else {
			for (let i = 0; i <= anskey.length - 1; i++) {
				latexEdit[i] = anskey[i];
				tempEqArr = { value: anskey[i], id: i };
			}

			$$invalidate(2, state.fillEquation = [...state.fillEquation, tempEqArr], state);
			$$invalidate(2, state.latexEditData = latexEdit, state);
		}
	}

	function editSelectbox(key) {
		// removing the %{,}% symbol from the key
		key = key.replace(/%{|}%/g, "");

		// splitting the key on pipe symbol
		key = key.split("|");

		// contain the ans
		let ans = key[0].trim();

		$$invalidate(2, state.fillDropDown = [], state);
		let tempDropDown = [];

		// split with ,
		let allValue = ans.split(",").map(item => item.trim());

		allValue.forEach((v, i) => {
			let opt = allValue[i];
			let check = "";

			// if found * then check that radio btn
			if (opt.indexOf('*') == 0) {
				check = "checked";
				opt = opt.slice(1);
				AH.select("#responseDialog #correct" + i).checked = true;
			}

			tempDropDown.push({ value: opt, id: "", checked: check });
			check = "";
		});

		$$invalidate(2, state.fillDropDown = tempDropDown, state);
		$$invalidate(2, state.fillInTheBlanksChoice = 2, state);
		$$invalidate(2, state.open = true, state);
	} //this.setState({open:true});

	function editDragDrop(key) {
		// first convert |d with #endpipe and the | with #pipe and then #endpipe with |d again
		key = key.replace(/\|d/g, "#endPipe").replace(/\|/g, "#pipe").replace(/#endPipe/g, "|d");

		// removing the %{,}% symbol from the key
		key = key.replace(/%{|}%/g, "");

		// split with |
		key = key.split("|");

		let ans = key[0].trim();

		// checking for the drag single
		$$invalidate(3, dragSingle = key[1].trim() == "ds" ? true : false);

		$$invalidate(2, state.fillDragDrop = [], state);
		let dragDrop = [];

		// spliting the ans with ,
		let allValue = ans.split(",");

		allValue.forEach((v, i) => {
			let opt = allValue[i];
			let check = "checked";

			// if finding ~i or i~ then unchecked the checkbox
			if (opt.match(/i~|~i/g)) {
				check = "";

				// removing ~i or i~ from the option
				opt = opt.replace(/i~|~i/g, "");
			}

			dragDrop.push({ value: opt, id: "", checked: check });
			check = "checked";
		});

		$$invalidate(2, state.fillDragDrop = dragDrop, state);
		$$invalidate(2, state.fillInTheBlanksChoice = 3, state);
		$$invalidate(2, state.open = true, state);
	}

	function editMultiline(key) {
		// removing the %{,}% symbol from the key
		key = key.replace(/%{|}%/g, "");

		// spliting the key with |
		key = key.split("|");

		let ans = key[0].trim();
		let attrs = key[1].trim();

		// parsing the attrs into the json
		attrs = JSON.parse(attrs);

		$$invalidate(2, state.fillMultiLine = [], state);
		let tempMulti = [];
		tempMulti.push({ value: ans, id: "" });
		$$invalidate(2, state.fillMultiLine = tempMulti, state);
		$$invalidate(2, state.fillMultiAttr = attrs, state);
		$$invalidate(2, state.fillInTheBlanksChoice = 5, state);
		$$invalidate(2, state.open = true, state);

		// putting the values of defaultAns , row and col
		if (attrs.defaultAns) AH.select("#responseDialog #defaultMultiAns").value = attrs.defaultAns;

		AH.select("#responseDialog #rows").value = attrs.rows;
		AH.select("#responseDialog #cols").value = attrs.cols;
	}

	/*----------------------end of the functions----------------------------------------*/
	// responsible for validation
	function showError(err) {
		//AH.select("#responseDialog").effect("shake");
		$$invalidate(1, message = err);

		$$invalidate(2, state.snackback = true, state);
	}

	// function calls when the done button is clicked
	function storeAns() {
		let validate = 0;

		switch (state.fillInTheBlanksChoice) {
			case 1:
				{
					// if type is textbox
					//if(state.fillInTheBlanksChoice == 1) {
					// contain the ans
					let ans = AH.select("#input1").value;

					// contain the setting values
					let codetype = AH.select("#responseDialog #codetype").checked;

					let numeric = AH.select("#responseDialog #numeric").checked;
					let customStyle = AH.select("#responseDialog #customStyle").checked;

					// if customStyle is true add the style in the answer
					if (customStyle == true) {
						ans += "#style#" + AH.select("#responseDialog #customStyleText").value;
					}

					// for codetype or numeric add |c or |n in answer
					if (codetype == true) {
						ans += " |c";
					} else if (numeric == true) {
						ans += " |n";
					}

					// contain the answer					
					var given_ans = ans.includes('|') ? ans.split('|')[0].trim() : ans;

					// function for validation
					if (ans == "") {
						validate = 1;
						showError("All fields are required");
					} else if (!given_ans) {
						validate = 1;
						showError("Please write data for match");
						AH.select("#input1").focus();
					} else if (codetype == true && numeric == true) {
						validate = 1;
						showError("You cannot use codetype and numeric at the same time");
					} else {
						// convert &apos; with #apos#
						let ansnew = replaceCharactersFunc(ans, replaceCharacters, "reverse");

						// add the textbox in the authoring area
						tinyMCE.activeEditor.insertContent("<span type='t' class='alert alert-info editFill' originalKey='%{" + ansnew.trim() + "}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template align-middle'></i>" + (numeric == true ? "Numeric" : "Textbox") + "</span>");
					}
				}
				break;
			case 2:
				{
					// for dropdown
					//if(this.state.fillInTheBlanksChoice == 2) {
					let a = AH.find("#responseDialog", "[id^=dropDown]", 'all');

					let str = "";
					let anyCorrect = "no";
					let isValue = "yes";

					// traversing throgh the dropdown
					a.forEach(_this => {
						// finding correct ans
						let correctAttr = _this.getAttribute('data-correct');

						// cheeck wether the check box is checked or not
						let isCorrect = AH.select(`#responseDialog #${correctAttr}`).checked;

						let ans = _this.value;

						if (ans.trim() == "") {
							isValue = "no";
						}

						if (isCorrect == true) {
							// if checked then add *
							anyCorrect = "yes";

							str += `*${ans},`;
						} else {
							// otherwsise add the option with ,
							str += ans + ",";
						}
					});

					// remove last comma
					str = str.slice(0, -1);

					// validation here
					if (anyCorrect == "no") {
						validate = 1;
						showError("Please select atleast one correct answer");
					} else if (isValue == "no") {
						validate = 1;
						showError("All fields are required");
					} else {
						// convert &apos; with #apos#
						let strnew = replaceCharactersFunc(str, replaceCharacters, "reverse");

						tinyMCE.activeEditor.insertContent("<span type='s' class='alert alert-info editFill' originalKey='%{" + strnew + "|s}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-fill-drop-down align-middle'></i>Dropdown</span>");
					}
				}
				break;
			case 3:
				{
					// for drag & drop, drag single
					//if(this.state.fillInTheBlanksChoice == 3) {
					// finding all the dragDrop options
					let d = AH.find("#responseDialog", "[id^=dragDrop]", 'all');

					let str = "";

					// check dragSingle is checked or not
					$$invalidate(3, dragSingle = AH.select("#responseDialog #drag_single").checked);

					// if dragSingle is checked then assign the dragType ds else d
					let dragType = dragSingle == true ? "ds" : "d";

					let isValue = "yes";
					let isChecked = false;

					// traversing each dragdrop option
					d.forEach(_this => {
						// finding the correct attr
						let correctAttr = _this.getAttribute('data-correct');

						// check for the option is correct or not
						let isCorrect = AH.select(`#responseDialog #${correctAttr}`).checked;

						let ans = _this.value;
						if (ans.trim() == "") isValue = "no";

						if (isCorrect == true) {
							// if correct the n add it with ,
							str += ans + ",";

							isChecked = true;
						} else {
							// if incorrect then add ~i 
							str += ans + "~i,";
						}
					});

					// removing last ,
					str = str.slice(0, -1);

					// validation
					if (!isChecked) {
						validate = 1;
						showError("Please select atleast one correct answer");
					} else if (isValue == "no") {
						validate = 1;
						showError("All fields are required");
					} else {
						// convert &apos; with #apos#
						let strnew = replaceCharactersFunc(str, replaceCharacters, "reverse");

						strnew = strnew.replace(/&#124;/g, "#pipe").replace(/\|/g, "#pipe");

						//add content
						tinyMCE.activeEditor.insertContent("<span type='" + dragType + "' class='alert alert-info editFill' originalKey='%{" + strnew + "|" + dragType + "}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-fill-drag-drop align-middle'></i>Drag & Drop</span>");
					}
				}
				break;
			case 5:
				{
					// if the type is multiline
					//if(this.state.fillInTheBlanksChoice == 5) {
					// getting all the feild values
					let m = AH.select("#responseDialog #multiLineCorrect").value; // correct answer

					let defaultAns = AH.select("#responseDialog #defaultMultiAns").value; // default ans
					let rows = AH.select("#responseDialog #rows").value; // rows
					let cols = AH.select("#responseDialog #cols").value; // cols
					let opt = `{"defaultAns": "${defaultAns}","rows":"${rows}","cols":"${cols}"}`; // adding values in json format

					// for validation
					if (m == "" || rows == "" || cols == "") {
						validate = 1;
						showError("All fields are required");
					} else if (isNaN(rows)) {
						validate = 1;
						showError("Please fill numeric data only.");
						AH.select("#responseDialog #rows").focus();
					} else if (isNaN(cols)) {
						validate = 1;
						showError("Please fill numeric data only.");
						AH.select("#responseDialog #cols").focus();
					} else {
						// convert &apos; with #apos#
						let optnew = replaceCharactersFunc(opt, replaceCharacters, "reverse");

						tinyMCE.activeEditor.insertContent("<span type='m' class='alert alert-info editFill' originalKey='%{" + m + "|" + optnew + "}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template align-middle'></i>Multiline</span>");
					}
				}
				break;
			case 6:
				{
					// for mathemetical expression
					//if(this.state.fillInTheBlanksChoice == 6) {
					let MathArray = [];

					for (let i = 0; i <= math_eq_count; i++) {
						if (document.querySelector("#input" + i)) {
							// if any value is blank then change the value of validate to 1
							if (!AH.select("#input" + i).value) {
								validate = 1;
							}

							MathArray.push(AH.select("#input" + i).value);
						}
					}

					let e = MathArray.join("##", math_eq_count);

					// for validation
					if (validate == 0) {
						if (window.currentId) {
							AH.select('#' + window.currentId, 'attr', { latex: e });
							AH.select('#' + window.currentId, 'attr', { originalKey: `%{${e}|e}%` });
							window.currentId = null;
							window.currentInp = null;
						} else {
							tinyMCE.activeEditor.insertContent("<span id=\"latexSpan" + window.spanCounter + "\" type='e' class='alert alert-info editFill editMath' latex='" + e + "' originalKey='%{" + e + "|e}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template'></i>Math</span>");
						}
					} else {
						showError("All fields are required");
					}
				}
				break;
		} // tinyMCE.activeEditor.insertContent("<span id=\"latexSpan"+window.spanCounter+"\" type='e' class='alert alert-info editFill editMath' latex='"+e+"' originalKey='%{"+e+"|e}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template'></i>Math</span>");	

		// for updating the cdata
		if (validate == 0) {
			reverseXml();

			// close the dialog
			handleClose();
		}
	}

	// for removing the drag and drop options
	function removeDragDrop(id) {
		let tempFDD = state.fillDragDrop;
		let len = Object.values(state.fillDragDrop).length;

		if (len != 1) {
			tempFDD.splice(id, 1);
		}

		$$invalidate(2, state.fillDragDrop = tempFDD, state);
	}

	// for removing the drop down options
	function removeDropDown(id) {
		AH.hideBsAll('.drop_down_delete', 'Tooltip');
		let tempFDD = state.fillDropDown;
		let len = Object.values(state.fillDropDown).length;

		if (len != 1) {
			tempFDD.splice(id, 1);
		}

		$$invalidate(2, state.fillDropDown = tempFDD, state);
	}

	// for removing the math equation options
	function removeMathEquation(id) {
		let len = Object.values(state.fillEquation).length;

		if (len != 1) {
			$$invalidate(2, state.fillEquation = state.fillEquation.filter(curr => curr.id != id), state);
		}
	}

	// for adding user response in fib mathametical expression
	function addEditable(i) {
		let txt = AH.select("#input" + i);
		let caretPos = txt.selectionStart;
		let textAreaTxt = txt.value;
		var txtToAdd = "user Response";
		txt.value = textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos);
	}

	// open the latex dialog
	function latexEdit(i) {
		if (!window.currentId) {
			AH.showmsg("Equation didn't created yet.");
			return;
		}

		$$invalidate(2, state.open = true, state); //false
	}

	// changes the fillInTheBlanksChoice state when changing dropdown
	function updatedropdown(event) {
		$$invalidate(2, state.fillInTheBlanksChoice = event.target.value, state);
	}

	

	// open the setting dialog
	function openSetting() {
		$$invalidate(2, state.settingmenuopen = !state.settingmenuopen, state);
	}

	// responsible for handling the reponses on checkbox in setting dialog
	function handleSetting(value, event) {
		if (value == 1) {
			$$invalidate(2, state.case_sensetive = event.target.checked, state);
		}

		if (value == 2) {
			$$invalidate(2, state.ignore_spcl_char = event.target.checked, state);
		}

		if (value == 3) {
			$$invalidate(2, state.multisetting = event.target.checked, state);
		}

		let setting_arr = [];

		if (state.case_sensetive == true) {
			setting_arr.push("1");
		}

		if (state.ignore_spcl_char == true) {
			setting_arr.push("2");
		}

		if (state.multisetting == true) {
			setting_arr.push("3");
		}

		$$invalidate(2, state.valueMultiple = setting_arr, state);
		storeAttr();
	} //self.forceUpdate();		

	const writable_props = ['xml', 'editorState', 'l', 'getChildXml'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<FillInTheBlanks> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(2, state.codetype = !state.codetype, state);
	};

	const click_handler_1 = () => {
		$$invalidate(2, state.numeric = !state.numeric, state);
	};

	const click_handler_2 = () => {
		$$invalidate(2, state.customStyle = !state.customStyle, state);
	};

	function input1_input_handler(each_value_3, i) {
		each_value_3[i].value = this.value;
		$$invalidate(2, state);
	}

	function input_change_handler() {
		dragSingle = this.checked;
		$$invalidate(3, dragSingle);
	}

	function input1_input_handler_1(each_value_2, i) {
		each_value_2[i].value = this.value;
		$$invalidate(2, state);
	}

	function input_input_handler(each_value, i) {
		each_value[i].value = this.value;
		$$invalidate(2, state);
	}

	function dialog0_visible_binding(value) {
		if ($$self.$$.not_equal(state.open, value)) {
			state.open = value;
			$$invalidate(2, state);
		}
	}

	function dialog1_visible_binding(value) {
		if ($$self.$$.not_equal(state.settingmenuopen, value)) {
			state.settingmenuopen = value;
			$$invalidate(2, state);
		}
	}

	const click_handler_3 = () => $$invalidate(2, state.snackback = false, state);

	function snackbar_visible_binding(value) {
		if ($$self.$$.not_equal(state.snackback, value)) {
			state.snackback = value;
			$$invalidate(2, state);
		}
	}

	$$self.$$set = $$props => {
		if ('xml' in $$props) $$invalidate(17, xml = $$props.xml);
		if ('editorState' in $$props) $$invalidate(18, editorState = $$props.editorState);
		if ('l' in $$props) $$invalidate(0, l = $$props.l);
		if ('getChildXml' in $$props) $$invalidate(19, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		AH,
		XMLToJSON,
		Button,
		Dialog,
		Checkbox,
		Snackbar,
		writable,
		onMount,
		onDestroy,
		xml,
		editorState,
		l,
		getChildXml,
		cmTime,
		math_eq_count,
		multiline_count,
		drag_drop_count,
		drop_down_count,
		timer,
		replaceCharacters,
		message,
		state,
		dragSingle,
		hdd,
		unsubscribe,
		loadModule,
		parseXmlAuthoring,
		htmlSpecialChars,
		reverseHtmlSpecialChars,
		reverseXml,
		didMount,
		setFillType,
		initEditor,
		createTableHtml,
		createTables,
		addEvent,
		storeAttr,
		addDropDownOption,
		addDragDropOption,
		addMultiLineOption,
		addMathEquation,
		updateDialog,
		handleOpen,
		handleClose,
		editTextbox,
		editMathbox,
		editSelectbox,
		editDragDrop,
		editMultiline,
		showError,
		replaceCharactersFunc,
		storeAns,
		removeDragDrop,
		removeDropDown,
		removeMathEquation,
		addEditable,
		latexEdit,
		updatedropdown,
		openSetting,
		handleSetting
	});

	$$self.$inject_state = $$props => {
		if ('xml' in $$props) $$invalidate(17, xml = $$props.xml);
		if ('editorState' in $$props) $$invalidate(18, editorState = $$props.editorState);
		if ('l' in $$props) $$invalidate(0, l = $$props.l);
		if ('getChildXml' in $$props) $$invalidate(19, getChildXml = $$props.getChildXml);
		if ('cmTime' in $$props) cmTime = $$props.cmTime;
		if ('math_eq_count' in $$props) math_eq_count = $$props.math_eq_count;
		if ('multiline_count' in $$props) multiline_count = $$props.multiline_count;
		if ('drag_drop_count' in $$props) drag_drop_count = $$props.drag_drop_count;
		if ('drop_down_count' in $$props) drop_down_count = $$props.drop_down_count;
		if ('timer' in $$props) timer = $$props.timer;
		if ('replaceCharacters' in $$props) replaceCharacters = $$props.replaceCharacters;
		if ('message' in $$props) $$invalidate(1, message = $$props.message);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
		if ('dragSingle' in $$props) $$invalidate(3, dragSingle = $$props.dragSingle);
		if ('hdd' in $$props) hdd = $$props.hdd;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		l,
		message,
		state,
		dragSingle,
		addDropDownOption,
		addDragDropOption,
		addMathEquation,
		updateDialog,
		handleClose,
		storeAns,
		removeDragDrop,
		removeDropDown,
		removeMathEquation,
		addEditable,
		latexEdit,
		openSetting,
		handleSetting,
		xml,
		editorState,
		getChildXml,
		click_handler,
		click_handler_1,
		click_handler_2,
		input1_input_handler,
		input_change_handler,
		input1_input_handler_1,
		input_input_handler,
		dialog0_visible_binding,
		dialog1_visible_binding,
		click_handler_3,
		snackbar_visible_binding
	];
}

class FillInTheBlanks extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				xml: 17,
				editorState: 18,
				l: 0,
				getChildXml: 19
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FillInTheBlanks",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[17] === undefined && !('xml' in props)) {
			console_1.warn("<FillInTheBlanks> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[18] === undefined && !('editorState' in props)) {
			console_1.warn("<FillInTheBlanks> was created without expected prop 'editorState'");
		}

		if (/*l*/ ctx[0] === undefined && !('l' in props)) {
			console_1.warn("<FillInTheBlanks> was created without expected prop 'l'");
		}

		if (/*getChildXml*/ ctx[19] === undefined && !('getChildXml' in props)) {
			console_1.warn("<FillInTheBlanks> was created without expected prop 'getChildXml'");
		}
	}

	get xml() {
		throw new Error("<FillInTheBlanks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<FillInTheBlanks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<FillInTheBlanks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<FillInTheBlanks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get l() {
		throw new Error("<FillInTheBlanks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<FillInTheBlanks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<FillInTheBlanks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<FillInTheBlanks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default FillInTheBlanks;
//# sourceMappingURL=FillInTheBlanks-a5023d36.js.map
