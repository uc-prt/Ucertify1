
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, a7 as Lang, v as validate_slots, o as onMount, A as AH, a8 as swal, a9 as afterUpdate, X as XMLToJSON, _ as onUserAnsChange, w as writable, f as space, h as text, ai as svg_element, j as attr_dev, k as add_location, n as insert_dev, q as listen_dev, F as set_data_dev, B as noop, x as detach_dev } from './main-1b18ba06.js';
import { s as styleInject } from './style-inject.es-1c867377.js';

var css_248z = "body, html{     \r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -khtml-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none;  \r\n}\r\n\r\n[tabindex=\"0\"]:focus {\r\n    box-shadow: 0 0 0 .09rem #89ace4!important;\r\n    outline: 0;\r\n}\r\n\r\n.compass_route {\r\n    stroke: #979797;\r\n    fill: transparent;\r\n    stroke-width: 2;\r\n    stroke-linecap: round;\r\n    stroke-dasharray: 0,9;\r\n}\r\n\r\n.compass_radius {\r\n    stroke: #979797;\r\n    stroke-width: 2;\r\n}\r\n\r\n.compass_center {\r\n    cursor: move;\r\n    stroke: #979797;\r\n    stroke-width: 2;\r\n}\r\n\r\n.compass_radius_icon {\r\n    stroke: #979797;\r\n    stroke-width: 2;\r\n}\r\n\r\n.compass_center:hover,\r\n.compass_center:focus,\r\n.compass_radius:focus,\r\n.compass_radius:hover,\r\n.compass_radius_icon:focus,\r\n.compass_radius_icon:hover {\r\n    stroke: #666666;\r\n}\r\n\r\n.compass_rotation:hover,\r\n.compass_radius_icon:hover,\r\n.compass_center:hover,\r\n.compass_rotation:focus,\r\n.compass_radius_icon:focus,\r\n.compass_center:focus {\r\n    opacity: 1;\r\n}\r\n\r\n.compass_rotation,\r\n.compassRotationBar,\r\n.compass_radius_icon {\r\n    cursor: pointer;\r\n    opacity: 0.6;\r\n}\r\n\r\n.centerImg svg {\r\n    position: absolute;\r\n    top: 0; \r\n    left: 0;\r\n    cursor: crosshair;\r\n}\r\n\r\n.eraserHover:hover,\r\n.eraserHover:focus {\r\n    opacity: 0.5;\r\n}\r\n\r\n.drawing-compass-pointer-border {\r\n    opacity: 0.6;\r\n    stroke-width: 2;\r\n    stroke: #979797;\r\n    fill: #f8f8ff;\r\n}\r\n\r\n#svgImgPreview,\r\n#svgImg {\r\n    max-width: none;\r\n}\r\n\r\n.lastCircle_hover {\r\n    stroke: #000;\r\n    fill: #aaa;\r\n    cursor: grab;\r\n}\r\n\r\n.resize {\r\n    z-index: 20!important;\r\n    cursor: move;\r\n    background-color: rgba(240,240,240,.6)!important;\r\n    box-shadow: 0 0 1px #000 inset;\r\n    position:absolute;\r\n    top: 35px;\r\n    left: 57px;\r\n    height: 66px;\r\n    width: 66px;\r\n    -webkit-border-radius: 100%;\r\n    -moz-border-radius: 100%;\r\n    border-radius: 100%;\r\n}\r\n#moveDrawIcon {\r\n    top: 50px;\r\n    left: 50px;\r\n    z-index: 500;\r\n    margin-top: -7px;\r\n    margin-left: -7px;\r\n}\r\n.drawing_module_container .btn-light {\r\n    background-color: #ebebeb !important;\r\n}\r\n.previewDrawingPaths path:focus {\r\n    opacity: 0.5;\r\n    outline: none;\r\n}\r\n\r\n.drawing_module_container .btn-light:not(:disabled):not(.disabled):active:focus,\r\n.drawing_module_container .btn-light:not(:disabled):not(.disabled).active:focus {\r\n    box-shadow: 0 0 0 0.2rem #aaa9!important;\r\n}\r\n\r\n.currentFocusPoint {\r\n    stroke: #027f02!important;\r\n}\r\n\r\n.centerImg svg:focus {\r\n    -webkit-box-shadow: inset 1px 1px 12px #ccc !important;\r\n    -moz-box-shadow: inset 1px 1px 12px #ccc !important;\r\n    box-shadow: inset 1px 1px 12px #ccc !important;\r\n    outline: 0;\r\n}\r\n\r\npath.answer_mark:focus {\r\n    opacity: 0.5;\r\n}\r\n\r\n.resizer {\r\n    width: 15px;\r\n    height: 15px;\r\n    position: absolute;\r\n    right: 0;\r\n    bottom: 0;\r\n    cursor: se-resize\r\n}\r\n\r\n#drawing-modal .modal-body,\r\n#drawing_shortcut_modal .modal-body {\r\n    max-height: 350px;\r\n}\r\n\r\n.shortcutTable [tabindex=\"0\"]:focus {\r\n    outline: -webkit-focus-ring-color auto 1px;\r\n}\r\n\r\n#drawingPreviewMain .h {\r\n    display: none !important;\r\n}\r\n\r\n.drawing_bgimg {\r\n    margin-right: 32px;\r\n    pointer-events: none;\r\n    opacity: 0.4;\r\n}\r\n\r\n#upload_media {\r\n    margin-top: 28px;\r\n}\r\n\r\n.setting_btn {\r\n    right: 1px;\r\n    top: 1px;\r\n    z-index: 1;\r\n}\r\n\r\n.drawing_module_container button:disabled {\r\n    pointer-events: auto !important;\r\n}";
styleInject(css_248z);

/* clsSMDrawing\DrawingPreview.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMDrawing\\DrawingPreview.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1tmjbvw-style";
	style.textContent = ".mr-2.svelte-1tmjbvw{margin-right:0.5em !important}#previewSvg.svelte-1tmjbvw{width:600px;height:520px;margin-top:-550px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRHJhd2luZ1ByZXZpZXcuc3ZlbHRlIiwic291cmNlcyI6WyJEcmF3aW5nUHJldmlldy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLVxyXG4gKiAgRmlsZSBOYW1lICAgOiBEcmF3aW5nUHJldmlldy5zdmVsdGVcclxuICogIERlc2NyaXB0aW9uIDogUmVzcG9uc2libGUgZm9yIFByZXZpZXcgU2lkZSBmdW5jdGlvbmFsaXR5XHJcbiAqICBBdXRob3IgICAgICA6IEF5dXNoIFNyaXZhc3RhdmFcclxuICogIFBhY2thZ2UgICAgIDogY2xzU01EcmF3aW5nIChQcmV2aWV3KVxyXG4gKiAgTGFzdCB1cGRhdGUgOiAwOS1BcHJpbC0yMDIxXHJcbiAqICBMYXN0IFVwZGF0ZWQgQnkgOiBBeXVzaCBTcml2YXN0YXZhXHJcbi0tPlxyXG48c2NyaXB0PlxyXG4gICAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcblx0aW1wb3J0IHsgQUggLCBvblVzZXJBbnNDaGFuZ2UsIFhNTFRvSlNPTn0gZnJvbSAnLi4vaGVscGVyL0hlbHBlckFJLnN2ZWx0ZSc7XHJcbiAgICBpbXBvcnQgbCBmcm9tICcuLi9zcmMvbGlicy9MYW5nJztcclxuICAgIGltcG9ydCBzd2FsIGZyb20gJ3N3ZWV0YWxlcnQnO1xyXG5cdGltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xyXG4gICAgaW1wb3J0ICcuLi9zcmMvbGlicy9kcmF3aW5nLmNzcyc7XHJcbiAgICBcclxuICAgIC8vIGV4cG9ydGluZyB0aGUgdmFyaWFibGVzXHJcbiAgICBleHBvcnQgbGV0IHhtbDtcclxuXHRleHBvcnQgbGV0IHV4bWw7XHJcblx0ZXhwb3J0IGxldCBpc1JldmlldztcclxuXHRleHBvcnQgbGV0IHNob3dBbnM7XHJcblx0ZXhwb3J0IGxldCBlZGl0b3JTdGF0ZTtcclxuXHJcbiAgICBsZXQgYmdJbWdQYXRoID0gJ2h0dHBzOi8vczMuYW1hem9uYXdzLmNvbS9qaWd5YWFzYV9jb250ZW50X3N0YXRpYy8nO1xyXG4gICAgbGV0IHhtbG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xyXG4gICAgLy8gZGVub3RlcyB0aGF0IGRyYXdpbmcgaXMgbm90IHNrZXRjaGluZ1xyXG4gICAgbGV0IGlzRHJhd2luZ1ByZXZpZXcgPSBmYWxzZTtcclxuICAgIC8vIGFsbG93IHRvIGRyYXcgdGhlIGRyYXdpbmcgdXNpbmcgY29tcGFzc1xyXG4gICAgbGV0IGlzRHJhd0NvbXBhc3NQcmV2aWV3ID0gdHJ1ZTtcclxuICAgIC8vIGluZGljYXRlcyB0aGF0IHN0YXJ0aW5nIHBvc2l0aW9uIHNob3VsZCBiZSBzdG9yZSB3aGVuIHBlcmZvcm0gdXNpbmcga2V5Ym9hcmQgYW5kIGNvbXBhc3NcclxuICAgIGxldCBpc1N0b3JlU3RhcnQgPSBmYWxzZTtcclxuICAgIC8vIGluZGljYXRlcyB0aGF0IGRyYXdpbmcgaXMgbm90IHN0YXJ0ZWRcclxuICAgIGxldCBpc0RyYXdTdG9wID0gMDtcclxuICAgIC8vIHNob3dzIHRoYXQgaXMgZHJhd2luZyBzdGFydGVkIGJ5IGtleWJvYXJkXHJcbiAgICBsZXQgc3RhcnREcmF3aW5nQnlLZXkgPSAwO1xyXG4gICAgLy8gdXNlZCB0byBjcmVhdGVzIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZSBVUkkgYW5kIHF1YWxpZmllZCBuYW1lXHJcbiAgICBsZXQgc2NyaWJibGU7XHJcbiAgICAvLyBkZW5vdGVzIG1vdXNlIGNvLW9yZGluYXRlc1xyXG4gICAgbGV0IHByZXZpZXdfbW91c2VYLCBwcmV2aWV3X21vdXNlWTtcclxuICAgIC8vIHNjcmliYmxlIGRyYXdpbmcgdG9vbCBpcyBlbmFibGVcclxuICAgIGxldCBwcmV2aWV3TW9kZSA9ICdzY3JpYmJsZSc7XHJcbiAgICAvLyBzdHJpa2UgY29sb3Igb2YgZHJhd2luZ1xyXG4gICAgbGV0IHByZXZpZXdDb2xvciA9ICcjMDBCQ0Q0JztcclxuICAgIC8vIHN0cm9rZSB3aWR0aCBvZiB0aGUgZHJhd2luZ1xyXG4gICAgbGV0IHByZXZpZXdUaGlja25lc3MgPSA1O1xyXG4gICAgLy8gY29udGFpbnMgb2JqZWN0IHRoYXQgaGF2ZSBrZXkgdHlwZSwgaW5kZXgsIG1vZGUsIG9yZGVyIGFuZCBkXHJcbiAgICBsZXQgcHJldmlld1NjcmliYmxlUGF0aCA9IFtdO1xyXG4gICAgLy8gc2hvd3MgbnVtYmVyIG9mIGRyYXdpbmcgc2tldGNoZWQgd2l0aCB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICBsZXQgcHJldmlld1NjcmliYmxlQ291bnQgPSAwO1xyXG4gICAgLy8gY29udGFpbnMgY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uXHJcbiAgICBsZXQgY2hlY2tDdXJyZW50UG9zaXRpb25YO1xyXG4gICAgLy8gY29udGFpbnMgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uXHJcbiAgICBsZXQgY2hlY2tDdXJyZW50UG9zaXRpb25ZO1xyXG4gICAgLy8gZGVub2VzIG5vIG9mIHVuZG8gZG9uZVxyXG4gICAgbGV0IHByZXZpZXdVbmRvQ291bnQgPSAwO1xyXG4gICAgLy8gY29udGFpbnMgdW5kbyBkYXRhXHJcbiAgICBsZXQgcHJldmlld1VuZG9MaXN0ID0gW107XHJcbiAgICAvLyBjb250YWlucyByZWRvIGRhdGFcclxuICAgIGxldCBwcmV2aWV3UmVkb0xpc3QgPSBbXTtcclxuICAgIC8vIGNvbnRhaW5zIHRoZSBmb2N1c1BvaW50c1xyXG4gICAgbGV0IGFjY2Vzc2liaWxpdHlQb2ludHNQcmV2aWV3ID0gW107XHJcbiAgICAvLyBudW1iZXIgb2YgZm9jdXMgcG9pbnQgZXhpc3RcclxuICAgIGxldCBmb2N1c1BvaW50Q291bnRQcmV2aWV3ID0gMTtcclxuICAgIC8vIHVzZWQgZm9yIG5vdCBmb2N1cyBvbiBwZXJ0aWN1bGFyIHBvaW50XHJcbiAgICBsZXQgbG9ja0ZvY3VzID0gMDtcclxuICAgIC8vIGRlbm90ZXMgdGhhdCBzY3JpYmJsZSBkcmF3aW5nIGlzIG5vdCBza2V0Y2hpbmdcclxuICAgIGxldCBpc1NjcmliYmxlID0gMDtcclxuICAgIC8vIGZvciBjb21wYXNzIHZhcmlhYmxlXHJcbiAgICAvLyBkZW5vdGVzIHggY28tb3JkaW5hdGUgb2YgdGhlIGNlbnRlclxyXG4gICAgbGV0IGN4O1xyXG4gICAgLy8gZGVub3RlcyB5IGNvLW9yZGluYXRlIG9mIHRoZSBjZW50ZXJcclxuICAgIGxldCBjeTtcclxuICAgIC8vIGRlbm90ZXMgeCBjby1vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIG1pZGRsZSBjaXJjbGUgbGllcyBvbiByb3RhdGlvbmJhclxyXG4gICAgbGV0IG1pZENpcmNsZV9jeDtcclxuICAgIC8vIGRlbm90ZXMgeSBjby1vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIG1pZGRsZSBjaXJjbGUgbGllcyBvbiByb3RhdGlvbmJhclxyXG4gICAgbGV0IG1pZENpcmNsZV9jeTtcclxuICAgIC8vIGRlbm90ZXMgeCBjby1vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHNtYWxsIG1pZGRsZSBjaXJjbGUgbGllcyBvbiByb3RhdGlvbmJhclxyXG4gICAgbGV0IG1pZFNtYWxsQ2lyY2xlX2N4O1xyXG4gICAgLy8gZGVub3RlcyB5IGNvLW9yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2Ygc21hbGwgbWlkZGxlIGNpcmNsZSBsaWVzIG9uIHJvdGF0aW9uYmFyXHJcbiAgICBsZXQgbWlkU21hbGxDaXJjbGVfY3k7XHJcbiAgICAvLyBkZW5vdGVzIHggY28tb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiBsYXN0IGNpcmNsZSBsaWVzIG9uIHJvdGF0aW9uYmFyXHJcbiAgICBsZXQgbGFzdENpcmNsZV9jeDtcclxuICAgIC8vIGRlbm90ZXMgeSBjby1vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIGxhc3QgY2lyY2xlIGxpZXMgb24gcm90YXRpb25iYXJcclxuICAgIGxldCBsYXN0Q2lyY2xlX2N5O1xyXG4gICAgLy8gZGVub3RlcyB4IGNvLW9yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2Ygcm90YXRpb24gaW5kaWNhdG9yIHRoYXQgY2FuIGJlIHNlZW4gYWZ0ZXIgbGFzdCBjaXJjbGUgb24gcm90YXRpb25iYXJcclxuICAgIGxldCBsYXN0U21hbGxDaXJjbGVfY3g7XHJcbiAgICAvLyBkZW5vdGVzIHkgY28tb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiByb3RhdGlvbiBpbmRpY2F0b3IgdGhhdCBjYW4gYmUgc2VlbiBhZnRlciBsYXN0IGNpcmNsZSBvbiByb3RhdGlvbmJhclxyXG4gICAgbGV0IGxhc3RTbWFsbENpcmNsZV9jeTtcclxuICAgIC8vIGRlZmluZXMgdGhlIGNvbXBhc3MgcmFkaXVzXHJcbiAgICBsZXQgcHJldmlld0NvbXBhc3NSYWRpdXMgPSAxMDA7XHJcbiAgICAvLyBkZW5vdGVzIHRoYXQgY29tcGFzcyBpcyBub3QgbW92ZWRcclxuICAgIGxldCBpc1ByZXZpZXdDb21wYXNzTW92ZSA9IGZhbHNlO1xyXG4gICAgLy8gc2V0cyB0aGUgZGVmYXVsdCBhbmdsZSBvZiBjb21wYXNzXHJcbiAgICBsZXQgcHJldmlld0NvbXBhc3NBbmdsZSA9IDkwO1xyXG4gICAgLy8gZGVub3RlcyB0aGF0IGNvbXBhc3MgcmFkaXVzIG5vdCBpbmNyZWFzZWRcclxuICAgIGxldCBpc1ByZXZpZXdSYWRpdXNJbmNyZWFzZSA9IDA7XHJcbiAgICAvLyBkZW5vdGVzIGluaXRpYWwgcG9pbnRzIGNvLW9yZGluYXRlXHJcbiAgICBsZXQgaW5pdGlhbFBvaW50ID0geyB4OiBudWxsLCB5OiBudWxsIH07XHJcbiAgICAvLyBkZW5vdGVzIGZpbmFsIHBvaW50cyBjby1vcmRpbmF0ZVxyXG4gICAgbGV0IGZpbmFsUG9pbnQgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcclxuICAgIC8vIGRlbm90ZXMgbm8gYW5nbGUgZGlzcGxhY2VkXHJcbiAgICBsZXQgY29tcGFzc0FuZ2xlRGlzcGxhY2VtZW50ID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XHJcbiAgICAvLyBkZW5vdGVzIHRoYXQgaXMgcmFkaXVzIHJvdGF0ZWRcclxuICAgIGxldCBpc1ByZXZpZXdSYWRpdXNSb3RhdGUgPSAwO1xyXG4gICAgLy8geSBjby1vcmRpbmF0ZSBvZiB0aGUgbWFya2VkIHBvaW50XHJcbiAgICBsZXQgY3Vyc29yVG9wID0gNTA7XHJcbiAgICAvLyB4IGNvLW9yZGluYXRlIG9mIHRoZSBtYXJrZWQgcG9pbnRcclxuICAgIGxldCBjdXJzb3JMZWZ0ID0gNTA7XHJcbiAgICAvLyB1c2VkIGZvciBhbnN3ZXIgcmVjb3JkaW5nXHJcbiAgICBsZXQgZGVmYXVsdFhNTCA9ICcnO1xyXG4gICAgbGV0IGNkYXRhID0gJyc7XHJcbiAgICAvLyBkZW5vdGVzIHRoYXQgYW5zd2VyIGlzIGluY29ycmVjdFxyXG4gICAgbGV0IGlzQW5zd2VyQ29ycmVjdCA9IGZhbHNlO1xyXG4gICAgLy8gZm9yIG1hcmtpbmdcclxuICAgIGxldCBpc01hcmtpbmcgPSAxO1xyXG4gICAgLy8gY29udGFpbnMgdGhlIGNvLW9yZGluYXRlcyBvZiBtYXJrZWQgcG9pbnRcclxuICAgIGxldCBtYXJrUG9pbnRzID0gW107XHJcbiAgICAvLyBkZW5vdGVzIGFycmF5IG9mIGRyYXdpbmcgdG9vbHNcclxuICAgIGxldCBzZWxlY3RlZFRvb2xzQXJyYXkgPSBbXCJfc2NyaWJibGVcIiwgXCJfbGluZVwiLCBcIl9jb21wYXNzXCJdO1xyXG4gICAgLy8gZm9yIHVzZXIgYW5zd2VyXHJcbiAgICBsZXQgdXNlckFuc1BhdGggPSBbXTtcclxuICAgIC8vIGluaXRpYWwgbGF5b3V0IG9mIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgbGV0IHVzZXJBbnNYTUwgPSAnPHNtYW5zIHR5cGU9XCI0MVwiPjwvc21hbnM+JztcclxuICAgIC8vIGNvbnRhaW5zIHRoZSB4IGFuZCB5IGNvLW9yZGluYXRlIG9mIHRoZSBwb2ludHMgbWFya2VkIGJ5IHVzZXJcclxuICAgIGxldCB1c2VyTWFya2luZ1BvaW50ID0gW107XHJcbiAgICAvLyBjb250YWlucyBkcmF3aW5nIHNrZXRjaGVkIGJ5IHVzZXIgYnkgdGhlIGhlbHAgb2YgZHJhd2luZyB0b29sc1xyXG4gICAgbGV0IHVzZXJEcmF3UGF0aCA9IFtdO1xyXG4gICAgLy8gZGVub3RlcyB0aGF0IGFuc3dlciBpcyBpbmNvcnJlY3RcclxuICAgIGxldCB1c2VyQW5zQ29ycmVjdCA9IGZhbHNlO1xyXG4gICAgLy8gY29udGFpbnMgdGhlIGNvLW9yZGluYXRlcyBvZiBtYXJrZWQgcG9pbnRcclxuICAgIGxldCBtYXJrUG9pbnRzRGF0YSA9IFtdO1xyXG4gICAgLy8gZm9yIGJyb3dzZXJzXHJcbiAgICBsZXQgaXNfbWFjID0gZmFsc2U7XHJcblxyXG4gICAgbGV0IHByZXZfc3RvcmUgPSB3cml0YWJsZSh7XHJcbiAgICAgICAgLy8gY29udGFpbnMgc3RhdHVzIG9mIHRoZSBhbnN3ZXJcclxuICAgICAgICBjb3JyZWN0QW5zd2VyOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHhtbCBvZiB0aGUgcHJvcHNcclxuICAgICAgICB4bWw6ICcnLFxyXG4gICAgICAgIC8vIG5vdCB1c2VkIGFueSB3aGVyZVxyXG4gICAgICAgIG9wZW5JbWc6IGZhbHNlLFxyXG4gICAgICAgIC8vIG5vdCB1c2VkIGFueSB3aGVyZVxyXG4gICAgICAgIG9wZW5EcmFnOiBmYWxzZSxcclxuICAgICAgICAvLyBkZW5vdGVzIGJhY2tncm91bmQgaW1hZ2VcclxuICAgICAgICBiZ0ltZzogJ3VzZXJhY2NvdW50XzAwMEFOdi5wbmcnLFxyXG4gICAgICAgIC8vIG5vdCB1c2VkIGFueSB3aGVyZSBcclxuICAgICAgICBjZGF0YTogJycsXHJcbiAgICAgICAgLy8gY29udGFpbnMgY2RhdGEgdmFsdWUgb2YgYmFja2dyb3VuZFBvaW50IG9mIHNteG1sIFxyXG4gICAgICAgIGZvY3VzREFUQTogJycsXHJcbiAgICAgICAgLy8gbm90IHVzZWQgYW55IHdoZXJlIFxyXG4gICAgICAgIHVzZXJYTUw6ICcnLFxyXG4gICAgICAgIC8vIHN0cm9rZSBjb2xvciBvZiB0aGUgZHJhd2luZyBza2V0Y2ggYnkgdGhlIGhlbHAgb2YgZHJhd2luZyB0b29sc1xyXG4gICAgICAgIGxpbmVDb2xvcjogJyMwMEJDRDQnLFxyXG4gICAgICAgIC8vIGNvbnRhaW5zIGRyYXdpbmcgdG9vbHMgYXJyYXlcclxuICAgICAgICBzZWxlY3RlZFRvb2xzOiBzZWxlY3RlZFRvb2xzQXJyYXksXHJcbiAgICAgICAgLy8gZGVub3RlcyByZW1lZGlhdGlvbiBtb2RlIGlzIG9mZlxyXG4gICAgICAgIHJlbWVkaWF0aW9uTW9kZTogJ29mZicsXHJcbiAgICAgICAgLy8gd2lkdGggb2YgdGhlIGJhY2tncm91bmQgaW1hZ2VcclxuICAgICAgICBpbWdXaWR0aDogXCI2MDBcIixcclxuICAgICAgICAvLyBhbHQgbWVzc2FnZSBvZiBiYWNrZ3JvdW5kIGltYWdlXHJcbiAgICAgICAgYWx0OiBcIlRyaWFuZ2xlIGltYWdlXCIsXHJcbiAgICAgICAgLy8gc2V0cyBjb2xvciBvZiB0aGUgbWFyayBwb2ludHNcclxuICAgICAgICBtYXJrUG9pbnRDb2xvcjogJyMwMGZmMDAnLFxyXG5cdH0pO1xyXG4gICAgXHJcbiAgICAvLyBzdWJzY3JpYmluZyB0aGUgc3RvcmUgaW4gdGhlIHN0YXRlIHZhcmlhYmxlXHJcbiAgICBsZXQgc3RhdGUgPSB7fTtcclxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcHJldl9zdG9yZS5zdWJzY3JpYmUodmFsdWUgPT4ge1xyXG5cdFx0c3RhdGUgPSB2YWx1ZTtcclxuXHR9KTtcclxuXHJcbiAgICAvLyBmb3IgYWRkaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50cyBhbmQgdGhlIGNzcyBmaWxlc1xyXG4gICAgb25Nb3VudChhc3luYygpID0+IHtcclxuICAgICAgICAvLyBjaGVja2VkIGZvciBtYWMgZGV2aWNlXHJcbiAgICAgICAgaXNfbWFjID0gKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1hY1wiKSAhPSAtMSlcclxuICAgICAgICAvLyB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiByb3RhdGlvbmJhciBhbmQgY2hhbmdlIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIGNpcmNsZXMgdGhhdCBsaWVzIG9uIHJvdGF0aW9uYmFyXHJcbiAgICAgICAgdXBkYXRlUHJldmlld0NvbXBhc3NDYWxjdWxhdGlvbigxNjAsIDExOCwgMTAwLCA5MCk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdjbGljaycsICcjc2V0LXJldmlldycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2V0UmV2aWV3KClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ2NsaWNrJywgJyN1bnNldC1yZXZpZXcnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHVuc2V0UmV2aWV3KClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ2NsaWNrJywgJyNwcmV2aWV3X3Jlc2V0X2J0bicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dhbCh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBsLnJlc2V0X21vZHVsZSxcclxuICAgICAgICAgICAgICAgIGljb246IFwid2FybmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uczogdHJ1ZSxcclxuICAgICAgICAgICAgfSkudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGFsbCB0aGUgYWN0aXZpdHkgYW5kIG1ha2VzIGl0IGluIGluaXRpYWwgY29uZGl0aW9uIGFzIGl0IGxvb2tzIGxpa2UganVzdCBhZnRlciBsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VYTUxGb3JHZXR0aW5nRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlaW5pdGlhbGl6ZUZvdWNzRXZlbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8qKiBTdGFydCBvZiBrZXkgZXZlbnRzICoqL1xyXG4gICAgICAgIC8vIHRvIHN0b3Agc2Nyb2xsaW5nIG9mIHBhZ2UgYnkgc3BhY2UgYW5kIGFycm93IGtleXNcclxuICAgICAgICBBSC5iaW5kKCdib2R5JywgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFlZGl0b3JTdGF0ZSAmJiAoZXZlbnQua2V5Q29kZSA9PSAzMiB8fCBldmVudC5rZXlDb2RlID09IDM3IHx8IGV2ZW50LmtleUNvZGUgPT0gMzggfHwgZXZlbnQua2V5Q29kZSA9PSAzOSB8fCBldmVudC5rZXlDb2RlID09IDQwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdrZXl1cCcsICcucHJldmlld0tleVN2ZyAucHJldmlld0RyYXdpbmdQYXRocyBwYXRoJywgZnVuY3Rpb24gKGN1cnJlbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDQ2IHx8IChldmVudC5rZXlDb2RlID09IDggJiYgaXNfbWFjKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyBkcmF3aW5nIG9uIHdoaWNoIGtleXVwIGV2ZW50IHRyaWdnZXJlZCBhbmQgdXBkYXRlIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgICAgIGVyYXNlcihjdXJyZW50LCBwcmV2aWV3U2NyaWJibGVQYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAna2V5dXAnLCAnLnByZXZpZXdLZXlTdmcnLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gOTAgJiYgZXZlbnQuY3RybEtleSAmJiAhIEFILnNlbGVjdCgnI3ByZXZpZXdfdW5kbycpLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREcmF3aW5nQnlLZXkgJiYgaXNEcmF3U3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgdGhlIGRyYXdpbmcgYW5kIHN0b3JlIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHRoZSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2xpY2sgdGhlIHVuZG8gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3VuZG8nKS5jbGljaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDg5ICYmIGV2ZW50LmN0cmxLZXkgJiYgISBBSC5zZWxlY3QoJyNwcmV2aWV3X3JlZG8nKS5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RHJhd2luZ0J5S2V5ICYmIGlzRHJhd1N0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHRoZSBkcmF3aW5nIGFuZCBzdG9yZSB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB0aGUgdXNlciBhbmQgc2V0cyB0aGUgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcERyYXcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNsaWNrIHRoZSByZWRvIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19yZWRvJykuY2xpY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA4OCAmJiBldmVudC5jdHJsS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGljayB0aGUgY2xlYXIgc2NyZWVuICh4KSBidXR0b25cclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdfY2xlYXJTY3JlZW4nKS5jbGljaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDMyKSAmJiBwcmV2aWV3TW9kZSAhPSAnY29tcGFzcycgJiYgcHJldmlld01vZGUgIT0gJ2VyYXNlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIGhpZGVzIHRoZSBpY29uICgrKSB1c2VkIHRvIHNrZXRjaCB0aGUgZHJhd2luZyB1c2luZyBrZXlib2FyZFxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjbW92ZURyYXdJY29uJywgJ3JlbW92ZUNsYXNzJywgJ2gnKTtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIGN1cnNvciBzdHlsZSB0byBhdXRvXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJy5wcmV2aWV3S2V5U3ZnJywgJ2NzcycsIHsnY3Vyc29yJzogJ2F1dG8nfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIChldmVudC5rZXlDb2RlID09IDEzIHx8IGV2ZW50LmtleUNvZGUgPT0gMzIpICYmIEFILnNlbGVjdCgnI21vdmVEcmF3SWNvbicpLm9mZnNldEhlaWdodCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlld01vZGUgPT0gJ21hcmtQb2ludHMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UgVVJJIGFuZCBxdWFsaWZpZWQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgJ2NpcmNsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3Q29sb3Ioc3RhdGUubWFya1BvaW50Q29sb3IsIHByZXZpZXdUaGlja25lc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdjbGFzcycgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCAnYW5zd2VyX21hcmsnKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnY3gnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4JywgY3Vyc29yTGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2N5JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIGN1cnNvclRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ3InICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCAnMnB4Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGVzIHRoZSB4IGFuZCB5IGNvLW9yZGluYXRlIG9mIHRoZSBtb3VzZSBpbnRvIG1hcmtQb2ludHMgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBtYXJrUG9pbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjdXJzb3JMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjdXJzb3JUb3BcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBlbGVtZW50IHN0b3JlZCBpbnRvIHZhcmlhYmxlIHNjcmliYmxlIGluIG1hcmsgcG9pbnQgY29udGFpbmVyIGluIHdoaWNoIGRyYXdpbmdzIGFyZSBzdG9yZWQgZG9uZSBieSB0aGUgaGVscCBvZiAnTWFyayBQb2luJyBBbmQgJ0ZpbmlzaCBNYXJraW5nJyBidXR0b25zXHJcbiAgICAgICAgICAgICAgICAgICAgQUguc2VsZWN0KCcucHJldmlld01hcmtpbmdQYXRocycpLnByZXBlbmQoc2NyaWJibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyB0aGUgYW5zd2VyIGFuZCB1cGRhdGVzIHRoZSBzdGF0dXMgYW5kIGVuYWJsZXMgJ01hcmsgUG9pbnRzJyBidXR0b24gYW5kIGFsc28gdXBkYXRlcyBpdHMgdGV4dCBhcyAnTWFyayBQb2ludHMnIFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlWE1MRm9yQW5zd2VyKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVVYTUwoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRHJhd1N0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCB0aGUgZHJhd2luZyBhbmQgc3RvcmUgdGhlIGRyYXdpbmcgc2tldGNoZWQgYnkgdGhlIHVzZXIgYW5kIHNldHMgdGhlIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wRHJhdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RHJhd2luZ0J5S2V5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgYWxsIG1hcmsgcG9pbnRzIGFuZCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2lzTUFya2luZycgdG8gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhck1hcmtpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHZhbHVlIG9mIHZhcmlhYmxlIHhtbG5zIG5hbWVzcGFjZSBVUkkgYW5kICdwYXRoJyBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmliYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAncGF0aCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSBzdHJva2UgY29sb3IgYW5kIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByZXZpZXdDb2xvcihwcmV2aWV3Q29sb3IsIHByZXZpZXdUaGlja25lc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZGF0YS10eXBlJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS10eXBlJywgcHJldmlld01vZGUgKyAnXycgKyBwcmV2aWV3U2NyaWJibGVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkYXRhLW9yZGVyJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1vcmRlcicsIHByZXZpZXdTY3JpYmJsZUNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2QnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00nICsgY3Vyc29yTGVmdCArICcgJyArIGN1cnNvclRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICd0YWJpbmRleCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RhYmluZGV4JywgJzAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIGN1cnNvciBsZWZ0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ3VycmVudFBvc2l0aW9uWCA9IGN1cnNvckxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSBjdXJzb3IgdG9wIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ3VycmVudFBvc2l0aW9uWSA9IGN1cnNvclRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGVzIG9iamVjdCBoYXZpbmcga2V5cyBtb2RlLCBvcmRlciwgdHlwZSwgaW5kZXggYW5kIGQgd2l0aCB0aGVpciB2YWx1ZXMgaW50byAgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5lIHRoYXQgcGVydGljdWxhciBzZXF1ZW5jZSBlbGVtZW50IHdpbGwgYmUgcmVtb3ZlZCBvciBhZGRlZCBvbiBkcmF3aW5nIGJvYXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAnYWRkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmluZXMgd2hhdCBpcyB0aGUgc2VxdWVuY2Ugb2YgcGVydGljdWxhciBkcmF3aW5nIG9uIGRyYXdpbmcgYm9hcmQgbWVhbnMgd2hlbiBpdCBpcyBkcmF3biB0aGVuIGhvdyBtYW55IGRyYXdpbmcgYWxyZWFkeSBkb25lIGFuZCBpdCBzdGFydHMgd2l0aCAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogcHJldmlld1NjcmliYmxlQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbmVzIHdoaWNoIGRyYXdpbmcgdG9vbCBpcyB1c2VkIGZvciBza2V0Y2ggdGhlIGRyYXdpbmcgd2l0aCBpdHMgc2VxdWVuY2Ugb24gZHJhd2luZyBib2FyZCBjb21iaW5kIHdpdGggdW5kZXJzY29yZSAoXylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHByZXZpZXdNb2RlICsgJ18nICsgcHJldmlld1NjcmliYmxlQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgdXNlZCBhcyBpdHMgcmVxdWlyZW1lbnQgY29tcGxldGVkIGJ5IG9yZGVyIGtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHByZXZpZXdTY3JpYmJsZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmeSB0aGUgcG9zaXRpb24gZnJvbSB3aGVyZSBkcmF3aW5nIHdpbGwgc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6ICdNJyArIGN1cnNvckxlZnQgKyAnICcgKyBjdXJzb3JUb3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IGRyYXdpbmcgaXMgc2tldGNoZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEcmF3U3RvcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdrZXlkb3duJywgJy5wcmV2aWV3S2V5U3ZnJywgZnVuY3Rpb24gKGN1cnJlbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChBSC5zZWxlY3QoJyNtb3ZlRHJhd0ljb24nKS5vZmZzZXRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHdpZHRoIG9mIHRoZSBiYWNrZ3JvdW5kIGltYWdlXHJcbiAgICAgICAgICAgICAgICBsZXQgaW1hZ2VXaWR0aCA9IEFILnNlbGVjdCgnI3N2Z0ltZ1ByZXZpZXcnKS5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHdpZHRoIG9mIHRoZSBiYWNrZ3JvdW5kIGltYWdlIFxyXG4gICAgICAgICAgICAgICAgbGV0IGltYWdlSGVpZ2h0ID0gQUguc2VsZWN0KCcjc3ZnSW1nUHJldmlldycpLmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSAmJiAoZXZlbnQua2V5Q29kZSA9PSAzOCB8fCBldmVudC5rZXlDb2RlID09IDM3IHx8IGV2ZW50LmtleUNvZGUgPT0gMzkgfHwgZXZlbnQua2V5Q29kZSA9PSA0MCkgJiYgIWxvY2tGb2N1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVhc2VzIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSBjdXJzb3JUb3AgYnkgMSBhZnRlciBkb3duIHRoZSB1cCBhcnJvdyBrZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvclRvcC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHZhcmlhYmxlIGN1cnNvclRvcCBieSAxIGFmdGVyIGRvd24gdGhlIGRvd24gYXJyb3cga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JUb3ArKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSBjdXJzb3JMZWZ0IGJ5IDEgYWZ0ZXIgZG93biB0aGUgcmlnaHQgYXJyb3cga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JMZWZ0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlYXNlcyB0aGUgdmFsdWUgb2YgdmFyaWFibGUgY3Vyc29yTGVmdCBieSAxIGFmdGVyIGRvd24gdGhlIGxlZnQgYXJyb3cga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JMZWZ0LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvclRvcCA8IDAgfHwgY3Vyc29yTGVmdCA+IGltYWdlV2lkdGggfHwgY3Vyc29yTGVmdCA8IDAgfHwgY3Vyc29yVG9wID4gaW1hZ2VIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb24gb2YgdGhlIGljb24gKCspIHVzZWQgZm9yIHNrZXRjaCB0aGUgZHJhd2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI21vdmVEcmF3SWNvbicsICdjc3MnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IGN1cnNvclRvcCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiBjdXJzb3JMZWZ0ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydERyYXdpbmdCeUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kICsgJyBMJyArIGN1cnNvckxlZnQgKyAnICcgKyBjdXJzb3JUb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlld01vZGUgIT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIHZhbHVlIG9mIHZhcmlhYmxlcyBjdXJzb3JMZWZ0IGFuZCBjdXJzb3JUb3Agc2VwYXJhdGVkIGJ5IHNwYWNlIHdpdGggcHJlZml4ICdMJyBpbiB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGtleSAnZCcgYXQgaW5kZXggc3BlY2lmaWVkIGluIHRoZSB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kID0gcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCArICcgTCcgKyBjdXJzb3JMZWZ0ICsgJyAnICsgY3Vyc29yVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIGVsZW1lbnQgc3RvcmVkIGludG8gdmFyaWFibGUgc2NyaWJibGUgaW4gZHJhd2luZyBjb250YWluZXIgaW4gd2hpY2ggZHJhd2luZ3MgYXJlIHN0b3JlZCBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdEcmF3aW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIGlzRHJhd1N0b3AgYnkgMSB0byBpbmRpY2F0ZSB0aGF0IHNrZXRjaGluZyBvZiB0aGUgZHJhd2luZyBpcyBzdG9wcGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJhd1N0b3AgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXlDb2RlID09IDc2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NrRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4ZWQgdGhlIG1hcmsgcG9pbnQgZnJvbSB3aGVyZSBkcmF3aW5nIHdpbGwgYmUgc3RhcnQgd2hlbiBwZXJmb3JtZWQgdmlhIGtleWJvYXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tGb2N1cyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RHJhd2luZ0J5S2V5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgYWxsIG1hcmsgcG9pbnRzIGFuZCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2lzTUFya2luZycgdG8gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhck1hcmtpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHggY28tb3JkaW5hdGUgb2YgdGhlIG1hcmsgcG9pbnQgY2lyY2xlIGFmdGVyIGNvbnZlcnRpbmcgaXQgaW50byBudW1iZXIgZnJvbSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yTGVmdCA9IE51bWJlcihBSC5zZWxlY3QoJy5jdXJyZW50Rm9jdXNQb2ludCcpLmdldEF0dHJpYnV0ZSgnY3gnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB5IGNvLW9yZGluYXRlIG9mIHRoZSBtYXJrIHBvaW50IGNpcmNsZSBhZnRlciBjb252ZXJ0aW5nIGl0IGludG8gbnVtYmVyIGZyb20gc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvclRvcCA9IE51bWJlcihBSC5zZWxlY3QoJy5jdXJyZW50Rm9jdXNQb2ludCcpLmdldEF0dHJpYnV0ZSgnY3knKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZXMgYW4gZWxlbWVudCB3aXRoIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSB4bWxucyBuYW1lc3BhY2UgVVJJIGFuZCAncGF0aCcgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgJ3BhdGgnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgc3Ryb2tlIGNvbG9yIGFuZCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3Q29sb3IocHJldmlld0NvbG9yLCBwcmV2aWV3VGhpY2tuZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2RhdGEtdHlwZScgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtdHlwZScsIHByZXZpZXdNb2RlICsgJ18nICsgcHJldmlld1NjcmliYmxlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZGF0YS1vcmRlcicgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtb3JkZXInLCBwcmV2aWV3U2NyaWJibGVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNJyArIGN1cnNvckxlZnQgKyAnICcgKyBjdXJzb3JUb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAndGFiaW5kZXgnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0YWJpbmRleCcsICcwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgdmFsdWUgb2YgY3VycmVudCB4IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ3VycmVudFBvc2l0aW9uWCA9IGN1cnNvckxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgdmFsdWUgb2YgY3VycmVudCB5IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ3VycmVudFBvc2l0aW9uWSA9IGN1cnNvclRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGVzIG9iamVjdCBoYXZpbmcga2V5cyBtb2RlLCBvcmRlciwgdHlwZSwgaW5kZXggYW5kIGQgd2l0aCB0aGVpciB2YWx1ZXMgaW50byAgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2FkZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogcHJldmlld1NjcmliYmxlQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwcmV2aWV3TW9kZSArICdfJyArIHByZXZpZXdTY3JpYmJsZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHByZXZpZXdTY3JpYmJsZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogJ00nICsgY3Vyc29yTGVmdCArICcgJyArIGN1cnNvclRvcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmxvY2sgdGhlIGZvY3VzIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tGb2N1cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgdGhlIGRyYXdpbmcgYW5kIHN0b3JlIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHRoZSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcERyYXcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA5ICYmIGxvY2tGb2N1cyAmJiAocHJldmlld01vZGUgPT0gJ2xpbmUnIHx8IHByZXZpZXdNb2RlID09ICdzY3JpYmJsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYXdMaW5lID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQUguc2VsZWN0KCcuY3VycmVudEZvY3VzUG9pbnQnKS5ub2RlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB4IGNvLW9yZGluYXRlIG9mIHRoZSBtYXJrIHBvaW50IGNpcmNsZSBhZnRlciBjb252ZXJ0aW5nIGl0IGludG8gbnVtYmVyIGZyb20gc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvckxlZnQgPSBOdW1iZXIoQUguc2VsZWN0KCcuY3VycmVudEZvY3VzUG9pbnQnKS5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250YWlucyB0aGUgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbWFyayBwb2ludCBjaXJjbGUgYWZ0ZXIgY29udmVydGluZyBpdCBpbnRvIG51bWJlciBmcm9tIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JUb3AgPSBOdW1iZXIoQUguc2VsZWN0KCcuY3VycmVudEZvY3VzUG9pbnQnKS5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oY3Vyc29yTGVmdCkgJiYgaXNOYU4oY3Vyc29yVG9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aWV3TW9kZSA9PSAnc2NyaWJibGUnIHx8IHByZXZpZXdNb2RlID09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHRoYXQgc2NyaWJibGUgZHJhd2luZyBpcyBza2V0Y2hpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2NyaWJibGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgKyAnIEwnICsgY3Vyc29yTGVmdCArICcgJyArIGN1cnNvclRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIGVsZW1lbnQgc3RvcmVkIGludG8gdmFyaWFibGUgc2NyaWJibGUgaW4gZHJhd2luZyBjb250YWluZXIgaW4gd2hpY2ggZHJhd2luZ3MgYXJlIHN0b3JlZCBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdEcmF3aW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRyYXdMaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAxMClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDY4ICYmIGxvY2tGb2N1cyAmJiBpc1NjcmliYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYXdfc2NyaWJibGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnNvckxlZnQpICYmIGlzTmFOKGN1cnNvclRvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIHZhbHVlIG9mIHZhcmlhYmxlcyBjdXJzb3JMZWZ0IGFuZCBjdXJzb3JUb3Agc2VwYXJhdGVkIGJ5IHNwYWNlIHdpdGggcHJlZml4ICdMJyBpbiB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGtleSAnZCcgYXQgaW5kZXggc3BlY2lmaWVkIGluIHRoZSB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgPSBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kICsgJyBMJyArIGN1cnNvckxlZnQgKyAnICcgKyBjdXJzb3JUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIGVsZW1lbnQgc3RvcmVkIGludG8gdmFyaWFibGUgc2NyaWJibGUgaW4gZHJhd2luZyBjb250YWluZXIgaW4gd2hpY2ggZHJhd2luZ3MgYXJlIHN0b3JlZCBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdEcmF3aW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRyYXdfc2NyaWJibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCBzY3JpYmJsZSBkcmF3aW5nIGlzIG5vdCBza2V0Y2hpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTY3JpYmJsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMTApXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ2tleWRvd24nLCAnLnByZXZpZXdLZXlTdmcgLmRyYXdpbmdDb21wYXNzQ2VudGVyJywgZnVuY3Rpb24gKGN1cnJlbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBjb21wYXNzIGVsZW1lbnRcclxuICAgICAgICAgICAgY29tcGFzc0tleUV2ZW50KCdtb3ZlJywgZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAna2V5ZG93bicsICcucHJldmlld0tleVN2ZyAubWlkX2NpcmNsZScsIGZ1bmN0aW9uIChjdXJyZW50LCBldmVudCkge1xyXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHJhZGl1cyBvZiB0aGUgY29tcGFzcyBlbGVtZW50XHJcbiAgICAgICAgICAgIGNvbXBhc3NLZXlFdmVudCgncmFkaXVzJywgZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAna2V5ZG93bicsICcucHJldmlld0tleVN2ZyAubWlkU21hbGxDaXJjbGUnLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBhbmdsZSBvZiB0aGUgY29tcGFzcyBlbGVtZW50IHdoZW4gZm9jdXMgaXMgb24gc21hbGwgbWlkZGxlIGNpcmNsZVxyXG4gICAgICAgICAgICBjb21wYXNzS2V5RXZlbnQoJ3JvdGF0ZScsIGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ2tleWRvd24nLCAnLnByZXZpZXdLZXlTdmcgLmxhc3RDaXJjbGUnLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBhbmdsZSBvZiB0aGUgY29tcGFzcyBlbGVtZW50IHdoZW4gZm9jdXMgaXMgb24gbGFzdCBjaXJjbGVcclxuICAgICAgICAgICAgY29tcGFzc0tleUV2ZW50KCdkcmF3JywgZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdrZXlkb3duJywgJy5mb2N1c1BvaW50cycsIGZ1bmN0aW9uIChjdXJyZW50LCBldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PSAxMykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDMyKSAmJiBwcmV2aWV3TW9kZSAhPSAnbWFya1BvaW50cycgJiYgcHJldmlld01vZGUgIT0gJ2VyYXNlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB4IGNvLW9yZGluYXRlIG9mIHRoZSBtYXJrIHBvaW50IGNpcmNsZSBhZnRlciBjb252ZXJ0aW5nIGl0IGludG8gbnVtYmVyIGZyb20gc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBjdXJzb3JMZWZ0ID0gTnVtYmVyKEFILnNlbGVjdCgnLmN1cnJlbnRGb2N1c1BvaW50JykuZ2V0QXR0cmlidXRlKCdjeCcpKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB5IGNvLW9yZGluYXRlIG9mIHRoZSBtYXJrIHBvaW50IGNpcmNsZSBhZnRlciBjb252ZXJ0aW5nIGl0IGludG8gbnVtYmVyIGZyb20gc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBjdXJzb3JUb3AgPSBOdW1iZXIoQUguc2VsZWN0KCcuY3VycmVudEZvY3VzUG9pbnQnKS5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpZXdNb2RlICE9ICdjb21wYXNzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBpY29uICgrKSB1c2VkIHRvIHNrZXRjaCB0aGUgZHJhd2luZyBieSB0aGUgaGVscCBvZiBrZXlib2FyZFxyXG4gICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI21vdmVEcmF3SWNvbicsICdjc3MnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IGN1cnNvclRvcCArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiBjdXJzb3JMZWZ0ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiByb3RhdGlvbmJhciBhbmQgY2hhbmdlIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIGNpcmNsZXMgdGhhdCBsaWVzIG9uIHJvdGF0aW9uYmFyXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUHJldmlld0NvbXBhc3NDYWxjdWxhdGlvbihjdXJzb3JMZWZ0LCBjdXJzb3JUb3AsIHByZXZpZXdDb21wYXNzUmFkaXVzLCBwcmV2aWV3Q29tcGFzc0FuZ2xlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAna2V5dXAnLCAnLnByZXZpZXdLZXlTdmcgLmxhc3RDaXJjbGUnLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0RyYXdDb21wYXNzUHJldmlldyAmJiBpc1N0b3JlU3RhcnQgJiYgZXZlbnQua2V5Q29kZSA9PSAxNikge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmVzIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHVzZXIgdXNpbmcga2V5Ym9hcmQgYW5kIHNldHMgdGhlIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgICAgICAgICAgc3RvcmVDb21wYXNzUGF0aEJ5S2V5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLyoqIEVuZCBvZiBrZXkgZXZlbnRzICoqL1xyXG4gICAgICAgIFxyXG4gICAgICAgIEFILmJpbmQoJy5wcmV2aWV3S2V5U3ZnIC5sYXN0Q2lyY2xlJywgJ2JsdXInLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0RyYXdDb21wYXNzUHJldmlldyAmJiBpc1N0b3JlU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0b3JlcyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB1c2VyIHVzaW5nIGtleWJvYXJkIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgICAgIHN0b3JlQ29tcGFzc1BhdGhCeUtleSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdtb3VzZWRvd24nLCAnI3ByZXZpZXdTdmcgLm1pZFNtYWxsQ2lyY2xlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocHJldmlld01vZGUgPT0gXCJjb21wYXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHJhZGl1cyByb3RhdGVkXHJcbiAgICAgICAgICAgICAgICBpc1ByZXZpZXdSYWRpdXNSb3RhdGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgdmFsdWUgb2YgY29tcGFzcyByYWRpdXMgYW5kIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjaGVja1ByZXZpZXdSYWRpdXNBbmRBbmdsZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHZhbHVlIG9mIHN0YXJ0IGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjb21wYXNzQW5nbGVEaXNwbGFjZW1lbnQuc3RhcnQgPSBwcmV2aWV3Q29tcGFzc0FuZ2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdtb3VzZWRvd24nLCAnI3ByZXZpZXdTdmcgLmRyYXdpbmdDb21wYXNzQ2VudGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocHJldmlld01vZGUgPT0gXCJjb21wYXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHggYW5kIHkgY28tb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBzZXRQcmV2aWV3TW91c2VDb29yZGluYXRlcyhldmVudClcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHggY28tb3JkaW5hdGUgb2YgdGhlIG1vdXNlXHJcbiAgICAgICAgICAgICAgICBjeCA9IHByZXZpZXdfbW91c2VYO1xyXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbnMgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbW91c2VcclxuICAgICAgICAgICAgICAgIGN5ID0gcHJldmlld19tb3VzZVk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb250YWlucyByYWRpdXMgb2YgdGhlIGNvbXBhc3NcclxuICAgICAgICAgICAgICAgIHByZXZpZXdDb21wYXNzUmFkaXVzID0gQUguc2VsZWN0KCcuZHJhd2luZ0NvbXBhc3NSb3V0ZScpLmdldEF0dHJpYnV0ZSgncicpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgcG9zaXRpb24gb2Ygcm90YXRpb25iYXIgYW5kIGNoYW5nZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGVzIHRoYXQgbGllcyBvbiByb3RhdGlvbmJhclxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJldmlld0NvbXBhc3NDYWxjdWxhdGlvbihjeCwgY3ksIHByZXZpZXdDb21wYXNzUmFkaXVzLCBwcmV2aWV3Q29tcGFzc0FuZ2xlKTtcclxuICAgICAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IGNvbXBhc3MgaXMgbW92ZWRcclxuICAgICAgICAgICAgICAgIGlzUHJldmlld0NvbXBhc3NNb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAnbW91c2Vkb3duJywgJyNwcmV2aWV3U3ZnIC5taWRfY2lyY2xlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocHJldmlld01vZGUgPT0gXCJjb21wYXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0byBjaGFuZ2UgdGhlIHZhbHVlIG9mIHJhZGl1cyBvZiB0aGUgY29tcGFzc1xyXG4gICAgICAgICAgICAgICAgaXNQcmV2aWV3UmFkaXVzSW5jcmVhc2UgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdtb3VzZWRvd24nLCAnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGUnLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgY29tcGFzc0xhc3RjaXJjbGVFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdrZXlkb3duJywgJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlJywgZnVuY3Rpb24gKGN1cnJlbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbXBhc3NMYXN0Y2lyY2xlRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ21vdXNlZG93bicsICcjcHJldmlld1N2ZycsIGZ1bmN0aW9uIChjdXJyZW50LCBldmVudCkge1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSBjdXJzb3Igc3R5bGUgYXMgY3Jvc3NoYWlyICgrKVxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3U3ZnJywgJ2NzcycgLCB7J2N1cnNvcic6ICdjcm9zc2hhaXInfSk7XHJcbiAgICAgICAgICAgIC8vIGhpZGVzIHRoZSBpY29uIHVzZWQgdG8gc2tldGNoIHRoZSBkcmF3aW5nIGJ5IHRoZSBoZWxwIG9mIGtleWJvYXJkXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI21vdmVEcmF3SWNvbicsICdhZGRDbGFzcycgLCAnaCcpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnREcmF3aW5nQnlLZXkgJiYgaXNEcmF3U3RvcCB8fCBsb2NrRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0b3AgdGhlIGRyYXdpbmcgYW5kIHN0b3JlIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHRoZSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgICAgIHN0b3BEcmF3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChwcmV2aWV3TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzY3JpYmJsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgYWxsIG1hcmsgcG9pbnRzIGFuZCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2lzTUFya2luZycgdG8gMVxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyTWFya2luZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbm90ZXMgdGhhdCBkcmF3aW5nIGlzIG9uIGdvaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaXNEcmF3aW5nUHJldmlldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3TW91c2VDb29yZGluYXRlcyhldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHZhbHVlIG9mIHZhcmlhYmxlIHhtbG5zIG5hbWVzcGFjZSBVUkkgYW5kICdwYXRoJyBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMsICdwYXRoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgc3Ryb2tlIGNvbG9yIGFuZCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIHNldFByZXZpZXdDb2xvcihwcmV2aWV3Q29sb3IsIHByZXZpZXdUaGlja25lc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkYXRhLXR5cGUnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtdHlwZScsIHByZXZpZXdNb2RlICsgJ18nICsgcHJldmlld1NjcmliYmxlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkYXRhLW9yZGVyJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLW9yZGVyJywgcHJldmlld1NjcmliYmxlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgJ00nICsgcHJldmlld19tb3VzZVggKyAnICcgKyBwcmV2aWV3X21vdXNlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ3RhYmluZGV4JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0YWJpbmRleCcsICcwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHggY28tb3JkaW5hdGUgb2YgdGhlIG1vdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDdXJyZW50UG9zaXRpb25YID0gcHJldmlld19tb3VzZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHkgY28tb3JkaW5hdGUgb2YgdGhlIG1vdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDdXJyZW50UG9zaXRpb25ZID0gcHJldmlld19tb3VzZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGVzIG9iamVjdCBoYXZpbmcga2V5cyBtb2RlLCBvcmRlciwgdHlwZSwgaW5kZXggYW5kIGQgd2l0aCB0aGVpciB2YWx1ZXMgaW50byAgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGgucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdhZGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogcHJldmlld1NjcmliYmxlQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHByZXZpZXdNb2RlICsgJ18nICsgcHJldmlld1NjcmliYmxlQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwcmV2aWV3U2NyaWJibGVDb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDogJ00nICsgcHJldmlld19tb3VzZVggKyAnICcgKyBwcmV2aWV3X21vdXNlWVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXJhc2VyJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVzIGRyYXdpbmcgb24gd2hpY2gga2V5dXAgZXZlbnQgdHJpZ2dlcmVkIGFuZCB1cGRhdGUgdGhlIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgICAgICAgICAgICAgIGVyYXNlcignLmN1cnJlbnRTdmcnLCBwcmV2aWV3U2NyaWJibGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcmtQb2ludHMnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNYXJraW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHggYW5kIHkgY28tb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByZXZpZXdNb3VzZUNvb3JkaW5hdGVzKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UgVVJJIGFuZCBxdWFsaWZpZWQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMsICdjaXJjbGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgc3Ryb2tlIGNvbG9yIGFuZCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3Q29sb3Ioc3RhdGUubWFya1BvaW50Q29sb3IsIHByZXZpZXdUaGlja25lc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnY2xhc3MnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsICdhbnN3ZXJfbWFyaycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnY3gnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeCcsIHByZXZpZXdfbW91c2VYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2N5JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3knLCBwcmV2aWV3X21vdXNlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdyJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsICcycHgnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGVzIHRoZSB4IGFuZCB5IGNvLW9yZGluYXRlIG9mIG1vdXNlIGludG8gbWFya1BvaW50cyBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrUG9pbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcHJldmlld19tb3VzZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwcmV2aWV3X21vdXNlWVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgZWxlbWVudCBzdG9yZWQgaW50byB2YXJpYWJsZSBzY3JpYmJsZSBpbiBtYXJrIHBvaW50IGNvbnRhaW5lciBpbiB3aGljaCBkcmF3aW5ncyBhcmUgc3RvcmVkIGRvbmUgYnkgdGhlIGhlbHAgb2YgJ01hcmsgUG9pbicgQW5kICdGaW5pc2ggTWFya2luZycgYnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJy5wcmV2aWV3TWFya2luZ1BhdGhzJykucHJlcGVuZChzY3JpYmJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyB0aGUgYW5zd2VyIGFuZCB1cGRhdGVzIHRoZSBzdGF0dXMgYW5kIGVuYWJsZXMgJ01hcmsgUG9pbnRzJyBidXR0b24gYW5kIGFsc28gdXBkYXRlcyBpdHMgdGV4dCBhcyAnTWFyayBQb2ludHMnIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVhNTEZvckFuc3dlcihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVVYTUwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTW91c2UgTW92ZSBldmVudFxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdtb3VzZW1vdmUnLCAnI3ByZXZpZXdTdmcnLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChwcmV2aWV3TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRHJhd2luZ1ByZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJldmlld01vdXNlQ29vcmRpbmF0ZXMoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kICsgJyBMJyArIHByZXZpZXdfbW91c2VYICsgJyAnICsgcHJldmlld19tb3VzZVkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGVja0N1cnJlbnRQb3NpdGlvblggPT0gcHJldmlld19tb3VzZVggJiYgY2hlY2tDdXJyZW50UG9zaXRpb25ZID09IHByZXZpZXdfbW91c2VZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgZWxlbWVudCBzdG9yZWQgaW50byB2YXJpYWJsZSBzY3JpYmJsZSBpbiBkcmF3aW5nIGNvbnRhaW5lciBpbiB3aGljaCBkcmF3aW5ncyBhcmUgc3RvcmVkIHNrZXRjaGVkIGJ5IHRoZSBoZWxwIG9mIGRyYXdpbmcgdG9vbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdEcmF3aW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NjcmliYmxlJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEcmF3aW5nUHJldmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSB4IGFuZCB5IGNvLW9yZGluYXRlIG9mIHRoZSBtb3VzZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3TW91c2VDb29yZGluYXRlcyhldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgKyAnIEwnICsgcHJldmlld19tb3VzZVggKyAnICcgKyBwcmV2aWV3X21vdXNlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgdmFsdWUgb2YgdmFyaWFibGVzIHByZXZpZXdfbW91c2VYIGFuZCBwcmV2aWV3X21vdXNlWSBzZXBhcmF0ZWQgYnkgc3BhY2Ugd2l0aCBwcmVmaXggJ0wnIGluIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUga2V5ICdkJyBhdCBpbmRleCBzcGVjaWZpZWQgaW4gdGhlIHZhcmlhYmxlIHByZXZpZXdTY3JpYmJsZUNvdW50IG9mIGFycmF5IHByZXZpZXdTY3JpYmJsZVBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCA9IHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgKyAnIEwnICsgcHJldmlld19tb3VzZVggKyAnICcgKyBwcmV2aWV3X21vdXNlWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQuc3BsaXQoJ0wnKS5sZW5ndGggLSAxKSA8IDMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBlbGVtZW50IHN0b3JlZCBpbnRvIHZhcmlhYmxlIHNjcmliYmxlIGluIGRyYXdpbmcgY29udGFpbmVyIGluIHdoaWNoIGRyYXdpbmdzIGFyZSBzdG9yZWQgc2tldGNoZWQgYnkgdGhlIGhlbHAgb2YgZHJhd2luZyB0b29sc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQUguc2VsZWN0KCcucHJldmlld0RyYXdpbmdQYXRocycpLnByZXBlbmQoc2NyaWJibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGFzcyc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3TW91c2VDb29yZGluYXRlcyhldmVudClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2aWV3Q29tcGFzc01vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHggY28tb3JkaW5hdGUgb2YgdGhlIG1vdXNlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9IHByZXZpZXdfbW91c2VYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250YWlucyB0aGUgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbW91c2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gcHJldmlld19tb3VzZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHJhZGl1cyBvZiB0aGUgY29tcGFzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcGFzc1JhZGl1cyA9IEFILnNlbGVjdCgnLmRyYXdpbmdDb21wYXNzUm91dGUnKS5nZXRBdHRyaWJ1dGUoJ3InKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgcG9zaXRpb24gb2Ygcm90YXRpb25iYXIgYW5kIGNoYW5nZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGVzIHRoYXQgbGllcyBvbiByb3RhdGlvbmJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcmV2aWV3Q29tcGFzc0NhbGN1bGF0aW9uKGN4LCBjeSwgcHJldmlld0NvbXBhc3NSYWRpdXMsIHByZXZpZXdDb21wYXNzQW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2aWV3UmFkaXVzSW5jcmVhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgdmFsdWUgb2YgY29tcGFzcyByYWRpdXMgYW5kIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUHJldmlld1JhZGl1c0FuZEFuZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZXMgdGhlIHJhZGl1cyBieSB0aGUgaGVscCBvZiBzdGFydCBhbmQgZW5kIHBvaW50cyBjby1vcmRpbmF0ZSBvZiB0aGUgcm90YXRpb24gYmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdDb21wYXNzUmFkaXVzID0gMiAqIE1hdGguc3FydChNYXRoLnBvdyhwcmV2aWV3X21vdXNlWCAtIGluaXRpYWxQb2ludC54LCAyKSArIE1hdGgucG93KHByZXZpZXdfbW91c2VZIC0gaW5pdGlhbFBvaW50LnksIDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlld0NvbXBhc3NSYWRpdXMgPCA4MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgODAgb2YgdGhlIHZhcmlhYmxlIHByZXZpZXdDb21wYXNzUmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcGFzc1JhZGl1cyA9IDgwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aWV3Q29tcGFzc1JhZGl1cyA+IDM2MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgMzYwIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3Q29tcGFzc1JhZGl1c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld0NvbXBhc3NSYWRpdXMgPSAzNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgcG9zaXRpb24gb2Ygcm90YXRpb25iYXIgYW5kIGNoYW5nZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGVzIHRoYXQgbGllcyBvbiByb3RhdGlvbmJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcmV2aWV3Q29tcGFzc0NhbGN1bGF0aW9uKGluaXRpYWxQb2ludC54LCBpbml0aWFsUG9pbnQueSwgcHJldmlld0NvbXBhc3NSYWRpdXMsIHByZXZpZXdDb21wYXNzQW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJldmlld1JhZGl1c1JvdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHRoZSB2YWx1ZSBvZiBjb21wYXNzIHJhZGl1cyBhbmQgYW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tQcmV2aWV3UmFkaXVzQW5kQW5nbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlcyB0aGUgYW5nbGUgYnkgdGhlIGhlbHAgb2Ygc3RhcnQgYW5kIGVuZCBwb2ludHMgY28tb3JkaW5hdGUgb2YgdGhlIHJvdGF0aW9uIGJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcGFzc0FuZ2xlID0gTWF0aC5hdGFuMihwcmV2aWV3X21vdXNlWSAtIGluaXRpYWxQb2ludC55LCBwcmV2aWV3X21vdXNlWCAtIGluaXRpYWxQb2ludC54KSAqIDE4MCAvIE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aWV3Q29tcGFzc0FuZ2xlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyAzNjAgaW50byB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHByZXZpZXdDb21wYXNzQW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdDb21wYXNzQW5nbGUgPSAzNjAgKyBwcmV2aWV3Q29tcGFzc0FuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB2YWx1ZSBvZiBlbmQgYW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFzc0FuZ2xlRGlzcGxhY2VtZW50LmVuZCA9IHByZXZpZXdDb21wYXNzQW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHJvdGF0aW9uYmFyIGFuZCBjaGFuZ2UgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlcyB0aGF0IGxpZXMgb24gcm90YXRpb25iYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUHJldmlld0NvbXBhc3NDYWxjdWxhdGlvbihpbml0aWFsUG9pbnQueCwgaW5pdGlhbFBvaW50LnksIHByZXZpZXdDb21wYXNzUmFkaXVzLCBwcmV2aWV3Q29tcGFzc0FuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRHJhd2luZ1ByZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoQUguc2VsZWN0KCcjcHJldmlld1N2ZyAubGFzdENpcmNsZScpLmNsYXNzTGlzdC5jb250YWlucygnbGFzdENpcmNsZV9ob3ZlcicpIHx8IEFILnNlbGVjdCgnI3ByZXZpZXdTdmcgLmxhc3RiaWdjaXJjbGUnKS5jbGFzc0xpc3QuY29udGFpbnMoJ2xhc3RDaXJjbGVfaG92ZXInKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50IG1vdXNlbGVhdmUgb24gdGhlIGVsZW1lbnQgaGF2ZSBpZCBwcmV2aWV3U3ZnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3TW91c2VMZWF2ZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCArICcgTCcgKyBsYXN0Q2lyY2xlX2N4ICsgJyAnICsgbGFzdENpcmNsZV9jeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIHZhbHVlIG9mIHZhcmlhYmxlcyBsYXN0Q2lyY2xlX2N4IGFuZCBsYXN0Q2lyY2xlX2N5IHNlcGFyYXRlZCBieSBzcGFjZSB3aXRoIHByZWZpeCAnTCcgaW4gdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBrZXkgJ2QnIGF0IGluZGV4IHNwZWNpZmllZCBpbiB0aGUgdmFyaWFibGUgcHJldmlld1NjcmliYmxlQ291bnQgb2YgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCA9IHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgKyAnIEwnICsgbGFzdENpcmNsZV9jeCArICcgJyArIGxhc3RDaXJjbGVfY3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgocHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZC5zcGxpdCgnTCcpLmxlbmd0aCAtIDEpIDwgNCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBlbGVtZW50IHN0b3JlZCBpbnRvIHZhcmlhYmxlIHNjcmliYmxlIGluIGRyYXdpbmcgY29udGFpbmVyIGluIHdoaWNoIGRyYXdpbmdzIGFyZSBzdG9yZWQgc2tldGNoZWQgYnkgdGhlIGhlbHAgb2YgZHJhd2luZyB0b29sc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdEcmF3aW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBNb3VzZSBVcCBFdmVudFxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdtb3VzZXVwJywgJyNwcmV2aWV3U3ZnJywgZnVuY3Rpb24gKGN1cnJlbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHByZXZpZXdNb3VzZUxlYXZlKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTW91c2UgbGVhdmUgRXZlbnRcclxuICAgICAgICBBSC5iaW5kKCcjcHJldmlld1N2ZycsICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHByZXZpZXdNb3VzZUxlYXZlKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRm9yIHRvb2xiYXJcclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAnY2xpY2snLCAnLnByZXZpZXdfdG9vbGJhcicsIGZ1bmN0aW9uIChjdXJyZW50LCBldmVudCkge1xyXG4gICAgICAgICAgICB0b29sYmFyQWN0aW9uKGN1cnJlbnQsIGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ2tleXVwJywgJy5wcmV2aWV3X3Rvb2xiYXInLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgdG9vbGJhckFjdGlvbihjdXJyZW50LCBldmVudCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdtb3VzZW92ZXInLCAnLnByZXZpZXdEcmF3aW5nUGF0aHMgcGF0aCcsIGZ1bmN0aW9uIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aWV3TW9kZSA9PSAnZXJhc2VyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgY3VycmVudFN2ZyBmcm9tIHRoZSBlbGVtZW50ICdwYXRoJyBpbnNpZGUgdGhlIGVsZW1lbnQgaGF2ZSBjbGFzcyAncHJldmlld0RyYXdpbmdQYXRocydcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdEcmF3aW5nUGF0aHMgcGF0aCcsICdyZW1vdmVDbGFzcycgLCAnY3VycmVudFN2ZycpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyB0aGUgY2xhc3MgJ2N1cnJlbnRTdmcnIHRvIHRoZSBlbGVtZW50ICdwYXRoJyBpbnNpZGUgdGhlIGVsZW1lbnQgaGF2ZSBjbGFzcyAncHJldmlld0RyYXdpbmdQYXRocycgb24gd2hpY2ggbW91c2VvdmVyXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnRTdmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAnbW91c2VvdXQnLCAnLnByZXZpZXdEcmF3aW5nUGF0aHMgcGF0aCcsIGZ1bmN0aW9uIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aWV3TW9kZSA9PSAnZXJhc2VyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgJ2N1cnJlbnRTdmcnIHRvIHRoZSBlbGVtZW50ICdwYXRoJyBpbnNpZGUgdGhlIGVsZW1lbnQgaGF2ZSBjbGFzcyAncHJldmlld0RyYXdpbmdQYXRocycgb24gd2hpY2ggbW91c2VvdXRcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZSgnY3VycmVudFN2ZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGxhc3QgY2lyY2xlIGV2ZW50c1xyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdtb3VzZW1vdmUnLCAnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGUnLCBmdW5jdGlvbiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAvLyBhZGRzIHRoZSBjbGFzcyAnbGFzdENpcmNsZV9ob3ZlcicgdG8gdGhlIGxhc3QgY2lyY2xlIG9uIGNvbXBhc3Mgcm90YXRpb24gYmFyIGxpZXMgb24gcm91dGUgb2YgdGhlIGNvbXBhc3NcclxuICAgICAgICAgICAgY3VycmVudC5jbGFzc0xpc3QuYWRkKFwibGFzdENpcmNsZV9ob3ZlclwiKTtcclxuICAgICAgICAgICAgLy8gc2hvd3MgdGhlIHJvdGF0aW9uYWwgaW5kaWNhdG9yXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGVNaWQnLCAnYXR0cicgLCB7J29wYWNpdHknOiAxfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ21vdXNlb3V0JywgJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlJywgZnVuY3Rpb24gKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgJ2xhc3RDaXJjbGVfaG92ZXInIHRvIHRoZSBsYXN0IGNpcmNsZSBvbiBjb21wYXNzIHJvdGF0aW9uIGJhciBsaWVzIG9uIHJvdXRlIG9mIHRoZSBjb21wYXNzXHJcbiAgICAgICAgICAgIGN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZShcImxhc3RDaXJjbGVfaG92ZXJcIik7XHJcbiAgICAgICAgICAgIC8vIGhpZGVzIHRoZSByb3RhdGlvbmFsIGluZGljYXRvclxyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlTWlkJywgJ2F0dHInICwgeydvcGFjaXR5JzogMH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBSC5saXN0ZW5BbGwoJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlJywgJ2ZvY3VzJywgZnVuY3Rpb24gKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgLy8gYWRkcyB0aGUgY2xhc3MgJ2xhc3RDaXJjbGVfaG92ZXInIHRvIHRoZSBsYXN0IGNpcmNsZSBvbiBjb21wYXNzIHJvdGF0aW9uIGJhciBsaWVzIG9uIHJvdXRlIG9mIHRoZSBjb21wYXNzXHJcbiAgICAgICAgICAgIGN1cnJlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoXCJsYXN0Q2lyY2xlX2hvdmVyXCIpO1xyXG4gICAgICAgICAgICAvLyBzaG93cyB0aGUgcm90YXRpb25hbCBpbmRpY2F0b3JcclxuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcjcHJldmlld1N2ZyAubGFzdENpcmNsZU1pZCcsICdhdHRyJyAsIHsnb3BhY2l0eSc6IDF9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBBSC5saXN0ZW5BbGwoJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlJywgJ2JsdXInLGZ1bmN0aW9uIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGNsYXNzICdsYXN0Q2lyY2xlX2hvdmVyJyB0byB0aGUgbGFzdCBjaXJjbGUgb24gY29tcGFzcyByb3RhdGlvbiBiYXIgbGllcyBvbiByb3V0ZSBvZiB0aGUgY29tcGFzc1xyXG4gICAgICAgICAgICBjdXJyZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKFwibGFzdENpcmNsZV9ob3ZlclwiKTtcclxuICAgICAgICAgICAgLy8gaGlkZXMgdGhlIHJvdGF0aW9uYWwgaW5kaWNhdG9yXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGVNaWQnLCAnYXR0cicgLCB7J29wYWNpdHknOiAwfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGZvciBjaGFuZ2luZyB0aGUgYWN0aXZlIGJ1dHRvbnNcclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAnY2xpY2snLCAnLnByZXZpZXdfYnRuJywgZnVuY3Rpb24gKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgYWN0aXZlIGZyb20gZHJhd2luZyB0b29scywgZGVsZXRlIGFuZCAgJ01hcmsgUG9pbnRzJyBidXR0b25zXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfYnRuLCAjbWFya19wb2ludHMnLCAncmVtb3ZlQ2xhc3MnLCAnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgdGhlIGNsYXNzIGFjdGl2ZSB3aGljaCBpcyBjbGlja2VkXHJcbiAgICAgICAgICAgIGN1cnJlbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGZvciBjbGVhcmluZyB0aGUgc2NyZWVuXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ2NsaWNrJywgJyNwcmV2aWV3X2NsZWFyU2NyZWVuJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBtYWtlcyBkcmF3aW5nIGNvbnRhaW5lciBlbXB0eSBpbiB3aGljaCBkcmF3aW5nIGlzIGRvbmUgYnkgdXNpbmcgZHJhd2luZyB0b29sc1xyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5wcmV2aWV3RHJhd2luZ1BhdGhzIHBhdGgnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHZhcmlhYmxlICdwcmV2aWV3VW5kb0NvdW50JyB0byAgMFxyXG4gICAgICAgICAgICBwcmV2aWV3VW5kb0NvdW50ID0gMDtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdmFyaWFibGUgJ3ByZXZpZXdTY3JpYmJsZUNvdW50JyB0byAgMFxyXG4gICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIC8vIG1ha2VzIGFycmF5ICdwcmV2aWV3U2NyaWJibGVQYXRoJyBlbXB0eSB0byBkZW5vdGUgdGhhdCBubyBkcmF3aW5nIGlzIHNrZXRjaGVkXHJcbiAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGggPSBbXTtcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgY29weSBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgIGxldCB0ZW1wQXJyYXlDb250YWluZXIgPSBhcnJheUNvcHkocHJldmlld1NjcmliYmxlUGF0aCk7XHJcbiAgICAgICAgICAgIC8vIHN0b3JlcyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgc3RvcmVVc2VyUGF0aHModGVtcEFycmF5Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIHVuZG8sIHJlZG8sIGNyb3NzICh4KSBidXR0b25zXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdfdW5kbycpLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19yZWRvJykuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X2NsZWFyU2NyZWVuJykuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBmb3IgdW5kb1xyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdjbGljaycsICcjcHJldmlld191bmRvJywgZnVuY3Rpb24gKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHByZXZpZXdVbmRvQ291bnQgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIHVuZG8gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBlbmFibGVkIHRoZSByZWRvIGJ1dHRvblxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3JlZG8nKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAocHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVQYXRoLmxlbmd0aCAtIDFdLm1vZGUgPT0gJ2FkZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGVsZW1lbnQgdGhhdCBoYXZlIGRhdGEtb3JkZXIgYXR0cmlidXRlIGFuZCB2YWx1ZSBvZiB0aGlzIGF0dHJpYnV0ZSBpcyBlcXVhbHMgdG8gc3VidGFjdGluZyAxIGZyb20gdGhlIHZhbHVlIG9mIGxlbmd0aCBvZiB0aGUgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aCwgbWVhbnMgcmVtb3ZlcyB0aGUgbGFzdCBkcmF3aW5nIHNrZXRjaGVkIGJ5IHRoZSBoZWxwIG9mIGRyYXdpbmcgdG9vbHNcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgW2RhdGEtb3JkZXI9XCInICsgKHByZXZpZXdTY3JpYmJsZVBhdGgubGVuZ3RoIC0gMSkgKyAnXCJdJywgJ3JlbW92ZScpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlUGF0aC5sZW5ndGggLSAxXS5tb2RlID09ICdyZW1vdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGFuIGVsZW1lbnQgd2l0aCB0aGUgdmFsdWUgb2YgdmFyaWFibGUgeG1sbnMgbmFtZXNwYWNlIFVSSSBhbmQgJ3BhdGgnIG5hbWVcclxuICAgICAgICAgICAgICAgIHNjcmliYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAncGF0aCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgc3Ryb2tlIGNvbG9yIGFuZCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgc2V0UHJldmlld0NvbG9yKHByZXZpZXdDb2xvciwgcHJldmlld1RoaWNrbmVzcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZGF0YS10eXBlJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtdHlwZScsIHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlUGF0aC5sZW5ndGggLSAxXS50eXBlKTtcclxuICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkYXRhLW9yZGVyJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtb3JkZXInLCAocHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVQYXRoLmxlbmd0aCAtIDFdLm9yZGVyKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVQYXRoLmxlbmd0aCAtIDFdLmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ3RhYmluZGV4JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RhYmluZGV4JywgJzAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aWV3TW9kZSA9PSAnZXJhc2VyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdjbGFzcycgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCAnZXJhc2VySG92ZXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIGVsZW1lbnQgc3RvcmVkIGludG8gdmFyaWFibGUgc2NyaWJibGUgaW4gZHJhd2luZyBjb250YWluZXIgaW4gd2hpY2ggZHJhd2luZ3MgYXJlIHN0b3JlZCBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJy5wcmV2aWV3RHJhd2luZ1BhdGhzJykucHJlcGVuZChzY3JpYmJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHVzaGVzIHRoZSBsYXN0IGRhdGEgb2YgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aCBpbnRvIGFycmF5IHByZXZpZXdVbmRvTGlzdFxyXG4gICAgICAgICAgICBwcmV2aWV3VW5kb0xpc3QucHVzaChwcmV2aWV3U2NyaWJibGVQYXRoLnBvcCgpKTtcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgY29weSBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgIGxldCB0ZW1wQXJyYXlDb250YWluZXIgPSBhcnJheUNvcHkocHJldmlld1NjcmliYmxlUGF0aCk7XHJcbiAgICAgICAgICAgIC8vIHN0b3JlcyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgc3RvcmVVc2VyUGF0aHModGVtcEFycmF5Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgLy8gZGVjcmVhc2VzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgcHJldmlld1NjcmliYmxlQ291bnQgYnkgMVxyXG4gICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVDb3VudC0tO1xyXG4gICAgICAgICAgICAvLyBkZWNyZWFzZXMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3VW5kb0NvdW50IGJ5IDFcclxuICAgICAgICAgICAgcHJldmlld1VuZG9Db3VudC0tO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19jbGVhclNjcmVlbicpLmRpc2FibGVkID0gKEFILnNlbGVjdEFsbCgnLnByZXZpZXdEcmF3aW5nUGF0aHMgcGF0aCcpLmxlbmd0aCA9PSAwKTtcclxuICAgICAgICAgICAgaWYgKHByZXZpZXdTY3JpYmJsZVBhdGgubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIHRoZSB1bmRvIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgY3VycmVudC5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gZm9yIHJlZG9cclxuICAgICAgICBBSC5saXN0ZW4oJ2JvZHknLCAnY2xpY2snLCAnI3ByZXZpZXdfcmVkbycsIGZ1bmN0aW9uIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGluY3JlYXNlcyB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHByZXZpZXdTY3JpYmJsZUNvdW50IGJ5IDFcclxuICAgICAgICAgICAgcHJldmlld1NjcmliYmxlQ291bnQrKztcclxuICAgICAgICAgICAgaWYgKHByZXZpZXdVbmRvTGlzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwdXNoZXMgdGhlIGxhc3QgZGF0YSBvZiBhcnJheSBwcmV2aWV3VW5kb0xpc3QgaW50byBhcnJheSBwcmV2aWV3UmVkb0xpc3RcclxuICAgICAgICAgICAgICAgIHByZXZpZXdSZWRvTGlzdC5wdXNoKHByZXZpZXdVbmRvTGlzdC5wb3AoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZpZXdSZWRvTGlzdFtwcmV2aWV3UmVkb0xpc3QubGVuZ3RoIC0gMV0ubW9kZSA9PSAnYWRkJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHZhbHVlIG9mIHZhcmlhYmxlIHhtbG5zIG5hbWVzcGFjZSBVUkkgYW5kICdwYXRoJyBuYW1lXHJcbiAgICAgICAgICAgICAgICBzY3JpYmJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgJ3BhdGgnKTtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgICAgIHNldFByZXZpZXdDb2xvcihwcmV2aWV3Q29sb3IsIHByZXZpZXdUaGlja25lc3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2RhdGEtdHlwZScgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLXR5cGUnLCBwcmV2aWV3UmVkb0xpc3RbcHJldmlld1JlZG9MaXN0Lmxlbmd0aCAtIDFdLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2RhdGEtb3JkZXInICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1vcmRlcicsIChwcmV2aWV3UmVkb0xpc3RbcHJldmlld1JlZG9MaXN0Lmxlbmd0aCAtIDFdLm9yZGVyKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcHJldmlld1JlZG9MaXN0W3ByZXZpZXdSZWRvTGlzdC5sZW5ndGggLSAxXS5kKTtcclxuICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICd0YWJpbmRleCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0YWJpbmRleCcsICcwJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlld01vZGUgPT0gJ2VyYXNlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnY2xhc3MnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgJ2VyYXNlckhvdmVyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBlbGVtZW50IHN0b3JlZCBpbnRvIHZhcmlhYmxlIHNjcmliYmxlIGluIGRyYXdpbmcgY29udGFpbmVyIGluIHdoaWNoIGRyYXdpbmdzIGFyZSBzdG9yZWQgc2tldGNoZWQgYnkgdGhlIGhlbHAgb2YgZHJhd2luZyB0b29sc1xyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcucHJldmlld0RyYXdpbmdQYXRocycpLnByZXBlbmQoc2NyaWJibGUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpZXdSZWRvTGlzdFtwcmV2aWV3UmVkb0xpc3QubGVuZ3RoIC0gMV0ubW9kZSA9PSAncmVtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgZWxlbWVudCB0aGF0IGhhdmUgZGF0YS1vcmRlciBhdHRyaWJ1dGUgYW5kIHZhbHVlIG9mIHRoaXMgYXR0cmlidXRlIGlzIGVxdWFscyB0byB0aGUgdmFsdWUgb2Ygb3JkZXIga2V5IG9mIHRoZSBsYXN0IGluZGV4IHZhbHVlIG9mIGFycmF5IHByZXZpZXdSZWRvTGlzdCwgbWVhbnMgcmVtb3ZlcyB0aGUgbGFzdCBkcmF3aW5nIHN0b3JlZCBpbiBhcnJheSBwcmV2aWV3UmVkb0xpc3RcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgW2RhdGEtb3JkZXI9XCInICsgKHByZXZpZXdSZWRvTGlzdFtwcmV2aWV3UmVkb0xpc3QubGVuZ3RoIC0gMV0ub3JkZXIpICsgJ1wiXScsICdyZW1vdmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3VW5kb0NvdW50IGJ5IDFcclxuICAgICAgICAgICAgcHJldmlld1VuZG9Db3VudCsrO1xyXG4gICAgICAgICAgICAvLyBwdXNoZXMgdGhlIGxhc3QgZGF0YSBvZiBhcnJheSBwcmV2aWV3UmVkb0xpc3QgaW50byBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGgucHVzaChwcmV2aWV3UmVkb0xpc3QucG9wKCkpO1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyBjb3B5IG9mIGFycmF5IHByZXZpZXdTY3JpYmJsZVBhdGhcclxuICAgICAgICAgICAgbGV0IHRlbXBBcnJheUNvbnRhaW5lciA9IGFycmF5Q29weShwcmV2aWV3U2NyaWJibGVQYXRoKTtcclxuICAgICAgICAgICAgLy8gc3RvcmVzIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHVzZXIgYW5kIHNldHMgdGhlIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgICAgICBzdG9yZVVzZXJQYXRocyh0ZW1wQXJyYXlDb250YWluZXIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19jbGVhclNjcmVlbicpLmRpc2FibGVkID0gKEFILnNlbGVjdEFsbCgnLnByZXZpZXdEcmF3aW5nUGF0aHMgcGF0aCcpLmxlbmd0aCA9PSAwKTtcclxuICAgICAgICAgICAgaWYgKHByZXZpZXdVbmRvTGlzdC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIHJlZG8gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZW5hYmxlZCB0aGUgdW5kbyBidXR0b25cclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld191bmRvJykuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgQUgubGlzdGVuKCdib2R5JywgJ2NsaWNrJywgJyNtYXJrX3BvaW50cycsIGZ1bmN0aW9uIChjdXJyZW50LCBldmVudCkge1xyXG4gICAgICAgICAgICBtYXJrUG9pbnRFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsICdrZXl1cCcsICcjbWFya19wb2ludHMnLCBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICAgICAgbWFya1BvaW50RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGNhbGwgdGhlIGZ1bmN0aW9uIGFmdGVyIHVwZGF0ZSBpbiB0aGUgc3RvcmUvc3RhdGVcclxuICAgIGFmdGVyVXBkYXRlKGFzeW5jKCk9PntcclxuICAgICAgICAvLyBmb3IgY2hhbmdpbmcgdGhlIHhtbCBhbmQgbG9hZGluZyB0aGUgbW9kdWxlIGFjY29yZGluZyB0byB0aGUgeG1sXHJcbiAgICAgICAgaWYgKHN0YXRlLnhtbCAhPSB4bWwpIHtcclxuICAgICAgICAgICAgcGFyc2VYTUxGb3JHZXR0aW5nRGF0YSgpO1xyXG4gICAgICAgICAgICBzdGF0ZS54bWwgPSB4bWw7XHJcbiAgICAgICAgICAgIHJlaW5pdGlhbGl6ZUZvdWNzRXZlbnQoKTtcclxuICAgICAgICAgICAgY2hlY2tVc2VyQW5zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZvciBjYWxsaW5nIHRoZSBzZXRyZXZpZXcgYW5kIHVuc2V0cmV2aWV3IGZ1bmN0aW9uIG9uIGNoYW5nZSBvZiByZXZpZXcgbW9kZVxyXG4gICAgICAgIGlmIChzdGF0ZS5yZXZpZXcgIT0gaXNSZXZpZXcgJiYgZWRpdG9yU3RhdGUpIHtcclxuICAgICAgICAgICAgcHJldl9zdG9yZS51cGRhdGUoIChpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnJldmlldyA9IGlzUmV2aWV3O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaXNSZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHNldFJldmlldygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdW5zZXRSZXZpZXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGZ1bmN0aW9uIHJlc3BvbnNpYmxlIGZvciB0aGUgY29tcGFzcyBsYXN0Y2lyY2xlIGtleWV2ZW50XHJcbiAgICBmdW5jdGlvbiBjb21wYXNzTGFzdGNpcmNsZUV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGlzU2NyaWJibGUpIHtcclxuICAgICAgICAgICAgc3RvcERyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNEcmF3Q29tcGFzc1ByZXZpZXcpIHJldHVybjtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgIGZhbHNlIG9mIHRoZSB2YXJpYWJsZSBpc0RyYXdDb21wYXNzUHJldmlld1xyXG4gICAgICAgICAgICBpc0RyYXdDb21wYXNzUHJldmlldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSB0cnVlIG9mIHRoZSB2YXJpYWJsZSBpc1N0b3JlU3RhcnQgdG8gc3RvcmUgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGlzU3RvcmVTdGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgY2xhc3MgbGFzdENpcmNsZV9ob3ZlciB0byB0aGUgbGFzdCBjaXJjbGUgb24gdGhlIHJvdGF0aW9uIGJhclxyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlJywgJ2FkZENsYXNzJywgJ2xhc3RDaXJjbGVfaG92ZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcmV2aWV3TW9kZSA9PSBcImNvbXBhc3NcIiAmJiBldmVudC50eXBlID09IFwibW91c2Vkb3duXCIpIHx8IChldmVudC5zaGlmdEtleSkpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgYWxsIG1hcmsgcG9pbnRzIGFuZCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2lzTUFya2luZycgdG8gMVxyXG4gICAgICAgICAgICBjbGVhck1hcmtpbmcoKTtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgY3Vyc29yIHN0eWxlIHRvIGdyYWJiaW5nIHdoZW4gbW91c2UgcmVhY2hlZCBpbnNpZGUgbGFzdCBjaXJjbGUgb24gdGhlIHJvdGF0aW9uIGJhclxyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlJywnY3NzJywgeydjdXJzb3InOiAnZ3JhYmJpbmcnfSk7XHJcbiAgICAgICAgICAgIGlmIChpc0RyYXdDb21wYXNzUHJldmlldyB8fCBldmVudC50eXBlID09IFwibW91c2Vkb3duXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IGRyYXdpbmcgaXMgc2tldGNoaW5nXHJcbiAgICAgICAgICAgICAgICBpc0RyYXdpbmdQcmV2aWV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHJhZGl1cyBpcyByb3RhdGluZ1xyXG4gICAgICAgICAgICAgICAgaXNQcmV2aWV3UmFkaXVzUm90YXRlID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB1cGRhdGVzIHRoZSB2YWx1ZSBvZiBjb21wYXNzIHJhZGl1cyBhbmQgYW5nbGVcclxuICAgICAgICAgICAgY2hlY2tQcmV2aWV3UmFkaXVzQW5kQW5nbGUoKTtcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHZhbHVlIG9mIHN0YXJ0IGFuZ2xlXHJcbiAgICAgICAgICAgIGNvbXBhc3NBbmdsZURpc3BsYWNlbWVudC5zdGFydCA9IHByZXZpZXdDb21wYXNzQW5nbGU7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZXMgYW4gZWxlbWVudCB3aXRoIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSB4bWxucyBuYW1lc3BhY2UgVVJJIGFuZCAncGF0aCcgbmFtZVxyXG4gICAgICAgICAgICBzY3JpYmJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgJ3BhdGgnKTtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgc3Ryb2tlIGNvbG9yIGFuZCB3aWR0aFxyXG4gICAgICAgICAgICBzZXRQcmV2aWV3Q29sb3IocHJldmlld0NvbG9yLCBwcmV2aWV3VGhpY2tuZXNzKTtcclxuICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2RhdGEtdHlwZScgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtdHlwZScsIHByZXZpZXdNb2RlICsgJ18nICsgcHJldmlld1NjcmliYmxlQ291bnQpO1xyXG4gICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZGF0YS1vcmRlcicgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtb3JkZXInLCBwcmV2aWV3U2NyaWJibGVDb3VudCk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsICdNJyArIGxhc3RDaXJjbGVfY3ggKyAnICcgKyBsYXN0Q2lyY2xlX2N5KTtcclxuICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ3RhYmluZGV4JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndGFiaW5kZXgnLCAnMCcpO1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyBjdXJyZW50IHggcG9zaXRpb25cclxuICAgICAgICAgICAgY2hlY2tDdXJyZW50UG9zaXRpb25YID0gbGFzdENpcmNsZV9jeDtcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgY3VycmVudCB5IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNoZWNrQ3VycmVudFBvc2l0aW9uWSA9IGxhc3RDaXJjbGVfY3k7XHJcbiAgICAgICAgICAgIC8vIHB1c2hlcyBvYmplY3QgaGF2aW5nIGtleXMgbW9kZSwgb3JkZXIsIHR5cGUsIGluZGV4IGFuZCBkIHdpdGggdGhlaXIgdmFsdWVzIGludG8gIGFycmF5IHByZXZpZXdTY3JpYmJsZVBhdGhcclxuICAgICAgICAgICAgcHJldmlld1NjcmliYmxlUGF0aC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG1vZGU6ICdhZGQnLFxyXG4gICAgICAgICAgICAgICAgb3JkZXI6IHByZXZpZXdTY3JpYmJsZUNvdW50LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogcHJldmlld01vZGUgKyAnXycgKyBwcmV2aWV3U2NyaWJibGVDb3VudCxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBwcmV2aWV3U2NyaWJibGVDb3VudCxcclxuICAgICAgICAgICAgICAgIGQ6ICdNJyArIGxhc3RDaXJjbGVfY3ggKyAnICcgKyBsYXN0Q2lyY2xlX2N5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgYWRkaW5nIHRoZSBmb2N1cyBhbmQgYmx1ciBldmVudFxyXG4gICAgZnVuY3Rpb24gcmVpbml0aWFsaXplRm91Y3NFdmVudCgpIHtcclxuICAgICAgICBBSC5saXN0ZW5BbGwoJy5mb2N1c1BvaW50cycsICdmb2N1cycsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmVzIHRoZSBjbGFzcyBjdXJyZW50Rm9jdXNQb2ludCBmcm9tIHRoZSBlbGVtZW50cyBoYXZlIGNsYXNzIGZvY3VzUG9pbnRzXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmZvY3VzUG9pbnRzJywgJ3JlbW92ZUNsYXNzJywgJ2N1cnJlbnRGb2N1c1BvaW50Jyk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgdGhlIGNsYXNzIGN1cnJlbnRGb2N1c1BvaW50IHRvIHRoZSBlbGVtZW50IHdoaWNoIGdvdCB0aGUgZm9jdXMgYW5kIGhhdmUgY2xhc3MgZm9jdXNQb2ludHMgXHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdjdXJyZW50Rm9jdXNQb2ludCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEFILmxpc3RlbkFsbCgnLmZvY3VzUG9pbnRzJywgJ2JsdXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGNsYXNzIGN1cnJlbnRGb2N1c1BvaW50IGZyb20gdGhlIGVsZW1lbnRzIGhhdmUgY2xhc3MgZm9jdXNQb2ludHNcclxuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuZm9jdXNQb2ludHMnLCAncmVtb3ZlQ2xhc3MnLCAnY3VycmVudEZvY3VzUG9pbnQnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgYWRkaW5nIHRoZSBtYXJrIHBvaW50IGZyb20gdGhlIGtleSBldmVudFxyXG4gICAgZnVuY3Rpb24gbWFya1BvaW50RXZlbnQoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQuc2NyZWVuWCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0RHJhd2luZ0J5S2V5ICYmIGlzRHJhd1N0b3ApIHtcclxuICAgICAgICAgICAgLy8gc3RvcCB0aGUgZHJhd2luZyBhbmQgc3RvcmUgdGhlIGRyYXdpbmcgc2tldGNoZWQgYnkgdGhlIHVzZXIgYW5kIHNldHMgdGhlIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgICAgICBzdG9wRHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSAzMiB8fCBldmVudC5zY3JlZW5YID09PSAwKSkge1xyXG4gICAgICAgICAgICAvLyBzdG9wcyB0aGUgZXZlbnRzIGZyb20gYmVpbmcgYnViYmxlZFxyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAvLyBqb2lucyB0aGUgbWFya2VkIHBvaW50cyBieSB0aGUgaGVscCBvZiBsaW5lIHRoYXQgc3RhcnRzIHdpdGggZmlyc3QgbWFyayBwb2ludCBhbmQgZW5kcyBhdCBsYXN0IG1hc2tlZCBwb2ludCBieSBtb3ZpbmcgaW4gc2VxdWVuY2lhbCBvcmRlclxyXG4gICAgICAgICAgICBtYXJrRmluYWxQb2ludHMoKTtcclxuICAgICAgICAgICAgaWYgKGlzTWFya2luZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaGlkZXMgcGx1cyBpY29uICgrKSB0aGF0IGlzIHVzZWQgZm9yIHNrZXRjaCB0aGUgZ3JhcGggdmlhIGtleWJvYXJkXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNtb3ZlRHJhd0ljb24nLCAnYWRkQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgY3Vyc29yIHN0eWxlIHRvIGNyb3NzaGFpciAoKylcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdTdmcnLCAnY3NzJywgeydjdXJzb3InOiAnY3Jvc3NoYWlyJ30pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvd3MgcGx1cyBpY29uICgrKSB0aGF0IGlzIHVzZWQgZm9yIHNrZXRjaCB0aGUgZ3JhcGggdmlhIGtleWJvYXJkXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNtb3ZlRHJhd0ljb24nLCAncmVtb3ZlQ2xhc3MnLCAnaCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIGN1cnNvciBzdHlsZSB0byBhdXRvXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3U3ZnJywgJ2NzcycsIHsnY3Vyc29yJzogJ2F1dG8nfSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09ICdjbGljaycgJiYgZXZlbnQuc2NyZWVuWCAhPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBqb2lucyB0aGUgbWFya2VkIHBvaW50cyBieSB0aGUgaGVscCBvZiBsaW5lIHRoYXQgc3RhcnRzIHdpdGggZmlyc3QgbWFyayBwb2ludCBhbmQgZW5kcyBhdCBsYXN0IG1hc2tlZCBwb2ludCBieSBtb3ZpbmcgaW4gc2VxdWVuY2lhbCBvcmRlclxyXG4gICAgICAgICAgICBtYXJrRmluYWxQb2ludHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBjYWxscyB3aGVuZXZlciB0aGVyZSBpcyBjbGljayBvbiB0b29sYmFyIGJ1dHRvbnNcclxuICAgIGZ1bmN0aW9uIHRvb2xiYXJBY3Rpb24oY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICBpZiAoaXNTY3JpYmJsZSkge1xyXG4gICAgICAgICAgICBzdG9wRHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PSAnY2xpY2snIHx8IChldmVudC5rZXlDb2RlID09IDEzIHx8IGV2ZW50LmtleUNvZGUgPT0gMzIpKSB7XHJcbiAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgdmFsdWUgb2YgdGhlIGRhdGEtdGl0bGUgYXR0cmlidXRlIG9mIHRoZSBkcmF3aW5nIHRvb2wgYnV0dG9ucyBvciBvZiBkZWxldGUgYnV0dG9uIG9uIHdoaWNoIGlzIGNsaWNrZWQgb3Igb24gd2hpY2gga2V5dXBlZFxyXG4gICAgICAgICAgICBwcmV2aWV3TW9kZSA9IGN1cnJlbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJyk7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0eWxlIG9mIHRoZSBjdXJzb3IgdG8gY3Jvc3NoYWlyICgrKVxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3U3ZnJywgJ2NzcycsIHsnY3Vyc29yJzogJ2Nyb3NzaGFpcid9KTtcclxuICAgICAgICAgICAgLy8gaGlkZXMgdGhlIGljb24gKCspIHRoYXQgaXMgdXNlZCBmb3Igc2tldGNoIHRoZSBkcmF3aW5nIGJ5IHRoZSBoZWxwIG9mIGtleWJvYXJkXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI21vdmVEcmF3SWNvbicsICdhZGRDbGFzcycsICdoJyk7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIDAgb2YgdmFyaWFibGUgc3RhcnREcmF3aW5nQnlLZXkgdG8gaW5kaWNhdGUgdGhhdCBkcmF3aW5nIGlzIG5vdCBzdGFydGVkIGJ5IHRoZSBrZXlib2FyZFxyXG4gICAgICAgICAgICBzdGFydERyYXdpbmdCeUtleSA9IDA7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBpc0RyYXdTdG9wIGJ5IDAgdG8gaW5kaWNhdGUgdGhhdCBza2V0Y2hpbmcgb2YgdGhlIGRyYXdpbmcgZWl0aGVyIG5vdCBzdGFydGVkIG9yIGluIHByb2dyZXNzXHJcbiAgICAgICAgICAgIGlzRHJhd1N0b3AgPSAwO1xyXG4gICAgICAgICAgICBpZiAocHJldmlld01vZGUgPT0gJ2VyYXNlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZHMgdGhlIGNsYXNzIGVyYXNlckhvdmVyIHRvIHRoZSBlbGVtZW50IHBhdGggdGhhdCBjb250YWlucyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5wcmV2aWV3RHJhd2luZ1BhdGhzIHBhdGgnLCAnYWRkQ2xhc3MnLCAnZXJhc2VySG92ZXInKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGNsYXNzIGVyYXNlckhvdmVyIHRvIHRoZSBlbGVtZW50IHBhdGggdGhhdCBjb250YWlucyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5wcmV2aWV3RHJhd2luZ1BhdGhzIHBhdGgnLCAncmVtb3ZlQ2xhc3MnLCAnZXJhc2VySG92ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBoaWRlcyB0aGUgY29tcGFzcyBlbGVtZW50XHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmRyYXdpbmdDb21wYXNzU3ZnJywgJ2FkZENsYXNzJywgJ2gnKTtcclxuICAgICAgICAgICAgaWYgKHByZXZpZXdNb2RlID09ICdjb21wYXNzJykge1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvd3MgdGhlIGNvbXBhc3MgdG9vbFxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuZHJhd2luZ0NvbXBhc3NTdmcnLCAncmVtb3ZlQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGFsbCBtYXJrIHBvaW50cyBhbmQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlICdpc01BcmtpbmcnIHRvIDFcclxuICAgICAgICAgICAgY2xlYXJNYXJraW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDMyKSAmJiBwcmV2aWV3TW9kZSAhPSAnZXJhc2VyJyAmJiBwcmV2aWV3TW9kZSAhPSAnY29tcGFzcycpIHtcclxuICAgICAgICAgICAgLy8gaGlkZXMgdGhlIGljb24gKCspLCB3aGljaCBpcyB1c2VkIHRvIHNrZXRjaCB0aGUgZHJhd2luZyB1c2luZyBrZXlib2FyZFxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNtb3ZlRHJhd0ljb24nLCAncmVtb3ZlQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSBjdXJzb3Igc3R5bGUgYXV0b1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3U3ZnJywgJ2NzcycsIHsnY3Vyc29yJzogJ2F1dG8nfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydERyYXdpbmdCeUtleSAmJiBpc0RyYXdTdG9wKSB7XHJcbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIGRyYXdpbmcgYW5kIHN0b3JlIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHRoZSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgc3RvcERyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBjYWxscyB3aGVuIHdlIGFyZSBsZWF2aW5nIHRoZSBkcmF3YWJsZSBhcmVhIG9yIG9uIG1vdXNldXBcclxuICAgIGZ1bmN0aW9uIHByZXZpZXdNb3VzZUxlYXZlKGV2ZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChwcmV2aWV3TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzY3JpYmJsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRHJhd2luZ1ByZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJldmlld01vdXNlQ29vcmRpbmF0ZXMoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9ja0ZvY3VzICYmICgoY2hlY2tDdXJyZW50UG9zaXRpb25YID09IHByZXZpZXdfbW91c2VYICYmIGNoZWNrQ3VycmVudFBvc2l0aW9uWSA9PSBwcmV2aWV3X21vdXNlWSAmJiBwcmV2aWV3TW9kZSA9PSAnbGluZScpIHx8IChwcmV2aWV3TW9kZSA9PSAnc2NyaWJibGUnICYmICgocHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZC5zcGxpdCgnTCcpLmxlbmd0aCAtIDEpIDwgMykpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gdGhlIGFycmF5IHByZXZpZXdTY3JpYmJsZVBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGgucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjaGVja0N1cnJlbnRQb3NpdGlvblggPT0gcHJldmlld19tb3VzZVggJiYgY2hlY2tDdXJyZW50UG9zaXRpb25ZID09IHByZXZpZXdfbW91c2VZICYmIHByZXZpZXdNb2RlID09ICdsaW5lJykgfHwgKHByZXZpZXdNb2RlID09ICdzY3JpYmJsZScgJiYgKChwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kLnNwbGl0KCdMJykubGVuZ3RoIC0gMSkgPCAzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2QnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgKyAnIEwnICsgcHJldmlld19tb3VzZVggKyAnICcgKyBwcmV2aWV3X21vdXNlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIHZhbHVlIG9mIHZhcmlhYmxlcyBwcmV2aWV3X21vdXNlWCBhbmQgcHJldmlld19tb3VzZVkgc2VwYXJhdGVkIGJ5IHNwYWNlIHdpdGggcHJlZml4ICdMJyBpbiB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGtleSAnZCcgYXQgaW5kZXggc3BlY2lmaWVkIGluIHRoZSB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kID0gcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCArICcgTCcgKyBwcmV2aWV3X21vdXNlWCArICcgJyArIHByZXZpZXdfbW91c2VZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgZWxlbWVudCBzdG9yZWQgaW50byB2YXJpYWJsZSBzY3JpYmJsZSBpbiBkcmF3aW5nIGNvbnRhaW5lciBpbiB3aGljaCBkcmF3aW5ncyBhcmUgc3RvcmVkIHNrZXRjaGVkIGJ5IHRoZSBoZWxwIG9mIGRyYXdpbmcgdG9vbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdEcmF3aW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlcyB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHByZXZpZXdTY3JpYmJsZUNvdW50IGJ5IDEgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgcHJldmlld1VuZG9Db3VudCBieSAxIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld1VuZG9Db3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZXMgYXJyYXkgcHJldmlld1VuZG9MaXN0IGJsYW5rXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3VW5kb0xpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZWQgY2xlYXIgc2NyZWVuIGFuZCB1bmRvIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19jbGVhclNjcmVlbicpLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3VuZG8nKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgcmVkbyBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdfcmVkbycpLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBmYWxzZSBvZiB0aGUgdmFyaWFibGUgaXNEcmF3aW5nUHJldmlldyBcclxuICAgICAgICAgICAgICAgICAgICBpc0RyYXdpbmdQcmV2aWV3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wYXNzJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCByYWRpdXMgaXMgbm90IGluY3JlYXNlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlld1JhZGl1c0luY3JlYXNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCByYWRpdXMgaXMgbm90IHJvdGF0ZWRcclxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXdSYWRpdXNSb3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXZpZXdDb21wYXNzTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSB4IGFuZCB5IGNvLW9yZGluYXRlIG9mIHRoZSBtb3VzZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3TW91c2VDb29yZGluYXRlcyhldmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHggY28tb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4ID0gcHJldmlld19tb3VzZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB5IGNvLW9yZGluYXRlIG9mIHRoZSBtb3VzZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeSA9IHByZXZpZXdfbW91c2VZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250YWlucyByYWRpdXMgb2YgdGhlIGNvbXBhc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld0NvbXBhc3NSYWRpdXMgPSBBSC5zZWxlY3QoJy5kcmF3aW5nQ29tcGFzc1JvdXRlJykuZ2V0QXR0cmlidXRlKCdyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHJvdGF0aW9uYmFyIGFuZCBjaGFuZ2UgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlcyB0aGF0IGxpZXMgb24gcm90YXRpb25iYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUHJldmlld0NvbXBhc3NDYWxjdWxhdGlvbihjeCwgY3ksIHByZXZpZXdDb21wYXNzUmFkaXVzLCBwcmV2aWV3Q29tcGFzc0FuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdGVzIHRoYXQgY29tcGFzcyBpcyBub3QgbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3Q29tcGFzc01vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRHJhd2luZ1ByZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kLnNwbGl0KCdMJykubGVuZ3RoIC0gMSkgPCA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVzIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld1NjcmliYmxlUGF0aC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kICsgJyBMJyArIGxhc3RDaXJjbGVfY3ggKyAnICcgKyBsYXN0Q2lyY2xlX2N5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgdmFsdWUgb2YgdmFyaWFibGVzIGxhc3RDaXJjbGVfY3ggYW5kIGxhc3RDaXJjbGVfY3kgc2VwYXJhdGVkIGJ5IHNwYWNlIHdpdGggcHJlZml4ICdMJyBpbiB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGtleSAnZCcgYXQgaW5kZXggc3BlY2lmaWVkIGluIHRoZSB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kID0gcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCArICcgTCcgKyBsYXN0Q2lyY2xlX2N4ICsgJyAnICsgbGFzdENpcmNsZV9jeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIGVsZW1lbnQgc3RvcmVkIGludG8gdmFyaWFibGUgc2NyaWJibGUgaW4gZHJhd2luZyBjb250YWluZXIgaW4gd2hpY2ggZHJhd2luZ3MgYXJlIHN0b3JlZCBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJy5wcmV2aWV3RHJhd2luZ1BhdGhzJykucHJlcGVuZChzY3JpYmJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBieSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgcHJldmlld1VuZG9Db3VudCBieSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3VW5kb0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlcyBhcnJheSBwcmV2aWV3VW5kb0xpc3QgYmxhbmtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdVbmRvTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCBjbGVhciBzY3JlZW4gKHgpIGFuZCB1bmRvIGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19jbGVhclNjcmVlbicpLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3VuZG8nKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIHJlZG8gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3JlZG8nKS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB2YWx1ZSBmYWxzZSBvZiB2YXJpYWJsZSBpc0RyYXdpbmdQcmV2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJhd2luZ1ByZXZpZXcgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSBjdXJzb3Igc3R5bGUgdG8gZ3JhYiB3aGVuIGl0IGxpZXMgb24gbGFzdCBjaXJjbGUgb24gdGhlIHJvdGF0aW9uIGJhclxyXG4gICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGUnLCAnY3NzJyAsIHsnY3Vyc29yJzogJ2dyYWInfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29udGFpbnMgY29weSBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgIGxldCB0ZW1wQXJyYXlDb250YWluZXIgPSBhcnJheUNvcHkocHJldmlld1NjcmliYmxlUGF0aCk7XHJcbiAgICAgICAgICAgIC8vIHN0b3JlcyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgc3RvcmVVc2VyUGF0aHModGVtcEFycmF5Q29udGFpbmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVja3MgdGhlIGFuc3dlciBhbmQgc2hvd3MgdGhlIHN0YXR1cyBvZiB0aGUgYW5zd2VyXHJcbiAgICBmdW5jdGlvbiBzZXRSZXZpZXcoKSB7XHJcbiAgICAgICAgaXNSZXZpZXcgPSB0cnVlO1xyXG4gICAgICAgIGlmIChzdGFydERyYXdpbmdCeUtleSAmJiBpc0RyYXdTdG9wIHx8IGxvY2tGb2N1cykge1xyXG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBkcmF3aW5nIGFuZCBzdG9yZSB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB0aGUgdXNlciBhbmQgc2V0cyB0aGUgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICAgICAgICAgIHN0b3BEcmF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEcmF3Q29tcGFzc1ByZXZpZXcgJiYgaXNTdG9yZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgIC8vIHN0b3JlcyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB1c2VyIHVzaW5nIGtleWJvYXJkIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgc3RvcmVDb21wYXNzUGF0aEJ5S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrcyB0aGUgYW5zd2VyIGFuZCB1cGRhdGVzIHRoZSBzdGF0dXMgYW5kIGVuYWJsZXMgJ01hcmsgUG9pbnRzJyBidXR0b24gYW5kIGFsc28gdXBkYXRlcyBpdHMgdGV4dCBhcyAnTWFyayBQb2ludHMnIFxyXG4gICAgICAgIHBhcnNlWE1MRm9yQW5zd2VyKHRydWUpO1xyXG4gICAgICAgIC8vIGNvbnRhaW5zIHRoZSB2YWx1ZSBvZiBzdGF0ZSBhcnJheSBzZWxlY3RlZFRvb2xzIGF0IGluZGV4IDAgYWZ0ZXIgcmVtb3ZpbmcgdGhlIGZpcnN0IGNoYXJhY3RlciBcclxuICAgICAgICBwcmV2aWV3TW9kZSA9IHN0YXRlLnNlbGVjdGVkVG9vbHNbMF0uc3Vic3RyKC0oc3RhdGUuc2VsZWN0ZWRUb29sc1swXS5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgYWN0aXZlIGZyb20gZHJhd2luZyB0b29scywgZGVsZXRlLCBhbmQgJ01hcmsgUG9pbnRzJyBvciAnRmluaXNoIE1hcmtpbmcnIGJ1dHRvbnNcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJy5wcmV2aWV3X2J0biwjbWFya19wb2ludHMnLCAncmVtb3ZlQ2xhc3MnLCAnYWN0aXZlJyk7XHJcbiAgICAgICAgLy8gYWRkcyB0aGUgY2xhc3MgYWN0aXZlIHRvIHRoZSBkcmF3aW5nIHRvb2wgYnV0dG9uIHdoaWNoIGV4aXN0IGF0IGluZGV4IDAgaW4gc3RhdGUgYXJyYXkgc2VsZWN0ZWRUb29sc1xyXG4gICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXcnICsgc3RhdGUuc2VsZWN0ZWRUb29sc1swXSwgJ2FkZENsYXNzJywgJ2FjdGl2ZScpO1xyXG4gICAgICAgIGlmIChwcmV2aWV3TW9kZSA9PSAnY29tcGFzcycpIHtcclxuICAgICAgICAgICAgLy8gc2hvd3MgdGhlIGNvbXBhc3MgdG9vbFxyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5kcmF3aW5nQ29tcGFzc1N2ZycsICdyZW1vdmVDbGFzcycsICdoJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaGlkZXMgdGhlIGNvbXBhc3MgdG9vbFxyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5kcmF3aW5nQ29tcGFzc1N2ZycsICdhZGRDbGFzcycsICdoJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0ZS5yZW1lZGlhdGlvbk1vZGUgPSAnb24nXHJcbiAgICAgICAgXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcucHJldmlld0J0bkdycCcsICdhZGRDbGFzcycsICdoJyk7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgJ25vbmUnIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3TW9kZVxyXG4gICAgICAgIHByZXZpZXdNb2RlID0gJ25vbmUnO1xyXG4gICAgICAgIC8vIG5vdCBhbGxvd2VkIHVzZXIgdG8gcGVyZm9ybSB0aGUgdGFza1xyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfZHJhd2luZ19jb250YWluZXInLCAnY3NzJywge3BvaW50ZXJFdmVudHM6IFwibm9uZVwifSk7XHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgcHJldmlld0tleVN2ZyBmcm9tIHRoZSBzdmcgZWxlbWVudCBoYXZlIGlkIHByZXZpZXdTdmdcclxuICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3U3ZnJywgJ3JlbW92ZUNsYXNzJywgJ3ByZXZpZXdLZXlTdmcnKTtcclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgbWFya2VkIHBvaW50cyBhbmQgYWxzbyB0aGUgcGF0aCB0aGF0IGlzIHNrZXRjaGVkIGJ5IHRoZSBoZWxwIG9mIG1hcmsgcG9pbnRzXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcucHJldmlld01hcmtpbmdQYXRocyAuYW5zd2VyX21hcmsnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgLy8gdXBkYXRlcyB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICBjcmVhdGVVWE1MKCk7XHJcbiAgICAgICAgLy8gZHJhdyB0aGUgbWFya2VkIHBvaW50cyBhbmQgdGhlIGxpbmVzIGNvbm5lY3RpbmcgdG8gdGhlc2UgcG9pbnRzXHJcbiAgICAgICAgYWRkTWFya1BvaW50T25Mb2FkKEpTT04ucGFyc2UobWFya1BvaW50c0RhdGEpKTtcclxuICAgICAgICAvLyBzZXRzIHRoZSB0YWJpbmRleCBhbmQgYXJpYS1sYWJlbCB0byB0aGUgZWxlbWVudHMgaGF2ZSBjbGFzcyAnYW5zd2VyX21hcmsnIGFuZCB0YWcgbmFtZSBpcyBwYXRoXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCdwYXRoLmFuc3dlcl9tYXJrJywnYXR0cicse1xyXG4gICAgICAgICAgICAndGFiaW5kZXgnOiAnMCcsXHJcbiAgICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiAnYW5zd2VyTGluZSdcclxuICAgICAgICB9KVxyXG4gICAgICAgIGlmIChzdGF0ZS5jb3JyZWN0QW5zd2VyKSB7XHJcbiAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgdGl0bGUgZWxlbWVudCBpbnNpZGUgdGhlIGVsZW1lbnQgcHJldmlld01hcmtpbmdQYXRocyB3aXRoIGNvcnJlY3QgbWVzc2FnZVxyXG4gICAgICAgICAgICBBSC5pbnNlcnQoJy5wcmV2aWV3TWFya2luZ1BhdGhzJywnPHRpdGxlIGlkPVwiYW5zd2VyTGluZVwiPicgKyBsLmFuc19jb3JyZWN0ICsgJzwvdGl0bGU+JywgJ2JlZm9yZWVuZCcpO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSBzdHJva2UgY29sb3Igb2YgdGhlIG1hcmsgcG9pbnRzIHRvICMwRjlENThcclxuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuYW5zd2VyX21hcmsnLCAnY3NzJywgeydzdHJva2UnOiAnIzBGOUQ1OCd9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBhcHBlbmQgdGhlIHRpdGxlIGVsZW1lbnQgaW5zaWRlIHRoZSBlbGVtZW50IHByZXZpZXdNYXJraW5nUGF0aHMgd2l0aCBpbmNvcnJlY3QgbWVzc2FnZVxyXG4gICAgICAgICAgICBBSC5pbnNlcnQoJy5wcmV2aWV3TWFya2luZ1BhdGhzJywnPHRpdGxlIGlkPVwiYW5zd2VyTGluZVwiPicgKyBsLmFuc19pbmNvcnJlY3QgKyAnPC90aXRsZT4nLCAnYmVmb3JlZW5kJyk7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgbWFyayBwb2ludHMgdG8gcmVkXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmFuc3dlcl9tYXJrJywgJ2NzcycsIHsnc3Ryb2tlJzogJyNGRjAwMDAnfSk7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgYW5zd2VyIHBvaW50IHRvICMwRjlENThcclxuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuYW5zd2VyX2NpcmNsZScsICdjc3MnLCB7J3N0cm9rZSc6ICcjMEY5RDU4J30pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhbGxvd2VkIHVzZXIgdG8gcGVyZm9ybSB0aGUgdGFzayBhbmQgY2hhbmdlcyB0aGUgc3Ryb2tlIGNvbG9yIG9mIG1hcmsgcG9pbnRzIFxyXG4gICAgZnVuY3Rpb24gdW5zZXRSZXZpZXcoKSB7XHJcbiAgICAgICAgaXNSZXZpZXcgPSBmYWxzZTtcclxuICAgICAgICAvLyBhbGxvd2VkIHVzZXIgdG8gcGVyZm9ybSB0aGUgdGFza1xyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfZHJhd2luZ19jb250YWluZXInLCdjc3MnLCB7cG9pbnRlckV2ZW50cyA6IFwiXCJ9KTtcclxuICAgICAgICAvLyBzaG93cyBhbGwgYnV0dG9uc1xyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdCdG5HcnAnLCAncmVtb3ZlQ2xhc3MnLCAnaCcpXHJcbiAgICAgICAgLy8gYWRkcyB0aGUgY2xhc3MgcHJldmlld0tleVN2ZyB0byB0aGUgc3ZnIGVsZW1lbnQgaGF2ZSBpZCBwcmV2aWV3U3ZnXHJcbiAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld1N2ZycsJ2FkZENsYXNzJywgJ3ByZXZpZXdLZXlTdmcnKTtcclxuICAgICAgICAvLyBjb250YWlucyB0aGUgdmFsdWUgb2Ygc3RhdGUgYXJyYXkgc2VsZWN0ZWRUb29scyBhdCBpbmRleCAwIGFmdGVyIHJlbW92aW5nIHRoZSBmaXJzdCBjaGFyYWN0ZXJcclxuICAgICAgICBwcmV2aWV3TW9kZSA9IHN0YXRlLnNlbGVjdGVkVG9vbHNbMF0uc3Vic3RyKC0oc3RhdGUuc2VsZWN0ZWRUb29sc1swXS5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgLy8gaXQncyBhbHNvIHVzZWQgYmVsb3cgaW4gdGhpcyBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfYnRuLCNtYXJrX3BvaW50cycsICdyZW1vdmVDbGFzcycsICdhY3RpdmUnKTtcclxuICAgICAgICAvLyBpdCdzIGFsc28gdXNlZCBiZWxvdyBpbiB0aGlzIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSByZW1vdmVkXHJcbiAgICAgICAgQUguc2VsZWN0KCcjcHJldmlldycgKyBzdGF0ZS5zZWxlY3RlZFRvb2xzWzBdLCAnYWRkQ2xhc3MnLCAnYWN0aXZlJyk7XHJcbiAgICAgICAgaWYgKHByZXZpZXdNb2RlID09ICdjb21wYXNzJykge1xyXG4gICAgICAgICAgICAvLyBzaG93cyBjb21wYXNzIHRvb2xcclxuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuZHJhd2luZ0NvbXBhc3NTdmcnLCAncmVtb3ZlQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSBzdHlsZSBvZiB0aGUgY3Vyc29yIHRvIGNyb3NzaGFpciAoKylcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld1N2ZycsICdjc3MnLCB7J2N1cnNvcic6ICdjcm9zc2hhaXInfSk7XHJcbiAgICAgICAgICAgIC8vIGhpZGVzIHRoZSBpY29uICgrKSB3aGljaCBpcyB1c2VkIHRvIHNrZXRjaCB0aGUgZHJhd2luZyB1c2luZyBrZXlib2FyZFxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNtb3ZlRHJhd0ljb24nLCAnYWRkQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGhpZGVzIGNvbXBhc3MgdG9vbFxyXG4gICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5kcmF3aW5nQ29tcGFzc1N2ZycsICdhZGRDbGFzcycsICdoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIGNsYXNzIGFjdGl2ZSBmcm9tIGRyYXdpbmcgdG9vbHMsIGRlbGV0ZSwgYW5kICdNYXJrIFBvaW50cycgb3IgJ0ZpbmlzaCBNYXJraW5nJyBidXR0b25zXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcucHJldmlld19idG4sI21hcmtfcG9pbnRzJywgJ3JlbW92ZUNsYXNzJywgJ2FjdGl2ZScpO1xyXG4gICAgICAgIC8vIGFkZHMgdGhlIGNsYXNzIGFjdGl2ZSB0byB0aGUgZHJhd2luZyB0b29sIGJ1dHRvbiB3aGljaCBleGlzdCBhdCBpbmRleCAwIGluIHN0YXRlIGFycmF5IHNlbGVjdGVkVG9vbHNcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJyNwcmV2aWV3JyArIHN0YXRlLnNlbGVjdGVkVG9vbHNbMF0sICdhZGRDbGFzcycsICdhY3RpdmUnKTtcclxuICAgICAgICAvLyByZW1vdmVzIHRoZSBjb3JyZWN0IGFuc3dlciBjaXJjbGUgdGhhdCBjYW4gYmUgc2VlbiBvbiByZW1lZGlhdGlvbiBtb2RlIGluIGdyZWVuIHN0cm9rZSBjb2xvclxyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnLmNvcnJlY3RfYW5zd2VyX2NvbnRhaW5lciAuYW5zd2VyX21hcmsnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgLy8gZW5hYmxlcyB0aGUgZWxlbWVudCBoYXZlIGlkIG1hcmtfcG9pbnRzIGFuZCB1cGRhdGVzIGl0cyB0ZXh0IGFzICdNYXJrIFBvaW50cydcclxuICAgICAgICBBSC5zZWxlY3QoJyNtYXJrX3BvaW50cycpLmlubmVyVGV4dCA9ICdNYXJrIFBvaW50cyc7XHJcbiAgICAgICAgQUguc2VsZWN0KCcjbWFya19wb2ludHMnKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSAnaXNNYXJraW5nJyB0byAxXHJcbiAgICAgICAgaXNNYXJraW5nID0gMTtcclxuICAgICAgICBzdGF0ZS5yZW1lZGlhdGlvbk1vZGUgPSAnb2ZmJztcclxuICAgICAgICAvLyByZW1vdmVzIHRoZSB0aXRsZSBlbGVtZW50IGluc2lkZSB0aGUgZWxlbWVudCBoYXZlIGNsYXNzIHByZXZpZXdNYXJraW5nUGF0aHNcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJy5wcmV2aWV3TWFya2luZ1BhdGhzIHRpdGxlJywgJ3JlbW92ZScpO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIHN0YXRlIG1hcmtQb2ludENvbG9yIGludG8gdGhlIHZhbHVlIG9mIGF0dHJpYnV0ZSBzdHJva2Ugb2YgdGhlIGVsZW1lbnQgaGF2ZSBjbGFzcyBhbnN3ZXJfbWFyayBhbmQgcmVtb3ZlcyBhdHRyaWJ1dGUgdGFiaW5kZXhcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJy5hbnN3ZXJfbWFyaycsICdjc3MnLCB7J3N0cm9rZScgOiBzdGF0ZS5tYXJrUG9pbnRDb2xvcn0pO1xyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnLmFuc3dlcl9tYXJrJywncmVtb3ZlQXR0cicsJ3RhYmluZGV4Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGFyc2VzIHRoZSB4bWwgYW5kIHVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB2YXJpYWJsZXMgYW5kIHN0YXRlcyBhbmQgd2lkdGgsIHNyYywgYWx0IG9mIHRoZSBiYWNrZ3JvdW5kIGltYWdlLCBzaG93cyB0aGUgZW5hYmxlZCBkcmF3aW5nIHRvb2xzIGFuZCBzZXRzIHRoZSBtYXJrIHBvaW50IHBvc2l0aW9uIGFuZCBkcmF3IHRoZSBsaW5lcyB1c2luZyBtYXJrIHBvaW50c1xyXG4gICAgZnVuY3Rpb24gcGFyc2VYTUxGb3JHZXR0aW5nRGF0YSgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyBqc29uIGRhdGEgb2YgdGhlIHhtbFxyXG4gICAgICAgICAgICBkZWZhdWx0WE1MID0gWE1MVG9KU09OKHhtbCk7XHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0WE1MLnNteG1sLl9tYXJrUG9pbnRDb2xvciA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHRoZSBrZXkgbWFya1BvaW50Q29sb3IgdG8gIzAwZmYwMCBvZiBqc29uIGRlZmF1bHRYTUxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRYTUwuc214bWwuX21hcmtQb2ludENvbG9yID0gJyMwMGZmMDAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0WE1MLnNteG1sLl9jb2xvciA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHRoZSBrZXkgY29sb3IgdG8gcmdiKDAsIDE4OCwgMjEyKSBvZiBqc29uIGRlZmF1bHRYTUxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRYTUwuc214bWwuX2NvbG9yID0gJ3JnYigwLCAxODgsIDIxMiknO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcmV2X3N0b3JlLnVwZGF0ZSgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2Ygc3RhdGUgYmdJbWcgdG8gdGhlIHZhbHVlIG9mIGtleSBiZ2ltZyBvZiBqc29uIGRlZmF1bHRYTUxcclxuICAgICAgICAgICAgICAgIGl0ZW0uYmdJbWcgPSBkZWZhdWx0WE1MLnNteG1sLl9iZ2ltZztcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHN0YXRlIGFsdCB0byB0aGUgdmFsdWUgb2Yga2V5IGltZ0FsdCBvZiBqc29uIGRlZmF1bHRYTUxcclxuICAgICAgICAgICAgICAgIGl0ZW0uYWx0ID0gZGVmYXVsdFhNTC5zbXhtbC5faW1nQWx0O1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2Ygc3RhdGUgaW1nV2lkdGggdG8gdGhlIHZhbHVlIG9mIGtleSB3aWR0aCBvZiBqc29uIGRlZmF1bHRYTUxcclxuICAgICAgICAgICAgICAgIGl0ZW0uaW1nV2lkdGggPSBkZWZhdWx0WE1MLnNteG1sLl93aWR0aDtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHN0YXRlIGxpbmVDb2xvciB0byB0aGUgdmFsdWUgb2Yga2V5IGNvbG9yIG9mIGpzb24gZGVmYXVsdFhNTFxyXG4gICAgICAgICAgICAgICAgaXRlbS5saW5lQ29sb3IgPSBkZWZhdWx0WE1MLnNteG1sLl9jb2xvcjtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHN0YXRlIGZvY3VzREFUQSB0byB0aGUgdmFsdWUgb2Ygc3Via2V5IGNkYXRhIG9mIGtleSBiYWNrZ3JvdW5kUG9pbnQgb2YganNvbiBkZWZhdWx0WE1MXHJcbiAgICAgICAgICAgICAgICBpdGVtLmZvY3VzREFUQSA9IGRlZmF1bHRYTUwuc214bWwuYmFja2dyb3VuZFBvaW50Ll9fY2RhdGE7XHJcbiAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBvZiBzdGF0ZSBtYXJrUG9pbnRDb2xvciB0byB0aGUgdmFsdWUgb2Yga2V5IG1hcmtQb2ludENvbG9yIG9mIGpzb24gZGVmYXVsdFhNTFxyXG4gICAgICAgICAgICAgICAgaXRlbS5tYXJrUG9pbnRDb2xvciA9IGRlZmF1bHRYTUwuc214bWwuX21hcmtQb2ludENvbG9yO1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2Ygc3RhdGUgc2VsZWN0ZWRUb29scyB0byB0aGUgdmFsdWUgb2Yga2V5ICdzZWxlY3RlZERyYXdpbmdUeXBlJyBhZnRlciBqb2luaW5nIGl0IHdpdGggY29tbWFtIG9mIGpzb24gZGVmYXVsdFhNTFxyXG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZFRvb2xzID0gZGVmYXVsdFhNTC5zbXhtbC5kaXYuX3NlbGVjdGVkRHJhd2luZ1R5cGUuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIG1ha2VzIGFycmF5ICdhY2Nlc3NpYmlsaXR5UG9pbnRzJyB0byBlbXB0eVxyXG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5UG9pbnRzUHJldmlldyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBhc3NpZ24gdGhlIHZhbHVlIDEgdG8gdGhlIHZhcmlhYmxlIGZvY3VzUG9pbnRDb3VudFByZXZpZXdcclxuICAgICAgICAgICAgZm9jdXNQb2ludENvdW50UHJldmlldyA9IDE7XHJcbiAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgdmFsdWUgb2Ygc3RhdGUgZm9jdXNEQVRBIGludG8gdmFyaWFibGUgdXBkYXRlZEZvY3VzQ0RBVEFcclxuICAgICAgICAgICAgbGV0IHVwZGF0ZWRGb2N1c0NEQVRBID0gc3RhdGUuZm9jdXNEQVRBO1xyXG4gICAgICAgICAgICAvLyByZXBsYWNlcyB0aGUgY2hhcmFjdGVyICchJyB0byAnLCcgYW5kIHdyYXBzIHRoZSB2YWx1ZSBpbnRvIHNxdWFyZSBicmFja2V0XHJcbiAgICAgICAgICAgIHVwZGF0ZWRGb2N1c0NEQVRBID0gJ1snICsgdXBkYXRlZEZvY3VzQ0RBVEEucmVwbGFjZSgvIS9nLCAnLCcpICsgJ10nO1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyBqYXZhc2NyaXB0IG9iamVjdCBcclxuICAgICAgICAgICAgdXBkYXRlZEZvY3VzQ0RBVEEgPSBKU09OLnBhcnNlKHVwZGF0ZWRGb2N1c0NEQVRBKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgZWxlbWVudCBjaXJjbGUsIHBhdGggYW5kIHRpdGxlIGZyb20gZWxlbWVudCBoYXZlIGNsYXNzICdiYWNrZ3JvdW5kRm9jdXNQYXRoUHJldmlldycgYW5kICdiYWNrZ3JvdW5kRm9jdXNQb2ludFByZXZpZXcnXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmJhY2tncm91bmRGb2N1c1BvaW50UHJldmlldyBjaXJjbGUsLmJhY2tncm91bmRGb2N1c1BhdGhQcmV2aWV3IHBhdGgsIC5iYWNrZ3JvdW5kRm9jdXNQb2ludFByZXZpZXcgdGl0bGUnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB1cGRhdGVkRm9jdXNDREFUQS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIC8vIHB1c2hlcyBkYXRhIG9mIG11bHRpIGRpbWVzaW9uIGFycmF5IHVwZGF0ZWRGb2N1c0NEQVRBIHNwZWNpZmllZCBhdCBwZXJ0aWN1bGFyIHJvdyBhbmQgY29sdW1uIHdoZXJlIHZhbHVlIG9mIHJvdyBhbmQgY29sdW1uIGlzIGVxdWFscyB0byB0aGUgdmFsdWUgb2YgdmFyaWFibGUgJ2luZGV4JyBpbnRvIGFycmF5IHByZXZpZXdTY3JpYmJsZVBhdGhcclxuICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlQb2ludHNQcmV2aWV3LnB1c2godXBkYXRlZEZvY3VzQ0RBVEFbaW5kZXhdW2luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHVwZGF0ZWRGb2N1c0NEQVRBLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViUG9pbnRzID0gMDsgc3ViUG9pbnRzIDwgdXBkYXRlZEZvY3VzQ0RBVEFbaW5kZXhdW2luZGV4XS5sZW5ndGg7IHN1YlBvaW50cysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgdmFsdWUgb2Yga2V5IHggb2YgbXVsdGkgZGltZW50aW9uIGFycmF5IG9iamVjdCAnYWNjZXNzaWJpbGl0eVBvaW50c1ByZXZpZXcnIHdoZXJlIHJvdyBhbmQgY29sdW1uIHZhbHVlcyBhcmUgdmFsdWUgb2YgdmFyaWFibGUgJ2luZGV4JyBhbmQgJ3N1YlBvaW50cycgd2l0aCB0aGUgdmFsdWUgb2Yga2V5IHggb2YgbXVsdGkgZGltZW50aW9uIGFycmF5IHVwZGF0ZWRGb2N1c0NEQVRBIG9iamVjdCB3aGVyZSByb3cgYW5kIGNvbHVtbiB2YWx1ZXMgYXJlIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZXMgJ2luZGV4JyBhbmQgJ3N1YlBvaW50cydcclxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5UG9pbnRzUHJldmlld1tpbmRleF1bc3ViUG9pbnRzXS54ID0gdXBkYXRlZEZvY3VzQ0RBVEFbaW5kZXhdW2luZGV4XVtzdWJQb2ludHNdLng7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgdmFsdWUgb2Yga2V5IHkgb2YgbXVsdGkgZGltZW50aW9uIGFycmF5IG9iamVjdCAnYWNjZXNzaWJpbGl0eVBvaW50c1ByZXZpZXcnIHdoZXJlIHJvdyBhbmQgY29sdW1uIHZhbHVlcyBhcmUgdmFsdWUgb2YgdmFyaWFibGUgJ2luZGV4JyBhbmQgJ3N1YlBvaW50cycgd2l0aCB0aGUgdmFsdWUgb2Yga2V5IHkgb2YgbXVsdGkgZGltZW50aW9uIGFycmF5IG9iamVjdCB1cGRhdGVkRm9jdXNDREFUQSB3aGVyZSByb3cgYW5kIGNvbHVtbiB2YWx1ZXMgYXJlIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZXMgJ2luZGV4JyBhbmQgJ3N1YlBvaW50cydcclxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5UG9pbnRzUHJldmlld1tpbmRleF1bc3ViUG9pbnRzXS55ID0gdXBkYXRlZEZvY3VzQ0RBVEFbaW5kZXhdW2luZGV4XVtzdWJQb2ludHNdLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UgVVJJIGFuZCBxdWFsaWZpZWQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgJ2NpcmNsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICBzZXRQcmV2aWV3Q29sb3IoJyM4MDgwODAnLCBwcmV2aWV3VGhpY2tuZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnYXJpYS1sYWJlbGxlZGJ5JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdhcmlhLWxhYmVsbGVkYnknLCAnZm9jdXNQb2ludF8nICsgZm9jdXNQb2ludENvdW50UHJldmlldyArICdfdGl0bGUgZm9jdXNQb2ludF8nICsgZm9jdXNQb2ludENvdW50UHJldmlldyArICdfZGVzYycpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICd0YWJpbmRleCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndGFiaW5kZXgnLCAnMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdjbGFzcycgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCAnZm9jdXNQb2ludHMnKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZGF0YS1mb2N1c09yZGVyJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWZvY3VzT3JkZXInLCBmb2N1c1BvaW50Q291bnRQcmV2aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnY3gnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4JywgYWNjZXNzaWJpbGl0eVBvaW50c1ByZXZpZXdbaW5kZXhdW3N1YlBvaW50c10ueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2N5JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIGFjY2Vzc2liaWxpdHlQb2ludHNQcmV2aWV3W2luZGV4XVtzdWJQb2ludHNdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdyJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgJzJweCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIHRoZSBzY3JpYmJsZSBlbGVtZW50IGJlZm9yZSB2ZXJ5IGZpcnN0IGVsZW1lbnQgaW5zaWRlIHRoZSBlbGVtZW50IGhhdmUgY2xhc3MgJ2JhY2tncm91bmRGb2N1c1BvaW50UHJldmlldydcclxuICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJy5iYWNrZ3JvdW5kRm9jdXNQb2ludFByZXZpZXcnKS5hcHBlbmQoc2NyaWJibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgdGl0bGUgYW5kIGRlc2NyaXB0aW9uIG9mIGZvY3VzIHBvaW50IGZvciBzY3JlZW4gcmVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgQUguaW5zZXJ0KCcuYmFja2dyb3VuZEZvY3VzUG9pbnRQcmV2aWV3JywgJzx0aXRsZSBpZD1cImZvY3VzUG9pbnRfJyArIGZvY3VzUG9pbnRDb3VudFByZXZpZXcgKyAnX3RpdGxlXCI+WW91IGFyZSBvbiB0aGUgJyArIGZvY3VzUG9pbnRDb3VudFByZXZpZXcgKyAnIFBvaW50IDwvdGl0bGU+PGRlc2MgaWQ9XCJmb2N1c1BvaW50XycgKyBmb2N1c1BvaW50Q291bnRQcmV2aWV3ICsgJ19kZXNjXCI+UHJlc3Mgc2hpZnQgKyB0YWIgdG8gbW92ZSB0b3dhcmRzIHRoZSBwcmV2aW91cyBwb2ludCBvciB0YWIgdG8gbW92ZSB0b3dhcmRzIHRoZSBuZXh0IHBvaW50czwvZGVzYz4nLCAnYmVmb3JlZW5kJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSAnZm9jdXNQb2ludENvdW50UHJldmlldycgYnkgMVxyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzUG9pbnRDb3VudFByZXZpZXcrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGpvaW4gdGhlIG1hcmtlZCBwb2ludHMgYW5kIHNldHMgdGhlIGNvbG9yIGFuZCB3aWR0aCBvZiB0aGUgc3Ryb2tlIFxyXG4gICAgICAgICAgICAgICAgam9pbk1hcmtlZFBvaW50KGFjY2Vzc2liaWxpdHlQb2ludHNQcmV2aWV3W2luZGV4XSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHN0cm9rZSBjb2xvclxyXG4gICAgICAgICAgICBwcmV2aWV3Q29sb3IgPSBzdGF0ZS5saW5lQ29sb3I7XHJcbiAgICAgICAgICAgIC8vIG1ha2VzIGFycmF5IHByZXZpZXdTY3JpYmJsZVBhdGggYmxhbmsgZm9yIHJlbW92ZSB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGggPSBbXTtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgdHJ1ZSBvZiB0aGUgdmFyaWFibGUgaXNEcmF3Q29tcGFzc1ByZXZpZXdcclxuICAgICAgICAgICAgaXNEcmF3Q29tcGFzc1ByZXZpZXcgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBmYWxzZSBvZiB0aGUgdmFyaWFibGUgaXNTdG9yZVN0YXJ0XHJcbiAgICAgICAgICAgIGlzU3RvcmVTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSAwIG9mIHRoZSB2YXJpYWJsZSBpc0RyYXdTdG9wXHJcbiAgICAgICAgICAgIGlzRHJhd1N0b3AgPSAwO1xyXG4gICAgICAgICAgICAvLyBzaG93cyB0aGF0IGRyYXdpbmcgaXMgbm90IHN0YXJ0IHZpYSBrZXlib2FyZFxyXG4gICAgICAgICAgICBzdGFydERyYXdpbmdCeUtleSA9IDA7XHJcbiAgICAgICAgICAgIC8vIHNob3dzIG51bWJlciBvZiBkcmF3aW5nIHNrZXRjaGVkIHdpdGggdGhlIGhlbHAgb2YgZHJhd2luZyB0b29sc1xyXG4gICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGNvdW50cyB0aGUgbnVtYmVyIG9mIHVuZG8gY2FuIGJlIGRvbmVcclxuICAgICAgICAgICAgcHJldmlld1VuZG9Db3VudCA9IDA7XHJcbiAgICAgICAgICAgIC8vIG1ha2VzIGFycmF5IHByZXZpZXdVbmRvTGlzdCBibGFuayB0byByZW1vdmUgdGhlIGFsbCB1bmRvIGRvbmVcclxuICAgICAgICAgICAgcHJldmlld1VuZG9MaXN0ID0gW107XHJcbiAgICAgICAgICAgIC8vIG1ha2VzIGFycmF5IHByZXZpZXdSZWRvTGlzdCBibGFuayB0byByZW1vdmUgdGhlIGFsbCByZWRvIGRvbmVcclxuICAgICAgICAgICAgcHJldmlld1JlZG9MaXN0ID0gW107XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSAnaXNNYXJraW5nJyB0byAxXHJcbiAgICAgICAgICAgIGlzTWFya2luZyA9IDE7XHJcbiAgICAgICAgICAgIC8vIG1ha2VzIGFycmF5IG1hcmtQb2ludHMgYmxhbmsgdG8gcmVtb3ZlIHRoZSBtYXJrIHBvaW50XHJcbiAgICAgICAgICAgIG1hcmtQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGZyb20gdGhlIHN0cmluZyBleGlzdCBpbiBzdGF0ZSBhcnJheSBzZWxlY3RlZFRvb2xzIGF0IGluZGV4IDBcclxuICAgICAgICAgICAgcHJldmlld01vZGUgPSBzdGF0ZS5zZWxlY3RlZFRvb2xzWzBdLnN1YnN0cigtKHN0YXRlLnNlbGVjdGVkVG9vbHNbMF0ubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICBpZiAoZWRpdG9yU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgZHJhd2luZyBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzIGFuZCBtYXJrZWQgcG9pbnRzIGFuZCBhbHNvIGxpbmVzIHRoYXQgaXMgZHJhd24gYXV0b21hdGljYWxseSB1c2luZyBtYXJrIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcucHJldmlld01hcmtpbmdQYXRocyAuYW5zd2VyX21hcmssLnByZXZpZXdEcmF3aW5nUGF0aHMgcGF0aCcsICdyZW1vdmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldmlld01vZGUgPT0gJ2NvbXBhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaG93cyB0aGUgY29tcGFzcyB0b29sXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5kcmF3aW5nQ29tcGFzc1N2ZycsICdyZW1vdmVDbGFzcycsICdoJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSBjdXJzb3Igc3R5bGUgdG8gY3Jvc3NoYWlyICgrKVxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld1N2ZycsJ2NzcycsIHsnY3Vyc29yJzogJ2Nyb3NzaGFpcid9KTtcclxuICAgICAgICAgICAgICAgIC8vIGhpZGVzIGljb24gKCspIHVzZWQgZm9yIHNrZXRjaCB0aGUgZHJhd2luZyB1c2luZyBrZXlib2FyZFxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjbW92ZURyYXdJY29uJywnYWRkQ2xhc3MnLCdoJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBoaWRlcyB0aGUgY29tcGFzcyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5kcmF3aW5nQ29tcGFzc1N2ZycsICdhZGRDbGFzcycsICdoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZW5hYmxlZCB0aGUgYnV0dG9uIGhhdmUgaWQgbWFya19wb2ludHMgYW5kIHVwZGF0ZSBpdHMgdGV4dCB0byAnTWFyayBQb2ludHMnIFxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNtYXJrX3BvaW50cycpLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI21hcmtfcG9pbnRzJykuaW5uZXJUZXh0ID0gXCJNYXJrIFBvaW50c1wiO1xyXG5cclxuICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIHVuZG8sIHJlZG8gYW5kIGNsZWFyIHNjcmVlbiAoeCkgYnV0dG9uc1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3VuZG8nKS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdfcmVkbycpLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19jbGVhclNjcmVlbicpLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgZHJhd2luZyB0b29sIGJ1dHRvbnNcclxuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuZ2VvbWV0cnlUb29sUHJldmlldycsICdhZGRDbGFzcycsICdoJyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2xzSW5kZXggPSAwOyB0b29sc0luZGV4IDwgc3RhdGUuc2VsZWN0ZWRUb29scy5sZW5ndGg7IHRvb2xzSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvd3MgdGhlIGRyYXdpbmcgdG9vbHMgYnV0dG9ucyB0aGF0IGV4aXN0IGluIHN0YXRlIGFycmF5IHNlbGVjdGVkVG9vbHNcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXcnICsgc3RhdGUuc2VsZWN0ZWRUb29sc1t0b29sc0luZGV4XSwgJ3JlbW92ZUNsYXNzJywgJ2gnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGNsYXNzIGFjdGl2ZSBmcm9tIGRyYXdpbmcgdG9vbHMsIGRlbGV0ZSBhbmQgJ01hcmsgUG9pbnRzJyBidXR0b25zXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfYnRuLCNtYXJrX3BvaW50cycsJ3JlbW92ZUNsYXNzJywgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAvLyBhZGRzIHRoZSBjbGFzcyBhY3RpdmUgdG8gc2NyaWJibGUgZHJhd2luZyB0b29sIGJ1dHRvblxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3JyArIHN0YXRlLnNlbGVjdGVkVG9vbHNbMF0sICdhZGRDbGFzcycsICdhY3RpdmUnKTtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgd2lkdGggb2YgdGhlIGJhY2tncm91bmQgaW1hZ2UgY29udGFpbmVyXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfZHJhd2luZ190b29sYmFyLCAuY2VudGVySW1nUHJldmlldycsJ2F0dHInLCB7J3N0eWxlJyA6J3dpZHRoOicgKyAoTnVtYmVyKHN0YXRlLmltZ1dpZHRoKSArIDIpICsgJ3B4J30pO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB3aWR0aCwgc3JjIGFuZCBhbHQgbWVzc2FnZSBvZiB0aGUgYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJy5jZW50ZXJJbWcgI3N2Z0ltZ1ByZXZpZXcnLCAnYXR0cicsIHtcclxuICAgICAgICAgICAgICAgICdzcmMnOiBiZ0ltZ1BhdGggKyAnJyArIHN0YXRlLmJnSW1nLFxyXG4gICAgICAgICAgICAgICAgJ2FsdCc6IHN0YXRlLmFsdCxcclxuICAgICAgICAgICAgICAgICd3aWR0aCc6IHN0YXRlLmltZ1dpZHRoLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIEFILmVuYWJsZUJzQWxsKCcudG9vbHRpcF9idG4nLCAnVG9vbHRpcCcsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjonYm9keSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKHtcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgZnVuYzogJ3BhcnNlWE1MRm9yR2V0dGluZ0RhdGEgQDI3MSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGpvaW5zIHRoZSBtYXJrZWQgcG9pbnRzIGJ5IHRoZSBoZWxwIG9mIGxpbmUgdGhhdCBzdGFydHMgd2l0aCBmaXJzdCBtYXJrIHBvaW50IGFuZCBlbmRzIGF0IGxhc3QgbWFza2VkIHBvaW50IGJ5IG1vdmluZyBpbiBzZXF1ZW5jaWFsIG9yZGVyXHJcbiAgICBmdW5jdGlvbiBtYXJrRmluYWxQb2ludHMoKSB7XHJcbiAgICAgICAgLy8gaGlkZXMgdGhlIGNvbXBhc3MgY29udGFpbmVyXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcuZHJhd2luZ0NvbXBhc3NTdmcnLCAnYWRkQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIGNsYXNzICdlcmFzZXJIb3ZlcicgZnJvbSB0aGUgZWxlbWVudCAncGF0aCcgaW5zaWRlIHRoZSBlbGVtZW50IGhhdmUgaWQgJ3ByZXZpZXdTdmcnXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcjcHJldmlld1N2ZyBwYXRoJywgJ3JlbW92ZUNsYXNzJyAsICdlcmFzZXJIb3ZlcicpO1xyXG4gICAgICAgIGlmIChpc01hcmtpbmcpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgYWN0aXZlIGZyb20gdGhlIGRyYXdpbmcgdG9vbHMgYW5kIGRlbGV0ZSBidXR0b25zXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfYnRuJywncmVtb3ZlQ2xhc3MnLCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgdGV4dCBvZiB0aGUgYnV0dG9uICdNYXJrIFBvaW50cycgdG8gJ0ZpbmlzaCBNQXJraW5nJyBhbmQgYWRkcyBjbGFzcyBhY3RpdmUgdG8gaXRcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjbWFya19wb2ludHMnKS5pbm5lclRleHQgPSBcIkZpbmlzaCBNYXJraW5nXCI7XHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI21hcmtfcG9pbnRzJywgJ2FkZENsYXNzJywgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2lzTWFya2luZycgdG8gMFxyXG4gICAgICAgICAgICBpc01hcmtpbmcgPSAwO1xyXG4gICAgICAgICAgICAvLyByZW1vdmVzIHRoZSBtYXJrIHBvaW50cyBhbmQgbGluZXNcclxuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcucHJldmlld01hcmtpbmdQYXRocyAuYW5zd2VyX21hcmsnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgICAgIC8vIG1ha2VzIGFycmF5IHVzZXJNYXJraW5nUG9pbnQgdG8gZW1wdHlcclxuICAgICAgICAgICAgdXNlck1hcmtpbmdQb2ludCA9IFtdO1xyXG4gICAgICAgICAgICAvLyBtYWtlcyBhcnJheSBtYXJrUG9pbnRzIHRvIGVtcHR5XHJcbiAgICAgICAgICAgIG1hcmtQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCFlZGl0b3JTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY29ycmVjdCBhbnN3ZXIgY2lyY2xlIHRoYXQgY2FuIGJlIHNlZW4gb24gcmVtZWRpYXRpb24gbW9kZSBpbiBncmVlbiBzdHJva2UgY29sb3JcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmNvcnJlY3RfYW5zd2VyX2NvbnRhaW5lciAuYW5zd2VyX21hcmsnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0cyB2YWx1ZSBvZiB2YXJpYWJsZSAncHJldmlld01vZGUnIHRvICdtYXJrUG9pbnRzJ1xyXG4gICAgICAgICAgICBwcmV2aWV3TW9kZSA9ICdtYXJrUG9pbnRzJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzdGVzIHRoZSB0ZXN0IG9mIHRoZSBidXR0b24gJ0ZpbmlzaCBNYXJraW5nJyB0byAnTWFyayBQb2ludHMnIGFuZCBhZGRzIGNsYXNzIGFjdGl2ZSB0byBpdFxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNtYXJrX3BvaW50cycpLmlubmVyVGV4dCA9IFwiTWFyayBQb2ludHNcIjtcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjbWFya19wb2ludHMnLCAncmVtb3ZlQ2xhc3MnLCAnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIGlmIChtYXJrUG9pbnRzLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBqb2luIHRoZSBtYXJrZWQgcG9pbnRzIGFuZCBzZXRzIHRoZSBjb2xvciBhbmQgd2lkdGggb2YgdGhlIHN0cm9rZSBcclxuICAgICAgICAgICAgICAgIGpvaW5NYXJrZWRQb2ludChtYXJrUG9pbnRzKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZW1lZGlhdGlvbk1vZGUgPT0gJ29uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyB0aGUgYW5zd2VyIGFuZCB1cGRhdGVzIHRoZSBzdGF0dXMgYW5kIGVuYWJsZXMgJ01hcmsgUG9pbnRzJyBidXR0b24gYW5kIGFsc28gdXBkYXRlcyBpdHMgdGV4dCBhcyAnTWFyayBQb2ludHMnIFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlWE1MRm9yQW5zd2VyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29udGFpbnMgdGhlIHZhbHVlIG9mIGluZGV4IDAgb2Ygc3RhdGUgYXJyYXkgc2VsZWN0ZWRUb29scyBhZnRlciByZW1vdmluZyB0aGUgZmlyc3QgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHByZXZpZXdNb2RlID0gc3RhdGUuc2VsZWN0ZWRUb29sc1swXS5zdWJzdHIoLShzdGF0ZS5zZWxlY3RlZFRvb2xzWzBdLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgLy8gaGlkZXMgdGhlIGljb24gKCspIHVzZWQgdG8gc2tldGNoIHRoZSBkcmF3aW5nIGJ5IHRoZSBoZWxwIG9mIGtleWJvYXJkXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI21vdmVEcmF3SWNvbicsICdhZGRDbGFzcycsICdoJyk7XHJcbiAgICAgICAgICAgIC8vIHN0eWxlcyB0aGUgY3Vyc29yIHRvIGNyb3NzaGFpciAoKylcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld1N2ZycsICdjc3MnLCB7J2N1cnNvcic6ICdjcm9zc2hhaXInfSk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgdGhlIGFjdGl2ZSBjbGFzcyB0byB0aGUgZHJhd2luZyB0b29sIGV4aXN0IGF0IGluZGV4IDAgaW4gc3RhdGUgYXJyYXkgc2VsZWN0ZWRUb29sc1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3JyArIHN0YXRlLnNlbGVjdGVkVG9vbHNbMF0sICdhZGRDbGFzcycsICdhY3RpdmUnKTtcclxuICAgICAgICAgICAgaWYgKHByZXZpZXdNb2RlID09ICdjb21wYXNzJykge1xyXG4gICAgICAgICAgICAgICAgLy8gc2hvd3MgdGhlIGNvbXBhc3MgdG9vbFxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuZHJhd2luZ0NvbXBhc3NTdmcnLCAncmVtb3ZlQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gaGlkZXMgdGhlIGNvbXBhc3MgdG9vbFxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuZHJhd2luZ0NvbXBhc3NTdmcnLCAnYWRkQ2xhc3MnLCAnaCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSAnaXNNYXJraW5nJyB0byAxXHJcbiAgICAgICAgICAgIGlzTWFya2luZyA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGRyYXcgdGhlIG1hcmtlZCBwb2ludHMgYW5kIHRoZSBsaW5lcyBjb25uZWN0aW5nIHRvIHRoZXNlIHBvaW50c1xyXG4gICAgZnVuY3Rpb24gYWRkTWFya1BvaW50T25Mb2FkKGFycmF5KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGVzIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZSBVUkkgYW5kIHF1YWxpZmllZCBuYW1lLlxyXG4gICAgICAgICAgICBzY3JpYmJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgJ2NpcmNsZScpO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSBzdHJva2UgY29sb3IgYW5kIHdpZHRoXHJcbiAgICAgICAgICAgIHNldFByZXZpZXdDb2xvcihzdGF0ZS5tYXJrUG9pbnRDb2xvciwgcHJldmlld1RoaWNrbmVzcyk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdjbGFzcycgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgJ2Fuc3dlcl9tYXJrJyk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdjeCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4JywgYXJyYXlbaW5kZXhdLngpO1xyXG4gICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnY3knICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIGFycmF5W2luZGV4XS55KTtcclxuICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ3InICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgJzJweCcpO1xyXG4gICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBlbGVtZW50IHN0b3JlZCBpbnRvIHZhcmlhYmxlIHNjcmliYmxlIGluIG1hcmsgcG9pbnQgY29udGFpbmVyIGluIHdoaWNoIGRyYXdpbmdzIGFyZSBzdG9yZWQgZG9uZSBieSB0aGUgaGVscCBvZiAnTWFyayBQb2luJyBBbmQgJ0ZpbmlzaCBNYXJraW5nJyBidXR0b25zXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdNYXJraW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gam9pbiB0aGUgbWFya2VkIHBvaW50cyBhbmQgc2V0cyB0aGUgY29sb3IgYW5kIHdpZHRoIG9mIHRoZSBzdHJva2UgXHJcbiAgICAgICAgam9pbk1hcmtlZFBvaW50KGFycmF5KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1c2VkIHRvIGxvYWQgdGhlIG1vZHVsZSBhY2NvcmRpbmcgdG8gdGhlIGRhdGEgb2Ygc214bWwgYW5kIHNtYW5zIHhtbFxyXG4gICAgZnVuY3Rpb24gbG9hZE1vZHVsZSh1YVhNTCwgZHJhd01hcmspIHtcclxuICAgICAgICAvLyBjb250YWlucyB0aGUganNvbiBkYXRhIG9mIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgIHVhWE1MID0gWE1MVG9KU09OKHVhWE1MKTtcclxuICAgICAgICAvLyBjb250YWlucyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgcG9pbnRzIG1hcmtlZCBieSB1c2VyXHJcbiAgICAgICAgdXNlck1hcmtpbmdQb2ludCA9IEpTT04ucGFyc2UodWFYTUwuc21hbnMubWFya3BvaW50cyk7XHJcbiAgICAgICAgaWYgKHVhWE1MLnNtYW5zLnVzZXJEcmF3UGF0aCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdXNlckRhdGFQYXRoIHRvIGJsYW5rIHRoYXQgaW5kaWNhdGVzIHRoYXQgbm8gZHJhd2luZyBpcyBza2V0Y2hlZFxyXG4gICAgICAgICAgICB1YVhNTC5zbWFucy51c2VyRHJhd1BhdGggPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29udGFpbnMgZHJhd2luZyBkYXRhIHNrZXRjaGVkIGJ5IHRoZSBoZWxwIG9mIGRyYXdpbmcgdG9vbHMgaW4gdGhlIGZvcm0gb2YgamF2YXNjcmlwdCBvYmplY3QgXHJcbiAgICAgICAgdXNlckRyYXdQYXRoID0gSlNPTi5wYXJzZSh1YVhNTC5zbWFucy51c2VyRHJhd1BhdGgpO1xyXG4gICAgICAgIC8vIGRlZmluZXMgdGhlIHZhbHVlIHRydWUgb3IgZmFsc2Ugb2YgdGhlIHZhcmlhYmxlIHVzZXJBbnNDb3JyZWN0IGFjY29yZGluZyB0byB0aGUgdmFsdWUgb2YgYW5zQ29ycmVjdCBvZiB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICB1c2VyQW5zQ29ycmVjdCA9IHVhWE1MLnNtYW5zLmFuc0NvcnJlY3QudG9Mb3dlckNhc2UoKSA9PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgLy8gY29udGFpbnMganNvbiBkYXRhIG9mIHhtbCBwcm9wc1xyXG4gICAgICAgIGRlZmF1bHRYTUwgPSBYTUxUb0pTT04oeG1sKTtcclxuICAgICAgICAvLyBjb250YWlucyBjZGF0YSBvZiBkcmF3aW5nIG9mIHNteG1sIHRoYXQgaGF2ZSB0byBiZSBwZXJmb3JtZWQgYnkgdGhlIGhlbHAgb2YgZHJhd2luZyB0b29scyBmb3IgY29ycmVjdCBhbnN3ZXJcclxuICAgICAgICBjZGF0YSA9IGRlZmF1bHRYTUwuc214bWwuZGl2Ll9fY2RhdGE7XHJcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgY2hhcmFjdGVyICchJyB3aXRoICcsJyBmcm9tIGNkYXRhIGFuZCB3cmFwIGl0IGluIHNxdWFyZSBicmFja2V0XHJcbiAgICAgICAgY2RhdGEgPSAnWycgKyBjZGF0YS5yZXBsYWNlKC8hL2csICcsJykgKyAnXSc7XHJcbiAgICAgICAgLy8gY29udmVydHMgY2RhdGEgc3RyaW5nIGludG8gamF2YXNjcmlwdCBvYmplY3RcclxuICAgICAgICBjZGF0YSA9IEpTT04ucGFyc2UoY2RhdGEpO1xyXG4gICAgICAgIC8vIGRyYXcgdGhlIG1hcmtlZCBwb2ludHMgYW5kIHRoZSBsaW5lcyBjb25uZWN0aW5nIHRvIHRoZXNlIHBvaW50c1xyXG4gICAgICAgIGFkZE1hcmtQb2ludE9uTG9hZCh1c2VyTWFya2luZ1BvaW50KTtcclxuICAgICAgICAvLyBjcmVhdGVzIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHVzZXJcclxuICAgICAgICBjcmVhdGVVc2VyUGF0aCgpO1xyXG4gICAgICAgIC8vIGNoZWNrcyB0aGUgYW5zd2VyIGlzIGNvcnJlY3Qgb3IgaW5jb3JyZWN0XHJcbiAgICAgICAgY2hlY2tDb3JyZWN0QW5zd2VyKHVzZXJNYXJraW5nUG9pbnQsIGRyYXdNYXJrKTtcclxuICAgICAgICAvLyBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuc3dlciAoIGNvcnJlY3Qgb3IgaW5jb3JyZWN0IG1lc3NhZ2Ugd2l0aCBzaG93aW5nIHRoZSBVSSB0aGF0IGluZGljYXRlcyBjb3JyZWN0IG9yIGluY29ycmVjdClcclxuICAgICAgICBzZXRTdGF0dXNPZkFucyh1c2VyQW5zQ29ycmVjdCwgdXNlck1hcmtpbmdQb2ludCwgZHJhd01hcmspO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgY29weWluZyB0aGUgYXJyYXkgYW5kIG1vZGlmeWluZyB0aGVtXHJcbiAgICBmdW5jdGlvbiBhcnJheUNvcHkoYXJyYXkpIHtcclxuICAgICAgICAvLyBjcmVhdGVzIGEgdGVtcG9yYXJ5IGFycmF5XHJcbiAgICAgICAgbGV0IHRlbXBBcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgLy8gcHVzaGVzIGRlZmF1bHQgaW5pdGlhbGl6ZWQgb2JqZWN0IGludG8gYXJyYXkgdGVtcEFycmF5XHJcbiAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG1vZGU6IFwibW9kZVwiLFxyXG4gICAgICAgICAgICAgICAgb3JkZXI6IDIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNjcmliYmxlXzBcIixcclxuICAgICAgICAgICAgICAgIGluZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgZDogXCJwYXRoXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgb2YgbW9kZSBrZXkgb2YgYXJyYXkgdGVtcEFycmF5IGF0IGluZGV4IHNwZWNpZmllZCBpbiB2YXJpYWJsZSAnaW5kZXgnIHdpdGggdGhlIHZhbHVlIG9mIG1vZGUga2V5IG9mIGFycmF5IHBhc3NlZCBpbiBhcmd1bWVudCBhdCBpbmRleCBzcGVjaWZpZWQgaW4gdmFyaWFibGUgJ2luZGV4J1xyXG4gICAgICAgICAgICB0ZW1wQXJyYXlbaW5kZXhdLm1vZGUgPSBhcnJheVtpbmRleF0ubW9kZTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvZiBvcmRlciBrZXkgb2YgYXJyYXkgdGVtcEFycmF5IGF0IGluZGV4IHNwZWNpZmllZCBpbiB2YXJpYWJsZSAnaW5kZXgnIHdpdGggdGhlIHZhbHVlIG9mIG9yZGVyIGtleSBvZiBhcnJheSBwYXNzZWQgaW4gYXJndW1lbnQgYXQgaW5kZXggc3BlY2lmaWVkIGluIHZhcmlhYmxlICdpbmRleCdcclxuICAgICAgICAgICAgdGVtcEFycmF5W2luZGV4XS5vcmRlciA9IGFycmF5W2luZGV4XS5vcmRlcjtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvZiB0eXBlIGtleSBvZiBhcnJheSB0ZW1wQXJyYXkgYXQgaW5kZXggc3BlY2lmaWVkIGluIHZhcmlhYmxlICdpbmRleCcgd2l0aCB0aGUgdmFsdWUgb2YgdHlwZSBrZXkgb2YgYXJyYXkgcGFzc2VkIGluIGFyZ3VtZW50IGF0IGluZGV4IHNwZWNpZmllZCBpbiB2YXJpYWJsZSAnaW5kZXgnXHJcbiAgICAgICAgICAgIHRlbXBBcnJheVtpbmRleF0udHlwZSA9IGFycmF5W2luZGV4XS50eXBlO1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlIG9mIGluZGV4IGtleSBvZiBhcnJheSB0ZW1wQXJyYXkgYXQgaW5kZXggc3BlY2lmaWVkIGluIHZhcmlhYmxlICdpbmRleCcgd2l0aCB0aGUgdmFsdWUgb2YgaW5kZXgga2V5IG9mIGFycmF5IHBhc3NlZCBpbiBhcmd1bWVudCBhdCBpbmRleCBzcGVjaWZpZWQgaW4gdmFyaWFibGUgJ2luZGV4J1xyXG4gICAgICAgICAgICB0ZW1wQXJyYXlbaW5kZXhdLmluZGV4ID0gYXJyYXlbaW5kZXhdLmluZGV4O1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlIG9mIGQga2V5IG9mIGFycmF5IHRlbXBBcnJheSBhdCBpbmRleCBzcGVjaWZpZWQgaW4gdmFyaWFibGUgJ2luZGV4JyB3aXRoIHRoZSB2YWx1ZSBvZiBkIGtleSBvZiBhcnJheSBwYXNzZWQgaW4gYXJndW1lbnQgYXQgaW5kZXggc3BlY2lmaWVkIGluIHZhcmlhYmxlICdpbmRleCdcclxuICAgICAgICAgICAgdGVtcEFycmF5W2luZGV4XS5kID0gYXJyYXlbaW5kZXhdLmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHVucyBhcnJheSBhZnRlciBjb3BpZWQgZGF0YSBmcm9tIGFycmF5IHBhc3NlZCBpbiBhcmd1bWVudHNcclxuICAgICAgICByZXR1cm4gdGVtcEFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZXMgZHJhd2luZyBvbiB3aGljaCBrZXl1cCBldmVudCB0cmlnZ2VyZWQgYW5kIHVwZGF0ZSB0aGUgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICBmdW5jdGlvbiBlcmFzZXIoY3VyQ2xhc3MsIGN1ckFycmF5KSB7XHJcbiAgICAgICAgaWYgKEFILnNlbGVjdChjdXJDbGFzcykuZ2V0QXR0cmlidXRlKFwiZGF0YS1vcmRlclwiKSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gbWFrZXMgYXJyYXkgcHJldmlld1VuZG9MaXN0IGJsYW5rXHJcbiAgICAgICAgICAgIHByZXZpZXdVbmRvTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAvLyBhIHRlbXBvcmFyeSB2YXJpYWJsZSB1c2VkIG9mIFxyXG4gICAgICAgICAgICBsZXQgdGVtcEFycmF5Q29udGFpbmVyID0gJyc7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBkcmF3aW5nIG9uIHdoaWNoIGtleXVwIGV2ZW50IGZpcmVkIGV4aXN0IGluIGFycmF5IGN1ckFycmF5XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSBjdXJBcnJheS5pbmRleE9mKGN1ckFycmF5W0FILnNlbGVjdChjdXJDbGFzcykuZ2V0QXR0cmlidXRlKFwiZGF0YS1vcmRlclwiKV0pO1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyBjdXJyZW50IGVsZW1lbnQgZnJvbSBhcnJheSBjdXJBcnJheSBhZnRlciBjb252ZXJ0aW5nIGl0IGludG8gc3RyaW5nIGFuZCB3cmFwaW5nIGluIHNxdWFyZSBicmFja2V0XHJcbiAgICAgICAgICAgIGxldCBjb252ZXJ0SlNPTnRvQXJyYXkgPSAnWycgKyBKU09OLnN0cmluZ2lmeShjdXJBcnJheVtjdXJyZW50SW5kZXhdKSArICddJztcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgY29weSBvZiBhcnJheSBjb252ZXJ0SlNPTnRvQXJyYXlcclxuICAgICAgICAgICAgdGVtcEFycmF5Q29udGFpbmVyID0gYXJyYXlDb3B5KEpTT04ucGFyc2UoY29udmVydEpTT050b0FycmF5KSk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgdGhlIHZhbHVlIHJlbW92ZSBvZiBtb2RlIGtleSBleGlzdCBhdCBpbmRleCAwIGluIGFycmF5IHRlbXBBcnJheUNvbnRhaW5lclxyXG4gICAgICAgICAgICB0ZW1wQXJyYXlDb250YWluZXJbMF0ubW9kZSA9IFwicmVtb3ZlXCI7XHJcbiAgICAgICAgICAgIC8vIHB1c2hlcyB0aGUgZGF0YSBvZiBhcnJheSAndGVtcEFycmF5Q29udGFpbmVyJyBleGlzdCBvbiBpbmRleCAwIGludG8gYXJyYXkgY3VyQXJyYXlcclxuICAgICAgICAgICAgY3VyQXJyYXkucHVzaCh0ZW1wQXJyYXlDb250YWluZXJbMF0pO1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyBjb3B5IG9mIGFycmF5IGN1ckFycmF5XHJcbiAgICAgICAgICAgIGxldCBlcmFzZXJBcnJheUNvbnRhaW5lciA9IGFycmF5Q29weShjdXJBcnJheSk7XHJcbiAgICAgICAgICAgIC8vIHN0b3JlcyB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB1c2VyIGFuZCBzZXRzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgc3RvcmVVc2VyUGF0aHMoZXJhc2VyQXJyYXlDb250YWluZXIpO1xyXG4gICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBieSAxXHJcbiAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZUNvdW50Kys7XHJcbiAgICAgICAgICAgIC8vIGluY3JlYXNlcyB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHByZXZpZXdVbmRvQ291bnQgYnkgMVxyXG4gICAgICAgICAgICBwcmV2aWV3VW5kb0NvdW50Kys7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBvbiB3aGljaCBrZXl1cCBldmVudCBmaXJlZFxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoY3VyQ2xhc3MsICdyZW1vdmUnKTtcclxuICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIHJlZG8gYnV0dG9uXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdfcmVkbycpLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gZW5hYmxlcyB1bmRvIGJ1dHRvblxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3VuZG8nKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoQUguc2VsZWN0QWxsKCcucHJldmlld0RyYXdpbmdQYXRocyBwYXRoJykubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIHRoZSBjbGVhciBzY3JlZW4gYnV0dG9uICh4KVxyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19jbGVhclNjcmVlbicpLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzdG9yZXMgdGhlIGRyYXdpbmcgc2tldGNoZWQgYnkgdXNlciBhbmQgc2V0cyB0aGUgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICBmdW5jdGlvbiBzdG9yZVVzZXJQYXRocyhkcmF3UGF0aEFycmF5KSB7XHJcbiAgICAgICAgLy8gbWFrZXMgYXJyYXkgdXNlckFuc1BhdGggYmxhbmtcclxuICAgICAgICB1c2VyQW5zUGF0aCA9IFtdO1xyXG4gICAgICAgIC8vIGNyZWF0ZXMgdGhlIHZhcmlhYmxlIHN1YmluZGV4IGFuZCBhc3NpZ24gdGhlIHZhbHVlIDBcclxuICAgICAgICBsZXQgc3ViaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkcmF3UGF0aEFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBzdWJpbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgd2hpbGUgKHN1YmluZGV4IDwgZHJhd1BhdGhBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcmF3UGF0aEFycmF5W2luZGV4XS50eXBlID09IGRyYXdQYXRoQXJyYXlbc3ViaW5kZXhdLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhd1BhdGhBcnJheVtpbmRleF0ubW9kZSA9PSBcImFkZFwiICYmIGRyYXdQYXRoQXJyYXlbc3ViaW5kZXhdLm1vZGUgPT0gXCJyZW1vdmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBudWxsIG9mIG1vZGUga2V5IG9mIGFycmF5IGRyYXdQYXRoQXJyYXkgaGF2ZSBpbmRleCBkZWZpbmVkIGluIHZhcmlhYmxlICdpbmRleCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1BhdGhBcnJheVtpbmRleF0ubW9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG51bGwgb2YgbW9kZSBrZXkgb2YgYXJyYXkgZHJhd1BhdGhBcnJheSBoYXZlIGluZGV4IGRlZmluZWQgaW4gdmFyaWFibGUgJ3N1YmluZGV4J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3UGF0aEFycmF5W3N1YmluZGV4XS5tb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBzdWJpbmRleCBieSAxXHJcbiAgICAgICAgICAgICAgICBzdWJpbmRleCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkcmF3UGF0aEFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSB2YWx1ZXMgaW4gdGhlIGRyYXdQYXRoQXJyYXkgYXJyYXkgd2hvc2UgdmFsdWUgb2YgbW9kZSBrZXkgaXMgbm90IG51bGxcclxuICAgICAgICAgICAgZHJhd1BhdGhBcnJheSA9IGRyYXdQYXRoQXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5tb2RlICE9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwdXNoZXMgZGF0YSBvZiBhcnJheSBkcmF3UGF0aEFycmF5IGludG8gYXJyYXkgdXNlckFuc1BhdGhcclxuICAgICAgICB1c2VyQW5zUGF0aC5wdXNoKGRyYXdQYXRoQXJyYXkpO1xyXG4gICAgICAgIC8vIHVwZGF0ZXMgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICAgICAgY3JlYXRlVVhNTCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZXMgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVVWE1MKCkge1xyXG4gICAgICAgIC8vIG1ha2VzIGFycmF5IG1hcmtQb2ludHNEYXRhIGVtcHR5XHJcbiAgICAgICAgbWFya1BvaW50c0RhdGEgPSBbXTtcclxuICAgICAgICBpZiAobWFya1BvaW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgcG9pbnRzIG1hcmtlZCBieSB1c2VyXHJcbiAgICAgICAgICAgIG1hcmtQb2ludHNEYXRhID0gSlNPTi5zdHJpbmdpZnkodXNlck1hcmtpbmdQb2ludClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgcG9pbnRzIG1hcmtlZCBieSB1c2VyXHJcbiAgICAgICAgICAgIG1hcmtQb2ludHNEYXRhID0gSlNPTi5zdHJpbmdpZnkobWFya1BvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnRhaW5zIHByb2Zvcm1hIG9mIHVzZXIgYW5zd2VyIHhtbCB3aXRoIHBvaW50cyBtYXJrZWQgYnkgdXNlciwgZHJhd2luZyBza2V0Y2hlZCBieSB1c2VyIGFuZCBzdGF0ZSBvZiBhbnN3ZXIgIFxyXG4gICAgICAgIHVzZXJBbnNYTUwgPSAnPHNtYW5zIHR5cGU9XCI0MVwiPjxtYXJrcG9pbnRzPicgKyBtYXJrUG9pbnRzRGF0YSArICc8L21hcmtwb2ludHM+PHVzZXJEcmF3UGF0aD4nICsgSlNPTi5zdHJpbmdpZnkodXNlckFuc1BhdGhbMF0pICsgJzwvdXNlckRyYXdQYXRoPjxhbnNDb3JyZWN0PicgKyBpc0Fuc3dlckNvcnJlY3QgKyAnPC9hbnNDb3JyZWN0Pjwvc21hbnM+JztcclxuICAgICAgICAvLyBkZWZpbmVkIHRoYXQgdXNlciBhbnN3ZXIgeG1sIGNoYW5nZWRcclxuICAgICAgICB3aW5kb3cuSVNTUEVDSUFMTU9EVUxFVVNFUlhNTENIQU5HRSA9IDE7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICAgICAgQUguc2VsZWN0KFwiI3NwZWNpYWxfbW9kdWxlX3VzZXJfeG1sXCIsICd2YWx1ZScsIHVzZXJBbnNYTUwpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBjcmVhdGVzIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHVzZXJcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVzZXJQYXRoKCkge1xyXG4gICAgICAgIGlmICh1c2VyRHJhd1BhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIGVuYWJsZXMgdGhlIGNyb3NzIGFuZCB1bmRvIGJ1dHRvbnMgXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdfdW5kbycpLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdfdW5kbycpLmRpc2FibGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdXNlckRyYXdQYXRoLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB0eXBlIGtleSB2YWx1ZSBvZiB0aGUgb2JqZWN0IGV4aXN0IGF0IGluZGV4IGRlZmluZWQgaW4gdmFyaWFibGUgJ2luZGV4JyBvZiBhcnJheSB1c2VyRHJhd1BhdGggYnkgYWRkaW5nIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSAnaW5kZXgnIGluIGl0cyBwcmV2aW91cyB2YWx1ZVxyXG4gICAgICAgICAgICB1c2VyRHJhd1BhdGhbaW5kZXhdLnR5cGUgPSB1c2VyRHJhd1BhdGhbaW5kZXhdLnR5cGUuc3Vic3RyKDAsIHVzZXJEcmF3UGF0aFtpbmRleF0udHlwZS5pbmRleE9mKCdfJykpICsgJ18nICsgaW5kZXg7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIG9yZGVyIGtleSB2YWx1ZSBvZiB0aGUgb2JqZWN0IGV4aXN0IGF0IGluZGV4IGRlZmluZWQgaW4gdmFyaWFibGUgJ2luZGV4JyBvZiBhcnJheSB1c2VyRHJhd1BhdGggYnkgYWRkaW5nIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSAnaW5kZXgnXHJcbiAgICAgICAgICAgIHVzZXJEcmF3UGF0aFtpbmRleF0ub3JkZXIgPSBpbmRleDtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlcyBhbiBlbGVtZW50IHdpdGggdGhlIHZhbHVlIG9mIHZhcmlhYmxlIHhtbG5zIG5hbWVzcGFjZSBVUkkgYW5kICdwYXRoJyBuYW1lXHJcbiAgICAgICAgICAgIHNjcmliYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAncGF0aCcpO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSBzdHJva2UgY29sb3IgYW5kIHdpZHRoXHJcbiAgICAgICAgICAgIHNldFByZXZpZXdDb2xvcihwcmV2aWV3Q29sb3IsIHByZXZpZXdUaGlja25lc3MpO1xyXG4gICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnZGF0YS10eXBlJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS10eXBlJywgdXNlckRyYXdQYXRoW2luZGV4XS50eXBlKTtcclxuICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2RhdGEtb3JkZXInICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLW9yZGVyJywgdXNlckRyYXdQYXRoW2luZGV4XS5vcmRlcik7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHVzZXJEcmF3UGF0aFtpbmRleF0uZCk7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICd0YWJpbmRleCcgKHdpdGggYSBuYW1lc3BhY2UgbnVsbClcclxuICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RhYmluZGV4JywgJzAnKTtcclxuICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgZWxlbWVudCBzdG9yZWQgaW50byB2YXJpYWJsZSBzY3JpYmJsZSBpbiBkcmF3aW5nIGNvbnRhaW5lciBpbiB3aGljaCBkcmF3aW5ncyBhcmUgc3RvcmVkIHNrZXRjaGVkIGJ5IHRoZSBoZWxwIG9mIGRyYXdpbmcgdG9vbHNcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcucHJldmlld0RyYXdpbmdQYXRocycpLnByZXBlbmQoc2NyaWJibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ3ByZXZpZXdTY3JpYmJsZUNvdW50JyB0byAgdGhlIHZhbHVlIG9mIGxlbmd0aCBvZiB0aGUgYXJyYXkgJ3VzZXJEcmF3UGF0aCdcclxuICAgICAgICBwcmV2aWV3U2NyaWJibGVDb3VudCA9IHVzZXJEcmF3UGF0aC5sZW5ndGg7XHJcbiAgICAgICAgLy8gY29udGFpbnMgY29weSBvZiBhcnJheSB1c2VyRHJhd1BhdGhcclxuICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoID0gYXJyYXlDb3B5KHVzZXJEcmF3UGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gam9pbiB0aGUgbWFya2VkIHBvaW50cyBhbmQgc2V0cyB0aGUgY29sb3IgYW5kIHdpZHRoIG9mIHRoZSBzdHJva2UgXHJcbiAgICBmdW5jdGlvbiBqb2luTWFya2VkUG9pbnQobWFya0FycmF5LCBmb2N1c1BvaW50KSB7XHJcbiAgICAgICAgaWYgKG1hcmtBcnJheS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZXMgYW4gZWxlbWVudCB3aXRoIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSB4bWxucyBuYW1lc3BhY2UgVVJJIGFuZCAncGF0aCcgbmFtZVxyXG4gICAgICAgIHNjcmliYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAncGF0aCcpO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSBkcmF3aW5nXHJcbiAgICAgICAgbGV0IHBvaW50U3RhcnRWYWx1ZXMgPSAnTSAnICsgbWFya0FycmF5WzBdLnggKyAnICcgKyBtYXJrQXJyYXlbMF0ueTtcclxuICAgICAgICAvLyB2YXJpYWJsZSBmb3IgZW5kIHBvaW50XHJcbiAgICAgICAgbGV0IHBvaW50RW5kVmFsdWVzID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IG1hcmtBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgLy8gYWRkcyB0aGUgdmFsdWUgb2YgeCBhbmQgeSBpbnRvIHByZXZpb3VzIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBwb2ludEVuZFZhbHVlcyBmcm9tIHRoZSBhcnJheSAnbWFya0FycmF5JyBhdCBpbmRleCBkZWZpbmVkIGluIHZhcmlhYmxlICdpbmRleCdcclxuICAgICAgICAgICAgcG9pbnRFbmRWYWx1ZXMgKz0gJyBMICcgKyBtYXJrQXJyYXlbaW5kZXhdLnggKyAnICcgKyBtYXJrQXJyYXlbaW5kZXhdLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcG9pbnRTdGFydFZhbHVlcyArICcnICsgcG9pbnRFbmRWYWx1ZXMpO1xyXG4gICAgICAgIGlmIChmb2N1c1BvaW50KSB7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgc2V0UHJldmlld0NvbG9yKCdyZ2IoMTI4LCAxMjgsIDEyOCknLCBwcmV2aWV3VGhpY2tuZXNzKTtcclxuICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgZWxlbWVudCBhc3NpZ25lZCBpbnRvIHZhcmlhYmxlICdzY3JpYmJsZScgaW4gYmFja2dyb3VuZCBmb2N1cyBjb250YWluZXIgZWxlbWVudFxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJy5iYWNrZ3JvdW5kRm9jdXNQYXRoUHJldmlldycpLnByZXBlbmQoc2NyaWJibGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgc2V0UHJldmlld0NvbG9yKHN0YXRlLm1hcmtQb2ludENvbG9yLCBwcmV2aWV3VGhpY2tuZXNzKTtcclxuICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2NsYXNzJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCAnYW5zd2VyX21hcmsnKTtcclxuICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgZWxlbWVudCBzdG9yZWQgaW50byB2YXJpYWJsZSBzY3JpYmJsZSBpbiBtYXJrIHBvaW50IGNvbnRhaW5lciBpbiB3aGljaCBkcmF3aW5ncyBhcmUgc3RvcmVkIGRvbmUgYnkgdGhlIGhlbHAgb2YgJ01hcmsgUG9pbicgQW5kICdGaW5pc2ggTWFya2luZycgYnV0dG9uc1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJy5wcmV2aWV3TWFya2luZ1BhdGhzJykucHJlcGVuZChzY3JpYmJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoZWNrcyB0aGUgYW5zd2VyIGFuZCB1cGRhdGVzIHRoZSBzdGF0dXMgYW5kIGVuYWJsZXMgJ01hcmsgUG9pbnRzJyBidXR0b24gYW5kIGFsc28gdXBkYXRlcyBpdHMgdGV4dCBhcyAnTWFyayBQb2ludHMnIFxyXG4gICAgZnVuY3Rpb24gcGFyc2VYTUxGb3JBbnN3ZXIoZHJhd01hcmspIHtcclxuICAgICAgICAvLyBjb250YWlucyB0aGUganNvbiBkYXRhIG9mIHRoZSB4bWwgb2YgcHJvcHNcclxuICAgICAgICBkZWZhdWx0WE1MID0gWE1MVG9KU09OKHN0YXRlLnhtbCk7XHJcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHZhbHVlIG9mIGNkYXRhIGluc2lkZSBkaXYgb2Ygc214bWxcclxuICAgICAgICBjZGF0YSA9IGRlZmF1bHRYTUwuc214bWwuZGl2Ll9fY2RhdGE7XHJcbiAgICAgICAgLy8gcmVwbGFjZXMgdGhlIGNoYXJhY3RlciAnIScgd2l0aCAnLCcgYW5kIHdyYXBzIGluIHNxdWFyZSBicmFja2V0IG9mIHRoZSB2YWx1ZSBvZiBjZGF0YSB2YXJpYWJsZVxyXG4gICAgICAgIGNkYXRhID0gJ1snICsgY2RhdGEucmVwbGFjZSgvIS9nLCAnLCcpICsgJ10nO1xyXG4gICAgICAgIC8vIHBhcnNlcyB0aGUgY2RhdGEgc3RyaW5nIHZhbHVlIGludG8gamF2YXNjcmlwdCBvYmplY3RcclxuICAgICAgICBjZGF0YSA9IEpTT04ucGFyc2UoY2RhdGEpO1xyXG4gICAgICAgIC8vIGNyZWF0ZXMgYW4gYXJyYXkgbWFya1BvaW50c0Fuc0RhdGFcclxuICAgICAgICBsZXQgbWFya1BvaW50c0Fuc0RhdGEgPSBbXTtcclxuICAgICAgICAvLyBhc3NpZ24gdGhlIHZhbHVlIG9mIGFycmF5IG1hcmtQb2ludHMgaW50byBhcnJheSBtYXJrUG9pbnRzQW5zRGF0YVxyXG4gICAgICAgIG1hcmtQb2ludHNBbnNEYXRhID0gbWFya1BvaW50cztcclxuICAgICAgICBpZiAoIWVkaXRvclN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh1eG1sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya1BvaW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB4IGFuZCB5IGNvLW9yZGluYXRlIG9mIHRoZSBwb2ludHMgbWFya2VkIGJ5IHVzZXJcclxuICAgICAgICAgICAgICAgICAgICBtYXJrUG9pbnRzQW5zRGF0YSA9IHVzZXJNYXJraW5nUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2tzIHRoZSBhbnN3ZXIgaXMgY29ycmVjdCBvciBpbmNvcnJlY3RcclxuICAgICAgICBjaGVja0NvcnJlY3RBbnN3ZXIobWFya1BvaW50c0Fuc0RhdGEsIGRyYXdNYXJrKTtcclxuICAgICAgICAvLyBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuc3dlciAoIGNvcnJlY3Qgb3IgaW5jb3JyZWN0IG1lc3NhZ2Ugd2l0aCBzaG93aW5nIHRoZSBVSSB0aGF0IGluZGljYXRlcyBjb3JyZWN0IG9yIGluY29ycmVjdClcclxuICAgICAgICBzZXRTdGF0dXNPZkFucyhpc0Fuc3dlckNvcnJlY3QsIG1hcmtQb2ludHNBbnNEYXRhLCBkcmF3TWFyayk7XHJcbiAgICAgICAgaWYgKGRyYXdNYXJrKSB7XHJcbiAgICAgICAgICAgIC8vIGVuYWJsZXMgdGhlIGVsZW1lbnQgaGF2ZSBpZCBtYXJrX3BvaW50cyBhbmQgdXBkYXRlcyBpdHMgdGV4dCBhcyAnTWFyayBQb2ludHMnXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI21hcmtfcG9pbnRzJykuaW5uZXJUZXh0ID0gJ01hcmsgUG9pbnRzJztcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjbWFya19wb2ludHMnKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2lzTWFya2luZycgdG8gMVxyXG4gICAgICAgICAgICBpc01hcmtpbmcgPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzdG9yZXMgdGhlIGRyYXdpbmcgc2tldGNoZWQgYnkgdXNlciB1c2luZyBrZXlib2FyZCBhbmQgc2V0cyB0aGUgdXNlciBhbnN3ZXIgeG1sXHJcbiAgICBmdW5jdGlvbiBzdG9yZUNvbXBhc3NQYXRoQnlLZXkoKSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgY2xhc3MgbGFzdENpcmNsZV9ob3ZlciBmcm9tIHRoZSBsYXN0IGNpcmNsZSB0aGF0IGV4aXN0IG9uIHJvdGF0aW9uIGJhciBvZiB0aGUgY29tcGFzc1xyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGUnLCAncmVtb3ZlQ2xhc3MnLCAnbGFzdENpcmNsZV9ob3ZlcicpO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIHN0eWxlIG9mIHRoZSBjdXJzb3IgdG8gZ3JhYiB3aGVuIGN1cnNvciBsaWVzIGluc2lkZSBsYXN0IGNpcmNsZVxyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGUnLCAnY3NzJywgeydjdXJzb3InOiAnZ3JhYid9KTtcclxuICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSB0cnVlIG9mIHZhcmlhYmxlIGlzRHJhd0NvbXBhc3NQcmV2aWV3XHJcbiAgICAgICAgaXNEcmF3Q29tcGFzc1ByZXZpZXcgPSB0cnVlO1xyXG4gICAgICAgIGlmIChwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kLmluZGV4T2YoJ0wnKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmVzIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoLnBvcCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgKyAnIEwnICsgbGFzdENpcmNsZV9jeCArICcgJyArIGxhc3RDaXJjbGVfY3kpO1xyXG4gICAgICAgICAgICAvLyBhZGRzIHZhbHVlIG9mIHZhcmlhYmxlcyBsYXN0Q2lyY2xlX2N4IGFuZCBsYXN0Q2lyY2xlX2N5IHNlcGFyYXRlZCBieSBzcGFjZSB3aXRoIHByZWZpeCAnTCcgaW4gdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBrZXkgJ2QnIGF0IGluZGV4IHNwZWNpZmllZCBpbiB0aGUgdmFyaWFibGUgcHJldmlld1NjcmliYmxlQ291bnQgb2YgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kID0gcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCArICcgTCcgKyBsYXN0Q2lyY2xlX2N4ICsgJyAnICsgbGFzdENpcmNsZV9jeTtcclxuICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgZWxlbWVudCBzdG9yZWQgaW50byB2YXJpYWJsZSBzY3JpYmJsZSBpbiBkcmF3aW5nIGNvbnRhaW5lciBpbiB3aGljaCBkcmF3aW5ncyBhcmUgc3RvcmVkIHNrZXRjaGVkIGJ5IHRoZSBoZWxwIG9mIGRyYXdpbmcgdG9vbHMgXHJcbiAgICAgICAgICAgIEFILnNlbGVjdCgnLnByZXZpZXdEcmF3aW5nUGF0aHMnKS5wcmVwZW5kKHNjcmliYmxlKTtcclxuICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBieSAxXHJcbiAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZUNvdW50Kys7XHJcbiAgICAgICAgICAgIC8vIGluY3JlYXNlcyB0aGUgdmFsdWUgb2YgdmFyaWFibGUgcHJldmlld1VuZG9Db3VudCBieSAxXHJcbiAgICAgICAgICAgIHByZXZpZXdVbmRvQ291bnQrKztcclxuICAgICAgICAgICAgLy8gbWFrZXMgYXJyYXkgcHJldmlld1VuZG9MaXN0IGJsYW5rIFxyXG4gICAgICAgICAgICBwcmV2aWV3VW5kb0xpc3QgPSBbXTtcclxuICAgICAgICAgICAgLy8gZW5hYmxlcyB0aGUgY3Jvc3MgKHgpIGFuZCB1bmRvIGJ1dHRvblxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3VuZG8nKS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X2NsZWFyU2NyZWVuJykuZGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGRpc2FibGVkIHRoZSByZWRvIGJ1dHRvblxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3JlZG8nKS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnRhaW5zIGNvcHkgb2YgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgIGxldCB0ZW1wQXJyYXlDb250YWluZXIgPSBhcnJheUNvcHkocHJldmlld1NjcmliYmxlUGF0aCk7XHJcbiAgICAgICAgLy8gc3RvcmVzIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHVzZXIgYW5kIHNldHMgdGhlIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgIHN0b3JlVXNlclBhdGhzKHRlbXBBcnJheUNvbnRhaW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlcyB0aGUgYWxsIG1hcmsgcG9pbnRzIGFuZCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2lzTUFya2luZycgdG8gMVxyXG4gICAgZnVuY3Rpb24gY2xlYXJNYXJraW5nKCkge1xyXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIG1hcmsgcG9pbnRzIGFuZCBsaW5lcyBcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJy5wcmV2aWV3TWFya2luZ1BhdGhzIC5hbnN3ZXJfbWFyaycsICdyZW1vdmUnKTtcclxuICAgICAgICBpZiAoIWVkaXRvclN0YXRlKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGNvcnJlY3QgYW5zd2VyIGNpcmNsZSB0aGF0IGNhbiBiZSBzZWVuIG9uIHJlbWVkaWF0aW9uIG1vZGUgaW4gZ3JlZW4gc3Ryb2tlIGNvbG9yXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmNvcnJlY3RfYW5zd2VyX2NvbnRhaW5lciAuYW5zd2VyX21hcmsnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1ha2VzIGFycmF5IG1hcmtQb2ludHMgZW1wdHlcclxuICAgICAgICBtYXJrUG9pbnRzID0gW107XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdGV4dCAnTWFyayBQb2ludHMnIG9mIHRoZSBlbGVtZW50IGhhdmluZyBpZCAnbWFya19wb2ludHMnIGFuZCBlbmFibGVkIHRoYXQgZWxlbWVudFxyXG4gICAgICAgIEFILnNlbGVjdCgnI21hcmtfcG9pbnRzJykuaW5uZXJUZXh0ID0gJ01hcmsgUG9pbnRzJztcclxuICAgICAgICBBSC5zZWxlY3QoJyNtYXJrX3BvaW50cycpLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdmFyaWFibGUgaXNNQXJraW5nIHRvIDEgdGhhdCBpbmRpY2F0ZXMgdGhhdCBtYXJrIGNhbiBiZSBkcmF3XHJcbiAgICAgICAgaXNNYXJraW5nID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVja3MgdGhlIGFuc3dlciBpcyBjb3JyZWN0IG9yIGluY29ycmVjdFxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb3JyZWN0QW5zd2VyKG1hcmtBcnJheSwgZHJhd01hcmspIHtcclxuICAgICAgICAvLyBjcmVhdGVzIGNvcnJlY3RBbnN3ZXIgYXJyYXlcclxuICAgICAgICBsZXQgY29ycmVjdEFuc3dlciA9IFtdO1xyXG4gICAgICAgIGlmIChkcmF3TWFyaykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2RhdGEubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZSBVUkkgYW5kIHF1YWxpZmllZCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgc2NyaWJibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMsICdjaXJjbGUnKTtcclxuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgICAgIHNldFByZXZpZXdDb2xvcignIzBGOUQ1OCcsICcyJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGEgbmV3IGF0dHJpYnV0ZSAnY2xhc3MnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCAnYW5zd2VyX21hcmsgYW5zd2VyX2NpcmNsZScpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2N4JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4JywgY2RhdGFbaW5kZXhdLngpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2N5JyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5JywgY2RhdGFbaW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ3InICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICBzY3JpYmJsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsIGNkYXRhW2luZGV4XS5yKTtcclxuICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIGNyZWF0ZWQgZWxlbWVudCB3aXRoIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSAneG1sbnMnIG5hbWVzcGFjZSBVUkkgYW5kIGNpcmNsZSBuYW1lIGluIGVsZW1lbnQgaGF2ZSBjbGFzcyAnY29ycmVjdF9hbnN3ZXJfY29udGFpbmVyJ1xyXG4gICAgICAgICAgICAgICAgQUguc2VsZWN0KCcuY29ycmVjdF9hbnN3ZXJfY29udGFpbmVyJykucHJlcGVuZChzY3JpYmJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNkYXRhLmxlbmd0aCA9PSAwIHx8IG1hcmtBcnJheS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSAnaXNBbnN3ZXJDb3JyZWN0JyB0byBmYWxzZVxyXG4gICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgJ2xpbmVDb3VudCcgYWNjb3JkaW5nIHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG1hcmtBcnJheVxyXG4gICAgICAgIGxldCBsaW5lQ291bnQgPSAobWFya0FycmF5Lmxlbmd0aCA9PSAxKSA/IG1hcmtBcnJheS5sZW5ndGggOiBtYXJrQXJyYXkubGVuZ3RoIC0gMTtcclxuICAgICAgICBmb3IgKGxldCBjZGF0YUluZGV4ID0gMDsgY2RhdGFJbmRleCA8IGNkYXRhLmxlbmd0aDsgY2RhdGFJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsaW5lQ291bnQ7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIGlmICgobGluZUNvdW50ID09IDEgJiYgbWFya0FycmF5Lmxlbmd0aCA9PSAxKSAmJiBjaGVja0ludGVyc2VjdGlvbihtYXJrQXJyYXlbaW5kZXhdLngsIG1hcmtBcnJheVtpbmRleF0ueSwgMCwgMCwgY2RhdGFbY2RhdGFJbmRleF0ueCwgY2RhdGFbY2RhdGFJbmRleF0ueSwgY2RhdGFbY2RhdGFJbmRleF0ucikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGRhdGEgJ01hdGNoJyBpbnRvIGFycmF5IGNvcnJlY3RBbnN3ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0QW5zd2VyLnB1c2goXCJNYXRjaFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgobGluZUNvdW50ID49IDEgJiYgbWFya0FycmF5Lmxlbmd0aCA+IDEpICYmIGNoZWNrSW50ZXJzZWN0aW9uKG1hcmtBcnJheVtpbmRleF0ueCwgbWFya0FycmF5W2luZGV4XS55LCBtYXJrQXJyYXlbaW5kZXggKyAxXS54LCBtYXJrQXJyYXlbaW5kZXggKyAxXS55LCBjZGF0YVtjZGF0YUluZGV4XS54LCBjZGF0YVtjZGF0YUluZGV4XS55LCBjZGF0YVtjZGF0YUluZGV4XS5yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggZGF0YSAnTWF0Y2gnIGludG8gYXJyYXkgY29ycmVjdEFuc3dlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RBbnN3ZXIucHVzaChcIk1hdGNoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3JyZWN0QW5zd2VyLmxlbmd0aCA9PSBjZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdmFyaWFibGUgJ2lzQW5zd2VyQ29ycmVjdCcgdG8gdHJ1ZVxyXG4gICAgICAgICAgICBpc0Fuc3dlckNvcnJlY3QgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHZhcmlhYmxlICdpc0Fuc3dlckNvcnJlY3QnIHRvIGZhbHNlXHJcbiAgICAgICAgICAgIGlzQW5zd2VyQ29ycmVjdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYWtlcyBjb3JyZWN0QW5zd2VyIGFycmF5IGVtcHR5XHJcbiAgICAgICAgY29ycmVjdEFuc3dlciA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldHMgdGhlIHN0YXR1cyBvZiB0aGUgYW5zd2VyICggY29ycmVjdCBvciBpbmNvcnJlY3QgbWVzc2FnZSB3aXRoIHNob3dpbmcgdGhlIFVJIHRoYXQgaW5kaWNhdGVzIGNvcnJlY3Qgb3IgaW5jb3JyZWN0KVxyXG4gICAgZnVuY3Rpb24gc2V0U3RhdHVzT2ZBbnMoaXNBbnN3ZXJDb3JyZWN0LCBtYXJrQXJyYXksIGRyYXdNYXJrKSB7XHJcbiAgICAgICAgaWYgKGlzQW5zd2VyQ29ycmVjdCkge1xyXG4gICAgICAgICAgICAvLyBzdGVzIHRoZSB2YWx1ZSBvZiB0aGUgc3RhdGUgY29ycmVjdEFuc3dlciB0byB0cnVlXHJcbiAgICAgICAgICAgIHN0YXRlLmNvcnJlY3RBbnN3ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZHJhd01hcmspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjZGF0YS5sZW5ndGggJiYgbWFya0FycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGpvaW4gdGhlIG1hcmtlZCBwb2ludHMgYW5kIHNldHMgdGhlIGNvbG9yIGFuZCB3aWR0aCBvZiB0aGUgc3Ryb2tlIFxyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5NYXJrZWRQb2ludChtYXJrQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgc3Ryb2tlIGNvbG9yIG9mIGVsZW1lbnQgaGF2ZSBjbGFzcyAnYW5zd2VyX21hcmsnIHRvICMwRjlENThcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmFuc3dlcl9tYXJrJywgJ2NzcycsIHsnc3Ryb2tlJzogJyMwRjlENTgnfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdGhlIG1lc3NhZ2UgdmFyaWFibGUgdG8gY29ycmVjdFxyXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvclN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvd3MgY29ycmVjdFxyXG4gICAgICAgICAgICAgICAgICAgIHNob3dBbnMobC5jb3JyZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmNvcnJlY3RBbnN3ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkcmF3TWFyaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNkYXRhLmxlbmd0aCAmJiBtYXJrQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gam9pbiB0aGUgbWFya2VkIHBvaW50cyBhbmQgc2V0cyB0aGUgY29sb3IgYW5kIHdpZHRoIG9mIHRoZSBzdHJva2UgXHJcbiAgICAgICAgICAgICAgICAgICAgam9pbk1hcmtlZFBvaW50KG1hcmtBcnJheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSBzdHJva2UgY29sb3Igb2YgdGhlIG1hcmsgcG9pbnRzIGFuZCBsaW5lcyB0aGF0IGFyZSBkcmF3IHVzaW5nIG1hcmsgcG9pbnRzIHRvICNmZjAwMDBcclxuICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLmFuc3dlcl9tYXJrJywgJ2NzcycsIHsnc3Ryb2tlJzogJyNmZjAwMDAnfSk7XHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5hbnN3ZXJfY2lyY2xlJywgJ2NzcycsIHsnc3Ryb2tlJzogJyMwRjlENTgnfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3JTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3dzIGFuc3dlciBpbmNvcnJlY3RcclxuICAgICAgICAgICAgICAgICAgICBzaG93QW5zKGwuaW5jb3JyZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGVjayBvciB1bmNoZWNrIHRoZSBlbGVtZW50IGhhdmUgaWQgJ2Fuc3dlcicgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZSBvZiB2YXJpYWJsZSBpc0Fuc3dlckNvcnJlY3RcclxuICAgICAgIC8vIEFILnNlbGVjdChcIiNhbnN3ZXJcIikuY2hlY2tlZCA9IHN0YXRlLmNvcnJlY3RBbnN3ZXI7XHJcbiAgICAgICAgb25Vc2VyQW5zQ2hhbmdlKHt1WG1sOiB1c2VyQW5zWE1MLCBhbnM6IHN0YXRlLmNvcnJlY3RBbnN3ZXJ9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDZW50ZXIgb2YgdGhlIGNpcmNsZSAoY3gsIGN5KVxyXG4gICAgLy8gUmFkaXVzIG9mIGNpcmNsZTogclxyXG4gICAgLy8gRmlyc3QgUG9pbnQgKGF4LGF5KSBhbmQgc2Vjb25kIFBvaW50IChieCxieSlcclxuICAgIGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHIpIHtcclxuICAgICAgICBheCAtPSBjeDtcclxuICAgICAgICBheSAtPSBjeTtcclxuICAgICAgICBieCAtPSBjeDtcclxuICAgICAgICBieSAtPSBjeTtcclxuICAgICAgICBsZXQgYSA9IChieCAtIGF4KSAqIChieCAtIGF4KSArIChieSAtIGF5KSAqIChieSAtIGF5KVxyXG4gICAgICAgIGxldCBiID0gMiAqIChheCAqIChieCAtIGF4KSArIGF5ICogKGJ5IC0gYXkpKTtcclxuICAgICAgICBsZXQgYyA9IGF4ICogYXggKyBheSAqIGF5IC0gciAqIHI7XHJcbiAgICAgICAgLy8gQXBwbHlpbmcgU2hyaSBEaGFyYWNoYXJ5YSBtZXRob2QgYnkgY29tcGFyaW5nIHRoZSBxdWFkcmF0aWMgdmFsdWVzIGEsIGIsIGNcclxuICAgICAgICBsZXQgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xyXG4gICAgICAgIGlmIChkaXNjIDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdDEgPSAoLWIgKyBNYXRoLnNxcnQoZGlzYykpIC8gKDIgKiBhKTtcclxuICAgICAgICBsZXQgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzYykpIC8gKDIgKiBhKTtcclxuICAgICAgICBpZiAoKDAgPCB0MSAmJiB0MSA8IDEpIHx8ICgwIDwgdDIgJiYgdDIgPCAxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZXMgdGhlIHZhbHVlIG9mIGNvbXBhc3MgcmFkaXVzIGFuZCBhbmdsZVxyXG4gICAgZnVuY3Rpb24gY2hlY2tQcmV2aWV3UmFkaXVzQW5kQW5nbGUoKSB7XHJcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHZhbHVlIG9mIGluaXRpYWwgeCBjby1vcmRpbmF0ZSBvZiBjb21wYXNzIHJvdGF0aW9uIGJhciBcclxuICAgICAgICBpbml0aWFsUG9pbnQueCA9IE51bWJlcihBSC5zZWxlY3QoJy5jb21wYXNzUm90YXRpb25CYXInKS5nZXRBdHRyaWJ1dGUoJ3gxJykpO1xyXG4gICAgICAgIC8vIGNvbnRhaW5zIHRoZSB2YWx1ZSBvZiBpbml0aWFsIHkgY28tb3JkaW5hdGUgb2YgY29tcGFzcyByb3RhdGlvbiBiYXJcclxuICAgICAgICBpbml0aWFsUG9pbnQueSA9IE51bWJlcihBSC5zZWxlY3QoJy5jb21wYXNzUm90YXRpb25CYXInKS5nZXRBdHRyaWJ1dGUoJ3kxJykpO1xyXG4gICAgICAgIC8vIGNvbnRhaW5zIHRoZSB2YWx1ZSBvZiBmaW5hbCB4IGNvLW9yZGluYXRlIG9mIGNvbXBhc3Mgcm90YXRpb24gYmFyXHJcbiAgICAgICAgZmluYWxQb2ludC54ID0gTnVtYmVyKEFILnNlbGVjdCgnLmNvbXBhc3NSb3RhdGlvbkJhcicpLmdldEF0dHJpYnV0ZSgneDInKSk7XHJcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHZhbHVlIG9mIGZpbmFsIHkgY28tb3JkaW5hdGUgb2YgY29tcGFzcyByb3RhdGlvbiBiYXJcclxuICAgICAgICBmaW5hbFBvaW50LnkgPSBOdW1iZXIoQUguc2VsZWN0KCcuY29tcGFzc1JvdGF0aW9uQmFyJykuZ2V0QXR0cmlidXRlKCd5MicpKTtcclxuICAgICAgICAvLyAvLyBjb250YWlucyB0aGUgbGVuZ3RoIG9mIGNvbXBhc3Mgcm90YXRpb24gYmFyXHJcbiAgICAgICAgcHJldmlld0NvbXBhc3NSYWRpdXMgPSBOdW1iZXIoQUguc2VsZWN0KCcuZHJhd2luZ0NvbXBhc3NSb3V0ZScpLmdldEF0dHJpYnV0ZSgncicpKTtcclxuICAgICAgICAvLyBjb250YWlucyB0aGUgdmFsdWUgb2YgY29tcGFzcyBhbmdsZSB1c2luZyB0aGUgY28tb3JkaW5hdGVzIG9mIHRoZSBpbml0aWFsIGFuZCBmaW5hbCBwb2ludHNcclxuICAgICAgICBwcmV2aWV3Q29tcGFzc0FuZ2xlID0gTWF0aC5hdGFuMihmaW5hbFBvaW50LnkgLSBpbml0aWFsUG9pbnQueSwgZmluYWxQb2ludC54IC0gaW5pdGlhbFBvaW50LngpICogMTgwIC8gTWF0aC5QSTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiByb3RhdGlvbmJhciBhbmQgY2hhbmdlIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIGNpcmNsZXMgdGhhdCBsaWVzIG9uIHJvdGF0aW9uYmFyXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVQcmV2aWV3Q29tcGFzc0NhbGN1bGF0aW9uKGN4LCBjeSwgcHJldmlld0NvbXBhc3NSYWRpdXMsIHByZXZpZXdDb21wYXNzQW5nbGUpIHtcclxuICAgICAgICAvLyBzZXRzIHRoZSBjZW50ZXIgb2YgeCBvZiBtaWRkbGUgY2lyY2xlIGxpZXMgb24gY29tcGFzcyByb3RhdGlvbmJhclxyXG4gICAgICAgIG1pZENpcmNsZV9jeCA9IGN4ICsgKHByZXZpZXdDb21wYXNzUmFkaXVzIC8gMikgKiBNYXRoLmNvcyhwcmV2aWV3Q29tcGFzc0FuZ2xlICogKE1hdGguUEkgLyAxODApKTtcclxuICAgICAgICAvLyBzZXRzIHRoZSBjZW50ZXIgb2YgeSBvZiBtaWRkbGUgY2lyY2xlIGxpZXMgb24gY29tcGFzcyByb3RhdGlvbmJhclxyXG4gICAgICAgIG1pZENpcmNsZV9jeSA9IGN5ICsgKHByZXZpZXdDb21wYXNzUmFkaXVzIC8gMikgKiBNYXRoLnNpbihwcmV2aWV3Q29tcGFzc0FuZ2xlICogKE1hdGguUEkgLyAxODApKTtcclxuICAgICAgICAvLyBzZXRzIHRoZSBjZW50ZXIgb2YgeCBvZiBzbWFsbCBtaWRkbGUgY2lyY2xlIGxpZXMgb24gY29tcGFzcyByb3RhdGlvbmJhclxyXG4gICAgICAgIG1pZFNtYWxsQ2lyY2xlX2N4ID0gY3ggKyAoKDMgKiBwcmV2aWV3Q29tcGFzc1JhZGl1cykgLyA0KSAqIE1hdGguY29zKHByZXZpZXdDb21wYXNzQW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkpO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIGNlbnRlciBvZiB5IG9mIHNtYWxsIG1pZGRsZSBjaXJjbGUgbGllcyBvbiBjb21wYXNzIHJvdGF0aW9uYmFyXHJcbiAgICAgICAgbWlkU21hbGxDaXJjbGVfY3kgPSBjeSArICgoMyAqIHByZXZpZXdDb21wYXNzUmFkaXVzKSAvIDQpICogTWF0aC5zaW4ocHJldmlld0NvbXBhc3NBbmdsZSAqIChNYXRoLlBJIC8gMTgwKSk7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgY2VudGVyIG9mIHggb2YgbGFzdCBjaXJjbGUgbGllcyBvbiBjb21wYXNzIHJvdGF0aW9uYmFyXHJcbiAgICAgICAgbGFzdENpcmNsZV9jeCA9IGN4ICsgKHByZXZpZXdDb21wYXNzUmFkaXVzKSAqIE1hdGguY29zKHByZXZpZXdDb21wYXNzQW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkpO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIGNlbnRlciBvZiB5IG9mIGxhc3QgY2lyY2xlIGxpZXMgb24gY29tcGFzcyByb3RhdGlvbmJhclxyXG4gICAgICAgIGxhc3RDaXJjbGVfY3kgPSBjeSArIChwcmV2aWV3Q29tcGFzc1JhZGl1cykgKiBNYXRoLnNpbihwcmV2aWV3Q29tcGFzc0FuZ2xlICogKE1hdGguUEkgLyAxODApKTtcclxuICAgICAgICAvLyBzZXRzIHRoZSBjZW50ZXIgb2YgeCBvZiByb3RhdGlvbiBpY29uIHRoYXQgY2FuIGJlIHNlZW4ganVzdCBpbiBmcm9udCBvZiB0aGUgbGFzdCBjaXJjbGUgdG8gaW5kaWNhdGlvbiB0aGF0IG1vdmUgdGhlIHJvdGF0aW9uYmFyIGluIHRoZXNlIGRpcmVjdGlvbnMgdG8gZHJhdyB0aGUgY2lyY3VsYXIgY3VydmVcclxuICAgICAgICBsYXN0U21hbGxDaXJjbGVfY3ggPSBjeCArICgoNSAqIHByZXZpZXdDb21wYXNzUmFkaXVzKSAvIDQpICogTWF0aC5jb3MocHJldmlld0NvbXBhc3NBbmdsZSAqIChNYXRoLlBJIC8gMTgwKSk7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgY2VudGVyIG9mIHggb2Ygcm90YXRpb24gaWNvbiB0aGF0IGNhbiBiZSBzZWVuIGp1c3QgaW4gZnJvbnQgb2YgdGhlIGxhc3QgY2lyY2xlIHRvIGluZGljYXRpb24gdGhhdCBtb3ZlIHRoZSByb3RhdGlvbmJhciBpbiB0aGVzZSBkaXJlY3Rpb25zIHRvIGRyYXcgdGhlIGNpcmN1bGFyIGN1cnZlXHJcbiAgICAgICAgbGFzdFNtYWxsQ2lyY2xlX2N5ID0gY3kgKyAoKDUgKiBwcmV2aWV3Q29tcGFzc1JhZGl1cykgLyA0KSAqIE1hdGguc2luKHByZXZpZXdDb21wYXNzQW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkpO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIGNlbnRlciBjby1vcmRpbmF0ZSBvZiB0aGUgY29tcGFzcyBhbmQgb2YgaXRzIHJvdXRlXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcuZHJhd2luZ0NvbXBhc3NSb3V0ZSwuZHJhd2luZ0NvbXBhc3NDZW50ZXInLCAnYXR0cicsIHtcclxuICAgICAgICAgICAgJ2N4JzogY3gsXHJcbiAgICAgICAgICAgICdjeSc6IGN5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgcmFkaXVzIG9mIHRoZSBjb21wYXNzIG9yIGxlbmd0aCBvZiB0aGUgcm90YXRpb25iYXJcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJy5kcmF3aW5nQ29tcGFzc1JvdXRlJywgJ2F0dHInLCB7J3InOiBwcmV2aWV3Q29tcGFzc1JhZGl1c30pO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIGNvLW9yZGluYXRlcyBvZiBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiB0aGUgY29tcGFzcyByb3RhdGlvbiBiYXJcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJy5jb21wYXNzUm90YXRpb25CYXInLCAnYXR0cicsIHtcclxuICAgICAgICAgICAgJ3gxJzogY3gsXHJcbiAgICAgICAgICAgICd5MSc6IGN5LFxyXG4gICAgICAgICAgICAneDInOiBsYXN0Q2lyY2xlX2N4LFxyXG4gICAgICAgICAgICAneTInOiBsYXN0Q2lyY2xlX2N5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHJvdGF0aW9uIGluZGljYXRvciBhbmQgcm90YXRlIGl0IGluIDNEIGRpbWVudGlvbiBmb3IgZGVmaW5lZCB2YXJpYWJsZXMgdmFsdWUgdGhhdCBjYW4gYmUgc2VlbiBhZnRlciBob3ZlciBvbiB0aGUgbGFzdCBjaXJjbGUgbGllcyBvbiByb3RhdGlvbiBiYXJcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJyNwcmV2aWV3U3ZnIC5sYXN0Q2lyY2xlTWlkJywgJ2F0dHInLCB7XHJcbiAgICAgICAgICAgICdjeCc6IGxhc3RTbWFsbENpcmNsZV9jeCxcclxuICAgICAgICAgICAgJ2N5JzogbGFzdFNtYWxsQ2lyY2xlX2N5LFxyXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiOiBcInJvdGF0ZShcIiArIHByZXZpZXdDb21wYXNzQW5nbGUgKyBcIixcIiArIGxhc3RTbWFsbENpcmNsZV9jeCArIFwiLFwiICsgbGFzdFNtYWxsQ2lyY2xlX2N5ICsgXCIpXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBzZXRzIHRoZSBjZW50ZXIgb2YgdGhlIGxhc3QgY2lyY2xlIGxpZXMgb24gcm90YXRpb24gYmFyXHJcbiAgICAgICAgQUguc2VsZWN0QWxsKCcjcHJldmlld1N2ZyAubGFzdENpcmNsZScsICdhdHRyJywge1xyXG4gICAgICAgICAgICAnY3gnOiBsYXN0Q2lyY2xlX2N4LFxyXG4gICAgICAgICAgICAnY3knOiBsYXN0Q2lyY2xlX2N5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBjZW50ZXIgb2Ygc21hbGwgbWlkZGxlIGNpcmNsZSBhbmQgcm90YXRlIGl0IGluIDNEIGRpbWVudGlvbiBmb3IgZGVmaW5lZCB2YXJpYWJsZXMgdmFsdWVcclxuICAgICAgICBBSC5zZWxlY3RBbGwoJyNwcmV2aWV3U3ZnIC5taWRTbWFsbENpcmNsZScsICdhdHRyJywge1xyXG4gICAgICAgICAgICAnY3gnOiBtaWRTbWFsbENpcmNsZV9jeCxcclxuICAgICAgICAgICAgJ2N5JzogbWlkU21hbGxDaXJjbGVfY3ksXHJcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCI6IFwicm90YXRlKFwiICsgcHJldmlld0NvbXBhc3NBbmdsZSArIFwiLFwiICsgbWlkU21hbGxDaXJjbGVfY3ggKyBcIixcIiArIG1pZFNtYWxsQ2lyY2xlX2N5ICsgXCIpXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBzZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIGNlbnRlciBvZiBtaWRkbGUgY2lyY2xlIGFuZCByb3RhdGUgaXQgaW4gM0QgZGltZW50aW9uIGZvciBkZWZpbmVkIHZhcmlhYmxlcyB2YWx1ZVxyXG4gICAgICAgIEFILnNlbGVjdEFsbCgnI3ByZXZpZXdTdmcgLm1pZF9jaXJjbGUnLCAnYXR0cicsIHtcclxuICAgICAgICAgICAgJ2N4JzogbWlkQ2lyY2xlX2N4LFxyXG4gICAgICAgICAgICAnY3knOiBtaWRDaXJjbGVfY3ksXHJcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCI6IFwicm90YXRlKFwiICsgcHJldmlld0NvbXBhc3NBbmdsZSArIFwiLFwiICsgbWlkQ2lyY2xlX2N4ICsgXCIsXCIgKyBtaWRDaXJjbGVfY3kgKyBcIilcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGFzc2lnbiB0aGUgdmFsdWUgb2YgdmFyaWFibGUgcHJldmlld0NvbXBhc3NBbmdsZSBpbnRvIHZhcmlhYmxlIGN1ckFuZ2xlXHJcbiAgICAgICAgbGV0IGN1ckFuZ2xlID0gcHJldmlld0NvbXBhc3NBbmdsZTtcclxuICAgICAgICBpZiAoY3VyQW5nbGUgPCAwKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZHMgMzYwIGRlZ3JlZSB2YWx1ZSBpbiBpdCdzIHByZXZpb3VzIHZhbHVlIG9mIHZhcmlhYmxlIGN1ckFuZ2xlXHJcbiAgICAgICAgICAgIGN1ckFuZ2xlID0gMzYwICsgY3VyQW5nbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHMgdGhlIG1lc3NhZ2UgYWJvdXQgYW5nbGUgZm9yIHNjcmVlbiByZWFkZXJcclxuICAgICAgICBBSC5zZWxlY3QoJyNjb21wYXNzUm90YXRpb25UaXRsZScpLmlubmVyVGV4dCA9IFwiQ29tcGFzcyBBbmdsZSwgWW91ciBDdXJyZW50IEFuZ2xlIGlzIFwiICsgY3VyQW5nbGUudG9GaXhlZCgwKSArIFwiIGRlZ3JlZVwiO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIG1lc3NhZ2UgYWJvdXQgcmFkaXVzIGZvciBzY3JlZW4gcmVhZGVyXHJcbiAgICAgICAgQUguc2VsZWN0KCcjY29tcGFzc1JhZGl1c1RpdGxlJykuaW5uZXJUZXh0ID0gXCJDb21wYXNzIFJhZGl1cywgWW91ciBDdXJyZW50IFJhZGl1cyBpcyBcIiArIChwcmV2aWV3Q29tcGFzc1JhZGl1cyAqIDAuMDI2NDkpLnRvRml4ZWQoMSkgKyBcImNtXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0cyB0aGUgeCBhbmQgeSBjby1vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgIGZ1bmN0aW9uIHNldFByZXZpZXdNb3VzZUNvb3JkaW5hdGVzKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHNpemUgb2YgZWxlbWVudCBoYXZpbmcgaWQgJ2F1dGhvcmluZ1N2ZycgYW5kIGl0cyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcclxuICAgICAgICBsZXQgYm91bmRhcnkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJldmlld1N2ZycpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIG1vdXNlIGNvLW9yZGluYXRlXHJcbiAgICAgICAgcHJldmlld19tb3VzZVggPSBldmVudC5jbGllbnRYIC0gYm91bmRhcnkubGVmdDtcclxuICAgICAgICAvLyBzZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBjby1vcmRpbmF0ZVxyXG4gICAgICAgIHByZXZpZXdfbW91c2VZID0gZXZlbnQuY2xpZW50WSAtIGJvdW5kYXJ5LnRvcDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXRzIHRoZSBzdHJva2UgY29sb3IgYW5kIHdpZHRoXHJcbiAgICBmdW5jdGlvbiBzZXRQcmV2aWV3Q29sb3IocHJldmlld0NvbG9yLCBwcmV2aWV3VGhpY2tuZXNzKSB7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBkcmF3aW5nXHJcbiAgICAgICAgc2NyaWJibGUuc3R5bGUuc3Ryb2tlID0gcHJldmlld0NvbG9yO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIHN0cm9rZSB3aWR0aCBvZiB0aGUgZHJhd2luZ1xyXG4gICAgICAgIHNjcmliYmxlLnN0eWxlLnN0cm9rZVdpZHRoID0gcHJldmlld1RoaWNrbmVzcztcclxuICAgICAgICBzY3JpYmJsZS5zdHlsZS5maWxsID0gJ25vbmUnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoYW5nZXMgdGhlIHZhbHVlIG9mIHJhZGl1cywgYW5nbGUsIGFuZCBjZW50ZXIgb2YgdGhlIGNvbXBhc3Mgd2hlbiBpdCBpcyBwZXJmb3JtZWQgdmlhIGtleWJvYXJkXHJcbiAgICBmdW5jdGlvbiBjb21wYXNzS2V5RXZlbnQobW9kZSwgZXZlbnQpIHtcclxuICAgICAgICBpZiAoICEgQUguc2VsZWN0KCcuZHJhd2luZ0NvbXBhc3NTdmcnKS5jbGFzc0xpc3QuY29udGFpbnMoJ2gnKSAmJiBwcmV2aWV3TW9kZSA9PSBcImNvbXBhc3NcIikge1xyXG4gICAgICAgICAgICAvLyBjb250YWlucyB3aWR0aCBvZiB0aGUgYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgICAgICAgICBsZXQgaW1hZ2VXaWR0aCA9IEFILnNlbGVjdCgnI3N2Z0ltZ1ByZXZpZXcnKS5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgd2lkdGggb2YgdGhlIGJhY2tncm91bmQgaW1hZ2UgXHJcbiAgICAgICAgICAgIGxldCBpbWFnZUhlaWdodCA9IEFILnNlbGVjdCgnI3N2Z0ltZ1ByZXZpZXcnKS5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZXMgdGhlIHZhbHVlIG9mIGNvbXBhc3MgcmFkaXVzIGFuZCBhbmdsZVxyXG4gICAgICAgICAgICBjaGVja1ByZXZpZXdSYWRpdXNBbmRBbmdsZSgpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKGV2ZW50LmtleUNvZGUgPT0gMzggfHwgZXZlbnQua2V5Q29kZSA9PSAzNyB8fCBldmVudC5rZXlDb2RlID09IDM5IHx8IGV2ZW50LmtleUNvZGUgPT0gNDApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAncmFkaXVzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSByYWRpdXMgdmFsdWUgYnkgMSBhZnRlciBkb3duIHRoZSBrZXkgc2hpZnQgYW5kIHVwIGFycm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcGFzc1JhZGl1cysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNyZWFzZXMgdGhlIHJhZGl1cyB2YWx1ZSBieSAxIGFmdGVyIGRvd24gdGhlIGtleSBzaGlmdCBhbmQgbGVmdCBhcnJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld0NvbXBhc3NSYWRpdXMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSByYWRpdXMgdmFsdWUgYnkgMSBhZnRlciBkb3duIHRoZSBrZXkgc2hpZnQgYW5kIHJpZ2h0IGFycm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcGFzc1JhZGl1cysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNyZWFzZXMgdGhlIHJhZGl1cyB2YWx1ZSBieSAxIGFmdGVyIGRvd24gdGhlIGtleSBzaGlmdCBhbmQgZG93biBhcnJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld0NvbXBhc3NSYWRpdXMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09ICdtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVhc2VzIHRoZSB2YWx1ZSBvZiB5IGNvLW9yZGluYXRlIG9mIGNvbXBhc3MgY2VudGVyIGJ5IDEgYWZ0ZXIgZG93biB0aGUga2V5IHNoaWZ0IGFuZCB1cCBhcnJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFBvaW50LnktLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVhc2VzIHRoZSB2YWx1ZSBvZiB4IGNvLW9yZGluYXRlIG9mIGNvbXBhc3MgY2VudGVyIGJ5IDEgYWZ0ZXIgZG93biB0aGUga2V5IHNoaWZ0IGFuZCBsZWZ0IGFycm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9pbnQueC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHggY28tb3JkaW5hdGUgb2YgY29tcGFzcyBjZW50ZXIgYnkgMSBhZnRlciBkb3duIHRoZSBrZXkgc2hpZnQgYW5kIHJpZ2h0IGFycm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9pbnQueCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHkgY28tb3JkaW5hdGUgb2YgY29tcGFzcyBjZW50ZXIgYnkgMSBhZnRlciBkb3duIHRoZSBrZXkgc2hpZnQgYW5kIGRvd24gYXJyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxQb2ludC55Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKG1vZGUgPT0gJ3JvdGF0ZScgfHwgbW9kZSA9PSAnZHJhdycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIGNvbXBhc3MgYW5nbGUgYnkgMSBhZnRlciBkb3duIHRoZSBrZXkgc2hpZnQgYW5kIHVwIGFycm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcGFzc0FuZ2xlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlYXNlcyB0aGUgdmFsdWUgb2YgY29tcGFzcyBhbmdsZSBieSAxIGFmdGVyIGRvd24gdGhlIGtleSBzaGlmdCBhbmQgcmlnaHQgYXJyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdDb21wYXNzQW5nbGUtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSB2YWx1ZSBvZiBjb21wYXNzIGFuZ2xlIGJ5IDEgYWZ0ZXIgZG93biB0aGUga2V5IHNoaWZ0IGFuZCBsZWZ0IGFycm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3Q29tcGFzc0FuZ2xlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlYXNlcyB0aGUgdmFsdWUgb2YgY29tcGFzcyBhbmdsZSBieSAxIGFmdGVyIGRvd24gdGhlIGtleSBzaGlmdCBhbmQgZG93biBhcnJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld0NvbXBhc3NBbmdsZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gJ2RyYXcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFILnNlbGVjdCgnI3ByZXZpZXdTdmcgLmxhc3RDaXJjbGUnKS5jbGFzc0xpc3QuY29udGFpbnMoJ2xhc3RDaXJjbGVfaG92ZXInKSB8fCBBSC5zZWxlY3QoJyNwcmV2aWV3U3ZnIC5sYXN0YmlnY2lyY2xlJykuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXN0Q2lyY2xlX2hvdmVyJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBhIG5ldyBhdHRyaWJ1dGUgJ2QnICh3aXRoIGEgbmFtZXNwYWNlIG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmliYmxlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCArICcgTCcgKyBsYXN0Q2lyY2xlX2N4ICsgJyAnICsgbGFzdENpcmNsZV9jeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgdmFsdWUgb2YgdmFyaWFibGVzIGxhc3RDaXJjbGVfY3ggYW5kIGxhc3RDaXJjbGVfY3kgc2VwYXJhdGVkIGJ5IHNwYWNlIHdpdGggcHJlZml4ICdMJyBpbiB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGtleSAnZCcgYXQgaW5kZXggc3BlY2lmaWVkIGluIHRoZSB2YXJpYWJsZSBwcmV2aWV3U2NyaWJibGVDb3VudCBvZiBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgPSBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kICsgJyBMJyArIGxhc3RDaXJjbGVfY3ggKyAnICcgKyBsYXN0Q2lyY2xlX2N5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIHRoZSBlbGVtZW50IHN0b3JlZCBpbnRvIHZhcmlhYmxlIHNjcmliYmxlIGluIGRyYXdpbmcgY29udGFpbmVyIGluIHdoaWNoIGRyYXdpbmdzIGFyZSBzdG9yZWQgc2tldGNoZWQgYnkgdGhlIGhlbHAgb2YgZHJhd2luZyB0b29sc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJy5wcmV2aWV3RHJhd2luZ1BhdGhzJykucHJlcGVuZChzY3JpYmJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxQb2ludC54IDwgMTAgfHwgcHJldmlld0NvbXBhc3NSYWRpdXMgPCA4MCB8fCBwcmV2aWV3Q29tcGFzc1JhZGl1cyA+IDM2MCB8fCBpbml0aWFsUG9pbnQueCA+IGltYWdlV2lkdGggfHwgaW5pdGlhbFBvaW50LnkgPCAxMCB8fCBpbml0aWFsUG9pbnQueSA+IGltYWdlSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0aGUgcG9zaXRpb24gb2Ygcm90YXRpb25iYXIgYW5kIGNoYW5nZSB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGVzIHRoYXQgbGllcyBvbiByb3RhdGlvbmJhclxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJldmlld0NvbXBhc3NDYWxjdWxhdGlvbihpbml0aWFsUG9pbnQueCwgaW5pdGlhbFBvaW50LnksIHByZXZpZXdDb21wYXNzUmFkaXVzLCBwcmV2aWV3Q29tcGFzc0FuZ2xlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzdG9wIHRoZSBkcmF3aW5nIGFuZCBzdG9yZSB0aGUgZHJhd2luZyBza2V0Y2hlZCBieSB0aGUgdXNlciBhbmQgc2V0cyB0aGUgdXNlciBhbnN3ZXIgeG1sIFxyXG4gICAgZnVuY3Rpb24gc3RvcERyYXcoKSB7XHJcbiAgICAgICAgaWYgKChjaGVja0N1cnJlbnRQb3NpdGlvblggPT0gY3Vyc29yTGVmdCAmJiBjaGVja0N1cnJlbnRQb3NpdGlvblkgPT0gY3Vyc29yVG9wICYmIHByZXZpZXdNb2RlID09ICdsaW5lJykgfHwgKHByZXZpZXdNb2RlID09ICdzY3JpYmJsZScgJiYgcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZC5pbmRleE9mKCdMJykgPT0gLTEpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBhcnJheSBwcmV2aWV3U2NyaWJibGVQYXRoXHJcbiAgICAgICAgICAgIHByZXZpZXdTY3JpYmJsZVBhdGgucG9wKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY3Vyc29yTGVmdCkgJiYgaXNOYU4oY3Vyc29yVG9wKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBuZXcgYXR0cmlidXRlICdkJyAod2l0aCBhIG5hbWVzcGFjZSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc2NyaWJibGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwcmV2aWV3U2NyaWJibGVQYXRoW3ByZXZpZXdTY3JpYmJsZUNvdW50XS5kICsgJyBMJyArIGN1cnNvckxlZnQgKyAnICcgKyBjdXJzb3JUb3ApO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkcyB2YWx1ZSBvZiB2YXJpYWJsZXMgY3Vyc29yTGVmdCBhbmQgY3Vyc29yVG9wIHNlcGFyYXRlZCBieSBzcGFjZSB3aXRoIHByZWZpeCAnTCcgaW4gdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBrZXkgJ2QnIGF0IGluZGV4IHNwZWNpZmllZCBpbiB0aGUgdmFyaWFibGUgcHJldmlld1NjcmliYmxlQ291bnQgb2YgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgICAgICAgICAgcHJldmlld1NjcmliYmxlUGF0aFtwcmV2aWV3U2NyaWJibGVDb3VudF0uZCA9IHByZXZpZXdTY3JpYmJsZVBhdGhbcHJldmlld1NjcmliYmxlQ291bnRdLmQgKyAnIEwnICsgY3Vyc29yTGVmdCArICcgJyArIGN1cnNvclRvcDtcclxuICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIGVsZW1lbnQgc3RvcmVkIGludG8gdmFyaWFibGUgc2NyaWJibGUgaW4gZHJhd2luZyBjb250YWluZXIgaW4gd2hpY2ggZHJhd2luZ3MgYXJlIHN0b3JlZCBza2V0Y2hlZCBieSB0aGUgaGVscCBvZiBkcmF3aW5nIHRvb2xzXHJcbiAgICAgICAgICAgICAgICBBSC5zZWxlY3QoJy5wcmV2aWV3RHJhd2luZ1BhdGhzJykucHJlcGVuZChzY3JpYmJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW5jcmVhc2VzIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgcHJldmlld1NjcmliYmxlQ291bnQgYnkgMVxyXG4gICAgICAgICAgICBwcmV2aWV3U2NyaWJibGVDb3VudCsrO1xyXG4gICAgICAgICAgICAvLyBpbmNyZWFzZXMgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3VW5kb0NvdW50IGJ5IDFcclxuICAgICAgICAgICAgcHJldmlld1VuZG9Db3VudCsrO1xyXG4gICAgICAgICAgICAvLyBtYWtlcyBhcnJheSBwcmV2aWV3VW5kb0xpc3QgYmxhbmtcclxuICAgICAgICAgICAgcHJldmlld1VuZG9MaXN0ID0gW107XHJcbiAgICAgICAgICAgIC8vIGVuYWJsZXMgdW5kbyBhbmQgY3Jvc3MgKHgpIGJ1dHRvbnNcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld191bmRvJykuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgQUguc2VsZWN0KCcjcHJldmlld19jbGVhclNjcmVlbicpLmRpc2FibGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBkaXNhYmxlZCByZWRvIGJ1dHRvblxyXG4gICAgICAgICAgICBBSC5zZWxlY3QoJyNwcmV2aWV3X3JlZG8nKS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHNjcmliYmxlIGRyYXdpbmcgaXMgbm90IHNrZXRjaGluZ1xyXG4gICAgICAgIGlzU2NyaWJibGUgPSAwO1xyXG4gICAgICAgIC8vIHNldHMgdGhlIHZhbHVlIG9mIHZhcmlhYmxlIHN0YXJ0RHJhd2luZ0J5S2V5IHRvIDBcclxuICAgICAgICBzdGFydERyYXdpbmdCeUtleSA9IDA7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdmFyaWFibGUgaXNEcmF3U3RvcCB0byAwXHJcbiAgICAgICAgaXNEcmF3U3RvcCA9IDA7XHJcbiAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgb2YgdmFyaWFibGUgbG9ja0ZvY3VzIHRvIDBcclxuICAgICAgICBsb2NrRm9jdXMgPSAwO1xyXG4gICAgICAgIC8vIGNvbnRhaW5zIGNvcHkgb2YgYXJyYXkgcHJldmlld1NjcmliYmxlUGF0aFxyXG4gICAgICAgIGxldCB0ZW1wQXJyYXlDb250YWluZXIgPSBhcnJheUNvcHkocHJldmlld1NjcmliYmxlUGF0aCk7XHJcbiAgICAgICAgLy8gc3RvcmVzIHRoZSBkcmF3aW5nIHNrZXRjaGVkIGJ5IHVzZXIgYW5kIHNldHMgdGhlIHVzZXIgYW5zd2VyIHhtbFxyXG4gICAgICAgIHN0b3JlVXNlclBhdGhzKHRlbXBBcnJheUNvbnRhaW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZnVuY3Rpb24gZm9yIG9wZW5pbmcgdGhlIHNob3J0Y3V0IG1vZGFsXHJcbiAgICBmdW5jdGlvbiBvcGVuU2hvcnRjdXQoKSB7XHJcbiAgICAgICAgQUguZ2V0QlMoJyNkcmF3aW5nX3Nob3J0Y3V0X21vZGFsJywgJ01vZGFsJykuc2hvdygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIGZvciBjaGVja2luZyB0aGUgdXNlciBhbnMgYW5kIGxvYWRpbmcgdGhlIG1vZHVsZSBvbiB0aGUgYmFzaXMgb2YgaXRcclxuICAgIGZ1bmN0aW9uIGNoZWNrVXNlckFucygpIHtcclxuICAgICAgICBpZiAodHlwZW9mIChlZGl0b3JTdGF0ZSkgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlcyB0aGUgcmVzZXQgYnV0dG9uXHJcbiAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnJlc2V0X2dyb3VwJywgJ3JlbW92ZScpO1xyXG4gICAgICAgICAgICBpZiAodXhtbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHV4bWwuc2VhcmNoKCc8c21hbnMgdHlwZT1cIjQxXCI+JykgPT0gLTEgfHwgdXhtbC5zZWFyY2goJzxzbWFucyB0eXBlPVwiNDFcIj48L3NtYW5zPicpID09IDAgfHwgdXhtbC5zZWFyY2goJ3VuZGVmaW5lZCcpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmxhbmtzIHRoZSB1c2VyIGFuc3dlciB4bWxcclxuICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3QoXCIjc3BlY2lhbF9tb2R1bGVfdXNlcl94bWxcIiwgJ3ZhbHVlJywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jldmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBBSC5zZWxlY3RBbGwoJy5wcmV2aWV3QnRuR3JwJywgJ2FkZENsYXNzJywgJ2gnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgdmFsdWUgJ25vbmUnIG9mIHRoZSB2YXJpYWJsZSBwcmV2aWV3TW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3TW9kZSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGFsbG93ZWQgdXNlciB0byBwZXJmb3JtIHRoZSB0YXNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfZHJhd2luZ19jb250YWluZXInLCAnY3NzJywge3BvaW50ZXJFdmVudHM6IFwibm9uZVwifSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGNsYXNzIHByZXZpZXdLZXlTdmcgZnJvbSB0aGUgc3ZnIGVsZW1lbnQgaGF2ZSBpZCBwcmV2aWV3U3ZnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdTdmcnLCAncmVtb3ZlQ2xhc3MnLCAncHJldmlld0tleVN2ZycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93ZWQgdXNlciB0byBwZXJmb3JtIHRoZSB0YXNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdEFsbCgnLnByZXZpZXdfZHJhd2luZ19jb250YWluZXInLCdjc3MnLCB7cG9pbnRlckV2ZW50cyA6IFwiXCJ9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvd3MgYWxsIGJ1dHRvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcucHJldmlld0J0bkdycCcsICdyZW1vdmVDbGFzcycsICdoJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyB0aGUgY2xhc3MgcHJldmlld0tleVN2ZyB0byB0aGUgc3ZnIGVsZW1lbnQgaGF2ZSBpZCBwcmV2aWV3U3ZnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXdTdmcnLCdhZGRDbGFzcycsICdwcmV2aWV3S2V5U3ZnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSB2YWx1ZSBvZiBzdGF0ZSBhcnJheSBzZWxlY3RlZFRvb2xzIGF0IGluZGV4IDAgYWZ0ZXIgcmVtb3ZpbmcgdGhlIGZpcnN0IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3TW9kZSA9IHN0YXRlLnNlbGVjdGVkVG9vbHNbMF0uc3Vic3RyKC0oc3RhdGUuc2VsZWN0ZWRUb29sc1swXS5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgYWxzbyB1c2VkIGJlbG93IGluIHRoaXMgZnVuY3Rpb24gc28gaXQgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcucHJldmlld19idG4sI21hcmtfcG9pbnRzJywgJ3JlbW92ZUNsYXNzJywgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGFsc28gdXNlZCBiZWxvdyBpbiB0aGlzIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3ByZXZpZXcnICsgc3RhdGUuc2VsZWN0ZWRUb29sc1swXSwgJ2FkZENsYXNzJywgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsb2FkTW9kdWxlKEFILnNlbGVjdChcIiNzcGVjaWFsX21vZHVsZV91c2VyX3htbFwiKS52YWx1ZSwgaXNSZXZpZXcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcbiAgICAubXItMiB7XHJcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwLjVlbSAhaW1wb3J0YW50O1xyXG4gICAgfVxyXG4gICAgI3ByZXZpZXdTdmcgeyBcclxuICAgICAgICB3aWR0aDogNjAwcHg7XHJcbiAgICAgICAgaGVpZ2h0OiA1MjBweDtcclxuICAgICAgICBtYXJnaW4tdG9wOi01NTBweDtcclxuICAgIH1cclxuPC9zdHlsZT5cclxuXHJcbjxtYWluIGlkPVwiZHJhd2luZ1ByZXZpZXdNYWluXCI+XHJcbiAgICA8ZGl2IGlkPVwiZHJhd2luZ19zaG9ydGN1dF9tb2RhbFwiIGNsYXNzPVwibW9kYWwgZmFkZVwiIHRhYkluZGV4PVwiLTFcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nIG1vZGFsLWRpYWxvZy1jZW50ZXJlZFwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+e2wuc2hvcnRjdXRzfTwvaDQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCI+JnRpbWVzOzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keSBvdmVyZmxvdy15XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktdW5rbm93bi1yb2xlIC0tPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgcm9sZT1cInNob3J0Y3V0XCIgY2xhc3M9XCJzaG9ydGN1dFRhYmxlIG0tMCBwLTIgYm9yZGVyLTAgY29tbW9uLXNob3J0Y3V0LXRhYmxlIHRhYmxlLXN0cmlwZWQgZm9udDE1XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keSB0YWJpbmRleD1cIjBcIiByb2xlPVwic2hvcnRjdXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB0YWJpbmRleD1cIjBcIiByb2xlPVwic2hvcnRjdXRcIj48dGQgY2xhc3M9XCJweS0xIGZvbnQtd2VpZ2h0LWJvbGQgdy01MCBwci0wXCI+e2wua2V5c308L3RkPjx0ZCBjbGFzcz1cInB5LTFcIj48ZGl2IGNsYXNzPVwiZC1mbGV4XCI+PHNwYW4gY2xhc3M9XCJwbC0zIGZvbnQtd2VpZ2h0LWJvbGRcIj57bC5kZXNfdHh0fTwvc3Bhbj48L2Rpdj48L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cInNob3J0Y3V0XCI+PHRkIGNsYXNzPVwicHktMSBmb250LXdlaWdodC1ib2xkIHctNTAgcHItMFwiPntsLmN0cmxfen08L3RkPjx0ZCBjbGFzcz1cInB5LTFcIj48ZGl2IGNsYXNzPVwiZC1mbGV4XCI+PHNwYW4gY2xhc3M9XCJwbC0zXCI+e2wudW5kb308L3NwYW4+PC9kaXY+PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJzaG9ydGN1dFwiID48dGQgY2xhc3M9XCJweS0xIGZvbnQtd2VpZ2h0LWJvbGQgdy01MCBwci0wXCI+e2wuY3RybF94fTwvdGQ+PHRkIGNsYXNzPVwicHktMVwiPjxkaXYgY2xhc3M9XCJkLWZsZXhcIj48c3BhbiBjbGFzcz1cInBsLTNcIj57bC5jdXR9PC9zcGFuPjwvZGl2PjwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB0YWJpbmRleD1cIjBcIiByb2xlPVwic2hvcnRjdXRcIiA+PHRkIGNsYXNzPVwicHktMSBmb250LXdlaWdodC1ib2xkIHctNTAgcHItMFwiPntsLmN0cmxfeX08L3RkPjx0ZCBjbGFzcz1cInB5LTFcIj48ZGl2IGNsYXNzPVwiZC1mbGV4XCI+PHNwYW4gY2xhc3M9XCJwbC0zXCI+e2wucmVkb308L3NwYW4+PC9kaXY+PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJzaG9ydGN1dFwiID48dGQgY2xhc3M9XCJweS0xIGZvbnQtd2VpZ2h0LWJvbGQgdy01MCBwci0wXCI+e2wuZW50ZXJ9PC90ZD48dGQgY2xhc3M9XCJweS0xXCI+PGRpdiBjbGFzcz1cImQtZmxleFwiPjxzcGFuIGNsYXNzPVwicGwtM1wiPntsLmVuYWJsZV90b29sfTwvc3Bhbj48L2Rpdj48L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cInNob3J0Y3V0XCIgPjx0ZCBjbGFzcz1cInB5LTEgZm9udC13ZWlnaHQtYm9sZCB3LTUwIHByLTBcIj57bC5zaGlmdF9lbnRlcn08L3RkPjx0ZCBjbGFzcz1cInB5LTFcIj48ZGl2IGNsYXNzPVwiZC1mbGV4XCI+PHNwYW4gY2xhc3M9XCJwbC0zXCI+e2wuc3RhcnRfc3RvcF90b29sfTwvc3Bhbj48L2Rpdj48L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cInNob3J0Y3V0XCIgPjx0ZCBjbGFzcz1cInB5LTEgZm9udC13ZWlnaHQtYm9sZCB3LTUwIHByLTBcIj57bC5zaGlmdF9hcnJvd308L3RkPjx0ZCBjbGFzcz1cInB5LTFcIj48ZGl2IGNsYXNzPVwiZC1mbGV4XCI+PHNwYW4gY2xhc3M9XCJwbC0zXCI+e2wuY29tcGFzc190b29sc308L3NwYW4+PC9kaXY+PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJzaG9ydGN1dFwiID48dGQgY2xhc3M9XCJweS0xIGZvbnQtd2VpZ2h0LWJvbGQgdy01MCBwci0wXCI+e2wubG9ja2luZ308L3RkPjx0ZCBjbGFzcz1cInB5LTFcIj48ZGl2IGNsYXNzPVwiZC1mbGV4XCI+PHNwYW4gY2xhc3M9XCJwbC0zXCI+e2wubG9ja2luZ190eHR9PC9zcGFuPjwvZGl2PjwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB0YWJpbmRleD1cIjBcIiByb2xlPVwic2hvcnRjdXRcIiA+PHRkIGNsYXNzPVwicHktMSBmb250LXdlaWdodC1ib2xkIHctNTAgcHItMFwiPntsLmRyYXdfa2V5fTwvdGQ+PHRkIGNsYXNzPVwicHktMVwiPjxkaXYgY2xhc3M9XCJkLWZsZXhcIj48c3BhbiBjbGFzcz1cInBsLTNcIj57bC5kcmF3X3R4dH08L3NwYW4+PC9kaXY+PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJzaG9ydGN1dFwiID48dGQgY2xhc3M9XCJweS0xIGZvbnQtd2VpZ2h0LWJvbGQgdy01MCBwci0wXCI+e2wudGFifTwvdGQ+PHRkIGNsYXNzPVwicHktMVwiPjxkaXYgY2xhc3M9XCJkLWZsZXhcIj48c3BhbiBjbGFzcz1cInBsLTNcIj57bC5mb2N1c19uZXh0fTwvc3Bhbj48L2Rpdj48L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cInNob3J0Y3V0XCIgPjx0ZCBjbGFzcz1cInB5LTEgZm9udC13ZWlnaHQtYm9sZCB3LTUwIHByLTBcIj57bC5zaGlmdF90YWJ9PC90ZD48dGQgY2xhc3M9XCJweS0xXCI+PGRpdiBjbGFzcz1cImQtZmxleFwiPjxzcGFuIGNsYXNzPVwicGwtM1wiPntsLmZvY3VzX3ByZXZ9PC9zcGFuPjwvZGl2PjwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB0YWJpbmRleD1cIjBcIiByb2xlPVwic2hvcnRjdXRcIiA+PHRkIGNsYXNzPVwicHktMSBmb250LXdlaWdodC1ib2xkIHctNTAgcHItMFwiPntsLmVzY308L3RkPjx0ZCBjbGFzcz1cInB5LTFcIj48ZGl2IGNsYXNzPVwiZC1mbGV4XCI+PHNwYW4gY2xhc3M9XCJwbC0zXCI+e2wuZXhpdF90eHR9PC9zcGFuPjwvZGl2PjwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpZ2h0XCIgZGF0YS1icy1kaXNtaXNzPVwibW9kYWxcIj57bC5jbG9zZX08L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImRyYXdpbmdfbW9kdWxlX2NvbnRhaW5lclwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiaCBoLWltcFwiIGlkPVwic2V0LXJldmlld1wiPjwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiaCBoLWltcFwiIGlkPVwidW5zZXQtcmV2aWV3XCI+PC9idXR0b24+XHJcbiAgICAgICAgPGNlbnRlciBjbGFzcz1cInByZXZpZXdfZHJhd2luZ19jb250YWluZXJcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm10LTIgbWItMyBwcmV2aWV3QnRuR3JwXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLXRvb2xiYXIgcHJldmlld19kcmF3aW5nX3Rvb2xiYXJcIiByb2xlPVwidG9vbGJhclwiIGFyaWEtbGFiZWw9e2wuZHJhd2luZ190b29sc30+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgdGFiSW5kZXg9XCIwXCIgYXJpYS1sYWJlbD17bC5kcmF3X3Rvb2xzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10aXRsZT1cInNjcmliYmxlXCIgdGFiSW5kZXg9XCIwXCIgYXJpYS1sYWJlbD17bC5zY3JpYmJsZV90b29sfSB0aXRsZT17bC5zY3JpYmJsZX0gbmFtZT1cInByZXZpZXdfc2NyaWJibGVcIiBpZD1cInByZXZpZXdfc2NyaWJibGVcIiBjbGFzcz1cImdlb21ldHJ5VG9vbFByZXZpZXcgdG9vbHRpcF9idG4gYnRuIGJ0bi1saWdodCBwcmV2aWV3X3Rvb2xiYXIgcHJldmlld19idG5cIj48aSBjbGFzcz1cImljb21vb24tcGVuY2lsXCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXRpdGxlPVwibGluZVwiIHRhYkluZGV4PVwiMFwiIGFyaWEtbGFiZWw9e2wubGluZV90b29sfSB0aXRsZT17bC5saW5lfSBuYW1lPVwicHJldmlld19saW5lXCIgaWQ9XCJwcmV2aWV3X2xpbmVcIiBjbGFzcz1cImdlb21ldHJ5VG9vbFByZXZpZXcgYnRuIGJ0bi1saWdodCB0b29sdGlwX2J0biBwcmV2aWV3X3Rvb2xiYXIgcHJldmlld19idG5cIj4vPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtdGl0bGU9XCJjb21wYXNzXCIgdGFiSW5kZXg9XCIwXCIgYXJpYS1sYWJlbD17bC5jb21wYXNzX3Rvb2x9IHRpdGxlPXtsLmNvbXBhc3N9IG5hbWU9XCJwcmV2aWV3X2NvbXBhc3NcIiBpZD1cInByZXZpZXdfY29tcGFzc1wiIGNsYXNzPVwiZ2VvbWV0cnlUb29sUHJldmlldyB0b29sdGlwX2J0biBidG4gYnRuLWxpZ2h0IHByZXZpZXdfdG9vbGJhciBwcmV2aWV3X2J0blwiPjxpIGNsYXNzPVwiaWNvbW9vbi1jb21wYXNzMVwiPjwvaT48L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiB0YWJJbmRleD1cIjBcIiBhcmlhLWxhYmVsPXtsLnJlbW92aW5nX3Rvb2xzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10aXRsZT1cImVyYXNlclwiIHRhYkluZGV4PVwiMFwiIGFyaWEtbGFiZWw9e2wuZGVsZXRlX3Rvb2x9IHRpdGxlPXtsLmRlbGV0ZV90b29sfSBuYW1lPVwiZXJhc2VyXCIgaWQ9XCJwcmV2aWV3X2VyYXNlclwiIGNsYXNzPVwiYnRuIGJ0bi1saWdodCB0b29sdGlwX2J0biBwcmV2aWV3X3Rvb2xiYXIgcHJldmlld19idG5cIj48aSBjbGFzcz1cImljb21vb24tZGVsZXRlLXNtXCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiAgdGl0bGU9e2wuY2xlYXJfc2NyZWVufSB0YWJJbmRleD1cIjBcIiBhcmlhLWxhYmVsPXtsLmNsZWFyX3NjcmVlbn0gbmFtZT1cImNsZWFyU2NyZWVuXCIgaWQ9XCJwcmV2aWV3X2NsZWFyU2NyZWVuXCIgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIGNsYXNzPVwiYnRuIGJ0bi1saWdodCB0b29sdGlwX2J0blwiPjxpIGNsYXNzPVwiaWNvbW9vbi1jbG9zZS0yXCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiB0aXRsZT17bC5yZWRvfSBuYW1lPVwicmVkb1wiIHRhYkluZGV4PVwiMFwiIGFyaWEtbGFiZWw9e2wucmVkb30gaWQ9XCJwcmV2aWV3X3JlZG9cIiBkaXNhYmxlZD1cImRpc2FibGVkXCIgY2xhc3M9XCJidG4gYnRuLWxpZ2h0IHRvb2x0aXBfYnRuXCI+PGkgY2xhc3M9XCJpY29tb29uLXJlZG8tMlwiPjwvaT48L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgdGl0bGU9e2wudW5kb30gbmFtZT1cInVuZG9cIiB0YWJJbmRleD1cIjBcIiBhcmlhLWxhYmVsPXtsLnVuZG99IGlkPVwicHJldmlld191bmRvXCIgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIGNsYXNzPVwiYnRuIGJ0bi1saWdodCB0b29sdGlwX2J0blwiPjxpIGNsYXNzPVwiaWNvbW9vbi11bmRvLTJcIj48L2k+PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yIG1hcmtpbmdfZ3JvdXBcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPXtsLm1hcmtpbmdfdG9vbHN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiB0aXRsZT17bC5tYXJrX2ZpbmlzaF9wb2ludH0gbmFtZT1cIm1hcmtfcG9pbnRzXCIgdGFiSW5kZXg9XCIwXCIgYXJpYS1sYWJlbD17bC5tYXJrX2Fuc19wb2ludH0gaWQ9XCJtYXJrX3BvaW50c1wiIGNsYXNzPVwiYnRuIHRvb2x0aXBfYnRuIGJ0bi1saWdodFwiPntsLm1hcmtfcG50fTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMiByZXNldF9ncm91cFwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9e2wucmVzZXR9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiB0aXRsZT17bC5yZXNldH0gbmFtZT1cInByZXZpZXdfcmVzZXRfYnRuXCIgdGFiSW5kZXg9XCIwXCIgYXJpYS1sYWJlbD17bC5yZXNldF9idG59IGlkPVwicHJldmlld19yZXNldF9idG5cIiBjbGFzcz1cImJ0biB0b29sdGlwX2J0biBidG4tbGlnaHRcIj48aSBjbGFzcz1cImljb21vb24tbmV3LTI0cHgtcmVzZXQtMVwiPjwvaT48L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPXtsLnNob3J0Y3V0c30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIHRpdGxlPXtsLnNob3J0Y3V0c30gbmFtZT1cInNob3J0Y3V0X21vZGFsX2J0blwiIGFyaWEtbGFiZWw9e2wuc2hvcnRjdXRzfSB0YWJJbmRleD1cIjBcIiBpZD1cInNob3J0Y3V0X21vZGFsX2J0blwiIGNsYXNzPVwidG9vbHRpcF9idG4gYnRuIGJ0bi1wcmltYXJ5XCIgb246Y2xpY2s9e29wZW5TaG9ydGN1dH0+e2wuc2hvcnRjdXRzfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cImNlbnRlckltZ1wiIGNsYXNzPVwiY2VudGVySW1nIGNlbnRlckltZ1ByZXZpZXcgbXktYXV0byByZWxhdGl2ZSBtbC0wXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cImJvcmRlclwiIGFsdD1cIlwiIHNyYz17YmdJbWdQYXRoICsgc3RhdGUuYmdJbWd9IGlkPVwic3ZnSW1nUHJldmlld1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29tb29uLXBsdXMgczIgbW92ZV9pY29uIHBvc2l0aW9uLWFic29sdXRlIGhcIiBpZD1cIm1vdmVEcmF3SWNvblwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBpZD1cInByZXZpZXdTdmdcIiBjbGFzcz1cInByZXZpZXdLZXlTdmdcIiB0YWJJbmRleD1cIjBcIiBhcmlhLWxhYmVsbGVkYnk9XCJwcmV2aWV3U3ZnVGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRpdGxlIGlkPVwicHJldmlld1N2Z1RpdGxlXCI+e3N0YXRlLmFsdH08L3RpdGxlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cImJhY2tncm91bmRGb2N1c1BhdGhQcmV2aWV3XCI+PC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cInByZXZpZXdEcmF3aW5nUGF0aHNcIj48L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxnIGNsYXNzPVwiY29ycmVjdF9hbnN3ZXJfY29udGFpbmVyXCI+PC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cImJhY2tncm91bmRGb2N1c1BvaW50UHJldmlld1wiPjwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGcgY2xhc3M9XCJwcmV2aWV3TWFya2luZ1BhdGhzXCI+PC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzPVwiZHJhd2luZ0NvbXBhc3NTdmcgaFwiIGZvY3VzYWJsZT1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiZHJhd2luZ0NvbXBhc3NSb3V0ZSBjb21wYXNzX3JvdXRlXCIgY3g9XCIyNjcuOTg0Mzc1XCIgY3k9XCIxNzNcIiByPVwiODBcIiBmaWxsLW9wYWNpdHk9XCIwXCIgc3Ryb2tlPVwiI0M5QzlDOVwiIHN0cm9rZS1kYXNoYXJyYXk9XCIyLDEwXCIgc3Ryb2tlLXdpZHRoPVwiMlwiPjwvY2lyY2xlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIGNsYXNzPVwiY29tcGFzc1JvdGF0aW9uQmFyIGNvbXBhc3NfcmFkaXVzXCIgeDE9XCIyNjcuOTg0Mzc1XCIgeTE9XCIxNzNcIiB4Mj1cIjI2Ny45ODQzNzVcIiB5Mj1cIjI1M1wiIHN0cm9rZT1cIiNDOUM5QzlcIiBzdHJva2Utd2lkdGg9XCIyXCI+PC9saW5lPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgdGFiSW5kZXg9XCIwXCIgY2xhc3M9XCJkcmF3aW5nQ29tcGFzc0NlbnRlciBjb21wYXNzX2NlbnRlclwiIGN4PVwiMjY3Ljk4NDM3NVwiIGN5PVwiMTczXCIgcj1cIjE3XCIgYXJpYS1sYWJlbGxlZGJ5PVwiY29tcGFzc0NlbnRlclRpdGxlIGNvbXBhc3NDZW50ZXJEZXNjXCIgZm9jdXNhYmxlPVwidHJ1ZVwiIGZpbGw9XCJ1cmwoI3ByZXZpZXdEcmF3aW5nQ2VudGVyKVwiIHN0cm9rZT1cIiNDOUM5QzlcIj48L2NpcmNsZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aXRsZSBpZD1cImNvbXBhc3NDZW50ZXJUaXRsZVwiPntsLmNvbXBhc3NfY2VudGVyfTwvdGl0bGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGVzYyBpZD1cImNvbXBhc3NDZW50ZXJEZXNjXCI+e2wuc2hpZnRfYXJyb3dfdXNlfTwvZGVzYz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZWZzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXR0ZXJuIGlkPVwicHJldmlld0RyYXdpbmdDZW50ZXJcIiB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiBmaWxsPVwicmVkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMSAtMyAyMSAzNVwiIHdpZHRoPVwiMzNcIiBoZWlnaHQ9XCI0MVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiM4MDgwODBcIiBjbGFzcz1cInN0MFwiIGQ9XCJNMy4yMiwxNS4xTDEsMTJsMi4yMi0zLjFDMy4yMiwxMC45NywzLjIyLDEzLjAzLDMuMjIsMTUuMXpcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiM4MDgwODBcIiBjbGFzcz1cInN0MFwiIGQ9XCJNOC45LDMuMjJMMTIsMWwzLjEsMi4yMkMxMy4wMywzLjIyLDEwLjk3LDMuMjIsOC45LDMuMjJ6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjODA4MDgwXCIgY2xhc3M9XCJzdDBcIiBkPVwiTTE1LjEsMjAuNzhMMTIsMjNsLTMuMS0yLjIyQzEwLjk3LDIwLjc4LDEzLjAzLDIwLjc4LDE1LjEsMjAuNzh6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjODA4MDgwXCIgY2xhc3M9XCJzdDBcIiBkPVwiTTIwLjc4LDguOUwyMywxMmwtMi4yMiwzLjFDMjAuNzgsMTMuMDMsMjAuNzgsMTAuOTcsMjAuNzgsOC45elwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjJcIiBmaWxsPVwiIzMzMzMzM1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcGF0dGVybj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGVmcz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJjb21wYXNzX3JhZGl1c19pY29uIG1pZF9jaXJjbGVcIiBjeD1cIjI2Ny45ODQzNzVcIiBjeT1cIjIxM1wiIHI9XCIxN1wiIGZpbGw9XCJ1cmwoI3ByZXZpZXdEcmF3aW5nUmFkaXVzKVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCwxNjAsMTY4KVwiIGFyaWEtbGFiZWxsZWRieT1cImNvbXBhc3NSYWRpdXNUaXRsZSBjb21wYXNzUmFkaXVzRGVzY1wiIHRhYkluZGV4PVwiMFwiIGZvY3VzYWJsZT1cInRydWVcIiBzdHJva2U9XCIjQzlDOUM5XCI+PC9jaXJjbGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGl0bGUgaWQ9XCJjb21wYXNzUmFkaXVzVGl0bGVcIj57bC5jb21wYXNzX3JhZGl1cyArIChwcmV2aWV3Q29tcGFzc1JhZGl1cyAqIDAuMDI2NDkpLnRvRml4ZWQoMil9PC90aXRsZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZXNjIGlkPVwiY29tcGFzc1JhZGl1c0Rlc2NcIj57bC5zaGlmdF9hcnJvd19yYWRpdXN9PC9kZXNjPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRlZnM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdHRlcm4gaWQ9XCJwcmV2aWV3RHJhd2luZ1JhZGl1c1wiIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHg9XCIwcHhcIiB5PVwiMHB4XCIgdmlld0JveD1cIjEgLTUgMjEgMzRcIiB3aWR0aD1cIjMzXCIgaGVpZ2h0PVwiMzNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCB4PVwiOC41M1wiIHk9XCIxLjExXCIgd2lkdGg9XCIxLjVcIiBoZWlnaHQ9XCIyMS43OVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCB4PVwiMTMuOTdcIiB5PVwiMS4xMVwiIHdpZHRoPVwiMS41XCIgaGVpZ2h0PVwiMjEuNzlcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTUuODcsMTYuODdMMSwxMmw0Ljg3LTQuODdDNS44NywxMC4zOCw1Ljg3LDEzLjYyLDUuODcsMTYuODd6XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTguMTMsMTYuODdMMjMsMTJsLTQuODctNC44N0MxOC4xMywxMC4zOCwxOC4xMywxMy42MiwxOC4xMywxNi44N3pcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wYXR0ZXJuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZWZzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImNvbXBhc3Nfcm90YXRpb24gbWlkU21hbGxDaXJjbGVcIiBjeD1cIjI2Ny45ODQzNzVcIiBjeT1cIjIzM1wiIHI9XCI4XCIgZmlsbD1cInVybCgjcHJldmlld01pZFNtYWxsQ2lyY2xlX2ljb24pXCIgYXJlYS1sYWJlbD1cIkNvbXBhc3MgQW5nbGUgVXNlIFNoaWZ0IGFuZCBhcnJvdyBrZXlzIHRvIGluY3JlYXNlIG9yIGRlY3JlYXNlIHRoZSByYWRpdXNcIiBhcmlhLWxhYmVsbGVkYnk9XCJjb21wYXNzUm90YXRpb25UaXRsZSBjb21wYXNzUm90YXRpb25EZXNjXCIgdGFiSW5kZXg9XCIwXCIgZm9jdXNhYmxlPVwidHJ1ZVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCwxNjAsMTkzKVwiPjwvY2lyY2xlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRpdGxlIGlkPVwiY29tcGFzc1JvdGF0aW9uVGl0bGVcIj57bC5jb21wYXNzX2FuZ2xlICsgcHJldmlld0NvbXBhc3NBbmdsZSArIGwuZGVncmVlfTwvdGl0bGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGVzYyBpZD1cImNvbXBhc3NSb3RhdGlvbkRlc2NcIj57bC5zaGlmdF9hcnJvd19hbmdsZX08L2Rlc2M+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGVmcz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0dGVybiBpZD1cInByZXZpZXdNaWRTbWFsbENpcmNsZV9pY29uXCIgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIxNnB4XCIgaGVpZ2h0PVwiMTZweFwiIHZpZXdCb3g9XCIwIDAgMTQgMTRcIiB2ZXJzaW9uPVwiMS4xXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwiIzAwMFwiIG9wYWNpdHk9XCIwLjhcIiBkPVwiTTcsMTQgQzMuMTM0MDA2NzUsMTQgMCwxMC44NjU5OTMyIDAsNyBDMCwzLjEzNDAwNjc1IDMuMTM0MDA2NzUsMCA3LCAwIEMxMC44NjU5OTMyLDAgMTQsMy4xMzQwMDY3NSAxNCw3IEMxNCwxMC44NjU5OTMyIDEwLjg2NTk5MzIsMTQgNywgMTQgWiBNNC42NjY2NjY2Nyw4LjE2NjY2NjY3IEw3LDExLjY2NjY2NjcgTDkuMzMzMzMzMzMsOC4xNjY2NjY2NyBMNC42NjY2NjY2Nyw4LjE2NjY2NjY3IFogTTQuNjY2NjY2NjcsNS44MzMzMzMzMyBMOS4zMzMzMzMzMyw1LjgzMzMzMzMzIEw3LDIuMzMzMzMzMzMgTDQuNjY2NjY2NjcsNS44MzMzMzMzMyBaXCI+PC9wYXRoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3BhdHRlcm4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2RlZnM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGNsYXNzPVwiZHJhd2luZy1jb21wYXNzLXBvaW50ZXIgbGFzdENpcmNsZVwiIGN4PVwiMjY3Ljk4NDM3NVwiIGN5PVwiMjUzXCIgcj1cIjNcIiBmaWxsPXtzdGF0ZS5saW5lQ29sb3J9PjwvY2lyY2xlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImRyYXdpbmctY29tcGFzcy1wb2ludGVyLWJvcmRlciBsYXN0Q2lyY2xlIGxhc3RiaWdjaXJjbGVcIiBhcmlhLWxhYmVsbGVkYnk9XCJjb21wYXNzQW5nbGVUaXRsZSBjb21wYXNzQW5nbGVEZXNjXCIgY3g9XCIyNjcuOTg0Mzc1XCIgY3k9XCIyNTNcIiByPVwiMTdcIiB0YWJJbmRleD1cIjBcIiBmb2N1c2FibGU9XCJ0cnVlXCIgZmlsbC1vcGFjaXR5PVwiMFwiIHN0cm9rZT1cIiNDOUM5QzlcIj48L2NpcmNsZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aXRsZSBpZD1cImNvbXBhc3NBbmdsZVRpdGxlXCI+e2wuY29tcGFzc19kcmF3fTwvdGl0bGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGVzYyBpZD1cImNvbXBhc3NBbmdsZURlc2NcIj57bC5zaGlmdF9hcnJvd19kcmF3fTwvZGVzYz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJsYXN0Q2lyY2xlTWlkXCIgZmlsbD1cInVybCgjcHJldmlld0xhc3RDaXJjbGVNaWRfaWNvbilcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAsMTYwLDI0MylcIiBjeD1cIjI2Ny45ODQzNzVcIiBjeT1cIjI5M1wiIHI9XCIxMlwiIG9wYWNpdHk9XCIwXCI+PC9jaXJjbGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGVmcz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0dGVybiBpZD1cInByZXZpZXdMYXN0Q2lyY2xlTWlkX2ljb25cIiB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjNcIiB2aWV3Qm94PVwiMCAwIDExIDI3XCIgdmVyc2lvbj1cIjEuMVwiIGVuYWJsZUJhY2tncm91bmQ9XCJuZXcgMCAwIDggMjRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnIHN0cm9rZT1cIm5vbmVcIiBzdHJva2VXaWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIG9wYWNpdHk9XCIwLjVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTUxNi4wMDAwMDAsIC00NDUuMDAwMDAwKVwiIGZpbGw9XCIjMzMzMzMzXCIgZmlsbFJ1bGU9XCJub256ZXJvXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyMDcuMDAwMDAwLCAzMTguMDAwMDAwKVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDMxMy43NDI3MzcsIDE0MC41NzY1NjEpIHJvdGF0ZSgtMi4wMDAwMDApIHRyYW5zbGF0ZSgtMzEzLjc0MjczNywgLTE0MC41NzY1NjEpIHRyYW5zbGF0ZSgzMDguMjQyNzM3LCAxMjcuMDc2NTYxKVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMy43NjQ5MTI3NiwyMi40MzA5NzI3IEM1Ljg4MjA3MjcyLDE5LjkwMjU3OCA3LjEwODQzNDg3LCAxNi40NDc3MzYgNy4xMDg0MzQ4NywxMi43NDQ2MjgxIEM3LjEwODQzNDg3LDkuOTA1MzMwMzkgNi4zODk3NDEyOCwgNy4yMDE4ODk1OSA1LjA3NTQyNDAxLDQuOTM0NjQzMTkgTDEuNzEzMTY1NDcsNS42NzIyMTgwMSBMNC45MTAwOTA5LCAwLjQ4MzA1MTg4IEwxMC4xNzE5MTczLDMuODE2NjMxMzcgTDcuMTEzNTEwMDUsNC40ODc1NTA2NCBDOC40MDg4OTAyLCA2LjkzOTY2Njc3IDkuMTA4NDM0ODcsOS43ODE4MTM5NSA5LjEwODQzNDg3LDEyLjc0NDYyODEgQzkuMTA4NDM0ODcsIDE2LjY2Nzc1NTUgNy44NzgyNzg4MSwyMC4zNjM4MDE4IDUuNzEyNTA4NTcsMjMuMTk3MjgxMiBMOC42MzM4NTQyNSwgMjQuMzQ2NzI1MSBMMi45MzE2NTc3MSwyNi44MjU1NjI1IEwwLjU5NTI4NzA0NiwyMS4xODM4Mzk2IEwzLjc2NDkxMjc2LCAyMi40MzA5NzI3IFpcIiBjbGFzcz1cIlwiPjwvcGF0aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wYXR0ZXJuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZWZzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvY2VudGVyPlxyXG4gICAgPC9kaXY+XHJcbjwvbWFpbj4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBdXJFSSxLQUFLLGVBQUMsQ0FBQyxBQUNILFlBQVksQ0FBRSxLQUFLLENBQUMsVUFBVSxBQUNsQyxDQUFDLEFBQ0QsV0FBVyxlQUFDLENBQUMsQUFDVCxLQUFLLENBQUUsS0FBSyxDQUNaLE1BQU0sQ0FBRSxLQUFLLENBQ2IsV0FBVyxNQUFNLEFBQ3JCLENBQUMifQ== */";
	append_dev(document_1.head, style);
}

function create_fragment(ctx) {
	let main;
	let div17;
	let div16;
	let div15;
	let div0;
	let h4;
	let t1;
	let button0;
	let t3;
	let div13;
	let table;
	let tbody;
	let tr0;
	let td0;
	let td1;
	let div1;
	let span0;
	let t6;
	let tr1;
	let td2;
	let td3;
	let div2;
	let span1;
	let t9;
	let tr2;
	let td4;
	let td5;
	let div3;
	let span2;
	let t12;
	let tr3;
	let td6;
	let td7;
	let div4;
	let span3;
	let t15;
	let tr4;
	let td8;
	let td9;
	let div5;
	let span4;
	let t18;
	let tr5;
	let td10;
	let td11;
	let div6;
	let span5;
	let t21;
	let tr6;
	let td12;
	let td13;
	let div7;
	let span6;
	let t24;
	let tr7;
	let td14;
	let td15;
	let div8;
	let span7;
	let t27;
	let tr8;
	let td16;
	let td17;
	let div9;
	let span8;
	let t30;
	let tr9;
	let td18;
	let td19;
	let div10;
	let span9;
	let t33;
	let tr10;
	let td20;
	let td21;
	let div11;
	let span10;
	let t36;
	let tr11;
	let td22;
	let td23;
	let div12;
	let span11;
	let t39;
	let div14;
	let button1;
	let t41;
	let div28;
	let button2;
	let t42;
	let button3;
	let t43;
	let center;
	let div24;
	let div23;
	let div18;
	let button4;
	let i0;
	let button4_aria_label_value;
	let button4_title_value;
	let t44;
	let button5;
	let t45;
	let button5_aria_label_value;
	let button5_title_value;
	let t46;
	let button6;
	let i1;
	let button6_aria_label_value;
	let button6_title_value;
	let div18_aria_label_value;
	let t47;
	let div19;
	let button7;
	let i2;
	let button7_aria_label_value;
	let button7_title_value;
	let t48;
	let button8;
	let i3;
	let button8_title_value;
	let button8_aria_label_value;
	let t49;
	let button9;
	let i4;
	let button9_title_value;
	let button9_aria_label_value;
	let t50;
	let button10;
	let i5;
	let button10_title_value;
	let button10_aria_label_value;
	let div19_aria_label_value;
	let t51;
	let div20;
	let button11;
	let t52_value = Lang.mark_pnt + "";
	let t52;
	let button11_title_value;
	let button11_aria_label_value;
	let div20_aria_label_value;
	let t53;
	let div21;
	let button12;
	let i6;
	let button12_title_value;
	let button12_aria_label_value;
	let div21_aria_label_value;
	let t54;
	let div22;
	let button13;
	let t55_value = Lang.shortcuts + "";
	let t55;
	let button13_title_value;
	let button13_aria_label_value;
	let div22_aria_label_value;
	let div23_aria_label_value;
	let t56;
	let div27;
	let div26;
	let img;
	let img_src_value;
	let t57;
	let div25;
	let span12;
	let t58;
	let svg6;
	let title0;
	let t59_value = /*state*/ ctx[2].alt + "";
	let t59;
	let g0;
	let g1;
	let g2;
	let g3;
	let g4;
	let svg5;
	let svg4;
	let g21;
	let circle0;
	let g5;
	let line;
	let g6;
	let circle1;
	let title1;
	let t60_value = Lang.compass_center + "";
	let t60;
	let desc0;
	let t61_value = Lang.shift_arrow_use + "";
	let t61;
	let defs0;
	let pattern0;
	let svg0;
	let path0;
	let path1;
	let path2;
	let path3;
	let circle2;
	let g13;
	let circle3;
	let title2;
	let t62_value = Lang.compass_radius + (/*previewCompassRadius*/ ctx[0] * 0.02649).toFixed(2) + "";
	let t62;
	let desc1;
	let t63_value = Lang.shift_arrow_radius + "";
	let t63;
	let defs1;
	let pattern1;
	let svg1;
	let g9;
	let g7;
	let rect0;
	let g8;
	let rect1;
	let g12;
	let g10;
	let path4;
	let g11;
	let path5;
	let g14;
	let circle4;
	let title3;
	let t64_value = Lang.compass_angle + /*previewCompassAngle*/ ctx[1] + Lang.degree + "";
	let t64;
	let desc2;
	let t65_value = Lang.shift_arrow_angle + "";
	let t65;
	let defs2;
	let pattern2;
	let svg2;
	let path6;
	let g15;
	let circle5;
	let circle5_fill_value;
	let circle6;
	let title4;
	let t66_value = Lang.compass_draw + "";
	let t66;
	let desc3;
	let t67_value = Lang.shift_arrow_draw + "";
	let t67;
	let g20;
	let circle7;
	let defs3;
	let pattern3;
	let svg3;
	let g19;
	let g18;
	let g17;
	let g16;
	let path7;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			main = element("main");
			div17 = element("div");
			div16 = element("div");
			div15 = element("div");
			div0 = element("div");
			h4 = element("h4");
			h4.textContent = `${Lang.shortcuts}`;
			t1 = space();
			button0 = element("button");
			button0.textContent = "";
			t3 = space();
			div13 = element("div");
			table = element("table");
			tbody = element("tbody");
			tr0 = element("tr");
			td0 = element("td");
			td0.textContent = `${Lang.keys}`;
			td1 = element("td");
			div1 = element("div");
			span0 = element("span");
			span0.textContent = `${Lang.des_txt}`;
			t6 = space();
			tr1 = element("tr");
			td2 = element("td");
			td2.textContent = `${Lang.ctrl_z}`;
			td3 = element("td");
			div2 = element("div");
			span1 = element("span");
			span1.textContent = `${Lang.undo}`;
			t9 = space();
			tr2 = element("tr");
			td4 = element("td");
			td4.textContent = `${Lang.ctrl_x}`;
			td5 = element("td");
			div3 = element("div");
			span2 = element("span");
			span2.textContent = `${Lang.cut}`;
			t12 = space();
			tr3 = element("tr");
			td6 = element("td");
			td6.textContent = `${Lang.ctrl_y}`;
			td7 = element("td");
			div4 = element("div");
			span3 = element("span");
			span3.textContent = `${Lang.redo}`;
			t15 = space();
			tr4 = element("tr");
			td8 = element("td");
			td8.textContent = `${Lang.enter}`;
			td9 = element("td");
			div5 = element("div");
			span4 = element("span");
			span4.textContent = `${Lang.enable_tool}`;
			t18 = space();
			tr5 = element("tr");
			td10 = element("td");
			td10.textContent = `${Lang.shift_enter}`;
			td11 = element("td");
			div6 = element("div");
			span5 = element("span");
			span5.textContent = `${Lang.start_stop_tool}`;
			t21 = space();
			tr6 = element("tr");
			td12 = element("td");
			td12.textContent = `${Lang.shift_arrow}`;
			td13 = element("td");
			div7 = element("div");
			span6 = element("span");
			span6.textContent = `${Lang.compass_tools}`;
			t24 = space();
			tr7 = element("tr");
			td14 = element("td");
			td14.textContent = `${Lang.locking}`;
			td15 = element("td");
			div8 = element("div");
			span7 = element("span");
			span7.textContent = `${Lang.locking_txt}`;
			t27 = space();
			tr8 = element("tr");
			td16 = element("td");
			td16.textContent = `${Lang.draw_key}`;
			td17 = element("td");
			div9 = element("div");
			span8 = element("span");
			span8.textContent = `${Lang.draw_txt}`;
			t30 = space();
			tr9 = element("tr");
			td18 = element("td");
			td18.textContent = `${Lang.tab}`;
			td19 = element("td");
			div10 = element("div");
			span9 = element("span");
			span9.textContent = `${Lang.focus_next}`;
			t33 = space();
			tr10 = element("tr");
			td20 = element("td");
			td20.textContent = `${Lang.shift_tab}`;
			td21 = element("td");
			div11 = element("div");
			span10 = element("span");
			span10.textContent = `${Lang.focus_prev}`;
			t36 = space();
			tr11 = element("tr");
			td22 = element("td");
			td22.textContent = `${Lang.esc}`;
			td23 = element("td");
			div12 = element("div");
			span11 = element("span");
			span11.textContent = `${Lang.exit_txt}`;
			t39 = space();
			div14 = element("div");
			button1 = element("button");
			button1.textContent = `${Lang.close}`;
			t41 = space();
			div28 = element("div");
			button2 = element("button");
			t42 = space();
			button3 = element("button");
			t43 = space();
			center = element("center");
			div24 = element("div");
			div23 = element("div");
			div18 = element("div");
			button4 = element("button");
			i0 = element("i");
			t44 = space();
			button5 = element("button");
			t45 = text("/");
			t46 = space();
			button6 = element("button");
			i1 = element("i");
			t47 = space();
			div19 = element("div");
			button7 = element("button");
			i2 = element("i");
			t48 = space();
			button8 = element("button");
			i3 = element("i");
			t49 = space();
			button9 = element("button");
			i4 = element("i");
			t50 = space();
			button10 = element("button");
			i5 = element("i");
			t51 = space();
			div20 = element("div");
			button11 = element("button");
			t52 = text(t52_value);
			t53 = space();
			div21 = element("div");
			button12 = element("button");
			i6 = element("i");
			t54 = space();
			div22 = element("div");
			button13 = element("button");
			t55 = text(t55_value);
			t56 = space();
			div27 = element("div");
			div26 = element("div");
			img = element("img");
			t57 = space();
			div25 = element("div");
			span12 = element("span");
			t58 = space();
			svg6 = svg_element("svg");
			title0 = svg_element("title");
			t59 = text(t59_value);
			g0 = svg_element("g");
			g1 = svg_element("g");
			g2 = svg_element("g");
			g3 = svg_element("g");
			g4 = svg_element("g");
			svg5 = svg_element("svg");
			svg4 = svg_element("svg");
			g21 = svg_element("g");
			circle0 = svg_element("circle");
			g5 = svg_element("g");
			line = svg_element("line");
			g6 = svg_element("g");
			circle1 = svg_element("circle");
			title1 = svg_element("title");
			t60 = text(t60_value);
			desc0 = svg_element("desc");
			t61 = text(t61_value);
			defs0 = svg_element("defs");
			pattern0 = svg_element("pattern");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			circle2 = svg_element("circle");
			g13 = svg_element("g");
			circle3 = svg_element("circle");
			title2 = svg_element("title");
			t62 = text(t62_value);
			desc1 = svg_element("desc");
			t63 = text(t63_value);
			defs1 = svg_element("defs");
			pattern1 = svg_element("pattern");
			svg1 = svg_element("svg");
			g9 = svg_element("g");
			g7 = svg_element("g");
			rect0 = svg_element("rect");
			g8 = svg_element("g");
			rect1 = svg_element("rect");
			g12 = svg_element("g");
			g10 = svg_element("g");
			path4 = svg_element("path");
			g11 = svg_element("g");
			path5 = svg_element("path");
			g14 = svg_element("g");
			circle4 = svg_element("circle");
			title3 = svg_element("title");
			t64 = text(t64_value);
			desc2 = svg_element("desc");
			t65 = text(t65_value);
			defs2 = svg_element("defs");
			pattern2 = svg_element("pattern");
			svg2 = svg_element("svg");
			path6 = svg_element("path");
			g15 = svg_element("g");
			circle5 = svg_element("circle");
			circle6 = svg_element("circle");
			title4 = svg_element("title");
			t66 = text(t66_value);
			desc3 = svg_element("desc");
			t67 = text(t67_value);
			g20 = svg_element("g");
			circle7 = svg_element("circle");
			defs3 = svg_element("defs");
			pattern3 = svg_element("pattern");
			svg3 = svg_element("svg");
			g19 = svg_element("g");
			g18 = svg_element("g");
			g17 = svg_element("g");
			g16 = svg_element("g");
			path7 = svg_element("path");
			attr_dev(h4, "class", "modal-title");
			add_location(h4, file, 2246, 20, 133183);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "close");
			attr_dev(button0, "data-bs-dismiss", "modal");
			add_location(button0, file, 2247, 20, 133247);
			attr_dev(div0, "class", "modal-header");
			add_location(div0, file, 2245, 16, 133135);
			attr_dev(td0, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td0, file, 2254, 61, 133716);
			attr_dev(span0, "class", "pl-3 font-weight-bold");
			add_location(span0, file, 2254, 155, 133810);
			attr_dev(div1, "class", "d-flex");
			add_location(div1, file, 2254, 135, 133790);
			attr_dev(td1, "class", "py-1");
			add_location(td1, file, 2254, 118, 133773);
			attr_dev(tr0, "tabindex", "0");
			attr_dev(tr0, "role", "shortcut");
			add_location(tr0, file, 2254, 28, 133683);
			attr_dev(td2, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td2, file, 2255, 61, 133943);
			attr_dev(span1, "class", "pl-3");
			add_location(span1, file, 2255, 157, 134039);
			attr_dev(div2, "class", "d-flex");
			add_location(div2, file, 2255, 137, 134019);
			attr_dev(td3, "class", "py-1");
			add_location(td3, file, 2255, 120, 134002);
			attr_dev(tr1, "tabindex", "0");
			attr_dev(tr1, "role", "shortcut");
			add_location(tr1, file, 2255, 28, 133910);
			attr_dev(td4, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td4, file, 2256, 62, 134153);
			attr_dev(span2, "class", "pl-3");
			add_location(span2, file, 2256, 158, 134249);
			attr_dev(div3, "class", "d-flex");
			add_location(div3, file, 2256, 138, 134229);
			attr_dev(td5, "class", "py-1");
			add_location(td5, file, 2256, 121, 134212);
			attr_dev(tr2, "tabindex", "0");
			attr_dev(tr2, "role", "shortcut");
			add_location(tr2, file, 2256, 28, 134119);
			attr_dev(td6, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td6, file, 2257, 62, 134362);
			attr_dev(span3, "class", "pl-3");
			add_location(span3, file, 2257, 158, 134458);
			attr_dev(div4, "class", "d-flex");
			add_location(div4, file, 2257, 138, 134438);
			attr_dev(td7, "class", "py-1");
			add_location(td7, file, 2257, 121, 134421);
			attr_dev(tr3, "tabindex", "0");
			attr_dev(tr3, "role", "shortcut");
			add_location(tr3, file, 2257, 28, 134328);
			attr_dev(td8, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td8, file, 2258, 62, 134572);
			attr_dev(span4, "class", "pl-3");
			add_location(span4, file, 2258, 157, 134667);
			attr_dev(div5, "class", "d-flex");
			add_location(div5, file, 2258, 137, 134647);
			attr_dev(td9, "class", "py-1");
			add_location(td9, file, 2258, 120, 134630);
			attr_dev(tr4, "tabindex", "0");
			attr_dev(tr4, "role", "shortcut");
			add_location(tr4, file, 2258, 28, 134538);
			attr_dev(td10, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td10, file, 2259, 62, 134788);
			attr_dev(span5, "class", "pl-3");
			add_location(span5, file, 2259, 163, 134889);
			attr_dev(div6, "class", "d-flex");
			add_location(div6, file, 2259, 143, 134869);
			attr_dev(td11, "class", "py-1");
			add_location(td11, file, 2259, 126, 134852);
			attr_dev(tr5, "tabindex", "0");
			attr_dev(tr5, "role", "shortcut");
			add_location(tr5, file, 2259, 28, 134754);
			attr_dev(td12, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td12, file, 2260, 62, 135014);
			attr_dev(span6, "class", "pl-3");
			add_location(span6, file, 2260, 163, 135115);
			attr_dev(div7, "class", "d-flex");
			add_location(div7, file, 2260, 143, 135095);
			attr_dev(td13, "class", "py-1");
			add_location(td13, file, 2260, 126, 135078);
			attr_dev(tr6, "tabindex", "0");
			attr_dev(tr6, "role", "shortcut");
			add_location(tr6, file, 2260, 28, 134980);
			attr_dev(td14, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td14, file, 2261, 62, 135238);
			attr_dev(span7, "class", "pl-3");
			add_location(span7, file, 2261, 159, 135335);
			attr_dev(div8, "class", "d-flex");
			add_location(div8, file, 2261, 139, 135315);
			attr_dev(td15, "class", "py-1");
			add_location(td15, file, 2261, 122, 135298);
			attr_dev(tr7, "tabindex", "0");
			attr_dev(tr7, "role", "shortcut");
			add_location(tr7, file, 2261, 28, 135204);
			attr_dev(td16, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td16, file, 2262, 62, 135456);
			attr_dev(span8, "class", "pl-3");
			add_location(span8, file, 2262, 160, 135554);
			attr_dev(div9, "class", "d-flex");
			add_location(div9, file, 2262, 140, 135534);
			attr_dev(td17, "class", "py-1");
			add_location(td17, file, 2262, 123, 135517);
			attr_dev(tr8, "tabindex", "0");
			attr_dev(tr8, "role", "shortcut");
			add_location(tr8, file, 2262, 28, 135422);
			attr_dev(td18, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td18, file, 2263, 62, 135672);
			attr_dev(span9, "class", "pl-3");
			add_location(span9, file, 2263, 155, 135765);
			attr_dev(div10, "class", "d-flex");
			add_location(div10, file, 2263, 135, 135745);
			attr_dev(td19, "class", "py-1");
			add_location(td19, file, 2263, 118, 135728);
			attr_dev(tr9, "tabindex", "0");
			attr_dev(tr9, "role", "shortcut");
			add_location(tr9, file, 2263, 28, 135638);
			attr_dev(td20, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td20, file, 2264, 62, 135885);
			attr_dev(span10, "class", "pl-3");
			add_location(span10, file, 2264, 161, 135984);
			attr_dev(div11, "class", "d-flex");
			add_location(div11, file, 2264, 141, 135964);
			attr_dev(td21, "class", "py-1");
			add_location(td21, file, 2264, 124, 135947);
			attr_dev(tr10, "tabindex", "0");
			attr_dev(tr10, "role", "shortcut");
			add_location(tr10, file, 2264, 28, 135851);
			attr_dev(td22, "class", "py-1 font-weight-bold w-50 pr-0");
			add_location(td22, file, 2265, 62, 136104);
			attr_dev(span11, "class", "pl-3");
			add_location(span11, file, 2265, 155, 136197);
			attr_dev(div12, "class", "d-flex");
			add_location(div12, file, 2265, 135, 136177);
			attr_dev(td23, "class", "py-1");
			add_location(td23, file, 2265, 118, 136160);
			attr_dev(tr11, "tabindex", "0");
			attr_dev(tr11, "role", "shortcut");
			add_location(tr11, file, 2265, 28, 136070);
			attr_dev(tbody, "tabindex", "0");
			attr_dev(tbody, "role", "shortcut");
			add_location(tbody, file, 2253, 24, 133617);
			attr_dev(table, "role", "shortcut");
			attr_dev(table, "class", "shortcutTable m-0 p-2 border-0 common-shortcut-table table-striped font15");
			add_location(table, file, 2252, 20, 133486);
			attr_dev(div13, "class", "modal-body overflow-y");
			add_location(div13, file, 2249, 16, 133365);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-light");
			attr_dev(button1, "data-bs-dismiss", "modal");
			add_location(button1, file, 2270, 20, 136405);
			attr_dev(div14, "class", "modal-footer");
			add_location(div14, file, 2269, 16, 136357);
			attr_dev(div15, "class", "modal-content");
			add_location(div15, file, 2244, 12, 133090);
			attr_dev(div16, "class", "modal-dialog modal-dialog-centered");
			add_location(div16, file, 2243, 8, 133028);
			attr_dev(div17, "id", "drawing_shortcut_modal");
			attr_dev(div17, "class", "modal fade");
			attr_dev(div17, "tabindex", "-1");
			add_location(div17, file, 2242, 4, 132952);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "class", "h h-imp");
			attr_dev(button2, "id", "set-review");
			add_location(button2, file, 2276, 8, 136617);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "class", "h h-imp");
			attr_dev(button3, "id", "unset-review");
			add_location(button3, file, 2277, 8, 136690);
			attr_dev(i0, "class", "icomoon-pencil");
			add_location(i0, file, 2282, 257, 137330);
			attr_dev(button4, "type", "button");
			attr_dev(button4, "data-title", "scribble");
			attr_dev(button4, "tabindex", "0");
			attr_dev(button4, "aria-label", button4_aria_label_value = Lang.scribble_tool);
			attr_dev(button4, "title", button4_title_value = Lang.scribble);
			attr_dev(button4, "name", "preview_scribble");
			attr_dev(button4, "id", "preview_scribble");
			attr_dev(button4, "class", "geometryToolPreview tooltip_btn btn btn-light preview_toolbar preview_btn");
			add_location(button4, file, 2282, 24, 137097);
			attr_dev(button5, "type", "button");
			attr_dev(button5, "data-title", "line");
			attr_dev(button5, "tabindex", "0");
			attr_dev(button5, "aria-label", button5_aria_label_value = Lang.line_tool);
			attr_dev(button5, "title", button5_title_value = Lang.line);
			attr_dev(button5, "name", "preview_line");
			attr_dev(button5, "id", "preview_line");
			attr_dev(button5, "class", "geometryToolPreview btn btn-light tooltip_btn preview_toolbar preview_btn");
			add_location(button5, file, 2283, 24, 137395);
			attr_dev(i1, "class", "icomoon-compass1");
			add_location(i1, file, 2284, 252, 137872);
			attr_dev(button6, "type", "button");
			attr_dev(button6, "data-title", "compass");
			attr_dev(button6, "tabindex", "0");
			attr_dev(button6, "aria-label", button6_aria_label_value = Lang.compass_tool);
			attr_dev(button6, "title", button6_title_value = Lang.compass);
			attr_dev(button6, "name", "preview_compass");
			attr_dev(button6, "id", "preview_compass");
			attr_dev(button6, "class", "geometryToolPreview tooltip_btn btn btn-light preview_toolbar preview_btn");
			add_location(button6, file, 2284, 24, 137644);
			attr_dev(div18, "class", "btn-group mr-2 svelte-1tmjbvw");
			attr_dev(div18, "role", "group");
			attr_dev(div18, "tabindex", "0");
			attr_dev(div18, "aria-label", div18_aria_label_value = Lang.draw_tools);
			add_location(div18, file, 2281, 20, 136991);
			attr_dev(i2, "class", "icomoon-delete-sm");
			add_location(i2, file, 2287, 224, 138273);
			attr_dev(button7, "type", "button");
			attr_dev(button7, "data-title", "eraser");
			attr_dev(button7, "tabindex", "0");
			attr_dev(button7, "aria-label", button7_aria_label_value = Lang.delete_tool);
			attr_dev(button7, "title", button7_title_value = Lang.delete_tool);
			attr_dev(button7, "name", "eraser");
			attr_dev(button7, "id", "preview_eraser");
			attr_dev(button7, "class", "btn btn-light tooltip_btn preview_toolbar preview_btn");
			add_location(button7, file, 2287, 24, 138073);
			attr_dev(i3, "class", "icomoon-close-2");
			add_location(i3, file, 2288, 209, 138526);
			attr_dev(button8, "type", "button");
			attr_dev(button8, "title", button8_title_value = Lang.clear_screen);
			attr_dev(button8, "tabindex", "0");
			attr_dev(button8, "aria-label", button8_aria_label_value = Lang.clear_screen);
			attr_dev(button8, "name", "clearScreen");
			attr_dev(button8, "id", "preview_clearScreen");
			button8.disabled = "disabled";
			attr_dev(button8, "class", "btn btn-light tooltip_btn");
			add_location(button8, file, 2288, 24, 138341);
			attr_dev(i4, "class", "icomoon-redo-2");
			add_location(i4, file, 2289, 178, 138746);
			attr_dev(button9, "type", "button");
			attr_dev(button9, "title", button9_title_value = Lang.redo);
			attr_dev(button9, "name", "redo");
			attr_dev(button9, "tabindex", "0");
			attr_dev(button9, "aria-label", button9_aria_label_value = Lang.redo);
			attr_dev(button9, "id", "preview_redo");
			button9.disabled = "disabled";
			attr_dev(button9, "class", "btn btn-light tooltip_btn");
			add_location(button9, file, 2289, 24, 138592);
			attr_dev(i5, "class", "icomoon-undo-2");
			add_location(i5, file, 2290, 178, 138965);
			attr_dev(button10, "type", "button");
			attr_dev(button10, "title", button10_title_value = Lang.undo);
			attr_dev(button10, "name", "undo");
			attr_dev(button10, "tabindex", "0");
			attr_dev(button10, "aria-label", button10_aria_label_value = Lang.undo);
			attr_dev(button10, "id", "preview_undo");
			button10.disabled = "disabled";
			attr_dev(button10, "class", "btn btn-light tooltip_btn");
			add_location(button10, file, 2290, 24, 138811);
			attr_dev(div19, "class", "btn-group mr-2 svelte-1tmjbvw");
			attr_dev(div19, "role", "group");
			attr_dev(div19, "tabindex", "0");
			attr_dev(div19, "aria-label", div19_aria_label_value = Lang.removing_tools);
			add_location(div19, file, 2286, 20, 137963);
			attr_dev(button11, "type", "button");
			attr_dev(button11, "title", button11_title_value = Lang.mark_finish_point);
			attr_dev(button11, "name", "mark_points");
			attr_dev(button11, "tabindex", "0");
			attr_dev(button11, "aria-label", button11_aria_label_value = Lang.mark_ans_point);
			attr_dev(button11, "id", "mark_points");
			attr_dev(button11, "class", "btn tooltip_btn btn-light");
			add_location(button11, file, 2293, 24, 139164);
			attr_dev(div20, "class", "btn-group mr-2 marking_group svelte-1tmjbvw");
			attr_dev(div20, "role", "group");
			attr_dev(div20, "aria-label", div20_aria_label_value = Lang.marking_tools);
			add_location(div20, file, 2292, 20, 139054);
			attr_dev(i6, "class", "icomoon-new-24px-reset-1");
			add_location(i6, file, 2296, 182, 139656);
			attr_dev(button12, "type", "button");
			attr_dev(button12, "title", button12_title_value = Lang.reset);
			attr_dev(button12, "name", "preview_reset_btn");
			attr_dev(button12, "tabindex", "0");
			attr_dev(button12, "aria-label", button12_aria_label_value = Lang.reset_btn);
			attr_dev(button12, "id", "preview_reset_btn");
			attr_dev(button12, "class", "btn tooltip_btn btn-light");
			add_location(button12, file, 2296, 24, 139498);
			attr_dev(div21, "class", "btn-group mr-2 reset_group svelte-1tmjbvw");
			attr_dev(div21, "role", "group");
			attr_dev(div21, "aria-label", div21_aria_label_value = Lang.reset);
			add_location(div21, file, 2295, 20, 139398);
			attr_dev(button13, "type", "button");
			attr_dev(button13, "title", button13_title_value = Lang.shortcuts);
			attr_dev(button13, "name", "shortcut_modal_btn");
			attr_dev(button13, "aria-label", button13_aria_label_value = Lang.shortcuts);
			attr_dev(button13, "tabindex", "0");
			attr_dev(button13, "id", "shortcut_modal_btn");
			attr_dev(button13, "class", "tooltip_btn btn btn-primary");
			add_location(button13, file, 2299, 24, 139847);
			attr_dev(div22, "class", "btn-group mr-2 svelte-1tmjbvw");
			attr_dev(div22, "role", "group");
			attr_dev(div22, "aria-label", div22_aria_label_value = Lang.shortcuts);
			add_location(div22, file, 2298, 20, 139755);
			attr_dev(div23, "class", "btn-toolbar preview_drawing_toolbar");
			attr_dev(div23, "role", "toolbar");
			attr_dev(div23, "aria-label", div23_aria_label_value = Lang.drawing_tools);
			add_location(div23, file, 2280, 16, 136876);
			attr_dev(div24, "class", "mt-2 mb-3 previewBtnGrp");
			add_location(div24, file, 2279, 12, 136821);
			attr_dev(img, "class", "border");
			attr_dev(img, "alt", "");
			if (img.src !== (img_src_value = /*bgImgPath*/ ctx[3] + /*state*/ ctx[2].bgImg)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "id", "svgImgPreview");
			add_location(img, file, 2305, 20, 140267);
			attr_dev(span12, "class", "icomoon-plus s2 move_icon position-absolute h");
			attr_dev(span12, "id", "moveDrawIcon");
			add_location(span12, file, 2307, 24, 140398);
			add_location(div25, file, 2306, 20, 140367);
			attr_dev(title0, "id", "previewSvgTitle");
			add_location(title0, file, 2310, 24, 140676);
			attr_dev(g0, "class", "backgroundFocusPathPreview");
			add_location(g0, file, 2311, 24, 140749);
			attr_dev(g1, "class", "previewDrawingPaths");
			add_location(g1, file, 2312, 24, 140817);
			attr_dev(g2, "class", "correct_answer_container");
			add_location(g2, file, 2313, 24, 140878);
			attr_dev(g3, "class", "backgroundFocusPointPreview");
			add_location(g3, file, 2314, 24, 140944);
			attr_dev(g4, "class", "previewMarkingPaths");
			add_location(g4, file, 2315, 24, 141013);
			attr_dev(circle0, "class", "drawingCompassRoute compass_route");
			attr_dev(circle0, "cx", "267.984375");
			attr_dev(circle0, "cy", "173");
			attr_dev(circle0, "r", "80");
			attr_dev(circle0, "fill-opacity", "0");
			attr_dev(circle0, "stroke", "#C9C9C9");
			attr_dev(circle0, "stroke-dasharray", "2,10");
			attr_dev(circle0, "stroke-width", "2");
			add_location(circle0, file, 2319, 36, 141235);
			attr_dev(line, "class", "compassRotationBar compass_radius");
			attr_dev(line, "x1", "267.984375");
			attr_dev(line, "y1", "173");
			attr_dev(line, "x2", "267.984375");
			attr_dev(line, "y2", "253");
			attr_dev(line, "stroke", "#C9C9C9");
			attr_dev(line, "stroke-width", "2");
			add_location(line, file, 2321, 40, 141484);
			add_location(g5, file, 2320, 36, 141439);
			attr_dev(circle1, "tabindex", "0");
			attr_dev(circle1, "class", "drawingCompassCenter compass_center");
			attr_dev(circle1, "cx", "267.984375");
			attr_dev(circle1, "cy", "173");
			attr_dev(circle1, "r", "17");
			attr_dev(circle1, "aria-labelledby", "compassCenterTitle compassCenterDesc");
			attr_dev(circle1, "focusable", "true");
			attr_dev(circle1, "fill", "url(#previewDrawingCenter)");
			attr_dev(circle1, "stroke", "#C9C9C9");
			add_location(circle1, file, 2324, 40, 141749);
			attr_dev(title1, "id", "compassCenterTitle");
			add_location(title1, file, 2325, 40, 142020);
			attr_dev(desc0, "id", "compassCenterDesc");
			add_location(desc0, file, 2326, 40, 142119);
			attr_dev(path0, "fill", "#808080");
			attr_dev(path0, "class", "st0");
			attr_dev(path0, "d", "M3.22,15.1L1,12l2.22-3.1C3.22,10.97,3.22,13.03,3.22,15.1z");
			add_location(path0, file, 2330, 52, 142506);
			attr_dev(path1, "fill", "#808080");
			attr_dev(path1, "class", "st0");
			attr_dev(path1, "d", "M8.9,3.22L12,1l3.1,2.22C13.03,3.22,10.97,3.22,8.9,3.22z");
			add_location(path1, file, 2331, 52, 142657);
			attr_dev(path2, "fill", "#808080");
			attr_dev(path2, "class", "st0");
			attr_dev(path2, "d", "M15.1,20.78L12,23l-3.1-2.22C10.97,20.78,13.03,20.78,15.1,20.78z");
			add_location(path2, file, 2332, 52, 142806);
			attr_dev(path3, "fill", "#808080");
			attr_dev(path3, "class", "st0");
			attr_dev(path3, "d", "M20.78,8.9L23,12l-2.22,3.1C20.78,13.03,20.78,10.97,20.78,8.9z");
			add_location(path3, file, 2333, 52, 142963);
			attr_dev(circle2, "cx", "12");
			attr_dev(circle2, "cy", "12");
			attr_dev(circle2, "r", "2");
			attr_dev(circle2, "fill", "#333333");
			add_location(circle2, file, 2334, 52, 143118);
			attr_dev(svg0, "x", "0px");
			attr_dev(svg0, "y", "0px");
			attr_dev(svg0, "viewBox", "1 -3 21 35");
			attr_dev(svg0, "width", "33");
			attr_dev(svg0, "height", "41");
			add_location(svg0, file, 2329, 48, 142387);
			attr_dev(pattern0, "id", "previewDrawingCenter");
			attr_dev(pattern0, "width", "20");
			attr_dev(pattern0, "height", "20");
			attr_dev(pattern0, "fill", "red");
			add_location(pattern0, file, 2328, 44, 142268);
			add_location(defs0, file, 2327, 40, 142216);
			add_location(g6, file, 2323, 36, 141703);
			attr_dev(circle3, "class", "compass_radius_icon mid_circle");
			attr_dev(circle3, "cx", "267.984375");
			attr_dev(circle3, "cy", "213");
			attr_dev(circle3, "r", "17");
			attr_dev(circle3, "fill", "url(#previewDrawingRadius)");
			attr_dev(circle3, "transform", "rotate(90,160,168)");
			attr_dev(circle3, "aria-labelledby", "compassRadiusTitle compassRadiusDesc");
			attr_dev(circle3, "tabindex", "0");
			attr_dev(circle3, "focusable", "true");
			attr_dev(circle3, "stroke", "#C9C9C9");
			add_location(circle3, file, 2340, 40, 143451);
			attr_dev(title2, "id", "compassRadiusTitle");
			add_location(title2, file, 2341, 40, 143748);
			attr_dev(desc1, "id", "compassRadiusDesc");
			add_location(desc1, file, 2342, 40, 143893);
			attr_dev(rect0, "x", "8.53");
			attr_dev(rect0, "y", "1.11");
			attr_dev(rect0, "width", "1.5");
			attr_dev(rect0, "height", "21.79");
			add_location(rect0, file, 2348, 60, 144398);
			add_location(g7, file, 2347, 56, 144333);
			attr_dev(rect1, "x", "13.97");
			attr_dev(rect1, "y", "1.11");
			attr_dev(rect1, "width", "1.5");
			attr_dev(rect1, "height", "21.79");
			add_location(rect1, file, 2351, 60, 144636);
			add_location(g8, file, 2350, 56, 144571);
			add_location(g9, file, 2346, 52, 144272);
			attr_dev(path4, "d", "M5.87,16.87L1,12l4.87-4.87C5.87,10.38,5.87,13.62,5.87,16.87z");
			add_location(path4, file, 2356, 60, 144990);
			add_location(g10, file, 2355, 56, 144925);
			attr_dev(path5, "d", "M18.13,16.87L23,12l-4.87-4.87C18.13,10.38,18.13,13.62,18.13,16.87z");
			add_location(path5, file, 2359, 60, 145248);
			add_location(g11, file, 2358, 56, 145183);
			add_location(g12, file, 2354, 52, 144864);
			attr_dev(svg1, "x", "0px");
			attr_dev(svg1, "y", "0px");
			attr_dev(svg1, "viewBox", "1 -5 21 34");
			attr_dev(svg1, "width", "33");
			attr_dev(svg1, "height", "33");
			add_location(svg1, file, 2345, 48, 144153);
			attr_dev(pattern1, "id", "previewDrawingRadius");
			attr_dev(pattern1, "width", "20");
			attr_dev(pattern1, "height", "20");
			add_location(pattern1, file, 2344, 44, 144045);
			add_location(defs1, file, 2343, 40, 143993);
			add_location(g13, file, 2339, 36, 143406);
			attr_dev(circle4, "class", "compass_rotation midSmallCircle");
			attr_dev(circle4, "cx", "267.984375");
			attr_dev(circle4, "cy", "233");
			attr_dev(circle4, "r", "8");
			attr_dev(circle4, "fill", "url(#previewMidSmallCircle_icon)");
			attr_dev(circle4, "area-label", "Compass Angle Use Shift and arrow keys to increase or decrease the radius");
			attr_dev(circle4, "aria-labelledby", "compassRotationTitle compassRotationDesc");
			attr_dev(circle4, "tabindex", "0");
			attr_dev(circle4, "focusable", "true");
			attr_dev(circle4, "transform", "rotate(90,160,193)");
			add_location(circle4, file, 2367, 40, 145733);
			attr_dev(title3, "id", "compassRotationTitle");
			add_location(title3, file, 2368, 40, 146110);
			attr_dev(desc2, "id", "compassRotationDesc");
			add_location(desc2, file, 2369, 40, 146243);
			attr_dev(path6, "fill", "#000");
			attr_dev(path6, "opacity", "0.8");
			attr_dev(path6, "d", "M7,14 C3.13400675,14 0,10.8659932 0,7 C0,3.13400675 3.13400675,0 7, 0 C10.8659932,0 14,3.13400675 14,7 C14,10.8659932 10.8659932,14 7, 14 Z M4.66666667,8.16666667 L7,11.6666667 L9.33333333,8.16666667 L4.66666667,8.16666667 Z M4.66666667,5.83333333 L9.33333333,5.83333333 L7,2.33333333 L4.66666667,5.83333333 Z");
			add_location(path6, file, 2373, 52, 146630);
			attr_dev(svg2, "width", "16px");
			attr_dev(svg2, "height", "16px");
			attr_dev(svg2, "viewBox", "0 0 14 14");
			attr_dev(svg2, "version", "1.1");
			add_location(svg2, file, 2372, 48, 146510);
			attr_dev(pattern2, "id", "previewMidSmallCircle_icon");
			attr_dev(pattern2, "width", "20");
			attr_dev(pattern2, "height", "20");
			add_location(pattern2, file, 2371, 44, 146396);
			add_location(defs2, file, 2370, 40, 146344);
			add_location(g14, file, 2366, 36, 145688);
			attr_dev(circle5, "class", "drawing-compass-pointer lastCircle");
			attr_dev(circle5, "cx", "267.984375");
			attr_dev(circle5, "cy", "253");
			attr_dev(circle5, "r", "3");
			attr_dev(circle5, "fill", circle5_fill_value = /*state*/ ctx[2].lineColor);
			add_location(circle5, file, 2379, 40, 147269);
			attr_dev(circle6, "class", "drawing-compass-pointer-border lastCircle lastbigcircle");
			attr_dev(circle6, "aria-labelledby", "compassAngleTitle compassAngleDesc");
			attr_dev(circle6, "cx", "267.984375");
			attr_dev(circle6, "cy", "253");
			attr_dev(circle6, "r", "17");
			attr_dev(circle6, "tabindex", "0");
			attr_dev(circle6, "focusable", "true");
			attr_dev(circle6, "fill-opacity", "0");
			attr_dev(circle6, "stroke", "#C9C9C9");
			add_location(circle6, file, 2380, 40, 147425);
			attr_dev(title4, "id", "compassAngleTitle");
			add_location(title4, file, 2381, 40, 147697);
			attr_dev(desc3, "id", "compassAngleDesc");
			add_location(desc3, file, 2382, 40, 147793);
			add_location(g15, file, 2378, 36, 147224);
			attr_dev(circle7, "class", "lastCircleMid");
			attr_dev(circle7, "fill", "url(#previewLastCircleMid_icon)");
			attr_dev(circle7, "transform", "rotate(90,160,243)");
			attr_dev(circle7, "cx", "267.984375");
			attr_dev(circle7, "cy", "293");
			attr_dev(circle7, "r", "12");
			attr_dev(circle7, "opacity", "0");
			add_location(circle7, file, 2385, 40, 147973);
			attr_dev(path7, "d", "M3.76491276,22.4309727 C5.88207272,19.902578 7.10843487, 16.447736 7.10843487,12.7446281 C7.10843487,9.90533039 6.38974128, 7.20188959 5.07542401,4.93464319 L1.71316547,5.67221801 L4.9100909, 0.48305188 L10.1719173,3.81663137 L7.11351005,4.48755064 C8.4088902, 6.93966677 9.10843487,9.78181395 9.10843487,12.7446281 C9.10843487, 16.6677555 7.87827881,20.3638018 5.71250857,23.1972812 L8.63385425, 24.3467251 L2.93165771,26.8255625 L0.595287046,21.1838396 L3.76491276, 22.4309727 Z");
			attr_dev(path7, "class", "");
			add_location(path7, file, 2393, 68, 149086);
			attr_dev(g16, "transform", "translate(313.742737, 140.576561) rotate(-2.000000) translate(-313.742737, -140.576561) translate(308.242737, 127.076561)");
			add_location(g16, file, 2392, 64, 148879);
			attr_dev(g17, "transform", "translate(207.000000, 318.000000)");
			add_location(g17, file, 2391, 60, 148764);
			attr_dev(g18, "transform", "translate(-516.000000, -445.000000)");
			attr_dev(g18, "fill", "#333333");
			attr_dev(g18, "fillrule", "nonzero");
			add_location(g18, file, 2390, 56, 148617);
			attr_dev(g19, "stroke", "none");
			attr_dev(g19, "strokewidth", "1");
			attr_dev(g19, "fill", "none");
			attr_dev(g19, "fillrule", "evenodd");
			attr_dev(g19, "opacity", "0.5");
			add_location(g19, file, 2389, 52, 148481);
			attr_dev(svg3, "width", "24");
			attr_dev(svg3, "height", "23");
			attr_dev(svg3, "viewBox", "0 0 11 27");
			attr_dev(svg3, "version", "1.1");
			attr_dev(svg3, "enablebackground", "new 0 0 8 24");
			add_location(svg3, file, 2388, 48, 148333);
			attr_dev(pattern3, "id", "previewLastCircleMid_icon");
			attr_dev(pattern3, "width", "20");
			attr_dev(pattern3, "height", "20");
			add_location(pattern3, file, 2387, 44, 148220);
			add_location(defs3, file, 2386, 40, 148168);
			add_location(g20, file, 2384, 36, 147928);
			add_location(g21, file, 2318, 32, 141194);
			add_location(svg4, file, 2317, 28, 141155);
			attr_dev(svg5, "class", "drawingCompassSvg h");
			attr_dev(svg5, "focusable", "false");
			add_location(svg5, file, 2316, 24, 141074);
			attr_dev(svg6, "width", "100%");
			attr_dev(svg6, "height", "100%");
			attr_dev(svg6, "id", "previewSvg");
			attr_dev(svg6, "class", "previewKeySvg svelte-1tmjbvw");
			attr_dev(svg6, "tabindex", "0");
			attr_dev(svg6, "aria-labelledby", "previewSvgTitle");
			add_location(svg6, file, 2309, 20, 140533);
			attr_dev(div26, "id", "centerImg");
			attr_dev(div26, "class", "centerImg centerImgPreview my-auto relative ml-0");
			add_location(div26, file, 2304, 16, 140168);
			add_location(div27, file, 2303, 12, 140145);
			attr_dev(center, "class", "preview_drawing_container");
			add_location(center, file, 2278, 8, 136765);
			attr_dev(div28, "class", "drawing_module_container");
			add_location(div28, file, 2275, 4, 136569);
			attr_dev(main, "id", "drawingPreviewMain");
			add_location(main, file, 2241, 0, 132916);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div17);
			append_dev(div17, div16);
			append_dev(div16, div15);
			append_dev(div15, div0);
			append_dev(div0, h4);
			append_dev(div0, t1);
			append_dev(div0, button0);
			append_dev(div15, t3);
			append_dev(div15, div13);
			append_dev(div13, table);
			append_dev(table, tbody);
			append_dev(tbody, tr0);
			append_dev(tr0, td0);
			append_dev(tr0, td1);
			append_dev(td1, div1);
			append_dev(div1, span0);
			append_dev(tbody, t6);
			append_dev(tbody, tr1);
			append_dev(tr1, td2);
			append_dev(tr1, td3);
			append_dev(td3, div2);
			append_dev(div2, span1);
			append_dev(tbody, t9);
			append_dev(tbody, tr2);
			append_dev(tr2, td4);
			append_dev(tr2, td5);
			append_dev(td5, div3);
			append_dev(div3, span2);
			append_dev(tbody, t12);
			append_dev(tbody, tr3);
			append_dev(tr3, td6);
			append_dev(tr3, td7);
			append_dev(td7, div4);
			append_dev(div4, span3);
			append_dev(tbody, t15);
			append_dev(tbody, tr4);
			append_dev(tr4, td8);
			append_dev(tr4, td9);
			append_dev(td9, div5);
			append_dev(div5, span4);
			append_dev(tbody, t18);
			append_dev(tbody, tr5);
			append_dev(tr5, td10);
			append_dev(tr5, td11);
			append_dev(td11, div6);
			append_dev(div6, span5);
			append_dev(tbody, t21);
			append_dev(tbody, tr6);
			append_dev(tr6, td12);
			append_dev(tr6, td13);
			append_dev(td13, div7);
			append_dev(div7, span6);
			append_dev(tbody, t24);
			append_dev(tbody, tr7);
			append_dev(tr7, td14);
			append_dev(tr7, td15);
			append_dev(td15, div8);
			append_dev(div8, span7);
			append_dev(tbody, t27);
			append_dev(tbody, tr8);
			append_dev(tr8, td16);
			append_dev(tr8, td17);
			append_dev(td17, div9);
			append_dev(div9, span8);
			append_dev(tbody, t30);
			append_dev(tbody, tr9);
			append_dev(tr9, td18);
			append_dev(tr9, td19);
			append_dev(td19, div10);
			append_dev(div10, span9);
			append_dev(tbody, t33);
			append_dev(tbody, tr10);
			append_dev(tr10, td20);
			append_dev(tr10, td21);
			append_dev(td21, div11);
			append_dev(div11, span10);
			append_dev(tbody, t36);
			append_dev(tbody, tr11);
			append_dev(tr11, td22);
			append_dev(tr11, td23);
			append_dev(td23, div12);
			append_dev(div12, span11);
			append_dev(div15, t39);
			append_dev(div15, div14);
			append_dev(div14, button1);
			append_dev(main, t41);
			append_dev(main, div28);
			append_dev(div28, button2);
			append_dev(div28, t42);
			append_dev(div28, button3);
			append_dev(div28, t43);
			append_dev(div28, center);
			append_dev(center, div24);
			append_dev(div24, div23);
			append_dev(div23, div18);
			append_dev(div18, button4);
			append_dev(button4, i0);
			append_dev(div18, t44);
			append_dev(div18, button5);
			append_dev(button5, t45);
			append_dev(div18, t46);
			append_dev(div18, button6);
			append_dev(button6, i1);
			append_dev(div23, t47);
			append_dev(div23, div19);
			append_dev(div19, button7);
			append_dev(button7, i2);
			append_dev(div19, t48);
			append_dev(div19, button8);
			append_dev(button8, i3);
			append_dev(div19, t49);
			append_dev(div19, button9);
			append_dev(button9, i4);
			append_dev(div19, t50);
			append_dev(div19, button10);
			append_dev(button10, i5);
			append_dev(div23, t51);
			append_dev(div23, div20);
			append_dev(div20, button11);
			append_dev(button11, t52);
			append_dev(div23, t53);
			append_dev(div23, div21);
			append_dev(div21, button12);
			append_dev(button12, i6);
			append_dev(div23, t54);
			append_dev(div23, div22);
			append_dev(div22, button13);
			append_dev(button13, t55);
			append_dev(center, t56);
			append_dev(center, div27);
			append_dev(div27, div26);
			append_dev(div26, img);
			append_dev(div26, t57);
			append_dev(div26, div25);
			append_dev(div25, span12);
			append_dev(div26, t58);
			append_dev(div26, svg6);
			append_dev(svg6, title0);
			append_dev(title0, t59);
			append_dev(svg6, g0);
			append_dev(svg6, g1);
			append_dev(svg6, g2);
			append_dev(svg6, g3);
			append_dev(svg6, g4);
			append_dev(svg6, svg5);
			append_dev(svg5, svg4);
			append_dev(svg4, g21);
			append_dev(g21, circle0);
			append_dev(g21, g5);
			append_dev(g5, line);
			append_dev(g21, g6);
			append_dev(g6, circle1);
			append_dev(g6, title1);
			append_dev(title1, t60);
			append_dev(g6, desc0);
			append_dev(desc0, t61);
			append_dev(g6, defs0);
			append_dev(defs0, pattern0);
			append_dev(pattern0, svg0);
			append_dev(svg0, path0);
			append_dev(svg0, path1);
			append_dev(svg0, path2);
			append_dev(svg0, path3);
			append_dev(svg0, circle2);
			append_dev(g21, g13);
			append_dev(g13, circle3);
			append_dev(g13, title2);
			append_dev(title2, t62);
			append_dev(g13, desc1);
			append_dev(desc1, t63);
			append_dev(g13, defs1);
			append_dev(defs1, pattern1);
			append_dev(pattern1, svg1);
			append_dev(svg1, g9);
			append_dev(g9, g7);
			append_dev(g7, rect0);
			append_dev(g9, g8);
			append_dev(g8, rect1);
			append_dev(svg1, g12);
			append_dev(g12, g10);
			append_dev(g10, path4);
			append_dev(g12, g11);
			append_dev(g11, path5);
			append_dev(g21, g14);
			append_dev(g14, circle4);
			append_dev(g14, title3);
			append_dev(title3, t64);
			append_dev(g14, desc2);
			append_dev(desc2, t65);
			append_dev(g14, defs2);
			append_dev(defs2, pattern2);
			append_dev(pattern2, svg2);
			append_dev(svg2, path6);
			append_dev(g21, g15);
			append_dev(g15, circle5);
			append_dev(g15, circle6);
			append_dev(g15, title4);
			append_dev(title4, t66);
			append_dev(g15, desc3);
			append_dev(desc3, t67);
			append_dev(g21, g20);
			append_dev(g20, circle7);
			append_dev(g20, defs3);
			append_dev(defs3, pattern3);
			append_dev(pattern3, svg3);
			append_dev(svg3, g19);
			append_dev(g19, g18);
			append_dev(g18, g17);
			append_dev(g17, g16);
			append_dev(g16, path7);

			if (!mounted) {
				dispose = listen_dev(button13, "click", /*openShortcut*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 4 && img.src !== (img_src_value = /*bgImgPath*/ ctx[3] + /*state*/ ctx[2].bgImg)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*state*/ 4 && t59_value !== (t59_value = /*state*/ ctx[2].alt + "")) set_data_dev(t59, t59_value);
			if (dirty[0] & /*previewCompassRadius*/ 1 && t62_value !== (t62_value = Lang.compass_radius + (/*previewCompassRadius*/ ctx[0] * 0.02649).toFixed(2) + "")) set_data_dev(t62, t62_value);
			if (dirty[0] & /*previewCompassAngle*/ 2 && t64_value !== (t64_value = Lang.compass_angle + /*previewCompassAngle*/ ctx[1] + Lang.degree + "")) set_data_dev(t64, t64_value);

			if (dirty[0] & /*state*/ 4 && circle5_fill_value !== (circle5_fill_value = /*state*/ ctx[2].lineColor)) {
				attr_dev(circle5, "fill", circle5_fill_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function arrayCopy(array) {
	// creates a temporary array
	let tempArray = [];

	for (let index = 0; index < array.length; index++) {
		// pushes default initialized object into array tempArray
		tempArray.push({
			mode: "mode",
			order: 2,
			type: "scribble_0",
			index: 0,
			d: "path"
		});

		// update the value of mode key of array tempArray at index specified in variable 'index' with the value of mode key of array passed in argument at index specified in variable 'index'
		tempArray[index].mode = array[index].mode;

		// update the value of order key of array tempArray at index specified in variable 'index' with the value of order key of array passed in argument at index specified in variable 'index'
		tempArray[index].order = array[index].order;

		// update the value of type key of array tempArray at index specified in variable 'index' with the value of type key of array passed in argument at index specified in variable 'index'
		tempArray[index].type = array[index].type;

		// update the value of index key of array tempArray at index specified in variable 'index' with the value of index key of array passed in argument at index specified in variable 'index'
		tempArray[index].index = array[index].index;

		// update the value of d key of array tempArray at index specified in variable 'index' with the value of d key of array passed in argument at index specified in variable 'index'
		tempArray[index].d = array[index].d;
	}

	// retuns array after copied data from array passed in arguments
	return tempArray;
}

// Center of the circle (cx, cy)
// Radius of circle: r
// First Point (ax,ay) and second Point (bx,by)
function checkIntersection(ax, ay, bx, by, cx, cy, r) {
	ax -= cx;
	ay -= cy;
	bx -= cx;
	by -= cy;
	let a = (bx - ax) * (bx - ax) + (by - ay) * (by - ay);
	let b = 2 * (ax * (bx - ax) + ay * (by - ay));
	let c = ax * ax + ay * ay - r * r;

	// Applying Shri Dharacharya method by comparing the quadratic values a, b, c
	let disc = b * b - 4 * a * c;

	if (disc <= 0) {
		return false;
	}

	let t1 = (-b + Math.sqrt(disc)) / (2 * a);
	let t2 = (-b - Math.sqrt(disc)) / (2 * a);

	if (0 < t1 && t1 < 1 || 0 < t2 && t2 < 1) {
		return true;
	}

	return false;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DrawingPreview", slots, []);
	let { xml } = $$props;
	let { uxml } = $$props;
	let { isReview } = $$props;
	let { showAns } = $$props;
	let { editorState } = $$props;
	let bgImgPath = "https://s3.amazonaws.com/jigyaasa_content_static/";
	let xmlns = "http://www.w3.org/2000/svg";

	// denotes that drawing is not sketching
	let isDrawingPreview = false;

	// allow to draw the drawing using compass
	let isDrawCompassPreview = true;

	// indicates that starting position should be store when perform using keyboard and compass
	let isStoreStart = false;

	// indicates that drawing is not started
	let isDrawStop = 0;

	// shows that is drawing started by keyboard
	let startDrawingByKey = 0;

	// used to creates an element with the specified namespace URI and qualified name
	let scribble;

	// denotes mouse co-ordinates
	let preview_mouseX, preview_mouseY;

	// scribble drawing tool is enable
	let previewMode = "scribble";

	// strike color of drawing
	let previewColor = "#00BCD4";

	// stroke width of the drawing
	let previewThickness = 5;

	// contains object that have key type, index, mode, order and d
	let previewScribblePath = [];

	// shows number of drawing sketched with the help of drawing tools
	let previewScribbleCount = 0;

	// contains current mouse x position
	let checkCurrentPositionX;

	// contains current mouse y position
	let checkCurrentPositionY;

	// denoes no of undo done
	let previewUndoCount = 0;

	// contains undo data
	let previewUndoList = [];

	// contains redo data
	let previewRedoList = [];

	// contains the focusPoints
	let accessibilityPointsPreview = [];

	// number of focus point exist
	let focusPointCountPreview = 1;

	// used for not focus on perticular point
	let lockFocus = 0;

	// denotes that scribble drawing is not sketching
	let isScribble = 0;

	// for compass variable
	// denotes x co-ordinate of the center
	let cx;

	// denotes y co-ordinate of the center
	let cy;

	// denotes x co-ordinate of the center of middle circle lies on rotationbar
	let midCircle_cx;

	// denotes y co-ordinate of the center of middle circle lies on rotationbar
	let midCircle_cy;

	// denotes x co-ordinate of the center of small middle circle lies on rotationbar
	let midSmallCircle_cx;

	// denotes y co-ordinate of the center of small middle circle lies on rotationbar
	let midSmallCircle_cy;

	// denotes x co-ordinate of the center of last circle lies on rotationbar
	let lastCircle_cx;

	// denotes y co-ordinate of the center of last circle lies on rotationbar
	let lastCircle_cy;

	// denotes x co-ordinate of the center of rotation indicator that can be seen after last circle on rotationbar
	let lastSmallCircle_cx;

	// denotes y co-ordinate of the center of rotation indicator that can be seen after last circle on rotationbar
	let lastSmallCircle_cy;

	// defines the compass radius
	let previewCompassRadius = 100;

	// denotes that compass is not moved
	let isPreviewCompassMove = false;

	// sets the default angle of compass
	let previewCompassAngle = 90;

	// denotes that compass radius not increased
	let isPreviewRadiusIncrease = 0;

	// denotes initial points co-ordinate
	let initialPoint = { x: null, y: null };

	// denotes final points co-ordinate
	let finalPoint = { x: null, y: null };

	// denotes no angle displaced
	let compassAngleDisplacement = { start: null, end: null };

	// denotes that is radius rotated
	let isPreviewRadiusRotate = 0;

	// y co-ordinate of the marked point
	let cursorTop = 50;

	// x co-ordinate of the marked point
	let cursorLeft = 50;

	// used for answer recording
	let defaultXML = "";

	let cdata = "";

	// denotes that answer is incorrect
	let isAnswerCorrect = false;

	// for marking
	let isMarking = 1;

	// contains the co-ordinates of marked point
	let markPoints = [];

	// denotes array of drawing tools
	let selectedToolsArray = ["_scribble", "_line", "_compass"];

	// for user answer
	let userAnsPath = [];

	// initial layout of user answer xml
	let userAnsXML = "<smans type=\"41\"></smans>";

	// contains the x and y co-ordinate of the points marked by user
	let userMarkingPoint = [];

	// contains drawing sketched by user by the help of drawing tools
	let userDrawPath = [];

	// denotes that answer is incorrect
	let userAnsCorrect = false;

	// contains the co-ordinates of marked point
	let markPointsData = [];

	// for browsers
	let is_mac = false;

	let prev_store = writable({
		// contains status of the answer
		correctAnswer: false,
		// contains the xml of the props
		xml: "",
		// not used any where
		openImg: false,
		// not used any where
		openDrag: false,
		// denotes background image
		bgImg: "useraccount_000ANv.png",
		// not used any where 
		cdata: "",
		// contains cdata value of backgroundPoint of smxml 
		focusDATA: "",
		// not used any where 
		userXML: "",
		// stroke color of the drawing sketch by the help of drawing tools
		lineColor: "#00BCD4",
		// contains drawing tools array
		selectedTools: selectedToolsArray,
		// denotes remediation mode is off
		remediationMode: "off",
		// width of the background image
		imgWidth: "600",
		// alt message of background image
		alt: "Triangle image",
		// sets color of the mark points
		markPointColor: "#00ff00"
	});

	// subscribing the store in the state variable
	let state = {};

	const unsubscribe = prev_store.subscribe(value => {
		$$invalidate(2, state = value);
	});

	// for adding all the necessary events and the css files
	onMount(async () => {
		// checked for mac device
		is_mac = navigator.userAgent.indexOf("Mac") != -1;

		// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
		updatePreviewCompassCalculation(160, 118, 100, 90);

		AH.listen("body", "click", "#set-review", function () {
			setReview();
		});

		AH.listen("body", "click", "#unset-review", function () {
			unsetReview();
		});

		AH.listen("body", "click", "#preview_reset_btn", function () {
			swal({
				text: Lang.reset_module,
				icon: "warning",
				buttons: true
			}).then(value => {
				if (value) {
					// reset all the activity and makes it in initial condition as it looks like just after load
					parseXMLForGettingData();

					reinitializeFoucsEvent();
				}
			});
		});

		/** Start of key events **/
		// to stop scrolling of page by space and arrow keys
		AH.bind("body", "keydown", function (event) {
			if (!editorState && (event.keyCode == 32 || event.keyCode == 37 || event.keyCode == 38 || event.keyCode == 39 || event.keyCode == 40)) {
				return false;
			}
		});

		AH.listen("body", "keyup", ".previewKeySvg .previewDrawingPaths path", function (current, event) {
			if (event.keyCode == 46 || event.keyCode == 8 && is_mac) {
				// removes drawing on which keyup event triggered and update the user answer xml
				eraser(current, previewScribblePath);
			}
		});

		AH.listen("body", "keyup", ".previewKeySvg", function (current, event) {
			if (event.keyCode == 90 && event.ctrlKey && !AH.select("#preview_undo").disabled) {
				if (startDrawingByKey && isDrawStop) {
					// stop the drawing and store the drawing sketched by the user and sets the user answer xml
					stopDraw();
				}

				// click the undo button
				AH.select("#preview_undo").click();
			}

			if (event.keyCode == 89 && event.ctrlKey && !AH.select("#preview_redo").disabled) {
				if (startDrawingByKey && isDrawStop) {
					// stop the drawing and store the drawing sketched by the user and sets the user answer xml
					stopDraw();
				}

				// click the redo button
				AH.select("#preview_redo").click();
			}

			if (event.keyCode == 88 && event.ctrlKey) {
				// click the clear screen (x) button
				AH.select("#preview_clearScreen").click();
			}

			if ((event.keyCode == 13 || event.keyCode == 32) && previewMode != "compass" && previewMode != "eraser") {
				// hides the icon (+) used to sketch the drawing using keyboard
				AH.select("#moveDrawIcon", "removeClass", "h");

				// sets the cursor style to auto
				AH.select(".previewKeySvg", "css", { "cursor": "auto" });
			}

			if (event.shiftKey && (event.keyCode == 13 || event.keyCode == 32) && AH.select("#moveDrawIcon").offsetHeight != 0) {
				if (previewMode == "markPoints") {
					// Creates an element with the specified namespace URI and qualified name.
					scribble = document.createElementNS(xmlns, "circle");

					// sets the stroke color and width
					setPreviewColor(state.markPointColor, previewThickness);

					// adds a new attribute 'class' (with a namespace null)
					scribble.setAttributeNS(null, "class", "answer_mark");

					// adds a new attribute 'cx' (with a namespace null)
					scribble.setAttributeNS(null, "cx", cursorLeft);

					// adds a new attribute 'cy' (with a namespace null)
					scribble.setAttributeNS(null, "cy", cursorTop);

					// adds a new attribute 'r' (with a namespace null)
					scribble.setAttributeNS(null, "r", "2px");

					// pushes the x and y co-ordinate of the mouse into markPoints array
					markPoints.push({ x: cursorLeft, y: cursorTop });

					// prepend the element stored into variable scribble in mark point container in which drawings are stored done by the help of 'Mark Poin' And 'Finish Marking' buttons
					AH.select(".previewMarkingPaths").prepend(scribble);

					// checks the answer and updates the status and enables 'Mark Points' button and also updates its text as 'Mark Points' 
					parseXMLForAnswer(false);

					// updates user answer xml
					createUXML();
				} else {
					if (isDrawStop) {
						// stop the drawing and store the drawing sketched by the user and sets the user answer xml
						stopDraw();
					} else {
						startDrawingByKey = 1;

						// removes the all mark points and sets the value of the variable 'isMArking' to 1
						clearMarking();

						// Creates an element with the value of variable xmlns namespace URI and 'path' name
						scribble = document.createElementNS(xmlns, "path");

						// sets the stroke color and width
						setPreviewColor(previewColor, previewThickness);

						// adds a new attribute 'data-type' (with a namespace null)
						scribble.setAttributeNS(null, "data-type", previewMode + "_" + previewScribbleCount);

						// adds a new attribute 'data-order' (with a namespace null)
						scribble.setAttributeNS(null, "data-order", previewScribbleCount);

						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", "M" + cursorLeft + " " + cursorTop);

						// adds a new attribute 'tabindex' (with a namespace null)
						scribble.setAttributeNS(null, "tabindex", "0");

						// contains the cursor left position
						checkCurrentPositionX = cursorLeft;

						// contains the cursor top position
						checkCurrentPositionY = cursorTop;

						// pushes object having keys mode, order, type, index and d with their values into  array previewScribblePath
						previewScribblePath.push({
							// define that perticular sequence element will be removed or added on drawing board
							mode: "add",
							// defines what is the sequence of perticular drawing on drawing board means when it is drawn then how many drawing already done and it starts with 0
							order: previewScribbleCount,
							// defines which drawing tool is used for sketch the drawing with its sequence on drawing board combind with underscore (_)
							type: previewMode + "_" + previewScribbleCount,
							// not used as its requirement completed by order key
							index: previewScribbleCount,
							// specify the position from where drawing will start
							d: "M" + cursorLeft + " " + cursorTop
						});

						// indicates that drawing is sketched
						isDrawStop = 1;
					}
				}
			}
		});

		AH.listen("body", "keydown", ".previewKeySvg", function (current, event) {
			if (AH.select("#moveDrawIcon").offsetHeight) {
				// contains width of the background image
				let imageWidth = AH.select("#svgImgPreview").clientWidth;

				// contains width of the background image 
				let imageHeight = AH.select("#svgImgPreview").clientHeight;

				if (event.shiftKey && (event.keyCode == 38 || event.keyCode == 37 || event.keyCode == 39 || event.keyCode == 40) && !lockFocus) {
					switch (event.keyCode) {
						case 38:
							// decreases the value of variable cursorTop by 1 after down the up arrow key
							cursorTop--;
							break;
						case 40:
							// increases the value of variable cursorTop by 1 after down the down arrow key
							cursorTop++;
							break;
						case 39:
							// increases the value of variable cursorLeft by 1 after down the right arrow key
							cursorLeft++;
							break;
						case 37:
							// decreases the value of variable cursorLeft by 1 after down the left arrow key
							cursorLeft--;
							break;
					}

					if (cursorTop < 0 || cursorLeft > imageWidth || cursorLeft < 0 || cursorTop > imageHeight) {
						return;
					}

					// sets the top and left position of the icon (+) used for sketch the drawing
					AH.select("#moveDrawIcon", "css", {
						"top": cursorTop + "px",
						"left": cursorLeft + "px"
					});

					if (startDrawingByKey) {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + cursorLeft + " " + cursorTop);

						if (previewMode != "line") {
							// adds value of variables cursorLeft and cursorTop separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
							previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + cursorLeft + " " + cursorTop;
						}

						// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
						AH.select(".previewDrawingPaths").prepend(scribble);

						// sets the value of the variable isDrawStop by 1 to indicate that sketching of the drawing is stopped
						isDrawStop = 1;
					}
				}

				if (event.shiftKey && event.keyCode == 76) {
					if (!lockFocus) {
						// fixed the mark point from where drawing will be start when performed via keyboard
						lockFocus = 1;

						startDrawingByKey = 1;

						// removes the all mark points and sets the value of the variable 'isMArking' to 1
						clearMarking();

						// contains the x co-ordinate of the mark point circle after converting it into number from string
						cursorLeft = Number(AH.select(".currentFocusPoint").getAttribute("cx"));

						// contains the y co-ordinate of the mark point circle after converting it into number from string
						cursorTop = Number(AH.select(".currentFocusPoint").getAttribute("cy"));

						// Creates an element with the value of variable xmlns namespace URI and 'path' name
						scribble = document.createElementNS(xmlns, "path");

						// sets the stroke color and width
						setPreviewColor(previewColor, previewThickness);

						// adds a new attribute 'data-type' (with a namespace null)
						scribble.setAttributeNS(null, "data-type", previewMode + "_" + previewScribbleCount);

						// adds a new attribute 'data-order' (with a namespace null)
						scribble.setAttributeNS(null, "data-order", previewScribbleCount);

						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", "M" + cursorLeft + " " + cursorTop);

						// adds a new attribute 'tabindex' (with a namespace null)
						scribble.setAttributeNS(null, "tabindex", "0");

						// assign the value of current x position
						checkCurrentPositionX = cursorLeft;

						// assign the value of current y position
						checkCurrentPositionY = cursorTop;

						// pushes object having keys mode, order, type, index and d with their values into  array previewScribblePath
						previewScribblePath.push({
							mode: "add",
							order: previewScribbleCount,
							type: previewMode + "_" + previewScribbleCount,
							index: previewScribbleCount,
							d: "M" + cursorLeft + " " + cursorTop
						});
					} else {
						// unlock the focus point
						lockFocus = 0;

						// stop the drawing and store the drawing sketched by the user and sets the user answer xml
						stopDraw();
					}
				}

				if (event.keyCode == 9 && lockFocus && (previewMode == "line" || previewMode == "scribble")) {
					let drawLine = setTimeout(
						function () {
							if (!AH.select(".currentFocusPoint").nodeName) {
								return;
							}

							// contains the x co-ordinate of the mark point circle after converting it into number from string
							cursorLeft = Number(AH.select(".currentFocusPoint").getAttribute("cx"));

							// contains the y co-ordinate of the mark point circle after converting it into number from string
							cursorTop = Number(AH.select(".currentFocusPoint").getAttribute("cy"));

							if (isNaN(cursorLeft) && isNaN(cursorTop)) {
								return;
							}

							if (previewMode == "scribble" || previewMode == "line") {
								// indicates that scribble drawing is sketching
								isScribble = 1;
							}

							// adds a new attribute 'd' (with a namespace null)
							scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + cursorLeft + " " + cursorTop);

							// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
							AH.select(".previewDrawingPaths").prepend(scribble);

							clearTimeout(drawLine);
						},
						10
					);
				}

				if (event.keyCode == 68 && lockFocus && isScribble) {
					let draw_scribble = setTimeout(
						function () {
							if (isNaN(cursorLeft) && isNaN(cursorTop)) {
								return;
							}

							// adds value of variables cursorLeft and cursorTop separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
							previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + cursorLeft + " " + cursorTop;

							// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
							AH.select(".previewDrawingPaths").prepend(scribble);

							clearTimeout(draw_scribble);

							// indicates that scribble drawing is not sketching
							isScribble = 0;
						},
						10
					);
				}
			}
		});

		AH.listen("body", "keydown", ".previewKeySvg .drawingCompassCenter", function (current, event) {
			// change the center position of the compass element
			compassKeyEvent("move", event);
		});

		AH.listen("body", "keydown", ".previewKeySvg .mid_circle", function (current, event) {
			// change the radius of the compass element
			compassKeyEvent("radius", event);
		});

		AH.listen("body", "keydown", ".previewKeySvg .midSmallCircle", function (current, event) {
			// change the angle of the compass element when focus is on small middle circle
			compassKeyEvent("rotate", event);
		});

		AH.listen("body", "keydown", ".previewKeySvg .lastCircle", function (current, event) {
			// change the angle of the compass element when focus is on last circle
			compassKeyEvent("draw", event);
		});

		AH.listen("body", "keydown", ".focusPoints", function (current, event) {
			if (event.shiftKey && event.keyCode == 13) {
				return false;
			}

			if ((event.keyCode == 13 || event.keyCode == 32) && previewMode != "markPoints" && previewMode != "eraser") {
				// contains the x co-ordinate of the mark point circle after converting it into number from string
				cursorLeft = Number(AH.select(".currentFocusPoint").getAttribute("cx"));

				// contains the y co-ordinate of the mark point circle after converting it into number from string
				cursorTop = Number(AH.select(".currentFocusPoint").getAttribute("cy"));

				if (previewMode != "compass") {
					// sets the position of the icon (+) used to sketch the drawing by the help of keyboard
					AH.select("#moveDrawIcon", "css", {
						"top": cursorTop + "px",
						"left": cursorLeft + "px"
					});
				} else {
					// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
					updatePreviewCompassCalculation(cursorLeft, cursorTop, previewCompassRadius, previewCompassAngle);
				}
			}
		});

		AH.listen("body", "keyup", ".previewKeySvg .lastCircle", function (current, event) {
			if (!isDrawCompassPreview && isStoreStart && event.keyCode == 16) {
				// stores the drawing sketched by user using keyboard and sets the user answer xml
				storeCompassPathByKey();
			}
		});

		/** End of key events **/
		AH.bind(".previewKeySvg .lastCircle", "blur", function () {
			if (!isDrawCompassPreview && isStoreStart) {
				// stores the drawing sketched by user using keyboard and sets the user answer xml
				storeCompassPathByKey();
			}
		});

		AH.listen("body", "mousedown", "#previewSvg .midSmallCircle", function () {
			if (previewMode == "compass") {
				// indicates that radius rotated
				isPreviewRadiusRotate = 1;

				// updates the value of compass radius and angle
				checkPreviewRadiusAndAngle();

				// contains the value of start angle
				compassAngleDisplacement.start = previewCompassAngle;
			}
		});

		AH.listen("body", "mousedown", "#previewSvg .drawingCompassCenter", function () {
			if (previewMode == "compass") {
				// sets the x and y co-ordinate of the mouse position
				setPreviewMouseCoordinates(event);

				// contains x co-ordinate of the mouse
				cx = preview_mouseX;

				// contains y co-ordinate of the mouse
				cy = preview_mouseY;

				// contains radius of the compass
				$$invalidate(0, previewCompassRadius = AH.select(".drawingCompassRoute").getAttribute("r"));

				// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
				updatePreviewCompassCalculation(cx, cy, previewCompassRadius, previewCompassAngle);

				// indicates that compass is moved
				isPreviewCompassMove = true;
			}
		});

		AH.listen("body", "mousedown", "#previewSvg .mid_circle", function () {
			if (previewMode == "compass") {
				// allows to change the value of radius of the compass
				isPreviewRadiusIncrease = 1;
			}
		});

		AH.listen("body", "mousedown", "#previewSvg .lastCircle", function (current, event) {
			compassLastcircleEvent(event);
		});

		AH.listen("body", "keydown", "#previewSvg .lastCircle", function (current, event) {
			compassLastcircleEvent(event);
		});

		// Mouse down event
		AH.listen("body", "mousedown", "#previewSvg", function (current, event) {
			// sets the cursor style as crosshair (+)
			AH.select("#previewSvg", "css", { "cursor": "crosshair" });

			// hides the icon used to sketch the drawing by the help of keyboard
			AH.select("#moveDrawIcon", "addClass", "h");

			if (startDrawingByKey && isDrawStop || lockFocus) {
				// stop the drawing and store the drawing sketched by the user and sets the user answer xml
				stopDraw();
			}

			switch (previewMode) {
				case "line":
				case "scribble":
					// removes the all mark points and sets the value of the variable 'isMArking' to 1
					clearMarking();
					// denotes that drawing is on going
					isDrawingPreview = true;
					// sets the x and y co-ordinate of the mouse position
					setPreviewMouseCoordinates(event);
					// Creates an element with the value of variable xmlns namespace URI and 'path' name
					scribble = document.createElementNS(xmlns, "path");
					// sets the stroke color and width
					setPreviewColor(previewColor, previewThickness);
					// adds a new attribute 'data-type' (with a namespace null)
					scribble.setAttributeNS(null, "data-type", previewMode + "_" + previewScribbleCount);
					// adds a new attribute 'data-order' (with a namespace null)
					scribble.setAttributeNS(null, "data-order", previewScribbleCount);
					// adds a new attribute 'd' (with a namespace null)
					scribble.setAttributeNS(null, "d", "M" + preview_mouseX + " " + preview_mouseY);
					// adds a new attribute 'tabindex' (with a namespace null)
					scribble.setAttributeNS(null, "tabindex", "0");
					// contains the x co-ordinate of the mouse
					checkCurrentPositionX = preview_mouseX;
					// contains the y co-ordinate of the mouse
					checkCurrentPositionY = preview_mouseY;
					// pushes object having keys mode, order, type, index and d with their values into  array previewScribblePath
					previewScribblePath.push({
						mode: "add",
						order: previewScribbleCount,
						type: previewMode + "_" + previewScribbleCount,
						index: previewScribbleCount,
						d: "M" + preview_mouseX + " " + preview_mouseY
					});
					break;
				case "eraser":
					// removes drawing on which keyup event triggered and update the user answer xml
					eraser(".currentSvg", previewScribblePath);
					break;
				case "markPoints":
					if (!isMarking) {
						// sets the x and y co-ordinate of the mouse position
						setPreviewMouseCoordinates(event);

						// Creates an element with the specified namespace URI and qualified name.
						scribble = document.createElementNS(xmlns, "circle");

						// sets the stroke color and width
						setPreviewColor(state.markPointColor, previewThickness);

						// adds a new attribute 'class' (with a namespace null)
						scribble.setAttributeNS(null, "class", "answer_mark");

						// adds a new attribute 'cx' (with a namespace null)
						scribble.setAttributeNS(null, "cx", preview_mouseX);

						// adds a new attribute 'cy' (with a namespace null)
						scribble.setAttributeNS(null, "cy", preview_mouseY);

						// adds a new attribute 'r' (with a namespace null)
						scribble.setAttributeNS(null, "r", "2px");

						// pushes the x and y co-ordinate of mouse into markPoints array
						markPoints.push({ x: preview_mouseX, y: preview_mouseY });

						// prepend the element stored into variable scribble in mark point container in which drawings are stored done by the help of 'Mark Poin' And 'Finish Marking' buttons
						AH.select(".previewMarkingPaths").prepend(scribble);

						// checks the answer and updates the status and enables 'Mark Points' button and also updates its text as 'Mark Points' 
						parseXMLForAnswer(false);

						// updates user answer xml
						createUXML();
					}
					break;
			}
		});

		// Mouse Move event
		AH.listen("body", "mousemove", "#previewSvg", function (current, event) {
			switch (previewMode) {
				case "line":
					if (isDrawingPreview) {
						// sets the x and y co-ordinate of the mouse position
						setPreviewMouseCoordinates(event);

						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + preview_mouseX + " " + preview_mouseY);

						if (!(checkCurrentPositionX == preview_mouseX && checkCurrentPositionY == preview_mouseY)) {
							// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
							AH.select(".previewDrawingPaths").prepend(scribble);
						}
					}
					break;
				case "scribble":
					if (isDrawingPreview) {
						// sets the x and y co-ordinate of the mouse position
						setPreviewMouseCoordinates(event);

						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + preview_mouseX + " " + preview_mouseY);

						// adds value of variables preview_mouseX and preview_mouseY separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
						previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + preview_mouseX + " " + preview_mouseY;

						if (!(previewScribblePath[previewScribbleCount].d.split("L").length - 1 < 3)) {
							// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
							AH.select(".previewDrawingPaths").prepend(scribble);
						}
					}
					break;
				case "compass":
					// sets the x and y co-ordinate of the mouse position
					setPreviewMouseCoordinates(event);
					if (isPreviewCompassMove) {
						// contains the x co-ordinate of the mouse 
						cx = preview_mouseX;

						// contains the y co-ordinate of the mouse 
						cy = preview_mouseY;

						// contains radius of the compass
						$$invalidate(0, previewCompassRadius = AH.select(".drawingCompassRoute").getAttribute("r"));

						// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
						updatePreviewCompassCalculation(cx, cy, previewCompassRadius, previewCompassAngle);
					}
					if (isPreviewRadiusIncrease) {
						// updates the value of compass radius and angle
						checkPreviewRadiusAndAngle();

						// calculates the radius by the help of start and end points co-ordinate of the rotation bar
						$$invalidate(0, previewCompassRadius = 2 * Math.sqrt(Math.pow(preview_mouseX - initialPoint.x, 2) + Math.pow(preview_mouseY - initialPoint.y, 2)));

						if (previewCompassRadius < 80) {
							// sets the value 80 of the variable previewCompassRadius
							$$invalidate(0, previewCompassRadius = 80);
						}

						if (previewCompassRadius > 360) {
							// sets the value 360 of the variable previewCompassRadius
							$$invalidate(0, previewCompassRadius = 360);
						}

						// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
						updatePreviewCompassCalculation(initialPoint.x, initialPoint.y, previewCompassRadius, previewCompassAngle);
					}
					if (isPreviewRadiusRotate) {
						// updates the value of compass radius and angle
						checkPreviewRadiusAndAngle();

						// calculates the angle by the help of start and end points co-ordinate of the rotation bar
						$$invalidate(1, previewCompassAngle = Math.atan2(preview_mouseY - initialPoint.y, preview_mouseX - initialPoint.x) * 180 / Math.PI);

						if (previewCompassAngle < 0) {
							// adds 360 into the value of the variable previewCompassAngle
							$$invalidate(1, previewCompassAngle = 360 + previewCompassAngle);
						}

						// contains the value of end angle
						compassAngleDisplacement.end = previewCompassAngle;

						// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
						updatePreviewCompassCalculation(initialPoint.x, initialPoint.y, previewCompassRadius, previewCompassAngle);
					}
					if (isDrawingPreview) {
						if (!(AH.select("#previewSvg .lastCircle").classList.contains("lastCircle_hover") || AH.select("#previewSvg .lastbigcircle").classList.contains("lastCircle_hover"))) {
							// trigger the event mouseleave on the element have id previewSvg
							previewMouseLeave(event);
						} else {
							// adds a new attribute 'd' (with a namespace null)
							scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy);

							// adds value of variables lastCircle_cx and lastCircle_cy separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
							previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy;

							if (!(previewScribblePath[previewScribbleCount].d.split("L").length - 1 < 4)) {
								// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
								AH.select(".previewDrawingPaths").prepend(scribble);
							}
						}
					}
					break;
			}
		});

		// Mouse Up Event
		AH.listen("body", "mouseup", "#previewSvg", function (current, event) {
			previewMouseLeave(event);
		});

		// Mouse leave Event
		AH.bind("#previewSvg", "mouseleave", function (event) {
			previewMouseLeave(event);
		});

		// For toolbar
		AH.listen("body", "click", ".preview_toolbar", function (current, event) {
			toolbarAction(current, event);
		});

		AH.listen("body", "keyup", ".preview_toolbar", function (current, event) {
			toolbarAction(current, event);
		});

		AH.listen("body", "mouseover", ".previewDrawingPaths path", function (current) {
			if (previewMode == "eraser") {
				// removes the class currentSvg from the element 'path' inside the element have class 'previewDrawingPaths'
				AH.selectAll(".previewDrawingPaths path", "removeClass", "currentSvg");

				// adds the class 'currentSvg' to the element 'path' inside the element have class 'previewDrawingPaths' on which mouseover
				current.classList.add("currentSvg");
			}
		});

		AH.listen("body", "mouseout", ".previewDrawingPaths path", function (current) {
			if (previewMode == "eraser") {
				// removes the class 'currentSvg' to the element 'path' inside the element have class 'previewDrawingPaths' on which mouseout
				current.classList.remove("currentSvg");
			}
		});

		// last circle events
		AH.listen("body", "mousemove", "#previewSvg .lastCircle", function (current) {
			// adds the class 'lastCircle_hover' to the last circle on compass rotation bar lies on route of the compass
			current.classList.add("lastCircle_hover");

			// shows the rotational indicator
			AH.selectAll("#previewSvg .lastCircleMid", "attr", { "opacity": 1 });
		});

		AH.listen("body", "mouseout", "#previewSvg .lastCircle", function (current) {
			// removes the class 'lastCircle_hover' to the last circle on compass rotation bar lies on route of the compass
			current.classList.remove("lastCircle_hover");

			// hides the rotational indicator
			AH.selectAll("#previewSvg .lastCircleMid", "attr", { "opacity": 0 });
		});

		AH.listenAll("#previewSvg .lastCircle", "focus", function (current) {
			// adds the class 'lastCircle_hover' to the last circle on compass rotation bar lies on route of the compass
			current.target.classList.add("lastCircle_hover");

			// shows the rotational indicator
			AH.selectAll("#previewSvg .lastCircleMid", "attr", { "opacity": 1 });
		});

		AH.listenAll("#previewSvg .lastCircle", "blur", function (current) {
			// removes the class 'lastCircle_hover' to the last circle on compass rotation bar lies on route of the compass
			current.target.classList.remove("lastCircle_hover");

			// hides the rotational indicator
			AH.selectAll("#previewSvg .lastCircleMid", "attr", { "opacity": 0 });
		});

		// for changing the active buttons
		AH.listen("body", "click", ".preview_btn", function (current) {
			// removes the class active from drawing tools, delete and  'Mark Points' buttons
			AH.selectAll(".preview_btn, #mark_points", "removeClass", "active");

			// adds the class active which is clicked
			current.classList.add("active");
		});

		// for clearing the screen
		AH.listen("body", "click", "#preview_clearScreen", function () {
			// makes drawing container empty in which drawing is done by using drawing tools
			AH.selectAll(".previewDrawingPaths path", "remove");

			// sets the value of variable 'previewUndoCount' to  0
			previewUndoCount = 0;

			// sets the value of variable 'previewScribbleCount' to  0
			previewScribbleCount = 0;

			// makes array 'previewScribblePath' empty to denote that no drawing is sketched
			previewScribblePath = [];

			// contains copy of array previewScribblePath
			let tempArrayContainer = arrayCopy(previewScribblePath);

			// stores the drawing sketched by user and sets the user answer xml
			storeUserPaths(tempArrayContainer);

			// disabled the undo, redo, cross (x) buttons
			AH.select("#preview_undo").disabled = true;

			AH.select("#preview_redo").disabled = true;
			AH.select("#preview_clearScreen").disabled = true;
		});

		// for undo
		AH.listen("body", "click", "#preview_undo", function (current) {
			if (previewUndoCount == 1) {
				// disabled the undo button
				current.disabled = true;
			}

			// enabled the redo button
			AH.select("#preview_redo").disabled = false;

			if (previewScribblePath[previewScribblePath.length - 1].mode == "add") {
				// removes the element that have data-order attribute and value of this attribute is equals to subtacting 1 from the value of length of the array previewScribblePath, means removes the last drawing sketched by the help of drawing tools
				AH.selectAll("#previewSvg [data-order=\"" + (previewScribblePath.length - 1) + "\"]", "remove");
			} else if (previewScribblePath[previewScribblePath.length - 1].mode == "remove") {
				// Creates an element with the value of variable xmlns namespace URI and 'path' name
				scribble = document.createElementNS(xmlns, "path");

				// sets the stroke color and width
				setPreviewColor(previewColor, previewThickness);

				// adds a new attribute 'data-type' (with a namespace null)
				scribble.setAttributeNS(null, "data-type", previewScribblePath[previewScribblePath.length - 1].type);

				// adds a new attribute 'data-order' (with a namespace null)
				scribble.setAttributeNS(null, "data-order", previewScribblePath[previewScribblePath.length - 1].order);

				// adds a new attribute 'd' (with a namespace null)
				scribble.setAttributeNS(null, "d", previewScribblePath[previewScribblePath.length - 1].d);

				// adds a new attribute 'tabindex' (with a namespace null)
				scribble.setAttributeNS(null, "tabindex", "0");

				if (previewMode == "eraser") {
					// adds a new attribute 'class' (with a namespace null)
					scribble.setAttributeNS(null, "class", "eraserHover");
				}

				// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
				AH.select(".previewDrawingPaths").prepend(scribble);
			}

			// pushes the last data of array previewScribblePath into array previewUndoList
			previewUndoList.push(previewScribblePath.pop());

			// contains copy of array previewScribblePath
			let tempArrayContainer = arrayCopy(previewScribblePath);

			// stores the drawing sketched by user and sets the user answer xml
			storeUserPaths(tempArrayContainer);

			// decreases the value of the variable previewScribbleCount by 1
			previewScribbleCount--;

			// decreases the value of the variable previewUndoCount by 1
			previewUndoCount--;

			AH.select("#preview_clearScreen").disabled = AH.selectAll(".previewDrawingPaths path").length == 0;

			if (previewScribblePath.length == 0) {
				// disabled the undo button
				current.disabled = true;
			}
		});

		// for redo
		AH.listen("body", "click", "#preview_redo", function (current) {
			// increases the value of the variable previewScribbleCount by 1
			previewScribbleCount++;

			if (previewUndoList.length > 0) {
				// pushes the last data of array previewUndoList into array previewRedoList
				previewRedoList.push(previewUndoList.pop());
			}

			if (previewRedoList[previewRedoList.length - 1].mode == "add") {
				// Creates an element with the value of variable xmlns namespace URI and 'path' name
				scribble = document.createElementNS(xmlns, "path");

				// sets the stroke color and width
				setPreviewColor(previewColor, previewThickness);

				// adds a new attribute 'data-type' (with a namespace null)
				scribble.setAttributeNS(null, "data-type", previewRedoList[previewRedoList.length - 1].type);

				// adds a new attribute 'data-order' (with a namespace null)
				scribble.setAttributeNS(null, "data-order", previewRedoList[previewRedoList.length - 1].order);

				// adds a new attribute 'd' (with a namespace null)
				scribble.setAttributeNS(null, "d", previewRedoList[previewRedoList.length - 1].d);

				// adds a new attribute 'tabindex' (with a namespace null)
				scribble.setAttributeNS(null, "tabindex", "0");

				if (previewMode == "eraser") {
					// adds a new attribute 'class' (with a namespace null)
					scribble.setAttributeNS(null, "class", "eraserHover");
				}

				// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
				AH.select(".previewDrawingPaths").prepend(scribble);
			} else if (previewRedoList[previewRedoList.length - 1].mode == "remove") {
				// removes the element that have data-order attribute and value of this attribute is equals to the value of order key of the last index value of array previewRedoList, means removes the last drawing stored in array previewRedoList
				AH.selectAll("#previewSvg [data-order=\"" + previewRedoList[previewRedoList.length - 1].order + "\"]", "remove");
			}

			// increases the value of the variable previewUndoCount by 1
			previewUndoCount++;

			// pushes the last data of array previewRedoList into array previewScribblePath
			previewScribblePath.push(previewRedoList.pop());

			// contains copy of array previewScribblePath
			let tempArrayContainer = arrayCopy(previewScribblePath);

			// stores the drawing sketched by user and sets the user answer xml
			storeUserPaths(tempArrayContainer);

			AH.select("#preview_clearScreen").disabled = AH.selectAll(".previewDrawingPaths path").length == 0;

			if (previewUndoList.length == 0) {
				// disabled the redo button
				current.disabled = true;
			}

			// enabled the undo button
			AH.select("#preview_undo").disabled = false;
		});

		AH.listen("body", "click", "#mark_points", function (current, event) {
			markPointEvent(event);
		});

		AH.listen("body", "keyup", "#mark_points", function (current, event) {
			markPointEvent(event);
		});
	});

	// call the function after update in the store/state
	afterUpdate(async () => {
		// for changing the xml and loading the module according to the xml
		if (state.xml != xml) {
			parseXMLForGettingData();
			$$invalidate(2, state.xml = xml, state);
			reinitializeFoucsEvent();
			checkUserAns();
		}

		// for calling the setreview and unsetreview function on change of review mode
		if (state.review != isReview && editorState) {
			prev_store.update(item => {
				item.review = isReview;
				return item;
			});

			if (isReview) {
				setReview();
			} else {
				unsetReview();
			}
		}
	});

	// function responsible for the compass lastcircle keyevent
	function compassLastcircleEvent(event) {
		if (isScribble) {
			stopDraw();
		}

		if (event.shiftKey) {
			if (!isDrawCompassPreview) return;

			// sets the value  false of the variable isDrawCompassPreview
			isDrawCompassPreview = false;

			// sets the value true of the variable isStoreStart to store the starting position
			isStoreStart = true;

			// adds class lastCircle_hover to the last circle on the rotation bar
			AH.selectAll("#previewSvg .lastCircle", "addClass", "lastCircle_hover");
		}

		if (previewMode == "compass" && event.type == "mousedown" || event.shiftKey) {
			// removes the all mark points and sets the value of the variable 'isMArking' to 1
			clearMarking();

			// sets the cursor style to grabbing when mouse reached inside last circle on the rotation bar
			AH.selectAll("#previewSvg .lastCircle", "css", { "cursor": "grabbing" });

			if (isDrawCompassPreview || event.type == "mousedown") {
				// indicates that drawing is sketching
				isDrawingPreview = true;

				// indicates that radius is rotating
				isPreviewRadiusRotate = 1;
			}

			// updates the value of compass radius and angle
			checkPreviewRadiusAndAngle();

			// contains the value of start angle
			compassAngleDisplacement.start = previewCompassAngle;

			// Creates an element with the value of variable xmlns namespace URI and 'path' name
			scribble = document.createElementNS(xmlns, "path");

			// sets the stroke color and width
			setPreviewColor(previewColor, previewThickness);

			// adds a new attribute 'data-type' (with a namespace null)
			scribble.setAttributeNS(null, "data-type", previewMode + "_" + previewScribbleCount);

			// adds a new attribute 'data-order' (with a namespace null)
			scribble.setAttributeNS(null, "data-order", previewScribbleCount);

			// adds a new attribute 'd' (with a namespace null)
			scribble.setAttributeNS(null, "d", "M" + lastCircle_cx + " " + lastCircle_cy);

			// adds a new attribute 'tabindex' (with a namespace null)
			scribble.setAttributeNS(null, "tabindex", "0");

			// contains current x position
			checkCurrentPositionX = lastCircle_cx;

			// contains current y position
			checkCurrentPositionY = lastCircle_cy;

			// pushes object having keys mode, order, type, index and d with their values into  array previewScribblePath
			previewScribblePath.push({
				mode: "add",
				order: previewScribbleCount,
				type: previewMode + "_" + previewScribbleCount,
				index: previewScribbleCount,
				d: "M" + lastCircle_cx + " " + lastCircle_cy
			});
		}
	}

	// for adding the focus and blur event
	function reinitializeFoucsEvent() {
		AH.listenAll(".focusPoints", "focus", function (event) {
			// removes the class currentFocusPoint from the elements have class focusPoints
			AH.selectAll(".focusPoints", "removeClass", "currentFocusPoint");

			// adds the class currentFocusPoint to the element which got the focus and have class focusPoints 
			event.target.classList.add("currentFocusPoint");
		});

		AH.listenAll(".focusPoints", "blur", function () {
			// removes the class currentFocusPoint from the elements have class focusPoints
			AH.selectAll(".focusPoints", "removeClass", "currentFocusPoint");
		});
	}

	// for adding the mark point from the key event
	function markPointEvent(event) {
		if (event.screenX == undefined) {
			return;
		}

		if (startDrawingByKey && isDrawStop) {
			// stop the drawing and store the drawing sketched by the user and sets the user answer xml
			stopDraw();
		}

		if (event.keyCode == 13 || event.keyCode == 32 || event.screenX === 0) {
			// stops the events from being bubbled
			event.preventDefault();

			// joins the marked points by the help of line that starts with first mark point and ends at last masked point by moving in sequencial order
			markFinalPoints();

			if (isMarking) {
				// hides plus icon (+) that is used for sketch the graph via keyboard
				AH.select("#moveDrawIcon", "addClass", "h");

				// sets the cursor style to crosshair (+)
				AH.select("#previewSvg", "css", { "cursor": "crosshair" });
			} else {
				// shows plus icon (+) that is used for sketch the graph via keyboard
				AH.select("#moveDrawIcon", "removeClass", "h");

				// sets the cursor style to auto
				AH.select("#previewSvg", "css", { "cursor": "auto" });
			}
		} else if (event.type == "click" && event.screenX !== 0) {
			// joins the marked points by the help of line that starts with first mark point and ends at last masked point by moving in sequencial order
			markFinalPoints();
		}
	}

	// this function calls whenever there is click on toolbar buttons
	function toolbarAction(current, event) {
		if (isScribble) {
			stopDraw();
		}

		if (event.type == "click" || (event.keyCode == 13 || event.keyCode == 32)) {
			// assign the value of the data-title attribute of the drawing tool buttons or of delete button on which is clicked or on which keyuped
			previewMode = current.getAttribute("data-title");

			// sets the style of the cursor to crosshair (+)
			AH.select("#previewSvg", "css", { "cursor": "crosshair" });

			// hides the icon (+) that is used for sketch the drawing by the help of keyboard
			AH.select("#moveDrawIcon", "addClass", "h");

			// sets the value 0 of variable startDrawingByKey to indicate that drawing is not started by the keyboard
			startDrawingByKey = 0;

			// sets the value of the variable isDrawStop by 0 to indicate that sketching of the drawing either not started or in progress
			isDrawStop = 0;

			if (previewMode == "eraser") {
				// adds the class eraserHover to the element path that contains the drawing sketched by the help of drawing tools
				AH.selectAll(".previewDrawingPaths path", "addClass", "eraserHover");
			} else {
				// removes the class eraserHover to the element path that contains the drawing sketched by the help of drawing tools
				AH.selectAll(".previewDrawingPaths path", "removeClass", "eraserHover");
			}

			// hides the compass element
			AH.selectAll(".drawingCompassSvg", "addClass", "h");

			if (previewMode == "compass") {
				// shows the compass tool
				AH.selectAll(".drawingCompassSvg", "removeClass", "h");
			}

			// removes the all mark points and sets the value of the variable 'isMArking' to 1
			clearMarking();
		}

		if ((event.keyCode == 13 || event.keyCode == 32) && previewMode != "eraser" && previewMode != "compass") {
			// hides the icon (+), which is used to sketch the drawing using keyboard
			AH.select("#moveDrawIcon", "removeClass", "h");

			// sets the cursor style auto
			AH.select("#previewSvg", "css", { "cursor": "auto" });
		}

		if (startDrawingByKey && isDrawStop) {
			// stop the drawing and store the drawing sketched by the user and sets the user answer xml
			stopDraw();
		}
	}

	// this function calls when we are leaving the drawable area or on mouseup
	function previewMouseLeave(event) {
		switch (previewMode) {
			case "line":
			case "scribble":
				if (isDrawingPreview) {
					// sets the x and y co-ordinate of the mouse position
					setPreviewMouseCoordinates(event);

					if (lockFocus && (checkCurrentPositionX == preview_mouseX && checkCurrentPositionY == preview_mouseY && previewMode == "line" || previewMode == "scribble" && previewScribblePath[previewScribbleCount].d.split("L").length - 1 < 3)) {
						// removes the last element from the array previewScribblePath
						previewScribblePath.pop();
					}

					if (checkCurrentPositionX == preview_mouseX && checkCurrentPositionY == preview_mouseY && previewMode == "line" || previewMode == "scribble" && previewScribblePath[previewScribbleCount].d.split("L").length - 1 < 3) {
						// removes the last element from the array previewScribblePath
						previewScribblePath.pop();
					} else {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + preview_mouseX + " " + preview_mouseY);

						// adds value of variables preview_mouseX and preview_mouseY separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
						previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + preview_mouseX + " " + preview_mouseY;

						// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
						AH.select(".previewDrawingPaths").prepend(scribble);

						// increases the value of the variable previewScribbleCount by 1 
						previewScribbleCount++;

						// increases the value of the variable previewUndoCount by 1 
						previewUndoCount++;

						// makes array previewUndoList blank
						previewUndoList = [];

						// enabled clear screen and undo button
						AH.select("#preview_clearScreen").disabled = false;

						AH.select("#preview_undo").disabled = false;

						// disabled redo button
						AH.select("#preview_redo").disabled = true;
					}
				}
				// sets the value false of the variable isDrawingPreview 
				isDrawingPreview = false;
				break;
			case "compass":
				// indicates that radius is not increased
				isPreviewRadiusIncrease = 0;
				// indicates that radius is not rotated
				isPreviewRadiusRotate = 0;
				if (isPreviewCompassMove) {
					// sets the x and y co-ordinate of the mouse position
					setPreviewMouseCoordinates(event);

					// contains the x co-ordinate of the mouse position
					cx = preview_mouseX;

					// contains the y co-ordinate of the mouse position
					cy = preview_mouseY;

					// contains radius of the compass
					$$invalidate(0, previewCompassRadius = AH.select(".drawingCompassRoute").getAttribute("r"));

					// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
					updatePreviewCompassCalculation(cx, cy, previewCompassRadius, previewCompassAngle);

					// indicates that compass is not moved
					isPreviewCompassMove = false;
				}
				if (isDrawingPreview) {
					if (previewScribblePath[previewScribbleCount].d.split("L").length - 1 < 4) {
						// removes the last element from the array previewScribblePath
						previewScribblePath.pop();
					} else {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy);

						// adds value of variables lastCircle_cx and lastCircle_cy separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
						previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy;

						// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
						AH.select(".previewDrawingPaths").prepend(scribble);

						// increases the value of the variable previewScribbleCount by 1
						previewScribbleCount++;

						// increases the value of the variable previewUndoCount by 1
						previewUndoCount++;

						// makes array previewUndoList blank
						previewUndoList = [];

						// enabled clear screen (x) and undo button
						AH.select("#preview_clearScreen").disabled = false;

						AH.select("#preview_undo").disabled = false;

						// disabled the redo button
						AH.select("#preview_redo").disabled = true;
					}

					// sets value false of variable isDrawingPreview
					isDrawingPreview = false;
				}
				// sets the cursor style to grab when it lies on last circle on the rotation bar
				AH.selectAll("#previewSvg .lastCircle", "css", { "cursor": "grab" });
				break;
		}

		// contains copy of array previewScribblePath
		let tempArrayContainer = arrayCopy(previewScribblePath);

		// stores the drawing sketched by user and sets the user answer xml
		storeUserPaths(tempArrayContainer);
	}

	// checks the answer and shows the status of the answer
	function setReview() {
		$$invalidate(5, isReview = true);

		if (startDrawingByKey && isDrawStop || lockFocus) {
			// stop the drawing and store the drawing sketched by the user and sets the user answer xml
			stopDraw();
		}

		if (!isDrawCompassPreview && isStoreStart) {
			// stores the drawing sketched by user using keyboard and sets the user answer xml
			storeCompassPathByKey();
		}

		// checks the answer and updates the status and enables 'Mark Points' button and also updates its text as 'Mark Points' 
		parseXMLForAnswer(true);

		// contains the value of state array selectedTools at index 0 after removing the first character 
		previewMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

		// removes the class active from drawing tools, delete, and 'Mark Points' or 'Finish Marking' buttons
		AH.selectAll(".preview_btn,#mark_points", "removeClass", "active");

		// adds the class active to the drawing tool button which exist at index 0 in state array selectedTools
		AH.select("#preview" + state.selectedTools[0], "addClass", "active");

		if (previewMode == "compass") {
			// shows the compass tool
			AH.selectAll(".drawingCompassSvg", "removeClass", "h");
		} else {
			// hides the compass tool
			AH.selectAll(".drawingCompassSvg", "addClass", "h");
		}

		$$invalidate(2, state.remediationMode = "on", state);
		AH.selectAll(".previewBtnGrp", "addClass", "h");

		// sets the value 'none' of the variable previewMode
		previewMode = "none";

		// not allowed user to perform the task
		AH.selectAll(".preview_drawing_container", "css", { pointerEvents: "none" });

		// removes the class previewKeySvg from the svg element have id previewSvg
		AH.select("#previewSvg", "removeClass", "previewKeySvg");

		// removes the marked points and also the path that is sketched by the help of mark points
		AH.selectAll(".previewMarkingPaths .answer_mark", "remove");

		// updates user answer xml
		createUXML();

		// draw the marked points and the lines connecting to these points
		addMarkPointOnLoad(JSON.parse(markPointsData));

		// sets the tabindex and aria-label to the elements have class 'answer_mark' and tag name is path
		AH.selectAll("path.answer_mark", "attr", {
			"tabindex": "0",
			"aria-labelledby": "answerLine"
		});

		if (state.correctAnswer) {
			// append the title element inside the element previewMarkingPaths with correct message
			AH.insert(".previewMarkingPaths", "<title id=\"answerLine\">" + Lang.ans_correct + "</title>", "beforeend");

			// sets the stroke color of the mark points to #0F9D58
			AH.selectAll(".answer_mark", "css", { "stroke": "#0F9D58" });
		} else {
			// append the title element inside the element previewMarkingPaths with incorrect message
			AH.insert(".previewMarkingPaths", "<title id=\"answerLine\">" + Lang.ans_incorrect + "</title>", "beforeend");

			// sets the stroke color of the mark points to red
			AH.selectAll(".answer_mark", "css", { "stroke": "#FF0000" });

			// sets the stroke color of the answer point to #0F9D58
			AH.selectAll(".answer_circle", "css", { "stroke": "#0F9D58" });
		}
	}

	// allowed user to perform the task and changes the stroke color of mark points 
	function unsetReview() {
		$$invalidate(5, isReview = false);

		// allowed user to perform the task
		AH.selectAll(".preview_drawing_container", "css", { pointerEvents: "" });

		// shows all buttons
		AH.selectAll(".previewBtnGrp", "removeClass", "h");

		// adds the class previewKeySvg to the svg element have id previewSvg
		AH.select("#previewSvg", "addClass", "previewKeySvg");

		// contains the value of state array selectedTools at index 0 after removing the first character
		previewMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

		// it's also used below in this function so it can be removed
		AH.selectAll(".preview_btn,#mark_points", "removeClass", "active");

		// it's also used below in this function so it can be removed
		AH.select("#preview" + state.selectedTools[0], "addClass", "active");

		if (previewMode == "compass") {
			// shows compass tool
			AH.selectAll(".drawingCompassSvg", "removeClass", "h");

			// sets the style of the cursor to crosshair (+)
			AH.select("#previewSvg", "css", { "cursor": "crosshair" });

			// hides the icon (+) which is used to sketch the drawing using keyboard
			AH.select("#moveDrawIcon", "addClass", "h");
		} else {
			// hides compass tool
			AH.selectAll(".drawingCompassSvg", "addClass", "h");
		}

		// removes the class active from drawing tools, delete, and 'Mark Points' or 'Finish Marking' buttons
		AH.selectAll(".preview_btn,#mark_points", "removeClass", "active");

		// adds the class active to the drawing tool button which exist at index 0 in state array selectedTools
		AH.selectAll("#preview" + state.selectedTools[0], "addClass", "active");

		// removes the correct answer circle that can be seen on remediation mode in green stroke color
		AH.selectAll(".correct_answer_container .answer_mark", "remove");

		// enables the element have id mark_points and updates its text as 'Mark Points'
		AH.select("#mark_points").innerText = "Mark Points";

		AH.select("#mark_points").disabled = false;

		// sets the value of the variable 'isMarking' to 1
		isMarking = 1;

		$$invalidate(2, state.remediationMode = "off", state);

		// removes the title element inside the element have class previewMarkingPaths
		AH.selectAll(".previewMarkingPaths title", "remove");

		// sets the value state markPointColor into the value of attribute stroke of the element have class answer_mark and removes attribute tabindex
		AH.selectAll(".answer_mark", "css", { "stroke": state.markPointColor });

		AH.selectAll(".answer_mark", "removeAttr", "tabindex");
	}

	// parses the xml and updates the values of variables and states and width, src, alt of the background image, shows the enabled drawing tools and sets the mark point position and draw the lines using mark points
	function parseXMLForGettingData() {
		try {
			// contains json data of the xml
			defaultXML = XMLToJSON(xml);

			if (defaultXML.smxml._markPointColor == undefined) {
				// sets the value of the key markPointColor to #00ff00 of json defaultXML
				defaultXML.smxml._markPointColor = "#00ff00";
			}

			if (defaultXML.smxml._color == undefined) {
				// sets the value of the key color to rgb(0, 188, 212) of json defaultXML
				defaultXML.smxml._color = "rgb(0, 188, 212)";
			}

			prev_store.update(item => {
				// sets the value of state bgImg to the value of key bgimg of json defaultXML
				item.bgImg = defaultXML.smxml._bgimg;

				// sets the value of state alt to the value of key imgAlt of json defaultXML
				item.alt = defaultXML.smxml._imgAlt;

				// sets the value of state imgWidth to the value of key width of json defaultXML
				item.imgWidth = defaultXML.smxml._width;

				// sets the value of state lineColor to the value of key color of json defaultXML
				item.lineColor = defaultXML.smxml._color;

				// sets the value of state focusDATA to the value of subkey cdata of key backgroundPoint of json defaultXML
				item.focusDATA = defaultXML.smxml.backgroundPoint.__cdata;

				// sets the value of state markPointColor to the value of key markPointColor of json defaultXML
				item.markPointColor = defaultXML.smxml._markPointColor;

				// sets the value of state selectedTools to the value of key 'selectedDrawingType' after joining it with commam of json defaultXML
				item.selectedTools = defaultXML.smxml.div._selectedDrawingType.split(",");

				return item;
			});

			// makes array 'accessibilityPoints' to empty
			accessibilityPointsPreview = [];

			// assign the value 1 to the variable focusPointCountPreview
			focusPointCountPreview = 1;

			// assign the value of state focusDATA into variable updatedFocusCDATA
			let updatedFocusCDATA = state.focusDATA;

			// replaces the character '!' to ',' and wraps the value into square bracket
			updatedFocusCDATA = "[" + updatedFocusCDATA.replace(/!/g, ",") + "]";

			// contains javascript object 
			updatedFocusCDATA = JSON.parse(updatedFocusCDATA);

			// removes the element circle, path and title from element have class 'backgroundFocusPathPreview' and 'backgroundFocusPointPreview'
			AH.selectAll(".backgroundFocusPointPreview circle,.backgroundFocusPathPreview path, .backgroundFocusPointPreview title", "remove");

			for (let index = 0; index < updatedFocusCDATA.length; index++) {
				// pushes data of multi dimesion array updatedFocusCDATA specified at perticular row and column where value of row and column is equals to the value of variable 'index' into array previewScribblePath
				accessibilityPointsPreview.push(updatedFocusCDATA[index][index]);
			}

			for (let index = 0; index < updatedFocusCDATA.length; index++) {
				for (let subPoints = 0; subPoints < updatedFocusCDATA[index][index].length; subPoints++) {
					// updates the value of key x of multi dimention array object 'accessibilityPointsPreview' where row and column values are value of variable 'index' and 'subPoints' with the value of key x of multi dimention array updatedFocusCDATA object where row and column values are the value of variables 'index' and 'subPoints'
					accessibilityPointsPreview[index][subPoints].x = updatedFocusCDATA[index][index][subPoints].x;

					// updates the value of key y of multi dimention array object 'accessibilityPointsPreview' where row and column values are value of variable 'index' and 'subPoints' with the value of key y of multi dimention array object updatedFocusCDATA where row and column values are the value of variables 'index' and 'subPoints'
					accessibilityPointsPreview[index][subPoints].y = updatedFocusCDATA[index][index][subPoints].y;

					// Creates an element with the specified namespace URI and qualified name.
					scribble = document.createElementNS(xmlns, "circle");

					// sets the stroke color and width
					setPreviewColor("#808080", previewThickness);

					// adds a new attribute 'aria-labelledby' (with a namespace null)
					scribble.setAttributeNS(null, "aria-labelledby", "focusPoint_" + focusPointCountPreview + "_title focusPoint_" + focusPointCountPreview + "_desc");

					// adds a new attribute 'tabindex' (with a namespace null)
					scribble.setAttributeNS(null, "tabindex", "0");

					// adds a new attribute 'class' (with a namespace null)
					scribble.setAttributeNS(null, "class", "focusPoints");

					// adds a new attribute 'data-focusOrder' (with a namespace null)
					scribble.setAttributeNS(null, "data-focusOrder", focusPointCountPreview);

					// adds a new attribute 'cx' (with a namespace null)
					scribble.setAttributeNS(null, "cx", accessibilityPointsPreview[index][subPoints].x);

					// adds a new attribute 'cy' (with a namespace null)
					scribble.setAttributeNS(null, "cy", accessibilityPointsPreview[index][subPoints].y);

					// adds a new attribute 'r' (with a namespace null)
					scribble.setAttributeNS(null, "r", "2px");

					// place the scribble element before very first element inside the element have class 'backgroundFocusPointPreview'
					AH.select(".backgroundFocusPointPreview").append(scribble);

					// adds title and description of focus point for screen reader
					AH.insert(".backgroundFocusPointPreview", "<title id=\"focusPoint_" + focusPointCountPreview + "_title\">You are on the " + focusPointCountPreview + " Point </title><desc id=\"focusPoint_" + focusPointCountPreview + "_desc\">Press shift + tab to move towards the previous point or tab to move towards the next points</desc>", "beforeend");

					// increases the value of variable 'focusPointCountPreview' by 1
					focusPointCountPreview++;
				}

				// join the marked points and sets the color and width of the stroke 
				joinMarkedPoint(accessibilityPointsPreview[index], 1);
			}

			// contains the stroke color
			previewColor = state.lineColor;

			// makes array previewScribblePath blank for remove the drawing sketched by the help of drawing tools
			previewScribblePath = [];

			// sets the value true of the variable isDrawCompassPreview
			isDrawCompassPreview = true;

			// sets the value false of the variable isStoreStart
			isStoreStart = false;

			// sets the value 0 of the variable isDrawStop
			isDrawStop = 0;

			// shows that drawing is not start via keyboard
			startDrawingByKey = 0;

			// shows number of drawing sketched with the help of drawing tools
			previewScribbleCount = 0;

			// counts the number of undo can be done
			previewUndoCount = 0;

			// makes array previewUndoList blank to remove the all undo done
			previewUndoList = [];

			// makes array previewRedoList blank to remove the all redo done
			previewRedoList = [];

			// sets the value of the variable 'isMarking' to 1
			isMarking = 1;

			// makes array markPoints blank to remove the mark point
			markPoints = [];

			// removes the first character from the string exist in state array selectedTools at index 0
			previewMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

			if (editorState) {
				// removes drawing sketched by the help of drawing tools and marked points and also lines that is drawn automatically using mark points
				AH.selectAll(".previewMarkingPaths .answer_mark,.previewDrawingPaths path", "remove");
			}

			if (previewMode == "compass") {
				// shows the compass tool
				AH.selectAll(".drawingCompassSvg", "removeClass", "h");

				// sets the cursor style to crosshair (+)
				AH.select("#previewSvg", "css", { "cursor": "crosshair" });

				// hides icon (+) used for sketch the drawing using keyboard
				AH.select("#moveDrawIcon", "addClass", "h");
			} else {
				// hides the compass element
				AH.selectAll(".drawingCompassSvg", "addClass", "h");
			}

			// enabled the button have id mark_points and update its text to 'Mark Points' 
			AH.select("#mark_points").disabled = false;

			AH.select("#mark_points").innerText = "Mark Points";

			// disabled the undo, redo and clear screen (x) buttons
			AH.select("#preview_undo").disabled = true;

			AH.select("#preview_redo").disabled = true;
			AH.select("#preview_clearScreen").disabled = true;

			// removes the drawing tool buttons
			AH.selectAll(".geometryToolPreview", "addClass", "h");

			for (let toolsIndex = 0; toolsIndex < state.selectedTools.length; toolsIndex++) {
				// shows the drawing tools buttons that exist in state array selectedTools
				AH.select("#preview" + state.selectedTools[toolsIndex], "removeClass", "h");
			}

			// removes the class active from drawing tools, delete and 'Mark Points' buttons
			AH.selectAll(".preview_btn,#mark_points", "removeClass", "active");

			// adds the class active to scribble drawing tool button
			AH.select("#preview" + state.selectedTools[0], "addClass", "active");

			// sets the width of the background image container
			AH.selectAll(".preview_drawing_toolbar, .centerImgPreview", "attr", {
				"style": "width:" + (Number(state.imgWidth) + 2) + "px"
			});

			// sets the width, src and alt message of the background image
			AH.select(".centerImg #svgImgPreview", "attr", {
				"src": bgImgPath + "" + state.bgImg,
				"alt": state.alt,
				"width": state.imgWidth
			});

			AH.enableBsAll(".tooltip_btn", "Tooltip", { container: "body" });
		} catch(error) {
			console.warn({
				error,
				func: "parseXMLForGettingData @271"
			});
		}
	}

	// joins the marked points by the help of line that starts with first mark point and ends at last masked point by moving in sequencial order
	function markFinalPoints() {
		// hides the compass container
		AH.selectAll(".drawingCompassSvg", "addClass", "h");

		// removes the class 'eraserHover' from the element 'path' inside the element have id 'previewSvg'
		AH.selectAll("#previewSvg path", "removeClass", "eraserHover");

		if (isMarking) {
			// removes the class active from the drawing tools and delete buttons
			AH.selectAll(".preview_btn", "removeClass", "active");

			// sets the text of the button 'Mark Points' to 'Finish MArking' and adds class active to it
			AH.select("#mark_points").innerText = "Finish Marking";

			AH.select("#mark_points", "addClass", "active");

			// sets the value of the variable 'isMarking' to 0
			isMarking = 0;

			// removes the mark points and lines
			AH.selectAll(".previewMarkingPaths .answer_mark", "remove");

			// makes array userMarkingPoint to empty
			userMarkingPoint = [];

			// makes array markPoints to empty
			markPoints = [];

			if (!editorState) {
				// removes the correct answer circle that can be seen on remediation mode in green stroke color
				AH.selectAll(".correct_answer_container .answer_mark", "remove");
			}

			// sets value of variable 'previewMode' to 'markPoints'
			previewMode = "markPoints";
		} else {
			// stes the test of the button 'Finish Marking' to 'Mark Points' and adds class active to it
			AH.select("#mark_points").innerText = "Mark Points";

			AH.select("#mark_points", "removeClass", "active");

			if (markPoints.length >= 1) {
				// join the marked points and sets the color and width of the stroke 
				joinMarkedPoint(markPoints);

				if (state.remediationMode == "on") {
					// checks the answer and updates the status and enables 'Mark Points' button and also updates its text as 'Mark Points' 
					parseXMLForAnswer();
				}
			}

			// contains the value of index 0 of state array selectedTools after removing the first character
			previewMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

			// hides the icon (+) used to sketch the drawing by the help of keyboard
			AH.select("#moveDrawIcon", "addClass", "h");

			// styles the cursor to crosshair (+)
			AH.select("#previewSvg", "css", { "cursor": "crosshair" });

			// adds the active class to the drawing tool exist at index 0 in state array selectedTools
			AH.select("#preview" + state.selectedTools[0], "addClass", "active");

			if (previewMode == "compass") {
				// shows the compass tool
				AH.selectAll(".drawingCompassSvg", "removeClass", "h");
			} else {
				// hides the compass tool
				AH.selectAll(".drawingCompassSvg", "addClass", "h");
			}

			// sets the value of the variable 'isMarking' to 1
			isMarking = 1;
		}
	}

	// draw the marked points and the lines connecting to these points
	function addMarkPointOnLoad(array) {
		for (let index = 0; index < array.length; index++) {
			// Creates an element with the specified namespace URI and qualified name.
			scribble = document.createElementNS(xmlns, "circle");

			// sets the stroke color and width
			setPreviewColor(state.markPointColor, previewThickness);

			// adds a new attribute 'class' (with a namespace null)
			scribble.setAttributeNS(null, "class", "answer_mark");

			// adds a new attribute 'cx' (with a namespace null)
			scribble.setAttributeNS(null, "cx", array[index].x);

			// adds a new attribute 'cy' (with a namespace null)
			scribble.setAttributeNS(null, "cy", array[index].y);

			// adds a new attribute 'r' (with a namespace null)
			scribble.setAttributeNS(null, "r", "2px");

			// prepend the element stored into variable scribble in mark point container in which drawings are stored done by the help of 'Mark Poin' And 'Finish Marking' buttons
			AH.select(".previewMarkingPaths").prepend(scribble);
		}

		// join the marked points and sets the color and width of the stroke 
		joinMarkedPoint(array);
	}

	// used to load the module according to the data of smxml and smans xml
	function loadModule(uaXML, drawMark) {
		// contains the json data of user answer xml
		uaXML = XMLToJSON(uaXML);

		// contains the x and y co-ordinate of the points marked by user
		userMarkingPoint = JSON.parse(uaXML.smans.markpoints);

		if (uaXML.smans.userDrawPath == undefined) {
			// sets the value of userDataPath to blank that indicates that no drawing is sketched
			uaXML.smans.userDrawPath = "";
		}

		// contains drawing data sketched by the help of drawing tools in the form of javascript object 
		userDrawPath = JSON.parse(uaXML.smans.userDrawPath);

		// defines the value true or false of the variable userAnsCorrect according to the value of ansCorrect of user answer xml
		userAnsCorrect = uaXML.smans.ansCorrect.toLowerCase() == "true"
		? true
		: false;

		// contains json data of xml props
		defaultXML = XMLToJSON(xml);

		// contains cdata of drawing of smxml that have to be performed by the help of drawing tools for correct answer
		cdata = defaultXML.smxml.div.__cdata;

		// replace the character '!' with ',' from cdata and wrap it in square bracket
		cdata = "[" + cdata.replace(/!/g, ",") + "]";

		// converts cdata string into javascript object
		cdata = JSON.parse(cdata);

		// draw the marked points and the lines connecting to these points
		addMarkPointOnLoad(userMarkingPoint);

		// creates the drawing sketched by user
		createUserPath();

		// checks the answer is correct or incorrect
		checkCorrectAnswer(userMarkingPoint, drawMark);

		// sets the status of the answer ( correct or incorrect message with showing the UI that indicates correct or incorrect)
		setStatusOfAns(userAnsCorrect, userMarkingPoint, drawMark);
	}

	// removes drawing on which keyup event triggered and update the user answer xml
	function eraser(curClass, curArray) {
		if (AH.select(curClass).getAttribute("data-order") != undefined) {
			// makes array previewUndoList blank
			previewUndoList = [];

			// a temporary variable used of 
			let tempArrayContainer = "";

			// find the index of the drawing on which keyup event fired exist in array curArray
			let currentIndex = curArray.indexOf(curArray[AH.select(curClass).getAttribute("data-order")]);

			// contains current element from array curArray after converting it into string and wraping in square bracket
			let convertJSONtoArray = "[" + JSON.stringify(curArray[currentIndex]) + "]";

			// contains copy of array convertJSONtoArray
			tempArrayContainer = arrayCopy(JSON.parse(convertJSONtoArray));

			// adds the value remove of mode key exist at index 0 in array tempArrayContainer
			tempArrayContainer[0].mode = "remove";

			// pushes the data of array 'tempArrayContainer' exist on index 0 into array curArray
			curArray.push(tempArrayContainer[0]);

			// contains copy of array curArray
			let eraserArrayContainer = arrayCopy(curArray);

			// stores the drawing sketched by user and sets the user answer xml
			storeUserPaths(eraserArrayContainer);

			// increases the value of the variable previewScribbleCount by 1
			previewScribbleCount++;

			// increases the value of the variable previewUndoCount by 1
			previewUndoCount++;

			// removes the current drawing on which keyup event fired
			AH.select(curClass, "remove");

			// disabled the redo button
			AH.select("#preview_redo").disabled = true;

			// enables undo button
			AH.select("#preview_undo").disabled = false;

			if (AH.selectAll(".previewDrawingPaths path").length == 0) {
				// disabled the clear screen button (x)
				AH.select("#preview_clearScreen").disabled = true;
			}
		}
	}

	// stores the drawing sketched by user and sets the user answer xml
	function storeUserPaths(drawPathArray) {
		// makes array userAnsPath blank
		userAnsPath = [];

		// creates the variable subindex and assign the value 0
		let subindex = 0;

		for (let index = 0; index < drawPathArray.length; index++) {
			subindex = index + 1;

			while (subindex < drawPathArray.length) {
				if (drawPathArray[index].type == drawPathArray[subindex].type) {
					if (drawPathArray[index].mode == "add" && drawPathArray[subindex].mode == "remove") {
						// sets the value null of mode key of array drawPathArray have index defined in variable 'index'
						drawPathArray[index].mode = null;

						// sets the value null of mode key of array drawPathArray have index defined in variable 'subindex'
						drawPathArray[subindex].mode = null;
					}
				}

				// increases the value of the variable subindex by 1
				subindex++;
			}
		}

		for (let index = 0; index < drawPathArray.length; index++) {
			// Return an array of all the values in the drawPathArray array whose value of mode key is not null
			drawPathArray = drawPathArray.filter(function (element) {
				return element.mode != null;
			});
		}

		// pushes data of array drawPathArray into array userAnsPath
		userAnsPath.push(drawPathArray);

		// updates user answer xml
		createUXML();
	}

	// creates user answer xml
	function createUXML() {
		// makes array markPointsData empty
		markPointsData = [];

		if (markPoints.length == 0) {
			// contains the x and y co-ordinate of the points marked by user
			markPointsData = JSON.stringify(userMarkingPoint);
		} else {
			// contains the x and y co-ordinate of the points marked by user
			markPointsData = JSON.stringify(markPoints);
		}

		// contains proforma of user answer xml with points marked by user, drawing sketched by user and state of answer  
		userAnsXML = "<smans type=\"41\"><markpoints>" + markPointsData + "</markpoints><userDrawPath>" + JSON.stringify(userAnsPath[0]) + "</userDrawPath><ansCorrect>" + isAnswerCorrect + "</ansCorrect></smans>";

		// defined that user answer xml changed
		window.ISSPECIALMODULEUSERXMLCHANGE = 1;

		// sets the user answer xml
		AH.select("#special_module_user_xml", "value", userAnsXML);
	}

	// creates the drawing sketched by user
	function createUserPath() {
		if (userDrawPath.length) {
			// enables the cross and undo buttons 
			AH.select("#preview_undo").disabled = false;

			AH.select("#preview_undo").disabled = false;
		}

		for (let index = 0; index < userDrawPath.length; index++) {
			// sets the type key value of the object exist at index defined in variable 'index' of array userDrawPath by adding the value of variable 'index' in its previous value
			userDrawPath[index].type = userDrawPath[index].type.substr(0, userDrawPath[index].type.indexOf("_")) + "_" + index;

			// sets the order key value of the object exist at index defined in variable 'index' of array userDrawPath by adding the value of variable 'index'
			userDrawPath[index].order = index;

			// Creates an element with the value of variable xmlns namespace URI and 'path' name
			scribble = document.createElementNS(xmlns, "path");

			// sets the stroke color and width
			setPreviewColor(previewColor, previewThickness);

			// adds a new attribute 'data-type' (with a namespace null)
			scribble.setAttributeNS(null, "data-type", userDrawPath[index].type);

			// adds a new attribute 'data-order' (with a namespace null)
			scribble.setAttributeNS(null, "data-order", userDrawPath[index].order);

			// adds a new attribute 'd' (with a namespace null)
			scribble.setAttributeNS(null, "d", userDrawPath[index].d);

			// adds a new attribute 'tabindex' (with a namespace null)
			scribble.setAttributeNS(null, "tabindex", "0");

			// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
			AH.select(".previewDrawingPaths").prepend(scribble);
		}

		// sets the value of the variable 'previewScribbleCount' to  the value of length of the array 'userDrawPath'
		previewScribbleCount = userDrawPath.length;

		// contains copy of array userDrawPath
		previewScribblePath = arrayCopy(userDrawPath);
	}

	// join the marked points and sets the color and width of the stroke 
	function joinMarkedPoint(markArray, focusPoint) {
		if (markArray.length == 0) {
			return;
		}

		// Creates an element with the value of variable xmlns namespace URI and 'path' name
		scribble = document.createElementNS(xmlns, "path");

		// sets the starting position of the drawing
		let pointStartValues = "M " + markArray[0].x + " " + markArray[0].y;

		// variable for end point
		let pointEndValues = "";

		for (let index = 1; index < markArray.length; index++) {
			// adds the value of x and y into previous value of the variable pointEndValues from the array 'markArray' at index defined in variable 'index'
			pointEndValues += " L " + markArray[index].x + " " + markArray[index].y;
		}

		// adds a new attribute 'd' (with a namespace null)
		scribble.setAttributeNS(null, "d", pointStartValues + "" + pointEndValues);

		if (focusPoint) {
			// sets the stroke color and width
			setPreviewColor("rgb(128, 128, 128)", previewThickness);

			// prepend the element assigned into variable 'scribble' in background focus container element
			AH.select(".backgroundFocusPathPreview").prepend(scribble);
		} else {
			// sets the stroke color and width
			setPreviewColor(state.markPointColor, previewThickness);

			// adds a new attribute 'class' (with a namespace null)
			scribble.setAttributeNS(null, "class", "answer_mark");

			// prepend the element stored into variable scribble in mark point container in which drawings are stored done by the help of 'Mark Poin' And 'Finish Marking' buttons
			AH.select(".previewMarkingPaths").prepend(scribble);
		}
	}

	// checks the answer and updates the status and enables 'Mark Points' button and also updates its text as 'Mark Points' 
	function parseXMLForAnswer(drawMark) {
		// contains the json data of the xml of props
		defaultXML = XMLToJSON(state.xml);

		// contains the value of cdata inside div of smxml
		cdata = defaultXML.smxml.div.__cdata;

		// replaces the character '!' with ',' and wraps in square bracket of the value of cdata variable
		cdata = "[" + cdata.replace(/!/g, ",") + "]";

		// parses the cdata string value into javascript object
		cdata = JSON.parse(cdata);

		// creates an array markPointsAnsData
		let markPointsAnsData = [];

		// assign the value of array markPoints into array markPointsAnsData
		markPointsAnsData = markPoints;

		if (!editorState) {
			if (uxml) {
				if (markPoints.length == 0) {
					// contains the x and y co-ordinate of the points marked by user
					markPointsAnsData = userMarkingPoint;
				}
			}
		}

		// checks the answer is correct or incorrect
		checkCorrectAnswer(markPointsAnsData, drawMark);

		// sets the status of the answer ( correct or incorrect message with showing the UI that indicates correct or incorrect)
		setStatusOfAns(isAnswerCorrect, markPointsAnsData, drawMark);

		if (drawMark) {
			// enables the element have id mark_points and updates its text as 'Mark Points'
			AH.select("#mark_points").innerText = "Mark Points";

			AH.select("#mark_points").disabled = false;

			// sets the value of the variable 'isMarking' to 1
			isMarking = 1;
		}
	}

	// stores the drawing sketched by user using keyboard and sets the user answer xml
	function storeCompassPathByKey() {
		// removes the class lastCircle_hover from the last circle that exist on rotation bar of the compass
		AH.selectAll("#previewSvg .lastCircle", "removeClass", "lastCircle_hover");

		// sets the style of the cursor to grab when cursor lies inside last circle
		AH.selectAll("#previewSvg .lastCircle", "css", { "cursor": "grab" });

		// sets the value true of variable isDrawCompassPreview
		isDrawCompassPreview = true;

		if (previewScribblePath[previewScribbleCount].d.indexOf("L") == -1) {
			// removes the last element from the array previewScribblePath
			previewScribblePath.pop();
		} else {
			// adds a new attribute 'd' (with a namespace null)
			scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy);

			// adds value of variables lastCircle_cx and lastCircle_cy separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
			previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy;

			// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools 
			AH.select(".previewDrawingPaths").prepend(scribble);

			// increases the value of variable previewScribbleCount by 1
			previewScribbleCount++;

			// increases the value of variable previewUndoCount by 1
			previewUndoCount++;

			// makes array previewUndoList blank 
			previewUndoList = [];

			// enables the cross (x) and undo button
			AH.select("#preview_undo").disabled = false;

			AH.select("#preview_clearScreen").disabled = false;

			// disabled the redo button
			AH.select("#preview_redo").disabled = true;
		}

		// contains copy of array previewScribblePath
		let tempArrayContainer = arrayCopy(previewScribblePath);

		// stores the drawing sketched by user and sets the user answer xml
		storeUserPaths(tempArrayContainer);
	}

	// removes the all mark points and sets the value of the variable 'isMArking' to 1
	function clearMarking() {
		// removes the mark points and lines 
		AH.selectAll(".previewMarkingPaths .answer_mark", "remove");

		if (!editorState) {
			// removes the correct answer circle that can be seen on remediation mode in green stroke color
			AH.selectAll(".correct_answer_container .answer_mark", "remove");
		}

		// makes array markPoints empty
		markPoints = [];

		// sets the text 'Mark Points' of the element having id 'mark_points' and enabled that element
		AH.select("#mark_points").innerText = "Mark Points";

		AH.select("#mark_points").disabled = false;

		// sets the value of variable isMArking to 1 that indicates that mark can be draw
		isMarking = 1;
	}

	// checks the answer is correct or incorrect
	function checkCorrectAnswer(markArray, drawMark) {
		// creates correctAnswer array
		let correctAnswer = [];

		if (drawMark) {
			for (let index = 0; index < cdata.length; index++) {
				// Creates an element with the specified namespace URI and qualified name.
				scribble = document.createElementNS(xmlns, "circle");

				// sets the stroke color and width
				setPreviewColor("#0F9D58", "2");

				// adds a new attribute 'class' (with a namespace null)
				scribble.setAttributeNS(null, "class", "answer_mark answer_circle");

				// adds a new attribute 'cx' (with a namespace null)
				scribble.setAttributeNS(null, "cx", cdata[index].x);

				// adds a new attribute 'cy' (with a namespace null)
				scribble.setAttributeNS(null, "cy", cdata[index].y);

				// adds a new attribute 'r' (with a namespace null)
				scribble.setAttributeNS(null, "r", cdata[index].r);

				// prepend the created element with the value of variable 'xmlns' namespace URI and circle name in element have class 'correct_answer_container'
				AH.select(".correct_answer_container").prepend(scribble);
			}
		}

		if (cdata.length == 0 || markArray.length == 0) {
			// sets the value of variable 'isAnswerCorrect' to false
			isAnswerCorrect = false;

			return;
		}

		// sets the value of the variable 'lineCount' according to the length of the array markArray
		let lineCount = markArray.length == 1
		? markArray.length
		: markArray.length - 1;

		for (let cdataIndex = 0; cdataIndex < cdata.length; cdataIndex++) {
			for (let index = 0; index < lineCount; index++) {
				if (lineCount == 1 && markArray.length == 1 && checkIntersection(markArray[index].x, markArray[index].y, 0, 0, cdata[cdataIndex].x, cdata[cdataIndex].y, cdata[cdataIndex].r)) {
					// push data 'Match' into array correctAnswer
					correctAnswer.push("Match");

					break;
				}

				if (lineCount >= 1 && markArray.length > 1 && checkIntersection(markArray[index].x, markArray[index].y, markArray[index + 1].x, markArray[index + 1].y, cdata[cdataIndex].x, cdata[cdataIndex].y, cdata[cdataIndex].r)) {
					// push data 'Match' into array correctAnswer
					correctAnswer.push("Match");

					break;
				}
			}
		}

		if (correctAnswer.length == cdata.length) {
			// sets the value of variable 'isAnswerCorrect' to true
			isAnswerCorrect = true;
		} else {
			// sets the value of variable 'isAnswerCorrect' to false
			isAnswerCorrect = false;
		}

		// makes correctAnswer array empty
		correctAnswer = [];
	}

	// sets the status of the answer ( correct or incorrect message with showing the UI that indicates correct or incorrect)
	function setStatusOfAns(isAnswerCorrect, markArray, drawMark) {
		if (isAnswerCorrect) {
			// stes the value of the state correctAnswer to true
			$$invalidate(2, state.correctAnswer = true, state);

			if (drawMark) {
				if (cdata.length && markArray.length) {
					// join the marked points and sets the color and width of the stroke 
					joinMarkedPoint(markArray);
				}

				// sets the stroke color of element have class 'answer_mark' to #0F9D58
				AH.selectAll(".answer_mark", "css", { "stroke": "#0F9D58" });

				// sets the value of the message variable to correct
				if (editorState) {
					// shows correct
					showAns(Lang.correct);
				}
			}
		} else {
			$$invalidate(2, state.correctAnswer = false, state);

			if (drawMark) {
				if (cdata.length && markArray.length) {
					// join the marked points and sets the color and width of the stroke 
					joinMarkedPoint(markArray);
				}

				// sets the stroke color of the mark points and lines that are draw using mark points to #ff0000
				AH.selectAll(".answer_mark", "css", { "stroke": "#ff0000" });

				AH.selectAll(".answer_circle", "css", { "stroke": "#0F9D58" });

				if (editorState) {
					// shows answer incorrect
					showAns(Lang.incorrect);
				}
			}
		}

		// check or uncheck the element have id 'answer' according to the value of variable isAnswerCorrect
		// AH.select("#answer").checked = state.correctAnswer;
		onUserAnsChange({
			uXml: userAnsXML,
			ans: state.correctAnswer
		});
	}

	// updates the value of compass radius and angle
	function checkPreviewRadiusAndAngle() {
		// contains the value of initial x co-ordinate of compass rotation bar 
		initialPoint.x = Number(AH.select(".compassRotationBar").getAttribute("x1"));

		// contains the value of initial y co-ordinate of compass rotation bar
		initialPoint.y = Number(AH.select(".compassRotationBar").getAttribute("y1"));

		// contains the value of final x co-ordinate of compass rotation bar
		finalPoint.x = Number(AH.select(".compassRotationBar").getAttribute("x2"));

		// contains the value of final y co-ordinate of compass rotation bar
		finalPoint.y = Number(AH.select(".compassRotationBar").getAttribute("y2"));

		// // contains the length of compass rotation bar
		$$invalidate(0, previewCompassRadius = Number(AH.select(".drawingCompassRoute").getAttribute("r")));

		// contains the value of compass angle using the co-ordinates of the initial and final points
		$$invalidate(1, previewCompassAngle = Math.atan2(finalPoint.y - initialPoint.y, finalPoint.x - initialPoint.x) * 180 / Math.PI);
	}

	// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
	function updatePreviewCompassCalculation(cx, cy, previewCompassRadius, previewCompassAngle) {
		// sets the center of x of middle circle lies on compass rotationbar
		midCircle_cx = cx + previewCompassRadius / 2 * Math.cos(previewCompassAngle * (Math.PI / 180));

		// sets the center of y of middle circle lies on compass rotationbar
		midCircle_cy = cy + previewCompassRadius / 2 * Math.sin(previewCompassAngle * (Math.PI / 180));

		// sets the center of x of small middle circle lies on compass rotationbar
		midSmallCircle_cx = cx + 3 * previewCompassRadius / 4 * Math.cos(previewCompassAngle * (Math.PI / 180));

		// sets the center of y of small middle circle lies on compass rotationbar
		midSmallCircle_cy = cy + 3 * previewCompassRadius / 4 * Math.sin(previewCompassAngle * (Math.PI / 180));

		// sets the center of x of last circle lies on compass rotationbar
		lastCircle_cx = cx + previewCompassRadius * Math.cos(previewCompassAngle * (Math.PI / 180));

		// sets the center of y of last circle lies on compass rotationbar
		lastCircle_cy = cy + previewCompassRadius * Math.sin(previewCompassAngle * (Math.PI / 180));

		// sets the center of x of rotation icon that can be seen just in front of the last circle to indication that move the rotationbar in these directions to draw the circular curve
		lastSmallCircle_cx = cx + 5 * previewCompassRadius / 4 * Math.cos(previewCompassAngle * (Math.PI / 180));

		// sets the center of x of rotation icon that can be seen just in front of the last circle to indication that move the rotationbar in these directions to draw the circular curve
		lastSmallCircle_cy = cy + 5 * previewCompassRadius / 4 * Math.sin(previewCompassAngle * (Math.PI / 180));

		// sets the center co-ordinate of the compass and of its route
		AH.selectAll(".drawingCompassRoute,.drawingCompassCenter", "attr", { cx, cy });

		// sets the radius of the compass or length of the rotationbar
		AH.selectAll(".drawingCompassRoute", "attr", { "r": previewCompassRadius });

		// sets the co-ordinates of start and end points of the compass rotation bar
		AH.selectAll(".compassRotationBar", "attr", {
			"x1": cx,
			"y1": cy,
			"x2": lastCircle_cx,
			"y2": lastCircle_cy
		});

		// sets the values of the center of the rotation indicator and rotate it in 3D dimention for defined variables value that can be seen after hover on the last circle lies on rotation bar
		AH.selectAll("#previewSvg .lastCircleMid", "attr", {
			"cx": lastSmallCircle_cx,
			"cy": lastSmallCircle_cy,
			"transform": "rotate(" + previewCompassAngle + "," + lastSmallCircle_cx + "," + lastSmallCircle_cy + ")"
		});

		// sets the center of the last circle lies on rotation bar
		AH.selectAll("#previewSvg .lastCircle", "attr", { "cx": lastCircle_cx, "cy": lastCircle_cy });

		// sets the values of the center of small middle circle and rotate it in 3D dimention for defined variables value
		AH.selectAll("#previewSvg .midSmallCircle", "attr", {
			"cx": midSmallCircle_cx,
			"cy": midSmallCircle_cy,
			"transform": "rotate(" + previewCompassAngle + "," + midSmallCircle_cx + "," + midSmallCircle_cy + ")"
		});

		// sets the values of the center of middle circle and rotate it in 3D dimention for defined variables value
		AH.selectAll("#previewSvg .mid_circle", "attr", {
			"cx": midCircle_cx,
			"cy": midCircle_cy,
			"transform": "rotate(" + previewCompassAngle + "," + midCircle_cx + "," + midCircle_cy + ")"
		});

		// assign the value of variable previewCompassAngle into variable curAngle
		let curAngle = previewCompassAngle;

		if (curAngle < 0) {
			// adds 360 degree value in it's previous value of variable curAngle
			curAngle = 360 + curAngle;
		}

		// sets the message about angle for screen reader
		AH.select("#compassRotationTitle").innerText = "Compass Angle, Your Current Angle is " + curAngle.toFixed(0) + " degree";

		// sets the message about radius for screen reader
		AH.select("#compassRadiusTitle").innerText = "Compass Radius, Your Current Radius is " + (previewCompassRadius * 0.02649).toFixed(1) + "cm";
	}

	// sets the x and y co-ordinate of the mouse position
	function setPreviewMouseCoordinates(event) {
		// contains the size of element having id 'authoringSvg' and its position relative to the viewport
		let boundary = document.getElementById("previewSvg").getBoundingClientRect();

		// sets the x position of the mouse co-ordinate
		preview_mouseX = event.clientX - boundary.left;

		// sets the y position of the mouse co-ordinate
		preview_mouseY = event.clientY - boundary.top;
	}

	// sets the stroke color and width
	function setPreviewColor(previewColor, previewThickness) {
		// sets the stroke color of the drawing
		scribble.style.stroke = previewColor;

		// sets the stroke width of the drawing
		scribble.style.strokeWidth = previewThickness;

		scribble.style.fill = "none";
	}

	// changes the value of radius, angle, and center of the compass when it is performed via keyboard
	function compassKeyEvent(mode, event) {
		if (!AH.select(".drawingCompassSvg").classList.contains("h") && previewMode == "compass") {
			// contains width of the background image
			let imageWidth = AH.select("#svgImgPreview").clientWidth;

			// contains width of the background image 
			let imageHeight = AH.select("#svgImgPreview").clientHeight;

			// updates the value of compass radius and angle
			checkPreviewRadiusAndAngle();

			if (event.shiftKey && (event.keyCode == 38 || event.keyCode == 37 || event.keyCode == 39 || event.keyCode == 40)) {
				if (mode == "radius") {
					switch (event.keyCode) {
						case 38:
							// increases the radius value by 1 after down the key shift and up arrow
							$$invalidate(0, previewCompassRadius++, previewCompassRadius);
							break;
						case 37:
							// decreases the radius value by 1 after down the key shift and left arrow
							$$invalidate(0, previewCompassRadius--, previewCompassRadius);
							break;
						case 39:
							// increases the radius value by 1 after down the key shift and right arrow
							$$invalidate(0, previewCompassRadius++, previewCompassRadius);
							break;
						case 40:
							// decreases the radius value by 1 after down the key shift and down arrow
							$$invalidate(0, previewCompassRadius--, previewCompassRadius);
							break;
					}
				}

				if (mode == "move") {
					switch (event.keyCode) {
						case 38:
							// decreases the value of y co-ordinate of compass center by 1 after down the key shift and up arrow
							initialPoint.y--;
							break;
						case 37:
							// decreases the value of x co-ordinate of compass center by 1 after down the key shift and left arrow
							initialPoint.x--;
							break;
						case 39:
							// increases the value of x co-ordinate of compass center by 1 after down the key shift and right arrow
							initialPoint.x++;
							break;
						case 40:
							// increases the value of y co-ordinate of compass center by 1 after down the key shift and down arrow
							initialPoint.y++;
							break;
					}
				}

				if (mode == "rotate" || mode == "draw") {
					switch (event.keyCode) {
						case 38:
							// increases the value of compass angle by 1 after down the key shift and up arrow
							$$invalidate(1, previewCompassAngle++, previewCompassAngle);
							break;
						case 39:
							// decreases the value of compass angle by 1 after down the key shift and right arrow
							$$invalidate(1, previewCompassAngle--, previewCompassAngle);
							break;
						case 37:
							// increases the value of compass angle by 1 after down the key shift and left arrow
							$$invalidate(1, previewCompassAngle++, previewCompassAngle);
							break;
						case 40:
							// decreases the value of compass angle by 1 after down the key shift and down arrow
							$$invalidate(1, previewCompassAngle--, previewCompassAngle);
							break;
					}
				}

				if (mode == "draw") {
					if (AH.select("#previewSvg .lastCircle").classList.contains("lastCircle_hover") || AH.select("#previewSvg .lastbigcircle").classList.contains("lastCircle_hover")) {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy);

						// adds value of variables lastCircle_cx and lastCircle_cy separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
						previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + lastCircle_cx + " " + lastCircle_cy;

						// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
						AH.select(".previewDrawingPaths").prepend(scribble);
					}
				}

				if (initialPoint.x < 10 || previewCompassRadius < 80 || previewCompassRadius > 360 || initialPoint.x > imageWidth || initialPoint.y < 10 || initialPoint.y > imageHeight) {
					return;
				}

				// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
				updatePreviewCompassCalculation(initialPoint.x, initialPoint.y, previewCompassRadius, previewCompassAngle);
			}
		}
	}

	// stop the drawing and store the drawing sketched by the user and sets the user answer xml 
	function stopDraw() {
		if (checkCurrentPositionX == cursorLeft && checkCurrentPositionY == cursorTop && previewMode == "line" || previewMode == "scribble" && previewScribblePath[previewScribbleCount].d.indexOf("L") == -1) {
			// removes the last element from the array previewScribblePath
			previewScribblePath.pop();
		} else {
			if (!(isNaN(cursorLeft) && isNaN(cursorTop))) {
				// adds a new attribute 'd' (with a namespace null)
				scribble.setAttributeNS(null, "d", previewScribblePath[previewScribbleCount].d + " L" + cursorLeft + " " + cursorTop);

				// adds value of variables cursorLeft and cursorTop separated by space with prefix 'L' in the previous value of the key 'd' at index specified in the variable previewScribbleCount of array previewScribblePath
				previewScribblePath[previewScribbleCount].d = previewScribblePath[previewScribbleCount].d + " L" + cursorLeft + " " + cursorTop;

				// prepend the element stored into variable scribble in drawing container in which drawings are stored sketched by the help of drawing tools
				AH.select(".previewDrawingPaths").prepend(scribble);
			}

			// increases the value of the variable previewScribbleCount by 1
			previewScribbleCount++;

			// increases the value of the variable previewUndoCount by 1
			previewUndoCount++;

			// makes array previewUndoList blank
			previewUndoList = [];

			// enables undo and cross (x) buttons
			AH.select("#preview_undo").disabled = false;

			AH.select("#preview_clearScreen").disabled = false;

			// disabled redo button
			AH.select("#preview_redo").disabled = true;
		}

		// indicates that scribble drawing is not sketching
		isScribble = 0;

		// sets the value of variable startDrawingByKey to 0
		startDrawingByKey = 0;

		// sets the value of variable isDrawStop to 0
		isDrawStop = 0;

		// sets the value of variable lockFocus to 0
		lockFocus = 0;

		// contains copy of array previewScribblePath
		let tempArrayContainer = arrayCopy(previewScribblePath);

		// stores the drawing sketched by user and sets the user answer xml
		storeUserPaths(tempArrayContainer);
	}

	// function for opening the shortcut modal
	function openShortcut() {
		AH.getBS("#drawing_shortcut_modal", "Modal").show();
	}

	// function for checking the user ans and loading the module on the basis of it
	function checkUserAns() {
		if (typeof editorState == "undefined") {
			// removes the reset button
			AH.selectAll(".reset_group", "remove");

			if (uxml) {
				if (uxml.search("<smans type=\"41\">") == -1 || uxml.search("<smans type=\"41\"></smans>") == 0 || uxml.search("undefined") != -1) {
					// blanks the user answer xml
					AH.select("#special_module_user_xml", "value", "");
				} else {
					if (isReview) {
						AH.selectAll(".previewBtnGrp", "addClass", "h");

						// sets the value 'none' of the variable previewMode
						previewMode = "none";

						// not allowed user to perform the task
						AH.selectAll(".preview_drawing_container", "css", { pointerEvents: "none" });

						// removes the class previewKeySvg from the svg element have id previewSvg
						AH.select("#previewSvg", "removeClass", "previewKeySvg");
					} else {
						// allowed user to perform the task
						AH.selectAll(".preview_drawing_container", "css", { pointerEvents: "" });

						// shows all buttons
						AH.selectAll(".previewBtnGrp", "removeClass", "h");

						// adds the class previewKeySvg to the svg element have id previewSvg
						AH.select("#previewSvg", "addClass", "previewKeySvg");

						// contains the value of state array selectedTools at index 0 after removing the first character
						previewMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

						// it's also used below in this function so it can be removed
						AH.selectAll(".preview_btn,#mark_points", "removeClass", "active");

						// it's also used below in this function so it can be removed
						AH.select("#preview" + state.selectedTools[0], "addClass", "active");
					}

					loadModule(AH.select("#special_module_user_xml").value, isReview);
				}
			}
		}
	}

	const writable_props = ["xml", "uxml", "isReview", "showAns", "editorState"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<DrawingPreview> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(6, xml = $$props.xml);
		if ("uxml" in $$props) $$invalidate(7, uxml = $$props.uxml);
		if ("isReview" in $$props) $$invalidate(5, isReview = $$props.isReview);
		if ("showAns" in $$props) $$invalidate(8, showAns = $$props.showAns);
		if ("editorState" in $$props) $$invalidate(9, editorState = $$props.editorState);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		AH,
		onUserAnsChange,
		XMLToJSON,
		l: Lang,
		swal,
		writable,
		xml,
		uxml,
		isReview,
		showAns,
		editorState,
		bgImgPath,
		xmlns,
		isDrawingPreview,
		isDrawCompassPreview,
		isStoreStart,
		isDrawStop,
		startDrawingByKey,
		scribble,
		preview_mouseX,
		preview_mouseY,
		previewMode,
		previewColor,
		previewThickness,
		previewScribblePath,
		previewScribbleCount,
		checkCurrentPositionX,
		checkCurrentPositionY,
		previewUndoCount,
		previewUndoList,
		previewRedoList,
		accessibilityPointsPreview,
		focusPointCountPreview,
		lockFocus,
		isScribble,
		cx,
		cy,
		midCircle_cx,
		midCircle_cy,
		midSmallCircle_cx,
		midSmallCircle_cy,
		lastCircle_cx,
		lastCircle_cy,
		lastSmallCircle_cx,
		lastSmallCircle_cy,
		previewCompassRadius,
		isPreviewCompassMove,
		previewCompassAngle,
		isPreviewRadiusIncrease,
		initialPoint,
		finalPoint,
		compassAngleDisplacement,
		isPreviewRadiusRotate,
		cursorTop,
		cursorLeft,
		defaultXML,
		cdata,
		isAnswerCorrect,
		isMarking,
		markPoints,
		selectedToolsArray,
		userAnsPath,
		userAnsXML,
		userMarkingPoint,
		userDrawPath,
		userAnsCorrect,
		markPointsData,
		is_mac,
		prev_store,
		state,
		unsubscribe,
		compassLastcircleEvent,
		reinitializeFoucsEvent,
		markPointEvent,
		toolbarAction,
		previewMouseLeave,
		setReview,
		unsetReview,
		parseXMLForGettingData,
		markFinalPoints,
		addMarkPointOnLoad,
		loadModule,
		arrayCopy,
		eraser,
		storeUserPaths,
		createUXML,
		createUserPath,
		joinMarkedPoint,
		parseXMLForAnswer,
		storeCompassPathByKey,
		clearMarking,
		checkCorrectAnswer,
		setStatusOfAns,
		checkIntersection,
		checkPreviewRadiusAndAngle,
		updatePreviewCompassCalculation,
		setPreviewMouseCoordinates,
		setPreviewColor,
		compassKeyEvent,
		stopDraw,
		openShortcut,
		checkUserAns
	});

	$$self.$inject_state = $$props => {
		if ("xml" in $$props) $$invalidate(6, xml = $$props.xml);
		if ("uxml" in $$props) $$invalidate(7, uxml = $$props.uxml);
		if ("isReview" in $$props) $$invalidate(5, isReview = $$props.isReview);
		if ("showAns" in $$props) $$invalidate(8, showAns = $$props.showAns);
		if ("editorState" in $$props) $$invalidate(9, editorState = $$props.editorState);
		if ("bgImgPath" in $$props) $$invalidate(3, bgImgPath = $$props.bgImgPath);
		if ("xmlns" in $$props) xmlns = $$props.xmlns;
		if ("isDrawingPreview" in $$props) isDrawingPreview = $$props.isDrawingPreview;
		if ("isDrawCompassPreview" in $$props) isDrawCompassPreview = $$props.isDrawCompassPreview;
		if ("isStoreStart" in $$props) isStoreStart = $$props.isStoreStart;
		if ("isDrawStop" in $$props) isDrawStop = $$props.isDrawStop;
		if ("startDrawingByKey" in $$props) startDrawingByKey = $$props.startDrawingByKey;
		if ("scribble" in $$props) scribble = $$props.scribble;
		if ("preview_mouseX" in $$props) preview_mouseX = $$props.preview_mouseX;
		if ("preview_mouseY" in $$props) preview_mouseY = $$props.preview_mouseY;
		if ("previewMode" in $$props) previewMode = $$props.previewMode;
		if ("previewColor" in $$props) previewColor = $$props.previewColor;
		if ("previewThickness" in $$props) previewThickness = $$props.previewThickness;
		if ("previewScribblePath" in $$props) previewScribblePath = $$props.previewScribblePath;
		if ("previewScribbleCount" in $$props) previewScribbleCount = $$props.previewScribbleCount;
		if ("checkCurrentPositionX" in $$props) checkCurrentPositionX = $$props.checkCurrentPositionX;
		if ("checkCurrentPositionY" in $$props) checkCurrentPositionY = $$props.checkCurrentPositionY;
		if ("previewUndoCount" in $$props) previewUndoCount = $$props.previewUndoCount;
		if ("previewUndoList" in $$props) previewUndoList = $$props.previewUndoList;
		if ("previewRedoList" in $$props) previewRedoList = $$props.previewRedoList;
		if ("accessibilityPointsPreview" in $$props) accessibilityPointsPreview = $$props.accessibilityPointsPreview;
		if ("focusPointCountPreview" in $$props) focusPointCountPreview = $$props.focusPointCountPreview;
		if ("lockFocus" in $$props) lockFocus = $$props.lockFocus;
		if ("isScribble" in $$props) isScribble = $$props.isScribble;
		if ("cx" in $$props) cx = $$props.cx;
		if ("cy" in $$props) cy = $$props.cy;
		if ("midCircle_cx" in $$props) midCircle_cx = $$props.midCircle_cx;
		if ("midCircle_cy" in $$props) midCircle_cy = $$props.midCircle_cy;
		if ("midSmallCircle_cx" in $$props) midSmallCircle_cx = $$props.midSmallCircle_cx;
		if ("midSmallCircle_cy" in $$props) midSmallCircle_cy = $$props.midSmallCircle_cy;
		if ("lastCircle_cx" in $$props) lastCircle_cx = $$props.lastCircle_cx;
		if ("lastCircle_cy" in $$props) lastCircle_cy = $$props.lastCircle_cy;
		if ("lastSmallCircle_cx" in $$props) lastSmallCircle_cx = $$props.lastSmallCircle_cx;
		if ("lastSmallCircle_cy" in $$props) lastSmallCircle_cy = $$props.lastSmallCircle_cy;
		if ("previewCompassRadius" in $$props) $$invalidate(0, previewCompassRadius = $$props.previewCompassRadius);
		if ("isPreviewCompassMove" in $$props) isPreviewCompassMove = $$props.isPreviewCompassMove;
		if ("previewCompassAngle" in $$props) $$invalidate(1, previewCompassAngle = $$props.previewCompassAngle);
		if ("isPreviewRadiusIncrease" in $$props) isPreviewRadiusIncrease = $$props.isPreviewRadiusIncrease;
		if ("initialPoint" in $$props) initialPoint = $$props.initialPoint;
		if ("finalPoint" in $$props) finalPoint = $$props.finalPoint;
		if ("compassAngleDisplacement" in $$props) compassAngleDisplacement = $$props.compassAngleDisplacement;
		if ("isPreviewRadiusRotate" in $$props) isPreviewRadiusRotate = $$props.isPreviewRadiusRotate;
		if ("cursorTop" in $$props) cursorTop = $$props.cursorTop;
		if ("cursorLeft" in $$props) cursorLeft = $$props.cursorLeft;
		if ("defaultXML" in $$props) defaultXML = $$props.defaultXML;
		if ("cdata" in $$props) cdata = $$props.cdata;
		if ("isAnswerCorrect" in $$props) isAnswerCorrect = $$props.isAnswerCorrect;
		if ("isMarking" in $$props) isMarking = $$props.isMarking;
		if ("markPoints" in $$props) markPoints = $$props.markPoints;
		if ("selectedToolsArray" in $$props) selectedToolsArray = $$props.selectedToolsArray;
		if ("userAnsPath" in $$props) userAnsPath = $$props.userAnsPath;
		if ("userAnsXML" in $$props) userAnsXML = $$props.userAnsXML;
		if ("userMarkingPoint" in $$props) userMarkingPoint = $$props.userMarkingPoint;
		if ("userDrawPath" in $$props) userDrawPath = $$props.userDrawPath;
		if ("userAnsCorrect" in $$props) userAnsCorrect = $$props.userAnsCorrect;
		if ("markPointsData" in $$props) markPointsData = $$props.markPointsData;
		if ("is_mac" in $$props) is_mac = $$props.is_mac;
		if ("prev_store" in $$props) prev_store = $$props.prev_store;
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		previewCompassRadius,
		previewCompassAngle,
		state,
		bgImgPath,
		openShortcut,
		isReview,
		xml,
		uxml,
		showAns,
		editorState
	];
}

class DrawingPreview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-1tmjbvw-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				xml: 6,
				uxml: 7,
				isReview: 5,
				showAns: 8,
				editorState: 9
			},
			[-1, -1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DrawingPreview",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[6] === undefined && !("xml" in props)) {
			console_1.warn("<DrawingPreview> was created without expected prop 'xml'");
		}

		if (/*uxml*/ ctx[7] === undefined && !("uxml" in props)) {
			console_1.warn("<DrawingPreview> was created without expected prop 'uxml'");
		}

		if (/*isReview*/ ctx[5] === undefined && !("isReview" in props)) {
			console_1.warn("<DrawingPreview> was created without expected prop 'isReview'");
		}

		if (/*showAns*/ ctx[8] === undefined && !("showAns" in props)) {
			console_1.warn("<DrawingPreview> was created without expected prop 'showAns'");
		}

		if (/*editorState*/ ctx[9] === undefined && !("editorState" in props)) {
			console_1.warn("<DrawingPreview> was created without expected prop 'editorState'");
		}
	}

	get xml() {
		throw new Error("<DrawingPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<DrawingPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<DrawingPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<DrawingPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isReview() {
		throw new Error("<DrawingPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isReview(value) {
		throw new Error("<DrawingPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showAns() {
		throw new Error("<DrawingPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showAns(value) {
		throw new Error("<DrawingPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<DrawingPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<DrawingPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default DrawingPreview;
//# sourceMappingURL=DrawingPreview-48a7a4fe.js.map
