
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, M as append_styles, C as validate_each_argument, v as validate_slots, ad as afterUpdate, o as onMount, A as AH, X as XMLToJSON, w as writable, y as l, e as element, h as text, k as add_location, n as insert_dev, p as append_dev, B as noop, x as detach_dev, z as empty, K as destroy_each, f as space, j as attr_dev, a6 as null_to_empty, l as set_style, q as listen_dev, E as is_function, G as prop_dev, H as run_all, a3 as select_option } from './main-5daa0370.js';
import { l as lib } from './parseCSV-66f989c1.js';

/* clsSMChoiceMatrix\ChoiceMatrix.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file = "clsSMChoiceMatrix\\ChoiceMatrix.svelte";

function add_css(target) {
	append_styles(target, "svelte-dt0zmm", ".fa-check.svelte-dt0zmm{color:#46A546}.fa-close.svelte-dt0zmm{color:#A80000}.fa-close.svelte-dt0zmm,.fa-check.svelte-dt0zmm{margin-left:9px;font-size:18px}.fa-close.svelte-dt0zmm,.fa-check.svelte-dt0zmm,.middle_align.svelte-dt0zmm{vertical-align:middle!important}.middle_align.svelte-dt0zmm{width:164px;min-width:164px}.topic_input.svelte-dt0zmm{min-width:257px}.preview_header.svelte-dt0zmm{font-size:16pt;font-weight:bold;vertical-align:middle}.adjust_width.svelte-dt0zmm{width:12%;text-align:center}.width180.svelte-dt0zmm{width:180px}.width150.svelte-dt0zmm{width:150px}.full_day.svelte-dt0zmm{background-color:#eee !important;color:#000 !important}.width90.svelte-dt0zmm{width:90px}.width20.svelte-dt0zmm{width:20px}.relative.svelte-dt0zmm{position:relative}.min_height_38.svelte-dt0zmm{min-height:38px}.min_width_200.svelte-dt0zmm{min-width:200px !important}.min_width_125.svelte-dt0zmm{min-width:125px}.max_width_150.svelte-dt0zmm{max-width:150px !important}.height34.svelte-dt0zmm{height:34px !important}.width_90.svelte-dt0zmm{width:90%}.font24.svelte-dt0zmm{font-size:15px !important}.iconPos.svelte-dt0zmm{position:relative;top:5px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hvaWNlTWF0cml4LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtZkEsU0FBUyxjQUFDLENBQUMsQUFDVixLQUFLLENBQUUsT0FBTyxBQUNmLENBQUMsQUFFRCxTQUFTLGNBQUMsQ0FBQyxBQUNWLEtBQUssQ0FBRSxPQUFPLEFBQ2YsQ0FBQyxBQUVELHVCQUFTLENBQ1QsU0FBUyxjQUFDLENBQUMsQUFDVixXQUFXLENBQUUsR0FBRyxDQUNoQixTQUFTLENBQUUsSUFBSSxBQUNoQixDQUFDLEFBRUQsdUJBQVMsQ0FDVCx1QkFBUyxDQUNULGFBQWEsY0FBQyxDQUFDLEFBQ2QsY0FBYyxDQUFFLE1BQU0sVUFBVSxBQUNqQyxDQUFDLEFBRUQsYUFBYSxjQUFDLENBQUMsQUFDZCxLQUFLLENBQUUsS0FBSyxDQUNaLFNBQVMsQ0FBRSxLQUFLLEFBQ2pCLENBQUMsQUFFRCxZQUFZLGNBQUMsQ0FBQyxBQUNiLFNBQVMsQ0FBRSxLQUFLLEFBQ2pCLENBQUMsQUFFRCxlQUFlLGNBQUMsQ0FBQyxBQUNoQixTQUFTLENBQUUsSUFBSSxDQUNmLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLGNBQWMsQ0FBRSxNQUFNLEFBQ3ZCLENBQUMsQUFFRCxhQUFhLGNBQUMsQ0FBQyxBQUNYLEtBQUssQ0FBRSxHQUFHLENBQ1YsVUFBVSxDQUFFLE1BQU0sQUFDdEIsQ0FBQyxBQUVELFNBQVMsY0FBQyxDQUFDLEFBQ1YsS0FBSyxDQUFFLEtBQUssQUFDYixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsQUFDVixLQUFLLENBQUUsS0FBSyxBQUNiLENBQUMsQUFFRCxTQUFTLGNBQUMsQ0FBQyxBQUNWLGdCQUFnQixDQUFFLElBQUksQ0FBQyxVQUFVLENBQ2pDLEtBQUssQ0FBRSxJQUFJLENBQUMsVUFBVSxBQUN2QixDQUFDLEFBR0QsUUFBUSxjQUFFLENBQUMsQUFDVixLQUFLLENBQUUsSUFBSSxBQUNaLENBQUMsQUFFRCxRQUFRLGNBQUMsQ0FBQyxBQUNULEtBQUssQ0FBRSxJQUFJLEFBQ1osQ0FBQyxBQUVELFNBQVMsY0FBQyxDQUFDLEFBQ1YsUUFBUSxDQUFFLFFBQVEsQUFDbkIsQ0FBQyxBQUVELGNBQWMsY0FBQyxDQUFDLEFBQ2YsVUFBVSxDQUFFLElBQUksQUFDakIsQ0FBQyxBQUVELGNBQWMsY0FBRSxDQUFDLEFBQ2hCLFNBQVMsQ0FBRSxLQUFLLENBQUMsVUFBVSxBQUM1QixDQUFDLEFBRUQsY0FBYyxjQUFFLENBQUMsQUFDaEIsU0FBUyxDQUFFLEtBQUssQUFDakIsQ0FBQyxBQUVELGNBQWMsY0FBQyxDQUFDLEFBQ2YsU0FBUyxDQUFFLEtBQUssQ0FBQyxVQUFVLEFBQzVCLENBQUMsQUFFRCxTQUFTLGNBQUUsQ0FBQyxBQUNYLE1BQU0sQ0FBRSxJQUFJLENBQUMsVUFBVSxBQUN4QixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsQUFDVixLQUFLLENBQUUsR0FBRyxBQUNYLENBQUMsQUFFRCxPQUFPLGNBQUMsQ0FBQyxBQUNQLFNBQVMsQ0FBRSxJQUFJLENBQUMsVUFBVSxBQUV4QixDQUFDLEFBQ0wsUUFBUSxjQUFDLENBQUMsQUFDVCxTQUFTLFFBQVEsQ0FDakIsSUFBSSxHQUFHLEFBQ1IsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDaG9pY2VNYXRyaXguc3ZlbHRlIl19 */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i];
	child_ctx[27] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i];
	child_ctx[27] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i];
	child_ctx[27] = i;
	return child_ctx;
}

// (363:7) {#each themeOption as theme, i}
function create_each_block_3(ctx) {
	let option;
	let t_value = l[/*theme*/ ctx[32]] + "";
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = "theme" + ++/*i*/ ctx[27];
			option.value = option.__value;
			add_location(option, file, 363, 8, 10620);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(363:7) {#each themeOption as theme, i}",
		ctx
	});

	return block;
}

// (400:32) {#if state.cdata}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value_2 = /*state*/ ctx[0].cdata.option;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, theme_color, removeOption, icon_class, updateOptionValue*/ 2195) {
				each_value_2 = /*state*/ ctx[0].cdata.option;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(400:32) {#if state.cdata}",
		ctx
	});

	return block;
}

// (401:36) {#each state.cdata.option as data,i}
function create_each_block_2(ctx) {
	let th;
	let div0;
	let textarea;
	let textarea_id_value;
	let textarea_value_value;
	let t0;
	let div1;
	let span;
	let span_class_value;
	let t1;
	let th_key_value;
	let th_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			th = element("th");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			div1 = element("div");
			span = element("span");
			t1 = space();
			attr_dev(textarea, "id", textarea_id_value = /*data*/ ctx[25].id);
			textarea.value = textarea_value_value = /*data*/ ctx[25].text;
			attr_dev(textarea, "class", "form-control form-control-md px-2 min_height_38 text-dark svelte-dt0zmm");
			attr_dev(textarea, "cols", "10");
			attr_dev(textarea, "rows", "1");
			add_location(textarea, file, 407, 48, 12894);
			attr_dev(div0, "class", "float-left");
			add_location(div0, file, 406, 44, 12818);
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*icon_class*/ ctx[4]) + " svelte-dt0zmm"));
			add_location(span, file, 421, 48, 13888);
			attr_dev(div1, "class", "float-left pointer pt-1 ml-2 delete_column height35 top1 position-relative");
			attr_dev(div1, "tab-index", "0");
			add_location(div1, file, 416, 44, 13529);
			attr_dev(th, "key", th_key_value = /*i*/ ctx[27]);
			attr_dev(th, "class", th_class_value = "" + (null_to_empty("middle_align text-center " + /*data*/ ctx[25].id) + " svelte-dt0zmm"));
			set_style(th, "background-color", /*theme_color*/ ctx[1][/*state*/ ctx[0].theme], 1);
			add_location(th, file, 401, 40, 12500);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, div0);
			append_dev(div0, textarea);
			append_dev(th, t0);
			append_dev(th, div1);
			append_dev(div1, span);
			append_dev(th, t1);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", /*updateOptionValue*/ ctx[7], false, false, false),
					listen_dev(
						div1,
						"click",
						function () {
							if (is_function(/*removeOption*/ ctx[11].bind(this, /*data*/ ctx[25].id))) /*removeOption*/ ctx[11].bind(this, /*data*/ ctx[25].id).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 1 && textarea_id_value !== (textarea_id_value = /*data*/ ctx[25].id)) {
				attr_dev(textarea, "id", textarea_id_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[25].text)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1 && th_class_value !== (th_class_value = "" + (null_to_empty("middle_align text-center " + /*data*/ ctx[25].id) + " svelte-dt0zmm"))) {
				attr_dev(th, "class", th_class_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(th, "background-color", /*theme_color*/ ctx[1][/*state*/ ctx[0].theme], 1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(401:36) {#each state.cdata.option as data,i}",
		ctx
	});

	return block;
}

// (430:28) {#if state.cdata}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*state*/ ctx[0].cdata.term;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, theme_color_terms, setCorrectAns, removeTerm, icon_class, updateTermValue*/ 5205) {
				each_value = /*state*/ ctx[0].cdata.term;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(430:28) {#if state.cdata}",
		ctx
	});

	return block;
}

// (449:40) {#each state.cdata.option as data2,j}
function create_each_block_1(ctx) {
	let td;
	let label;
	let input;
	let input_value_value;
	let input_name_value;
	let input_id_value;
	let input_data_correct_value;
	let label_for_value;
	let td_key_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			label = element("label");
			input = element("input");
			attr_dev(input, "type", "radio");
			attr_dev(input, "class", "preview_radio align-middle");
			input.value = input_value_value = /*data2*/ ctx[28].id;
			attr_dev(input, "name", input_name_value = /*i*/ ctx[27] + 1);
			attr_dev(input, "id", input_id_value = 'a' + /*i*/ ctx[27] + /*j*/ ctx[30]);
			attr_dev(input, "data-correct", input_data_correct_value = /*data*/ ctx[25].correct);
			add_location(input, file, 452, 56, 16121);
			attr_dev(label, "class", "label_choice pointer d-block w-100 mb-0");
			attr_dev(label, "for", label_for_value = 'a' + /*i*/ ctx[27] + /*j*/ ctx[30]);
			add_location(label, file, 451, 52, 15988);
			attr_dev(td, "class", "text-center align-middle h-auto min_width_125 max_width_150 svelte-dt0zmm");
			attr_dev(td, "key", td_key_value = /*j*/ ctx[30]);

			set_style(
				td,
				"background-color",
				/*i*/ ctx[27] % 2 == 0
				? /*theme_color_terms*/ ctx[2][/*state*/ ctx[0].theme]
				: "#FFF",
				1
			);

			add_location(td, file, 449, 12, 15741);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, label);
			append_dev(label, input);

			if (!mounted) {
				dispose = listen_dev(input, "click", /*setCorrectAns*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = /*data2*/ ctx[28].id)) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*state*/ 1 && input_data_correct_value !== (input_data_correct_value = /*data*/ ctx[25].correct)) {
				attr_dev(input, "data-correct", input_data_correct_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(
					td,
					"background-color",
					/*i*/ ctx[27] % 2 == 0
					? /*theme_color_terms*/ ctx[2][/*state*/ ctx[0].theme]
					: "#FFF",
					1
				);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(449:40) {#each state.cdata.option as data2,j}",
		ctx
	});

	return block;
}

// (431:32) {#each state.cdata.term as data,i}
function create_each_block(ctx) {
	let tr;
	let td;
	let textarea;
	let textarea_id_value;
	let textarea_value_value;
	let t0;
	let div;
	let span;
	let span_class_value;
	let td_class_value;
	let t1;
	let t2;
	let tr_key_value;
	let mounted;
	let dispose;
	let each_value_1 = /*state*/ ctx[0].cdata.option;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");
			td = element("td");
			textarea = element("textarea");
			t0 = space();
			div = element("div");
			span = element("span");
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			attr_dev(textarea, "id", textarea_id_value = /*data*/ ctx[25].id);
			textarea.value = textarea_value_value = /*data*/ ctx[25].text;
			attr_dev(textarea, "class", "form-control form-control-md width_90 float-left min_height_38 mr-2 svelte-dt0zmm");
			set_style(textarea, "outline", "none");
			set_style(textarea, "height", "38px");
			add_location(textarea, file, 433, 44, 14607);
			attr_dev(span, "class", span_class_value = "" + (/*icon_class*/ ctx[4] + "+ iconPos" + " svelte-dt0zmm"));
			add_location(span, file, 445, 48, 15504);
			attr_dev(div, "class", "pointer pt-1 mt-sm2 ml-2 delete_row height34 svelte-dt0zmm");
			attr_dev(div, "tab-index", "0");
			add_location(div, file, 440, 44, 15140);
			attr_dev(td, "class", td_class_value = "" + (null_to_empty("min_width_200 h-auto " + /*data*/ ctx[25].id) + " svelte-dt0zmm"));

			set_style(
				td,
				"background-color",
				/*i*/ ctx[27] % 2 == 0
				? /*theme_color_terms*/ ctx[2][/*state*/ ctx[0].theme]
				: "#FFF",
				1
			);

			add_location(td, file, 432, 40, 14414);
			attr_dev(tr, "key", tr_key_value = /*i*/ ctx[27]);
			add_location(tr, file, 431, 36, 14360);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td);
			append_dev(td, textarea);
			append_dev(td, t0);
			append_dev(td, div);
			append_dev(div, span);
			append_dev(tr, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t2);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*updateTermValue*/ ctx[6], false, false, false),
					listen_dev(
						div,
						"click",
						function () {
							if (is_function(/*removeTerm*/ ctx[10].bind(this, /*data*/ ctx[25].id))) /*removeTerm*/ ctx[10].bind(this, /*data*/ ctx[25].id).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 1 && textarea_id_value !== (textarea_id_value = /*data*/ ctx[25].id)) {
				attr_dev(textarea, "id", textarea_id_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*data*/ ctx[25].text)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1 && td_class_value !== (td_class_value = "" + (null_to_empty("min_width_200 h-auto " + /*data*/ ctx[25].id) + " svelte-dt0zmm"))) {
				attr_dev(td, "class", td_class_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(
					td,
					"background-color",
					/*i*/ ctx[27] % 2 == 0
					? /*theme_color_terms*/ ctx[2][/*state*/ ctx[0].theme]
					: "#FFF",
					1
				);
			}

			if (dirty[0] & /*theme_color_terms, state, setCorrectAns*/ 4101) {
				each_value_1 = /*state*/ ctx[0].cdata.option;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(431:32) {#each state.cdata.term as data,i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div6;
	let div5;
	let div4;
	let div1;
	let div0;
	let label0;
	let t1;
	let select;
	let select_value_value;
	let t2;
	let label1;
	let t4;
	let input;
	let input_value_value;
	let t5;
	let span0;
	let t7;
	let div2;
	let table;
	let thead;
	let tr;
	let th;
	let textarea;
	let textarea_value_value;
	let textarea_style_value;
	let t8;
	let t9;
	let tbody;
	let t10;
	let small;
	let strong;
	let t13;
	let t14_value = l.comment_choiceMatrix + "";
	let t14;
	let t15;
	let div3;
	let button0;
	let span1;
	let t17;
	let t18_value = l.add_row + "";
	let t18;
	let button0_style_value;
	let t19;
	let button1;
	let span2;
	let t21;
	let t22_value = l.add_column + "";
	let t22;
	let button1_style_value;
	let div3_style_value;
	let mounted;
	let dispose;
	let each_value_3 = /*themeOption*/ ctx[3];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let if_block0 = /*state*/ ctx[0].cdata && create_if_block_1(ctx);
	let if_block1 = /*state*/ ctx[0].cdata && create_if_block(ctx);

	const block = {
		c: function create() {
			main = element("main");
			div6 = element("div");
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			label0 = element("label");
			label0.textContent = `${l.themes}`;
			t1 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			label1 = element("label");
			label1.textContent = `${l.table_width}`;
			t4 = space();
			input = element("input");
			t5 = space();
			span0 = element("span");
			span0.textContent = "px";
			t7 = space();
			div2 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th = element("th");
			textarea = element("textarea");
			t8 = space();
			if (if_block0) if_block0.c();
			t9 = space();
			tbody = element("tbody");
			if (if_block1) if_block1.c();
			t10 = space();
			small = element("small");
			strong = element("strong");
			strong.textContent = `* ${l.note_label}`;
			t13 = space();
			t14 = text(t14_value);
			t15 = space();
			div3 = element("div");
			button0 = element("button");
			span1 = element("span");
			span1.textContent = "+";
			t17 = space();
			t18 = text(t18_value);
			t19 = space();
			button1 = element("button");
			span2 = element("span");
			span2.textContent = "+";
			t21 = space();
			t22 = text(t22_value);
			attr_dev(label0, "for", "select_themes");
			attr_dev(label0, "class", "mb-0 pl-1 mt-2 mr-2 float-left");
			add_location(label0, file, 350, 6, 10111);
			attr_dev(select, "class", "form-select form-control-md px-2 enroll_date_td width150 float-left svelte-dt0zmm");
			attr_dev(select, "id", "select_themes");
			attr_dev(select, "name", "select_themes");
			add_location(select, file, 356, 24, 10268);
			attr_dev(label1, "for", "customWidth");
			attr_dev(label1, "class", "mb-0 mt-2 mr-2 ml-2 float-left");
			add_location(label1, file, 366, 6, 10728);
			attr_dev(input, "class", "form-control form-control-md px-2 width90 float-left svelte-dt0zmm");
			attr_dev(input, "step", "10");
			attr_dev(input, "min", "500");
			attr_dev(input, "max", "1000");
			attr_dev(input, "type", "number");
			input.value = input_value_value = parseInt(/*state*/ ctx[0].maxWidth);
			attr_dev(input, "id", "customWidth");
			add_location(input, file, 367, 24, 10845);
			attr_dev(span0, "class", "d-inline-block mt-2 ml-1 width20 float-left svelte-dt0zmm");
			add_location(span0, file, 378, 24, 11216);
			attr_dev(div0, "class", "float-left mb-1 pr-2 ");
			add_location(div0, file, 349, 20, 10066);
			attr_dev(div1, "class", "form-group row full_day mx-0 pt-2 pb-1 w-100 svelte-dt0zmm");
			add_location(div1, file, 347, 16, 9892);
			textarea.value = textarea_value_value = /*state*/ ctx[0].stem;
			attr_dev(textarea, "class", "form-control form-control-md px-2 min_height_38 text-dark svelte-dt0zmm");
			attr_dev(textarea, "style", textarea_style_value = 'outline:none;');
			attr_dev(textarea, "cols", "15");
			attr_dev(textarea, "rows", "1");
			add_location(textarea, file, 390, 36, 11838);
			attr_dev(th, "class", "topic_input text-center svelte-dt0zmm");
			attr_dev(th, "id", "hello");
			set_style(th, "background-color", /*theme_color*/ ctx[1][/*state*/ ctx[0].theme], 1);
			add_location(th, file, 385, 32, 11640);
			attr_dev(tr, "class", "table-head");
			add_location(tr, file, 384, 28, 11581);
			add_location(thead, file, 383, 24, 11544);
			add_location(tbody, file, 428, 24, 14200);
			attr_dev(table, "class", "table table-bordered relative w-100 ml-0 mt-0 svelte-dt0zmm");
			attr_dev(table, "id", "my_table");
			add_location(table, file, 382, 20, 11439);
			attr_dev(div2, "class", "table-responsive mt-4 d-flex align-items-center");
			add_location(div2, file, 381, 16, 11354);
			add_location(strong, file, 470, 52, 17207);
			attr_dev(small, "class", "text-danger font13");
			add_location(small, file, 470, 16, 17171);
			attr_dev(span1, "class", "font24 svelte-dt0zmm");
			add_location(span1, file, 479, 26, 17657);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-outline-primary btn-sm add_stem pr-md ml-2 px-2");
			attr_dev(button0, "id", "btn");
			attr_dev(button0, "style", button0_style_value = 'width: 122px;');
			add_location(button0, file, 473, 24, 17375);
			attr_dev(span2, "class", "font24 svelte-dt0zmm");
			add_location(span2, file, 489, 7, 17962);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-outline-primary btn-sm add_option pr-md ml-2 px-2");
			attr_dev(button1, "id", "btn_opt");
			attr_dev(button1, "style", button1_style_value = 'width: 122px;');
			add_location(button1, file, 483, 6, 17758);
			attr_dev(div3, "class", "text-center");
			attr_dev(div3, "style", div3_style_value = 'width:100%;');
			add_location(div3, file, 471, 16, 17291);
			attr_dev(div4, "class", "col-12 col-lg-12 p-0");
			add_location(div4, file, 346, 12, 9838);
			attr_dev(div5, "id", "authoring");
			attr_dev(div5, "class", "p-2 border");
			add_location(div5, file, 345, 8, 9781);
			add_location(div6, file, 344, 4, 9766);
			add_location(main, file, 343, 0, 9754);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div6);
			append_dev(div6, div5);
			append_dev(div5, div4);
			append_dev(div4, div1);
			append_dev(div1, div0);
			append_dev(div0, label0);
			append_dev(div0, t1);
			append_dev(div0, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*state*/ ctx[0].theme);
			append_dev(div0, t2);
			append_dev(div0, label1);
			append_dev(div0, t4);
			append_dev(div0, input);
			append_dev(div0, t5);
			append_dev(div0, span0);
			append_dev(div4, t7);
			append_dev(div4, div2);
			append_dev(div2, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th);
			append_dev(th, textarea);
			append_dev(tr, t8);
			if (if_block0) if_block0.m(tr, null);
			append_dev(table, t9);
			append_dev(table, tbody);
			if (if_block1) if_block1.m(tbody, null);
			append_dev(div4, t10);
			append_dev(div4, small);
			append_dev(small, strong);
			append_dev(small, t13);
			append_dev(small, t14);
			append_dev(div4, t15);
			append_dev(div4, div3);
			append_dev(div3, button0);
			append_dev(button0, span1);
			append_dev(button0, t17);
			append_dev(button0, t18);
			append_dev(div3, t19);
			append_dev(div3, button1);
			append_dev(button1, span2);
			append_dev(button1, t21);
			append_dev(button1, t22);

			if (!mounted) {
				dispose = [
					listen_dev(select, "click", /*changeTheme*/ ctx[13], false, false, false),
					listen_dev(input, "keyup", /*handleMaxwidth*/ ctx[14].bind(this), false, false, false),
					listen_dev(input, "change", /*handleMaxwidth*/ ctx[14].bind(this), false, false, false),
					listen_dev(textarea, "change", /*updateStem*/ ctx[5], false, false, false),
					listen_dev(button0, "click", /*addStem*/ ctx[8], false, false, false),
					listen_dev(button1, "click", /*addOption*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*themeOption*/ 8) {
				each_value_3 = /*themeOption*/ ctx[3];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			if (dirty[0] & /*state*/ 1 && select_value_value !== (select_value_value = /*state*/ ctx[0].theme)) {
				select_option(select, /*state*/ ctx[0].theme);
			}

			if (dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = parseInt(/*state*/ ctx[0].maxWidth))) {
				prop_dev(input, "value", input_value_value);
			}

			if (dirty[0] & /*state*/ 1 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[0].stem)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 1) {
				set_style(th, "background-color", /*theme_color*/ ctx[1][/*state*/ ctx[0].theme], 1);
			}

			if (/*state*/ ctx[0].cdata) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(tr, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*state*/ ctx[0].cdata) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(tbody, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function reverseCSVFormat(data) {
	// value of stem
	let csvFormat = data.stem + ",";

	// getting values of option and appending it to the csvFormat
	data.option.map(val1 => {
		csvFormat += val1.text + ",";
	});

	csvFormat += "\n";

	data.term.map((val2, j) => {
		// adding the text of term
		csvFormat += val2.text + ",";

		// adding 1,0 n the basis of radio is checked or not
		data.option.map(val1 => {
			csvFormat += val2.correct == val1.id ? "1," : "0,";
		});

		csvFormat += "\n";
	});

	// returning all the appended data
	return csvFormat;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChoiceMatrix', slots, []);
	let { getChildXml } = $$props;
	let { xml } = $$props;

	let theme_color = {
		theme1: '#5B9BD5',
		theme2: '#3B67BC',
		theme3: '#F6C3A2',
		theme4: '#70AD47',
		theme5: '#745998'
	};

	let theme_color_terms = {
		theme1: '#DEEAF6',
		theme2: '#D4DEF1',
		theme3: '#FAE0CF',
		theme4: '#E2EFD9',
		theme5: '#E1DAE9'
	};

	// variable declaration
	let themeOption = ['light_blue', 'dark_blue', 'peach', 'green', 'purple'];

	let widthVal = "";
	let icon_class = "icomoon-new-24px-delete-1 s3";
	let lastAction;
	let state = {};

	let stateData = writable({
		cdata: "",
		stem: "",
		xml: "",
		theme: "",
		font: "",
		maxWidth: ""
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	////////////    Exectuing each time the xml will change //////////////
	afterUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			loadModule(xml);
		}
	});

	onMount(() => {
		AH.listen(document, 'keydown', 'textarea', function (event) {
			if (event.keyCode == 13) {
				event.preventDefault();
			}
		});

		document.querySelector('.add_stem, .add_stem').addEventListener("click", function (event) {
			event.preventDefault();
		});

		// try catch block in error handling
		try {
			// check if xml is not blank
			if (xml) {
				// load the module on the basis of xml 
				loadModule(xml);

				// update the cdata accordingly
				reverseXml();
			}
		} catch(e) {
			console.log({
				Error: e.message,
				File: "choiceMatrix",
				Line: "65"
			});
		}

		AH.listen(document, 'keydown', '.delete_column', function (_this, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// click the element which currently get the focus and enter key is down
				AH.trigger(_this, 'click');

				//_this.dispatchEvent(new Event("click"));
				event.preventDefault();
			}
		});

		AH.listen(document, 'keydown', '.delete_row', function (_this, event) {
			if (event.keyCode == 13 || event.which == 13) {
				// click the element which currently get the focus and enter key is down
				_this.dispatchEvent(new Event("click"));

				event.preventDefault();
			}
		});
	});

	// it load the module 
	function loadModule(loadXml) {
		// convert the xml into json and pass it in the parseXMLAuthoring function to parse the xml
		loadXml = XMLToJSON(loadXml);

		parseXMLAuthoring(loadXml);
	}

	// it is used for parsing the xml for authoring area
	function parseXMLAuthoring(MYXML) {
		let formattedData = lib.parseCSVFormat(MYXML.smxml.__cdata);
		let cdata = formattedData;
		let rawData = [];

		// copying the JSON data in the rawData and make it array 
		rawData = JSON.parse(JSON.stringify(cdata));

		$$invalidate(0, state.cdata = rawData, state);
		$$invalidate(0, state.stem = rawData.stem, state);
		$$invalidate(0, state.theme = MYXML.smxml._theme, state);
		$$invalidate(0, state.font = MYXML.smxml._font, state);

		$$invalidate(
			0,
			state.maxWidth = MYXML.smxml._maxwidth
			? parseInt(MYXML.smxml._maxwidth)
			: 800,
			state
		);

		let timer = setTimeout(
			function () {
				let radio_len1 = document.getElementsByClassName('preview_radio');

				for (let i = 0; i < radio_len1.length; i++) {
					radio_len1[i].checked = radio_len1[i].getAttribute('value') == radio_len1[i].getAttribute('data-correct')
					? true
					: false;
				}

				clearTimeout(timer);
			},
			200
		);
	}

	// calls on change in the stem textarea
	function updateStem(e) {
		$$invalidate(0, state.stem = e.target.value, state);
		$$invalidate(0, state.cdata.stem = e.target.value, state);

		// updaing the cdata
		reverseXml();
	}

	//////////// Update the cdata ///////////////////
	function reverseXml() {
		let csvReverse = reverseCSVFormat(state.cdata);
		csvReverse = csvReverse.replace(/\’|\′/g, "'").replace(/\″|\“|\”/g, "\"");
		let updatedXml = `<smxml type="27" name="ChoiceMatrix" theme="${state.theme}" font="${state.font}" maxwidth="${state.maxWidth}"><!--[CDATA[${csvReverse}]]--></smxml>`;
		getChildXml(updatedXml);
	}

	function updateTermValue(e) {
		//it update the text of that particular term by finding the id of the changed term textarea
		state.cdata && state.cdata.term.map(function (data, i) {
			if (data.id == e.target.id) {
				data.text = e.target.value;
			}
		});

		// update the cdata
		reverseXml();
	}

	////////////// updating the option ///////////////
	function updateOptionValue(e) {
		//it update the text of that particular option by finding the id of the changed option textarea
		state.cdata && state.cdata.option.map(function (data, i) {
			if (data.id == e.target.id) {
				data.text = e.target.value;
			}
		});

		// update the cdata
		reverseXml();
	}

	///////////  Added row rows  /////////////////
	function addStem() {
		let id = state.cdata.term.length + 1;

		if (id <= 6) {
			state.cdata.term.push({
				id: "t" + id,
				correct: "",
				text: "Term Sample text"
			});

			reverseXml();
		} else {
			AH.alert('Maximum possible value of rows are 6.');
		}
	}

	/////////  This function is added the column  ///////////////
	function addOption() {
		let id = state.cdata.option.length + 1;

		if (id <= 4) {
			state.cdata.option.push({ id: "o" + id, text: "Option" });
			reverseXml();
		} else {
			AH.alert('Maximum possible value of columns are 4.');
		}
	}

	//////////// This function delete the rows /////////////
	function removeTerm(id) {
		if (state.cdata.term.length > 2) {
			let newTerm = [];
			let count = 1;

			state.cdata.term.map(function (data, i) {
				if (data.id == id) {
					state.cdata.term.splice(i, 1);
				}
			});

			state.cdata.term.map(function (data, i) {
				newTerm.push({
					id: "t" + count,
					correct: data.correct,
					text: data.text
				});

				count++;
			});

			$$invalidate(0, state.cdata.term = newTerm, state);
			let radio_len = document.getElementsByClassName('preview_radio');

			for (let i = 0; i < radio_len; i++) {
				radio_len[i].checked = false;
			}

			//updating the cdata
			reverseXml();
		} else {
			AH.alert("You must have at least two rows.");
		}
	}

	// when delete btn of option is cliked
	function removeOption(id) {
		// checking min no of option 
		if (state.cdata.option.length > 2) {
			let newOption = [];
			let count = 1;

			// removing that particular option
			state.cdata.option.map(function (data, i) {
				if (data.id == id) {
					state.cdata.option.splice(i, 1);
				}
			});

			state.cdata.option.map(function (data, i) {
				newOption.push({ id: "o" + count, text: data.text });
				count++;
			});

			// remove the correct answer
			removeCorrectAns();

			$$invalidate(0, state.cdata.option = newOption, state);

			// updates the xml
			reverseXml();
		} else {
			AH.alert("You must have at least two columns.");
		}
	}

	// for removing the correct ans
	function removeCorrectAns() {
		state.cdata && state.cdata.term.map(function (data, i) {
			data.correct = "";
		});
	}

	// for setting the correct answer
	function setCorrectAns(e) {
		// getting name of the clicked radio btn to find the index
		let rname = e.target.name;

		let rindex = rname - 1;

		// store the value of target in correct key of the term at that index 
		$$invalidate(0, state.cdata.term[rindex].correct = e.target.value, state);

		reverseXml();
	}

	////// This function is fired then change theme ////////////
	function changeTheme(e) {
		// update the state
		$$invalidate(0, state.theme = e.target.value, state);

		// update the cdata
		reverseXml(); // Remove setTimeout in this place
	}

	// when there is change in table
	function handleMaxwidth() {
		// getting the value of width
		widthVal = document.querySelector('#customWidth').value;

		// setting the width of the table
		document.getElementById('test_table').style.width = widthVal + 'px';

		// check for th timeout if exist clear the timeout to save memory
		lastAction ? clearTimeout(lastAction) : "";

		lastAction = setTimeout(
			function () {
				// checking condition that the table width must between the 500 and 1000
				if (widthVal < 500) {
					//// jQuery('#customWidth').val() remove this
					$$invalidate(0, state.maxWidth = 500, state);

					let timer = setTimeout(
						function () {
							reverseXml();
							clearTimeout(timer);
						},
						100
					); //  Fixed

					AH.alert("Width should not be less than 500px");
				}

				if (widthVal > 1000) {
					//// jQuery('#customWidth').val() remove this
					$$invalidate(0, state.maxWidth = 1000, state);

					let timer = setTimeout(
						function () {
							reverseXml();
							clearTimeout(timer);
						},
						100
					); // Fixed

					AH.alert("Width should not be greater than 1000px");
				}
			},
			1000
		);

		// update the state
		$$invalidate(0, state.maxWidth = widthVal, state);

		// update the cdata
		reverseXml();
	}

	const writable_props = ['getChildXml', 'xml'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<ChoiceMatrix> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('getChildXml' in $$props) $$invalidate(15, getChildXml = $$props.getChildXml);
		if ('xml' in $$props) $$invalidate(16, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		writable,
		l,
		lib1: lib,
		XMLToJSON,
		AH,
		getChildXml,
		xml,
		theme_color,
		theme_color_terms,
		themeOption,
		widthVal,
		icon_class,
		lastAction,
		state,
		stateData,
		unsubscribe,
		loadModule,
		parseXMLAuthoring,
		updateStem,
		reverseXml,
		reverseCSVFormat,
		updateTermValue,
		updateOptionValue,
		addStem,
		addOption,
		removeTerm,
		removeOption,
		removeCorrectAns,
		setCorrectAns,
		changeTheme,
		handleMaxwidth
	});

	$$self.$inject_state = $$props => {
		if ('getChildXml' in $$props) $$invalidate(15, getChildXml = $$props.getChildXml);
		if ('xml' in $$props) $$invalidate(16, xml = $$props.xml);
		if ('theme_color' in $$props) $$invalidate(1, theme_color = $$props.theme_color);
		if ('theme_color_terms' in $$props) $$invalidate(2, theme_color_terms = $$props.theme_color_terms);
		if ('themeOption' in $$props) $$invalidate(3, themeOption = $$props.themeOption);
		if ('widthVal' in $$props) widthVal = $$props.widthVal;
		if ('icon_class' in $$props) $$invalidate(4, icon_class = $$props.icon_class);
		if ('lastAction' in $$props) lastAction = $$props.lastAction;
		if ('state' in $$props) $$invalidate(0, state = $$props.state);
		if ('stateData' in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		theme_color,
		theme_color_terms,
		themeOption,
		icon_class,
		updateStem,
		updateTermValue,
		updateOptionValue,
		addStem,
		addOption,
		removeTerm,
		removeOption,
		setCorrectAns,
		changeTheme,
		handleMaxwidth,
		getChildXml,
		xml
	];
}

class ChoiceMatrix extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { getChildXml: 15, xml: 16 }, add_css, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChoiceMatrix",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[15] === undefined && !('getChildXml' in props)) {
			console_1.warn("<ChoiceMatrix> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[16] === undefined && !('xml' in props)) {
			console_1.warn("<ChoiceMatrix> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<ChoiceMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ChoiceMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<ChoiceMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ChoiceMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ChoiceMatrix;
//# sourceMappingURL=ChoiceMatrix-514fa205.js.map
