
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, V as Checkbox, C as validate_each_argument, U as Button, O as Dialog, P as binding_callbacks, Q as bind, v as validate_slots, o as onMount, X as XMLToJSON, A as AH, L as beforeUpdate, w as writable, y as language, M as JSONToXML, h as text, f as space, j as attr_dev, k as add_location, n as insert_dev, q as listen_dev, G as prop_dev, r as group_outros, a as transition_out, u as check_outros, t as transition_in, x as detach_dev, H as run_all, c as create_component, m as mount_component, W as add_flush_callback, b as destroy_component, K as destroy_each, B as noop, $ as null_to_empty } from './main-0211720b.js';

/* clsSMStepAlgo/StepAlgo.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMStepAlgo/StepAlgo.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-smsdwz-style";
	style.textContent = ".font18.svelte-smsdwz{font-size:16px}.fwidth.svelte-smsdwz{width:100%}.light-cyan-bg.svelte-smsdwz{background-color:#d4e4ff;color:#333}.top2.svelte-smsdwz{top:2px}.right5.svelte-smsdwz{right:5px}.right35.svelte-smsdwz{right:35px}.step_checkbox.svelte-smsdwz{width:22%;border:1px solid black;margin-left:10px;position:relative;bottom:1px;cursor:pointer;padding:3px 2px 0}.fixed_ans.svelte-smsdwz{top:10px;position:relative;float:right;border:1px solid #e0e0e0;background-color:#f5f5f5;border-radius:4px;padding:5px;font-size:15px;font-weight:700}.check_box.svelte-smsdwz{right:24px;position:relative;width:40px}.inner_inputs.svelte-smsdwz{margin:0 12px!important}.pointer.svelte-smsdwz{cursor:pointer !important}.width100.svelte-smsdwz{width:100px}[id^=\"fillmain\"]{overflow:hidden;text-align:left}[id^=\"fillmain\"] pre{background:none;border:none;font-size:14px!important}[id^=\"fillmain\"] .string{min-height:50px;margin-top:10px;margin-right:10px}[id^=\"fillmain\"] .footerstr{position:relative;margin-top:10px;background-color:#ccc;padding:15px;min-height:60px}[id^=\"fillmain\"] .footerstr .arrow-up{position:absolute;top:-10px;right:50%;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:10px solid #ccc}[id^=\"fillmain\"] .fill-row{padding:6px}[id^=\"fillmain\"] .fillelement, [id^=\"fillmain\"] .drag-resize{height:30px;display:inline-block;position:relative;min-height:30px;margin:1px}[id^=\"fillmain\"] input[type=\"text\"], [id^=\"fillmain\"] select{height:99%!important;resize:none;font-size:12px;color:#000;max-width:800px}[id^=\"fillmain\"] .drag-resize{vertical-align:middle;border:1px solid #31B731;text-align:center;padding:3px;font-size:14px}[id^=\"fillmain\"] .drag-resize.ui-draggable{cursor:move}[id^=\"fillmain\"] .drop-hover{border:1px dashed red!important;box-shadow:0 0 0 2px yellow inset;outline:1px solid blue}[id^=\"fillmain\"] .fillcheck ul{width:220px}[id^=\"fillmain\"] .fillcheck li.selected{background-color:#E5E5E5}.fillcheck .selected .icomoon-checkmark-3:before{float:left;color:blue;padding:3px;position:relative;right:14px}.fillcheck .icomoon-close-2:before{float:left;color:blue;position:relative;right:14px;font-size:20px}.MathJax_Display{display:inline!important}[id^=\"fillmain\"] .select{font-size:15px}[id^=\"fillmain\"] .textarea{vertical-align:middle;border-radius:3px;background:#ffe;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.ui-draggable-disabled{cursor:no-drop!important;opacity:0.5!important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RlcEFsZ28uc3ZlbHRlIiwic291cmNlcyI6WyJTdGVwQWxnby5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiXG48IS0tIFxuKiAgRmlsZSBOYW1lICAgOiBTdGVwQWxnby5zdmVsdGVcbiogIERlc2NyaXB0aW9uIDogU2F2aW5nIGFuc3dlciB0b29sIGFuZCBxdWVzdGlvbiBtb2RlbCBib3hlc1xuKiAgQXV0aG9yICAgICAgOiBTdW5kYXJhbSBUcmlwYXRoaVxuKiAgVmVyc2lvbiAgICAgOiAxLjBcbiogIFBhY2thZ2UgICAgIDogcGUtaXRlbXNcbiogIExhc3QgdXBkYXRlIDogIC0tPlxuPHNjcmlwdD5cbiAgICBpbXBvcnQge3dyaXRhYmxlfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuICAgIGltcG9ydCB7IEJ1dHRvbiwgRGlhbG9nLCBDaGVja2JveCB9IGZyb20gJ3N2ZWx0ZS1tdWkvc3JjJztcbiAgICBpbXBvcnQgbCBmcm9tICcuLi9zcmMvbGlicy9lZGl0b3JMaWIvbGFuZ3VhZ2UuanMnO1xuICAgIGltcG9ydCB7IGJlZm9yZVVwZGF0ZSxvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQge0FILFhNTFRvSlNPTixKU09OVG9YTUx9IGZyb20gXCIuLi9oZWxwZXIvSGVscGVyQUkuc3ZlbHRlXCI7XG5cbiAgICAgd2luZG93LnNwYW5Db3VudGVyID0gMDtcbiAgICAvLyB3aW5kb3cuY3VycmVudElkID0gXCJcIjtcbiAgICAvLyB3aW5kb3cuY3VycmVudElucCA9IFwiXCI7XG4gICAgbGV0IHN0YXRlID0ge307XG4gICAgbGV0IG5ld194bWwgPSB7fVxuICAgIHZhciBhbGxfc3RlcHMgPSBbXTtcbiAgICBleHBvcnQgbGV0IHN0b3BBdXRob3JpbmdVcGRhdGU7XG4gICAgZXhwb3J0IGxldCB4bWw7XG4gICAgZXhwb3J0IGxldCBlZGl0b3JTdGF0ZTtcbiAgICBleHBvcnQgbGV0IGdldENoaWxkWG1sO1xuXG4gICAgXG4gICAgXG4gICAgbGV0IHN0YXRlRGF0YSA9IHdyaXRhYmxlKHtcbiAgICAgICAgeG1sICAgICAgICAgICAgICAgICAgICAgICAgIDogJycsICAgICAgICAgXG4gICAgICAgIGZpbGxJblRoZUJsYW5rc0Nob2ljZSAgICAgICA6IDEsXG4gICAgICAgIG9wZW5lZCAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBkZWxldGVJbmRleCAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICByZW1lZGlhdGlvblRvZ2dsZSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgc25hY2tiYWNrICAgICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGlucHV0X2FucyAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICBzcGFuQ291bnRlciAgICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICBjdXJyZW50SWQgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgY3VycmVudElucCAgICAgICAgICAgICAgICAgIDogJydcblxuICAgIH0pXG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0YXRlRGF0YS5zdWJzY3JpYmUoKGl0ZW1zKT0+e1xuICAgICAgICBzdGF0ZSA9IGl0ZW1zO1xuICAgIH0pXG5cbiAgICBvbk1vdW50KCgpPT57XG4gICAgICAgIGlmKHhtbCkge1xuICAgICAgICAgICAgbmV3X3htbCA9IFhNTFRvSlNPTih4bWwpO1xuICAgICAgICAgICAgc2hvd0l0ZW1zKG5ld194bWwuc214bWwuc3RlcCk7XG4gICAgICAgICAgICAvL2pRdWVyeSgnI3N0aWNreV9jaGVja2JveF8wJykudHJpZ2dlcignY2xpY2snKTtcbiAgICAgICAgICAgIEFILnNlbGVjdChcIiNzdGlja3lfY2hlY2tib3hfMFwiKS5jbGljaygpO1xuICAgICAgICAgICAgLy9zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8valF1ZXJ5KCcjc3RpY2t5X2NoZWNrYm94XzAnKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICAgICAgICAgIEFILnNlbGVjdCgnI3N0aWNreV9jaGVja2JveF8wJykuY2xpY2soKTtcbiAgICAgICAgICAgIC8vfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8valF1ZXJ5KCcuc2F2ZV9idXR0b25fc3RlcHMnKS5wcm9wKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgQUguc2VsZWN0QWxsKCcuc2F2ZV9idXR0b25fc3RlcHMnLCdhdHRyJyx7ZGlzYWJsZWQ6J2Rpc2FibGVkJ30pO1xuICAgICAgICAgICAgaW5pdEVkaXRvcigpO1xuICAgICAgICB9LCA1MDApO1xuXG4gICAgICAgIC8vIGpRdWVyeShkb2N1bWVudCkub24oXCJjbGljayB0b3VjaHN0YXJ0XCIsIFwiLmVkaXRGaWxsXCIsIGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0aWYoalF1ZXJ5KHRoaXMpLmF0dHIoXCJ0eXBlXCIpID09IFwidFwiKSB7XG5cdFx0Ly8gXHRcdGVkaXRUZXh0Ym94KGpRdWVyeSh0aGlzKS5hdHRyKFwib3JpZ2luYWxLZXlcIikpO1xuXHRcdC8vIFx0fSBlbHNlIGlmKGpRdWVyeSh0aGlzKS5hdHRyKFwidHlwZVwiKSA9PSBcImVcIikge1xuXHRcdC8vIFx0XHRlZGl0TWF0aGJveChqUXVlcnkodGhpcykuYXR0cihcIm9yaWdpbmFsS2V5XCIpKTtcblx0XHQvLyBcdH1cblx0XHQvLyB9KVxuXG4gICAgICAgIEFILmxpc3Rlbihkb2N1bWVudCwnY2xpY2snLCcuZWRpdEZpbGwnLGZ1bmN0aW9uKGN1cnIsZSkge1xuICAgICAgICAgICAgaWYoY3Vyci5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwidFwiKSB7XG4gICAgICAgICAgICAgICAgZWRpdFRleHRib3goY3Vyci5nZXRBdHRyaWJ1dGUoXCJvcmlnaW5hbEtleVwiKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoY3Vyci5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwiZVwiKSB7XG4gICAgICAgICAgICAgICAgZWRpdE1hdGhib3goY3Vyci5nZXRBdHRyaWJ1dGUoXCJvcmlnaW5hbEtleVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgQUgubGlzdGVuKGRvY3VtZW50LCd0b3VjaHN0YXJ0JywnLmVkaXRGaWxsJyxmdW5jdGlvbihjdXJyLGUpIHtcbiAgICAgICAgICAgIGlmKGN1cnIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcInRcIikge1xuICAgICAgICAgICAgICAgIGVkaXRUZXh0Ym94KGN1cnIuZ2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnIuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PSBcImVcIikge1xuICAgICAgICAgICAgICAgIGVkaXRNYXRoYm94KGN1cnIuZ2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG5cblxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBlZGl0VGV4dGJveChrZXkpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY2hlY2tpbmcnKTtcblx0XHRrZXkgPSBrZXkucmVwbGFjZSgvJXt8fSUvZywgXCJcIik7XG5cdFx0a2V5ID0ga2V5LnNwbGl0KFwifFwiKTtcblx0XHRsZXQgYW5zID0ga2V5WzBdLnRyaW0oKTtcbiAgICAgICAgXG5cdFx0bGV0IGFuc190eXBlID0gKChrZXlbMV0pP2tleVsxXS50cmltKCk6XCJcIik7XG5cdFx0XG4gICAgICAgICAgICBzdGF0ZS5udW1lcmljID0gKChhbnNfdHlwZSA9PSBcIm5cIik/IHRydWUgOiBmYWxzZSApO1xuICAgICAgICAgICAgc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID0gMTtcbiAgICAgICAgICAgIHN0YXRlLm9wZW4gPSB0cnVlO1xuICAgICAgICBcblx0XHQvL3RoaXMuc2V0U3RhdGUoe2ZpbGxJblRoZUJsYW5rc0Nob2ljZToxfSk7XG5cdFx0Ly90aGlzLnNldFN0YXRlKHtvcGVuOnRydWV9KTtcblx0XHRpZihhbnMuaW5kZXhPZihcIiNzdHlsZSNcIikgIT0gLTEpIHtcblx0XHRcdGxldCBjdXN0b21TdHlsZSAgPSBhbnMuc3BsaXQoXCIjc3R5bGUjXCIpXG5cdFx0XHQvL2pRdWVyeShcIiNyZXNwb25zZURpYWxvZyAjY3VzdG9tU3R5bGVUZXh0XCIpLnZhbChjdXN0b21TdHlsZVsxXSk7XG4gICAgICAgICAgICBBSC5zZWxlY3QoXCIjcmVzcG9uc2VEaWFsb2cgI2N1c3RvbVN0eWxlVGV4dFwiKS52YWx1ZSA9IGN1c3RvbVN0eWxlWzFdO1xuXG5cdFx0XHQvL2pRVWVyeShcIiNpbnB1dDFcIikudmFsKGN1c3RvbVN0eWxlWzBdKTtcbiAgICAgICAgICAgIC8vQUguc2VsZWN0KFwiI2lucHV0MVwiKS52YWx1ZSA9IGN1c3RvbVN0eWxlWzBdO1xuICAgICAgICAgICAgc3RhdGUuaW5wdXRfYW5zID0gY3VzdG9tU3R5bGVbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8valF1ZXJ5KFwiI2lucHV0MVwiKS52YWwoYW5zKTtcbiAgICAgICAgICAgIC8vIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIC8vICAgICBBSC5zZWxlY3QoXCIjaW5wdXQxXCIpLnZhbHVlID0gYW5zO1xuICAgICAgICAgICAgLy8gfSwxMDApXG4gICAgICAgICAgICBzdGF0ZS5pbnB1dF9hbnMgPSBhbnM7XG5cdFx0fVx0XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBlZGl0TWF0aGJveChrZXkpIHtcblx0XHRrZXkgPSBrZXkucmVwbGFjZSgvJXt8fSUvZywgXCJcIik7XG5cdFx0a2V5ID0ga2V5LnNwbGl0KFwifFwiKTtcblx0XHRsZXQgYW5zID0ga2V5WzBdLnRyaW0oKTtcblx0XHRsZXQgYW5zX3R5cGUgPSAoKGtleVsxXSk/a2V5WzFdLnRyaW0oKTpcIlwiKTtcblx0XHQvLyB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgLy8gICAgIGN1c3RvbVN0eWxlOigoYW5zLmluZGV4T2YoXCIjc3R5bGUjXCIpICE9IC0xKT90cnVlOmZhbHNlKSxcbiAgICAgICAgLy8gICAgIGZpbGxJblRoZUJsYW5rc0Nob2ljZToyLFxuICAgICAgICAvLyAgICAgb3Blbjp0cnVlXG4gICAgICAgIC8vIH0pO1xuICAgICAgICBzdGF0ZS5jdXN0b21TdHlsZSA9ICgoYW5zLmluZGV4T2YoXCIjc3R5bGUjXCIpICE9IC0xKT90cnVlOmZhbHNlKTtcbiAgICAgICAgc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID0yO1xuICAgICAgICBzdGF0ZS5vcGVuID0gdHJ1ZTtcblx0XHQvL3RoaXMuc2V0U3RhdGUoe2ZpbGxJblRoZUJsYW5rc0Nob2ljZToyfSk7ICMjIEFMcmVhZHkgY29tbWVudGVkXG5cdFx0Ly90aGlzLnNldFN0YXRlKHtvcGVuOnRydWV9KTsgIyMgQUxyZWFkeSBjb21tZW50ZWRcblxuXHRcdGlmKGFucy5pbmRleE9mKFwiI3N0eWxlI1wiKSAhPSAtMSkge1xuXHRcdFx0bGV0IGN1c3RvbVN0eWxlICA9IGFucy5zcGxpdChcIiNzdHlsZSNcIilcblx0XHRcdC8vJChcIiNyZXNwb25zZURpYWxvZyAjY3VzdG9tU3R5bGVUZXh0XCIpLnZhbChjdXN0b21TdHlsZVsxXSk7XG4gICAgICAgICAgICBBSC5zZWxlY3QoXCIjcmVzcG9uc2VEaWFsb2dcIikudmFsdWUgPSBjdXN0b21TdHlsZVsxXTtcbiAgICAgICAgICAgIEFILnNlbGVjdCgnI2N1c3RvbVN0eWxlVGV4dCcpLnZhbHVlID0gY3VzdG9tU3R5bGVbMV07XG5cdFx0XHQvLyQoXCIjaW5wdXRcIitpKS52YWwoY3VzdG9tU3R5bGVbMF0pO1xuICAgICAgICAgICAgQUguc2VsZWN0KFwiI2lucHV0XCIraSkudmFsdWUgPSBjdXN0b21TdHlsZVswXTtcblx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgLy8kKFwiI2lucHV0XCIpLnZhbChhbnMpO1xuICAgICAgICAgICAgQUguc2VsZWN0KFwiI2lucHV0XCIpLnZhbHVlID0gYW5zO1xuXHRcdH1cdFxuXHR9XG4gICAgXG4gICAgYmVmb3JlVXBkYXRlKCgpPT57XG4gICAgICAgIGlmICh4bWwgIT0gc3RhdGUueG1sKSB7XG4gICAgICAgICAgICBzdGF0ZS54bWwgPSB4bWw7XG4gICAgICAgICAgICBpZiAoc3RvcEF1dGhvcmluZ1VwZGF0ZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgbmV3X3htbCA9IFhNTFRvSlNPTihzdGF0ZS54bWwpO1xuICAgICAgICAgICAgc2hvd0l0ZW1zKG5ld194bWwuc214bWwuc3RlcCk7XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gc2hvd0l0ZW1zKHN0ZXBzKSB7XG4gICAgICAgIHN0ZXBzID0gcmVwbGFjZVZhcmlhYmxlcyhzdGVwcyk7XG4gICAgICAgIGFsbF9zdGVwcyA9IHN0ZXBzO1xuICAgICAgICBzZXRUb2dnbGUoYWxsX3N0ZXBzKTtcbiAgICAgICAgcGFyc2VYbWxBdXRob3Jpbmcoc3RlcHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRvZ2dsZShzdGVwcykge1xuICAgICAgICBsZXQgdG9vZ2xlID0gJyc7XG4gICAgICAgIHN0ZXBzLm1hcChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYoaXRlbS5fdmlld29ubHkgPT0gMSkge1xuICAgICAgICAgICAgICAgIGFsbF9zdGVwc1tpbmRleF0udG9nZ2xlID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsX3N0ZXBzW2luZGV4XS50b2dnbGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYWxsX3N0ZXBzO1xuICAgIH0gXG5cbiAgICBmdW5jdGlvbiByZXBsYWNlVmFyaWFibGVzKGxhdGV4X3N0cikge1xuICAgICAgICBsZXQgbGF0ZXhfYXJyID0gW107XG4gICAgICAgIGxldCBsYXRleF9hcnJfY2hlY2sgPSBsYXRleF9zdHI7XG4gICAgICAgIGlmKGxhdGV4X2Fycl9jaGVjay5sZW5ndGggPT0gdW5kZWZpbmVkICYmIGxhdGV4X2Fycl9jaGVjayAhPSBcIlwiKSB7XG4gICAgICAgICAgICBsYXRleF9hcnIucHVzaChsYXRleF9hcnJfY2hlY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGF0ZXhfYXJyID0gbGF0ZXhfYXJyX2NoZWNrO1xuICAgICAgICB9XG4gICAgICAgIGxhdGV4X2Fyci5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBjZGF0YSA9IGl0ZW0uX19jZGF0YTtcbiAgICAgICAgICAgIGxldCB2YXJzID0gY2RhdGEubWF0Y2goLzx7W1xcc1xcU10qP30+L2dtKTtcbiAgICAgICAgICAgIGlmKHZhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXJzLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gZWxlbWVudC5tYXRjaCgvPFxceyguKj8pXFx9Pi9nKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udG9TdHJpbmcoKS5yZXBsYWNlKC88XFx7fFxcfT4vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gXCJ2YXI6XCIraXRlbTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBjZGF0YSA9IGNkYXRhLnJlcGxhY2UoZWxlbWVudCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXRleF9hcnJbaW5kZXhdLl9fY2RhdGEgPSBjZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXRleF9hcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VYbWxBdXRob3Jpbmcoc3RlcHMpIHtcbiAgICAgICAgc3RlcHMubWFwKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBsZXQgY2RhdGEgPSBpdGVtLl9fY2RhdGE7XG4gICAgICAgICAgICBsZXQgYW5zd2VyS2V5ID0gY2RhdGEubWF0Y2goLyV7W1xcc1xcU10qP30lL2dtKTtcbiAgICAgICAgICAgIGxldCBhbnN3ZXJUeXBlID0gJyc7XG4gICAgICAgICAgICBpZihhbnN3ZXJLZXkpIHtcbiAgICAgICAgICAgICAgICAvL2pRdWVyeShhbnN3ZXJLZXkpLmVhY2goZnVuY3Rpb24oaSl7XG4gICAgICAgICAgICAgICAgYW5zd2VyS2V5LmZvckVhY2goZnVuY3Rpb24oZGF0YSxpKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsS2V5ID0gYW5zd2VyS2V5W2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF0ZXhLZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWRpdE1hdGggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBhbnN3ZXJUeXBlID0gYW5zd2VyS2V5W2ldLm1hdGNoKC9cXHwoLio/KX0lJC9nbSk7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlclR5cGUgPSAoYW5zd2VyVHlwZSkgPyBhbnN3ZXJUeXBlWzBdLnJlcGxhY2UoL1xcfHx9JS9nbSwgJycpIDogJ3QnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXJLZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWNvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYoYW5zd2VyVHlwZSA9PSBcInRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGFuc3dlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lcktleSA9IFwiVGV4dGJveFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IFwiaWNvbW9vbi1pbnNlcnQtdGVtcGxhdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGFuc3dlclR5cGUgPT0gXCJuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcInRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyS2V5ID0gXCJOdW1lcmljXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gXCJpY29tb29uLWluc2VydC10ZW1wbGF0ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYW5zd2VyVHlwZT09IFwiZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gYW5zd2VyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyS2V5ID0gXCJNYXRoXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRleEtleSA9IG9yaWdpbmFsS2V5LnJlcGxhY2UoL1xcJVxce3xcXHxlXFx9XFwlL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXhLZXkgPSBcImxhdGV4PVxcXCJcIitsYXRleEtleStcIlxcXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRNYXRoID0gXCJlZGl0TWF0aFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IFwiaWNvbW9vbi1pbnNlcnQtdGVtcGxhdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFJlZ0V4cC5xdW90ZShvcmlnaW5hbEtleSkpO1xuICAgICAgICAgICAgICAgICAgICBjZGF0YSA9IGNkYXRhLnJlcGxhY2UocmVnZXgsIFwiPHNwYW4gaWQ9XFxcImxhdGV4U3BhblwiKyhzdGF0ZS5zcGFuQ291bnRlciA9ICsrc3RhdGUuc3BhbkNvdW50ZXIpK1wiXFxcIiBcIitsYXRleEtleStcIiB0eXBlPSdcIit0eXBlK1wiJyBjbGFzcz0nYWxlcnQgYWxlcnQtaW5mbyBlZGl0RmlsbCBcIitlZGl0TWF0aCtcIicgb3JpZ2luYWxrZXk9J1wiK29yaWdpbmFsS2V5K1wiJyBzdHlsZT0ncGFkZGluZzogNXB4O291dGxpbmU6IG5vbmU7bGluZS1oZWlnaHQ6NDBweDtjdXJzb3I6bW92ZTtjb2xvcjojMDAwJyBjb250ZW50RWRpdGFibGU9J2ZhbHNlJz48aSBzdHlsZT0ncGFkZGluZy1yaWdodDo0cHgnIGNsYXNzPSdcIitpY29uK1wiJz48L2k+XCIraW5uZXJLZXkrXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsX3N0ZXBzW2luZGV4XS5fX2NkYXRhID0gY2RhdGE7XG4gICAgICAgIH0pO1xuXHR9XG5cblxuXG4gICAgZnVuY3Rpb24gZ29OZXh0KGlkKSB7XG4gICAgICAgIGxldCByZWYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK2lkKTtcbiAgICAgICAgaWYocmVmLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmdvbmV4dCA9IHRydWU7XG4gICAgICAgICAgICBuZXdfeG1sLnNteG1sLl9nb25leHQgPSBcIjFcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmdvbmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5fZ29uZXh0ID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlWE1MKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4ZWRBbnN3ZXIoaWQpIHtcbiAgICAgICAgbGV0IHJlZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjXCIraWQpO1xuICAgICAgICBpZihyZWYuY2hlY2tlZCkge1xuICAgICAgICAgICAgc3RhdGUudmFyaWFibGVfYnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuX2ZpeGVkID0gXCIxXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS52YXJpYWJsZV9idXR0b24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuX2ZpeGVkID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlWE1MKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlQ2hlY2tib3goaWQsIGZpbGxpZCwgZSkge1xuICAgICAgICBsZXQgbmFtZSA9IGUudGFyZ2V0Lm5hbWU7XG4gICAgICAgIGxldCByZWYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiK25hbWUraWQpO1xuICAgICAgICBsZXQgdmFsID0gXCJfXCIrZS50YXJnZXQudmFsdWU7XG4gICAgICAgIGxldCBzZXEgPSBpZDtcbiAgICAgICAgaWYocmVmLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtzZXFdW3ZhbF0gPSBcIjFcIjsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfeG1sLnNteG1sLnN0ZXBbc2VxXVt2YWxdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9sZXQgZGF0YSA9IGpRdWVyeSgnIycrZmlsbGlkKS5odG1sKCk7XG4gICAgICAgIGxldCBkYXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycrZmlsbGlkKS5pbm5lckhUTUw7XG4gICAgICAgIHVwZGF0ZVhNTCgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRGlzYWJsZShpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoYW5kbGUgY2xpY2snKTtcbiAgICAgICAgLy9qUXVlcnkoJyNzYXZlX3N0ZXBfJytpKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICBBSC5zZWxlY3QoJyNzYXZlX3N0ZXBfJytpLCdyZW1vdmVBdHRyJywnZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSYWRpbyhpbmRleCwgZmlsbGlkLCBldmVudCkge1xuICAgICAgICBpZihhbGxfc3RlcHNbaW5kZXhdLnRvZ2dsZSA9PSAxKSB7XG4gICAgICAgICAgICBhbGxfc3RlcHNbaW5kZXhdLnRvZ2dsZSA9IDBcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtpbmRleF0uX3ZpZXdvbmx5ID0gXCIwXCI7XG4gICAgICAgICAgICBuZXdfeG1sLnNteG1sLnN0ZXBbaW5kZXhdLl9hdHRlbXB0ID0gXCIxXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxfc3RlcHNbaW5kZXhdLnRvZ2dsZSA9PSAxO1xuICAgICAgICAgICAgbmV3X3htbC5zbXhtbC5zdGVwW2luZGV4XS5fdmlld29ubHkgPSBcIjFcIjtcbiAgICAgICAgICAgIG5ld194bWwuc214bWwuc3RlcFtpbmRleF0uX2F0dGVtcHQgPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2xldCBkYXRhID0galF1ZXJ5KCcjJytmaWxsaWQpLmh0bWwoKTtcbiAgICAgICAgbGV0IGRhdGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJytmaWxsaWQpLmlubmVySFRNTDtcbiAgICAgICAgdXBkYXRlWE1MKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlRXZlbnQoaW5kZXgsIGRhdGEpIHtcbiAgICAgICAgbGV0IGRlbGV0ZV9ldmVudDtcbiAgICAgICAgaWYoZGF0YSA9PSAnc3RlcHMnKSB7XG4gICAgICAgICAgICBkZWxldGVfZXZlbnQgPSBhbGxfc3RlcHM7XG4gICAgICAgICAgICBpZihkZWxldGVfZXZlbnQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZCA9IGRlbGV0ZV9ldmVudC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBSC5hbGVydChcIllvdSBoYXZlIGF0bGVhc3QgMiBzdGVwcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGFsbF9zdGVwcyA9IGRlbGV0ZV9ldmVudDsgXG4gICAgICAgIHVwZGF0ZVhNTCgpO1xuICAgICAgICB9IGVsc2UgaWYoZGF0YSA9PSAnYWxnbycpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS5kZWxldGVJbmRleCA9IGluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTYXZlKGlkLCBmaWxsaWQpIHtcbiAgICAgICAgLy9sZXQgZGF0YSA9IGpRdWVyeSgnIycrZmlsbGlkKS5odG1sKCk7XG4gICAgICAgIGxldCBkYXRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycrZmlsbGlkKS5pbm5lckhUTUw7XG4gICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLyZhbXA7L2csJyYnKTsgLy8gcmVwbGFjZSBhbXAgdG8gbWFpbnRhaW4gaHRtbCBlbnRpdHkuXG4gICAgICAgIGFsbF9zdGVwc1tpZF0uX19jZGF0YSA9IGRhdGE7IFxuICAgICAgICAvL2pRdWVyeSgnI3NhdmVfc3RlcF8nK2lkKS5wcm9wKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAvL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzYXZlX3N0ZXBfJytpZCkuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBBSC5zZWxlY3QoJyNzYXZlX3N0ZXBfJytpZCwnYXR0cicse2Rpc2FibGVkOidkaXNhYmxlZCd9KVxuICAgICAgICB1cGRhdGVYTUwoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVYTUwoKSB7XG4gICAgICAgIGxldCBmaXhhbnMgPSBuZXdfeG1sLnNteG1sLl9maXhlZDtcbiAgICAgICAgbGV0IGdvbmV4dCA9IG5ld194bWwuc214bWwuX2dvbmV4dDtcbiAgICAgICAgbGV0IHhtbCA9ICc8c214bWwgdHlwZT1cIjM3XCIgZml4ZWQ9XCInK2ZpeGFucysnXCIgZ29uZXh0PVwiJytnb25leHQrJ1wiPic7XG4gICAgICAgIGFsbF9zdGVwcy5tYXAoZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgICAgICAgbGV0IHNlcSA9IGkrMTtcbiAgICAgICAgICAgIGxldCB2aWV3b25seSA9IGVsZW1lbnQuX3ZpZXdvbmx5O1xuICAgICAgICAgICAgbGV0IG1vZGUgPSBlbGVtZW50Ll9tb2RlO1xuICAgICAgICAgICAgbGV0IGF0dGVtcHQgPSBlbGVtZW50Ll9hdHRlbXB0O1xuICAgICAgICAgICAgbGV0IHN0aWNreSA9IGVsZW1lbnQuX3N0aWNreTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZWxlbWVudC5fX2NkYXRhO1xuICAgICAgICAgICAgLy8gZGF0YSA9IHNlbGYucmV2ZXJzZVJlcGxhY2VWYXJpYWJsZXMoZGF0YSk7XG4gICAgICAgICAgICBkYXRhID0gcmV2ZXJzZUh0bWxTcGVjaWFsQ2hhcnMoZGF0YSk7XG4gICAgICAgICAgICBkYXRhID0gcmVwbGFjZVNwYWNlcyhkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgID0gZGF0YS5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJykucmVwbGFjZSgvJm5ic3A7L2csICcgJyk7XG4gICAgICAgICAgICBkYXRhICA9IGRhdGEucmVwbGFjZSgvJy9nLCAnXCInKS5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgICAgICAgICAgbGV0IGFyciA9IGRhdGEubWF0Y2goLzxzcGFuKC4qPyk+KC4qPyk8XFwvc3Bhbj4vZ2kpO1xuICAgICAgICAgICAgaWYoYXJyKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbGtleSA9IGFycltpXS5tYXRjaCgvb3JpZ2luYWxrZXk9XCIlKC4qPyklXCIvZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG9yaWdpbmFsa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbGtleSA9IG9yaWdpbmFsa2V5LnRvU3RyaW5nKCkucmVwbGFjZSgvb3JpZ2luYWxrZXk9L2csICcnKS5yZXBsYWNlKC9cIiV8JVwiL2csICclJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKGFycltpXSwgb3JpZ2luYWxrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNkYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHhtbCA9IHhtbCArIFwiPHN0ZXAgc2VxPSdcIitzZXErXCInXCIgKyAoKGF0dGVtcHQgIT0gdW5kZWZpbmVkKT8gXCIgYXR0ZW1wdCA9J1wiK2F0dGVtcHQrXCInXCIgOiAnICcpICsgKCh2aWV3b25seSAhPSB1bmRlZmluZWQpPyBcIiB2aWV3b25seSA9J1wiK3ZpZXdvbmx5K1wiJ1wiIDogJyAnKSArICgobW9kZSAhPSB1bmRlZmluZWQpPyBcIiBtb2RlID0nXCIrbW9kZStcIidcIiA6ICcgJykgKyAoKHN0aWNreSAhPSB1bmRlZmluZWQpPyBcIiBzdGlja3kgPSdcIitzdGlja3krXCInXCIgOiAnICcpICtcIj48IS0tW0NEQVRBW1wiK2NkYXRhK1wiXV0tLT48L3N0ZXA+XCI7XG4gICAgICAgIH0pO1xuICAgICAgICB4bWwgPSB4bWwgKyBcIjwvc214bWw+XCI7XG4gICAgICAgIGdldENoaWxkWG1sKHhtbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV2ZXJzZUh0bWxTcGVjaWFsQ2hhcnMoZGF0YSkge1xuICAgICAgICBsZXQgdGFncyA9IGRhdGEubWF0Y2goLyZsdDsoLio/KSZndDsvZ20pO1xuXHRcdGxldCB0YWcgPSAnJztcblx0XHRpZih0YWdzKSB7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFnID0gdGFnc1tpXTtcbiAgICAgICAgICAgICAgICB0YWdzW2ldID0gdGFnc1tpXS5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKHRhZywgdGFnc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTcGFjZXMoZGF0YSkge1xuICAgICAgICBsZXQgbWF0Y2hpbmcgPSBkYXRhLm1hdGNoKC92YXI6dmFyXFxkK1xccytcXHMrL2cpO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGlmKG1hdGNoaW5nKSB7XG4gICAgICAgICAgICBtYXRjaGluZy5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIG1hdGNoID0gaXRlbS50cmltKCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShpdGVtLG1hdGNoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEV2ZW50KGRhdGEpIHtcbiAgICAgICAgbGV0IG9iaiA9IHt9O1xuICAgICAgICBvYmouX3NlcSA9IGFsbF9zdGVwcy5sZW5ndGgrMTtcbiAgICAgICAgb2JqLl92aWV3b25seSA9IFwiMVwiO1xuICAgICAgICBvYmouX2F0dGVtcHQgPSBcIjBcIjtcbiAgICAgICAgb2JqLl9tb2RlID0gXCIwXCI7XG4gICAgICAgIG9iai5fX2NkYXRhID0gXCJOZXcgU3RlcFwiO1xuICAgICAgICBhbGxfc3RlcHMucHVzaChvYmopO1xuICAgICAgICB1cGRhdGVYTUwoKTtcbiAgICAgICAgc3RhdGUuc25hY2tiYWNrID0gdHJ1ZTtcbiAgICAgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluaXRFZGl0b3IoKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEVkaXRvcigpIHtcbiAgICAgICAgLy8galF1ZXJ5KGRvY3VtZW50KS5vbihcImNsaWNrXCIsIFwiLmVkaXRNYXRoXCIsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyAgICAgd2luZG93LmN1cnJlbnRJZCA9IGpRdWVyeSh0aGlzKS5hdHRyKCdpZCcpO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICBBSC5saXN0ZW4oZG9jdW1lbnQsXCJjbGlja1wiLFwiLmVkaXRNYXRoXCIsZnVuY3Rpb24oX3RoaXMsZSl7XG4gICAgICAgICAgICAvLyB3aW5kb3cuY3VycmVudElkID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudElkID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGpRdWVyeShkb2N1bWVudCkub24oXCJjbGlja1wiLCBcIi5tYXRlcmlhbE92ZXJsYXlcIiwgZnVuY3Rpb24oZSl7XG5cdFx0Ly8gXHR3aW5kb3cuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgLy8gICAgIHdpbmRvdy5jdXJyZW50SW5wID0gbnVsbDtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgQUgubGlzdGVuKGRvY3VtZW50LCdjbGljaycsJy5tYXRlcmlhbE92ZXJsYXknLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgLy93aW5kb3cuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJZCAgPSBudWxsO1xuICAgICAgICAgICAgLy93aW5kb3cuY3VycmVudElucCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50SW5wID0gbnVsbDtcbiAgICAgICAgfSlcblxuXHRcdHRpbnlNQ0UuUGx1Z2luTWFuYWdlci5hZGQoJ3JlcycsIGZ1bmN0aW9uKGVkaXRvciwgdXJsKSB7XG4gICAgICAgICAgICBlZGl0b3IuYWRkTWVudUl0ZW0oJ3Jlc3AnLCB7XG4gICAgICAgICAgICAgICAgdGV4dDpcIkFkZCByZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGlkOidhZGRUb2tlbicsXG4gICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPcGVuKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiAnaW5zZXJ0JyxcbiAgICAgICAgICAgICAgICBwcmVwZW5kVG9Db250ZXh0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cdFx0dGlueW1jZS5QbHVnaW5NYW5hZ2VyLmxvYWQoJ2VxdWF0aW9uZWRpdG9yJywgdGhlbWVVcmwrJ3BlLWl0ZW1zL3RpbnltY2UvcGx1Z2lucy9lcXVhdGlvbmVkaXRvci9wbHVnaW4ubWluLmpzJyk7XG5cdFx0dGlueW1jZS5pbml0KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnLnRpbnltY2UtZWRpdG9yLXJlcycsXG4gICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICB0aGVtZTogJ21vZGVybicsXG4gICAgICAgICAgICBza2luOiAnc2tpbjAyJyxcbiAgICAgICAgICAgIG1pbl93aWR0aDogMTAwLFxuICAgICAgICAgICAgcmVzaXplOiB0cnVlLFxuICAgICAgICAgICAgbWVudWJhcjogZmFsc2UsXG4gICAgICAgICAgICB0b29sYmFyOiB0cnVlLFxuICAgICAgICAgICAgZWxlbWVudHBhdGg6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzYmFyOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcmNlX2JyX25ld2xpbmVzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX3RyYWlsaW5nX2JyczogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlZF9yb290X2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzOiAnc3BhbltvbkNsaWNrfGNvbnRlbnRFZGl0YWJsZV0nLFxuICAgICAgICAgICAgdmFsaWRfZWxlbWVudHM6IFwiKlsqXVwiLFxuXHRcdFx0Zml4ZWRfdG9vbGJhcl9jb250YWluZXI6ICcjdG9vbGJhcl9jb250YWluZXInLFxuICAgICAgICAgICAgZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHM6ICd1YzpzeW50YXgsdWM6cmVmJyxcbiAgICAgICAgICAgIGN1c3RvbV9lbGVtZW50czogJ3VjOnN5bnRheCx+dWM6cmVmJyxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBcImxpc3RzIGxpbmsgaW1hZ2UgY2hhcm1hcCBwcmludCBwcmV2aWV3IGFuY2hvclwiLFxuICAgICAgICAgICAgICAgIFwic2VhcmNocmVwbGFjZSBjb2RlIGZ1bGxzY3JlZW5cIixcbiAgICAgICAgICAgICAgICBcImluc2VydGRhdGV0aW1lIG1lZGlhIHRhYmxlIGNvbnRleHRtZW51IHBhc3RlIHJlcyBlcXVhdGlvbmVkaXRvciBcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNvbnRlbnRfY3NzOiB0aGVtZVVybCsncGUtaXRlbXMvdGlueW1jZS9wbHVnaW5zL2VxdWF0aW9uZWRpdG9yL21hdGhxdWlsbC5jc3MnLFxuICAgICAgICAgICAgdG9vbGJhcjogW1xuICAgICAgICAgICAgJyBib2xkIGl0YWxpYyB1bmRlcmxpbmUgfCBlcXVhdGlvbmVkaXRvcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBjb250ZXh0bWVudTpcInJlc3BcIixcbiAgICAgICAgICAgIHBhc3RlX2FzX3RleHQ6IHRydWVcbiAgICAgICAgfSk7XG5cdH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsb3NlKCkge1xuICAgICAgICBpZihzdGF0ZS5maWxsSW5UaGVCbGFua3NDaG9pY2UgPT0gMikge1xuXHRcdFx0Ly93aW5kb3cuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJbnAgPSBudWxsO1xuXHRcdH1cbiAgICAgICAgc3RhdGUub3BlbiA9IGZhbHNlOyBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEaWFsb2codGFyZ2V0VmFsKSB7ICBcbiAgICAgICAgc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID0gdGFyZ2V0VmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEVkaXRhYmxlKCkge1xuXHRcdC8vbGV0IHR4dCA9IGpRdWVyeShcIiNpbnB1dFwiKTtcbiAgICAgICAgbGV0IHR4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaW5wdXRcIik7XG4gICAgICAgIC8vbGV0IGNhcmV0UG9zID0gdHh0WzBdLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBsZXQgY2FyZXRQb3MgPSB0eHQuc2VsZWN0aW9uU3RhcnQ7XG5cdFx0Ly9sZXQgdGV4dEFyZWFUeHQgPSB0eHQudmFsKCk7XG4gICAgICAgIGxldCB0ZXh0QXJlYVR4dCA9IHR4dC52YWx1ZTtcbiAgICAgICAgIHZhciB0eHRUb0FkZCA9IFwiXFxcXE1hdGhRdWlsbE1hdGhGaWVsZFwiO1xuICAgICAgICB2YXIgdHh0VG9BZGQgID0gXCJ1c2VyIFJlc3BvbnNlXCI7XG4gICAgICAgIC8vdHh0LnZhbCh0ZXh0QXJlYVR4dC5zdWJzdHJpbmcoMCwgY2FyZXRQb3MpICsgdHh0VG9BZGQgKyB0ZXh0QXJlYVR4dC5zdWJzdHJpbmcoY2FyZXRQb3MpKTtcbiAgICAgICAgdHh0LnZhbHVlID0gdGV4dEFyZWFUeHQuc3Vic3RyaW5nKDAsIGNhcmV0UG9zKSArIHR4dFRvQWRkICsgdGV4dEFyZWFUeHQuc3Vic3RyaW5nKGNhcmV0UG9zKTtcblx0fVxuXG4gICAgZnVuY3Rpb24gbGF0ZXhFZGl0KCkge1xuICAgICAgICBzdGF0ZS5vcGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9yZUFucygpIHtcblx0XHR2YXIgdmFsaWRhdGUgPSAwO1xuXHRcdGlmKHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAxKSB7XG5cdFx0XHQvL2xldCBhbnMgPSBqUXVlcnkoXCIjaW5wdXQxXCIpLnZhbCgpO1xuICAgICAgICAgICAgbGV0IGFucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaW5wdXQxXCIpLnZhbHVlO1xuXHRcdFx0Ly9sZXQgbnVtZXJpYyA9IGpRdWVyeShcIiNyZXNwb25zZURpYWxvZyAjbnVtZXJpY1wiKVswXS5jaGVja2VkO1xuICAgICAgICAgICAgbGV0IG51bWVyaWMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Jlc3BvbnNlRGlhbG9nICNudW1lcmljXCIpLmNoZWNrZWQ7XG4gICAgICAgICAgICBpZihudW1lcmljID09IHRydWUpIHtcblx0XHRcdFx0YW5zICs9IFwiIHxuXCI7XG5cdFx0XHR9XG5cdFx0XHRpZihhbnMudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0dmFsaWRhdGUgPSAxO1xuXHRcdFx0XHR2YWxpZGF0ZShcIkFsbCBmaWVsZHMgYXJlIHJlcXVpcmVkXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGlueU1DRS5hY3RpdmVFZGl0b3IuaW5zZXJ0Q29udGVudChcIjxzcGFuIHR5cGU9J3QnIGNsYXNzPSdhbGVydCBhbGVydC1pbmZvIGVkaXRGaWxsJyBvcmlnaW5hbEtleT0nJXtcIithbnMudHJpbSgpK1wifSUnIHN0eWxlPSdwYWRkaW5nOiA1cHg7b3V0bGluZTogbm9uZTtsaW5lLWhlaWdodDo0MHB4O2N1cnNvcjptb3ZlO2NvbG9yOiMwMDAnIGNvbnRlbnRFZGl0YWJsZT0nZmFsc2UnPjxpIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OjRweCcgY2xhc3M9J2ljb21vb24taW5zZXJ0LXRlbXBsYXRlJz48L2k+XCIrKChudW1lcmljID09IHRydWUpP1wiTnVtZXJpY1wiOlwiVGV4dGJveFwiKStcIjwvc3Bhbj5cIik7XG5cdFx0XHR9XG4gICAgICAgIH1cbiAgICAgICAgaWYoc3RhdGUuZmlsbEluVGhlQmxhbmtzQ2hvaWNlID09IDIpIHtcblx0XHRcdC8vbGV0IGUgPSBqUXVlcnkoXCIjaW5wdXRcIikudmFsKCk7XG4gICAgICAgICAgICBsZXQgZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaW5wdXRcIikudmFsdWU7XG5cdFx0XHRpZih2YWxpZGF0ZSA9PSAwKSB7XG5cdFx0XHRcdC8vZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNcIit3aW5kb3cuY3VycmVudElkKS5zZXRBdHRyaWJ1dGUoXCJsYXRleFwiLGUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjXCIrc3RhdGUuY3VycmVudElkKS5zZXRBdHRyaWJ1dGUoXCJsYXRleFwiLGUpO1xuXHRcdFx0XHQvL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjXCIrd2luZG93LmN1cnJlbnRJZCkuc2V0QXR0cmlidXRlKFwib3JpZ2luYWxLZXlcIixcIiV7XCIrZStcInxlfSVcIik7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNcIitzdGF0ZS5jdXJyZW50SWQpLnNldEF0dHJpYnV0ZShcIm9yaWdpbmFsS2V5XCIsXCIle1wiK2UrXCJ8ZX0lXCIpO1xuXHRcdFx0XHQvL3dpbmRvdy5jdXJyZW50SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJZCA9IG51bGw7XG5cdFx0XHRcdC8vd2luZG93LmN1cnJlbnRJbnAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJbnAgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsaWRhdGUoXCJBbGwgZmllbGRzIGFyZSByZXF1aXJlZFwiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZih2YWxpZGF0ZSA9PSAwKSB7XG5cdFx0XHRoYW5kbGVDbG9zZSgpO1xuXHRcdH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVPcGVuKCkge1xuICAgICAgICAvLyB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgLy8gICAgIG9wZW46IHRydWUsXG4gICAgICAgIC8vICAgICBjb2RldHlwZTogZmFsc2UsXG4gICAgICAgIC8vICAgICBudW1lcmljOiBmYWxzZVxuICAgICAgICAvLyB9KTtcbiAgICAgICAgc3RhdGUub3BlbiA9IHRydWU7XG4gICAgICAgIHN0YXRlLmNvZGV0eXBlID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLm51bWVyaWMgPSBmYWxzZTtcbiAgICAgICAgLy90aGlzLnNldFN0YXRlKHtjb2RldHlwZTogZmFsc2V9KTsgI2FscmVhZHkgY29tbWVudGVkIG9uIGFsc28gcmVhY3RcbiAgICAgICAgLy90aGlzLnNldFN0YXRlKHtudW1lcmljOiBmYWxzZX0pOyAjYWxyZWFkeSBjb21tZW50ZWQgb24gYWxzbyByZWFjdFxuICAgIH1cblxuPC9zY3JpcHQ+IFxuPG1haW4+XG4gICAgPGRpdiBjbGFzcz1cIm10LWltcCBib3JkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJvcmRlci1ib3R0b20gZC1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIHB4LTIgcHQtMVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtaW5saW5lLWJsb2NrIHB0LTEgZmxvYXQtc3RhcnQgY3Jfc3RlcFwiIHN0eWxlPXsnZm9udC1zaXplOjIwcHg7cG9zaXRpb246cmVsYXRpdmU7J30+e2wuY3JlYXRlX3N0ZXBzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17e319PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2Rlc19jaGVja2JveCBkLWlubGluZS1ibG9jayB0b3AtY2hlY2tib3hfZ29uZXh0IHBvc2l0aW9uLXJlbGF0aXZlIHRvcDJcIj5cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveCAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cImdvX25leHRcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0ge3N0YXRlLmdvbmV4dCA/IHRydWU6IGZhbHNlfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrPXsoZSk9Pntnb05leHQoXCJnb19uZXh0XCIsZSl9fSBcbiAgICAgICAgICAgICAgICAgICAgPntcIkdvIE5leHRcIn08L0NoZWNrYm94PlxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGVzX2NoZWNrYm94IGQtaW5saW5lLWJsb2NrIG0tbCB0b3AtY2hlY2tib3hfZml4IHBvc2l0aW9uLXJlbGF0aXZlIHRvcDJcIj5cbiAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94ICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiZml4ZWRhbnNfY2hlY2tib3hcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0ge3N0YXRlLnZhcmlhYmxlX2J1dHRvbiA/IHRydWU6IGZhbHNlfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrPXsoZSk9PntmaXhlZEFuc3dlcihcImZpeGVkYW5zX2NoZWNrYm94XCIsZSl9fSBcbiAgICAgICAgICAgICAgICAgICAgPntcIkZpeCBBbnN3ZXJcIn0gPC9DaGVja2JveD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwib3V0ZXJfc3RlcHMgbXQtMyBteC0zIGNsZWFyLWJvdGhcIj5cbiAgICAgICAgICAgIDwhLS0ge3RoaXMuYWxsX3N0ZXBzLm1hcCgoaXRlbSwgaW5kZXgpID0+IC0tPlxuICAgICAgICAgICAgeyNlYWNoIGFsbF9zdGVwcyBhcyBpdGVtLGluZGV4fVxuICAgICAgICAgICAgICAgIDxmaWVsZHNldCBrZXk9e2luZGV4fSBzdHlsZT17J2JvcmRlcjoxcHggc29saWQgZ3JleSd9IGNsYXNzPVwibmV3X3N0ZXBzIHNlcV9pbmJveCBmdyBzaGFkb3ctc20gbWItMlwiPlxuICAgICAgICAgICAgICAgICAgICA8bGVnZW5kIGNsYXNzPVwiZm9udDE4IG1iIG1zLTIgcGwtMVwiIHN0eWxlPXsnd2lkdGg6MWVtO2Zsb2F0Om5vbmU7J30+e2luZGV4KzF9PC9sZWdlbmQ+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWlubGluZS1ibG9jayB0YWJsZV93aWR0aCBtcy0yIHBsLTEgcGItMiBtYi0xXCIgc3R5bGU9eyd3aWR0aDo5NyU7J30+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc2VxPXtpbmRleH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0aW55bWNlLWVkaXRvci1yZXMgc3RlcHNfZWRpdCBwLTEgYm9yZGVyIGZpbGxBdXRob3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPXtgZmlsbEF1dGhvcl8ke2luZGV4fWB9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXsncGFkZGluZzowIDhweDtvdmVyZmxvdzphdXRvO291dGxpbmU6bm9uZSd9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFZGl0YWJsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXRleHQ9XCJFbnRlciB0ZXh0IGhlcmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmtleXVwPXsoZSk9PntoYW5kbGVEaXNhYmxlKGluZGV4LGUpfX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtAaHRtbCBpdGVtLl9fY2RhdGF9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2aWV3X2NoZWNrYm94IGQtaW5saW5lLWJsb2NrIGxpZ2h0LWN5YW4tYmcgcHgtMiBwLTEgZnVsbC13aWR0aCBmd2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRlc3QgZC1pbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicG9pbnRlciBkLWlubGluZS1ibG9jayBwbGFpbl90ZXh0XCIgZGF0YS10b2dnbGU9XCJ0b29sdGlwXCIgdGl0bGU9XCJEb24ndCB1c2UgYW55IGludGVyYWN0aXZlIGl0ZW0hXCIgZm9yPXtgdmlld29ubHlfcmFkaW9fJHtpbmRleH1gfT57bC5wbGFpbl90ZXh0fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdC1wZXJjZW50IG1zLTRcIiBzdHlsZT17J2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlOyd9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9ybS1jaGVjayBmb3JtLXN3aXRjaFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgaWQ9XCJzd2l0Y2hFbGVtZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9eyhpdGVtLnRvZ2dsZSA9PSBcIjFcIj8gZmFsc2U6IHRydWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlPXsoZSk9PntoYW5kbGVSYWRpbyhpbmRleCwgJ2ZpbGxBdXRob3JfJytpbmRleCxlKX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcj1cInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzd2l0Y2hFbGVtZW50XCI+e2wuaW50ZXJhY3RpdmV9PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWlubGluZS1ibG9jayBwbGFpbl90ZXh0IG1zLTNcIiA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZXNfY2hlY2tib3ggZC1pbmxpbmUtYmxvY2sgbXMtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2hlY2tfYm94IGQtaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0geyhpdGVtLl9tb2RlID09IFwiMVwiKSA/IC0tPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uX21vZGUgPT0gXCIxXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggZGF0YS1zZXE9e2luZGV4fSBjbGFzcz1cImlubmVyX2lucHV0cyBvcHRpb25fY2hlY2tib3hcIiBvbjpjbGljaz17KGUpPT57aGFuZGxlQ2hhbmdlQ2hlY2tib3goaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgsZSl9fSB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIm1vZGVcIiBuYW1lPVwibW9kZV9jaGVja2JveF9cIiBpZD17YG1vZGVfY2hlY2tib3hfJHtpbmRleH1gfSBjaGVja2VkPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGRhdGEtc2VxPXtpbmRleH0gY2xhc3M9XCJpbm5lcl9pbnB1dHMgb3B0aW9uX2NoZWNrYm94XCIgb246Y2xpY2s9eyhlKT0+e2hhbmRsZUNoYW5nZUNoZWNrYm94KGluZGV4LCAnZmlsbEF1dGhvcl8nK2luZGV4LGUpfX0gdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJtb2RlXCIgbmFtZT1cIm1vZGVfY2hlY2tib3hfXCIgaWQ9e2Btb2RlX2NoZWNrYm94XyR7aW5kZXh9YH0gY2hlY2tlZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvbnQtd2VpZ2h0LW5vcm1hbCBtZS0xIHBvc2l0aW9uLXJlbGF0aXZlIHRvcDIgcmlnaHQzNVwiIGZvcj17YG1vZGVfY2hlY2tib3hfJHtpbmRleH1gfT57bC5ub192YWxpZGF0aW9ufTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0ge2luZGV4ID09IDAgPyAgLS0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGluZGV4ID09IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0aWNrX2NoZWNrYm94IGQtaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2hlY2tfYm94IGQtaW5saW5lLWJsb2NrXCI+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0geyhpdGVtLl9zdGlja3kgPT0gXCIxXCIpID8gLS0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uX3N0aWNreSA9PSBcIjFcIn0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGRhdGEtc2VxPXtpbmRleH0gY2hlY2tlZD17dHJ1ZX0gY2xhc3M9XCJpbm5lcl9pbnB1dHMgb3B0aW9uX2NoZWNrYm94XCIgb246Y2xpY2s9e2hhbmRsZUNoYW5nZUNoZWNrYm94LmJpbmQodGhpcywgaW5kZXgsICdmaWxsQXV0aG9yXycraW5kZXgpfSB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cInN0aWNreVwiIG5hbWU9XCJzdGlja3lfY2hlY2tib3hfXCIgaWQ9e2BzdGlja3lfY2hlY2tib3hfJHtpbmRleH1gfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPENoZWNrYm94IGRhdGEtc2VxPXtpbmRleH0gY2hlY2tlZD17ZmFsc2V9IGNsYXNzPVwiaW5uZXJfaW5wdXRzIG9wdGlvbl9jaGVja2JveFwiIG9uOmNsaWNrPXtoYW5kbGVDaGFuZ2VDaGVja2JveC5iaW5kKHRoaXMsIGluZGV4LCAnZmlsbEF1dGhvcl8nK2luZGV4KX0gdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJzdGlja3lcIiBuYW1lPVwic3RpY2t5X2NoZWNrYm94X1wiIGlkPXtgc3RpY2t5X2NoZWNrYm94XyR7aW5kZXh9YH0vPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb250LXdlaWdodC1ub3JtYWwgbWUtMSBwb3NpdGlvbi1yZWxhdGl2ZSB0b3AyIHJpZ2h0MzVcIiBmb3I9e2BzdGlja3lfY2hlY2tib3hfJHtpbmRleH1gfT57bC5zdGlja3l9PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9IFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17J2Rpc3BsYXk6aW5saW5lLWJsb2NrO2Zsb2F0OnJpZ2h0Oyd9IGNsYXNzPVwiYnV0dG9ucyBlZGl0X3N0ZXBzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1pbmxpbmUtYmxvY2sgbXJcIiBzdHlsZT17J2Rpc3BsYXk6aW5saW5lLWJsb2NrOyd9IG9uOmNsaWNrPXsoZSk9PntkZWxldGVFdmVudChpbmRleCwgJ3N0ZXBzJyxlKX19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1saWdodCBmb250MTJcIj57bC5kZWxldGV9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1pbmxpbmUtYmxvY2tcIiBzdHlsZT17J3RleHQtYWxpZ246cmlnaHQ7bWFyZ2luLXRvcDo2cHg7J30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBpZD17YHNhdmVfc3RlcF8ke2luZGV4fWB9IHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17KGUpPT57aGFuZGxlU2F2ZShpbmRleCwgJ2ZpbGxBdXRob3JfJytpbmRleCxlKX19IGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGZvbnQxMiBzYXZlX2J1dHRvbl9zdGVwc1wiPntsLnNhdmV9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICAgICAgICA8IS0tICl9IC0tPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBteC0zIG10LTMgcGItM1wiPlxuICAgICAgICAgICAgPEJ1dHRvbiB2YXJpYW50PVwiZmFiXCIgY29sb3I9XCJwcmltYXJ5XCIgbWluaSBhcmlhLWxhYmVsPVwiQWRkXCJcbiAgICAgICAgICAgICAgICBvbjpjbGljaz17YWRkRXZlbnQuYmluZCh0aGlzLCAnc3RlcHMnKX1cbiAgICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1wcmltYXJ5IHJvdW5kZWQgcG9zaXRpb24tcmVsYXRpdmUgYm90dG9tMCBiZy13aGl0ZSBzaGFkb3ctc20gaGVpZ2h0MzBcIlxuICAgICAgICAgICAgICAgIHN0eWxlPXsnZmxvYXQ6bGVmdDt3aWR0aDoxMjBweDtoZWlnaHQ6MzBweDtib3JkZXI6MXB4IHNvbGlkICM0Mjg1ZjQ7Y29sb3I6IzQyODVmNDt0ZXh0LXRyYW5zZm9ybTpub25lOyd9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udDE4XCI+JiM0MzsgJm5ic3A7PC9zcGFuPiBBZGQgU3RlcFxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8RGlhbG9nIG92ZXJsYXlDbGFzcz1cIm1hdGVyaWFsT3ZlcmxheVwiICBiaW5kOnZpc2libGU9e3N0YXRlLm9wZW59IG9uOmNsb3NlPXtoYW5kbGVDbG9zZS5iaW5kKHRoaXMpfSBkaXNhYmxlRW5mb3JjZUZvY3VzPXt0cnVlfSB3aWR0aD1cIjY1MFwiIGNsYXNzPVwicm93XCIgc3R5bGU9eydiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyd9PlxuICAgICAgICAgICAgICAgICAgICA8IS0tIDxEaWFsb2dUaXRsZSBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXM9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290OlwicC1tZCBlZGl0b3JfbW9kYWxfdGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgID4gLS0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc2xvdD1cInRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXItbGcgZmxvYXQtbGVmdFwiIHN0eWxlPXsncGFkZGluZy10b3A6MTBweDtwYWRkaW5nLWxlZnQ6MTNweDtmb250LXNpemU6MThweDsnfT57bC5maWxsX2hlYWRlcn08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsb2F0LXJpZ2h0IG1yLTRcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtdC0xIHJvdyBtbC0wXCI+XG5cdFx0XHRcdFx0XHRcdFx0PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9e1wiYnRuIGJ0bi1saWdodCBjb2wtM1wiICsgKChzdGF0ZS5maWxsSW5UaGVCbGFua3NDaG9pY2UgPT0gMSk/IFwiIGFjdGl2ZVwiOiBcIlwiKX0gdmFsdWU9ezF9IG9uOmNsaWNrPXt1cGRhdGVEaWFsb2cuYmluZCh0aGlzLCAxKX0gPlRleHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz17XCJidG4gYnRuLWxpZ2h0IGNvbC05XCIgKyAoKHN0YXRlLmZpbGxJblRoZUJsYW5rc0Nob2ljZSA9PSAyKT8gXCIgYWN0aXZlXCI6IFwiXCIpfSB2YWx1ZT17Mn0gb246Y2xpY2s9e3VwZGF0ZURpYWxvZy5iaW5kKHRoaXMsIDIpfSA+TWF0aGVtYXRpY2FsIEVxdWF0aW9uPC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8IS0tIDwvRGlhbG9nVGl0bGU+IC0tPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInJlc3BvbnNlRGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBzdGF0ZS5maWxsSW5UaGVCbGFua3NDaG9pY2UgPT0gMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXggbXItMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3aWR0aDEwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3ggIGlkID0gXCJudW1lcmljXCIgY2hlY2tlZCA9IHtzdGF0ZS5udW1lcmljfT57XCJOdW1lcmljXCJ9PC9DaGVja2JveD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcImlucHV0MVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtzdGF0ZS5pbnB1dF9hbnN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbCBtci00IG1sLTNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9eydtYXJnaW46NXB4J31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG86Zm9jdXMgPSB7dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0geygoQUguc2VsZWN0KFwiI2lucHV0MVwiKS5pbm5lckhUTUwgIT0gXCJcIik/bC5maWxsX3RleHRfcGxhY2Vob2xkZXI6XCJcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlciBmb250LXdlaWdodC1ib2xkIG1sLTIgbXQtM1wiPiogTm90ZTo8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlciBtbC0yXCIgc3R5bGU9eyd0ZXh0LWluZGVudDoxNXB4J30+e2wuZmlsbF90ZXh0X2hlbHAxfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtZGFuZ2VyIG1sLTJcIiBzdHlsZT17J3RleHQtaW5kZW50OjE1cHgnfT4yLiBQbGVhc2UgZG8gbm90IGluY2x1ZGUgc3BhY2UuPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0ge1wiaW5wdXRcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3MgPSBcImxhdGV4SW5wIGZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0geydtYXJnaW46NXB4O3dpZHRoOjcxJTsnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvOmZvY3VzID0ge3RydWV9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50ID0gXCJjb250YWluZWRcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBcInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsnYm9yZGVyOjFweCBzb2xpZCAjNDI4NWY0O2NvbG9yOiM0Mjg1ZjQ7dGV4dC10cmFuc2Zvcm06bm9uZTsnfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7YWRkRWRpdGFibGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXByaW1hcnkgaGVpZ2h0MzAgYmctd2hpdGUgc2hhZG93LXNtIG10LTEgdG9wMSBtbC0xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkIFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+ICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFwibGF0ZXhFZGl0QnV0dG9uIGQtaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHtcImxhdGV4RWRpdFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudCA9IFwiY29udGFpbmVkXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IFwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHsnbWFyZ2luOjVweDtkaXNwbGF5Om5vbmU7J30gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljayA9IHtsYXRleEVkaXR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFZGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1kYW5nZXIgZm9udC13ZWlnaHQtYm9sZCBtbC0xXCI+KiBOb3RlOjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtZGFuZ2VyIG1sLTFcIiBzdHlsZT17J3RleHQtaW5kZW50OiAxNXB4Oyd9PntsLmZpbGxfbWF0aF9oZWxwMX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlciBtbC0xXCIgc3R5bGU9eyd0ZXh0LWluZGVudDogMTVweDsnfT57bC5maWxsX21hdGhfaGVscDJ9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cblxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN2ZWx0ZUZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB2YXJpYW50PVwiY29udGFpbmVkXCIgb246Y2xpY2s9e2hhbmRsZUNsb3NlfSA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2wuY2FuY2VsfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+LFxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB2YXJpYW50PVwiY29udGFpbmVkXCIgb246Y2xpY2s9e3N0b3JlQW5zfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmctcHJpbWFyeSB0ZXh0LXdoaXRlXCI+e2wuZG9uZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9EaWFsb2c+XG48L21haW4+XG5cblxuICAgIFxuXG5cbjxzdHlsZT5cbiAgICAuZm9udDE4IHtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgIH1cbiAgICAuZndpZHRoICAge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICAubGlnaHQtY3lhbi1iZyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkNGU0ZmY7IFxuICAgICAgICBjb2xvcjogIzMzMztcbiAgICB9XG5cbiAgICAudG9wMiB7XG4gICAgICAgIHRvcDogMnB4O1xuICAgIH1cbiAgICAucmlnaHQ1IHtcbiAgICAgICAgcmlnaHQ6IDVweDtcbiAgICB9XG5cbiAgICAucmlnaHQzNSB7XG4gICAgICAgIHJpZ2h0OiAzNXB4O1xuICAgIH1cblxuICAgIC5zdGVwX2NoZWNrYm94IHtcbiAgICAgICAgd2lkdGg6IDIyJTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJvdHRvbTogMXB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHBhZGRpbmc6IDNweCAycHggMDtcbiAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgLyogLnN0ZXBzX2VkaXQ6ZW1wdHk6YmVmb3JlIHtcbiAgICAgICAgY29udGVudDogYXR0cihkYXRhLXRleHQpLFxuICAgICAgICBjb250ZW50LWVkaXRhYmxlOmZhbHNlO1xuICAgIH0gKi9cblxuICAgIC5maXhlZF9hbnMge1xuICAgICAgICB0b3A6IDEwcHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZTBlMGUwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNWY1O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgZm9udC1zaXplOiAxNXB4O1xuICAgICAgICBmb250LXdlaWdodDogNzAwO1xuICAgIH1cblxuICAgIC5jaGVja19ib3gge1xuICAgICAgICByaWdodDogMjRweDtcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgIH1cblxuICAgIC5pbm5lcl9pbnB1dHMge1xuICAgICAgICBtYXJnaW46IDAgMTJweCFpbXBvcnRhbnQ7XG4gICAgfSAgICAgIFxuICAgIFxuICAgIC5wb2ludGVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLndpZHRoMTAwIHt3aWR0aDogMTAwcHg7fVxuXG4gICAgLyogLmVkaXRfc3RlcHMge1xuICAgICAgICBtYXJnaW4tdG9wOiAxMXB4IWltcG9ydGFudDtcbiAgICB9XG4gICAgLnZpZXdfY2hlY2tib3gge1xuICAgICAgICBoZWlnaHQ6IDc1cHg7XG4gICAgfVxuICAgIC5wbGFpbl90ZXh0IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBib3R0b206IDIwcHg7XG4gICAgfSAqL1xuXG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0pIHtcbiAgICAgICAgb3ZlcmZsb3c6aGlkZGVuO1xuICAgICAgICAvKndpZHRoOjcwMHB4OyAgdGVzdGluZyovXG4gICAgICAgIHRleHQtYWxpZ246bGVmdDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gcHJlKSB7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4IWltcG9ydGFudDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLnN0cmluZykge1xuICAgICAgICBtaW4taGVpZ2h0OjUwcHg7XG4gICAgICAgIG1hcmdpbi10b3A6MTBweDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OjEwcHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5mb290ZXJzdHIpIHtcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNjY2M7XG4gICAgICAgIHBhZGRpbmc6IDE1cHg7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDYwcHg7LyoxMDBweDsqL1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZm9vdGVyc3RyIC5hcnJvdy11cCkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTEwcHg7XG4gICAgICAgIHJpZ2h0OiA1MCU7XG4gICAgICAgIHdpZHRoOiAwO1xuICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIGJvcmRlci1sZWZ0OiAxMHB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXItcmlnaHQ6IDEwcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDEwcHggc29saWQgI2NjYztcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLmZpbGwtcm93KSB7XG4gICAgICAgIHBhZGRpbmc6NnB4O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZmlsbGVsZW1lbnQsIFtpZF49XCJmaWxsbWFpblwiXSAuZHJhZy1yZXNpemUpIHtcbiAgICAgICAgaGVpZ2h0OjMwcHg7XG4gICAgICAgIGRpc3BsYXk6aW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICAgICAgbWluLWhlaWdodDogMzBweDtcbiAgICAgICAgbWFyZ2luOiAxcHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIGlucHV0W3R5cGU9XCJ0ZXh0XCJdLCBbaWRePVwiZmlsbG1haW5cIl0gc2VsZWN0KSB7XHRcbiAgICAgICAgaGVpZ2h0Ojk5JSFpbXBvcnRhbnQ7XG4gICAgICAgIHJlc2l6ZTogbm9uZTtcbiAgICAgICAgZm9udC1zaXplOjEycHg7XG4gICAgICAgIGNvbG9yOiAjMDAwO1xuICAgICAgICBtYXgtd2lkdGg6IDgwMHB4O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZHJhZy1yZXNpemUpIHtcbiAgICAgICAgdmVydGljYWwtYWxpZ246bWlkZGxlO1xuICAgICAgICBib3JkZXI6MXB4IHNvbGlkICMzMUI3MzE7XG4gICAgICAgIHRleHQtYWxpZ246Y2VudGVyO1xuICAgICAgICBwYWRkaW5nOjNweDtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZHJhZy1yZXNpemUudWktZHJhZ2dhYmxlKSB7XG4gICAgICAgIGN1cnNvcjptb3ZlO1xuICAgIH1cbiAgICA6Z2xvYmFsKFtpZF49XCJmaWxsbWFpblwiXSAuZHJvcC1ob3Zlcikge1xuICAgICAgICBib3JkZXI6IDFweCBkYXNoZWQgcmVkIWltcG9ydGFudDtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMnB4IHllbGxvdyBpbnNldDtcbiAgICAgICAgb3V0bGluZTogMXB4IHNvbGlkIGJsdWU7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5maWxsY2hlY2sgdWwpIHtcbiAgICAgICAgd2lkdGg6MjIwcHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC5maWxsY2hlY2sgbGkuc2VsZWN0ZWQpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0U1RTVFNTtcbiAgICB9XG4gICAgOmdsb2JhbCguZmlsbGNoZWNrIC5zZWxlY3RlZCAuaWNvbW9vbi1jaGVja21hcmstMzpiZWZvcmUpIHtcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIGNvbG9yOiBibHVlO1xuICAgICAgICBwYWRkaW5nOiAzcHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcmlnaHQ6IDE0cHg7XG4gICAgfVxuICAgIDpnbG9iYWwoLmZpbGxjaGVjayAuaWNvbW9vbi1jbG9zZS0yOmJlZm9yZSkge1xuICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcmlnaHQ6IDE0cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICB9XG4gICAgOmdsb2JhbCguTWF0aEpheF9EaXNwbGF5KSB7XG4gICAgICAgICAgICBkaXNwbGF5IDogaW5saW5lIWltcG9ydGFudDtcbiAgICB9XG4gICAgOmdsb2JhbChbaWRePVwiZmlsbG1haW5cIl0gLnNlbGVjdCkge1xuICAgICAgICBmb250LXNpemU6IDE1cHg7XG4gICAgfVxuICAgIDpnbG9iYWwoW2lkXj1cImZpbGxtYWluXCJdIC50ZXh0YXJlYSkge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6M3B4O1xuICAgICAgICBiYWNrZ3JvdW5kOiNmZmU7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG4gICAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsMC4wNzUpO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwwLjA3NSk7XG4gICAgfVxuICAgIDpnbG9iYWwoLnVpLWRyYWdnYWJsZS1kaXNhYmxlZCkge1xuICAgICAgICBjdXJzb3I6IG5vLWRyb3AhaW1wb3J0YW50O1xuICAgICAgICBvcGFjaXR5OiAwLjUhaW1wb3J0YW50O1xuICAgIH1cbiAgICAgICAgICAgICAgICBcbjwvc3R5bGU+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTh2QkksT0FBTyxjQUFDLENBQUMsQUFDTCxTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBQ0QsT0FBTyxjQUFHLENBQUMsQUFDUCxLQUFLLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxjQUFjLGNBQUMsQ0FBQyxBQUNaLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsS0FBSyxDQUFFLElBQUksQUFDZixDQUFDLEFBRUQsS0FBSyxjQUFDLENBQUMsQUFDSCxHQUFHLENBQUUsR0FBRyxBQUNaLENBQUMsQUFDRCxPQUFPLGNBQUMsQ0FBQyxBQUNMLEtBQUssQ0FBRSxHQUFHLEFBQ2QsQ0FBQyxBQUVELFFBQVEsY0FBQyxDQUFDLEFBQ04sS0FBSyxDQUFFLElBQUksQUFDZixDQUFDLEFBRUQsY0FBYyxjQUFDLENBQUMsQUFDWixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FDdkIsV0FBVyxDQUFFLElBQUksQ0FDakIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLEdBQUcsQ0FDWCxNQUFNLENBQUUsT0FBTyxDQUNmLE9BQU8sQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQUFDdEIsQ0FBQyxBQU9ELFVBQVUsY0FBQyxDQUFDLEFBQ1IsR0FBRyxDQUFFLElBQUksQ0FDVCxRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsS0FBSyxDQUNaLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDekIsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixhQUFhLENBQUUsR0FBRyxDQUNsQixPQUFPLENBQUUsR0FBRyxDQUNaLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLEdBQUcsQUFDcEIsQ0FBQyxBQUVELFVBQVUsY0FBQyxDQUFDLEFBQ1IsS0FBSyxDQUFFLElBQUksQ0FDWCxTQUFTLFFBQVEsQ0FDakIsS0FBSyxDQUFFLElBQUksQUFDZixDQUFDLEFBRUQsYUFBYSxjQUFDLENBQUMsQUFDWCxNQUFNLENBQUUsQ0FBQyxDQUFDLElBQUksVUFBVSxBQUM1QixDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDTixNQUFNLENBQUUsT0FBTyxDQUFDLFVBQVUsQUFDOUIsQ0FBQyxBQUVELFNBQVMsY0FBQyxDQUFDLEtBQUssQ0FBRSxLQUFLLEFBQUMsQ0FBQyxBQWFqQixnQkFBZ0IsQUFBRSxDQUFDLEFBQ3ZCLFNBQVMsTUFBTSxDQUVmLFdBQVcsSUFBSSxBQUNuQixDQUFDLEFBQ08sb0JBQW9CLEFBQUUsQ0FBQyxBQUMzQixVQUFVLENBQUUsSUFBSSxDQUNoQixNQUFNLENBQUUsSUFBSSxDQUNaLFNBQVMsQ0FBRSxJQUFJLFVBQVUsQUFDN0IsQ0FBQyxBQUNPLHdCQUF3QixBQUFFLENBQUMsQUFDL0IsV0FBVyxJQUFJLENBQ2YsV0FBVyxJQUFJLENBQ2YsYUFBYSxJQUFJLEFBQ3JCLENBQUMsQUFDTywyQkFBMkIsQUFBRSxDQUFDLEFBQ2xDLFNBQVMsUUFBUSxDQUNqQixVQUFVLENBQUUsSUFBSSxDQUNoQixnQkFBZ0IsQ0FBRSxJQUFJLENBQ3RCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLElBQUksQUFDcEIsQ0FBQyxBQUNPLHFDQUFxQyxBQUFFLENBQUMsQUFDNUMsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLEtBQUssQ0FDVixLQUFLLENBQUUsR0FBRyxDQUNWLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxXQUFXLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQ25DLFlBQVksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FDcEMsYUFBYSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUNsQyxDQUFDLEFBQ08sMEJBQTBCLEFBQUUsQ0FBQyxBQUNqQyxRQUFRLEdBQUcsQUFDZixDQUFDLEFBQ08sNERBQTRELEFBQUUsQ0FBQyxBQUNuRSxPQUFPLElBQUksQ0FDWCxRQUFRLFlBQVksQ0FDcEIsU0FBUyxRQUFRLENBQ2pCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxHQUFHLEFBQ2YsQ0FBQyxBQUNPLDREQUE0RCxBQUFFLENBQUMsQUFDbkUsT0FBTyxHQUFHLFVBQVUsQ0FDcEIsTUFBTSxDQUFFLElBQUksQ0FDWixVQUFVLElBQUksQ0FDZCxLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxLQUFLLEFBQ3BCLENBQUMsQUFDTyw2QkFBNkIsQUFBRSxDQUFDLEFBQ3BDLGVBQWUsTUFBTSxDQUNyQixPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUN4QixXQUFXLE1BQU0sQ0FDakIsUUFBUSxHQUFHLENBQ1gsU0FBUyxDQUFFLElBQUksQUFDbkIsQ0FBQyxBQUNPLDBDQUEwQyxBQUFFLENBQUMsQUFDakQsT0FBTyxJQUFJLEFBQ2YsQ0FBQyxBQUNPLDRCQUE0QixBQUFFLENBQUMsQUFDbkMsTUFBTSxDQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxVQUFVLENBQ2hDLFVBQVUsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FDbEMsT0FBTyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUMzQixDQUFDLEFBQ08sOEJBQThCLEFBQUUsQ0FBQyxBQUNyQyxNQUFNLEtBQUssQUFDZixDQUFDLEFBQ08sdUNBQXVDLEFBQUUsQ0FBQyxBQUM5QyxnQkFBZ0IsQ0FBRSxPQUFPLEFBQzdCLENBQUMsQUFDTyxnREFBZ0QsQUFBRSxDQUFDLEFBQ3ZELEtBQUssQ0FBRSxJQUFJLENBQ1gsS0FBSyxDQUFFLElBQUksQ0FDWCxPQUFPLENBQUUsR0FBRyxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUNPLGtDQUFrQyxBQUFFLENBQUMsQUFDekMsS0FBSyxDQUFFLElBQUksQ0FDWCxLQUFLLENBQUUsSUFBSSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsU0FBUyxDQUFFLElBQUksQUFDbkIsQ0FBQyxBQUNPLGdCQUFnQixBQUFFLENBQUMsQUFDbkIsT0FBTyxDQUFHLE1BQU0sVUFBVSxBQUNsQyxDQUFDLEFBQ08sd0JBQXdCLEFBQUUsQ0FBQyxBQUMvQixTQUFTLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBQ08sMEJBQTBCLEFBQUUsQ0FBQyxBQUNqQyxlQUFlLE1BQU0sQ0FDckIsY0FBYyxHQUFHLENBQ2pCLFdBQVcsSUFBSSxDQUNmLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDdEIsa0JBQWtCLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQ3JELFVBQVUsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQUFDakQsQ0FBQyxBQUNPLHNCQUFzQixBQUFFLENBQUMsQUFDN0IsTUFBTSxDQUFFLE9BQU8sVUFBVSxDQUN6QixPQUFPLENBQUUsR0FBRyxVQUFVLEFBQzFCLENBQUMifQ== */";
	append_dev(document_1.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

// (568:20) <Checkbox                           id="go_next"                          defaultChecked = {state.gonext ? true: false}                          on:click={(e)=>{goNext("go_next",e)}}                      >
function create_default_slot_8(ctx) {
	let t_value = "Go Next" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(568:20) <Checkbox                           id=\\\"go_next\\\"                          defaultChecked = {state.gonext ? true: false}                          on:click={(e)=>{goNext(\\\"go_next\\\",e)}}                      >",
		ctx
	});

	return block;
}

// (576:20) <Checkbox                           id="fixedans_checkbox"                          defaultChecked = {state.variable_button ? true: false}                          on:click={(e)=>{fixedAnswer("fixedans_checkbox",e)}}                      >
function create_default_slot_7(ctx) {
	let t_value = "Fix Answer" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(576:20) <Checkbox                           id=\\\"fixedans_checkbox\\\"                          defaultChecked = {state.variable_button ? true: false}                          on:click={(e)=>{fixedAnswer(\\\"fixedans_checkbox\\\",e)}}                      >",
		ctx
	});

	return block;
}

// (625:32) {:else}
function create_else_block_2(ctx) {
	let checkbox;
	let current;

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[23](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: false
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_3);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(625:32) {:else}",
		ctx
	});

	return block;
}

// (622:32) {#if item._mode == "1"}
function create_if_block_3(ctx) {
	let checkbox;
	let current;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[22](/*index*/ ctx[40], ...args);
	}

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "mode",
				name: "mode_checkbox_",
				id: `mode_checkbox_${/*index*/ ctx[40]}`,
				checked: true
			},
			$$inline: true
		});

	checkbox.$on("click", click_handler_2);

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(622:32) {#if item._mode == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (634:24) {#if index == 0}
function create_if_block_1(ctx) {
	let div;
	let span;
	let current_block_type_index;
	let if_block;
	let t0;
	let label;
	let label_for_value;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[38]._sticky == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if_block.c();
			t0 = space();
			label = element("label");
			label.textContent = `${language.sticky}`;
			attr_dev(span, "class", "check_box d-inline-block svelte-smsdwz");
			add_location(span, file, 635, 32, 24558);
			attr_dev(label, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-smsdwz");
			attr_dev(label, "for", label_for_value = `sticky_checkbox_${/*index*/ ctx[40]}`);
			add_location(label, file, 644, 32, 25449);
			attr_dev(div, "class", "stick_checkbox d-inline-block");
			add_location(div, file, 634, 28, 24482);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			if_blocks[current_block_type_index].m(span, null);
			append_dev(div, t0);
			append_dev(div, label);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(span, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(634:24) {#if index == 0}",
		ctx
	});

	return block;
}

// (641:36) {:else}
function create_else_block_1(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: false,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], "fillAuthor_" + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(641:36) {:else}",
		ctx
	});

	return block;
}

// (639:36) {#if item._sticky == "1"}
function create_if_block_2(ctx) {
	let checkbox;
	let current;

	checkbox = new Checkbox({
			props: {
				"data-seq": /*index*/ ctx[40],
				checked: true,
				class: "inner_inputs option_checkbox",
				type: "checkbox",
				value: "sticky",
				name: "sticky_checkbox_",
				id: `sticky_checkbox_${/*index*/ ctx[40]}`
			},
			$$inline: true
		});

	checkbox.$on("click", /*handleChangeCheckbox*/ ctx[4].bind(this, /*index*/ ctx[40], "fillAuthor_" + /*index*/ ctx[40]));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(639:36) {#if item._sticky == \\\"1\\\"}",
		ctx
	});

	return block;
}

// (587:12) {#each all_steps as item,index}
function create_each_block(ctx) {
	let fieldset;
	let legend;
	let t0_value = /*index*/ ctx[40] + 1 + "";
	let t0;
	let legend_style_value;
	let t1;
	let div1;
	let div0;
	let raw_value = /*item*/ ctx[38].__cdata + "";
	let div0_data_seq_value;
	let div0_id_value;
	let div0_style_value;
	let div0_contenteditable_value;
	let div1_style_value;
	let t2;
	let div8;
	let div2;
	let span0;
	let span0_for_value;
	let t4;
	let span2;
	let span1;
	let input;
	let input_checked_value;
	let t5;
	let label0;
	let span2_style_value;
	let t7;
	let div4;
	let div3;
	let span3;
	let current_block_type_index;
	let if_block0;
	let t8;
	let label1;
	let label1_for_value;
	let t10;
	let t11;
	let div7;
	let div5;
	let button0;
	let div5_style_value;
	let t13;
	let div6;
	let button1;
	let button1_id_value;
	let div6_style_value;
	let div7_style_value;
	let fieldset_key_value;
	let fieldset_style_value;
	let t15;
	let current;
	let mounted;
	let dispose;

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[20](/*index*/ ctx[40], ...args);
	}

	function change_handler(...args) {
		return /*change_handler*/ ctx[21](/*index*/ ctx[40], ...args);
	}

	const if_block_creators = [create_if_block_3, create_else_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[38]._mode == "1") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*index*/ ctx[40] == 0 && create_if_block_1(ctx);

	function click_handler_4(...args) {
		return /*click_handler_4*/ ctx[24](/*index*/ ctx[40], ...args);
	}

	function click_handler_5(...args) {
		return /*click_handler_5*/ ctx[25](/*index*/ ctx[40], ...args);
	}

	const block = {
		c: function create() {
			fieldset = element("fieldset");
			legend = element("legend");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			t2 = space();
			div8 = element("div");
			div2 = element("div");
			span0 = element("span");
			span0.textContent = `${language.plain_text}`;
			t4 = space();
			span2 = element("span");
			span1 = element("span");
			input = element("input");
			t5 = space();
			label0 = element("label");
			label0.textContent = `${language.interactive}`;
			t7 = space();
			div4 = element("div");
			div3 = element("div");
			span3 = element("span");
			if_block0.c();
			t8 = space();
			label1 = element("label");
			label1.textContent = `${language.no_validation}`;
			t10 = space();
			if (if_block1) if_block1.c();
			t11 = space();
			div7 = element("div");
			div5 = element("div");
			button0 = element("button");
			button0.textContent = `${language.delete}`;
			t13 = space();
			div6 = element("div");
			button1 = element("button");
			button1.textContent = `${language.save}`;
			t15 = space();
			attr_dev(legend, "class", "font18 mb ms-2 pl-1 svelte-smsdwz");
			attr_dev(legend, "style", legend_style_value = "width:1em;float:none;");
			add_location(legend, file, 588, 20, 21241);
			attr_dev(div0, "data-seq", div0_data_seq_value = /*index*/ ctx[40]);
			attr_dev(div0, "class", "tinymce-editor-res steps_edit p-1 border fillAuthor");
			attr_dev(div0, "id", div0_id_value = `fillAuthor_${/*index*/ ctx[40]}`);
			attr_dev(div0, "style", div0_style_value = "padding:0 8px;overflow:auto;outline:none");
			attr_dev(div0, "contenteditable", div0_contenteditable_value = true);
			attr_dev(div0, "data-text", "Enter text here");
			add_location(div0, file, 590, 24, 21454);
			attr_dev(div1, "class", "d-inline-block table_width ms-2 pl-1 pb-2 mb-1");
			attr_dev(div1, "style", div1_style_value = "width:97%;");
			add_location(div1, file, 589, 20, 21348);
			attr_dev(span0, "class", "pointer d-inline-block plain_text svelte-smsdwz");
			attr_dev(span0, "data-toggle", "tooltip");
			attr_dev(span0, "title", "Don't use any interactive item!");
			attr_dev(span0, "for", span0_for_value = `viewonly_radio_${/*index*/ ctx[40]}`);
			add_location(span0, file, 604, 24, 22217);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "form-check-input");
			attr_dev(input, "id", "switchElement");
			input.checked = input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true;
			attr_dev(input, "color", "primary");
			add_location(input, file, 607, 32, 22586);
			attr_dev(label0, "for", "switchElement");
			add_location(label0, file, 612, 32, 22948);
			attr_dev(span1, "class", "form-check form-switch");
			add_location(span1, file, 606, 28, 22516);
			attr_dev(span2, "class", "stat-percent ms-4");
			attr_dev(span2, "style", span2_style_value = "display:inline-block;position:relative;");
			add_location(span2, file, 605, 24, 22405);
			attr_dev(div2, "class", "test d-inline-block");
			add_location(div2, file, 603, 20, 22159);
			attr_dev(span3, "class", "check_box d-inline-block svelte-smsdwz");
			add_location(span3, file, 619, 28, 23295);
			attr_dev(label1, "class", "font-weight-normal me-1 position-relative top2 right35 svelte-smsdwz");
			attr_dev(label1, "for", label1_for_value = `mode_checkbox_${/*index*/ ctx[40]}`);
			add_location(label1, file, 630, 28, 24207);
			attr_dev(div3, "class", "modes_checkbox d-inline-block ms-2");
			add_location(div3, file, 618, 24, 23218);
			attr_dev(div4, "class", "d-inline-block plain_text ms-3");
			add_location(div4, file, 617, 20, 23148);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn btn-light font12");
			add_location(button0, file, 650, 28, 25925);
			attr_dev(div5, "class", "d-inline-block mr");
			attr_dev(div5, "style", div5_style_value = "display:inline-block;");
			add_location(div5, file, 649, 24, 25785);
			attr_dev(button1, "id", button1_id_value = `save_step_${/*index*/ ctx[40]}`);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "btn btn-primary font12 save_button_steps");
			add_location(button1, file, 653, 28, 26152);
			attr_dev(div6, "class", "d-inline-block");
			attr_dev(div6, "style", div6_style_value = "text-align:right;margin-top:6px;");
			add_location(div6, file, 652, 24, 26052);
			attr_dev(div7, "style", div7_style_value = "display:inline-block;float:right;");
			attr_dev(div7, "class", "buttons edit_steps");
			add_location(div7, file, 648, 20, 25684);
			attr_dev(div8, "class", "view_checkbox d-inline-block light-cyan-bg px-2 p-1 full-width fwidth svelte-smsdwz");
			add_location(div8, file, 602, 20, 22055);
			attr_dev(fieldset, "key", fieldset_key_value = /*index*/ ctx[40]);
			attr_dev(fieldset, "style", fieldset_style_value = "border:1px solid grey");
			attr_dev(fieldset, "class", "new_steps seq_inbox fw shadow-sm mb-2");
			add_location(fieldset, file, 587, 16, 21120);
		},
		m: function mount(target, anchor) {
			insert_dev(target, fieldset, anchor);
			append_dev(fieldset, legend);
			append_dev(legend, t0);
			append_dev(fieldset, t1);
			append_dev(fieldset, div1);
			append_dev(div1, div0);
			div0.innerHTML = raw_value;
			append_dev(fieldset, t2);
			append_dev(fieldset, div8);
			append_dev(div8, div2);
			append_dev(div2, span0);
			append_dev(div2, t4);
			append_dev(div2, span2);
			append_dev(span2, span1);
			append_dev(span1, input);
			append_dev(span1, t5);
			append_dev(span1, label0);
			append_dev(div8, t7);
			append_dev(div8, div4);
			append_dev(div4, div3);
			append_dev(div3, span3);
			if_blocks[current_block_type_index].m(span3, null);
			append_dev(div3, t8);
			append_dev(div3, label1);
			append_dev(div4, t10);
			if (if_block1) if_block1.m(div4, null);
			append_dev(div8, t11);
			append_dev(div8, div7);
			append_dev(div7, div5);
			append_dev(div5, button0);
			append_dev(div7, t13);
			append_dev(div7, div6);
			append_dev(div6, button1);
			insert_dev(target, t15, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "keyup", keyup_handler, false, false, false),
					listen_dev(input, "change", change_handler, false, false, false),
					listen_dev(div5, "click", click_handler_4, false, false, false),
					listen_dev(button1, "click", click_handler_5, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*all_steps*/ 2) && raw_value !== (raw_value = /*item*/ ctx[38].__cdata + "")) div0.innerHTML = raw_value;
			if (!current || dirty[0] & /*all_steps*/ 2 && input_checked_value !== (input_checked_value = /*item*/ ctx[38].toggle == "1" ? false : true)) {
				prop_dev(input, "checked", input_checked_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(span3, null);
			}

			if (/*index*/ ctx[40] == 0) if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(fieldset);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t15);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(587:12) {#each all_steps as item,index}",
		ctx
	});

	return block;
}

// (663:12) <Button variant="fab" color="primary" mini aria-label="Add"                 on:click={addEvent.bind(this, 'steps')}                 class="btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30"                 style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>
function create_default_slot_6(ctx) {
	let span;
	let t1;

	const block = {
		c: function create() {
			span = element("span");
			span.textContent = "+  ";
			t1 = text(" Add Step");
			attr_dev(span, "class", "font18 svelte-smsdwz");
			add_location(span, file, 666, 16, 26915);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			insert_dev(target, t1, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(663:12) <Button variant=\\\"fab\\\" color=\\\"primary\\\" mini aria-label=\\\"Add\\\"                 on:click={addEvent.bind(this, 'steps')}                 class=\\\"btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30\\\"                 style={'float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;'}>",
		ctx
	});

	return block;
}

// (676:20) <div slot="title">
function create_title_slot(ctx) {
	let div0;
	let div1;
	let div1_style_value;
	let t1;
	let div3;
	let div2;
	let button0;
	let t2;
	let button0_class_value;
	let button0_value_value;
	let t3;
	let button1;
	let t4;
	let button1_class_value;
	let button1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div0 = element("div");
			div1 = element("div");
			div1.textContent = `${language.fill_header}`;
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			button0 = element("button");
			t2 = text("Text");
			t3 = space();
			button1 = element("button");
			t4 = text("Mathematical Equation");
			attr_dev(div1, "class", "mr-lg float-left");
			attr_dev(div1, "style", div1_style_value = "padding-top:10px;padding-left:13px;font-size:18px;");
			add_location(div1, file, 676, 24, 27449);
			attr_dev(button0, "type", "button");

			attr_dev(button0, "class", button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-smsdwz"));

			button0.value = button0_value_value = 1;
			add_location(button0, file, 680, 8, 27695);
			attr_dev(button1, "type", "button");

			attr_dev(button1, "class", button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-smsdwz"));

			button1.value = button1_value_value = 2;
			add_location(button1, file, 681, 8, 27872);
			attr_dev(div2, "class", "btn-group mt-1 row ml-0");
			add_location(div2, file, 679, 7, 27649);
			attr_dev(div3, "class", "float-right mr-4");
			add_location(div3, file, 678, 24, 27611);
			attr_dev(div0, "slot", "title");
			add_location(div0, file, 675, 20, 27406);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, div1);
			append_dev(div0, t1);
			append_dev(div0, div3);
			append_dev(div3, div2);
			append_dev(div2, button0);
			append_dev(button0, t2);
			append_dev(div2, t3);
			append_dev(div2, button1);
			append_dev(button1, t4);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*updateDialog*/ ctx[11].bind(this, 1), false, false, false),
					listen_dev(button1, "click", /*updateDialog*/ ctx[11].bind(this, 2), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 1 && button0_class_value !== (button0_class_value = "" + (null_to_empty("btn btn-light col-3" + (/*state*/ ctx[0].fillInTheBlanksChoice == 1
			? " active"
			: "")) + " svelte-smsdwz"))) {
				attr_dev(button0, "class", button0_class_value);
			}

			if (dirty[0] & /*state*/ 1 && button1_class_value !== (button1_class_value = "" + (null_to_empty("btn btn-light col-9" + (/*state*/ ctx[0].fillInTheBlanksChoice == 2
			? " active"
			: "")) + " svelte-smsdwz"))) {
				attr_dev(button1, "class", button1_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_title_slot.name,
		type: "slot",
		source: "(676:20) <div slot=\\\"title\\\">",
		ctx
	});

	return block;
}

// (710:28) {:else}
function create_else_block(ctx) {
	let div5;
	let div1;
	let input;
	let input_id_value;
	let input_style_value;
	let input_auto_focus_value;
	let t0;
	let button0;
	let t1;
	let div0;
	let button1;
	let t2;
	let div2;
	let t4;
	let div3;
	let div3_style_value;
	let t6;
	let div4;
	let div4_style_value;
	let current;

	button0 = new Button({
			props: {
				variant: "contained",
				color: "primary",
				style: "border:1px solid #4285f4;color:#4285f4;text-transform:none;",
				class: "btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", addEditable);

	button1 = new Button({
			props: {
				id: "latexEdit",
				variant: "contained",
				color: "primary",
				style: "margin:5px;display:none;",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*latexEdit*/ ctx[12]);

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			input = element("input");
			t0 = space();
			create_component(button0.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(button1.$$.fragment);
			t2 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t4 = space();
			div3 = element("div");
			div3.textContent = `${language.fill_math_help1}`;
			t6 = space();
			div4 = element("div");
			div4.textContent = `${language.fill_math_help2}`;
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = "input");
			attr_dev(input, "class", "latexInp form-control");
			attr_dev(input, "style", input_style_value = "margin:5px;width:71%;");
			attr_dev(input, "auto:focus", input_auto_focus_value = true);
			add_location(input, file, 712, 40, 29920);
			attr_dev(div0, "class", "latexEditButton d-inline-block");
			add_location(div0, file, 729, 40, 31059);
			attr_dev(div1, "class", "d-flex");
			add_location(div1, file, 711, 36, 29859);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-1");
			add_location(div2, file, 741, 36, 31830);
			attr_dev(div3, "class", "text-danger ml-1");
			attr_dev(div3, "style", div3_style_value = "text-indent: 15px;");
			add_location(div3, file, 742, 36, 31927);
			attr_dev(div4, "class", "text-danger ml-1");
			attr_dev(div4, "style", div4_style_value = "text-indent: 15px;");
			add_location(div4, file, 743, 36, 32048);
			add_location(div5, file, 710, 32, 29817);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, input);
			append_dev(div1, t0);
			mount_component(button0, div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);
			mount_component(button1, div0, null);
			append_dev(div5, t2);
			append_dev(div5, div2);
			append_dev(div5, t4);
			append_dev(div5, div3);
			append_dev(div5, t6);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(710:28) {:else}",
		ctx
	});

	return block;
}

// (689:28) {#if state.fillInTheBlanksChoice == 1}
function create_if_block(ctx) {
	let div5;
	let div1;
	let div0;
	let checkbox;
	let t0;
	let input;
	let input_value_value;
	let input_style_value;
	let input_auto_focus_value;
	let input_placeholder_value;
	let t1;
	let div2;
	let t3;
	let div3;
	let div3_style_value;
	let t5;
	let div4;
	let div4_style_value;
	let current;

	checkbox = new Checkbox({
			props: {
				id: "numeric",
				checked: /*state*/ ctx[0].numeric,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");
			create_component(checkbox.$$.fragment);
			t0 = space();
			input = element("input");
			t1 = space();
			div2 = element("div");
			div2.textContent = "* Note:";
			t3 = space();
			div3 = element("div");
			div3.textContent = `${language.fill_text_help1}`;
			t5 = space();
			div4 = element("div");
			div4.textContent = "2. Please do not include space.";
			attr_dev(div0, "class", "width100 svelte-smsdwz");
			add_location(div0, file, 691, 40, 28439);
			attr_dev(input, "type", "text");
			attr_dev(input, "id", "input1");
			input.value = input_value_value = /*state*/ ctx[0].input_ans;
			attr_dev(input, "class", "form-control mr-4 ml-3");
			attr_dev(input, "style", input_style_value = "margin:5px");
			attr_dev(input, "auto:focus", input_auto_focus_value = true);

			attr_dev(input, "placeholder", input_placeholder_value = AH.select("#input1").innerHTML != ""
			? language.fill_text_placeholder
			: "");

			add_location(input, file, 695, 44, 28717);
			attr_dev(div1, "class", "d-flex mr-2");
			add_location(div1, file, 690, 36, 28373);
			attr_dev(div2, "class", "text-danger font-weight-bold ml-2 mt-3");
			add_location(div2, file, 705, 36, 29394);
			attr_dev(div3, "class", "text-danger ml-2");
			attr_dev(div3, "style", div3_style_value = "text-indent:15px");
			add_location(div3, file, 706, 36, 29496);
			attr_dev(div4, "class", "text-danger ml-2");
			attr_dev(div4, "style", div4_style_value = "text-indent:15px");
			add_location(div4, file, 707, 36, 29615);
			add_location(div5, file, 689, 32, 28331);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div1);
			append_dev(div1, div0);
			mount_component(checkbox, div0, null);
			append_dev(div1, t0);
			append_dev(div1, input);
			append_dev(div5, t1);
			append_dev(div5, div2);
			append_dev(div5, t3);
			append_dev(div5, div3);
			append_dev(div5, t5);
			append_dev(div5, div4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox_changes.checked = /*state*/ ctx[0].numeric;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox_changes.$$scope = { dirty, ctx };
			}

			checkbox.$set(checkbox_changes);

			if (!current || dirty[0] & /*state*/ 1 && input_value_value !== (input_value_value = /*state*/ ctx[0].input_ans) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
			destroy_component(checkbox);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(689:28) {#if state.fillInTheBlanksChoice == 1}",
		ctx
	});

	return block;
}

// (721:40) <Button                                              variant = "contained"                                              color = "primary"                                             style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                              on:click = {addEditable}                                             class="btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1"                                         >
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Add Response");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(721:40) <Button                                              variant = \\\"contained\\\"                                              color = \\\"primary\\\"                                             style = {'border:1px solid #4285f4;color:#4285f4;text-transform:none;'}                                              on:click = {addEditable}                                             class=\\\"btn btn-outline-primary height30 bg-white shadow-sm mt-1 top1 ml-1\\\"                                         >",
		ctx
	});

	return block;
}

// (731:44) <Button                                                  id = {"latexEdit"}                                                 variant = "contained"                                                  color = "primary"                                                 style = {'margin:5px;display:none;'}                                                  on:click = {latexEdit}                                                                                >
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(731:44) <Button                                                  id = {\\\"latexEdit\\\"}                                                 variant = \\\"contained\\\"                                                  color = \\\"primary\\\"                                                 style = {'margin:5px;display:none;'}                                                  on:click = {latexEdit}                                                                                >",
		ctx
	});

	return block;
}

// (693:44) <Checkbox  id = "numeric" checked = {state.numeric}>
function create_default_slot_3(ctx) {
	let t_value = "Numeric" + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(693:44) <Checkbox  id = \\\"numeric\\\" checked = {state.numeric}>",
		ctx
	});

	return block;
}

// (752:24) <Button variant="contained" on:click={handleClose} >
function create_default_slot_2(ctx) {
	let t0_value = language.cancel + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(752:24) <Button variant=\\\"contained\\\" on:click={handleClose} >",
		ctx
	});

	return block;
}

// (755:24) <Button variant="contained" on:click={storeAns}                             class="bg-primary text-white">
function create_default_slot_1(ctx) {
	let t_value = language.done + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(755:24) <Button variant=\\\"contained\\\" on:click={storeAns}                             class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (670:8) <Dialog overlayClass="materialOverlay"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width="650" class="row" style={'background-color: #fff;'}>
function create_default_slot(ctx) {
	let t0;
	let div1;
	let div0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div2;
	let button0;
	let t2;
	let button1;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*state*/ ctx[0].fillInTheBlanksChoice == 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button0 = new Button({
			props: {
				variant: "contained",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*handleClose*/ ctx[10]);

	button1 = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*storeAns*/ ctx[13]);

	const block = {
		c: function create() {
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			t1 = space();
			div2 = element("div");
			create_component(button0.$$.fragment);
			t2 = text(",\n                        ");
			create_component(button1.$$.fragment);
			attr_dev(div0, "id", "responseDialog");
			add_location(div0, file, 687, 24, 28206);
			add_location(div1, file, 686, 20, 28176);
			attr_dev(div2, "class", "svelteFooter");
			add_location(div2, file, 750, 20, 32290);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if_blocks[current_block_type_index].m(div0, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
			mount_component(button0, div2, null);
			append_dev(div2, t2);
			mount_component(button1, div2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			const button0_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			if_blocks[current_block_type_index].d();
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(670:8) <Dialog overlayClass=\\\"materialOverlay\\\"  bind:visible={state.open} on:close={handleClose.bind(this)} disableEnforceFocus={true} width=\\\"650\\\" class=\\\"row\\\" style={'background-color: #fff;'}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div7;
	let div4;
	let div0;
	let div0_style_value;
	let t1;
	let div3;
	let div1;
	let checkbox0;
	let t2;
	let div2;
	let checkbox1;
	let div3_style_value;
	let t3;
	let div5;
	let t4;
	let div6;
	let button;
	let t5;
	let dialog;
	let updating_visible;
	let current;

	checkbox0 = new Checkbox({
			props: {
				id: "go_next",
				defaultChecked: /*state*/ ctx[0].gonext ? true : false,
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox0.$on("click", /*click_handler*/ ctx[18]);

	checkbox1 = new Checkbox({
			props: {
				id: "fixedans_checkbox",
				defaultChecked: /*state*/ ctx[0].variable_button ? true : false,
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	checkbox1.$on("click", /*click_handler_1*/ ctx[19]);
	let each_value = /*all_steps*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	button = new Button({
			props: {
				variant: "fab",
				color: "primary",
				mini: true,
				"aria-label": "Add",
				class: "btn btn-outline-primary rounded position-relative bottom0 bg-white shadow-sm height30",
				style: "float:left;width:120px;height:30px;border:1px solid #4285f4;color:#4285f4;text-transform:none;",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*addEvent*/ ctx[9].bind(this, "steps"));

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[26].call(null, value);
	}

	let dialog_props = {
		overlayClass: "materialOverlay",
		disableEnforceFocus: true,
		width: "650",
		class: "row",
		style: "background-color: #fff;",
		$$slots: {
			default: [create_default_slot],
			title: [create_title_slot]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].open !== void 0) {
		dialog_props.visible = /*state*/ ctx[0].open;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
	dialog.$on("close", /*handleClose*/ ctx[10].bind(this));

	const block = {
		c: function create() {
			main = element("main");
			div7 = element("div");
			div4 = element("div");
			div0 = element("div");
			div0.textContent = `${language.create_steps}`;
			t1 = space();
			div3 = element("div");
			div1 = element("div");
			create_component(checkbox0.$$.fragment);
			t2 = space();
			div2 = element("div");
			create_component(checkbox1.$$.fragment);
			t3 = space();
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div6 = element("div");
			create_component(button.$$.fragment);
			t5 = space();
			create_component(dialog.$$.fragment);
			attr_dev(div0, "class", "d-inline-block pt-1 float-start cr_step");
			attr_dev(div0, "style", div0_style_value = "font-size:20px;position:relative;");
			add_location(div0, file, 563, 12, 19930);
			attr_dev(div1, "class", "modes_checkbox d-inline-block top-checkbox_gonext position-relative top2 svelte-smsdwz");
			add_location(div1, file, 565, 16, 20095);
			attr_dev(div2, "class", "modes_checkbox d-inline-block m-l top-checkbox_fix position-relative top2 svelte-smsdwz");
			add_location(div2, file, 574, 16, 20515);
			attr_dev(div3, "style", div3_style_value = {});
			add_location(div3, file, 564, 12, 20062);
			attr_dev(div4, "class", "border-bottom d-flex justify-content-between px-2 pt-1");
			add_location(div4, file, 562, 8, 19849);
			attr_dev(div5, "class", "outer_steps mt-3 mx-3 clear-both");
			add_location(div5, file, 584, 8, 20955);
			attr_dev(div6, "class", "row mx-3 mt-3 pb-3");
			add_location(div6, file, 661, 8, 26506);
			attr_dev(div7, "class", "mt-imp border");
			add_location(div7, file, 561, 4, 19813);
			add_location(main, file, 560, 0, 19802);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div7);
			append_dev(div7, div4);
			append_dev(div4, div0);
			append_dev(div4, t1);
			append_dev(div4, div3);
			append_dev(div3, div1);
			mount_component(checkbox0, div1, null);
			append_dev(div3, t2);
			append_dev(div3, div2);
			mount_component(checkbox1, div2, null);
			append_dev(div7, t3);
			append_dev(div7, div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_dev(div7, t4);
			append_dev(div7, div6);
			mount_component(button, div6, null);
			append_dev(div7, t5);
			mount_component(dialog, div7, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox0_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox0_changes.defaultChecked = /*state*/ ctx[0].gonext ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};
			if (dirty[0] & /*state*/ 1) checkbox1_changes.defaultChecked = /*state*/ ctx[0].variable_button ? true : false;

			if (dirty[1] & /*$$scope*/ 1024) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			checkbox1.$set(checkbox1_changes);

			if (dirty[0] & /*handleSave, deleteEvent, handleChangeCheckbox, all_steps, handleRadio, handleDisable*/ 498) {
				each_value = /*all_steps*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div5, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const button_changes = {};

			if (dirty[1] & /*$$scope*/ 1024) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const dialog_changes = {};

			if (dirty[0] & /*state*/ 1 | dirty[1] & /*$$scope*/ 1024) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 1) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[0].open;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(button.$$.fragment, local);
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(button.$$.fragment, local);
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(checkbox0);
			destroy_component(checkbox1);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
			destroy_component(dialog);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function replaceVariables(latex_str) {
	let latex_arr = [];
	let latex_arr_check = latex_str;

	if (latex_arr_check.length == undefined && latex_arr_check != "") {
		latex_arr.push(latex_arr_check);
	} else {
		latex_arr = latex_arr_check;
	}

	latex_arr.map(function (item, index) {
		let cdata = item.__cdata;
		let vars = cdata.match(/<{[\s\S]*?}>/gm);

		if (vars) {
			vars.map(function (element) {
				let item = element.match(/<\{(.*?)\}>/g);
				item = item.toString().replace(/<\{|\}>/g, "");
				item = "var:" + item;
				item = item.trim();
				cdata = cdata.replace(element, item);
			});
		}

		latex_arr[index].__cdata = cdata;
	});

	return latex_arr;
}

function reverseHtmlSpecialChars(data) {
	let tags = data.match(/&lt;(.*?)&gt;/gm);
	let tag = "";

	if (tags) {
		for (var i = 0; i < tags.length; i++) {
			tag = tags[i];
			tags[i] = tags[i].replace(/&lt;/g, "<").replace(/&gt;/g, ">");
			data = data.replace(tag, tags[i]);
		}
	}

	return data;
}

function replaceSpaces(data) {
	let matching = data.match(/var:var\d+\s+\s+/g);
	let match;

	if (matching) {
		matching.map(function (item, index) {
			match = item.trim();
			data = data.replace(item, match);
		});
	}

	return data;
}

function addEditable() {
	//let txt = jQuery("#input");
	let txt = document.querySelector("#input");

	//let caretPos = txt[0].selectionStart;
	let caretPos = txt.selectionStart;

	//let textAreaTxt = txt.val();
	let textAreaTxt = txt.value;

	var txtToAdd = "\\MathQuillMathField";
	var txtToAdd = "user Response";

	//txt.val(textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos));
	txt.value = textAreaTxt.substring(0, caretPos) + txtToAdd + textAreaTxt.substring(caretPos);
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("StepAlgo", slots, []);
	window.spanCounter = 0;

	// window.currentId = "";
	// window.currentInp = "";
	let state = {};

	let new_xml = {};
	var all_steps = [];
	let { stopAuthoringUpdate } = $$props;
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;

	let stateData = writable({
		xml: "",
		fillInTheBlanksChoice: 1,
		opened: false,
		deleteIndex: "",
		remediationToggle: false,
		snackback: false,
		input_ans: "",
		spanCounter: 0,
		currentId: "",
		currentInp: ""
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	onMount(() => {
		if (xml) {
			new_xml = XMLToJSON(xml);
			showItems(new_xml.smxml.step);

			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select("#sticky_checkbox_0").click();

			//setTimeout(function() {
			//jQuery('#sticky_checkbox_0').trigger('click');
			AH.select("#sticky_checkbox_0").click();
		} //}, 1000);

		setTimeout(
			function () {
				//jQuery('.save_button_steps').prop('disabled', 'disabled');
				AH.selectAll(".save_button_steps", "attr", { disabled: "disabled" });

				initEditor();
			},
			500
		);

		// jQuery(document).on("click touchstart", ".editFill", function() {
		// 	if(jQuery(this).attr("type") == "t") {
		// 		editTextbox(jQuery(this).attr("originalKey"));
		// 	} else if(jQuery(this).attr("type") == "e") {
		// 		editMathbox(jQuery(this).attr("originalKey"));
		// 	}
		// })
		AH.listen(document, "click", ".editFill", function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});

		AH.listen(document, "touchstart", ".editFill", function (curr, e) {
			if (curr.getAttribute("type") == "t") {
				editTextbox(curr.getAttribute("originalKey"));
			} else if (curr.getAttribute("type") == "e") {
				editMathbox(curr.getAttribute("originalKey"));
			}
		});
	});

	function editTextbox(key) {
		//console.log('checking');
		key = key.replace(/%{|}%/g, "");

		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";
		$$invalidate(0, state.numeric = ans_type == "n" ? true : false, state);
		$$invalidate(0, state.fillInTheBlanksChoice = 1, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:1});
		//this.setState({open:true});
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//jQuery("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog #customStyleText").value = customStyle[1];

			//jQUery("#input1").val(customStyle[0]);
			//AH.select("#input1").value = customStyle[0];
			$$invalidate(0, state.input_ans = customStyle[0], state);
		} else {
			//jQuery("#input1").val(ans);
			// setTimeout(()=>{
			//     AH.select("#input1").value = ans;
			// },100)
			$$invalidate(0, state.input_ans = ans, state);
		}
	}

	function editMathbox(key) {
		key = key.replace(/%{|}%/g, "");
		key = key.split("|");
		let ans = key[0].trim();
		let ans_type = key[1] ? key[1].trim() : "";

		// this.setState({
		//     customStyle:((ans.indexOf("#style#") != -1)?true:false),
		//     fillInTheBlanksChoice:2,
		//     open:true
		// });
		$$invalidate(0, state.customStyle = ans.indexOf("#style#") != -1 ? true : false, state);

		$$invalidate(0, state.fillInTheBlanksChoice = 2, state);
		$$invalidate(0, state.open = true, state);

		//this.setState({fillInTheBlanksChoice:2}); ## ALready commented
		//this.setState({open:true}); ## ALready commented
		if (ans.indexOf("#style#") != -1) {
			let customStyle = ans.split("#style#");

			//$("#responseDialog #customStyleText").val(customStyle[1]);
			AH.select("#responseDialog").value = customStyle[1];

			AH.select("#customStyleText").value = customStyle[1];

			//$("#input"+i).val(customStyle[0]);
			AH.select("#input" + i).value = customStyle[0];
		} else {
			//$("#input").val(ans);
			AH.select("#input").value = ans;
		}
	}

	beforeUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			if (stopAuthoringUpdate === true) return;
			new_xml = XMLToJSON(state.xml);
			showItems(new_xml.smxml.step);
		}
	});

	function showItems(steps) {
		steps = replaceVariables(steps);
		$$invalidate(1, all_steps = steps);
		setToggle(all_steps);
		parseXmlAuthoring(steps);
	}

	function setToggle(steps) {

		steps.map(function (item, index) {
			if (item._viewonly == 1) {
				$$invalidate(1, all_steps[index].toggle = 1, all_steps);
			} else {
				$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			}
		});

		return all_steps;
	}

	function parseXmlAuthoring(steps) {
		steps.map(function (item, index) {
			let cdata = item.__cdata;
			let answerKey = cdata.match(/%{[\s\S]*?}%/gm);
			let answerType = "";

			if (answerKey) {
				//jQuery(answerKey).each(function(i){
				answerKey.forEach(function (data, i) {
					let originalKey = answerKey[i];
					let latexKey = "";
					let editMath = "";
					answerType = answerKey[i].match(/\|(.*?)}%$/gm);
					answerType = answerType ? answerType[0].replace(/\||}%/gm, "") : "t";
					let innerKey = "";
					let icon = "";
					let type = "";

					if (answerType == "t") {
						type = answerType;
						innerKey = "Textbox";
						icon = "icomoon-insert-template";
					} else if (answerType == "n") {
						type = "t";
						innerKey = "Numeric";
						icon = "icomoon-insert-template";
					} else if (answerType == "e") {
						type = answerType;
						innerKey = "Math";
						latexKey = originalKey.replace(/\%\{|\|e\}\%/g, "");
						latexKey = "latex=\"" + latexKey + "\"";
						editMath = "editMath";
						icon = "icomoon-insert-template";
					}

					var regex = new RegExp(RegExp.quote(originalKey));
					cdata = cdata.replace(regex, "<span id=\"latexSpan" + $$invalidate(0, state.spanCounter = $$invalidate(0, ++state.spanCounter, state), state) + "\" " + latexKey + " type='" + type + "' class='alert alert-info editFill " + editMath + "' originalkey='" + originalKey + "' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='" + icon + "'></i>" + innerKey + "</span>");
				});
			}

			$$invalidate(1, all_steps[index].__cdata = cdata, all_steps);
		});
	}

	function goNext(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.gonext = true, state);
			new_xml.smxml._gonext = "1";
		} else {
			$$invalidate(0, state.gonext = false, state);
			new_xml.smxml._gonext = "0";
		}

		updateXML();
	}

	function fixedAnswer(id) {
		let ref = document.querySelector("#" + id);

		if (ref.checked) {
			$$invalidate(0, state.variable_button = true, state);
			new_xml.smxml._fixed = "1";
		} else {
			$$invalidate(0, state.variable_button = false, state);
			new_xml.smxml._fixed = "0";
		}

		updateXML();
	}

	function handleChangeCheckbox(id, fillid, e) {
		let name = e.target.name;
		let ref = document.querySelector("#" + name + id);
		let val = "_" + e.target.value;
		let seq = id;

		if (ref.checked) {
			new_xml.smxml.step[seq][val] = "1";
		} else {
			new_xml.smxml.step[seq][val] = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		updateXML();
	}

	function handleDisable(i) {
		console.log("handle click");

		//jQuery('#save_step_'+i).removeAttr('disabled');
		AH.select("#save_step_" + i, "removeAttr", "disabled");
	}

	function handleRadio(index, fillid, event) {
		if (all_steps[index].toggle == 1) {
			$$invalidate(1, all_steps[index].toggle = 0, all_steps);
			new_xml.smxml.step[index]._viewonly = "0";
			new_xml.smxml.step[index]._attempt = "1";
		} else {
			all_steps[index].toggle == 1;
			new_xml.smxml.step[index]._viewonly = "1";
			new_xml.smxml.step[index]._attempt = "0";
		}

		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		updateXML();
	}

	function deleteEvent(index, data) {
		let delete_event;

		if (data == "steps") {
			delete_event = all_steps;

			if (delete_event.length > 2) {
				const add = delete_event.splice(index, 1);
			} else {
				AH.alert("You have atleast 2 steps.");
			}

			$$invalidate(1, all_steps = delete_event);
			updateXML();
		} else if (data == "algo") {
			$$invalidate(0, state.opened = true, state);
			$$invalidate(0, state.deleteIndex = index, state);
		}

		
	}

	function handleSave(id, fillid) {
		//let data = jQuery('#'+fillid).html();
		let data = document.querySelector("#" + fillid).innerHTML;

		data = data.replace(/&amp;/g, "&"); // replace amp to maintain html entity.
		$$invalidate(1, all_steps[id].__cdata = data, all_steps);

		//jQuery('#save_step_'+id).prop('disabled', 'disabled');
		//document.querySelector('#save_step_'+id).disabled = true;
		AH.select("#save_step_" + id, "attr", { disabled: "disabled" });

		updateXML();
	}

	function updateXML() {
		let fixans = new_xml.smxml._fixed;
		let gonext = new_xml.smxml._gonext;
		let xml = "<smxml type=\"37\" fixed=\"" + fixans + "\" gonext=\"" + gonext + "\">";

		all_steps.map(function (element, i) {
			let seq = i + 1;
			let viewonly = element._viewonly;
			let mode = element._mode;
			let attempt = element._attempt;
			let sticky = element._sticky;
			let data = element.__cdata;

			// data = self.reverseReplaceVariables(data);
			data = reverseHtmlSpecialChars(data);

			data = replaceSpaces(data);
			data = data.replace(/&quot;/g, "\"").replace(/&nbsp;/g, " ");
			data = data.replace(/'/g, "\"").replace(/\n/g, "");
			let arr = data.match(/<span(.*?)>(.*?)<\/span>/gi);

			if (arr) {
				for (var i = 0; i < arr.length; i++) {
					let originalkey = arr[i].match(/originalkey="%(.*?)%"/g);

					if (originalkey) {
						originalkey = originalkey.toString().replace(/originalkey=/g, "").replace(/"%|%"/g, "%");
						data = data.replace(arr[i], originalkey);
					}
				}
			}

			let cdata = data;

			xml = xml + "<step seq='" + seq + "'" + (attempt != undefined
			? " attempt ='" + attempt + "'"
			: " ") + (viewonly != undefined
			? " viewonly ='" + viewonly + "'"
			: " ") + (mode != undefined ? " mode ='" + mode + "'" : " ") + (sticky != undefined ? " sticky ='" + sticky + "'" : " ") + "><!--[CDATA[" + cdata + "]]--></step>";
		});

		xml = xml + "</smxml>";
		getChildXml(xml);
	}

	function addEvent(data) {
		let obj = {};
		obj._seq = all_steps.length + 1;
		obj._viewonly = "1";
		obj._attempt = "0";
		obj._mode = "0";
		obj.__cdata = "New Step";
		all_steps.push(obj);
		updateXML();
		$$invalidate(0, state.snackback = true, state);

		var timer = setTimeout(
			function () {
				initEditor();
				clearTimeout(timer);
			},
			500
		);
	}

	function initEditor() {
		// jQuery(document).on("click", ".editMath", function(e){
		//     window.currentId = jQuery(this).attr('id');
		// });
		AH.listen(document, "click", ".editMath", function (_this, e) {
			// window.currentId = _this.getAttribute('id');
			$$invalidate(0, state.currentId = _this.getAttribute("id"), state);
		});

		// jQuery(document).on("click", ".materialOverlay", function(e){
		// 	window.currentId = null;
		//     window.currentInp = null;
		// });
		AH.listen(document, "click", ".materialOverlay", function (e) {
			//window.currentId = null;
			$$invalidate(0, state.currentId = null, state);

			//window.currentInp = null;
			$$invalidate(0, state.currentInp = null, state);
		});

		tinyMCE.PluginManager.add("res", function (editor, url) {
			editor.addMenuItem("resp", {
				text: "Add response",
				id: "addToken",
				onclick() {
					handleOpen();
				},
				context: "insert",
				prependToContext: true
			});
		});

		tinymce.PluginManager.load("equationeditor", themeUrl + "pe-items/tinymce/plugins/equationeditor/plugin.min.js");

		tinymce.init({
			selector: ".tinymce-editor-res",
			inline: true,
			theme: "modern",
			skin: "skin02",
			min_width: 100,
			resize: true,
			menubar: false,
			toolbar: true,
			elementpath: false,
			statusbar: false,
			force_br_newlines: true,
			remove_trailing_brs: true,
			forced_root_block: false,
			extended_valid_elements: "span[onClick|contentEditable]",
			valid_elements: "*[*]",
			fixed_toolbar_container: "#toolbar_container",
			extended_valid_elements: "uc:syntax,uc:ref",
			custom_elements: "uc:syntax,~uc:ref",
			plugins: [
				"lists link image charmap print preview anchor",
				"searchreplace code fullscreen",
				"insertdatetime media table contextmenu paste res equationeditor "
			],
			content_css: themeUrl + "pe-items/tinymce/plugins/equationeditor/mathquill.css",
			toolbar: [" bold italic underline | equationeditor"],
			contextmenu: "resp",
			paste_as_text: true
		});
	}

	function handleClose() {
		if (state.fillInTheBlanksChoice == 2) {
			//window.currentId = null;
			$$invalidate(0, state.currentInp = null, state);
		}

		$$invalidate(0, state.open = false, state);
	}

	function updateDialog(targetVal) {
		$$invalidate(0, state.fillInTheBlanksChoice = targetVal, state);
	}

	function latexEdit() {
		$$invalidate(0, state.open = true, state);
	}

	function storeAns() {
		var validate = 0;

		if (state.fillInTheBlanksChoice == 1) {
			//let ans = jQuery("#input1").val();
			let ans = document.querySelector("#input1").value;

			//let numeric = jQuery("#responseDialog #numeric")[0].checked;
			let numeric = document.querySelector("#responseDialog #numeric").checked;

			if (numeric == true) {
				ans += " |n";
			}

			if (ans.trim() == "") {
				validate = 1;
				validate("All fields are required");
			} else {
				tinyMCE.activeEditor.insertContent("<span type='t' class='alert alert-info editFill' originalKey='%{" + ans.trim() + "}%' style='padding: 5px;outline: none;line-height:40px;cursor:move;color:#000' contentEditable='false'><i style='padding-right:4px' class='icomoon-insert-template'></i>" + (numeric == true ? "Numeric" : "Textbox") + "</span>");
			}
		}

		if (state.fillInTheBlanksChoice == 2) {
			//let e = jQuery("#input").val();
			let e = document.querySelector("#input").value;

			if (validate == 0) {
				//document.querySelector("#"+window.currentId).setAttribute("latex",e);
				document.querySelector("#" + state.currentId).setAttribute("latex", e);

				//document.querySelector("#"+window.currentId).setAttribute("originalKey","%{"+e+"|e}%");
				document.querySelector("#" + state.currentId).setAttribute("originalKey", "%{" + e + "|e}%");

				//window.currentId = null;
				$$invalidate(0, state.currentId = null, state);

				//window.currentInp = null;
				$$invalidate(0, state.currentInp = null, state);
			} else {
				validate("All fields are required");
			}
		}

		if (validate == 0) {
			handleClose();
		}
	}

	function handleOpen() {
		// this.setState({
		//     open: true,
		//     codetype: false,
		//     numeric: false
		// });
		$$invalidate(0, state.open = true, state);

		$$invalidate(0, state.codetype = false, state);
		$$invalidate(0, state.numeric = false, state);
	} //this.setState({codetype: false}); #already commented on also react
	//this.setState({numeric: false}); #already commented on also react

	const writable_props = ["stopAuthoringUpdate", "xml", "editorState", "getChildXml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<StepAlgo> was created with unknown prop '${key}'`);
	});

	const click_handler = e => {
		goNext("go_next");
	};

	const click_handler_1 = e => {
		fixedAnswer("fixedans_checkbox");
	};

	const keyup_handler = (index, e) => {
		handleDisable(index);
	};

	const change_handler = (index, e) => {
		handleRadio(index, "fillAuthor_" + index);
	};

	const click_handler_2 = (index, e) => {
		handleChangeCheckbox(index, "fillAuthor_" + index, e);
	};

	const click_handler_3 = (index, e) => {
		handleChangeCheckbox(index, "fillAuthor_" + index, e);
	};

	const click_handler_4 = (index, e) => {
		deleteEvent(index, "steps");
	};

	const click_handler_5 = (index, e) => {
		handleSave(index, "fillAuthor_" + index);
	};

	function dialog_visible_binding(value) {
		state.open = value;
		$$invalidate(0, state);
	}

	$$self.$$set = $$props => {
		if ("stopAuthoringUpdate" in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		writable,
		Button,
		Dialog,
		Checkbox,
		l: language,
		beforeUpdate,
		onMount,
		AH,
		XMLToJSON,
		JSONToXML,
		state,
		new_xml,
		all_steps,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		stateData,
		unsubscribe,
		editTextbox,
		editMathbox,
		showItems,
		setToggle,
		replaceVariables,
		parseXmlAuthoring,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		updateXML,
		reverseHtmlSpecialChars,
		replaceSpaces,
		addEvent,
		initEditor,
		handleClose,
		updateDialog,
		addEditable,
		latexEdit,
		storeAns,
		handleOpen
	});

	$$self.$inject_state = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("new_xml" in $$props) new_xml = $$props.new_xml;
		if ("all_steps" in $$props) $$invalidate(1, all_steps = $$props.all_steps);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(14, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("xml" in $$props) $$invalidate(15, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(16, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(17, getChildXml = $$props.getChildXml);
		if ("stateData" in $$props) stateData = $$props.stateData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		all_steps,
		goNext,
		fixedAnswer,
		handleChangeCheckbox,
		handleDisable,
		handleRadio,
		deleteEvent,
		handleSave,
		addEvent,
		handleClose,
		updateDialog,
		latexEdit,
		storeAns,
		stopAuthoringUpdate,
		xml,
		editorState,
		getChildXml,
		click_handler,
		click_handler_1,
		keyup_handler,
		change_handler,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		dialog_visible_binding
	];
}

class StepAlgo extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-smsdwz-style")) add_css();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				stopAuthoringUpdate: 14,
				xml: 15,
				editorState: 16,
				getChildXml: 17
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StepAlgo",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stopAuthoringUpdate*/ ctx[14] === undefined && !("stopAuthoringUpdate" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*xml*/ ctx[15] === undefined && !("xml" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[16] === undefined && !("editorState" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[17] === undefined && !("getChildXml" in props)) {
			console_1.warn("<StepAlgo> was created without expected prop 'getChildXml'");
		}
	}

	get stopAuthoringUpdate() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<StepAlgo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<StepAlgo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMMixedItem/ItemPlugin.svelte generated by Svelte v3.29.0 */
const file$1 = "clsSMMixedItem/ItemPlugin.svelte";

// (13:4) {#if parseInt(editorState.content_icon) == 2}
function create_if_block$1(ctx) {
	let newauthoring;
	let current;

	newauthoring = new StepAlgo({
			props: {
				xml: /*xml*/ ctx[0],
				getChildXml: /*getChildXml*/ ctx[2],
				stopAuthoringUpdate: /*stopAuthoringUpdate*/ ctx[3],
				uxml: /*uxml*/ ctx[4]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(newauthoring.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(newauthoring, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const newauthoring_changes = {};
			if (dirty & /*xml*/ 1) newauthoring_changes.xml = /*xml*/ ctx[0];
			if (dirty & /*getChildXml*/ 4) newauthoring_changes.getChildXml = /*getChildXml*/ ctx[2];
			if (dirty & /*stopAuthoringUpdate*/ 8) newauthoring_changes.stopAuthoringUpdate = /*stopAuthoringUpdate*/ ctx[3];
			if (dirty & /*uxml*/ 16) newauthoring_changes.uxml = /*uxml*/ ctx[4];
			newauthoring.$set(newauthoring_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(newauthoring.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(newauthoring.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(newauthoring, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(13:4) {#if parseInt(editorState.content_icon) == 2}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let main;
	let show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;
	let current;
	let if_block = show_if && create_if_block$1(ctx);

	const block = {
		c: function create() {
			main = element("main");
			if (if_block) if_block.c();
			add_location(main, file$1, 11, 0, 224);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			if (if_block) if_block.m(main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*editorState*/ 2) show_if = parseInt(/*editorState*/ ctx[1].content_icon) == 2;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*editorState*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(main, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ItemPlugin", slots, []);
	let { xml } = $$props;
	let { editorState } = $$props;
	let { getChildXml } = $$props;
	let { stopAuthoringUpdate } = $$props;
	let { uxml } = $$props;
	const writable_props = ["xml", "editorState", "getChildXml", "stopAuthoringUpdate", "uxml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ItemPlugin> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("uxml" in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	$$self.$capture_state = () => ({
		NewAuthoring: StepAlgo,
		xml,
		editorState,
		getChildXml,
		stopAuthoringUpdate,
		uxml
	});

	$$self.$inject_state = $$props => {
		if ("xml" in $$props) $$invalidate(0, xml = $$props.xml);
		if ("editorState" in $$props) $$invalidate(1, editorState = $$props.editorState);
		if ("getChildXml" in $$props) $$invalidate(2, getChildXml = $$props.getChildXml);
		if ("stopAuthoringUpdate" in $$props) $$invalidate(3, stopAuthoringUpdate = $$props.stopAuthoringUpdate);
		if ("uxml" in $$props) $$invalidate(4, uxml = $$props.uxml);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [xml, editorState, getChildXml, stopAuthoringUpdate, uxml];
}

class ItemPlugin extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			xml: 0,
			editorState: 1,
			getChildXml: 2,
			stopAuthoringUpdate: 3,
			uxml: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ItemPlugin",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[0] === undefined && !("xml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'xml'");
		}

		if (/*editorState*/ ctx[1] === undefined && !("editorState" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'editorState'");
		}

		if (/*getChildXml*/ ctx[2] === undefined && !("getChildXml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'getChildXml'");
		}

		if (/*stopAuthoringUpdate*/ ctx[3] === undefined && !("stopAuthoringUpdate" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'stopAuthoringUpdate'");
		}

		if (/*uxml*/ ctx[4] === undefined && !("uxml" in props)) {
			console.warn("<ItemPlugin> was created without expected prop 'uxml'");
		}
	}

	get xml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stopAuthoringUpdate() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopAuthoringUpdate(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get uxml() {
		throw new Error("<ItemPlugin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set uxml(value) {
		throw new Error("<ItemPlugin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ItemPlugin;
//# sourceMappingURL=ItemPlugin-80a62d26.js.map
