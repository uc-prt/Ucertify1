
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, e as element, p as append_dev, C as validate_each_argument, v as validate_slots, L as beforeUpdate, o as onMount, A as AH, a9 as afterUpdate, y as language, w as writable, X as XMLToJSON, M as JSONToXML, z as empty, n as insert_dev, x as detach_dev, c as create_component, f as space, m as mount_component, t as transition_in, a as transition_out, b as destroy_component, j as attr_dev, k as add_location, K as destroy_each, l as set_style, q as listen_dev, r as group_outros, u as check_outros, G as prop_dev, H as run_all, B as noop, h as text } from './main-f041e104.js';
import { G as GriddedHelper } from './GriddedHelper-bde7a853.js';

/* clsSMGridded\Gridded.svelte generated by Svelte v3.29.0 */

const { console: console_1, document: document_1 } = globals;
const file = "clsSMGridded\\Gridded.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1wrfq8n-style";
	style.textContent = ".custom_checkbox_new.svelte-1wrfq8n.svelte-1wrfq8n{display:block;position:relative;width:20px;height:20px;margin-bottom:0;cursor:pointer;font-size:18px}.layoutHeading{font-weight:bold;font-size:16px;color:#1877b1}.items_element:hover{border:1.2px solid #777}.moreOptions{-webkit-box-shadow:3px 4px 6px #c4c5c5;-moz-box-shadow:3px 4px 6px #c4c5c5;box-shadow:3px 4px 6px #c4c5c5;background-color:#f0f0f0;border-top:1px solid #1877b1;border-bottom:1px solid #1877b1}.moreOptionDetails{background-color:#f7f7f7}.input_col{position:relative;left:5px}.layoutheading{padding:5px;font-size:20px;font-weight:bold}.numbr_range{position:relative;left:130px}.numbr_range_txt{position:relative;left:200px}.plus_minus_fraction{position:relative;top:20px}.floating_fraction{position:relative;top:27px}.plus_minus_span{position:relative;left:5px}.floating_decimal{float:right;margin-right:45px}.fontStyle{width:100px;float:right;margin-right:60px}.fraction_slash{position:relative;left:177px}.minus_tab,\r\n.plus_tab,\r\n.slash_tab{text-align:center}.gridded_tab.svelte-1wrfq8n.svelte-1wrfq8n{background-color:#f0f0f0;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.font_size_label{position:relative;left:198px}.font_size{position:relative;left:225px}.decimal_col{position:relative;left:208px;width:90px}.correct_color{background-color:#E9FFE9}.fixed_decimal_check{position:relative;top:26px;left:13px}.correct_incorrect_icon_fill{position:relative;width:19px;height:19px;right:121px;top:-55px;background:white;border-radius:50%}.row_column_decimal{position:relative;top:30px;left:5px}.fixed_point_class{position:relative;left:7px}.row_column{position:relative;left:5px}.answer_icon{position:absolute;top:3px;right:34px}.col_range{width:205px}.posSize{position:relative;left:7px}.fontSmall{font-size:12px;text-align:center}.fontNormal{font-size:14px;text-align:center}.fontLarge{font-size:24px;text-align:center}.fontExtraLarge{font-size:26px;text-align:center}.grid{position:relative;top:10px;box-shadow:10px 5px 10px #000}.items_element{border:1px solid #8080807a;padding:6px 10px;border-radius:50%;background-color:white}.griddedModule .active{color:white;transition:1s;background:#696969;border:2px solid #fff}.sla_point{padding:6px 11px}.griddedModule.svelte-1wrfq8n table tr td.svelte-1wrfq8n:last-child{border-right:1px solid #ccc !important}.griddedModule.svelte-1wrfq8n .lastGrid tr:last-child td.svelte-1wrfq8n{border-bottom:1px solid #ccc !important}.griddedModule td{border:1px solid #f0f0f0 !important;border-left:1px solid #ccc !important}.token:hover{border:1px solid #000 !important}.bla .token:hover{border:1px solid #fff !important}.token_selected{background-color:#64bb63;color:#fff}.bla .token_highlight_heading{color:#000 !important}.griddedModule .expandIcon{font-size:27px;font-weight:bold;color:#1877b1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZGRlZC5zdmVsdGUiLCJzb3VyY2VzIjpbIkdyaWRkZWQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS0gXHJcbiAqICBGaWxlIE5hbWUgICA6IEdyaWRkZWQuanNcclxuICogIERlc2NyaXB0aW9uIDogTGF5b3V0IGRlY2lkZWQgZm9yIGdyaWRkZWQgc2hlZXRcclxuICogIEF1dGhvciAgICAgIDogU3VuZGFyYW0gVHJpcGF0aGlcclxuICogIFZlcnNpb24gICAgIDogMS4wXHJcbiAqICBQYWNrYWdlICAgICA6IHBlLWdvbGRcclxuICogIExhc3QgdXBkYXRlIDogMTQtTWFyY2gtMjAyMSAgLS0+XHJcblxyXG48c2NyaXB0PlxyXG4gICAgaW1wb3J0IGwgZnJvbSAnLi4vc3JjL2xpYnMvZWRpdG9yTGliL2xhbmd1YWdlLmpzJztcclxuICAgIGltcG9ydCB7d3JpdGFibGV9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XHJcbiAgICBpbXBvcnQge0FILFhNTFRvSlNPTixKU09OVG9YTUx9IGZyb20gXCIuLi9oZWxwZXIvSGVscGVyQUkuc3ZlbHRlXCI7XHJcbiAgICBpbXBvcnQgeyBvbk1vdW50LCBhZnRlclVwZGF0ZSwgYmVmb3JlVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcclxuICAgIGltcG9ydCBHcmlkZGVkSGVscGVyIGZyb20gJy4vR3JpZGRlZEhlbHBlci5zdmVsdGUnO1xyXG5cclxuXHJcblxyXG4gICAgbGV0IHN0YXRlID0ge307XHJcbiAgICBleHBvcnQgbGV0IGdldENoaWxkWG1sO1xyXG4gICAgbGV0IGNvcnJlY3RBbnMgPSBbXTtcclxuXHJcbiAgICBleHBvcnQgbGV0IHhtbDtcclxuXHJcbiAgICBsZXQgc3RhdGVEYXRhID0gd3JpdGFibGUoe1xyXG4gICAgICAgICAgICByb3dOdW0gICAgICAgICAgICAgICAgICA6IDQsXHJcbiAgICAgICAgICAgIGNvbE51bSAgICAgICAgICAgICAgICAgIDogNCxcclxuICAgICAgICAgICAgdGFibGVOYW1lICAgICAgICAgICAgICAgOiBcIkdyaWRkZWQgU3lzdGVtXCIsXHJcbiAgICAgICAgICAgIHBsdXNfbWludXMgICAgICAgICAgICAgIDogMCxcclxuICAgICAgICAgICAgc2xhc2hfdmFsICAgICAgICAgICAgICAgOiAwLFxyXG4gICAgICAgICAgICBkZWNpbWFsX3ZhbCAgICAgICAgICAgICA6IDAsXHJcbiAgICAgICAgICAgIHhtbCAgICAgICAgICAgICAgICAgICAgIDogJycsXHJcbiAgICAgICAgICAgIHRleHRTaXplICAgICAgICAgICAgICAgIDogMTQsXHJcbiAgICAgICAgICAgIHJlc0FucyAgICAgICAgICAgICAgICAgIDogJycsXHJcbiAgICAgICAgICAgIGNvcnJlY3RBbnMgICAgICAgICAgICAgIDogW10sXHJcbiAgICAgICAgICAgIGxpc3RBbnMgICAgICAgICAgICAgICAgIDogW10sXHJcbiAgICAgICAgICAgIHJlcyAgICAgICAgICAgICAgICAgICAgIDogJycsXHJcbiAgICAgICAgICAgIGZpeGVkX2RlY2ltYWxfdmFsICAgICAgIDogMCxcclxuICAgICAgICAgICAgZGVjaW1hbF9wb2ludCAgICAgICAgICAgOiAwLFxyXG4gICAgfSlcclxuXHJcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0YXRlRGF0YS5zdWJzY3JpYmUoKGl0ZW1zKT0+e1xyXG4gICAgICAgIHN0YXRlID0gaXRlbXM7XHJcbiAgICB9KVxyXG5cclxuICAgIFxyXG5cclxuICAgIGJlZm9yZVVwZGF0ZSgoKT0+e1xyXG5cclxuICAgICAgICBBSS5zZWxlY3RBbGwoJy50ZEZvbnQnLCdjc3MnLHtcclxuICAgICAgICAgICAgZm9udFNpemU6JzE0cHgnXHJcbiAgICAgICAgfSlcclxuICAgIFxyXG4gICAgfSlcclxuXHJcblxyXG4gICAgb25Nb3VudCgoKT0+e1xyXG4gICAgICAgIEFILmxpc3RlbignYm9keScsJ2tleWRvd24nLCcudGRfZGF0YScsKChfdGhpcyxlKT0+e1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkV2bnRzID0+IFwiLGUpO1xyXG4gICAgICAgICAgICBpZihlLndoaWNoID09PSAxMykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xpY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSlcclxuXHJcbiAgICBhZnRlclVwZGF0ZSgoKT0+e1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh4bWwgIT0gc3RhdGUueG1sKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnhtbCA9IHhtbDtcclxuICAgICAgICAgICAgbG9hZE1vZHVsZSh4bWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaXJzdFJvd0l0ZW0oKTtcclxuICAgICAgICBzbGFzaEZ1bmMoKTtcclxuICAgICAgICBkZWNpbWFsRmxvYXRpbmcoKTtcclxuICAgICAgICBwbHVzTWludXNTaWduKCk7XHJcbiAgICAgICAgY3JlYXRlZFNoZWV0Um93KCk7XHJcbiAgICB9KVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRNb2R1bGUobG9hZFhtbCkge1xyXG4gICAgICAgIGxvYWRYbWwgPSBYTUxUb0pTT04obG9hZFhtbCk7XHJcbiAgICAgICAgcGFyc2VYTUxBdXRob3JpbmcobG9hZFhtbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VYTUxBdXRob3JpbmcoTVlYTUwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUucm93TnVtID0gTVlYTUwuc214bWwuX3JvdztcclxuICAgICAgICAgICAgICAgIHN0YXRlLmNvbE51bSA9IE1ZWE1MLnNteG1sLl9jb2w7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zbGFzaF92YWwgPSAgTVlYTUwuc214bWwuX3NsYXNoO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUucGx1c19taW51cyA9IE1ZWE1MLnNteG1sLl9wbHVzbWludXM7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5kZWNpbWFsX3ZhbCA9ICBNWVhNTC5zbXhtbC5fZGVjaW1hbDtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnRleHRTaXplID0gTVlYTUwuc214bWwuX2ZvbnQ7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb3JyZWN0QW5zID0gIE1ZWE1MLnNteG1sLl9jb3JyZWN0QW5zO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRYbWwoSlNPTlRvWE1MKE1ZWE1MKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTVlYTUwuc214bWwuX3BsdXNtaW51cyA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BsdXNfbWludXNfY2hlY2tib3gnKS5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChNWVhNTC5zbXhtbC5fc2xhc2ggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcmFjdGlvbl9zbGFzaF9jaGVja2JveCcpLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKE1ZWE1MLnNteG1sLl9kZWNpbWFsID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmxvYXRpbmdfZGVjaW1hbF9jaGVja2JveCcpLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih7XHJcbiAgICAgICAgICAgICAgICAnZXJyb3InOiBldmVudHMubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICdmdW5jdGlvbiBuYW1lJzogJ3BhcnNlWE1MQXV0aG9yaW5nJyxcclxuICAgICAgICAgICAgICAgICdGaWxlIG5hbWUnOiAnR3JpZGRlZC5qcydcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGJvb2xlYW4gdmFsdWUgaW4gcGx1cy9taW51c1xyXG4gICAgZnVuY3Rpb24gcGx1c01pbnVzU2V0VmFsKCkge1xyXG4gICAgICAgIHN0YXRlLnBsdXNfbWludXMgPSAoc3RhdGUucGx1c19taW51cyA9PSAwKSA/IDEgOiAwO1xyXG4gICAgICAgIHVwZGF0ZVhtbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNsYXNoIGZ1bmN0aW9uIHNldCB2YWx1ZSB0cnVlIG9yIGZhbHNlXHJcbiAgICBmdW5jdGlvbiBzbGFzaEZ1bmNTZXRWYWwoZXZlbnQpIHtcclxuICAgICAgICBzdGF0ZS5zbGFzaF92YWwgPSAoc3RhdGUuc2xhc2hfdmFsID09IDApID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHVwZGF0ZVhtbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZGlzYWJsZSBkZWNpbWFsIGlucHV0IGJveFxyXG4gICAgZnVuY3Rpb24gZml4ZWRGdW5jKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHN0YXRlLmZpeGVkX2RlY2ltYWxfdmFsID09IDApIHtcclxuICAgICAgICAgICAgc3RhdGUuZml4ZWRfZGVjaW1hbF92YWwgPSAxO1xyXG4gICAgICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdGaXhlZF9kZWNpbWFsX2NvbHVtbicpO1xyXG4gICAgICAgICAgICBlbGVtLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmZpeGVkX2RlY2ltYWxfdmFsID0gMDtcclxuICAgICAgICAgICAgc3RhdGUuZGVjaW1hbF9wb2ludCA9IDAgO1xyXG5cclxuICAgICAgICAgICAgbGV0IGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnRml4ZWRfZGVjaW1hbF9jb2x1bW4nKTtcclxuICAgICAgICAgICAgZWxlbS52YWx1ZSA9IFwiIFwiO1xyXG4gICAgICAgICAgICBlbGVtLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB1cGRhdGVYbWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuXHJcbiAgICAvLyBTZXQgdmFsdWUgZGVjaW1hbCBmbG9hdGluZ1xyXG4gICAgZnVuY3Rpb24gZGVjaW1hbEZ1bmNTZXRWYWwgKGV2ZW50KSB7XHJcbiAgICAgICAgc3RhdGUuZGVjaW1hbF92YWwgPSAoc3RhdGUuZGVjaW1hbF92YWwgPT0gMCkgPyAxIDogMDtcclxuICAgICAgICB1cGRhdGVYbWwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGRlY2lkZWQgdG8gcm93IG9yIGNvbHVtbiBmdW5jdGlvblxyXG4gICAgZnVuY3Rpb24gY2hhbmdlUm93Q29sKGV2ZW50KSB7XHJcbiAgICAgICAgaWYoKGV2ZW50LnRhcmdldC52YWx1ZSkubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBBSC5hbGVydCgnYWNjZXB0IG9ubHkgc2luZ2xlIHZhbHVlJyk7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IDQ7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2NoZWNrJyk7XHJcblxyXG4gICAgICAgIGxldCB2YWwgPSBldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgaWYgKCEodmFsID4gMCAmJiB2YWwgPD0gMTApKSB7XHJcbiAgICAgICAgICAgIEFILmFsZXJ0KGwuZ3JpZF9vbmVfdG9fdGVuKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJjb2xfbm1iclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQudmFsdWUgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBBSC5hbGVydChsLmNvbF9sZXNzX29uZSk7XHJcbiAgICAgICAgICAgICAgICBldmFcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlID4gNikge1xyXG4gICAgICAgICAgICAgICAgQUguYWxlcnQobC50eXBlX29uZV90b19zZXZlbik7XHJcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXRlLmNvbE51bSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlIDwgMSkge1xyXG4gICAgICAgICAgICBBSC5hbGVydChsLnJvd19sZXNzX29uZSk7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQudmFsdWUgPiAxMCkge1xyXG4gICAgICAgICAgICAgICAgQUguYWxlcnQobC50eXBlX29uZV90b190ZW4pO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGF0ZS5yb3dOdW0gPSBldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVhtbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpeGVkRGVjaW1hbFBvaW50cyhldmVudCkge1xyXG4gICAgICAgIGxldCBkZWNpbWFsUG9zaXRpb24gPSBldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgaWYoKGV2ZW50LnRhcmdldC52YWx1ZSkubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBBSC5hbGVydCgnYWNjZXB0IG9ubHkgc2luZ2xlIHZhbHVlJyk7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGRlY2ltYWxQb3NpdGlvbiA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDEgfHwgZXZlbnQudGFyZ2V0LnZhbHVlIDwgMSB8fCBzdGF0ZS5jb2xOdW0gPD0gZXZlbnQudGFyZ2V0LnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRlY2ltYWxQb3NpdGlvbiA9IDE7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IDE7XHJcbiAgICAgICAgICAgIEFILmFsZXJ0KGwuZGVjaW1hbF9wb3NpdGlvbisoc3RhdGUuY29sTnVtLTEpK1wiLlwiKTtcclxuICAgICAgICAgICAgLy8kKFwiLnNhLWluZm9cIikuc2hvdygpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2EtaW5mbycpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5kZWNpbWFsX3BvaW50ID0gZGVjaW1hbFBvc2l0aW9uO1xyXG4gICAgICAgIHVwZGF0ZVhtbCgpO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgeG1sXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVYbWwoKSB7XHJcbiAgICAgICAgLy8gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgdXBkYXRlZFhtbCA9ICc8c214bWwgdHlwZT1cIjU2XCIgbmFtZT1cIkdyaWRkZWRcIiBwbHVzbWludXM9XCInK3N0YXRlLnBsdXNfbWludXMrJ1wiIHNsYXNoPVwiJytzdGF0ZS5zbGFzaF92YWwrJ1wiIGRlY2ltYWw9XCInK3N0YXRlLmRlY2ltYWxfdmFsKydcIiBmaXhlZF9wb2ludD1cIicrc3RhdGUuZGVjaW1hbF9wb2ludCsnXCIgZm9udD1cIicrc3RhdGUudGV4dFNpemUrJ1wiIHJvdz1cIicrc3RhdGUucm93TnVtKydcIiBjb2w9XCInK3N0YXRlLmNvbE51bSsnXCIgY29ycmVjdEFucz1cIicrc3RhdGUucmVzKydcIiA+PCEtLVtDREFUQVtdXS0tPjwvc214bWw+JztcclxuICAgICAgICAgICAgZ2V0Q2hpbGRYbWwodXBkYXRlZFhtbCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vIH0sIDUwMCk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIFxyXG5cclxuICAgIC8vIENyZWF0ZSBhIHNoZWV0IGFjY29yZGluZyB0byByYW5nZVxyXG4gICAgbGV0IHRvdGFsUm93cyA9IFtdLHRvdGFsQ29scyA9IFtdO1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlZFNoZWV0Um93KCkge1xyXG4gICAgICAgIEFILnNlbGVjdCgnLnRkRm9udCcsJ2Nzcycse2ZvbnRTaXplOnN0YXRlLnRleHRTaXplfSlcclxuICAgICAgICB0b3RhbFJvd3MgPSBbXTtcclxuICAgICAgICBsZXQgZGVjX3BvaW50ID0gc3RhdGUuZGVjaW1hbF9wb2ludDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnJvd051bTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRvdGFsQ29scyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQ29scyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG90YWxDb2xzLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTpcImNvbFwiK2kraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbENvbHMubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQ29scyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvdGFsQ29scyx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImNvbFwiK2kraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqICsgXCItXCIgKyBpICsgaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RhbFJvd3MgPSBbXHJcbiAgICAgICAgICAgICAgICAuLi50b3RhbFJvd3Mse1xyXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJyb3dcIitpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgXHJcbiAgICBcclxufTtcclxuXHJcbiBcclxuXHJcbiAgICAvLyBjcmVhdGVkIGEgc2xhc2ggcm93IGluIGdyaWRkZWQgc2hlZXRcclxuICAgIGxldCBDb2xzX3NsYXNoO1xyXG4gICAgZnVuY3Rpb24gc2xhc2hGdW5jKGV2ZW50KSB7XHJcbiAgICAgICAgQ29sc19zbGFzaCA9IFtdO1xyXG4gICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUuY29sTnVtOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgQ29sc19zbGFzaCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5Db2xzX3NsYXNoLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImNvbFwiK2osXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoQ29sc19zbGFzaC5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcclxuICAgICAgICAgICAgICAgIENvbHNfc2xhc2ggPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19zbGFzaCx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIGRlY2ltYWwgZmxvYXRpbmcgcm93XHJcbiAgICBsZXQgQ29sc19kZWNpbWFsO1xyXG4gICAgZnVuY3Rpb24gZGVjaW1hbEZsb2F0aW5nKGV2ZW50KSB7XHJcbiAgICAgICAgQ29sc19kZWNpbWFsID0gW107XHJcbiAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaiA9PSBkZWNfcG9pbnQgLSAxICYmIGRlY19wb2ludCAhPSAwICkge1xyXG4gICAgICAgICAgICAgICAgQ29sc19kZWNpbWFsID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLkNvbHNfZGVjaW1hbCx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJjb2xcIitqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChDb2xzX2RlY2ltYWwubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29sc19kZWNpbWFsLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2xzX2RlY2ltYWwgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19kZWNpbWFsLHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidGRcIiArIGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAgLy8gY3JlYXRlIHBsdXMgYW5kIG1pbnVzIHJvd1xyXG4gICAgbGV0IENvbHNfTWludXMgPSBbXSxDb2xzID0gW107IFxyXG4gICAgZnVuY3Rpb24gcGx1c01pbnVzU2lnbihldmVudCkgIHtcclxuICAgICAgICAgICAgbGV0IFJvd3MgPSBbXTtcclxuICAgICAgICAgICAgQ29scyA9IFtdO1xyXG4gICAgICAgICAgICBDb2xzX01pbnVzID0gW107XHJcbiAgICAgICAgICAgIGxldCBSb3dzX01pbnVzID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZWNfcG9pbnQgPSBzdGF0ZS5kZWNpbWFsX3BvaW50O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLmNvbE51bTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29scyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLkNvbHMse1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUYWc6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENvbHMubGVuZ3RoIDwgc3RhdGUuY29sTnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29scyx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb2xzX01pbnVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19NaW51cyx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidGRcIiArIGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRhZzogaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3BvaW50OiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ29sc19NaW51cy5sZW5ndGggPCBzdGF0ZS5jb2xOdW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbHNfTWludXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uQ29sc19NaW51cyx7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRkXCIgKyBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNwb2ludDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ3JlYXRlIHZlcnkgZmlyc3Qgcm93IGFuZCBzdG9yZSBkYXRhIGFjY29yZGluZyB0byBjbGlja1xyXG4gICAgbGV0IENvbHNGaXJzdFJvdyA9IFtdO1xyXG4gICAgZnVuY3Rpb24gZmlyc3RSb3dJdGVtKCkge1xyXG4gICAgICAgIGxldCBSb3dzID0gW107XHJcbiAgICAgICAgQ29sc0ZpcnN0Um93ID0gW107XHJcbiAgICAgICAgbGV0IGRlY19wb2ludCA9IHN0YXRlLmRlY2ltYWxfcG9pbnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5jb2xOdW07IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaiA9PT0gZGVjX3BvaW50IC0gMSAmJiBkZWNfcG9pbnQgIT0gMCApIHtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBDb2xzRmlyc3RSb3cgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uQ29sc0ZpcnN0Um93LHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQ29sc0ZpcnN0Um93Lmxlbmd0aCA8IHN0YXRlLmNvbE51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgQ29sc0ZpcnN0Um93ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5Db2xzRmlyc3RSb3cse1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd0ZCcraixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVGFnOiBqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcG9pbnQ6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAgLy8gQ2hlY2sgdmFsaWRhdGlvbiBmaXJzdCByb3cgaW5wdXQgdHlwZVxyXG4gICAgZnVuY3Rpb24gcm93VmFsaWRhdGlvbihldmVudCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdudW1iZXInICsgc3RhdGUucGx1c19taW51cyk7XHJcbiAgICAgICAgbGV0IGEgPSBzdGF0ZS5yb3dOdW0tMTtcclxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgQUguYWxlcnQobC5kb3VibGVfZGlnaXQpO1xyXG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSAnJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0LnZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICBBSC5hbGVydChsLmxlc3Nfb25lKTtcclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gXCJcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGEgPCBldmVudC50YXJnZXQudmFsdWUpIHtcclxuICAgICAgICAgICAgQUguYWxlcnQobC5udW1iZXJfZnJvbSArIGEpO1xyXG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSAnJztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUucGx1c19taW51cyA9PSAwICYmICBldmVudC50YXJnZXQudmFsdWUgPT0gXCIrXCIgfHwgZXZlbnQudGFyZ2V0LnZhbHVlID09IFwiLVwiKSB7XHJcbiAgICAgICAgICAgIEFILmFsZXJ0KCdQbHogc2VsZWN0IHBsdXMgYW5kIG1pbnVzIG9wdGlvbicpO1xyXG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zbGFzaF92YWwgPT0gMCAmJiAgZXZlbnQudGFyZ2V0LnZhbHVlID09IFwiL1wiKSB7XHJcbiAgICAgICAgICAgIEFILmFsZXJ0KCdQbHogc2VsZWN0IHNsYXNoIG9wdGlvbicpO1xyXG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZWNpbWFsX3ZhbCA9PSAwICYmICBldmVudC50YXJnZXQudmFsdWUgPT0gXCIuXCIpIHtcclxuICAgICAgICAgICAgQUguYWxlcnQoJ1BseiBzZWxlY3QgZGVjaW1hbCBvcHRpb24nKTtcclxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gXCJcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBsZXQgYXR0cmlidXRlID0gZXZlbnQudGFyZ2V0LmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLXRhZycpLnZhbHVlO1xyXG4gICAgICAgIGNvcnJlY3RBbnNbYXR0cmlidXRlXSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcclxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29ycmVjdEFucy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZihjb3JyZWN0QW5zW2ldKSA9PSAndW5kZWZpbmVkJyB8fCBjb3JyZWN0QW5zW2ldPT1cIlwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb3JyZWN0QW5zW2ldID0gXCIlYmxhbmslXCI7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGNvcnJlY3RBbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3JyZWN0QW5zWyhjb3JyZWN0QW5zLmxlbmd0aCktMV0gPT0gXCIlYmxhbmslXCIpIHtcclxuICAgICAgICAgICAgY29ycmVjdEFucy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHN0YXRlLmxpc3RBbnMgPSBjb3JyZWN0QW5zO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN0YXRlLnJlcyA9IHN0YXRlLmxpc3RBbnMudG9TdHJpbmcoKTtcclxuICAgICAgICB1cGRhdGVYbWwoKTtcclxuICAgIH1cclxuXHJcbiAgICAgLy8gQ2hhbmdlIGNvbG9yIGluIHNoZWV0IGFjY29yZGluZyB0byB1c2VyIGlucHV0XHJcbiAgICBmdW5jdGlvbiBoaWdoTGlnaHQoZXZlbnQpIHtcclxuICAgICAgICBsZXQgY2VsbF9jbGFzcyA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcclxuICAgICAgICBsZXQgY29sdW1uX2luZGV4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoY2VsbF9jbGFzcyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb2x1bW5faW5kZXgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbl9pbmRleFtpXS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29sdW1uX2luZGV4W2ldLmlubmVySFRNTCA9PSBldmVudC50YXJnZXQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcbiAgICAgICAgbGV0IGNlbGxfY2xhc3MgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XHJcbiAgICAgICAgbGV0IGNvbHVtbl9pbmRleCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGNlbGxfY2xhc3MpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uX2luZGV4Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5faW5kZXhbaV0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcclxuICAgICAgICBsZXQgdGFyZ2V0X2lkID0gZXZlbnQudGFyZ2V0LmlkO1xyXG4gICAgICAgIGxldCB0YXJnZXRfdG9fZGlzcGxheSA9IHRhcmdldF9pZC5zcGxpdChcIi1cIik7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0X3RvX2Rpc3BsYXlbMF0pLnZhbHVlID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTDtcclxuXHJcbiAgICAgICAgbGV0IGF0dHJpYnV0ZSA9IGV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS10YWcnKS52YWx1ZTtcclxuICAgICAgICBjb3JyZWN0QW5zW2F0dHJpYnV0ZV0gPSBldmVudC50YXJnZXQuaW5uZXJIVE1MO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcnJlY3RBbnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YoY29ycmVjdEFuc1tpXSkgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvcnJlY3RBbnNbaV0gPSBcIiVibGFuayVcIjtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coY29ycmVjdEFucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3RhdGUubGlzdEFucyA9IGNvcnJlY3RBbnM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3RhdGUucmVzID0gc3RhdGUubGlzdEFucy50b1N0cmluZygpO1xyXG4gICAgICAgIHVwZGF0ZVhtbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluc2VydCBhIGRhdGEgaW4gdG9wIHJvdyBhY2NvcmRpbmcgdG8gY2xpY2sgIGFuZCBjaGFuZ2UgY29sb3JzXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGlja0NvbWJvKGV2ZW50KSB7XHJcbiAgICAgICAgLy9sZXQgY2VsbF9jbGFzcyA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcclxuICAgICAgICBsZXQgY2VsbF9jbGFzcyA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxyXG4gICAgICAgIGxldCBjb2x1bW5faW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShjZWxsX2NsYXNzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbl9pbmRleC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uX2luZGV4W2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKGV2ZW50LmRldGFpbC50YXJnZXQpLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgbGV0IHRhcmdldF9pZCA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pZDtcclxuICAgICAgICBsZXQgdGFyZ2V0X3RvX2Rpc3BsYXkgPSB0YXJnZXRfaWQuc3BsaXQoXCItXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldF90b19kaXNwbGF5WzBdKS52YWx1ZSA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pbm5lckhUTUw7XHJcblxyXG4gICAgICAgIC8vbGV0IGF0dHJpYnV0ZSA9IGV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS10YWcnKS52YWx1ZTtcclxuICAgICAgICBsZXQgYXR0cmlidXRlID0gKGV2ZW50LmRldGFpbC50YXJnZXQpLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLXRhZycpLnZhbHVlO1xyXG4gICAgICAgIGNvcnJlY3RBbnNbYXR0cmlidXRlXSA9IChldmVudC5kZXRhaWwudGFyZ2V0KS5pbm5lckhUTUw7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ycmVjdEFucy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZihjb3JyZWN0QW5zW2ldKSA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgY29ycmVjdEFuc1tpXSA9IFwiJWJsYW5rJVwiO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhjb3JyZWN0QW5zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzdGF0ZS5saXN0QW5zID0gY29ycmVjdEFucztcclxuICAgICAgICBcclxuICAgICAgICBzdGF0ZS5yZXMgPSBzdGF0ZS5saXN0QW5zLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdXBkYXRlWG1sKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoKSB7XHJcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncG9pbnRzJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZWxbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBlbFtpXS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuPC9zY3JpcHQ+XHJcbjxtYWluPlxyXG4gICAgPGRpdiBjbGFzcz1cImdyaWRkZWRNb2R1bGVcIj5cclxuICAgICAgICA8dGFibGUgYm9yZGVyPVwiMVwiIGlkPVwidGFiMlwiIGNsYXNzPVwidGFiMlwiIHN0eWxlPXsnYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTt0ZXh0LWFsaWduOiBjZW50ZXI7JyB9ID5cclxuICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBDb2xzRmlyc3RSb3cgYXMgdmFsLGl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgdmFsLmRlY3BvaW50ID09IHRydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBzdHlsZT0nd2lkdGg6NTBweDt0ZXh0LWFsaWduOmNlbnRlcjsnICB2YWx1ZT1cIi5cIiBjbGFzcz1cInRkRm9udFwiIGRpc2FibGVkPVwidHJ1ZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD17dmFsLmlkfSBuYW1lPXt2YWwubmFtZX0gZGF0YS10YWc9e3ZhbC5kYXRhVGFnfSBzdHlsZT17J3dpZHRoOjUwcHg7dGV4dC1hbGlnbjpjZW50ZXI7J30gb246Y2hhbmdlPXtyb3dWYWxpZGF0aW9ufSBvbjppbnB1dD17aGlnaExpZ2h0fSBjbGFzcz1cInRkRm9udCBmb1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIHsjaWYgc3RhdGUucGx1c19taW51cyA9PSAxfVxyXG4gICAgICAgICAgICA8R3JpZGRlZEhlbHBlciBcclxuICAgICAgICAgICAgICAgIG9uOmhhbmRsZUNsaWNrQ29tYm89e2hhbmRsZUNsaWNrQ29tYm99XHJcbiAgICAgICAgICAgICAgICBsb29wID0ge0NvbHN9XHJcbiAgICAgICAgICAgICAgICBjbGFzczEgPSBcInRkRm9udCBwbHVzX3RhYiBwb2ludHNcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250IHBsdXNfdGFiIGl0ZW1zX2VsZW1lbnRcIlxyXG4gICAgICAgICAgICAgICAgdGFibGVJZCA9XCJwbHVzX21pbnVzX3RhYlwiXHJcbiAgICAgICAgICAgICAgICB0YWJsZUNsYXNzID1cInBsdXNfbWludXNfdGFiIGdyaWRkZWRfdGFiIG10LTAgbXlQXCJcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIrXCJcclxuICAgICAgICAgICAgPjwvR3JpZGRlZEhlbHBlcj5cclxuICAgICAgICAgICAgPEdyaWRkZWRIZWxwZXIgXHJcbiAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvPXtoYW5kbGVDbGlja0NvbWJvfVxyXG4gICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX01pbnVzfVxyXG4gICAgICAgICAgICAgICAgY2xhc3MxID0gXCJ0ZEZvbnQgcGx1c190YWJcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250IG1pbnVzX3BvaW50IHRleHQtY2VudGVyIGl0ZW1zX2VsZW1lbnRcIlxyXG4gICAgICAgICAgICAgICAgdGFibGVJZCA9XCJwbHVzX21pbnVzX3RhYlwiXHJcbiAgICAgICAgICAgICAgICB0YWJsZUNsYXNzID1cInBsdXNfbWludXNfdGFiIGdyaWRkZWRfdGFiIG10LTAgbXlQXCJcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCItXCJcclxuICAgICAgICAgICAgPjwvR3JpZGRlZEhlbHBlcj5cclxuICAgICAgICB7L2lmfVxyXG4gICAgICAgIHsjaWYgc3RhdGUuZGVjaW1hbF92YWwgPT0gMX1cclxuICAgICAgICAgICAgPEdyaWRkZWRIZWxwZXIgXHJcbiAgICAgICAgICAgICAgICBvbjpoYW5kbGVDbGlja0NvbWJvPXtoYW5kbGVDbGlja0NvbWJvfVxyXG4gICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX3NsYXNofVxyXG4gICAgICAgICAgICAgICAgY2xhc3MxID0gXCJ0ZEZvbnQgcG9pbnRzXCJcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRkRm9udCB0ZXh0LWNlbnRlciBpdGVtc19lbGVtZW50IGRlY2xfcG9pbnRcIlxyXG4gICAgICAgICAgICAgICAgdGFibGVJZCA9XCJzbGFzaF90YWJcIlxyXG4gICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJzbGFzaF90YWIgZ3JpZGRlZF90YWIgbXQtMCBteVBcIlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIi5cIlxyXG4gICAgICAgICAgICA+PC9HcmlkZGVkSGVscGVyPlxyXG4gICAgICAgIHsvaWZ9XHJcbiAgICAgICAgeyNpZiBzdGF0ZS5zbGFzaF92YWwgPT0gMX1cclxuICAgICAgICAgICAgICAgIDxHcmlkZGVkSGVscGVyIFxyXG4gICAgICAgICAgICAgICAgICAgIG9uOmhhbmRsZUNsaWNrQ29tYm89e2hhbmRsZUNsaWNrQ29tYm99XHJcbiAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHtDb2xzX3NsYXNofVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzMSA9IFwidGRGb250IHBvaW50c1wiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGRGb250IHRleHQtY2VudGVyIGl0ZW1zX2VsZW1lbnQgc2xhX3BvaW50XCJcclxuICAgICAgICAgICAgICAgICAgICB0YWJsZUlkID1cInNsYXNoX3RhYlwiXHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzcyA9XCJzbGFzaF90YWIgZ3JpZGRlZF90YWIgbXQtMCBteVBcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCIvXCJcclxuICAgICAgICAgICAgICAgID48L0dyaWRkZWRIZWxwZXI+XHJcbiAgICAgICAgey9pZn1cclxuXHJcbiAgICAgICAgPHRhYmxlIGlkPVwiZ3JpZGRlZF9zaGVldFwiIGNsYXNzPVwiZ3JpZGRlZF90YWIgbGFzdEdyaWQgbXQtMCBteVBcIj5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB7I2VhY2ggdG90YWxSb3dzIGFzIGRhdGEsIG5vfVxyXG4gICAgICAgICAgICAgICAgICAgIDx0ciBrZXk9XCJyb3d7bm99XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCB0b3RhbENvbHMgYXMgdmFsLCBpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiB2YWwuZGVjcG9pbnQgPT0gdHJ1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBrZXk9e3ZhbC5rZXl9IGNsYXNzID0ndGRGb250IHRleHQtY2VudGVyIHBvaW50cycgIHdpZHRoPVwiNTBcIiBkaXNhYmxlZD1cInRydWVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHdpZHRoPVwiNTBcIiBjbGFzcz1cInRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHRhYkluZGV4PXswfSBrZXk9e3ZhbC5rZXl9IG5hbWU9e3ZhbC5uYW1lfSBkYXRhLXRhZz17dmFsLm5hbWV9IGNsYXNzID0ndGRGb250IHRkX2RhdGEgdGV4dC1jZW50ZXIgaXRlbXNfZWxlbWVudCcgaWQ9e3ZhbC5pZH0gIG9uOmNsaWNrPXtoYW5kbGVDbGlja30+eytub308L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgIFxyXG4gICAgICAgIDwvdGFibGU+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJhY2NvcmRpb24gbXQtNVwiIGlkPVwiYWNjb3JkaW9uRXhhbXBsZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojRjBGMEYwO1wiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWNjb3JkaW9uLWl0ZW1cIj5cclxuICAgICAgICAgICAgPGgyIGNsYXNzPVwiYWNjb3JkaW9uLWhlYWRlciBtdC0wXCIgaWQ9XCJoZWFkaW5nT25lXCI+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYWNjb3JkaW9uLWJ1dHRvbiBjb2xsYXBzZWQgcHktMFwiIHR5cGU9XCJidXR0b25cIiBkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCIgZGF0YS1icy10YXJnZXQ9XCIjY29sbGFwc2VPbmVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIiBhcmlhLWNvbnRyb2xzPVwiY29sbGFwc2VPbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICB7bC5sYXlvdXRfb3B0aW9uc31cclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2gyPlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwiY29sbGFwc2VPbmVcIiBjbGFzcz1cImFjY29yZGlvbi1jb2xsYXBzZSBjb2xsYXBzZVwiIGFyaWEtbGFiZWxsZWRieT1cImhlYWRpbmdPbmVcIiBkYXRhLWJzLXBhcmVudD1cIiNhY2NvcmRpb25FeGFtcGxlXCIgc3R5bGU9XCJcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhY2NvcmRpb24tYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvbnQtd2VpZ2h0LWJvbGRcIj57bC5yb3dfY291bnR9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPVwiMVwiIG1heD1cIjEwXCIgIHZhbHVlPXtzdGF0ZS5yb3dOdW19IG5hbWU9XCJjb2xfcmFuZ2VcIiBpZD1cImNvbF9yYW5nZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sICBpbmxpbmUtYmxvY2tcIiBkYXRhLWxhYmVsPVwiTnVtYmVyIG9mIHJvd3NcIiBvbjpjaGFuZ2U9e2NoYW5nZVJvd0NvbH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS02XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9udC13ZWlnaHQtYm9sZFwiPntsLmNvbF9jb3VudH08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49XCIxXCIgbWF4PVwiNlwiICB2YWx1ZT17c3RhdGUuY29sTnVtfSBuYW1lPVwiY29sX25tYnJcIiBpZD1cImNvbF9yYW5nZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sICBpbmxpbmUtYmxvY2tcIiBkYXRhLWxhYmVsPVwiTnVtYmVyIG9mIHJvd3NcIiBvbjpjaGFuZ2U9e2NoYW5nZVJvd0NvbH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS02XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5saW5lLWJsb2NrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImN1c3RvbV9jaGVja2JveF9uZXcgZmxvYXQtbGVmdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcInBsdXNfbWludXNfY2hlY2tib3hcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0UHJvcHM9e3sgJ2FyaWEtbGFiZWwnOiAnUGx1cy9NaW51cyBDb2x1bW4nIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2sgPSB7cGx1c01pbnVzU2V0VmFsfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPjxsYWJlbCBmb3I9XCJwbHVzX21pbnVzX2NoZWNrYm94XCIgY2xhc3M9XCJwbC0xXCI+UGx1cy9NaW51cyBDb2x1bW48L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTZcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbmxpbmUtYmxvY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkID0gXCJmcmFjdGlvbl9zbGFzaF9jaGVja2JveFwiIGNsYXNzPVwiY3VzdG9tX2NoZWNrYm94X25ldyBmbG9hdC1sZWZ0XCIgaW5wdXRQcm9wcz17eyAnYXJpYS1sYWJlbCc6ICdGcmFjdGlvbi9TbGFzaCcgfX0gb246Y2xpY2sgPSB7c2xhc2hGdW5jU2V0VmFsfSAvPjxsYWJlbCBmb3IgPSBcImZyYWN0aW9uX3NsYXNoX2NoZWNrYm94XCIgY2xhc3M9XCJwbC0xXCI+RnJhY3Rpb24vU2xhc2g8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTZcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlubGluZS1ibG9ja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZCA9IFwiZml4ZWRfZGVjaW1hbF9jaGVja2JveFwiIGNsYXNzPVwiY3VzdG9tX2NoZWNrYm94X25ldyBmbG9hdC1sZWZ0XCIgaW5wdXRQcm9wcz17eyAnYXJpYS1sYWJlbCc6ICdGaXhlZCBEZWNpbWFsJyB9fSBvbjpjbGljayA9IHtmaXhlZEZ1bmN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz4gPGxhYmVsIGZvcj1cImZpeGVkX2RlY2ltYWxfY2hlY2tib3hcIiBjbGFzcz1cInBsLTFcIj4gRml4ZWQgRGVjaW1hbDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5saW5lLWJsb2NrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQgPSBcImZsb2F0aW5nX2RlY2ltYWxfY2hlY2tib3hcIiBjbGFzcz1cImN1c3RvbV9jaGVja2JveF9uZXcgZmxvYXQtbGVmdFwiIGlucHV0UHJvcHM9e3sgJ2FyaWEtbGFiZWwnOiAnRmxvYXRpbmcgRGVjaW1hbCcgfX0gb246Y2xpY2sgPSB7ZGVjaW1hbEZ1bmNTZXRWYWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPjxsYWJlbCBmb3I9XCJmbG9hdGluZ19kZWNpbWFsX2NoZWNrYm94XCIgY2xhc3M9XCJwbC0xXCI+RmxvYXRpbmcgRGVjaW1hbDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTYgaW5saW5lLWJsb2NrIHBsLTBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj1cIjFcIiBtYXg9XCI3XCIgIG5hbWU9XCJGaXhlZF9kZWNpbWFsX2NvbHVtblwiIGlkPVwiRml4ZWRfZGVjaW1hbF9jb2x1bW5cIiBjbGFzcz1cImZvcm0tY29udHJvbCAgaW5saW5lLWJsb2NrXCIgcGxhY2Vob2xkZXI9XCJGaXhlZCBkZWNpbWFsIGNvbHVtblwiIHN0eWxlPXsnZGlzcGxheTogbm9uZSd9IGRhdGEtbGFiZWw9XCJGaXhlZCBkZWNpbWFsIGNvbHVtblwiIGRpc2FibGVkPVwidHJ1ZVwiIG9uOmNoYW5nZT17Zml4ZWREZWNpbWFsUG9pbnRzfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvbWFpbj5cclxuPHN0eWxlPlxyXG4gICAgLmN1c3RvbV9jaGVja2JveF9uZXcge1xyXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgICAgICB3aWR0aDogMjBweDtcclxuICAgICAgICBoZWlnaHQ6IDIwcHg7XHJcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcclxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xyXG4gICAgfVxyXG5cclxuOmdsb2JhbCgubGF5b3V0SGVhZGluZykge1xyXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICBmb250LXNpemU6IDE2cHg7XHJcbiAgICBjb2xvcjogIzE4NzdiMTtcclxufVxyXG5cclxuOmdsb2JhbCguaXRlbXNfZWxlbWVudDpob3Zlcikge1xyXG4gICAgYm9yZGVyOiAxLjJweCBzb2xpZCAjNzc3O1xyXG59XHJcblxyXG46Z2xvYmFsKC5tb3JlT3B0aW9ucykge1xyXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiAzcHggNHB4IDZweCAjYzRjNWM1O1xyXG4gICAgLW1vei1ib3gtc2hhZG93OiAzcHggNHB4IDZweCAjYzRjNWM1O1xyXG4gICAgYm94LXNoYWRvdzogM3B4IDRweCA2cHggI2M0YzVjNTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XHJcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgIzE4NzdiMTtcclxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjMTg3N2IxO1xyXG59XHJcblxyXG46Z2xvYmFsKC5tb3JlT3B0aW9uRGV0YWlscykge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcclxufVxyXG5cclxuOmdsb2JhbCguaW5wdXRfY29sKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBsZWZ0OiA1cHg7XHJcbn1cclxuXHJcbjpnbG9iYWwoLmxheW91dGhlYWRpbmcpIHtcclxuICAgIHBhZGRpbmc6IDVweDtcclxuICAgIGZvbnQtc2l6ZTogMjBweDtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG59XHJcblxyXG5cclxuOmdsb2JhbCgubnVtYnJfcmFuZ2UpIHtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIGxlZnQ6IDEzMHB4O1xyXG59XHJcblxyXG46Z2xvYmFsKC5udW1icl9yYW5nZV90eHQpIHtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIGxlZnQ6IDIwMHB4O1xyXG59XHJcblxyXG46Z2xvYmFsKC5wbHVzX21pbnVzX2ZyYWN0aW9uKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB0b3A6IDIwcHg7XHJcbn1cclxuXHJcbjpnbG9iYWwoLmZsb2F0aW5nX2ZyYWN0aW9uKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB0b3A6IDI3cHg7XHJcbn1cclxuXHJcbjpnbG9iYWwoLnBsdXNfbWludXNfc3Bhbikge1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgbGVmdDogNXB4O1xyXG59XHJcblxyXG46Z2xvYmFsKC5mbG9hdGluZ19kZWNpbWFsKSB7XHJcbiAgICBmbG9hdDogcmlnaHQ7XHJcbiAgICBtYXJnaW4tcmlnaHQ6IDQ1cHg7XHJcbn1cclxuXHJcbjpnbG9iYWwoLmZvbnRTdHlsZSkge1xyXG4gICAgd2lkdGg6IDEwMHB4O1xyXG4gICAgZmxvYXQ6IHJpZ2h0O1xyXG4gICAgbWFyZ2luLXJpZ2h0OiA2MHB4O1xyXG59XHJcblxyXG46Z2xvYmFsKC5mcmFjdGlvbl9zbGFzaCkge1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgbGVmdDogMTc3cHg7XHJcbn1cclxuXHJcbjpnbG9iYWwoLm1pbnVzX3RhYixcclxuLnBsdXNfdGFiLFxyXG4uc2xhc2hfdGFiKSB7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbn1cclxuXHJcbi5ncmlkZGVkX3RhYiB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjBmMGYwO1xyXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcclxufVxyXG5cclxuOmdsb2JhbCguZm9udF9zaXplX2xhYmVsKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBsZWZ0OiAxOThweDtcclxufVxyXG5cclxuOmdsb2JhbCguZm9udF9zaXplKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBsZWZ0OiAyMjVweDtcclxufVxyXG5cclxuXHJcbjpnbG9iYWwoLmRlY2ltYWxfY29sKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBsZWZ0OiAyMDhweDtcclxuICAgIHdpZHRoOiA5MHB4O1xyXG59XHJcblxyXG46Z2xvYmFsKC5jb3JyZWN0X2NvbG9yKSB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRTlGRkU5O1xyXG59XHJcblxyXG46Z2xvYmFsKC5maXhlZF9kZWNpbWFsX2NoZWNrKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB0b3A6IDI2cHg7XHJcbiAgICBsZWZ0OiAxM3B4O1xyXG59XHJcblxyXG46Z2xvYmFsKC5jb3JyZWN0X2luY29ycmVjdF9pY29uX2ZpbGwpIHtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIHdpZHRoOiAxOXB4O1xyXG4gICAgaGVpZ2h0OiAxOXB4O1xyXG4gICAgcmlnaHQ6IDEyMXB4O1xyXG4gICAgdG9wOiAtNTVweDtcclxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG59XHJcblxyXG46Z2xvYmFsKC5yb3dfY29sdW1uX2RlY2ltYWwpIHtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIHRvcDogMzBweDtcclxuICAgIGxlZnQ6IDVweDtcclxuXHJcbn1cclxuXHJcbjpnbG9iYWwoLmZpeGVkX3BvaW50X2NsYXNzKSB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICBsZWZ0OiA3cHg7XHJcbn1cclxuXHJcbjpnbG9iYWwoLnJvd19jb2x1bW4pIHtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIGxlZnQ6IDVweDtcclxufVxyXG5cclxuOmdsb2JhbCguYW5zd2VyX2ljb24pIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHRvcDogM3B4O1xyXG4gICAgcmlnaHQ6IDM0cHg7XHJcbn1cclxuXHJcbi5teVAgdGJvZHkge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcblxyXG46Z2xvYmFsKC5jb2xfcmFuZ2UpIHtcclxuICAgIHdpZHRoOiAyMDVweDtcclxufVxyXG5cclxuOmdsb2JhbCgucG9zU2l6ZSkge1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgbGVmdDogN3B4O1xyXG59XHJcblxyXG46Z2xvYmFsKC5mb250U21hbGwpIHtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxufVxyXG5cclxuOmdsb2JhbCguZm9udE5vcm1hbCkge1xyXG4gICAgZm9udC1zaXplOiAxNHB4O1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG59XHJcblxyXG46Z2xvYmFsKC5mb250TGFyZ2UpIHtcclxuICAgIGZvbnQtc2l6ZTogMjRweDtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxufVxyXG5cclxuOmdsb2JhbCguZm9udEV4dHJhTGFyZ2UpIHtcclxuICAgIGZvbnQtc2l6ZTogMjZweDtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxufVxyXG5cclxuOmdsb2JhbCguZ3JpZCkge1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgdG9wOiAxMHB4O1xyXG4gICAgYm94LXNoYWRvdzogMTBweCA1cHggMTBweCAjMDAwO1xyXG59XHJcblxyXG46Z2xvYmFsKC5pdGVtc19lbGVtZW50KSB7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjODA4MDgwN2E7XHJcbiAgICBwYWRkaW5nOiA2cHggMTBweDtcclxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG59XHJcblxyXG46Z2xvYmFsKC5ncmlkZGVkTW9kdWxlIC5hY3RpdmUpIHtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIHRyYW5zaXRpb246IDFzO1xyXG4gICAgYmFja2dyb3VuZDogIzY5Njk2OTtcclxuICAgIGJvcmRlcjogMnB4IHNvbGlkICNmZmY7XHJcbn1cclxuXHJcbi5taW51c19wb2ludCxcclxuLmRlY2xfcG9pbnQge1xyXG4gICAgcGFkZGluZzogNnB4IDEycHg7XHJcbn1cclxuXHJcbjpnbG9iYWwoLnNsYV9wb2ludCkge1xyXG4gICAgcGFkZGluZzogNnB4IDExcHg7XHJcbn1cclxuXHJcbi5ncmlkZGVkTW9kdWxlIHRhYmxlIHRyIHRkOmxhc3QtY2hpbGQge1xyXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2NjYyAhaW1wb3J0YW50O1xyXG59XHJcblxyXG4uZ3JpZGRlZE1vZHVsZSAubGFzdEdyaWQgdHI6bGFzdC1jaGlsZCB0ZCB7XHJcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYyAhaW1wb3J0YW50O1xyXG59XHJcblxyXG46Z2xvYmFsKC5ncmlkZGVkTW9kdWxlIHRkKSB7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZjBmMGYwICFpbXBvcnRhbnQ7XHJcbiAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNjY2MgIWltcG9ydGFudDtcclxufVxyXG5cclxuOmdsb2JhbCgudG9rZW46aG92ZXIpIHtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkICMwMDAgIWltcG9ydGFudDtcclxufVxyXG5cclxuOmdsb2JhbCguYmxhIC50b2tlbjpob3Zlcikge1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZiAhaW1wb3J0YW50O1xyXG59XHJcblxyXG46Z2xvYmFsKC50b2tlbl9zZWxlY3RlZCkge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzY0YmI2MztcclxuICAgIGNvbG9yOiAjZmZmO1xyXG59XHJcblxyXG46Z2xvYmFsKC5ibGEgLnRva2VuX2hpZ2hsaWdodF9oZWFkaW5nKSB7XHJcbiAgICBjb2xvcjogIzAwMCAhaW1wb3J0YW50O1xyXG59XHJcblxyXG46Z2xvYmFsKC5ncmlkZGVkTW9kdWxlIC5leHBhbmRJY29uKSB7XHJcbiAgICBmb250LXNpemU6IDI3cHg7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIGNvbG9yOiAjMTg3N2IxO1xyXG59XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE4ckJJLG9CQUFvQiw4QkFBQyxDQUFDLEFBQ2xCLE9BQU8sQ0FBRSxLQUFLLENBQ2QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLGFBQWEsQ0FBRSxDQUFDLENBQ2hCLE1BQU0sQ0FBRSxPQUFPLENBQ2YsU0FBUyxDQUFFLElBQUksQUFDbkIsQ0FBQyxBQUVHLGNBQWMsQUFBRSxDQUFDLEFBQ3JCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsS0FBSyxDQUFFLE9BQU8sQUFDbEIsQ0FBQyxBQUVPLG9CQUFvQixBQUFFLENBQUMsQUFDM0IsTUFBTSxDQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxBQUM1QixDQUFDLEFBRU8sWUFBWSxBQUFFLENBQUMsQUFDbkIsa0JBQWtCLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUN2QyxlQUFlLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUNwQyxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUMvQixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLFVBQVUsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDN0IsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxBQUNwQyxDQUFDLEFBRU8sa0JBQWtCLEFBQUUsQ0FBQyxBQUN6QixnQkFBZ0IsQ0FBRSxPQUFPLEFBQzdCLENBQUMsQUFFTyxVQUFVLEFBQUUsQ0FBQyxBQUNqQixRQUFRLENB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 */";
	append_dev(document_1.head, style);
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[32] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

// (565:24) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_id_value;
	let input_name_value;
	let input_data_tag_value;
	let input_style_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			attr_dev(input, "id", input_id_value = /*val*/ ctx[33].id);
			attr_dev(input, "name", input_name_value = /*val*/ ctx[33].name);
			attr_dev(input, "data-tag", input_data_tag_value = /*val*/ ctx[33].dataTag);
			attr_dev(input, "style", input_style_value = "width:50px;text-align:center;");
			attr_dev(input, "class", "tdFont fo");
			add_location(input, file, 565, 32, 19293);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*rowValidation*/ ctx[13], false, false, false),
					listen_dev(input, "input", highLight, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsFirstRow*/ 64 && input_id_value !== (input_id_value = /*val*/ ctx[33].id)) {
				attr_dev(input, "id", input_id_value);
			}

			if (dirty[0] & /*ColsFirstRow*/ 64 && input_name_value !== (input_name_value = /*val*/ ctx[33].name)) {
				attr_dev(input, "name", input_name_value);
			}

			if (dirty[0] & /*ColsFirstRow*/ 64 && input_data_tag_value !== (input_data_tag_value = /*val*/ ctx[33].dataTag)) {
				attr_dev(input, "data-tag", input_data_tag_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(565:24) {:else}",
		ctx
	});

	return block;
}

// (563:24) {#if val.decpoint == true}
function create_if_block_4(ctx) {
	let input;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "text");
			set_style(input, "width", "50px");
			set_style(input, "text-align", "center");
			input.value = ".";
			attr_dev(input, "class", "tdFont");
			input.disabled = "true";
			add_location(input, file, 563, 28, 19125);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(563:24) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (562:20) {#each ColsFirstRow as val,i}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*val*/ ctx[33].decpoint == true) return create_if_block_4;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(562:20) {#each ColsFirstRow as val,i}",
		ctx
	});

	return block;
}

// (572:8) {#if state.plus_minus == 1}
function create_if_block_3(ctx) {
	let griddedhelper0;
	let t;
	let griddedhelper1;
	let current;

	griddedhelper0 = new GriddedHelper({
			props: {
				loop: /*Cols*/ ctx[5],
				class1: "tdFont plus_tab points",
				className: "tdFont plus_tab items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "+"
			},
			$$inline: true
		});

	griddedhelper0.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	griddedhelper1 = new GriddedHelper({
			props: {
				loop: /*Cols_Minus*/ ctx[4],
				class1: "tdFont plus_tab",
				className: "tdFont minus_point text-center items_element",
				tableId: "plus_minus_tab",
				tableClass: "plus_minus_tab gridded_tab mt-0 myP",
				value: "-"
			},
			$$inline: true
		});

	griddedhelper1.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(griddedhelper0.$$.fragment);
			t = space();
			create_component(griddedhelper1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(griddedhelper1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper0_changes = {};
			if (dirty[0] & /*Cols*/ 32) griddedhelper0_changes.loop = /*Cols*/ ctx[5];
			griddedhelper0.$set(griddedhelper0_changes);
			const griddedhelper1_changes = {};
			if (dirty[0] & /*Cols_Minus*/ 16) griddedhelper1_changes.loop = /*Cols_Minus*/ ctx[4];
			griddedhelper1.$set(griddedhelper1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper0.$$.fragment, local);
			transition_in(griddedhelper1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper0.$$.fragment, local);
			transition_out(griddedhelper1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(griddedhelper1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(572:8) {#if state.plus_minus == 1}",
		ctx
	});

	return block;
}

// (592:8) {#if state.decimal_val == 1}
function create_if_block_2(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[3],
				class1: "tdFont points",
				className: "tdFont text-center items_element decl_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 myP",
				value: "."
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 8) griddedhelper_changes.loop = /*Cols_slash*/ ctx[3];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(592:8) {#if state.decimal_val == 1}",
		ctx
	});

	return block;
}

// (603:8) {#if state.slash_val == 1}
function create_if_block_1(ctx) {
	let griddedhelper;
	let current;

	griddedhelper = new GriddedHelper({
			props: {
				loop: /*Cols_slash*/ ctx[3],
				class1: "tdFont points",
				className: "tdFont text-center items_element sla_point",
				tableId: "slash_tab",
				tableClass: "slash_tab gridded_tab mt-0 myP",
				value: "/"
			},
			$$inline: true
		});

	griddedhelper.$on("handleClickCombo", /*handleClickCombo*/ ctx[15]);

	const block = {
		c: function create() {
			create_component(griddedhelper.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(griddedhelper, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const griddedhelper_changes = {};
			if (dirty[0] & /*Cols_slash*/ 8) griddedhelper_changes.loop = /*Cols_slash*/ ctx[3];
			griddedhelper.$set(griddedhelper_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(griddedhelper.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(griddedhelper.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(griddedhelper, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(603:8) {#if state.slash_val == 1}",
		ctx
	});

	return block;
}

// (624:28) {:else}
function create_else_block(ctx) {
	let td;
	let span;
	let t_value = +/*no*/ ctx[32] + "";
	let t;
	let span_tabindex_value;
	let span_key_value;
	let span_name_value;
	let span_data_tag_value;
	let span_id_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			td = element("td");
			span = element("span");
			t = text(t_value);
			attr_dev(span, "tabindex", span_tabindex_value = 0);
			attr_dev(span, "key", span_key_value = /*val*/ ctx[33].key);
			attr_dev(span, "name", span_name_value = /*val*/ ctx[33].name);
			attr_dev(span, "data-tag", span_data_tag_value = /*val*/ ctx[33].name);
			attr_dev(span, "class", "tdFont td_data text-center items_element");
			attr_dev(span, "id", span_id_value = /*val*/ ctx[33].id);
			add_location(span, file, 625, 36, 21994);
			attr_dev(td, "width", "50");
			attr_dev(td, "class", "text-center svelte-1wrfq8n");
			add_location(td, file, 624, 32, 21921);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, span);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*handleClick*/ ctx[14], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 4 && span_key_value !== (span_key_value = /*val*/ ctx[33].key)) {
				attr_dev(span, "key", span_key_value);
			}

			if (dirty[0] & /*totalCols*/ 4 && span_name_value !== (span_name_value = /*val*/ ctx[33].name)) {
				attr_dev(span, "name", span_name_value);
			}

			if (dirty[0] & /*totalCols*/ 4 && span_data_tag_value !== (span_data_tag_value = /*val*/ ctx[33].name)) {
				attr_dev(span, "data-tag", span_data_tag_value);
			}

			if (dirty[0] & /*totalCols*/ 4 && span_id_value !== (span_id_value = /*val*/ ctx[33].id)) {
				attr_dev(span, "id", span_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(624:28) {:else}",
		ctx
	});

	return block;
}

// (620:28) {#if val.decpoint == true}
function create_if_block(ctx) {
	let td;
	let td_key_value;

	const block = {
		c: function create() {
			td = element("td");
			attr_dev(td, "key", td_key_value = /*val*/ ctx[33].key);
			attr_dev(td, "class", "tdFont text-center points svelte-1wrfq8n");
			attr_dev(td, "width", "50");
			attr_dev(td, "disabled", "true");
			add_location(td, file, 620, 28, 21700);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols*/ 4 && td_key_value !== (td_key_value = /*val*/ ctx[33].key)) {
				attr_dev(td, "key", td_key_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(620:28) {#if val.decpoint == true}",
		ctx
	});

	return block;
}

// (619:24) {#each totalCols as val, i}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*val*/ ctx[33].decpoint == true) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(619:24) {#each totalCols as val, i}",
		ctx
	});

	return block;
}

// (617:16) {#each totalRows as data, no}
function create_each_block(ctx) {
	let tr;
	let t;
	let tr_key_value;
	let each_value_1 = /*totalCols*/ ctx[2];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "key", tr_key_value = "row" + /*no*/ ctx[32]);
			add_location(tr, file, 617, 20, 21543);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*totalCols, handleClick*/ 16388) {
				each_value_1 = /*totalCols*/ ctx[2];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(617:16) {#each totalRows as data, no}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let main;
	let div23;
	let table0;
	let tbody;
	let tr;
	let table0_style_value;
	let t0;
	let t1;
	let t2;
	let t3;
	let table1;
	let t4;
	let div22;
	let div21;
	let h2;
	let button;
	let t6;
	let div20;
	let div19;
	let div6;
	let div2;
	let div0;
	let t8;
	let div1;
	let input0;
	let input0_value_value;
	let t9;
	let div5;
	let div3;
	let t11;
	let div4;
	let input1;
	let input1_value_value;
	let t12;
	let div11;
	let div8;
	let div7;
	let input2;
	let input2_inputprops_value;
	let label0;
	let t14;
	let div10;
	let div9;
	let input3;
	let input3_inputprops_value;
	let label1;
	let t16;
	let div16;
	let div13;
	let div12;
	let input4;
	let input4_inputprops_value;
	let t17;
	let label2;
	let t19;
	let div15;
	let div14;
	let input5;
	let input5_inputprops_value;
	let label3;
	let t21;
	let div18;
	let div17;
	let input6;
	let input6_style_value;
	let current;
	let mounted;
	let dispose;
	let each_value_2 = /*ColsFirstRow*/ ctx[6];
	validate_each_argument(each_value_2);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block0 = /*state*/ ctx[0].plus_minus == 1 && create_if_block_3(ctx);
	let if_block1 = /*state*/ ctx[0].decimal_val == 1 && create_if_block_2(ctx);
	let if_block2 = /*state*/ ctx[0].slash_val == 1 && create_if_block_1(ctx);
	let each_value = /*totalRows*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			main = element("main");
			div23 = element("div");
			table0 = element("table");
			tbody = element("tbody");
			tr = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			table1 = element("table");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div22 = element("div");
			div21 = element("div");
			h2 = element("h2");
			button = element("button");
			button.textContent = `${language.layout_options}`;
			t6 = space();
			div20 = element("div");
			div19 = element("div");
			div6 = element("div");
			div2 = element("div");
			div0 = element("div");
			div0.textContent = `${language.row_count}`;
			t8 = space();
			div1 = element("div");
			input0 = element("input");
			t9 = space();
			div5 = element("div");
			div3 = element("div");
			div3.textContent = `${language.col_count}`;
			t11 = space();
			div4 = element("div");
			input1 = element("input");
			t12 = space();
			div11 = element("div");
			div8 = element("div");
			div7 = element("div");
			input2 = element("input");
			label0 = element("label");
			label0.textContent = "Plus/Minus Column";
			t14 = space();
			div10 = element("div");
			div9 = element("div");
			input3 = element("input");
			label1 = element("label");
			label1.textContent = "Fraction/Slash";
			t16 = space();
			div16 = element("div");
			div13 = element("div");
			div12 = element("div");
			input4 = element("input");
			t17 = space();
			label2 = element("label");
			label2.textContent = "Fixed Decimal";
			t19 = space();
			div15 = element("div");
			div14 = element("div");
			input5 = element("input");
			label3 = element("label");
			label3.textContent = "Floating Decimal";
			t21 = space();
			div18 = element("div");
			div17 = element("div");
			input6 = element("input");
			add_location(tr, file, 560, 16, 18988);
			add_location(tbody, file, 559, 12, 18963);
			attr_dev(table0, "border", "1");
			attr_dev(table0, "id", "tab2");
			attr_dev(table0, "class", "tab2");
			attr_dev(table0, "style", table0_style_value = "border-collapse: collapse;text-align: center;");
			add_location(table0, file, 558, 8, 18850);
			attr_dev(table1, "id", "gridded_sheet");
			attr_dev(table1, "class", "gridded_tab lastGrid mt-0 myP svelte-1wrfq8n");
			add_location(table1, file, 614, 8, 21396);
			attr_dev(button, "class", "accordion-button collapsed py-0");
			attr_dev(button, "type", "button");
			attr_dev(button, "data-bs-toggle", "collapse");
			attr_dev(button, "data-bs-target", "#collapseOne");
			attr_dev(button, "aria-expanded", "false");
			attr_dev(button, "aria-controls", "collapseOne");
			add_location(button, file, 637, 16, 22571);
			attr_dev(h2, "class", "accordion-header mt-0");
			attr_dev(h2, "id", "headingOne");
			add_location(h2, file, 636, 12, 22503);
			attr_dev(div0, "class", "font-weight-bold");
			add_location(div0, file, 646, 28, 23162);
			attr_dev(input0, "type", "number");
			attr_dev(input0, "min", "1");
			attr_dev(input0, "max", "10");
			input0.value = input0_value_value = /*state*/ ctx[0].rowNum;
			attr_dev(input0, "name", "col_range");
			attr_dev(input0, "id", "col_range");
			attr_dev(input0, "class", "form-control  inline-block");
			attr_dev(input0, "data-label", "Number of rows");
			add_location(input0, file, 648, 32, 23280);
			add_location(div1, file, 647, 28, 23241);
			attr_dev(div2, "class", "col-sm-6");
			add_location(div2, file, 645, 24, 23110);
			attr_dev(div3, "class", "font-weight-bold");
			add_location(div3, file, 652, 28, 23608);
			attr_dev(input1, "type", "number");
			attr_dev(input1, "min", "1");
			attr_dev(input1, "max", "6");
			input1.value = input1_value_value = /*state*/ ctx[0].colNum;
			attr_dev(input1, "name", "col_nmbr");
			attr_dev(input1, "id", "col_range");
			attr_dev(input1, "class", "form-control  inline-block");
			attr_dev(input1, "data-label", "Number of rows");
			add_location(input1, file, 654, 32, 23726);
			add_location(div4, file, 653, 28, 23687);
			attr_dev(div5, "class", "col-sm-6");
			add_location(div5, file, 651, 24, 23556);
			attr_dev(div6, "class", "row form-group");
			add_location(div6, file, 643, 20, 23038);
			attr_dev(input2, "type", "checkbox");
			attr_dev(input2, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input2, "id", "plus_minus_checkbox");
			attr_dev(input2, "inputprops", input2_inputprops_value = { "aria-label": "Plus/Minus Column" });
			add_location(input2, file, 662, 36, 24216);
			attr_dev(label0, "for", "plus_minus_checkbox");
			attr_dev(label0, "class", "pl-1");
			add_location(label0, file, 666, 38, 24559);
			attr_dev(div7, "class", "inline-block");
			add_location(div7, file, 661, 28, 24152);
			attr_dev(div8, "class", "col-sm-6");
			add_location(div8, file, 660, 24, 24100);
			attr_dev(input3, "type", "checkbox");
			attr_dev(input3, "id", "fraction_slash_checkbox");
			attr_dev(input3, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input3, "inputprops", input3_inputprops_value = { "aria-label": "Fraction/Slash" });
			add_location(input3, file, 671, 36, 24840);
			attr_dev(label1, "for", "fraction_slash_checkbox");
			attr_dev(label1, "class", "pl-1");
			add_location(label1, file, 671, 208, 25012);
			attr_dev(div9, "class", "inline-block");
			add_location(div9, file, 670, 28, 24776);
			attr_dev(div10, "class", "col-sm-6");
			add_location(div10, file, 669, 24, 24724);
			attr_dev(div11, "class", "row form-group");
			add_location(div11, file, 659, 20, 24046);
			attr_dev(input4, "type", "checkbox");
			attr_dev(input4, "id", "fixed_decimal_checkbox");
			attr_dev(input4, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input4, "inputprops", input4_inputprops_value = { "aria-label": "Fixed Decimal" });
			add_location(input4, file, 679, 32, 25364);
			attr_dev(label2, "for", "fixed_decimal_checkbox");
			attr_dev(label2, "class", "pl-1");
			add_location(label2, file, 680, 35, 25562);
			attr_dev(div12, "class", "inline-block");
			add_location(div12, file, 678, 24, 25304);
			attr_dev(div13, "class", "col-sm-6");
			add_location(div13, file, 677, 20, 25256);
			attr_dev(input5, "type", "checkbox");
			attr_dev(input5, "id", "floating_decimal_checkbox");
			attr_dev(input5, "class", "custom_checkbox_new float-left svelte-1wrfq8n");
			attr_dev(input5, "inputprops", input5_inputprops_value = { "aria-label": "Floating Decimal" });
			add_location(input5, file, 685, 28, 25819);
			attr_dev(label3, "for", "floating_decimal_checkbox");
			attr_dev(label3, "class", "pl-1");
			add_location(label3, file, 686, 30, 26026);
			attr_dev(div14, "class", "inline-block");
			add_location(div14, file, 684, 24, 25763);
			attr_dev(div15, "class", "col-sm-6");
			add_location(div15, file, 683, 20, 25715);
			attr_dev(div16, "class", "row form-group");
			add_location(div16, file, 676, 16, 25206);
			attr_dev(input6, "type", "number");
			attr_dev(input6, "min", "1");
			attr_dev(input6, "max", "7");
			attr_dev(input6, "name", "Fixed_decimal_column");
			attr_dev(input6, "id", "Fixed_decimal_column");
			attr_dev(input6, "class", "form-control  inline-block");
			attr_dev(input6, "placeholder", "Fixed decimal column");
			attr_dev(input6, "style", input6_style_value = "display: none");
			attr_dev(input6, "data-label", "Fixed decimal column");
			input6.disabled = "true";
			add_location(input6, file, 692, 24, 26297);
			add_location(div17, file, 691, 20, 26266);
			attr_dev(div18, "class", "col-sm-6 inline-block pl-0");
			add_location(div18, file, 690, 16, 26204);
			attr_dev(div19, "class", "accordion-body");
			add_location(div19, file, 642, 16, 22988);
			attr_dev(div20, "id", "collapseOne");
			attr_dev(div20, "class", "accordion-collapse collapse");
			attr_dev(div20, "aria-labelledby", "headingOne");
			attr_dev(div20, "data-bs-parent", "#accordionExample");
			add_location(div20, file, 641, 12, 22839);
			attr_dev(div21, "class", "accordion-item");
			add_location(div21, file, 635, 12, 22461);
			attr_dev(div22, "class", "accordion mt-5");
			attr_dev(div22, "id", "accordionExample");
			set_style(div22, "background-color", "#F0F0F0");
			add_location(div22, file, 634, 8, 22363);
			attr_dev(div23, "class", "griddedModule svelte-1wrfq8n");
			add_location(div23, file, 557, 4, 18813);
			add_location(main, file, 556, 0, 18801);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div23);
			append_dev(div23, table0);
			append_dev(table0, tbody);
			append_dev(tbody, tr);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append_dev(div23, t0);
			if (if_block0) if_block0.m(div23, null);
			append_dev(div23, t1);
			if (if_block1) if_block1.m(div23, null);
			append_dev(div23, t2);
			if (if_block2) if_block2.m(div23, null);
			append_dev(div23, t3);
			append_dev(div23, table1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(table1, null);
			}

			append_dev(div23, t4);
			append_dev(div23, div22);
			append_dev(div22, div21);
			append_dev(div21, h2);
			append_dev(h2, button);
			append_dev(div21, t6);
			append_dev(div21, div20);
			append_dev(div20, div19);
			append_dev(div19, div6);
			append_dev(div6, div2);
			append_dev(div2, div0);
			append_dev(div2, t8);
			append_dev(div2, div1);
			append_dev(div1, input0);
			append_dev(div6, t9);
			append_dev(div6, div5);
			append_dev(div5, div3);
			append_dev(div5, t11);
			append_dev(div5, div4);
			append_dev(div4, input1);
			append_dev(div19, t12);
			append_dev(div19, div11);
			append_dev(div11, div8);
			append_dev(div8, div7);
			append_dev(div7, input2);
			append_dev(div7, label0);
			append_dev(div11, t14);
			append_dev(div11, div10);
			append_dev(div10, div9);
			append_dev(div9, input3);
			append_dev(div9, label1);
			append_dev(div19, t16);
			append_dev(div19, div16);
			append_dev(div16, div13);
			append_dev(div13, div12);
			append_dev(div12, input4);
			append_dev(div12, t17);
			append_dev(div12, label2);
			append_dev(div16, t19);
			append_dev(div16, div15);
			append_dev(div15, div14);
			append_dev(div14, input5);
			append_dev(div14, label3);
			append_dev(div19, t21);
			append_dev(div19, div18);
			append_dev(div18, div17);
			append_dev(div17, input6);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input0, "change", /*changeRowCol*/ ctx[11], false, false, false),
					listen_dev(input1, "change", /*changeRowCol*/ ctx[11], false, false, false),
					listen_dev(input2, "click", /*plusMinusSetVal*/ ctx[7], false, false, false),
					listen_dev(input3, "click", /*slashFuncSetVal*/ ctx[8], false, false, false),
					listen_dev(input4, "click", /*fixedFunc*/ ctx[9], false, false, false),
					listen_dev(input5, "click", /*decimalFuncSetVal*/ ctx[10], false, false, false),
					listen_dev(input6, "change", /*fixedDecimalPoints*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ColsFirstRow, rowValidation*/ 8256) {
				each_value_2 = /*ColsFirstRow*/ ctx[6];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (/*state*/ ctx[0].plus_minus == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*state*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div23, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[0].decimal_val == 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*state*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div23, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*state*/ ctx[0].slash_val == 1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*state*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div23, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*totalCols, handleClick, totalRows*/ 16390) {
				each_value = /*totalRows*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(table1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*state*/ 1 && input0_value_value !== (input0_value_value = /*state*/ ctx[0].rowNum)) {
				prop_dev(input0, "value", input0_value_value);
			}

			if (!current || dirty[0] & /*state*/ 1 && input1_value_value !== (input1_value_value = /*state*/ ctx[0].colNum)) {
				prop_dev(input1, "value", input1_value_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_each(each_blocks_1, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function highLight(event) {
	let cell_class = event.target.getAttribute("name");
	let column_index = document.getElementsByName(cell_class);

	for (let i = 1; i < column_index.length; i++) {
		if (column_index[i].classList.contains("active")) {
			column_index[i].classList.remove("active");
		}

		if (column_index[i].innerHTML == event.target.value) {
			column_index[i].classList.add("active");
		}
	}
}

function removeClass() {
	let el = document.getElementsByClassName("points");

	for (let i = 0; i < el.length; i++) {
		if (el[i].classList.contains("active")) {
			el[i].classList.remove("active");
		}
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Gridded", slots, []);
	let state = {};
	let { getChildXml } = $$props;
	let correctAns = [];
	let { xml } = $$props;

	let stateData = writable({
		rowNum: 4,
		colNum: 4,
		tableName: "Gridded System",
		plus_minus: 0,
		slash_val: 0,
		decimal_val: 0,
		xml: "",
		textSize: 14,
		resAns: "",
		correctAns: [],
		listAns: [],
		res: "",
		fixed_decimal_val: 0,
		decimal_point: 0
	});

	const unsubscribe = stateData.subscribe(items => {
		$$invalidate(0, state = items);
	});

	beforeUpdate(() => {
		AI.selectAll(".tdFont", "css", { fontSize: "14px" });
	});

	onMount(() => {
		AH.listen("body", "keydown", ".td_data", (_this, e) => {
			console.log("Evnts => ", e);

			if (e.which === 13) {
				_this.click();
			}
		});
	});

	afterUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(0, state.xml = xml, state);
			loadModule(xml);
		}

		firstRowItem();
		slashFunc();
		decimalFloating();
		plusMinusSign();
		createdSheetRow();
	});

	function loadModule(loadXml) {
		loadXml = XMLToJSON(loadXml);
		parseXMLAuthoring(loadXml);
	}

	function parseXMLAuthoring(MYXML) {
		try {
			$$invalidate(0, state.rowNum = MYXML.smxml._row, state);
			$$invalidate(0, state.colNum = MYXML.smxml._col, state);
			$$invalidate(0, state.slash_val = MYXML.smxml._slash, state);
			$$invalidate(0, state.plus_minus = MYXML.smxml._plusminus, state);
			$$invalidate(0, state.decimal_val = MYXML.smxml._decimal, state);
			$$invalidate(0, state.textSize = MYXML.smxml._font, state);
			$$invalidate(0, state.correctAns = MYXML.smxml._correctAns, state);
			getChildXml(JSONToXML(MYXML));

			if (MYXML.smxml._plusminus == 1) {
				document.getElementById("plus_minus_checkbox").checked = true;
			}

			if (MYXML.smxml._slash == 1) {
				document.getElementById("fraction_slash_checkbox").checked = true;
			}

			if (MYXML.smxml._decimal == 1) {
				document.getElementById("floating_decimal_checkbox").checked = true;
			}
		} catch(events) {
			console.warn({
				"error": events.message,
				"function name": "parseXMLAuthoring",
				"File name": "Gridded.js"
			});
		}
	}

	// Set boolean value in plus/minus
	function plusMinusSetVal() {
		$$invalidate(0, state.plus_minus = state.plus_minus == 0 ? 1 : 0, state);
		updateXml();
	}

	// slash function set value true or false
	function slashFuncSetVal(event) {
		$$invalidate(0, state.slash_val = state.slash_val == 0 ? 1 : 0, state);
		updateXml();
	}

	// This function disable decimal input box
	function fixedFunc(event) {
		if (state.fixed_decimal_val == 0) {
			$$invalidate(0, state.fixed_decimal_val = 1, state);
			let elem = document.getElementById("Fixed_decimal_column");
			elem.disabled = false;
			elem.style.display = "inline-block";
		} else {
			$$invalidate(0, state.fixed_decimal_val = 0, state);
			$$invalidate(0, state.decimal_point = 0, state);
			let elem = document.getElementById("Fixed_decimal_column");
			elem.value = " ";
			elem.disabled = true;
			elem.style.display = "none";
			updateXml();
		}
	}

	// Set value decimal floating
	function decimalFuncSetVal(event) {
		$$invalidate(0, state.decimal_val = state.decimal_val == 0 ? 1 : 0, state);
		updateXml();
	}

	// This function decided to row or column function
	function changeRowCol(event) {
		if (event.target.value.length > 1) {
			AH.alert("accept only single value");
			event.target.value = 4;
			return false;
		}

		console.log("check");
		let val = event.target.value;

		if (!(val > 0 && val <= 10)) {
			AH.alert(language.grid_one_to_ten);
			return false;
		}

		if (event.target.name == "col_nmbr") {
			if (event.target.value < 1) {
				AH.alert(language.col_less_one);
				eva;
				event.target.value = 1;
				return false;
			} else if (event.target.value > 6) {
				AH.alert(language.type_one_to_seven);
				event.target.value = "";
				return false;
			}

			$$invalidate(0, state.colNum = event.target.value, state);
		} else {
			if (event.target.value < 1) {
				AH.alert(language.row_less_one);
				event.target.value = 1;
				return false;
			} else if (event.target.value > 10) {
				AH.alert(language.type_one_to_ten);
				event.target.value = "";
				return false;
			}

			$$invalidate(0, state.rowNum = event.target.value, state);
		}

		updateXml();
	}

	function fixedDecimalPoints(event) {
		let decimalPosition = event.target.value;

		if (event.target.value.length > 1) {
			AH.alert("accept only single value");
			event.target.value = "";
			return false;
		}

		if (event.target.value == "") {
			decimalPosition = "";
		}

		if (event.target.value.length > 1 || event.target.value < 1 || state.colNum <= event.target.value) {
			decimalPosition = 1;
			event.target.value = 1;
			AH.alert(language.decimal_position + (state.colNum - 1) + ".");

			//$(".sa-info").show();
			document.querySelector(".sa-info").style.display = "block";
		}

		$$invalidate(0, state.decimal_point = decimalPosition, state);
		updateXml();
	}

	// Update the xml
	function updateXml() {
		// setTimeout( function() {
		let updatedXml = "<smxml type=\"56\" name=\"Gridded\" plusminus=\"" + state.plus_minus + "\" slash=\"" + state.slash_val + "\" decimal=\"" + state.decimal_val + "\" fixed_point=\"" + state.decimal_point + "\" font=\"" + state.textSize + "\" row=\"" + state.rowNum + "\" col=\"" + state.colNum + "\" correctAns=\"" + state.res + "\" ><!--[CDATA[]]--></smxml>";

		getChildXml(updatedXml);
	} // }, 500);

	// Create a sheet according to range
	let totalRows = [], totalCols = [];

	function createdSheetRow() {
		AH.select(".tdFont", "css", { fontSize: state.textSize });
		$$invalidate(1, totalRows = []);
		let dec_point = state.decimal_point;

		for (let i = 0; i < state.rowNum; i++) {
			$$invalidate(2, totalCols = []);

			for (let j = 0; j < state.colNum; j++) {
				if (j == dec_point - 1 && dec_point != 0) {
					$$invalidate(2, totalCols = [...totalCols, { key: "col" + i + j, decpoint: true }]);
				} else {
					if (totalCols.length < state.colNum) {
						$$invalidate(2, totalCols = [
							...totalCols,
							{
								key: "col" + i + j,
								name: j,
								id: "td" + j + "-" + i + j,
								decpoint: false
							}
						]);
					}
				}
			}

			$$invalidate(1, totalRows = [...totalRows, { key: "row" + i }]);
		}
	}

	

	// created a slash row in gridded sheet
	let Cols_slash;

	function slashFunc(event) {
		$$invalidate(3, Cols_slash = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(3, Cols_slash = [...Cols_slash, { key: "col" + j, decpoint: true }]);
			} else {
				if (Cols_slash.length < state.colNum) {
					$$invalidate(3, Cols_slash = [
						...Cols_slash,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// Create a decimal floating row
	let Cols_decimal;

	function decimalFloating(event) {
		Cols_decimal = [];
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				Cols_decimal = [...Cols_decimal, { key: "col" + j, decpoint: true }];
			} else {
				if (Cols_decimal.length < state.colNum) {
					Cols_decimal.push(Cols_decimal = [
						...Cols_decimal,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// create plus and minus row
	let Cols_Minus = [], Cols = [];

	function plusMinusSign(event) {
		$$invalidate(5, Cols = []);
		$$invalidate(4, Cols_Minus = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(5, Cols = [
					...Cols,
					{
						id: "td" + j,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols.length < state.colNum) {
					$$invalidate(5, Cols = [
						...Cols,
						{
							id: "td" + j,
							dataTag: j,
							name: j,
							decpoint: false
						}
					]);
				}
			}

			if (j == dec_point - 1 && dec_point != 0) {
				$$invalidate(4, Cols_Minus = [
					...Cols_Minus,
					{
						id: "td" + j,
						dataTag: j,
						name: j,
						decpoint: true
					}
				]);
			} else {
				if (Cols_Minus.length < state.colNum) {
					$$invalidate(4, Cols_Minus = [
						...Cols_Minus,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// Create very first row and store data according to click
	let ColsFirstRow = [];

	function firstRowItem() {
		$$invalidate(6, ColsFirstRow = []);
		let dec_point = state.decimal_point;

		for (let j = 0; j < state.colNum; j++) {
			if (j === dec_point - 1 && dec_point != 0) {
				$$invalidate(6, ColsFirstRow = [...ColsFirstRow, { decpoint: true }]);
			} else {
				if (ColsFirstRow.length < state.colNum) {
					$$invalidate(6, ColsFirstRow = [
						...ColsFirstRow,
						{
							id: "td" + j,
							name: j,
							dataTag: j,
							decpoint: false
						}
					]);
				}
			}
		}
	}

	// Check validation first row input type
	function rowValidation(event) {
		console.log("number" + state.plus_minus);
		let a = state.rowNum - 1;

		if (event.target.value.length > 1) {
			AH.alert(language.double_digit);
			event.target.value = "";
			return false;
		} else if (event.target.value < 0) {
			AH.alert(language.less_one);
			event.target.value = "";
			return false;
		} else if (a < event.target.value) {
			AH.alert(language.number_from + a);
			event.target.value = "";
			return false;
		} else if (state.plus_minus == 0 && event.target.value == "+" || event.target.value == "-") {
			AH.alert("Plz select plus and minus option");
			event.target.value = "";
			return false;
		} else if (state.slash_val == 0 && event.target.value == "/") {
			AH.alert("Plz select slash option");
			event.target.value = "";
			return false;
		} else if (state.decimal_val == 0 && event.target.value == ".") {
			AH.alert("Plz select decimal option");
			event.target.value = "";
			return false;
		}

		let attribute = event.target.attributes.getNamedItem("data-tag").value;
		correctAns[attribute] = event.target.value;

		for (let i = 0; i < correctAns.length; i++) {
			if (typeof correctAns[i] == "undefined" || correctAns[i] == "") {
				correctAns[i] = "%blank%";
			} //console.log(correctAns);
		}

		if (correctAns[correctAns.length - 1] == "%blank%") {
			correctAns.pop();
		}

		$$invalidate(0, state.listAns = correctAns, state);
		$$invalidate(0, state.res = state.listAns.toString(), state);
		updateXml();
	}

	function handleClick(event) {
		let cell_class = event.target.getAttribute("name");
		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.target.classList.add("active");
		let target_id = event.target.id;
		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.target.innerHTML;
		let attribute = event.target.attributes.getNamedItem("data-tag").value;
		correctAns[attribute] = event.target.innerHTML;

		for (let i = 0; i < correctAns.length; i++) {
			if (typeof correctAns[i] == "undefined") {
				correctAns[i] = "%blank%";
			} //console.log(correctAns);
		}

		$$invalidate(0, state.listAns = correctAns, state);
		$$invalidate(0, state.res = state.listAns.toString(), state);
		updateXml();
	}

	// Insert a data in top row according to click  and change colors
	function handleClickCombo(event) {
		//let cell_class = event.target.getAttribute('name');
		let cell_class = event.detail.target.getAttribute("name");

		let column_index = document.getElementsByName(cell_class);

		for (let i = 0; i < column_index.length; i++) {
			if (column_index[i].classList.contains("active")) {
				column_index[i].classList.remove("active");
			}
		}

		event.detail.target.classList.add("active");
		let target_id = event.detail.target.id;
		let target_to_display = target_id.split("-");
		document.getElementById(target_to_display[0]).value = event.detail.target.innerHTML;

		//let attribute = event.target.attributes.getNamedItem('data-tag').value;
		let attribute = event.detail.target.attributes.getNamedItem("data-tag").value;

		correctAns[attribute] = event.detail.target.innerHTML;

		for (let i = 0; i < correctAns.length; i++) {
			if (typeof correctAns[i] == "undefined") {
				correctAns[i] = "%blank%";
			} //console.log(correctAns);
		}

		$$invalidate(0, state.listAns = correctAns, state);
		$$invalidate(0, state.res = state.listAns.toString(), state);
		updateXml();
	}

	const writable_props = ["getChildXml", "xml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Gridded> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("getChildXml" in $$props) $$invalidate(16, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(17, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		l: language,
		writable,
		AH,
		XMLToJSON,
		JSONToXML,
		onMount,
		afterUpdate,
		beforeUpdate,
		GriddedHelper,
		state,
		getChildXml,
		correctAns,
		xml,
		stateData,
		unsubscribe,
		loadModule,
		parseXMLAuthoring,
		plusMinusSetVal,
		slashFuncSetVal,
		fixedFunc,
		decimalFuncSetVal,
		changeRowCol,
		fixedDecimalPoints,
		updateXml,
		totalRows,
		totalCols,
		createdSheetRow,
		Cols_slash,
		slashFunc,
		Cols_decimal,
		decimalFloating,
		Cols_Minus,
		Cols,
		plusMinusSign,
		ColsFirstRow,
		firstRowItem,
		rowValidation,
		highLight,
		handleClick,
		handleClickCombo,
		removeClass
	});

	$$self.$inject_state = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("getChildXml" in $$props) $$invalidate(16, getChildXml = $$props.getChildXml);
		if ("correctAns" in $$props) correctAns = $$props.correctAns;
		if ("xml" in $$props) $$invalidate(17, xml = $$props.xml);
		if ("stateData" in $$props) stateData = $$props.stateData;
		if ("totalRows" in $$props) $$invalidate(1, totalRows = $$props.totalRows);
		if ("totalCols" in $$props) $$invalidate(2, totalCols = $$props.totalCols);
		if ("Cols_slash" in $$props) $$invalidate(3, Cols_slash = $$props.Cols_slash);
		if ("Cols_decimal" in $$props) Cols_decimal = $$props.Cols_decimal;
		if ("Cols_Minus" in $$props) $$invalidate(4, Cols_Minus = $$props.Cols_Minus);
		if ("Cols" in $$props) $$invalidate(5, Cols = $$props.Cols);
		if ("ColsFirstRow" in $$props) $$invalidate(6, ColsFirstRow = $$props.ColsFirstRow);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		totalRows,
		totalCols,
		Cols_slash,
		Cols_Minus,
		Cols,
		ColsFirstRow,
		plusMinusSetVal,
		slashFuncSetVal,
		fixedFunc,
		decimalFuncSetVal,
		changeRowCol,
		fixedDecimalPoints,
		rowValidation,
		handleClick,
		handleClickCombo,
		getChildXml,
		xml
	];
}

class Gridded extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-1wrfq8n-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { getChildXml: 16, xml: 17 }, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gridded",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[16] === undefined && !("getChildXml" in props)) {
			console_1.warn("<Gridded> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[17] === undefined && !("xml" in props)) {
			console_1.warn("<Gridded> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<Gridded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<Gridded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<Gridded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<Gridded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Gridded;
//# sourceMappingURL=Gridded-e8b1741a.js.map
