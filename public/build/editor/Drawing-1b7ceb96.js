
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, h as text, f as space, j as attr_dev, k as add_location, n as insert_dev, p as append_dev, F as set_data_dev, G as prop_dev, B as noop, x as detach_dev, g as globals, a7 as l, P as Dialog, Q as binding_callbacks, R as bind, a9 as afterUpdate, o as onMount, A as AH, a8 as swal, X as XMLToJSON, N as JSONToXML, w as writable, V as Button, ak as svg_element, c as create_component, Y as src_url_equal, m as mount_component, q as listen_dev, Z as add_flush_callback, t as transition_in, a as transition_out, b as destroy_component } from './main-55b2d529.js';
import { D as Draggable } from './Draggable-eea764a0.js';
import { R as Resizable } from './Resizable-87a71a4a.js';

/* clsSMDrawing\DrawingModal.svelte generated by Svelte v3.40.2 */

const file = "clsSMDrawing\\DrawingModal.svelte";

function create_fragment(ctx) {
	let div24;
	let div23;
	let div22;
	let div0;
	let h4;
	let t0_value = /*l*/ ctx[0].configuration + "";
	let t0;
	let t1;
	let button0;
	let t3;
	let div20;
	let div19;
	let div4;
	let div2;
	let div1;
	let label0;
	let t4_value = /*l*/ ctx[0].background_image + "";
	let t4;
	let t5;
	let input0;
	let t6;
	let div3;
	let button1;
	let t7_value = /*l*/ ctx[0].upload_media_text + "";
	let t7;
	let button1_value_value;
	let t8;
	let div7;
	let div6;
	let div5;
	let label1;
	let span0;
	let t9_value = /*l*/ ctx[0].alt_txt_image + "";
	let t9;
	let t10;
	let input1;
	let t11;
	let div11;
	let div9;
	let div8;
	let label2;
	let span1;
	let t12_value = /*l*/ ctx[0].width_of_image + "";
	let t12;
	let t13;
	let input2;
	let t14;
	let div10;
	let span2;
	let label3;
	let t15_value = /*l*/ ctx[0].draw_color + "";
	let t15;
	let t16;
	let select0;
	let option0;
	let t17_value = /*l*/ ctx[0].red + "";
	let t17;
	let option0_value_value;
	let option1;
	let t18_value = /*l*/ ctx[0].green + "";
	let t18;
	let option1_value_value;
	let option2;
	let t19_value = /*l*/ ctx[0].light_blue + "";
	let t19;
	let option3;
	let t20_value = /*l*/ ctx[0].blue + "";
	let t20;
	let option3_value_value;
	let t21;
	let div13;
	let div12;
	let span3;
	let label4;
	let t22_value = /*l*/ ctx[0].markPointColor + "";
	let t22;
	let t23;
	let select1;
	let option4;
	let t24_value = /*l*/ ctx[0].lightGreen + "";
	let t24;
	let option5;
	let t25_value = /*l*/ ctx[0].black + "";
	let t25;
	let option6;
	let t26_value = /*l*/ ctx[0].orange + "";
	let t26;
	let t27;
	let div14;
	let span5;
	let label5;
	let span4;
	let t28_value = /*l*/ ctx[0].tools + "";
	let t28;
	let t29;
	let div18;
	let div15;
	let input3;
	let t30;
	let label6;
	let t31_value = /*l*/ ctx[0].scribble + "";
	let t31;
	let t32;
	let div16;
	let input4;
	let t33;
	let label7;
	let t34_value = /*l*/ ctx[0].line + "";
	let t34;
	let t35;
	let div17;
	let input5;
	let t36;
	let label8;
	let t37_value = /*l*/ ctx[0].compass + "";
	let t37;
	let t38;
	let div21;
	let button2;
	let t39_value = /*l*/ ctx[0].cancel + "";
	let t39;
	let t40;
	let button3;
	let t41_value = /*l*/ ctx[0].submit + "";
	let t41;

	const block = {
		c: function create() {
			div24 = element("div");
			div23 = element("div");
			div22 = element("div");
			div0 = element("div");
			h4 = element("h4");
			t0 = text(t0_value);
			t1 = space();
			button0 = element("button");
			button0.textContent = "Ã—";
			t3 = space();
			div20 = element("div");
			div19 = element("div");
			div4 = element("div");
			div2 = element("div");
			div1 = element("div");
			label0 = element("label");
			t4 = text(t4_value);
			t5 = space();
			input0 = element("input");
			t6 = space();
			div3 = element("div");
			button1 = element("button");
			t7 = text(t7_value);
			t8 = space();
			div7 = element("div");
			div6 = element("div");
			div5 = element("div");
			label1 = element("label");
			span0 = element("span");
			t9 = text(t9_value);
			t10 = space();
			input1 = element("input");
			t11 = space();
			div11 = element("div");
			div9 = element("div");
			div8 = element("div");
			label2 = element("label");
			span1 = element("span");
			t12 = text(t12_value);
			t13 = space();
			input2 = element("input");
			t14 = space();
			div10 = element("div");
			span2 = element("span");
			label3 = element("label");
			t15 = text(t15_value);
			t16 = space();
			select0 = element("select");
			option0 = element("option");
			t17 = text(t17_value);
			option1 = element("option");
			t18 = text(t18_value);
			option2 = element("option");
			t19 = text(t19_value);
			option3 = element("option");
			t20 = text(t20_value);
			t21 = space();
			div13 = element("div");
			div12 = element("div");
			span3 = element("span");
			label4 = element("label");
			t22 = text(t22_value);
			t23 = space();
			select1 = element("select");
			option4 = element("option");
			t24 = text(t24_value);
			option5 = element("option");
			t25 = text(t25_value);
			option6 = element("option");
			t26 = text(t26_value);
			t27 = space();
			div14 = element("div");
			span5 = element("span");
			label5 = element("label");
			span4 = element("span");
			t28 = text(t28_value);
			t29 = space();
			div18 = element("div");
			div15 = element("div");
			input3 = element("input");
			t30 = space();
			label6 = element("label");
			t31 = text(t31_value);
			t32 = space();
			div16 = element("div");
			input4 = element("input");
			t33 = space();
			label7 = element("label");
			t34 = text(t34_value);
			t35 = space();
			div17 = element("div");
			input5 = element("input");
			t36 = space();
			label8 = element("label");
			t37 = text(t37_value);
			t38 = space();
			div21 = element("div");
			button2 = element("button");
			t39 = text(t39_value);
			t40 = space();
			button3 = element("button");
			t41 = text(t41_value);
			attr_dev(h4, "class", "modal-title");
			add_location(h4, file, 15, 16, 498);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "close");
			attr_dev(button0, "data-bs-dismiss", "modal");
			add_location(button0, file, 16, 16, 562);
			attr_dev(div0, "class", "modal-header");
			add_location(div0, file, 14, 12, 454);
			attr_dev(label0, "class", "control-label font-weight-normal d-inline-flex");
			attr_dev(label0, "for", "backgroundImage");
			add_location(label0, file, 23, 32, 936);
			attr_dev(input0, "type", "text");
			input0.disabled = "disabled";
			input0.readOnly = "readonly";
			attr_dev(input0, "class", "form-control drawing_bgimg");
			attr_dev(input0, "id", "backgroundImage");
			attr_dev(input0, "name", "backgroundImage");
			add_location(input0, file, 24, 32, 1082);
			attr_dev(div1, "class", "form-group text-left");
			add_location(div1, file, 22, 28, 868);
			attr_dev(div2, "class", "col-6");
			add_location(div2, file, 21, 24, 819);
			attr_dev(button1, "id", "upload_media");
			attr_dev(button1, "type", "button");
			button1.value = button1_value_value = /*l*/ ctx[0].upload_media_text;
			attr_dev(button1, "margin", "normal");
			attr_dev(button1, "class", "btn btn-primary w-100");
			add_location(button1, file, 28, 28, 1378);
			attr_dev(div3, "class", "col-6 margin-top-2");
			add_location(div3, file, 27, 24, 1316);
			attr_dev(div4, "class", "row");
			add_location(div4, file, 20, 20, 776);
			attr_dev(span0, "class", "mendatory_label float-left");
			add_location(span0, file, 34, 108, 1842);
			attr_dev(label1, "class", "control-label font-weight-normal d-inline-flex");
			attr_dev(label1, "for", "imgAlt");
			add_location(label1, file, 34, 32, 1766);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "class", "form-control");
			attr_dev(input1, "id", "imgAlt");
			input1.value = "";
			attr_dev(input1, "name", "imgAlt");
			add_location(input1, file, 35, 32, 1949);
			attr_dev(div5, "class", "form-group text-left");
			add_location(div5, file, 33, 28, 1698);
			attr_dev(div6, "class", "col-12");
			add_location(div6, file, 32, 24, 1648);
			attr_dev(div7, "class", "row");
			add_location(div7, file, 31, 20, 1605);
			attr_dev(span1, "class", "mendatory_label float-left");
			add_location(span1, file, 42, 109, 2381);
			attr_dev(label2, "class", "control-label font-weight-normal d-inline-flex");
			attr_dev(label2, "for", "imgWidth");
			add_location(label2, file, 42, 32, 2304);
			attr_dev(input2, "type", "number");
			attr_dev(input2, "class", " form-control num");
			attr_dev(input2, "id", "imgWidth");
			input2.value = "";
			attr_dev(input2, "name", "imgWidth");
			add_location(input2, file, 43, 32, 2489);
			attr_dev(div8, "class", "form-group text-left");
			add_location(div8, file, 41, 28, 2236);
			attr_dev(div9, "class", "col-6");
			add_location(div9, file, 40, 24, 2187);
			attr_dev(label3, "for", "lineColor");
			attr_dev(label3, "class", "text-dark");
			add_location(label3, file, 48, 32, 2760);
			add_location(span2, file, 47, 28, 2720);
			option0.__value = option0_value_value = /*l*/ ctx[0].red;
			option0.value = option0.__value;
			add_location(option0, file, 51, 32, 2980);
			option1.__value = option1_value_value = /*l*/ ctx[0].green;
			option1.value = option1.__value;
			add_location(option1, file, 52, 32, 3052);
			option2.__value = "#00BCD4";
			option2.value = option2.__value;
			option2.selected = "selected";
			add_location(option2, file, 53, 32, 3128);
			option3.__value = option3_value_value = /*l*/ ctx[0].blue;
			option3.value = option3.__value;
			add_location(option3, file, 54, 32, 3229);
			attr_dev(select0, "id", "lineColor");
			attr_dev(select0, "class", "form-control form-select");
			add_location(select0, file, 50, 28, 2890);
			attr_dev(div10, "class", "col-6");
			add_location(div10, file, 46, 24, 2671);
			attr_dev(div11, "class", "row");
			add_location(div11, file, 39, 20, 2144);
			attr_dev(label4, "for", "markPointColor");
			attr_dev(label4, "class", "text-dark");
			add_location(label4, file, 61, 32, 3527);
			add_location(span3, file, 60, 28, 3487);
			option4.__value = "#00FF00";
			option4.value = option4.__value;
			option4.selected = "selected";
			add_location(option4, file, 64, 32, 3761);
			option5.__value = "#000";
			option5.value = option5.__value;
			add_location(option5, file, 65, 32, 3862);
			option6.__value = "#ff8c00";
			option6.value = option6.__value;
			add_location(option6, file, 66, 32, 3935);
			attr_dev(select1, "id", "markPointColor");
			attr_dev(select1, "class", "form-control form-select");
			add_location(select1, file, 63, 28, 3666);
			attr_dev(div12, "class", "col-6");
			add_location(div12, file, 59, 24, 3438);
			attr_dev(div13, "class", "row mb-3");
			add_location(div13, file, 58, 20, 3390);
			attr_dev(span4, "class", "mendatory_label float-left");
			add_location(span4, file, 73, 67, 4291);
			attr_dev(label5, "class", "mt-2 text-dark relative");
			add_location(label5, file, 73, 28, 4252);
			add_location(span5, file, 71, 24, 4130);
			add_location(div14, file, 70, 20, 4099);
			attr_dev(input3, "type", "checkbox");
			input3.value = "_scribble";
			attr_dev(input3, "class", "checkbox-inline toolCheckbox form-check-input");
			attr_dev(input3, "name", "scribble_checkbox");
			attr_dev(input3, "id", "scribble_checkbox");
			add_location(input3, file, 78, 28, 4572);
			attr_dev(label6, "for", "scribble_checkbox");
			attr_dev(label6, "class", "text-dark form-check-label");
			add_location(label6, file, 79, 28, 4747);
			attr_dev(div15, "class", "form-check form-check-inline");
			add_location(div15, file, 77, 24, 4500);
			attr_dev(input4, "type", "checkbox");
			input4.value = "_line";
			attr_dev(input4, "class", "checkbox-inline toolCheckbox form-check-input");
			attr_dev(input4, "name", "line_checkbox");
			attr_dev(input4, "id", "line_checkbox");
			add_location(input4, file, 82, 28, 4963);
			attr_dev(label7, "for", "line_checkbox");
			attr_dev(label7, "class", "text-dark form-check-label");
			add_location(label7, file, 83, 28, 5126);
			attr_dev(div16, "class", "form-check form-check-inline");
			add_location(div16, file, 81, 24, 4891);
			attr_dev(input5, "type", "checkbox");
			input5.value = "_compass";
			attr_dev(input5, "class", "checkbox-inline toolCheckbox form-check-input");
			attr_dev(input5, "name", "compass_checkbox");
			attr_dev(input5, "id", "compass_checkbox");
			add_location(input5, file, 86, 28, 5334);
			attr_dev(label8, "for", "compass_checkbox");
			attr_dev(label8, "class", "text-dark form-check-label");
			add_location(label8, file, 87, 28, 5506);
			attr_dev(div17, "class", "form-check form-check-inline");
			add_location(div17, file, 85, 24, 5262);
			attr_dev(div18, "class", "d-block toolsCheckbox");
			add_location(div18, file, 76, 20, 4439);
			attr_dev(div19, "class", "authoring-modal");
			add_location(div19, file, 19, 16, 725);
			attr_dev(div20, "class", "modal-body overflow-y");
			add_location(div20, file, 18, 12, 672);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "class", "btn btn-light");
			attr_dev(button2, "data-bs-dismiss", "modal");
			add_location(button2, file, 93, 16, 5752);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "class", "btn btn-secondary drawing_modal_submit");
			add_location(button3, file, 94, 16, 5857);
			attr_dev(div21, "class", "modal-footer");
			add_location(div21, file, 92, 12, 5708);
			attr_dev(div22, "class", "modal-content");
			add_location(div22, file, 13, 8, 413);
			attr_dev(div23, "class", "modal-dialog modal-dialog-centered");
			add_location(div23, file, 12, 4, 355);
			attr_dev(div24, "id", "drawing-modal");
			attr_dev(div24, "class", "modal fade");
			attr_dev(div24, "tabindex", "-1");
			add_location(div24, file, 11, 0, 292);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div24, anchor);
			append_dev(div24, div23);
			append_dev(div23, div22);
			append_dev(div22, div0);
			append_dev(div0, h4);
			append_dev(h4, t0);
			append_dev(div0, t1);
			append_dev(div0, button0);
			append_dev(div22, t3);
			append_dev(div22, div20);
			append_dev(div20, div19);
			append_dev(div19, div4);
			append_dev(div4, div2);
			append_dev(div2, div1);
			append_dev(div1, label0);
			append_dev(label0, t4);
			append_dev(div1, t5);
			append_dev(div1, input0);
			append_dev(div4, t6);
			append_dev(div4, div3);
			append_dev(div3, button1);
			append_dev(button1, t7);
			append_dev(div19, t8);
			append_dev(div19, div7);
			append_dev(div7, div6);
			append_dev(div6, div5);
			append_dev(div5, label1);
			append_dev(label1, span0);
			append_dev(span0, t9);
			append_dev(div5, t10);
			append_dev(div5, input1);
			append_dev(div19, t11);
			append_dev(div19, div11);
			append_dev(div11, div9);
			append_dev(div9, div8);
			append_dev(div8, label2);
			append_dev(label2, span1);
			append_dev(span1, t12);
			append_dev(div8, t13);
			append_dev(div8, input2);
			append_dev(div11, t14);
			append_dev(div11, div10);
			append_dev(div10, span2);
			append_dev(span2, label3);
			append_dev(label3, t15);
			append_dev(div10, t16);
			append_dev(div10, select0);
			append_dev(select0, option0);
			append_dev(option0, t17);
			append_dev(select0, option1);
			append_dev(option1, t18);
			append_dev(select0, option2);
			append_dev(option2, t19);
			append_dev(select0, option3);
			append_dev(option3, t20);
			append_dev(div19, t21);
			append_dev(div19, div13);
			append_dev(div13, div12);
			append_dev(div12, span3);
			append_dev(span3, label4);
			append_dev(label4, t22);
			append_dev(div12, t23);
			append_dev(div12, select1);
			append_dev(select1, option4);
			append_dev(option4, t24);
			append_dev(select1, option5);
			append_dev(option5, t25);
			append_dev(select1, option6);
			append_dev(option6, t26);
			append_dev(div19, t27);
			append_dev(div19, div14);
			append_dev(div14, span5);
			append_dev(span5, label5);
			append_dev(label5, span4);
			append_dev(span4, t28);
			append_dev(div19, t29);
			append_dev(div19, div18);
			append_dev(div18, div15);
			append_dev(div15, input3);
			append_dev(div15, t30);
			append_dev(div15, label6);
			append_dev(label6, t31);
			append_dev(div18, t32);
			append_dev(div18, div16);
			append_dev(div16, input4);
			append_dev(div16, t33);
			append_dev(div16, label7);
			append_dev(label7, t34);
			append_dev(div18, t35);
			append_dev(div18, div17);
			append_dev(div17, input5);
			append_dev(div17, t36);
			append_dev(div17, label8);
			append_dev(label8, t37);
			append_dev(div22, t38);
			append_dev(div22, div21);
			append_dev(div21, button2);
			append_dev(button2, t39);
			append_dev(div21, t40);
			append_dev(div21, button3);
			append_dev(button3, t41);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*l*/ 1 && t0_value !== (t0_value = /*l*/ ctx[0].configuration + "")) set_data_dev(t0, t0_value);
			if (dirty & /*l*/ 1 && t4_value !== (t4_value = /*l*/ ctx[0].background_image + "")) set_data_dev(t4, t4_value);
			if (dirty & /*l*/ 1 && t7_value !== (t7_value = /*l*/ ctx[0].upload_media_text + "")) set_data_dev(t7, t7_value);

			if (dirty & /*l*/ 1 && button1_value_value !== (button1_value_value = /*l*/ ctx[0].upload_media_text)) {
				prop_dev(button1, "value", button1_value_value);
			}

			if (dirty & /*l*/ 1 && t9_value !== (t9_value = /*l*/ ctx[0].alt_txt_image + "")) set_data_dev(t9, t9_value);
			if (dirty & /*l*/ 1 && t12_value !== (t12_value = /*l*/ ctx[0].width_of_image + "")) set_data_dev(t12, t12_value);
			if (dirty & /*l*/ 1 && t15_value !== (t15_value = /*l*/ ctx[0].draw_color + "")) set_data_dev(t15, t15_value);
			if (dirty & /*l*/ 1 && t17_value !== (t17_value = /*l*/ ctx[0].red + "")) set_data_dev(t17, t17_value);

			if (dirty & /*l*/ 1 && option0_value_value !== (option0_value_value = /*l*/ ctx[0].red)) {
				prop_dev(option0, "__value", option0_value_value);
				option0.value = option0.__value;
			}

			if (dirty & /*l*/ 1 && t18_value !== (t18_value = /*l*/ ctx[0].green + "")) set_data_dev(t18, t18_value);

			if (dirty & /*l*/ 1 && option1_value_value !== (option1_value_value = /*l*/ ctx[0].green)) {
				prop_dev(option1, "__value", option1_value_value);
				option1.value = option1.__value;
			}

			if (dirty & /*l*/ 1 && t19_value !== (t19_value = /*l*/ ctx[0].light_blue + "")) set_data_dev(t19, t19_value);
			if (dirty & /*l*/ 1 && t20_value !== (t20_value = /*l*/ ctx[0].blue + "")) set_data_dev(t20, t20_value);

			if (dirty & /*l*/ 1 && option3_value_value !== (option3_value_value = /*l*/ ctx[0].blue)) {
				prop_dev(option3, "__value", option3_value_value);
				option3.value = option3.__value;
			}

			if (dirty & /*l*/ 1 && t22_value !== (t22_value = /*l*/ ctx[0].markPointColor + "")) set_data_dev(t22, t22_value);
			if (dirty & /*l*/ 1 && t24_value !== (t24_value = /*l*/ ctx[0].lightGreen + "")) set_data_dev(t24, t24_value);
			if (dirty & /*l*/ 1 && t25_value !== (t25_value = /*l*/ ctx[0].black + "")) set_data_dev(t25, t25_value);
			if (dirty & /*l*/ 1 && t26_value !== (t26_value = /*l*/ ctx[0].orange + "")) set_data_dev(t26, t26_value);
			if (dirty & /*l*/ 1 && t28_value !== (t28_value = /*l*/ ctx[0].tools + "")) set_data_dev(t28, t28_value);
			if (dirty & /*l*/ 1 && t31_value !== (t31_value = /*l*/ ctx[0].scribble + "")) set_data_dev(t31, t31_value);
			if (dirty & /*l*/ 1 && t34_value !== (t34_value = /*l*/ ctx[0].line + "")) set_data_dev(t34, t34_value);
			if (dirty & /*l*/ 1 && t37_value !== (t37_value = /*l*/ ctx[0].compass + "")) set_data_dev(t37, t37_value);
			if (dirty & /*l*/ 1 && t39_value !== (t39_value = /*l*/ ctx[0].cancel + "")) set_data_dev(t39, t39_value);
			if (dirty & /*l*/ 1 && t41_value !== (t41_value = /*l*/ ctx[0].submit + "")) set_data_dev(t41, t41_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div24);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DrawingModal', slots, []);
	let { l } = $$props;
	const writable_props = ['l'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DrawingModal> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('l' in $$props) $$invalidate(0, l = $$props.l);
	};

	$$self.$capture_state = () => ({ l });

	$$self.$inject_state = $$props => {
		if ('l' in $$props) $$invalidate(0, l = $$props.l);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [l];
}

class DrawingModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { l: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DrawingModal",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*l*/ ctx[0] === undefined && !('l' in props)) {
			console.warn("<DrawingModal> was created without expected prop 'l'");
		}
	}

	get l() {
		throw new Error("<DrawingModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set l(value) {
		throw new Error("<DrawingModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMDrawing\Drawing.svelte generated by Svelte v3.40.2 */

const { Object: Object_1, console: console_1 } = globals;
const file$1 = "clsSMDrawing\\Drawing.svelte";

// (1567:4) <Dialog    bind:visible={state.openDeleteDialog}    style={'width:500px;background-color:#FFF;'}   >
function create_default_slot_1(ctx) {
	let div1;
	let div0;
	let span;
	let span_style_value;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			span.textContent = `${l.del_confirmation}`;
			attr_dev(span, "class", "col-md-12");
			attr_dev(span, "style", span_style_value = 'margin-top:40px;margin-bottom:40px;text-align:center;');
			add_location(span, file$1, 1572, 4, 96158);
			attr_dev(div0, "class", "row");
			add_location(div0, file$1, 1571, 3, 96135);
			add_location(div1, file$1, 1570, 2, 96125);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, span);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(1567:4) <Dialog    bind:visible={state.openDeleteDialog}    style={'width:500px;background-color:#FFF;'}   >",
		ctx
	});

	return block;
}

// (1578:12) <Button variant="contained" on:click={resetModule}      class="bg-primary text-white">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Yes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(1578:12) <Button variant=\\\"contained\\\" on:click={resetModule}      class=\\\"bg-primary text-white\\\">",
		ctx
	});

	return block;
}

// (1576:2) 
function create_footer_slot(ctx) {
	let div;
	let input;
	let t;
	let button;
	let div_style_value;
	let current;
	let mounted;
	let dispose;

	button = new Button({
			props: {
				variant: "contained",
				class: "bg-primary text-white",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*resetModule*/ ctx[2]);

	const block = {
		c: function create() {
			div = element("div");
			input = element("input");
			t = space();
			create_component(button.$$.fragment);
			attr_dev(input, "type", "button");
			attr_dev(input, "variant", "contained");
			attr_dev(input, "class", "btn btn-light colorgray");
			input.value = "Cancel";
			add_location(input, file$1, 1576, 3, 96384);
			attr_dev(div, "slot", "footer");
			attr_dev(div, "class", "svelteFooter");
			attr_dev(div, "style", div_style_value = 'width:100%;text-align:center;');
			add_location(div, file$1, 1575, 2, 96298);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input);
			append_dev(div, t);
			mount_component(button, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "click", /*click_handler*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 64) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(1576:2) ",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let main;
	let div11;
	let center;
	let div7;
	let div5;
	let div0;
	let button0;
	let i0;
	let button0_title_value;
	let t0;
	let button1;
	let t1;
	let button1_title_value;
	let t2;
	let button2;
	let i1;
	let button2_title_value;
	let div0_aria_label_value;
	let t3;
	let div1;
	let button3;
	let i2;
	let button3_title_value;
	let t4;
	let button4;
	let i3;
	let button4_title_value;
	let t5;
	let button5;
	let i4;
	let button5_title_value;
	let t6;
	let button6;
	let i5;
	let button6_title_value;
	let div1_aria_label_value;
	let t7;
	let div2;
	let button7;
	let t8_value = l.add_point + "";
	let t8;
	let button7_title_value;
	let div2_aria_label_value;
	let t9;
	let div3;
	let button8;
	let t10_value = l.add_focus_pnt + "";
	let t10;
	let button8_title_value;
	let div3_aria_label_value;
	let t11;
	let div4;
	let button9;
	let i6;
	let button9_title_value;
	let div4_aria_label_value;
	let div5_aria_label_value;
	let t12;
	let div6;
	let t14;
	let div10;
	let div9;
	let div8;
	let button10;
	let i7;
	let t15;
	let img;
	let img_src_value;
	let img_alt_value;
	let t16;
	let svg6;
	let title;
	let t17_value = /*state*/ ctx[0].alt + "";
	let t17;
	let g0;
	let g1;
	let g2;
	let svg5;
	let svg4;
	let g19;
	let circle0;
	let g3;
	let line;
	let g4;
	let circle1;
	let defs0;
	let pattern0;
	let svg0;
	let path0;
	let path1;
	let path2;
	let path3;
	let circle2;
	let g11;
	let circle3;
	let defs1;
	let pattern1;
	let svg1;
	let g7;
	let g5;
	let rect0;
	let g6;
	let rect1;
	let g10;
	let g8;
	let path4;
	let g9;
	let path5;
	let g12;
	let circle4;
	let defs2;
	let pattern2;
	let svg2;
	let path6;
	let g13;
	let circle5;
	let circle5_fill_value;
	let circle6;
	let g18;
	let circle7;
	let defs3;
	let pattern3;
	let svg3;
	let g17;
	let g16;
	let g15;
	let g14;
	let path7;
	let t18;
	let drawingmodal;
	let t19;
	let dialog;
	let updating_visible;
	let current;
	let mounted;
	let dispose;
	drawingmodal = new DrawingModal({ props: { l }, $$inline: true });

	function dialog_visible_binding(value) {
		/*dialog_visible_binding*/ ctx[7](value);
	}

	let dialog_props = {
		style: 'width:500px;background-color:#FFF;',
		$$slots: {
			footer: [create_footer_slot],
			default: [create_default_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*state*/ ctx[0].openDeleteDialog !== void 0) {
		dialog_props.visible = /*state*/ ctx[0].openDeleteDialog;
	}

	dialog = new Dialog({ props: dialog_props, $$inline: true });
	binding_callbacks.push(() => bind(dialog, 'visible', dialog_visible_binding));

	const block = {
		c: function create() {
			main = element("main");
			div11 = element("div");
			center = element("center");
			div7 = element("div");
			div5 = element("div");
			div0 = element("div");
			button0 = element("button");
			i0 = element("i");
			t0 = space();
			button1 = element("button");
			t1 = text("/");
			t2 = space();
			button2 = element("button");
			i1 = element("i");
			t3 = space();
			div1 = element("div");
			button3 = element("button");
			i2 = element("i");
			t4 = space();
			button4 = element("button");
			i3 = element("i");
			t5 = space();
			button5 = element("button");
			i4 = element("i");
			t6 = space();
			button6 = element("button");
			i5 = element("i");
			t7 = space();
			div2 = element("div");
			button7 = element("button");
			t8 = text(t8_value);
			t9 = space();
			div3 = element("div");
			button8 = element("button");
			t10 = text(t10_value);
			t11 = space();
			div4 = element("div");
			button9 = element("button");
			i6 = element("i");
			t12 = space();
			div6 = element("div");
			div6.textContent = `${l.delete_point_msg}`;
			t14 = space();
			div10 = element("div");
			div9 = element("div");
			div8 = element("div");
			button10 = element("button");
			i7 = element("i");
			t15 = space();
			img = element("img");
			t16 = space();
			svg6 = svg_element("svg");
			title = svg_element("title");
			t17 = text(t17_value);
			g0 = svg_element("g");
			g1 = svg_element("g");
			g2 = svg_element("g");
			svg5 = svg_element("svg");
			svg4 = svg_element("svg");
			g19 = svg_element("g");
			circle0 = svg_element("circle");
			g3 = svg_element("g");
			line = svg_element("line");
			g4 = svg_element("g");
			circle1 = svg_element("circle");
			defs0 = svg_element("defs");
			pattern0 = svg_element("pattern");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			circle2 = svg_element("circle");
			g11 = svg_element("g");
			circle3 = svg_element("circle");
			defs1 = svg_element("defs");
			pattern1 = svg_element("pattern");
			svg1 = svg_element("svg");
			g7 = svg_element("g");
			g5 = svg_element("g");
			rect0 = svg_element("rect");
			g6 = svg_element("g");
			rect1 = svg_element("rect");
			g10 = svg_element("g");
			g8 = svg_element("g");
			path4 = svg_element("path");
			g9 = svg_element("g");
			path5 = svg_element("path");
			g12 = svg_element("g");
			circle4 = svg_element("circle");
			defs2 = svg_element("defs");
			pattern2 = svg_element("pattern");
			svg2 = svg_element("svg");
			path6 = svg_element("path");
			g13 = svg_element("g");
			circle5 = svg_element("circle");
			circle6 = svg_element("circle");
			g18 = svg_element("g");
			circle7 = svg_element("circle");
			defs3 = svg_element("defs");
			pattern3 = svg_element("pattern");
			svg3 = svg_element("svg");
			g17 = svg_element("g");
			g16 = svg_element("g");
			g15 = svg_element("g");
			g14 = svg_element("g");
			path7 = svg_element("path");
			t18 = space();
			create_component(drawingmodal.$$.fragment);
			t19 = space();
			create_component(dialog.$$.fragment);
			attr_dev(i0, "class", "icomoon-pencil");
			add_location(i0, file$1, 1444, 231, 84688);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "tabindex", "0");
			attr_dev(button0, "data-title", "scribble");
			attr_dev(button0, "title", button0_title_value = l.scribble);
			attr_dev(button0, "name", "authoring_scribble");
			attr_dev(button0, "id", "authoring_scribble");
			attr_dev(button0, "class", "btn btn-light auth_toolbar geometryTool tooltip_btn authoring_btn active");
			add_location(button0, file$1, 1444, 24, 84481);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "tabindex", "0");
			attr_dev(button1, "data-title", "line");
			attr_dev(button1, "title", button1_title_value = l.line);
			attr_dev(button1, "name", "authoring_line");
			attr_dev(button1, "id", "authoring_line");
			attr_dev(button1, "class", "btn btn-light auth_toolbar geometryTool tooltip_btn authoring_btn");
			add_location(button1, file$1, 1445, 24, 84753);
			attr_dev(i1, "class", "icomoon-compass1");
			add_location(i1, file$1, 1446, 210, 85159);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "tabindex", "0");
			attr_dev(button2, "data-title", "compass");
			attr_dev(button2, "title", button2_title_value = l.compass);
			attr_dev(button2, "name", "compass");
			attr_dev(button2, "id", "authoring_compass");
			attr_dev(button2, "class", "btn btn-light auth_toolbar geometryTool tooltip_btn authoring_btn");
			add_location(button2, file$1, 1446, 24, 84973);
			attr_dev(div0, "tabindex", "0");
			attr_dev(div0, "class", "btn-group mr-2");
			attr_dev(div0, "role", "group");
			attr_dev(div0, "aria-label", div0_aria_label_value = l.draw_tools);
			add_location(div0, file$1, 1443, 20, 84375);
			attr_dev(i2, "class", "icomoon-delete-sm");
			add_location(i2, file$1, 1449, 178, 85514);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "tabindex", "0");
			attr_dev(button3, "title", button3_title_value = l.delete_tool);
			attr_dev(button3, "name", "eraser");
			attr_dev(button3, "id", "authoring_eraser");
			attr_dev(button3, "class", "btn btn-light auth_toolbar authoring_btn tooltip_btn");
			add_location(button3, file$1, 1449, 24, 85360);
			attr_dev(i3, "class", "icomoon-close-2");
			add_location(i3, file$1, 1450, 183, 85741);
			attr_dev(button4, "type", "button");
			attr_dev(button4, "title", button4_title_value = l.clear_screen);
			attr_dev(button4, "tabindex", "0");
			attr_dev(button4, "name", "clearScreen");
			attr_dev(button4, "id", "authoring_clearScreen");
			button4.disabled = "disabled";
			attr_dev(button4, "class", "btn btn-light tooltip_btn");
			add_location(button4, file$1, 1450, 24, 85582);
			attr_dev(i4, "class", "icomoon-redo-2");
			add_location(i4, file$1, 1451, 160, 85943);
			attr_dev(button5, "type", "button");
			attr_dev(button5, "tabindex", "0");
			attr_dev(button5, "title", button5_title_value = l.redo);
			attr_dev(button5, "name", "redo");
			attr_dev(button5, "id", "authoring_redo");
			button5.disabled = "disabled";
			attr_dev(button5, "class", "btn btn-light tooltip_btn");
			add_location(button5, file$1, 1451, 24, 85807);
			attr_dev(i5, "class", "icomoon-undo-2");
			add_location(i5, file$1, 1452, 160, 86144);
			attr_dev(button6, "type", "button");
			attr_dev(button6, "tabindex", "0");
			attr_dev(button6, "title", button6_title_value = l.undo);
			attr_dev(button6, "name", "undo");
			attr_dev(button6, "id", "authoring_undo");
			button6.disabled = "disabled";
			attr_dev(button6, "class", "btn btn-light tooltip_btn");
			add_location(button6, file$1, 1452, 24, 86008);
			attr_dev(div1, "tabindex", "0");
			attr_dev(div1, "class", "btn-group mr-2");
			attr_dev(div1, "role", "group");
			attr_dev(div1, "aria-label", div1_aria_label_value = l.removing_tools);
			add_location(div1, file$1, 1448, 20, 85250);
			attr_dev(button7, "type", "button");
			attr_dev(button7, "tabindex", "0");
			attr_dev(button7, "data-title", "authoring_point");
			attr_dev(button7, "title", button7_title_value = l.add_show_point);
			attr_dev(button7, "name", "authoring_point");
			attr_dev(button7, "id", "authoring_point");
			attr_dev(button7, "class", "btn btn-light tooltip_btn");
			add_location(button7, file$1, 1455, 24, 86328);
			attr_dev(div2, "class", "btn-group mr-2");
			attr_dev(div2, "role", "group");
			attr_dev(div2, "aria-label", div2_aria_label_value = l.answer_point);
			add_location(div2, file$1, 1454, 20, 86233);
			attr_dev(button8, "type", "button");
			attr_dev(button8, "tabindex", "0");
			attr_dev(button8, "title", button8_title_value = l.add_finish_point);
			attr_dev(button8, "name", "focus_point");
			attr_dev(button8, "id", "focus_point");
			attr_dev(button8, "class", "btn btn-light tooltip_btn");
			add_location(button8, file$1, 1458, 24, 86661);
			attr_dev(div3, "class", "btn-group mr-2");
			attr_dev(div3, "role", "group");
			attr_dev(div3, "aria-label", div3_aria_label_value = l.access_mode);
			add_location(div3, file$1, 1457, 20, 86567);
			attr_dev(i6, "class", "icomoon-new-24px-reset-1");
			add_location(i6, file$1, 1461, 146, 87082);
			attr_dev(button9, "type", "button");
			attr_dev(button9, "tabindex", "0");
			attr_dev(button9, "title", button9_title_value = l.reset);
			attr_dev(button9, "name", "default_button");
			attr_dev(button9, "id", "reset_btn");
			attr_dev(button9, "class", "btn btn-light tooltip_btn");
			add_location(button9, file$1, 1461, 24, 86960);
			attr_dev(div4, "class", "btn-group mr-2");
			attr_dev(div4, "role", "group");
			attr_dev(div4, "aria-label", div4_aria_label_value = l.def_mode);
			add_location(div4, file$1, 1460, 20, 86869);
			attr_dev(div5, "class", "btn-toolbar auth_drawing_toolbar");
			attr_dev(div5, "role", "toolbar");
			attr_dev(div5, "aria-label", div5_aria_label_value = l.drawing_tools);
			add_location(div5, file$1, 1442, 16, 84263);
			attr_dev(div6, "id", "add_point_msg");
			attr_dev(div6, "class", "text-danger my-1");
			add_location(div6, file$1, 1464, 16, 87201);
			attr_dev(div7, "class", "mt-2 mb-2");
			add_location(div7, file$1, 1441, 12, 84222);
			attr_dev(i7, "class", "icomoon-24px-settings-1");
			add_location(i7, file$1, 1470, 28, 87655);
			attr_dev(button10, "type", "button");
			attr_dev(button10, "tabindex", "0");
			attr_dev(button10, "title", "Configuration");
			attr_dev(button10, "class", "btn tooltip_btn btn-light p-1");
			add_location(button10, file$1, 1469, 24, 87508);
			attr_dev(div8, "class", "btn-group position-absolute setting_btn");
			add_location(div8, file$1, 1468, 20, 87429);
			attr_dev(img, "class", "border");
			if (!src_url_equal(img.src, img_src_value = /*bgImgPath*/ ctx[1] + /*state*/ ctx[0].bgImg)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "id", "svgImg");
			attr_dev(img, "alt", img_alt_value = /*state*/ ctx[0].alt);
			add_location(img, file$1, 1473, 20, 87779);
			attr_dev(title, "id", "authoringSvgTitle");
			add_location(title, file$1, 1475, 24, 88005);
			attr_dev(g0, "class", "backgroundFocusPath");
			add_location(g0, file$1, 1476, 24, 88080);
			attr_dev(g1, "class", "drawing_paths");
			add_location(g1, file$1, 1477, 24, 88141);
			attr_dev(g2, "class", "backgroundFocusPoint");
			add_location(g2, file$1, 1478, 24, 88196);
			attr_dev(circle0, "class", "drawing-compass-route compass_route");
			attr_dev(circle0, "cx", "267.984375");
			attr_dev(circle0, "cy", "173");
			attr_dev(circle0, "r", "80");
			add_location(circle0, file$1, 1482, 36, 88453);
			attr_dev(line, "class", "compass_rotationBar compass_radius");
			attr_dev(line, "x1", "267.984375");
			attr_dev(line, "y1", "173");
			attr_dev(line, "x2", "267.984375");
			attr_dev(line, "y2", "253");
			add_location(line, file$1, 1484, 40, 88629);
			add_location(g3, file$1, 1483, 36, 88584);
			attr_dev(circle1, "class", "drawing_compass_center compass_center");
			attr_dev(circle1, "cx", "267.984375");
			attr_dev(circle1, "cy", "173");
			attr_dev(circle1, "r", "17");
			attr_dev(circle1, "focusable", "true");
			attr_dev(circle1, "fill", "url(#drawingCenter)");
			add_location(circle1, file$1, 1487, 40, 88860);
			attr_dev(path0, "fill", "#808080");
			attr_dev(path0, "class", "st0");
			attr_dev(path0, "d", "M3.22,15.1L1,12l2.22-3.1C3.22,10.97,3.22,13.03,3.22,15.1z");
			add_location(path0, file$1, 1491, 52, 89313);
			attr_dev(path1, "fill", "#808080");
			attr_dev(path1, "class", "st0");
			attr_dev(path1, "d", "M8.9,3.22L12,1l3.1,2.22C13.03,3.22,10.97,3.22,8.9,3.22z");
			add_location(path1, file$1, 1492, 52, 89464);
			attr_dev(path2, "fill", "#808080");
			attr_dev(path2, "class", "st0");
			attr_dev(path2, "d", "M15.1,20.78L12,23l-3.1-2.22C10.97,20.78,13.03,20.78,15.1,20.78z");
			add_location(path2, file$1, 1493, 52, 89613);
			attr_dev(path3, "fill", "#808080");
			attr_dev(path3, "class", "st0");
			attr_dev(path3, "d", "M20.78,8.9L23,12l-2.22,3.1C20.78,13.03,20.78,10.97,20.78,8.9z");
			add_location(path3, file$1, 1494, 52, 89770);
			attr_dev(circle2, "cx", "12");
			attr_dev(circle2, "cy", "12");
			attr_dev(circle2, "r", "2");
			attr_dev(circle2, "fill", "#333333");
			add_location(circle2, file$1, 1495, 52, 89925);
			attr_dev(svg0, "x", "0px");
			attr_dev(svg0, "y", "0px");
			attr_dev(svg0, "viewBox", "1 -3 21 35");
			attr_dev(svg0, "width", "33");
			attr_dev(svg0, "height", "41");
			add_location(svg0, file$1, 1490, 48, 89194);
			attr_dev(pattern0, "id", "drawingCenter");
			attr_dev(pattern0, "width", "20");
			attr_dev(pattern0, "height", "20");
			add_location(pattern0, file$1, 1489, 44, 89093);
			add_location(defs0, file$1, 1488, 40, 89041);
			add_location(g4, file$1, 1486, 36, 88815);
			attr_dev(circle3, "class", "compass_radius_icon mid_circle");
			attr_dev(circle3, "cx", "267.984375");
			attr_dev(circle3, "cy", "213");
			attr_dev(circle3, "r", "17");
			attr_dev(circle3, "fill", "url(#drawingRadius)");
			attr_dev(circle3, "transform", "rotate(90,160,168)");
			attr_dev(circle3, "focusable", "true");
			add_location(circle3, file$1, 1501, 40, 90258);
			attr_dev(rect0, "x", "8.53");
			attr_dev(rect0, "y", "1.11");
			attr_dev(rect0, "width", "1.5");
			attr_dev(rect0, "height", "21.79");
			add_location(rect0, file$1, 1507, 60, 90861);
			add_location(g5, file$1, 1506, 56, 90796);
			attr_dev(rect1, "x", "13.97");
			attr_dev(rect1, "y", "1.11");
			attr_dev(rect1, "width", "1.5");
			attr_dev(rect1, "height", "21.79");
			add_location(rect1, file$1, 1510, 60, 91099);
			add_location(g6, file$1, 1509, 56, 91034);
			add_location(g7, file$1, 1505, 52, 90735);
			attr_dev(path4, "d", "M5.87,16.87L1,12l4.87-4.87C5.87,10.38,5.87,13.62,5.87,16.87z");
			add_location(path4, file$1, 1515, 60, 91453);
			add_location(g8, file$1, 1514, 56, 91388);
			attr_dev(path5, "d", "M18.13,16.87L23,12l-4.87-4.87C18.13,10.38,18.13,13.62,18.13,16.87z");
			add_location(path5, file$1, 1518, 60, 91711);
			add_location(g9, file$1, 1517, 56, 91646);
			add_location(g10, file$1, 1513, 52, 91327);
			attr_dev(svg1, "x", "0px");
			attr_dev(svg1, "y", "0px");
			attr_dev(svg1, "viewBox", "1 -5 21 34");
			attr_dev(svg1, "width", "33");
			attr_dev(svg1, "height", "33");
			add_location(svg1, file$1, 1504, 48, 90616);
			attr_dev(pattern1, "id", "drawingRadius");
			attr_dev(pattern1, "width", "20");
			attr_dev(pattern1, "height", "20");
			add_location(pattern1, file$1, 1503, 44, 90515);
			add_location(defs1, file$1, 1502, 40, 90463);
			add_location(g11, file$1, 1500, 36, 90213);
			attr_dev(circle4, "class", "compass_rotation midSmallCircle");
			attr_dev(circle4, "cx", "267.984375");
			attr_dev(circle4, "cy", "233");
			attr_dev(circle4, "r", "8");
			attr_dev(circle4, "fill", "url(#midSmallCircle_icon)");
			attr_dev(circle4, "focusable", "true");
			attr_dev(circle4, "transform", "rotate(90,160,193)");
			add_location(circle4, file$1, 1526, 40, 92196);
			attr_dev(path6, "fill", "#000");
			attr_dev(path6, "opacity", "0.8");
			attr_dev(path6, "d", "M7,14 C3.13400675,14 0,10.8659932 0,7 C0,3.13400675 3.13400675,0 7, 0 C10.8659932,0 14,3.13400675 14,7 C14,10.8659932 10.8659932,14 7, 14 Z M4.66666667,8.16666667 L7,11.6666667 L9.33333333,8.16666667 L4.66666667,8.16666667 Z M4.66666667,5.83333333 L9.33333333,5.83333333 L7,2.33333333 L4.66666667,5.83333333 Z");
			add_location(path6, file$1, 1530, 52, 92686);
			attr_dev(svg2, "width", "16px");
			attr_dev(svg2, "height", "16px");
			attr_dev(svg2, "viewBox", "0 0 14 14");
			attr_dev(svg2, "version", "1.1");
			add_location(svg2, file$1, 1529, 48, 92566);
			attr_dev(pattern2, "id", "midSmallCircle_icon");
			attr_dev(pattern2, "width", "20");
			attr_dev(pattern2, "height", "20");
			add_location(pattern2, file$1, 1528, 44, 92459);
			add_location(defs2, file$1, 1527, 40, 92407);
			add_location(g12, file$1, 1525, 36, 92151);
			attr_dev(circle5, "class", "drawing-compass-pointer lastCircle");
			attr_dev(circle5, "cx", "267.984375");
			attr_dev(circle5, "cy", "253");
			attr_dev(circle5, "r", "3");
			attr_dev(circle5, "fill", circle5_fill_value = /*state*/ ctx[0].lineColor);
			add_location(circle5, file$1, 1536, 40, 93326);
			attr_dev(circle6, "class", "drawing-compass-pointer-border lastCircle last_big_circle");
			attr_dev(circle6, "cx", "267.984375");
			attr_dev(circle6, "cy", "253");
			attr_dev(circle6, "r", "17");
			attr_dev(circle6, "focusable", "true");
			add_location(circle6, file$1, 1537, 40, 93483);
			add_location(g13, file$1, 1535, 36, 93280);
			attr_dev(circle7, "class", "lastCircleMid");
			attr_dev(circle7, "fill", "url(#lastCircleMid_icon)");
			attr_dev(circle7, "cx", "267.984375");
			attr_dev(circle7, "cy", "293");
			attr_dev(circle7, "r", "12");
			attr_dev(circle7, "opacity", "0");
			add_location(circle7, file$1, 1540, 40, 93740);
			attr_dev(path7, "d", "M3.76491276,22.4309727 C5.88207272,19.902578 7.10843487, 16.447736 7.10843487,12.7446281 C7.10843487,9.90533039 6.38974128, 7.20188959 5.07542401,4.93464319 L1.71316547,5.67221801 L4.9100909, 0.48305188 L10.1719173,3.81663137 L7.11351005,4.48755064 C8.4088902, 6.93966677 9.10843487,9.78181395 9.10843487,12.7446281 C9.10843487, 16.6677555 7.87827881,20.3638018 5.71250857,23.1972812 L8.63385425, 24.3467251 L2.93165771,26.8255625 L0.595287046,21.1838396 L3.76491276, 22.4309727 Z");
			attr_dev(path7, "class", "");
			add_location(path7, file$1, 1548, 68, 94808);
			attr_dev(g14, "transform", "translate(313.742737, 140.576561) rotate(-2.000000) translate(-313.742737, -140.576561) translate(308.242737, 127.076561)");
			add_location(g14, file$1, 1547, 64, 94601);
			attr_dev(g15, "transform", "translate(207.000000, 318.000000)");
			add_location(g15, file$1, 1546, 60, 94486);
			attr_dev(g16, "transform", "translate(-516.000000, -445.000000)");
			attr_dev(g16, "fill", "#333333");
			attr_dev(g16, "fillrule", "nonzero");
			add_location(g16, file$1, 1545, 56, 94339);
			attr_dev(g17, "stroke", "none");
			attr_dev(g17, "strokewidth", "1");
			attr_dev(g17, "fill", "none");
			attr_dev(g17, "fillrule", "evenodd");
			attr_dev(g17, "opacity", "0.5");
			add_location(g17, file$1, 1544, 52, 94203);
			attr_dev(svg3, "width", "24");
			attr_dev(svg3, "height", "23");
			attr_dev(svg3, "viewBox", "0 0 11 27");
			attr_dev(svg3, "version", "1.1");
			attr_dev(svg3, "enablebackground", "new 0 0 8 24");
			add_location(svg3, file$1, 1543, 48, 94055);
			attr_dev(pattern3, "id", "lastCircleMid_icon");
			attr_dev(pattern3, "width", "20");
			attr_dev(pattern3, "height", "20");
			add_location(pattern3, file$1, 1542, 44, 93949);
			add_location(defs3, file$1, 1541, 40, 93897);
			add_location(g18, file$1, 1539, 36, 93695);
			add_location(g19, file$1, 1481, 32, 88412);
			attr_dev(svg4, "class", "drawing-compass-wrapper");
			add_location(svg4, file$1, 1480, 28, 88341);
			attr_dev(svg5, "class", "drawing_compass_svg h");
			attr_dev(svg5, "focusable", "false");
			add_location(svg5, file$1, 1479, 24, 88258);
			attr_dev(svg6, "width", "100%");
			attr_dev(svg6, "height", "100%");
			attr_dev(svg6, "id", "authoringSvg");
			attr_dev(svg6, "tabindex", "0");
			attr_dev(svg6, "aria-labelledby", "authoringSvgTitle");
			add_location(svg6, file$1, 1474, 20, 87880);
			attr_dev(div9, "id", "centerImg");
			attr_dev(div9, "class", "centerImg authCenterImg my-auto relative ml-0");
			add_location(div9, file$1, 1467, 16, 87333);
			add_location(div10, file$1, 1466, 12, 87310);
			add_location(center, file$1, 1440, 8, 84200);
			attr_dev(div11, "class", "drawing_module_container");
			add_location(div11, file$1, 1439, 4, 84152);
			add_location(main, file$1, 1438, 0, 84140);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div11);
			append_dev(div11, center);
			append_dev(center, div7);
			append_dev(div7, div5);
			append_dev(div5, div0);
			append_dev(div0, button0);
			append_dev(button0, i0);
			append_dev(div0, t0);
			append_dev(div0, button1);
			append_dev(button1, t1);
			append_dev(div0, t2);
			append_dev(div0, button2);
			append_dev(button2, i1);
			append_dev(div5, t3);
			append_dev(div5, div1);
			append_dev(div1, button3);
			append_dev(button3, i2);
			append_dev(div1, t4);
			append_dev(div1, button4);
			append_dev(button4, i3);
			append_dev(div1, t5);
			append_dev(div1, button5);
			append_dev(button5, i4);
			append_dev(div1, t6);
			append_dev(div1, button6);
			append_dev(button6, i5);
			append_dev(div5, t7);
			append_dev(div5, div2);
			append_dev(div2, button7);
			append_dev(button7, t8);
			append_dev(div5, t9);
			append_dev(div5, div3);
			append_dev(div3, button8);
			append_dev(button8, t10);
			append_dev(div5, t11);
			append_dev(div5, div4);
			append_dev(div4, button9);
			append_dev(button9, i6);
			append_dev(div7, t12);
			append_dev(div7, div6);
			append_dev(center, t14);
			append_dev(center, div10);
			append_dev(div10, div9);
			append_dev(div9, div8);
			append_dev(div8, button10);
			append_dev(button10, i7);
			append_dev(div9, t15);
			append_dev(div9, img);
			append_dev(div9, t16);
			append_dev(div9, svg6);
			append_dev(svg6, title);
			append_dev(title, t17);
			append_dev(svg6, g0);
			append_dev(svg6, g1);
			append_dev(svg6, g2);
			append_dev(svg6, svg5);
			append_dev(svg5, svg4);
			append_dev(svg4, g19);
			append_dev(g19, circle0);
			append_dev(g19, g3);
			append_dev(g3, line);
			append_dev(g19, g4);
			append_dev(g4, circle1);
			append_dev(g4, defs0);
			append_dev(defs0, pattern0);
			append_dev(pattern0, svg0);
			append_dev(svg0, path0);
			append_dev(svg0, path1);
			append_dev(svg0, path2);
			append_dev(svg0, path3);
			append_dev(svg0, circle2);
			append_dev(g19, g11);
			append_dev(g11, circle3);
			append_dev(g11, defs1);
			append_dev(defs1, pattern1);
			append_dev(pattern1, svg1);
			append_dev(svg1, g7);
			append_dev(g7, g5);
			append_dev(g5, rect0);
			append_dev(g7, g6);
			append_dev(g6, rect1);
			append_dev(svg1, g10);
			append_dev(g10, g8);
			append_dev(g8, path4);
			append_dev(g10, g9);
			append_dev(g9, path5);
			append_dev(g19, g12);
			append_dev(g12, circle4);
			append_dev(g12, defs2);
			append_dev(defs2, pattern2);
			append_dev(pattern2, svg2);
			append_dev(svg2, path6);
			append_dev(g19, g13);
			append_dev(g13, circle5);
			append_dev(g13, circle6);
			append_dev(g19, g18);
			append_dev(g18, circle7);
			append_dev(g18, defs3);
			append_dev(defs3, pattern3);
			append_dev(pattern3, svg3);
			append_dev(svg3, g17);
			append_dev(g17, g16);
			append_dev(g16, g15);
			append_dev(g15, g14);
			append_dev(g14, path7);
			append_dev(div11, t18);
			mount_component(drawingmodal, div11, null);
			append_dev(main, t19);
			mount_component(dialog, main, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button10, "click", /*openModal*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*state*/ 1 && !src_url_equal(img.src, img_src_value = /*bgImgPath*/ ctx[1] + /*state*/ ctx[0].bgImg)) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty[0] & /*state*/ 1 && img_alt_value !== (img_alt_value = /*state*/ ctx[0].alt)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if ((!current || dirty[0] & /*state*/ 1) && t17_value !== (t17_value = /*state*/ ctx[0].alt + "")) set_data_dev(t17, t17_value);

			if (!current || dirty[0] & /*state*/ 1 && circle5_fill_value !== (circle5_fill_value = /*state*/ ctx[0].lineColor)) {
				attr_dev(circle5, "fill", circle5_fill_value);
			}

			const dialog_changes = {};

			if (dirty[0] & /*state*/ 1 | dirty[2] & /*$$scope*/ 64) {
				dialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_visible && dirty[0] & /*state*/ 1) {
				updating_visible = true;
				dialog_changes.visible = /*state*/ ctx[0].openDeleteDialog;
				add_flush_callback(() => updating_visible = false);
			}

			dialog.$set(dialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(drawingmodal.$$.fragment, local);
			transition_in(dialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(drawingmodal.$$.fragment, local);
			transition_out(dialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(drawingmodal);
			destroy_component(dialog);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function isNumeric(num) {
	return !isNaN(parseFloat(num)) && isFinite(num);
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Drawing', slots, []);
	let { xml } = $$props;
	let { getChildXml } = $$props;
	let bgImgPath = 'https://s3.amazonaws.com/jigyaasa_content_static/';
	let xmlns = "http://www.w3.org/2000/svg";

	// denotes that drawing is not sketching
	let isDrawing = false;

	// used to creates an element with the specified namespace URI and qualified name
	let scribble;

	// denotes mouse co-ordinates
	let auth_mouseX, auth_mouseY;

	// container of drawing sketched by the help of drawing tools
	let drawing_paths;

	// scribble drawing tool is enable
	let authoringMode = 'scribble';

	// strike color of drawing
	let authColor = '#00BCD4';

	// stroke width of the drawing
	let authThickness = 5;

	// contains object that have key type, index, mode, order and d
	let scribblePath = [];

	// contains sequence of the drawing
	let scribbleCount = 0;

	// contains current mouse x position
	let checkCurrentPositionX;

	// contains current mouse y position
	let checkCurrentPositionY;

	// denoes no of undo done
	let undoCount = 0;

	// contains undo data
	let undo_list = [];

	// contains redo data
	let redo_list = [];

	// used to check validateInput
	let isValid = true;

	// for compass variable
	// denotes x co-ordinate of the center
	let cx;

	// denotes y co-ordinate of the center
	let cy;

	// denotes x co-ordinate of the center of middle circle lies on rotationbar
	let midCircle_cx;

	// denotes x co-ordinate of the center of middle circle lies on rotationbar
	let midCircle_cy;

	// denotes center of x co-ordinate of small middle circle lies on rotationbar
	let midSmallCircle_cx;

	// denotes x co-ordinate of the center of small middle circle lies on rotationbar
	let midSmallCircle_cy;

	// denotes center of x co-ordinate of last circle lies on rotationbar
	let lastCircle_cx;

	// denotes x co-ordinate of the center of last circle lies on rotationbar
	let lastCircle_cy;

	// denotes center of x co-ordinate of rotation indicator
	let lastSmallCircle_cx;

	// denotes x co-ordinate of the center of rotation indicator
	let lastSmallCircle_cy;

	// radius of the compass
	let compassRadius;

	// denotes that compass is not moved
	let isCompassMove = false;

	// sets the default angle of compass
	let compassAngle = 90;

	// denotes that compass radius not increased
	let isRadiusIncrease = 0;

	// denotes initial points co-ordinate
	let initialPoint = { x: null, y: null };

	// denotes final points co-ordinate
	let finalPoint = { x: null, y: null };

	// denotes that is radius rotated
	let isRadiusRotate = 0;

	// used for answer recording
	let defaultXML = '';

	// defines that not any point added using 'Add Point' button
	let selectionPoint = 0;

	// used for store the point added by clicking on 'Add Point' button
	let selectionArray = [];

	// used to contain the x, y and radius of Point added by clicking on 'Add Point' button
	let cdata = '';

	// used to enables the drawing tools that can be used to draw the drawing
	let selectedToolsArray = ["_scribble", "_line", "_compass"];

	// used for access the focus points using keyboard
	let isAccessibleMarking = 1;

	// contains the focusPoints
	let accessibilityPoints = [];

	// array contains x and y co-ordinate of added focus point
	let tempAccessPoints = [];

	// number of focus point exist
	let focusPointCount = 1;

	let auth_store = writable({
		// contains the xml
		xml: '',
		// used to open the configuration dialog box
		bgImg: 'useraccount_000ANv.png',
		snackback: false,
		// contains points used for correct answer
		cDATA: '',
		// contains focus points that can be access via keyboard 
		focusDATA: '',
		imgWidth: "600",
		alt: "Triangle image",
		// message for snackbar
		message: '',
		// contains drawing tools
		selectedTools: selectedToolsArray,
		// for stroke color of drawing
		lineColor: '#00BCD4',
		// for mark point color
		markPointColor: '#00FF00'
	});

	let state = {};

	const unsubscribe = auth_store.subscribe(value => {
		$$invalidate(0, state = value);
	});

	afterUpdate(async () => {
		if (state.xml != xml) {
			// for changing the data when XML is changed manually 
			parseXMLForGettingData();

			$$invalidate(0, state.xml = xml, state);
		}
	});

	// call after html render and added the necessary events
	onMount(async () => {
		drawing_paths = AH.select('.drawing_paths');

		AH.setAttr('.centerImg #svgImg', {
			'src': bgImgPath + '' + state.bgImg,
			'alt': state.alt,
			'width': state.imgWidth
		});

		AH.setAttr('.auth_drawing_toolbar', {
			'style': 'width:' + (Number(state.imgWidth) + 2) + 'px'
		});

		AH.setAttr('.authCenterImg', {
			'style': 'width:' + (Number(state.imgWidth) + 2) + 'px'
		});

		updateCompassCalculation(160, 118, 100, 90);

		AH.listen('body', 'mousedown', '#authoringSvg .mid_circle', function () {
			if (authoringMode == "compass") {
				// checks if radius of the circle increased
				isRadiusIncrease = 1;
			}
		});

		AH.listen('body', 'mousedown', '#authoringSvg .midSmallCircle', function () {
			if (authoringMode == "compass") {
				// checks if radius of the circle increased
				isRadiusRotate = 1;
			}
		});

		AH.listen('body', 'mousedown', '#authoringSvg .drawing_compass_center', function (current, event) {
			if (authoringMode == "compass") {
				// used to set the x and y co-ordinate of the mouse position
				setMouseCoordinates(event);

				// contains the value of center x
				cx = auth_mouseX;

				// contains the value of center y
				cy = auth_mouseY;

				// contains the value of compass route radius
				compassRadius = AH.select('.drawing-compass-route').getAttribute('r');

				// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
				updateCompassCalculation(cx, cy, compassRadius, compassAngle);

				// rotate the small middle circle at defined angle from its center position
				AH.selectAll('#authoringSvg .midSmallCircle', 'attr', {
					"transform": "rotate(" + compassAngle + "," + AH.select('#authoringSvg .midSmallCircle').getAttribute('cx') + "," + AH.select('#authoringSvg .midSmallCircle').getAttribute('cy') + ")"
				});

				// rotate the middle circle at defined angle from its center position
				AH.selectAll('#authoringSvg .mid_circle', 'attr', {
					"transform": "rotate(" + compassAngle + "," + AH.select('#authoringSvg .mid_circle').getAttribute('cx') + "," + AH.select('#authoringSvg .mid_circle').getAttribute('cy') + ")"
				});

				// rotate the rotation indicator circle at defined angle from its center position
				AH.selectAll('#authoringSvg .lastCircleMid', 'attr', {
					"transform": "rotate(" + compassAngle + "," + AH.select('#authoringSvg .lastCircleMid').getAttribute('cx') + "," + AH.select('#authoringSvg .lastCircleMid').getAttribute('cy') + ")"
				});

				// defines that compass moved
				isCompassMove = true;
			}
		});

		AH.listen('body', 'mousemove', '#authoringSvg .lastCircle', function (current) {
			// adds the class 'lastCircle_hover' to the last circle on compass rotation bar lies on route of the compass
			current.classList.add("lastCircle_hover");

			// shows the rotational indicator
			AH.selectAll('#authoringSvg .lastCircleMid', 'attr', { 'opacity': 1 });
		});

		AH.listen('body', 'mouseout', '#authoringSvg .lastCircle', function (current) {
			// removes the class 'lastCircle_hover' to the last circle on compass rotation bar lies on route of the compass
			current.classList.remove("lastCircle_hover");

			// hides the rotational indicator
			AH.selectAll('#authoringSvg .lastCircleMid', 'attr', { 'opacity': 0 });
		});

		AH.listen('body', 'mousedown', '#authoringSvg .lastCircle', function (current) {
			if (authoringMode == "compass") {
				// used check that drawing 
				isDrawing = true;

				// checks if compass rotaionbar rotated
				isRadiusRotate = 1;

				// change the cursor style to grabbing for the circle that lies on the compass route
				AH.selectAll('#authoringSvg .lastCircle', 'css', { 'cursor': 'grabbing' });

				// Creates an element with the value of variable xmlns namespace URI and path name.
				scribble = document.createElementNS(xmlns, 'path');

				// sets the stroke width and color of the drawing drawn by scribble drawing tool
				setAuthColor(authColor, authThickness);

				// adds a new attribute 'data-type' (with a namespace null)
				scribble.setAttributeNS(null, 'data-type', authoringMode + '_' + scribbleCount);

				// adds a new attribute 'data-order' (with a namespace null)
				scribble.setAttributeNS(null, 'data-order', scribbleCount);

				// adds a new attribute 'd' (with a namespace null)
				scribble.setAttributeNS(null, 'd', 'M' + lastCircle_cx + ' ' + lastCircle_cy);

				// contains the center x of last circle on rotationbar
				checkCurrentPositionX = lastCircle_cx;

				// contains the center y of last circle on rotationbar
				checkCurrentPositionY = lastCircle_cy;

				// pushes the object containing keys mode, order, type, index and d 
				scribblePath.push({
					mode: 'add',
					order: scribbleCount,
					type: authoringMode + '_' + scribbleCount,
					index: scribbleCount,
					d: 'M' + lastCircle_cx + ' ' + lastCircle_cy
				});
			}
		});

		AH.listen('body', 'mousedown', '#authoringSvg', function (current, event) {
			// used to set the UI of the buttons and sketch or remove the drawing and adds focus point to access via keyboard
			authoringMousedownDraw(event);
		});

		// only for authoring area for adding answer points 
		AH.listen('body', 'click', '#authoring_point', function (current) {
			// parses the point that can be access via keyboard on preview side
			parseXMLForAccessPoint();

			// removes the class active from element have class 'authoring_btn' or id 'focus_point'
			AH.selectAll('.authoring_btn, #focus_point', 'removeClass', 'active');

			// adds the class active to 'Add Point' button
			current.classList.add('active');

			// assign the value 'authoring_point' to variable 'authoringMode'
			authoringMode = 'authoring_point';

			// removes the class 'eraserHover' from the elements have tag name path inside the element have id authoringSvg
			AH.selectAll('#authoringSvg path', 'removeClass', 'eraserHover');

			// sets the cursor style to 'unset'
			AH.selectAll('#authoringSvg', 'css', { 'cursor': 'unset' });

			// hides the compass element
			AH.selectAll('.drawing_compass_svg', 'addClass', 'h');

			if (AH.select('#authoring_point').innerText == "Add Point") {
				// increases the value of variable 'selectedPoint to detect that how many points are added using 'Add Point' button
				selectionPoint++;

				// push the object taking the initial point of x and y co-ordinate and radius of the circle into arraay 'selectionArray' that is added using 'Add Point' button
				selectionArray.push({ Center_X: 90, Center_Y: 68, radius: 33 });

				// draw the point after click on 'Add Point' button
				AH.insert('#centerImg', '<div class="resize" data-point="' + selectionPoint + '"><div class="resizer icomoon-resize"></div></div>', 'beforeend');

				// updates the marking points xml after to resize or drag the points
				setPointDataInXML();
			}

			if (!(AH.select('.resize').nodeName && AH.select('.resize').offsetHeight) || selectionPoint == 0) {
				// shows the points created using 'Add Point' button
				AH.selectAll('.resize', 'removeClass', 'h');

				// hides the compass element
				AH.selectAll('.drawing_compass_svg', 'addClass', 'h');

				// Adds the text 'Add Point' of the button having text 'Show Point'
				AH.select('#authoring_point').innerText = 'Add Point';
			}

			AH.select('#add_point_msg').classList.remove('h');
		});

		// Mouse Move Event
		AH.listen('body', 'mousemove', '#authoringSvg', function (current, event) {
			// used to set the x and y co-ordinate of the mouse position
			setMouseCoordinates(event);

			switch (authoringMode) {
				case 'line':
					if (isDrawing) {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, 'd', scribblePath[scribbleCount].d + ' L' + auth_mouseX + ' ' + auth_mouseY);

						// prepend the element scribble into the container have class drawing_paths
						drawing_paths.prepend(scribble);
					}
					break;
				case 'scribble':
					if (isDrawing) {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, 'd', scribblePath[scribbleCount].d + ' L' + auth_mouseX + ' ' + auth_mouseY);

						// adds the x an y mouse position with prefix 'L' into the value of key 'd' of array 'scribblePath' with index no containing into variable scribbleCount
						scribblePath[scribbleCount].d = scribblePath[scribbleCount].d + ' L' + auth_mouseX + ' ' + auth_mouseY;

						// prepend the element scribble into the container have class drawing_paths
						drawing_paths.prepend(scribble);
					}
					break;
				case 'compass':
					if (isCompassMove) {
						// defines the center of the x co-ordinate
						cx = auth_mouseX;

						// contains the center of the x co-ordinate
						cy = auth_mouseY;

						// radius of the compass or width of the rotationbar of the compass
						compassRadius = AH.select('.drawing-compass-route').getAttribute('r');

						// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
						updateCompassCalculation(cx, cy, compassRadius, compassAngle);
					}
					if (isRadiusIncrease) {
						// calculates the angle using initial and final point and find the radius of the compass
						checkRadiusPointsAndAngle();

						// rounds the angle to make it integer value
						compassAngle = Math.round(compassAngle);

						// calculates the radius of the compass
						compassRadius = 2 * Math.sqrt(Math.pow(auth_mouseX - initialPoint.x, 2) + Math.pow(auth_mouseY - initialPoint.y, 2));

						if (compassRadius < 80) {
							compassRadius = 80;
						}

						if (compassRadius > 360) {
							compassRadius = 360;
						}

						// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
						updateCompassCalculation(initialPoint.x, initialPoint.y, compassRadius, compassAngle);
					}
					if (isRadiusRotate) {
						// used to set the x and y co-ordinate of the mouse position
						setMouseCoordinates(event);

						// calculates the angle using initial and final point and find the radius of the compass
						checkRadiusPointsAndAngle();

						// calculates the angle of the compass
						compassAngle = Math.atan2(auth_mouseY - initialPoint.y, auth_mouseX - initialPoint.x) * 180 / Math.PI;

						if (compassAngle < 0) {
							compassAngle = 360 + compassAngle;
						}

						// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
						updateCompassCalculation(initialPoint.x, initialPoint.y, compassRadius, compassAngle);
					}
					if (isDrawing) {
						if (!AH.select('#authoringSvg .last_big_circle').classList.contains('lastCircle_hover')) {
							authoringMouseLeave(event);
						} else {
							// adds a new attribute 'd' (with a namespace null)
							scribble.setAttributeNS(null, 'd', scribblePath[scribbleCount].d + ' L' + lastCircle_cx + ' ' + lastCircle_cy);

							// adds the values of center of x and y of last circle on rotationbar with prefix 'L' into the value of key 'd' of array 'scribblePath' with index no containing into variable scribbleCount
							scribblePath[scribbleCount].d = scribblePath[scribbleCount].d + ' L' + lastCircle_cx + ' ' + lastCircle_cy;

							// prepend the element scribble into the container have class drawing_paths
							drawing_paths.prepend(scribble);
						}
					}
					// rotates the small middle circle at given angle from it's center position
					AH.selectAll('#authoringSvg .midSmallCircle', 'attr', {
						"transform": "rotate(" + compassAngle + "," + AH.select('#authoringSvg .midSmallCircle').getAttribute('cx') + "," + AH.select('#authoringSvg .midSmallCircle').getAttribute('cy') + ")"
					});
					// rotates the middle circle at given angle from it's center position
					AH.selectAll('#authoringSvg .mid_circle', 'attr', {
						"transform": "rotate(" + compassAngle + "," + AH.select('#authoringSvg .mid_circle').getAttribute('cx') + "," + AH.select('#authoringSvg .mid_circle').getAttribute('cy') + ")"
					});
					// rotates the last circle at given angle from it's center position
					AH.selectAll('#authoringSvg .lastCircleMid', 'attr', {
						"transform": "rotate(" + compassAngle + "," + AH.select('#authoringSvg .lastCircleMid').getAttribute('cx') + "," + AH.select('#authoringSvg .lastCircleMid').getAttribute('cy') + ")"
					});
					break;
			}
		});

		// Mouse Up Event
		AH.listen('body', 'mouseup', '#authoringSvg', function (current, event) {
			authoringMouseLeave(event);
		});

		AH.bind('#authoringSvg', 'mouseleave', function (event) {
			authoringMouseLeave(event);
		});

		AH.listen('body', 'click', '#authoring_clearScreen', function (current) {
			// makes drawing container empty in which drawing is done by using drawing tools
			AH.select('.drawing_paths').innerHTML = '';

			// sets the value of variable 'undoCount' to  0
			undoCount = 0;

			// sets the value of variable 'scribbleCount' to  0
			scribbleCount = 0;

			// makes array 'scribblePath' empty 
			scribblePath = [];

			// disabled the undo, redo, cross (x) buttons
			AH.select('#authoring_undo').disabled = true;

			AH.select('#authoring_redo').disabled = true;
			AH.select('#authoring_clearScreen').disabled = true;
		});

		AH.listen('body', 'click', '.auth_toolbar', function (current) {
			// hides the points added by clicking on 'Add Point' button
			AH.selectAll('.resize', 'addClass', 'h');

			// parses the point that can be access via keyboard on preview side
			parseXMLForAccessPoint();

			// sets the style of the cursor to crosshair (+)
			AH.selectAction('#authoringSvg', 'css', { 'cursor': 'crosshair' });

			// contains the value of attribute 'data-title' on which currently clicked
			authoringMode = current.getAttribute('data-title');

			AH.selectAll('.authoring_btn,#authoring_point,#focus_point', 'removeClass', 'active');
			current.classList.add('active');

			if (authoringMode == 'eraser') {
				// adds the class 'eraserHover' to the element 'path' inside drawing container in which drawing is done by using drawing tools
				AH.selectAll('.drawing_paths path', 'addClass', 'eraserHover');
			} else {
				// removes the class 'eraserHover' to the element 'path' inside drawing container in which drawing is done by using drawing tools
				AH.selectAll('.drawing_paths path', 'removeClass', 'eraserHover');
			}

			if (authoringMode == 'compass') {
				// shows the compass tool
				AH.selectAll('.drawing_compass_svg', 'removeClass', 'h');
			} else {
				// hides the compass element
				AH.selectAll('.drawing_compass_svg', 'addClass', 'h');
			}

			if (selectionPoint != 0) {
				// sets the text 'Show Point' of the element having id 'authoring_point' if the value of variable 'selectionPoint' is not equals to 0
				AH.select('#authoring_point').innerText = 'Show Point';

				AH.select('#add_point_msg').classList.add('h');
			}
		});

		AH.listen('body', 'mouseover', '.drawing_paths path', function (current) {
			if (authoringMode == 'eraser') {
				// removes the class currentSvg from the element 'path' inside the element have class 'drawing_paths'
				AH.selectAll('.drawing_paths path', 'removeClass', 'currentSvg');

				// adds the class 'currentSvg' to the element 'path' inside the element have class 'drawing_paths' on which mouseover
				current.classList.add('currentSvg');
			}
		});

		AH.listen('body', 'mouseout', '.drawing_paths path', function (current) {
			if (authoringMode == 'eraser') {
				// removes the class 'currentSvg' to the element 'path' inside the element have class 'drawing_paths' on which mouseout
				current.classList.remove('currentSvg');
			}
		});

		AH.listen('body', 'click', '#authoring_undo', function (current) {
			if (undoCount == 1) {
				// disabled the undo button
				current.disabled = true;

				// enabled the redo button
				AH.select('#authoring_redo').disabled = false;
			} else {
				// enabled the redo button
				AH.select('#authoring_redo').disabled = false;
			}

			if (scribblePath[scribblePath.length - 1].mode == 'add') {
				// removes the element which 'data-order' attributes value is equals to the value of array length scribblePath reducing by 1
				AH.select('#authoringSvg [data-order="' + (scribblePath.length - 1) + '"]', 'remove');
			} else if (scribblePath[scribblePath.length - 1].mode == 'remove') {
				// Creates an element with the specified namespace URI and qualified name.
				scribble = document.createElementNS(xmlns, 'path');

				// sets the stroke width and color of the drawing drawn by scribble drawing tool
				setAuthColor(authColor, authThickness);

				// adds a new attribute 'data-type' (with a namespace null)
				scribble.setAttributeNS(null, 'data-type', scribblePath[scribblePath.length - 1].type);

				// adds a new attribute 'data-order' (with a namespace null)
				scribble.setAttributeNS(null, 'data-order', scribblePath[scribblePath.length - 1].order);

				// adds a new attribute 'd' (with a namespace null)
				scribble.setAttributeNS(null, 'd', scribblePath[scribblePath.length - 1].d);

				if (authoringMode == 'eraser') {
					// adds a new attribute 'class' (with a namespace null)
					scribble.setAttributeNS(null, 'class', 'eraserHover');
				}

				// prepend the element scribble into the container have class drawing_paths
				drawing_paths.prepend(scribble);
			}

			// pushes the last data of array scribblePath into array undo_list
			undo_list.push(scribblePath.pop());

			// reduces the value of variable 'scribbleCount' by 1
			scribbleCount--;

			// reduces the value of variable 'undoCount' by 1
			undoCount--;

			if (AH.selectAll('.drawing_paths path').length == 0) {
				// disabled the cross (x) button if no drawing sketched by using drawing tools
				AH.select('#authoring_clearScreen').disabled = true;
			} else {
				// enables the cross (x) button if drawing has been sketched by using drawing tools
				AH.select('#authoring_clearScreen').disabled = false;
			}

			if (scribblePath.length == 0) {
				// disabled the undo button if length of the array 'scribblePath' is 0 
				current.disabled = true;
			}
		});

		AH.listen('body', 'click', '#authoring_redo', function (current) {
			// increases the value of the variable 'scribbleCount' by 1
			scribbleCount++;

			if (undo_list.length > 0) {
				// pushes the last data of the array undo_list into array redo_list
				redo_list.push(undo_list.pop());
			}

			if (redo_list[redo_list.length - 1].mode == 'add') {
				// Creates an element with the specified namespace URI and qualified name.
				scribble = document.createElementNS(xmlns, 'path');

				// sets the stroke width and color of the drawing drawn by scribble drawing tool
				setAuthColor(authColor, authThickness);

				// adds a new attribute 'data-type' (with a namespace null)
				scribble.setAttributeNS(null, 'data-type', redo_list[redo_list.length - 1].type);

				// adds a new attribute 'data-order' (with a namespace null)
				scribble.setAttributeNS(null, 'data-order', redo_list[redo_list.length - 1].order);

				// adds a new attribute 'd' (with a namespace null)
				scribble.setAttributeNS(null, 'd', redo_list[redo_list.length - 1].d);

				if (authoringMode == 'eraser') {
					// adds a new attribute 'class' (with a namespace null)
					scribble.setAttributeNS(null, 'class', 'eraserHover');
				}

				// prepend the element scribble into the container have class drawing_paths
				drawing_paths.prepend(scribble);
			} else if (redo_list[redo_list.length - 1].mode == 'remove') {
				// removes the element which 'data-order' attributes value is equals to the value of order key of last data in array redo_list
				AH.select('#authoringSvg [data-order="' + redo_list[redo_list.length - 1].order + '"]', 'remove');
			}

			// increases the value of variable 'undoCount' by 1
			undoCount++;

			// pushes the last value of the array redo_list into array scribblePath
			scribblePath.push(redo_list.pop());

			if (AH.selectAll('.drawing_paths path').length == 0) {
				// disabled the cross (x) button if no drawing is sketched by using drawing tools
				AH.select('#authoring_clearScreen').disabled = true;
			} else {
				// enables the cross (x) button if any drawing is sketched by using drawing tools
				AH.select('#authoring_clearScreen').disabled = false;
			}

			if (undo_list.length == 0) {
				// disabled the redo button if no data exist in array undo_list
				current.disabled = true;

				// enables the undo button if no data exist in array undo_list
				AH.select('#authoring_undo').disabled = false;
			} else {
				// enables the undo button if data exist in array undo_list
				AH.select('#authoring_undo').disabled = false;
			}
		});

		AH.listen('body', 'click', '#reset_btn', function () {
			// swal({
			//     text: l.reset_module,
			//     icon: "warning",
			//     buttons: ["cancel","ok"],
			// }).then((value) => {
			//     if (value) {
			//         // reset all the activity and makes it in initial condition as it looks like just after load
			//         resetModule();
			//     }
			// });
			$$invalidate(0, state.openDeleteDialog = true, state);
		});

		AH.listen('body', 'click', '#focus_point', function () {
			// hides the compass element
			AH.selectAll('.drawing_compass_svg', 'addClass', 'h');

			AH.selectAll('#authoringSvg path', 'removeClass', 'eraserHover');

			// sets the cursor style as crosshair (+)
			AH.select('#authoringSvg', 'css', { 'cursor': 'crosshair' });

			// hides the circle shape element created using 'Add Point' button
			AH.selectAll('.resize', 'addClass', 'h');

			if (selectionPoint != 0) {
				// if any point created using 'Add point' button then after click on 'Add Focus Point' or 'Finish Marking' button text of 'Add Point' button changes to 'Show Point'
				AH.select('#authoring_point').innerText = 'Show Point';

				AH.select('#add_point_msg').classList.add('h');
			}

			if (isAccessibleMarking) {
				// removes the class active from the drawing tools, delete and 'Add Point' buttons
				AH.selectAll('.authoring_btn,#authoring_point', 'removeClass', 'active');

				// adds the class active to the button have id 'focus_point' and change the text as 'Finish Marking'
				AH.select('#focus_point').innerText = "Finish Marking";

				AH.select('#focus_point', 'addClass', 'active');

				// sets the value of variable 'isAccessibleMarking' to 0 
				isAccessibleMarking = 0;

				// sets the value of variable 'authoringMode' to 'markAccessibilityPoint'
				authoringMode = 'markAccessibilityPoint';
			} else {
				// parses the point that can be access via keyboard on preview side
				parseXMLForAccessPoint();
			}
		});

		AI.listen('body', 'contextmenu', '.resize', function (current, event) {
			event.preventDefault();

			swal({
				text: l.delete_points,
				icon: "warning",
				buttons: true
			}).then(value => {
				if (value) {
					let btnIndex = current.getAttribute("data-point");

					// makes the x co-ordinate of the point null
					selectionArray[btnIndex - 1].Center_X = null;

					// makes the y co-ordinate of the point null
					selectionArray[btnIndex - 1].Center_Y = null;

					// makes the radius of the point null
					selectionArray[btnIndex - 1].radius = null;

					// removes the point
					current.remove();

					// this function will set the point value in xml 
					setPointDataInXML();
				}
			});
		});

		AI.listen('body', 'keyup', '.authoring-modal input', function (current, event) {
			event.stopPropagation();
			AH.selectAll('.error', 'remove');
			validateInput(current);
		});

		AI.listen('body', 'change', '.authoring-modal input', function (current, event) {
			event.stopPropagation();
			AH.selectAll('.error', 'remove');
			validateInput(current);
		});

		AI.listen('body', 'click', '.drawing_modal_submit', function (current, event) {
			if (isValid && AH.selectAll('.showError').length == 0) {
				selectedToolsArray = [];
				let checkboxes = AH.selectAll('.checkbox-inline:checked');

				for (let index = 0; index < checkboxes.length; index++) {
					/* pushes the drawing tools value that can be used to draw the drawing into the array of drawing tools by checking the checkbox of tools group in configaration modal box */
					selectedToolsArray.push(checkboxes[index].value);
				}

				auth_store.update(item => {
					item.bgImg = AH.select('#backgroundImage').value;

					// sets the alt message for background image
					item.alt = AH.select('#imgAlt').value.trim();

					// sets the width of background image
					item.imgWidth = AH.select('#imgWidth').value;

					// sets the stroke color of drawing shape
					item.lineColor = AH.select('#lineColor').value;

					// sets the point color of drawing shape on Preview area
					item.markPointColor = AH.select('#markPointColor').value;

					// sets which type of drawing tools can be used to draw the drawing such as scribble, line or compass
					item.selectedTools = selectedToolsArray;

					return item;
				});

				resetModule();
				parseXMLForSettingData(xml);
				AH.getBS('#drawing-modal', 'Modal').hide();
			} else {
				swal({
					text: "Please solve all the errors!",
					icon: "warning"
				});
			}
		});

		AH.listen('body', 'click', '#upload_media', function () {
			AH.getBS('#modal-media-upload', 'Modal').show();
		});

		enableDragResize();
	});

	// function for validation of the modal's input
	function validateInput(current) {
		// sets the value of isValid variable to true
		isValid = true;

		if (current.value.trim() == '') {
			isValid = false;
			AH.insert(current.parentElement, '<span class="error text-danger">' + l.fill_warning + '</span>', 'beforeend');
		} else if (current.classList.contains('num') && Number(current.value) < 600) {
			isValid = false;

			// shows warning message if width of image is less than 600
			AH.insert(current.parentElement, '<span class="error text-danger">' + l.val_gt_limit + '</span>', 'beforeend');
		} else if (!isNumeric(current.value) && current.classList.contains('num')) {
			// sets the value of isValid variable to false
			isValid = false;

			// shows warning message if width of image takes any non number data but it cannot be seen as field has not allowed to take non numeric data
			AH.insert(current.parentElement, '<span class="error text-danger">' + l.enter_number + '</span>', 'beforeend');
		} else if (AH.selectAll('.checkbox-inline:checked').length == 0 && current.classList.contains('checkbox-inline')) {
			// sets the value of isValid variable to false
			isValid = false;

			// shows warning message if no any drawing tools selected
			AH.insert(current.closest('.toolsCheckbox').parentElement, '<span class="error text-danger">' + l.select_one_tool + '</span>', 'beforeend');
		}

		if (isValid) {
			if (current.classList.contains('checkbox-inline')) {
				// in case when current element which value changed has class 'checkbox-inline' and value of variable 'isValid' is true then removes class 'showError to the element have id backgroundImage
				AH.select('#backgroundImage').classList.remove('showError');
			} else {
				// in case when current element which value changed has not class 'checkbox-inline' and value of variable 'isValid' is true then removes class 'showError from current element and removes border and background color
				current.classList.remove('showError');

				AH.setCss(current, { "border": "", "background": "" });
			}
		} else {
			if (current.classList.contains('checkbox-inline')) {
				// in case when current element which value changed has class 'checkbox-inline' and value of variable 'isValid' is false then adds class 'showError to the element have id backgroundImage
				AH.select('#backgroundImage').classList.add('showError');
			} else {
				current.classList.add('showError');

				// in case when current element which value changed has not class 'checkbox-inline' and value of variable 'isValid' is false then adds 'showError' class and sets border color to red and background color to #FFCECE
				AH.setCss(current, {
					"border": "1px solid red",
					"background": "#FFCECE"
				});
			}
		}
	}

	// function for enabling resize and dragging
	function enableDragResize() {
		let draggable = new Draggable({
				containment: '#authoringSvg',
				classes: ".resize",
				ignore: ['.tools', '.resizer']
			});

		draggable.onDragStop = function (event, position, ui) {
			let pointIndex = ui.getAttribute("data-point");

			// sets the height value to it's width value
			AH.setCss(ui, {
				height: ui.offsetWidth + "px",
				width: ui.offsetWidth + "px"
			});

			// contains the radius of the point
			let h = ui.offsetHeight / 2;

			// contains x co-ordinate of the point
			let CenterX = position.left + h;

			// contains y co-ordinate of the point
			let CenterY = position.top + h;

			// assign the value of the x co-ordinate of the point at index 'pointIndex-1' in array selectionArray
			selectionArray[pointIndex - 1].Center_X = CenterX;

			// assign the value of the y co-ordinate of the point at index 'pointIndex-1' in array selectionArray
			selectionArray[pointIndex - 1].Center_Y = CenterY;

			// assign the value of radius of the point at index 'pointIndex-1' in array selectionArray
			selectionArray[pointIndex - 1].radius = h;

			// this function will set the point value in xml 
			setPointDataInXML();
		};

		let resizable = new Resizable('#authoringSvg', '.resize');

		resizable.onStop = function (e, ui) {
			let pointIndex = ui.getAttribute("data-point");

			// sets the height of the selector element equal to width of that element
			let resolution = Number(ui.offsetWidth) > 66 ? 66 : ui.offsetWidth;

			AH.setCss(ui, {
				height: resolution + "px",
				width: resolution + "px"
			});

			// contains radius of the point
			let h = ui.offsetHeight / 2;

			// contains co-ordinate of center x
			let CenterX = ui.offsetLeft + h;

			// contains co-ordinate of center y
			let CenterY = ui.offsetTop + h;

			// sets the co-ordinate of center x of the point contained at index 'pointIndex -1' in array selectionArray
			selectionArray[pointIndex - 1].Center_X = CenterX;

			// sets the co-ordinate of center y of the point contained at index 'pointIndex -1' in array selectionArray
			selectionArray[pointIndex - 1].Center_Y = CenterY;

			// sets the radius of the point contained at index 'pointIndex -1' in array selectionArray
			selectionArray[pointIndex - 1].radius = h;

			// this function will set the point value in xml 
			setPointDataInXML();
		};
	}

	// function called on the mouse leave on the authoring svg
	function authoringMouseLeave(event) {
		switch (authoringMode) {
			case 'line':
			case 'scribble':
				if (isDrawing) {
					// used to set the x and y co-ordinate of the mouse position
					setMouseCoordinates(event);

					if (checkCurrentPositionX == auth_mouseX && checkCurrentPositionY == auth_mouseY) {
						// removes the last value from array scribblePath
						scribblePath.pop();
					} else {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, 'd', scribblePath[scribbleCount].d + ' L' + auth_mouseX + ' ' + auth_mouseY);

						// adds the x an y mouse position with prefix 'L' into the value of key 'd' of array 'scribblePath' with index no containing into variable scribbleCount
						scribblePath[scribbleCount].d = scribblePath[scribbleCount].d + ' L' + auth_mouseX + ' ' + auth_mouseY;

						// prepend the element scribble into the container have class drawing_paths
						drawing_paths.prepend(scribble);

						// increases the value variable 'scribbleCount' by 1
						scribbleCount++;

						// increases the value variable 'undoCount' by 1
						undoCount++;

						// makes array undo_list blank
						undo_list = [];

						// enables undo and cross (x) buttons
						AH.select('#authoring_undo').disabled = false;

						AH.select('#authoring_clearScreen').disabled = false;
						AH.select('#authoring_redo').disabled = true;
					}
				}
				isDrawing = false;
				break;
			case 'compass':
				isRadiusIncrease = 0;
				isRadiusRotate = 0;
				if (isCompassMove) {
					// used to set the x and y co-ordinate of the mouse position
					setMouseCoordinates(event);

					// contains x co-ordinate of the mouse
					cx = auth_mouseX;

					// contains y co-ordinate of the mouse
					cy = auth_mouseY;

					// contains radius of the compass
					compassRadius = AH.select('.drawing-compass-route').getAttribute('r');

					// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
					updateCompassCalculation(cx, cy, compassRadius, compassAngle);

					// defines the value of the variable 'isCompassMove' to false to indicate that compass is not moved
					isCompassMove = false;
				}
				if (isDrawing) {
					if (checkCurrentPositionX == lastCircle_cx && checkCurrentPositionY == lastCircle_cy) {
						// removes the last element from the array 'scribblePath'
						scribblePath.pop();
					} else {
						// adds a new attribute 'd' (with a namespace null)
						scribble.setAttributeNS(null, 'd', scribblePath[scribbleCount].d + ' L' + lastCircle_cx + ' ' + lastCircle_cy);

						// adds the values of center of x and y of last circle on rotationbar with prefix 'L' into the value of key 'd' of array 'scribblePath' with index no containing into variable scribbleCount
						scribblePath[scribbleCount].d = scribblePath[scribbleCount].d + ' L' + lastCircle_cx + ' ' + lastCircle_cy;

						// prepend the element scribble into the container have class drawing_paths
						drawing_paths.prepend(scribble);

						// increases the value of the variable 'scribbleCount' by 1
						scribbleCount++;

						// increases the value of the variable 'undoCount' by 1
						undoCount++;

						// makes blank array undo_list 
						undo_list = [];

						// enables undo and cross (x) button
						AH.select('#authoring_undo').disabled = false;

						AH.select('#authoring_clearScreen').disabled = false;
						AH.select('#authoring_redo').disabled = true;
					}

					// assign the value 'false' of the variable 'isDrawing' to indicate that drawing is not sketching
					isDrawing = false;
				}
				// defines the style of the cursor when it goes to last circle of the rotationbar
				AH.selectAll('#authoringSvg .lastCircle', 'css', { 'cursor': 'grab' });
				break;
		}
	}

	// updates the position of rotationbar and change the center position of the circles that lies on rotationbar
	function updateCompassCalculation(cx, cy, compassRadius, compassAngle) {
		// sets the center of x of middle circle lies on compass rotationbar
		midCircle_cx = cx + compassRadius / 2 * Math.cos(compassAngle * (Math.PI / 180));

		// sets the center of y of middle circle lies on compass rotationbar
		midCircle_cy = cy + compassRadius / 2 * Math.sin(compassAngle * (Math.PI / 180));

		// sets the center of x of small middle circle lies on compass rotationbar
		midSmallCircle_cx = cx + 3 * compassRadius / 4 * Math.cos(compassAngle * (Math.PI / 180));

		// sets the center of y of small middle circle lies on compass rotationbar
		midSmallCircle_cy = cy + 3 * compassRadius / 4 * Math.sin(compassAngle * (Math.PI / 180));

		// sets the center of x of last circle lies on compass rotationbar
		lastCircle_cx = cx + compassRadius * Math.cos(compassAngle * (Math.PI / 180));

		// sets the center of y of last circle lies on compass rotationbar
		lastCircle_cy = cy + compassRadius * Math.sin(compassAngle * (Math.PI / 180));

		// sets the center of x of rotaion indicator shows after last circle of compass rotaionbar
		lastSmallCircle_cx = cx + 5 * compassRadius / 4 * Math.cos(compassAngle * (Math.PI / 180));

		// sets the center of y of rotaion indicator shows after last circle of compass rotaionbar
		lastSmallCircle_cy = cy + 5 * compassRadius / 4 * Math.sin(compassAngle * (Math.PI / 180));

		// used to set the center co-ordinate of the compass and of its route
		AH.selectAll('.drawing-compass-route, .drawing_compass_center', 'attr', { cx, cy });

		// sets the radius of the compass route
		AH.select('.drawing-compass-route').setAttribute('r', compassRadius);

		// sets the compass rotation bar's position
		AH.setAttr('#authoringSvg .compass_rotationBar', {
			'x1': cx,
			'y1': cy,
			'x2': lastCircle_cx,
			'y2': lastCircle_cy
		});

		// sets the position of rotaion indicator
		AH.setAttr('#authoringSvg .lastCircleMid', {
			'cx': lastSmallCircle_cx,
			'cy': lastSmallCircle_cy
		});

		// sets the center position of the last circle that lies on the compass route
		AH.selectAll('#authoringSvg .lastCircle', 'attr', { 'cx': lastCircle_cx, 'cy': lastCircle_cy });

		// sets the center position of the middle small circle that lies between last and middle circle on the compass rotaionbar
		AH.setAttr('#authoringSvg .midSmallCircle', {
			'cx': midSmallCircle_cx,
			'cy': midSmallCircle_cy
		});

		// sets the center position of the middle circle that lies on the compass rotaionbar    
		AH.setAttr('#authoringSvg .mid_circle', { 'cx': midCircle_cx, 'cy': midCircle_cy });
	}

	// for updating the cdata in the xml
	function setPointDataInXML() {
		cdata = '';

		for (let index = 0; index < selectionArray.length; index++) {
			// For avoiding the null value if found
			if (selectionArray[index].Center_X == null && selectionArray[index].Center_Y == null && selectionArray[index].radius == null) {
				// contains an array returned value from array selectionArray which is not null
				selectionArray = selectionArray.filter(function (element) {
					return element.Center_X != null;
				});

				continue;
			}

			// adds the value of center co-ordinate x and y and radius of the point at perticular index in the form of object and each point is separated with symbol '!'
			cdata += '{"x":"' + selectionArray[index].Center_X + '","y":"' + selectionArray[index].Center_Y + '","r":"' + selectionArray[index].radius + '"}!';
		}

		let resize = AH.selectAll('.resize');

		if (resize.length > 0) {
			for (let index = 0; index < selectionArray.length; index++) {
				AH.setAttr(resize[index], { "data-point": index + 1 });
			}
		} else {
			AH.select('#add_point_msg').classList.add('h');
			selectionPoint = 0;

			// removes the first character from string in state array selectedTools at index 0
			authoringMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

			// sets the cursor style to crosshair (+)
			AH.setCss('#authoringSvg', { 'cursor': 'crosshair' });

			if (authoringMode == 'compass') {
				// shows the compass tool
				AH.selectAll('.drawing_compass_svg', 'removeClass', 'h');
			} else {
				// hides the compass element
				AH.selectAll('.drawing_compass_svg', 'addClass', 'h');
			}

			AH.selectAll('.authoring_btn,#authoring_point,#focus_point', 'removeClass', 'active');
			AH.selectAll('[data-title="' + authoringMode + '"]', 'addClass', 'active');
		}

		// removes the last character that is '!' from variable 'cdata'
		cdata = cdata.substr(0, cdata.length - 1);

		// updates the cdata value that exist inside div element of the xml according to the value of points that were added or removed
		parseXMLForPoint(cdata);
	}

	// updates the cdata value that exist inside div element of the xml according to the value of points that were added or removed
	function parseXMLForPoint(cdata) {
		// converts the xml value into json and assign it into variable 'defaultXML'
		defaultXML = XMLToJSON(xml);

		// assign the value of argument 'cdata' to sub key 'cdata' of key 'div' of object 'defaultXML'
		defaultXML.smxml.div.__cdata = cdata;

		// converts json of xml into xml again
		defaultXML = JSONToXML(defaultXML);

		// changes the format of cdata
		defaultXML = defaultXML.replace(/<!\[CDATA\[/g, '<!--[CDATA[');

		// changes the format of cdata
		defaultXML = defaultXML.replace(/\]\]>/g, ']]-->');

		// update the xml
		getChildXml(defaultXML);

		// assign the value of changed xml into state xml
		$$invalidate(0, state.xml = defaultXML, state);
	}

	// calculates the angle using initial and final point and find the radius of the compass
	function checkRadiusPointsAndAngle() {
		// denotes the initial x co-ordinate
		initialPoint.x = Number(AH.select('.compass_rotationBar').getAttribute('x1'));

		// denotes the initial y co-ordinate
		initialPoint.y = Number(AH.select('.compass_rotationBar').getAttribute('y1'));

		// denotes the final x co-ordinate
		finalPoint.x = Number(AH.select('.compass_rotationBar').getAttribute('x2'));

		// denotes the final y co-ordinate
		finalPoint.y = Number(AH.select('.compass_rotationBar').getAttribute('y2'));

		// denotes the radius of the compass
		compassRadius = Number(AH.select('.drawing-compass-route').getAttribute('r'));

		// calculates the angle using initial and final point co-ordinate
		compassAngle = Math.atan2(finalPoint.y - initialPoint.y, finalPoint.x - initialPoint.x) * 180 / Math.PI;
	}

	// parses the point that can be access via keyboard on preview side
	function parseXMLForAccessPoint() {
		if (tempAccessPoints.length > 0) {
			// push the value of tempAccessPoints into array 'accessibilityPoints'
			accessibilityPoints.push(tempAccessPoints);
		}

		// contains json data of xml 
		defaultXML = XMLToJSON(xml);

		var focusPointData = '';

		// used to create the array object 'focusPointData' containing the x and y co-ordinates value of points draw on drawing board using 'Add Focus Point' button
		for (let points = 0; points < accessibilityPoints.length; points++) {
			focusPointData += '{"' + points + '":[';

			for (let subPoints = 0; subPoints < accessibilityPoints[points].length; subPoints++) {
				focusPointData += '{"x":"' + accessibilityPoints[points][subPoints].x + '","y":"' + accessibilityPoints[points][subPoints].y + '"}!';
			}

			focusPointData = focusPointData.substr(0, focusPointData.length - 1) + ']}!';
		}

		// removes the last character from variable 'focusPointData'
		focusPointData = focusPointData.substr(0, focusPointData.length - 1);

		// updates the cdata value with the value of variable 'focusPointData'
		defaultXML.smxml.backgroundPoint.__cdata = focusPointData;

		// converts json of xml into xml
		defaultXML = JSONToXML(defaultXML);

		// updates the format of CDATA
		defaultXML = defaultXML.replace(/<!\[CDATA\[/g, '<!--[CDATA[');

		// updates the format of CDATA
		defaultXML = defaultXML.replace(/\]\]>/g, ']]-->');

		// update the xml
		getChildXml(defaultXML);

		// updates the state 'xml'
		$$invalidate(0, state.xml = defaultXML, state);

		// changed the text of element have id 'focus_point' to 'Add Focus Point' and removes the class active
		AH.select('#focus_point').innerText = "Add Focus Point";

		AH.select('#focus_point').classList.remove('active');

		// assign the string to the variable 'authoringMode' after removing the first character from the string at index 0 of state array 'selectedTools'
		authoringMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

		// change the cursor style as crosshair (+)
		AH.setCss('#authoringSvg', { cursor: 'crosshair' });

		// adds the active class to scribber drawing tools
		AH.select('#authoring' + state.selectedTools[0]).classList.add('active');

		if (authoringMode == 'compass') {
			// shows the compass tool
			AH.selectAll('.drawing_compass_svg', 'removeClass', 'h');
		} else {
			// hides the compass element
			AH.selectAll('.drawing_compass_svg', 'addClass', 'h');
		}

		isAccessibleMarking = 1;

		// joins the focus points craeted by using 'Add focus Point' button otherwise return as it was before
		joinFocusPoint(tempAccessPoints);
	}

	// joins the focus points craeted by using 'Add focus Point' button otherwise return as it was before
	function joinFocusPoint(markArray) {
		if (markArray.length == 0) {
			return;
		}

		// Creates an element with the specified namespace URI and qualified name
		scribble = document.createElementNS(xmlns, 'path');

		// contains the string showing the start point
		let pointStartValues = 'M ' + markArray[0].x + ' ' + markArray[0].y;

		// contains the string showing the end point
		let pointEndValues = '';

		for (let index = 1; index < markArray.length; index++) {
			// adds the value of x anf y from array 'markArray' defined at specific index to variable 'pointEndValues'
			pointEndValues += ' L ' + markArray[index].x + ' ' + markArray[index].y;
		}

		// adds a new attribute (with a namespace)
		scribble.setAttributeNS(null, 'd', pointStartValues + '' + pointEndValues);

		// sets the stroke width and color of the drawing drawn by scribble drawing tool
		setAuthColor('rgb(128, 128, 128)', authThickness);

		// add as very first element inside the 'g' tag of 'svg' used for sketch the drawing
		AH.select('.backgroundFocusPath').prepend(scribble);

		// blanks the value of array 'tempAccessPoints'
		tempAccessPoints = [];
	}

	// used to set the x and y co-ordinate of the mouse position
	function setMouseCoordinates(event) {
		// contains the size of element having id 'authoringSvg' and its position relative to the viewport
		let boundary = document.getElementById('authoringSvg').getBoundingClientRect();

		// sets the x position of the mouse co-ordinate
		auth_mouseX = event.clientX - boundary.left;

		// sets the y position of the mouse co-ordinate
		auth_mouseY = event.clientY - boundary.top;
	}

	// sets the stroke width and color of the drawing drawn by scribble drawing tool
	function setAuthColor(authColor, authThickness) {
		// sets the stroke color of the scribble drawing
		scribble.style.stroke = authColor;

		// sets the stroke width of the scribble drawing
		scribble.style.strokeWidth = authThickness;

		scribble.style.fill = 'none';
	}

	// reset all the activity and makes it in initial condition as it looks like just after load
	function resetModule() {
		// updates the text of element having id 'authoring_point' 
		AH.select('#authoring_point').innerText = 'Add Point';

		AH.select('#add_point_msg').classList.add('h');

		// removes circular shape that is added by clicking on 'Add Point' button
		AH.selectAll('.resize', 'remove');

		// removes the activity done using drawing tools
		AH.select('.drawing_paths').innerHTML = '';

		// disabled the undo, redo and delete button
		AH.select('#authoring_redo').disabled = true;

		AH.select('#authoring_undo').disabled = true;
		AH.select('#authoring_clearScreen').disabled = true;

		// sets the cursor style to crosshair (+)
		AH.setCss('#authoringSvg', { 'cursor': 'crosshair' });

		// assign the string after removing the first character from the string at index 0 of the state array selectedTools
		authoringMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

		// this function set the default data
		setDefaultData();

		// removes the active class from the element have class 'authoring_btn' or have id 'authoring_point' or have id 'focus_point'
		AH.selectAll('.authoring_btn,#authoring_point,#focus_point', 'removeClass', 'active');

		// parses the point that can be access via keyboard on preview side
		parseXMLForAccessPoint();

		// blanks the value of cdata exist inside div element of the xml showing that no points added
		// parseXMLForPoint('');
		setTimeout(
			() => {
				parseXMLForPoint('');
			},
			1000
		);

		// clear the undo count
		undoCount = 0;

		// clear the added point
		selectionPoint = 0;

		// clear the scribbleCount
		scribbleCount = 0;

		// clear the paths of scribble
		scribblePath = [];

		// clear the all added points
		selectionArray = [];

		$$invalidate(0, state.openDeleteDialog = false, state);
	}

	// this function set the default data
	function setDefaultData() {
		// hides drawing tools
		AH.selectAll('.geometryTool', 'addClass', 'h');

		for (let toolsIndex = 0; toolsIndex < state.selectedTools.length; toolsIndex++) {
			// shows the tools that is enabled from configuration dialog box
			AH.selectAll('#authoring' + state.selectedTools[toolsIndex], 'removeClass', 'h');
		}

		// removes all the points created after clicking on 'Add Focus Point' button 
		AH.selectAll('.backgroundFocusPoint circle,.backgroundFocusPath path', 'remove');

		// assign the value of stroke color into variable 'authColor' choosen from configuration dialog box
		authColor = state.lineColor;

		// sets the width of drawing board and container of buttons
		AH.selectAll('.authCenterImg,.auth_drawing_toolbar', 'attr', {
			'style': 'width:' + (Number(state.imgWidth) + 2) + 'px'
		});

		// sets the attributes 'src', 'alt', 'width' of the background image
		AH.setAttr('.centerImg #svgImg', {
			'src': bgImgPath + '' + state.bgImg,
			'alt': state.alt,
			'width': state.imgWidth
		});

		//  hides the compass element
		AH.selectAll('.drawing_compass_svg', 'addClass', 'h');

		// removes all points points created using 'Add Focus Point' button
		accessibilityPoints = [];

		// removes values from array 'tempAccessPoints'
		tempAccessPoints = [];
	}

	// for changing the data when XML is changed manually 
	function parseXMLForGettingData() {
		// contains json data of the xml
		defaultXML = XMLToJSON(xml);

		auth_store.update(item => {
			// sets the value of state bgImg to the value of key bgimg of json defaultXML
			item.bgImg = defaultXML.smxml._bgimg;

			// sets the value of state alt to the value of key imgAlt of json defaultXML
			item.alt = defaultXML.smxml._imgAlt;

			// sets the value of state imgWidth to the value of key width of json defaultXML
			item.imgWidth = defaultXML.smxml._width;

			// sets the value of state selectedTools to the value of key 'selectedDrawingType' after joining it with commam of json defaultXML
			item.selectedTools = defaultXML.smxml.div._selectedDrawingType.split(',');

			// sets the value of state cDATA to the value of subkey cdata of key div of json defaultXML
			item.cDATA = defaultXML.smxml.div.__cdata;

			// sets the value of state focusDATA to the value of subkey cdata of key backgroundPoint of json defaultXML
			item.focusDATA = defaultXML.smxml.backgroundPoint.__cdata;

			// sets the value of state markPointColor to the value of key markPointColor of json defaultXML
			item.markPointColor = defaultXML.smxml._markPointColor;

			// sets the value of state lineColor to the value of key color of json defaultXML
			item.lineColor = defaultXML.smxml._color;

			return item;
		});

		// to handle the errors
		try {
			AH.select('#authoring_point').innerText = 'Add Point';

			// this function set the default data
			setDefaultData();

			// sets the added point value to 0
			selectionPoint = 0;

			// removes all the sketch draw by drawing tools
			AH.select('.drawing_paths').innerHTML = '';

			// disabled the button undo, redo and clear 
			AH.select('#authoring_redo').disabled = true;

			AH.select('#authoring_undo').disabled = true;
			AH.select('#authoring_clearScreen').disabled = true;

			// clears the value of variable undoCount
			undoCount = 0;

			// clears the value of variable scribbleCount
			scribbleCount = 0;

			// assign the value 1 to the variable focusPointCount
			focusPointCount = 1;

			// clears the value of array variable scribblePath
			scribblePath = [];

			// assign the value of state cDATA to the variable updatedCDATA
			let updatedCDATA = state.cDATA;

			// replaces the character '!' to ',' and wraps the value into square bracket
			updatedCDATA = '[' + updatedCDATA.replace(/!/g, ',') + ']';

			// parses the string data of variable updatedCDATA into javascript object
			updatedCDATA = JSON.parse(updatedCDATA);

			// removes the point added by clicking on 'Add Point' button
			AH.selectAll('.resize', 'remove');

			// defines the length of the array selectionArray
			let selectionArrayLength = selectionArray.length;

			if (updatedCDATA.length > selectionArrayLength) {
				for (let index = 0; index < updatedCDATA.length - selectionArrayLength; index++) {
					// pushes the point into array selectionArray added by clicking on 'Add Point' button with center of x at 90, center of y at 68 and with radius 33
					selectionArray.push({ Center_X: 90, Center_Y: 68, radius: 33 });
				}
			} else {
				for (let index = updatedCDATA.length; index < selectionArrayLength; index++) {
					// popes the point from array selectionArray
					selectionArray.pop();
				}
			}

			for (let index = 0; index < updatedCDATA.length; index++) {
				// increases the value of selectedPoint to indicate that how many points have been added
				selectionPoint++;

				// sets the center of x of the point added at last position of the array selectionArray
				selectionArray[selectionPoint - 1].Center_X = updatedCDATA[index].x;

				// sets the center of y of the point added at last position of the array selectionArray
				selectionArray[selectionPoint - 1].Center_Y = updatedCDATA[index].y;

				// sets the radius of the point added at last position of the array selectionArray
				selectionArray[selectionPoint - 1].radius = updatedCDATA[index].r;

				// adds the point to the drawing board at defined position
				AH.insert('#centerImg', '<div class="resize" data-point="' + selectionPoint + '" style="z-index: 10; left: ' + (updatedCDATA[index].x - updatedCDATA[index].r) + 'px; top: ' + (updatedCDATA[index].y - updatedCDATA[index].r) + 'px;width: ' + 2 * updatedCDATA[index].r + 'px; height: ' + 2 * updatedCDATA[index].r + 'px;"><div class="resizer icomoon-resize"></div></div>', 'beforeend');

				// updates the marking points xml after to resize or drag the points
				setPointDataInXML();
			}

			// contains the value of state focusDATA
			let updatedFocusCDATA = state.focusDATA;

			// contains the value of variable 'updatedFocusCDATA' after replacing character '!' to ',' and wrapping inside square bracket
			updatedFocusCDATA = '[' + updatedFocusCDATA.replace(/!/g, ',') + ']';

			// contains javascript object after parsing the string assigned into variable 'updatedFocusCDATA'
			updatedFocusCDATA = JSON.parse(updatedFocusCDATA);

			// removes the focus points and lines that joins the focus points
			AH.selectAll('.backgroundFocusPoint circle,.backgroundFocusPath path', 'remove');

			// makes array 'accessibilityPoints' to empty
			accessibilityPoints = [];

			for (let index = 0; index < updatedFocusCDATA.length; index++) {
				// pushes the object containing array of focus points lies in array updatedFocusCDATA at given index into array accessibilityPoints
				accessibilityPoints.push(updatedFocusCDATA[index][index]);
			}

			for (let index = 0; index < updatedFocusCDATA.length; index++) {
				for (let subPoints = 0; subPoints < updatedFocusCDATA[index][index].length; subPoints++) {
					// updates the value of key x of multi dimention array object 'accessibilityPoints' where row and column values are value of variable 'index' and 'subPoints' with the value of key x of multi dimention array object updatedFocusCDATA where row and column values are the value of variables 'index' and 'subPoints'
					accessibilityPoints[index][subPoints].x = updatedFocusCDATA[index][index][subPoints].x;

					// updates the value of key y of multi dimention array object 'accessibilityPoints' where row and column values are value of variable 'index' and 'subPoints' with the value of key y of multi dimention array object updatedFocusCDATA where row and column values are the value of variables 'index' and 'subPoints'
					accessibilityPoints[index][subPoints].y = updatedFocusCDATA[index][index][subPoints].y;

					// Creates an element with the specified namespace URI and qualified name.
					scribble = document.createElementNS(xmlns, 'circle');

					// sets the stroke width and color of the drawing drawn by scribble drawing tool
					setAuthColor('#808080', authThickness);

					// adds a new attribute 'id' (with a namespace null)
					scribble.setAttributeNS(null, 'id', 'focusPoint' + focusPointCount);

					// adds a new attribute 'cx' (with a namespace null)
					scribble.setAttributeNS(null, 'cx', accessibilityPoints[index][subPoints].x);

					// adds a new attribute 'cy' (with a namespace null)
					scribble.setAttributeNS(null, 'cy', accessibilityPoints[index][subPoints].y);

					// adds a new attribute 'r' (with a namespace null)
					scribble.setAttributeNS(null, 'r', '2px');

					// place the scribble element before very first element inside the element have class 'backgroundFocusPoint'
					AH.select('.backgroundFocusPoint').prepend(scribble);

					// increases the value of variable 'focusPointCount' by 1
					focusPointCount++;
				}

				// joins the focus points craeted by using 'Add focus Point' button
				joinFocusPoint(accessibilityPoints[index]);
			}

			if (selectionPoint == 0) {
				AH.select('#add_point_msg').classList.add('h');
			} else {
				AH.select('#add_point_msg').classList.remove('h');
			}

			if (AH.selectAll('.resize').length > 0) {
				// sets the value of variable 'authoringMode' to 'authoring_point'
				authoringMode = 'authoring_point';

				// sets the cursor style value as auto
				AH.setCss('#authoringSvg', { 'cursor': 'auto' });
			} else {
				// removes the first character from string in state array selectedTools at index 0
				authoringMode = state.selectedTools[0].substr(-(state.selectedTools[0].length - 1));

				// sets the cursor style to crosshair (+)
				AH.setCss('#authoringSvg', { 'cursor': 'crosshair' });

				if (authoringMode == 'compass') {
					// shows the compass tool
					AH.selectAll('.drawing_compass_svg', 'removeClass', 'h');
				} else {
					// hides the compass element
					AH.selectAll('.drawing_compass_svg', 'addClass', 'h');
				}
			}

			AH.selectAll('.authoring_btn,#authoring_point,#focus_point', 'removeClass', 'active');
			AH.selectAll('[data-title="' + authoringMode + '"]', 'addClass', 'active');
		} catch(e) {
			console.warn({ e, func: 'parseXMLForGettingData' });
		}
	}

	// used to update the xml value according to the updation made in configuration modal box
	function parseXMLForSettingData(XML) {
		// contains json of xml data
		defaultXML = XMLToJSON(XML);

		// stores the value of background image into json of xml having key bgimg
		defaultXML.smxml._bgimg = state.bgImg;

		// stores the value of alt message of background image into json of xml having key imgAlt
		defaultXML.smxml._imgAlt = state.alt;

		// stores the value of the width of background image into json of xml having key width
		defaultXML.smxml._width = state.imgWidth;

		// stores the value of stroke color of drawing into json of xml having key color
		defaultXML.smxml._color = state.lineColor;

		// stores the value of point color of drawing into json of xml having key markPointColor
		defaultXML.smxml._markPointColor = state.markPointColor;

		// store the values of drawing tools after joining it using comma that can be used to draw the drawing into json of xml having key selectedDrawingType
		defaultXML.smxml.div._selectedDrawingType = selectedToolsArray.join(',');

		// blanks the value of key CDATA inside the key div of json xml to clean the drawing board 
		defaultXML.smxml.div.__cdata = '';

		// blanks the value of key CDATA inside the key backgroundPoint of json xml to clean the drawing board 
		defaultXML.smxml.backgroundPoint.__cdata = '';

		// converts json of the xml into xml
		defaultXML = JSONToXML(defaultXML);

		// changed the format of CDATA
		defaultXML = defaultXML.replace('<![CDATA[]]>', '<!--[CDATA[]]-->');

		// updates the xml
		getChildXml(defaultXML);

		// sets the value of state 'xml'
		$$invalidate(0, state.xml = defaultXML, state);
	}

	// used to set the UI of the buttons and sketch or remove the drawing and adds focus point to access via keyboard
	function authoringMousedownDraw(event) {
		switch (authoringMode) {
			case 'line':
			case 'scribble':
				isDrawing = true;
				// used to set the x and y co-ordinate of the mouse position
				setMouseCoordinates(event);
				// Creates an element with the specified namespace URI and qualified name.
				scribble = document.createElementNS(xmlns, 'path');
				// sets the stroke width and color of the drawing drawn by scribble drawing tool
				setAuthColor(authColor, authThickness);
				// adds a new attribute 'data-type' (with a namespace null)
				scribble.setAttributeNS(null, 'data-type', authoringMode + '_' + scribbleCount);
				// adds a new attribute 'data-order' (with a namespace null)
				scribble.setAttributeNS(null, 'data-order', scribbleCount);
				// adds a new attribute 'd' (with a namespace null)
				scribble.setAttributeNS(null, 'd', 'M' + auth_mouseX + ' ' + auth_mouseY);
				// contains the x position of the mouse co-ordinate
				checkCurrentPositionX = auth_mouseX;
				// contains the x position of the mouse co-ordinate
				checkCurrentPositionY = auth_mouseY;
				// pushes the object containing keys mode, order, type, index and d 
				scribblePath.push({
					mode: 'add',
					order: scribbleCount,
					type: authoringMode + '_' + scribbleCount,
					index: scribbleCount,
					d: 'M' + auth_mouseX + ' ' + auth_mouseY
				});
				break;
			case 'eraser':
				if (AH.select('.currentSvg').nodeName && AH.select('.currentSvg').getAttribute("data-order") != undefined) {
					// makes empty undo_list array
					undo_list = [];

					// defines variable 'tempArrayContainer'
					let tempArrayContainer = '';

					// contains the Index of the value at index returned by the 'data-order' attribute of the element has class 'currentSvg' in scribblePath array 
					let currentIndex = scribblePath.indexOf(scribblePath[AH.select('.currentSvg').getAttribute("data-order")]);

					// copies all enumerable own properties from objects defined into scribblePath array at given index to a target object
					tempArrayContainer = Object.assign({}, scribblePath[currentIndex]);

					// defines the value of key 'mode' to remove of tempArrayContainer object
					tempArrayContainer.mode = "remove";

					// pushes the object 'tempArrayContainer' into scribblePath array
					scribblePath.push(tempArrayContainer);

					// increases the value of variable 'scribbleCount' by 1
					scribbleCount++;

					// increases the value of variable 'undoCount' by 1
					undoCount++;

					// disabled the redo button
					AH.select('#authoring_redo').disabled = true;

					// removes the element have class 'currentSvg'
					AH.selectAll('.currentSvg', 'remove');

					if (AH.selectAll('.drawing_paths path').length == 0) {
						// disabled the cross (x) button
						AH.select('#authoring_clearScreen').disabled = true;
					}
				}
				break;
			case 'markAccessibilityPoint':
				if (!isAccessibleMarking) {
					// used to set the x and y co-ordinate of the mouse position
					setMouseCoordinates(event);

					// Creates an element with the specified namespace URI and qualified name.
					scribble = document.createElementNS(xmlns, 'circle');

					// sets the stroke width and color of the drawing drawn by scribble drawing tool
					setAuthColor('#808080', authThickness);

					// adds a new attribute 'id' (with a namespace null)
					scribble.setAttributeNS(null, 'id', 'focusPoint' + focusPointCount);

					// adds a new attribute 'cx' (with a namespace null)
					scribble.setAttributeNS(null, 'cx', auth_mouseX);

					// adds a new attribute 'cy' (with a namespace null)
					scribble.setAttributeNS(null, 'cy', auth_mouseY);

					// adds a new attribute 'r' (with a namespace null)
					scribble.setAttributeNS(null, 'r', '2px');

					// pushes the mouse x and y position into array 'tempAccessPoints' into json format
					tempAccessPoints.push({ x: auth_mouseX, y: auth_mouseY });

					// increases the value of the variable 'focusPointCount' by 1
					focusPointCount++;

					// prepend the element scribble into the element have class 'backgroundFocusPoint'
					AH.select('.backgroundFocusPoint').prepend(scribble);
				}
				break;
		}
	}

	// function for opening the drawing modal and changing the modal values
	function openModal() {
		AH.getBS('#drawing-modal', 'Modal').show();
		AH.select('#backgroundImage').value = state.bgImg;

		if (state.lineColor != '') {
			// used to show the by default selected particular color from drawing color dropdown
			AH.select('#lineColor option[value="' + state.lineColor + '"]').selected = true;
		}

		if (state.markPointColor != '') {
			// used to show the by default selected particular color from point color dropdown
			AH.select('#markPointColor option[value="' + state.markPointColor + '"]').selected = true;
		}

		if (state.selectedTools.length > 0) {
			// uncheck the all drawing tools checkbox
			AH.selectAll('.toolCheckbox', 'checked', false);

			for (var toolsIndex = 0; toolsIndex < state.selectedTools.length; toolsIndex++) {
				// check that drawing tool checkbox which value exist in state array 'selectedTools'
				AH.select('[value="' + state.selectedTools[toolsIndex] + '"]').checked = true;
			}
		}

		AH.select('#imgWidth').value = state.imgWidth;
		AH.select('#imgAlt').value = state.alt;
		let inputs = AH.selectAll('.authoring-modal input');
		AH.selectAll('.error', 'remove');

		for (let index = 0; index < inputs.length; index++) {
			validateInput(inputs[index]);
		}
	}

	const writable_props = ['xml', 'getChildXml'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Drawing> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(0, state.openDeleteDialog = false, state);
	};

	function dialog_visible_binding(value) {
		if ($$self.$$.not_equal(state.openDeleteDialog, value)) {
			state.openDeleteDialog = value;
			$$invalidate(0, state);
		}
	}

	$$self.$$set = $$props => {
		if ('xml' in $$props) $$invalidate(4, xml = $$props.xml);
		if ('getChildXml' in $$props) $$invalidate(5, getChildXml = $$props.getChildXml);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		onMount,
		writable,
		XMLToJSON,
		JSONToXML,
		AH,
		swal,
		l,
		Draggable,
		Resizable,
		DrawingModal,
		Button,
		Dialog,
		xml,
		getChildXml,
		bgImgPath,
		xmlns,
		isDrawing,
		scribble,
		auth_mouseX,
		auth_mouseY,
		drawing_paths,
		authoringMode,
		authColor,
		authThickness,
		scribblePath,
		scribbleCount,
		checkCurrentPositionX,
		checkCurrentPositionY,
		undoCount,
		undo_list,
		redo_list,
		isValid,
		cx,
		cy,
		midCircle_cx,
		midCircle_cy,
		midSmallCircle_cx,
		midSmallCircle_cy,
		lastCircle_cx,
		lastCircle_cy,
		lastSmallCircle_cx,
		lastSmallCircle_cy,
		compassRadius,
		isCompassMove,
		compassAngle,
		isRadiusIncrease,
		initialPoint,
		finalPoint,
		isRadiusRotate,
		defaultXML,
		selectionPoint,
		selectionArray,
		cdata,
		selectedToolsArray,
		isAccessibleMarking,
		accessibilityPoints,
		tempAccessPoints,
		focusPointCount,
		auth_store,
		state,
		unsubscribe,
		isNumeric,
		validateInput,
		enableDragResize,
		authoringMouseLeave,
		updateCompassCalculation,
		setPointDataInXML,
		parseXMLForPoint,
		checkRadiusPointsAndAngle,
		parseXMLForAccessPoint,
		joinFocusPoint,
		setMouseCoordinates,
		setAuthColor,
		resetModule,
		setDefaultData,
		parseXMLForGettingData,
		parseXMLForSettingData,
		authoringMousedownDraw,
		openModal
	});

	$$self.$inject_state = $$props => {
		if ('xml' in $$props) $$invalidate(4, xml = $$props.xml);
		if ('getChildXml' in $$props) $$invalidate(5, getChildXml = $$props.getChildXml);
		if ('bgImgPath' in $$props) $$invalidate(1, bgImgPath = $$props.bgImgPath);
		if ('xmlns' in $$props) xmlns = $$props.xmlns;
		if ('isDrawing' in $$props) isDrawing = $$props.isDrawing;
		if ('scribble' in $$props) scribble = $$props.scribble;
		if ('auth_mouseX' in $$props) auth_mouseX = $$props.auth_mouseX;
		if ('auth_mouseY' in $$props) auth_mouseY = $$props.auth_mouseY;
		if ('drawing_paths' in $$props) drawing_paths = $$props.drawing_paths;
		if ('authoringMode' in $$props) authoringMode = $$props.authoringMode;
		if ('authColor' in $$props) authColor = $$props.authColor;
		if ('authThickness' in $$props) authThickness = $$props.authThickness;
		if ('scribblePath' in $$props) scribblePath = $$props.scribblePath;
		if ('scribbleCount' in $$props) scribbleCount = $$props.scribbleCount;
		if ('checkCurrentPositionX' in $$props) checkCurrentPositionX = $$props.checkCurrentPositionX;
		if ('checkCurrentPositionY' in $$props) checkCurrentPositionY = $$props.checkCurrentPositionY;
		if ('undoCount' in $$props) undoCount = $$props.undoCount;
		if ('undo_list' in $$props) undo_list = $$props.undo_list;
		if ('redo_list' in $$props) redo_list = $$props.redo_list;
		if ('isValid' in $$props) isValid = $$props.isValid;
		if ('cx' in $$props) cx = $$props.cx;
		if ('cy' in $$props) cy = $$props.cy;
		if ('midCircle_cx' in $$props) midCircle_cx = $$props.midCircle_cx;
		if ('midCircle_cy' in $$props) midCircle_cy = $$props.midCircle_cy;
		if ('midSmallCircle_cx' in $$props) midSmallCircle_cx = $$props.midSmallCircle_cx;
		if ('midSmallCircle_cy' in $$props) midSmallCircle_cy = $$props.midSmallCircle_cy;
		if ('lastCircle_cx' in $$props) lastCircle_cx = $$props.lastCircle_cx;
		if ('lastCircle_cy' in $$props) lastCircle_cy = $$props.lastCircle_cy;
		if ('lastSmallCircle_cx' in $$props) lastSmallCircle_cx = $$props.lastSmallCircle_cx;
		if ('lastSmallCircle_cy' in $$props) lastSmallCircle_cy = $$props.lastSmallCircle_cy;
		if ('compassRadius' in $$props) compassRadius = $$props.compassRadius;
		if ('isCompassMove' in $$props) isCompassMove = $$props.isCompassMove;
		if ('compassAngle' in $$props) compassAngle = $$props.compassAngle;
		if ('isRadiusIncrease' in $$props) isRadiusIncrease = $$props.isRadiusIncrease;
		if ('initialPoint' in $$props) initialPoint = $$props.initialPoint;
		if ('finalPoint' in $$props) finalPoint = $$props.finalPoint;
		if ('isRadiusRotate' in $$props) isRadiusRotate = $$props.isRadiusRotate;
		if ('defaultXML' in $$props) defaultXML = $$props.defaultXML;
		if ('selectionPoint' in $$props) selectionPoint = $$props.selectionPoint;
		if ('selectionArray' in $$props) selectionArray = $$props.selectionArray;
		if ('cdata' in $$props) cdata = $$props.cdata;
		if ('selectedToolsArray' in $$props) selectedToolsArray = $$props.selectedToolsArray;
		if ('isAccessibleMarking' in $$props) isAccessibleMarking = $$props.isAccessibleMarking;
		if ('accessibilityPoints' in $$props) accessibilityPoints = $$props.accessibilityPoints;
		if ('tempAccessPoints' in $$props) tempAccessPoints = $$props.tempAccessPoints;
		if ('focusPointCount' in $$props) focusPointCount = $$props.focusPointCount;
		if ('auth_store' in $$props) auth_store = $$props.auth_store;
		if ('state' in $$props) $$invalidate(0, state = $$props.state);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		state,
		bgImgPath,
		resetModule,
		openModal,
		xml,
		getChildXml,
		click_handler,
		dialog_visible_binding
	];
}

class Drawing extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { xml: 4, getChildXml: 5 }, null, [-1, -1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Drawing",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*xml*/ ctx[4] === undefined && !('xml' in props)) {
			console_1.warn("<Drawing> was created without expected prop 'xml'");
		}

		if (/*getChildXml*/ ctx[5] === undefined && !('getChildXml' in props)) {
			console_1.warn("<Drawing> was created without expected prop 'getChildXml'");
		}
	}

	get xml() {
		throw new Error("<Drawing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<Drawing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getChildXml() {
		throw new Error("<Drawing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<Drawing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Drawing;
//# sourceMappingURL=Drawing-1b7ceb96.js.map
