
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, g as globals, v as validate_slots, o as onMount, X as XMLToJSON, A as AH, y as language, e as element, f as space, h as text, j as attr_dev, k as add_location, n as insert_dev, p as append_dev, Y as select_option, q as listen_dev, G as prop_dev, B as noop, x as detach_dev, H as run_all } from './main-59da555a.js';

/* clsSMAudioRecorder/AudioRecorder.svelte generated by Svelte v3.29.0 */

const { console: console_1 } = globals;
const file = "clsSMAudioRecorder/AudioRecorder.svelte";

function create_fragment(ctx) {
	let div15;
	let div14;
	let div0;
	let b0;
	let t1;
	let t2_value = language.recording_warning + "";
	let t2;
	let t3;
	let div2;
	let div1;
	let b1;
	let t5;
	let textarea;
	let textarea_value_value;
	let textarea_aria_label_value;
	let t6;
	let div6;
	let div3;
	let label0;
	let b2;
	let t8;
	let select;
	let option0;
	let option1;
	let option2;
	let option3;
	let option4;
	let option5;
	let option6;
	let option7;
	let select_value_value;
	let t17;
	let div5;
	let label1;
	let input;
	let input_checked_value;
	let t18;
	let div4;
	let t19;
	let label2;
	let t21;
	let div13;
	let div12;
	let div7;
	let b3;
	let t23;
	let div10;
	let span0;
	let t25;
	let div8;
	let img0;
	let img0_src_value;
	let t26;
	let div9;
	let img1;
	let img1_src_value;
	let t27;
	let div11;
	let button0;
	let span1;
	let span1_data_original_title_value;
	let button0_aria_label_value;
	let t28;
	let button1;
	let span2;
	let button1_disabled_value;
	let button1_aria_label_value;
	let t29;
	let button2;
	let span3;
	let button2_disabled_value;
	let t30;
	let div22;
	let div21;
	let div20;
	let div19;
	let div16;
	let h4;
	let t32;
	let button3;
	let t34;
	let div17;
	let t35_value = language.modal_data + "";
	let t35;
	let t36;
	let div18;
	let button4;
	let t38;
	let button5;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div15 = element("div");
			div14 = element("div");
			div0 = element("div");
			b0 = element("b");
			b0.textContent = `${language.note_label}`;
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			div2 = element("div");
			div1 = element("div");
			b1 = element("b");
			b1.textContent = `${language.spoken_label}`;
			t5 = space();
			textarea = element("textarea");
			t6 = space();
			div6 = element("div");
			div3 = element("div");
			label0 = element("label");
			b2 = element("b");
			b2.textContent = `${language.select_lang}`;
			t8 = space();
			select = element("select");
			option0 = element("option");
			option0.textContent = `${language.english_us}`;
			option1 = element("option");
			option1.textContent = `${language.german_lang}`;
			option2 = element("option");
			option2.textContent = `${language.french_lang}`;
			option3 = element("option");
			option3.textContent = `${language.spanish_lang}`;
			option4 = element("option");
			option4.textContent = `${language.hindi_lang}`;
			option5 = element("option");
			option5.textContent = `${language.japanese_lang}`;
			option6 = element("option");
			option6.textContent = `${language.korean_lang}`;
			option7 = element("option");
			option7.textContent = `${language.italiano}`;
			t17 = space();
			div5 = element("div");
			label1 = element("label");
			input = element("input");
			t18 = space();
			div4 = element("div");
			t19 = space();
			label2 = element("label");
			label2.textContent = `${language.show_transcript}`;
			t21 = space();
			div13 = element("div");
			div12 = element("div");
			div7 = element("div");
			b3 = element("b");
			b3.textContent = `${language.audio_recorder}`;
			t23 = space();
			div10 = element("div");
			span0 = element("span");
			span0.textContent = `${language.starting_message}`;
			t25 = space();
			div8 = element("div");
			img0 = element("img");
			t26 = space();
			div9 = element("div");
			img1 = element("img");
			t27 = space();
			div11 = element("div");
			button0 = element("button");
			span1 = element("span");
			t28 = space();
			button1 = element("button");
			span2 = element("span");
			t29 = space();
			button2 = element("button");
			span3 = element("span");
			t30 = space();
			div22 = element("div");
			div21 = element("div");
			div20 = element("div");
			div19 = element("div");
			div16 = element("div");
			h4 = element("h4");
			h4.textContent = `${language.confirm_label}`;
			t32 = space();
			button3 = element("button");
			button3.textContent = "×";
			t34 = space();
			div17 = element("div");
			t35 = text(t35_value);
			t36 = space();
			div18 = element("div");
			button4 = element("button");
			button4.textContent = `${language.no_label}`;
			t38 = space();
			button5 = element("button");
			button5.textContent = `${language.yes_label}`;
			attr_dev(b0, "class", "noteColor bolder");
			add_location(b0, file, 400, 12, 19363);
			attr_dev(div0, "class", "col-12");
			attr_dev(div0, "tabindex", "0");
			attr_dev(div0, "aria-label", "Recording will end after 15 sec");
			add_location(div0, file, 399, 8, 19272);
			add_location(b1, file, 404, 30, 19527);
			attr_dev(div1, "class", "pb-2");
			add_location(div1, file, 404, 12, 19509);
			attr_dev(textarea, "id", "data_container");
			textarea.disabled = "disabled";
			attr_dev(textarea, "name", "cdata");
			attr_dev(textarea, "class", "form-control");
			attr_dev(textarea, "rows", "3");
			attr_dev(textarea, "cols", "75");
			textarea.value = textarea_value_value = /*state*/ ctx[3].cdata;

			attr_dev(textarea, "aria-label", textarea_aria_label_value = language.spoken_label + " " + (/*state*/ ctx[3].cdata != ""
			? /*state*/ ctx[3].cdata
			: "Nothing"));

			add_location(textarea, file, 405, 12, 19569);
			attr_dev(div2, "class", "col-6 py-2 mb-1");
			add_location(div2, file, 403, 8, 19467);
			add_location(b2, file, 409, 45, 19959);
			attr_dev(label0, "for", "language_select");
			add_location(label0, file, 409, 16, 19930);
			attr_dev(div3, "class", "select_label_container");
			add_location(div3, file, 408, 12, 19877);
			option0.__value = "en-US";
			option0.value = option0.__value;
			attr_dev(option0, "aria-label", "English United States");
			add_location(option0, file, 412, 16, 20255);
			option1.__value = "de-DE";
			option1.value = option1.__value;
			attr_dev(option1, "aria-label", "German");
			add_location(option1, file, 413, 16, 20352);
			option2.__value = "fr-FR";
			option2.value = option2.__value;
			attr_dev(option2, "aria-label", "French");
			add_location(option2, file, 414, 16, 20435);
			option3.__value = "es-ES";
			option3.value = option3.__value;
			attr_dev(option3, "aria-label", "Spanish");
			add_location(option3, file, 415, 16, 20518);
			option4.__value = "hi-IN";
			option4.value = option4.__value;
			attr_dev(option4, "aria-label", "Hindi");
			add_location(option4, file, 416, 16, 20603);
			option5.__value = "ja-JP";
			option5.value = option5.__value;
			attr_dev(option5, "aria-label", "Japanese");
			add_location(option5, file, 417, 16, 20684);
			option6.__value = "ko-KR";
			option6.value = option6.__value;
			attr_dev(option6, "aria-label", "Korean");
			add_location(option6, file, 418, 16, 20771);
			option7.__value = "it-IT";
			option7.value = option7.__value;
			attr_dev(option7, "aria-label", "Italian");
			add_location(option7, file, 419, 16, 20854);
			attr_dev(select, "id", "language_select");
			attr_dev(select, "name", "language");
			attr_dev(select, "class", "disability_apply form-control form-control-sm");
			attr_dev(select, "aria-label", "Select the language for Recording");
			add_location(select, file, 411, 12, 20021);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "name", "showTranscript");
			attr_dev(input, "id", "showTranscript");
			attr_dev(input, "tabindex", "0");
			attr_dev(input, "class", "form-check-input");
			input.checked = input_checked_value = /*state*/ ctx[3].showTranscript;
			add_location(input, file, 423, 20, 21131);
			attr_dev(div4, "class", "check_mark_custom pt-sm1");
			add_location(div4, file, 433, 20, 21553);
			attr_dev(label1, "for", "showTranscript");
			attr_dev(label1, "class", "custom_checkbox_new float-left mr-1");
			add_location(label1, file, 422, 16, 21038);
			attr_dev(label2, "for", "showTranscript");
			attr_dev(label2, "class", "form-check-label");
			add_location(label2, file, 435, 16, 21639);
			attr_dev(div5, "class", "form-check form-check-inline transcript_container mt-3");
			add_location(div5, file, 421, 12, 20953);
			attr_dev(div6, "class", "col-6 py-2 mb-1");
			add_location(div6, file, 407, 8, 19835);
			add_location(b3, file, 441, 20, 21975);
			attr_dev(div7, "class", "p-2 tokenfield bg-light mb-3");
			attr_dev(div7, "aria-label", "Audio Recorder");
			attr_dev(div7, "tabindex", "0");
			add_location(div7, file, 440, 16, 21871);
			attr_dev(span0, "class", "align-self-center mx-auto authInitialState tokenfield");
			attr_dev(span0, "aria-label", "Click on record to start recording");
			attr_dev(span0, "tabindex", "0");
			add_location(span0, file, 444, 20, 22144);
			if (img0.src !== (img0_src_value = "//s3.amazonaws.com/jigyaasa_content_static/6ba174bf48e9b6dc8d8bd19d13c9caa9_000Awg.gif")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "recording is on");
			attr_dev(img0, "class", "w-100 h-100 img_fit");
			add_location(img0, file, 446, 24, 22442);
			attr_dev(div8, "class", "h authRecordingOn w-100 h-100 tokenfield");
			attr_dev(div8, "aria-label", "recording is on");
			attr_dev(div8, "tabindex", "0");
			add_location(div8, file, 445, 20, 22321);
			if (img1.src !== (img1_src_value = "//s3.amazonaws.com/jigyaasa_content_static/giphy_000AYi.gif")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "audio is playing");
			attr_dev(img1, "class", "w-100 h-100 img_fit");
			add_location(img1, file, 449, 24, 22762);
			attr_dev(div9, "class", "h authAudioPlaying w-100 h-100 tokenfield");
			attr_dev(div9, "aria-label", "Audio is playing");
			attr_dev(div9, "tabindex", "0");
			add_location(div9, file, 448, 20, 22639);
			attr_dev(div10, "class", "mx-auto text-danger recording_status initialState mb-3 d-flex mx-auto");
			add_location(div10, file, 443, 16, 22040);
			attr_dev(span1, "class", "icomoon-circle-2 s2 text-danger position-relative top1");
			attr_dev(span1, "data-bs-toggle", "tooltip");
			attr_dev(span1, "data-placement", "top");

			attr_dev(span1, "data-original-title", span1_data_original_title_value = /*state*/ ctx[3].status == "recording"
			? "Stop Recording"
			: "Start Recording");

			add_location(span1, file, 461, 24, 23403);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "name", "recordButton");
			attr_dev(button0, "id", "recordButton");
			attr_dev(button0, "class", "btn btn-light py-0");
			attr_dev(button0, "aria-label", button0_aria_label_value = "Click for " + /*areaLabelForRecordButton*/ ctx[2]);
			add_location(button0, file, 453, 20, 23041);
			attr_dev(span2, "class", "icomoon-24px-autoplay-4 position-relative top1");
			attr_dev(span2, "data-bs-toggle", "tooltip");
			attr_dev(span2, "data-placement", "top");
			attr_dev(span2, "data-original-title", "Play Audio");
			add_location(span2, file, 472, 24, 24074);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "name", "stopButton");
			attr_dev(button1, "id", "stopButton");
			button1.disabled = button1_disabled_value = /*state*/ ctx[3].disabled;
			attr_dev(button1, "class", "btn btn-light py-0");
			attr_dev(button1, "aria-label", button1_aria_label_value = "Click for " + /*areaLabelForStopButton*/ ctx[0]);
			add_location(button1, file, 463, 20, 23668);
			attr_dev(span3, "class", "icomoon-new-24px-reset-1 position-relative top1");
			attr_dev(span3, "data-bs-toggle", "tooltip");
			attr_dev(span3, "data-placement", "top");
			attr_dev(span3, "title", "Reset Data");
			add_location(span3, file, 485, 24, 24807);
			attr_dev(button2, "type", "button");
			attr_dev(button2, "name", "resetButton");
			attr_dev(button2, "id", "resetButton");
			attr_dev(button2, "class", "btn btn-light py-0");
			button2.disabled = button2_disabled_value = /*state*/ ctx[3].isReset;
			attr_dev(button2, "data-bs-toggle", "modal");
			attr_dev(button2, "data-bs-target", "#authoring_confirm_modal");
			attr_dev(button2, "aria-label", "Click on this button for override the previous recording");
			add_location(button2, file, 474, 20, 24272);
			attr_dev(div11, "id", "controls_container");
			attr_dev(div11, "class", "bg-light text-center w-100 p-2");
			add_location(div11, file, 452, 16, 22952);
			attr_dev(div12, "class", "border rounded shadow-sm");
			add_location(div12, file, 439, 12, 21816);
			attr_dev(div13, "class", "col-12 col-md-8 offset-md-2");
			add_location(div13, file, 438, 8, 21762);
			attr_dev(div14, "class", "row");
			add_location(div14, file, 398, 4, 19246);
			attr_dev(div15, "id", "authoring_container");
			attr_dev(div15, "class", "container");
			add_location(div15, file, 397, 0, 19193);
			attr_dev(h4, "class", "modal-title tokenfield");
			attr_dev(h4, "aria-label", "Confirmation Dialog box");
			attr_dev(h4, "tabindex", "0");
			add_location(h4, file, 497, 20, 25324);
			attr_dev(button3, "type", "button");
			attr_dev(button3, "class", "close");
			attr_dev(button3, "data-bs-dismiss", "modal");
			attr_dev(button3, "tabindex", "0");
			attr_dev(button3, "aria-label", "Click on this button for close the confirmation dialog box");
			add_location(button3, file, 498, 20, 25452);
			attr_dev(div16, "class", "modal-header");
			add_location(div16, file, 496, 16, 25277);
			attr_dev(div17, "class", "modal-body tokenfield");
			attr_dev(div17, "tabindex", "0");
			attr_dev(div17, "aria-label", /*areaLabelForModalContent*/ ctx[1]);
			attr_dev(div17, "id", "dialogBody");
			attr_dev(div17, "name", "dialogBody");
			add_location(div17, file, 500, 16, 25653);
			attr_dev(button4, "type", "button");
			attr_dev(button4, "class", "authoring_dismiss_modal btn btn-light pr-2");
			attr_dev(button4, "data-bs-dismiss", "modal");
			attr_dev(button4, "tabindex", "0");
			attr_dev(button4, "aria-label", "Click on this button for neglecte to override previous recording");
			add_location(button4, file, 504, 20, 25895);
			attr_dev(button5, "type", "button");
			attr_dev(button5, "class", "authoring_dismiss_done btn btn-primary");
			attr_dev(button5, "data-bs-dismiss", "modal");
			attr_dev(button5, "tabindex", "0");
			attr_dev(button5, "aria-label", "Click on this button for override the previous recording");
			add_location(button5, file, 505, 20, 26150);
			attr_dev(div18, "class", "modal-footer");
			add_location(div18, file, 503, 16, 25848);
			attr_dev(div19, "class", "modal-content");
			add_location(div19, file, 495, 12, 25233);
			attr_dev(div20, "class", "modal-dialog modal-md modal-dialog-centered");
			add_location(div20, file, 494, 8, 25163);
			attr_dev(div21, "class", "modal fade");
			attr_dev(div21, "id", "authoring_confirm_modal");
			add_location(div21, file, 493, 4, 25101);
			attr_dev(div22, "class", "authoring_modal_container container");
			add_location(div22, file, 492, 0, 25047);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div15, anchor);
			append_dev(div15, div14);
			append_dev(div14, div0);
			append_dev(div0, b0);
			append_dev(div0, t1);
			append_dev(div0, t2);
			append_dev(div14, t3);
			append_dev(div14, div2);
			append_dev(div2, div1);
			append_dev(div1, b1);
			append_dev(div2, t5);
			append_dev(div2, textarea);
			append_dev(div14, t6);
			append_dev(div14, div6);
			append_dev(div6, div3);
			append_dev(div3, label0);
			append_dev(label0, b2);
			append_dev(div6, t8);
			append_dev(div6, select);
			append_dev(select, option0);
			append_dev(select, option1);
			append_dev(select, option2);
			append_dev(select, option3);
			append_dev(select, option4);
			append_dev(select, option5);
			append_dev(select, option6);
			append_dev(select, option7);
			select_option(select, /*state*/ ctx[3].language);
			append_dev(div6, t17);
			append_dev(div6, div5);
			append_dev(div5, label1);
			append_dev(label1, input);
			append_dev(label1, t18);
			append_dev(label1, div4);
			append_dev(div5, t19);
			append_dev(div5, label2);
			append_dev(div14, t21);
			append_dev(div14, div13);
			append_dev(div13, div12);
			append_dev(div12, div7);
			append_dev(div7, b3);
			append_dev(div12, t23);
			append_dev(div12, div10);
			append_dev(div10, span0);
			append_dev(div10, t25);
			append_dev(div10, div8);
			append_dev(div8, img0);
			append_dev(div10, t26);
			append_dev(div10, div9);
			append_dev(div9, img1);
			append_dev(div12, t27);
			append_dev(div12, div11);
			append_dev(div11, button0);
			append_dev(button0, span1);
			append_dev(div11, t28);
			append_dev(div11, button1);
			append_dev(button1, span2);
			append_dev(div11, t29);
			append_dev(div11, button2);
			append_dev(button2, span3);
			insert_dev(target, t30, anchor);
			insert_dev(target, div22, anchor);
			append_dev(div22, div21);
			append_dev(div21, div20);
			append_dev(div20, div19);
			append_dev(div19, div16);
			append_dev(div16, h4);
			append_dev(div16, t32);
			append_dev(div16, button3);
			append_dev(div19, t34);
			append_dev(div19, div17);
			append_dev(div17, t35);
			append_dev(div19, t36);
			append_dev(div19, div18);
			append_dev(div18, button4);
			append_dev(div18, t38);
			append_dev(div18, button5);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "change", /*handleChange*/ ctx[5], false, false, false),
					listen_dev(select, "change", /*handleChange*/ ctx[5], false, false, false),
					listen_dev(select, "blur", /*handleChange*/ ctx[5], false, false, false),
					listen_dev(input, "click", /*handleCheck*/ ctx[4], false, false, false),
					listen_dev(input, "keyup", /*adaKeyupCheckbox*/ ctx[11], false, false, false),
					listen_dev(button0, "click", /*startRecording*/ ctx[6], false, false, false),
					listen_dev(button1, "click", /*playRecording*/ ctx[8], false, false, false),
					listen_dev(button2, "click", /*setData*/ ctx[7], false, false, false),
					listen_dev(button4, "click", /*modalResponse*/ ctx[10], false, false, false),
					listen_dev(button5, "click", /*manageData*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*state*/ 8 && textarea_value_value !== (textarea_value_value = /*state*/ ctx[3].cdata)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty & /*state*/ 8 && textarea_aria_label_value !== (textarea_aria_label_value = language.spoken_label + " " + (/*state*/ ctx[3].cdata != ""
			? /*state*/ ctx[3].cdata
			: "Nothing"))) {
				attr_dev(textarea, "aria-label", textarea_aria_label_value);
			}

			if (dirty & /*state*/ 8 && select_value_value !== (select_value_value = /*state*/ ctx[3].language)) {
				select_option(select, /*state*/ ctx[3].language);
			}

			if (dirty & /*state*/ 8 && input_checked_value !== (input_checked_value = /*state*/ ctx[3].showTranscript)) {
				prop_dev(input, "checked", input_checked_value);
			}

			if (dirty & /*state*/ 8 && span1_data_original_title_value !== (span1_data_original_title_value = /*state*/ ctx[3].status == "recording"
			? "Stop Recording"
			: "Start Recording")) {
				attr_dev(span1, "data-original-title", span1_data_original_title_value);
			}

			if (dirty & /*areaLabelForRecordButton*/ 4 && button0_aria_label_value !== (button0_aria_label_value = "Click for " + /*areaLabelForRecordButton*/ ctx[2])) {
				attr_dev(button0, "aria-label", button0_aria_label_value);
			}

			if (dirty & /*state*/ 8 && button1_disabled_value !== (button1_disabled_value = /*state*/ ctx[3].disabled)) {
				prop_dev(button1, "disabled", button1_disabled_value);
			}

			if (dirty & /*areaLabelForStopButton*/ 1 && button1_aria_label_value !== (button1_aria_label_value = "Click for " + /*areaLabelForStopButton*/ ctx[0])) {
				attr_dev(button1, "aria-label", button1_aria_label_value);
			}

			if (dirty & /*state*/ 8 && button2_disabled_value !== (button2_disabled_value = /*state*/ ctx[3].isReset)) {
				prop_dev(button2, "disabled", button2_disabled_value);
			}

			if (dirty & /*areaLabelForModalContent*/ 2) {
				attr_dev(div17, "aria-label", /*areaLabelForModalContent*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div15);
			if (detaching) detach_dev(t30);
			if (detaching) detach_dev(div22);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AudioRecorder", slots, []);
	let { getChildXml } = $$props;
	let { xml } = $$props;
	let recognition;
	let synth;
	let resetClicked = "no";
	let areaLabelForStopButton;
	let areaLabelForModalContent;
	let areaLabelForRecordButton;
	let timeForRecording = 15;
	let manageTimer, voiceForSpeech;

	let state = {
		language: "",
		cdata: "",
		disabled: true,
		xml: "",
		status: "",
		isReset: true,
		showTranscript: false,
		counter: 0
	};

	onMount(() => {
		// stores the xml value in xml state
		$$invalidate(3, state.xml = xml, state);

		loadModule(xml);
	});

	// load the module according to the value of xml
	function loadModule(loadXml) {
		// contains json data of xml
		let newXml = XMLToJSON(loadXml);

		// parses the xml data and update the xml
		parseXMLAuthoring(newXml);
	}

	// parses the xml data and update the xml
	function parseXMLAuthoring(MYXML) {
		try {
			// used to set the value of the state language from the value of language key of xml json
			($$invalidate(3, state.language = MYXML.smxml._language, state), $$invalidate(
				3,
				// used to set the value of the state cdata from the value of cdata key of xml json
				state.cdata = MYXML.smxml.__cdata,
				state
			), $$invalidate(
				3,
				// used to set the value of the state status from the value of status key of xml json
				state.status = MYXML.smxml._status,
				state
			), $$invalidate(
				3,
				// used to sets the value of the state disabled to false if the value of 'status' key of xml json is 'recordingStopped' otherwise 'true' 
				state.disabled = MYXML.smxml._status == "recordingStopped" ? false : true,
				state
			), $$invalidate(
				3,
				// used to set the value of the state isReset from the value of isReset key of xml json
				state.isReset = MYXML.smxml._isReset == "true" ? true : false,
				state
			), $$invalidate(
				3,
				// used to set the value of the state showTranscript from the value of showTranscript key of xml json
				state.showTranscript = MYXML.smxml._showTranscript == "true" ? true : false,
				state
			));

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();
		} catch(event) {
			console.warn({
				"error": event.message,
				"function name": "parseXMLAuthoring",
				"File name": "AudioRecorder.svelte"
			});
		}
	}

	// assign the value of 'showTranscript' state to target elements checked value
	function handleCheck(event) {
		$$invalidate(3, state.showTranscript = event.target.checked, state);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();
	}

	// used for update the xml and disabled the element for language selection and to show the transcript checkbox
	function checkState() {
		let state_timer = setTimeout(
			function () {
				// creates the xml according to the value of states: status, language, isReset, showTranscript and cdata
				let xml = "<smxml type=\"43\" name=\"AudioRecorder\" status=\"" + state.status + "\" language=\"" + state.language + "\" isReset=\"" + state.isReset + "\" showTranscript=\"" + state.showTranscript + "\"><!--[CDATA[" + state.cdata + "]]--></smxml>";

				// update the xml
				updateData(xml);

				state.status != ""
				? // disabled the show transcript checkbox and language select dropdown
					(AH.select(".disability_apply, #showTranscript").disabled = "disabled", // makes label of language select and show transcript to look like disabled
					AH.selectAll(".transcript_container, .select_label_container label", "addClass", "disabledState"))
				: // enables the show transcript checkbox and language select dropdown
					(AH.select(".disability_apply, #showTranscript").disabled = "", // makes label of language select and show transcript to look like active
					AH.selectAll(".transcript_container, .select_label_container label", "removeClass", "disabledState"));

				// used for screen reader to read the message when user reached on play button
				$$invalidate(0, areaLabelForStopButton = AH.select("#authoring_container #stopButton span").getAttribute("data-original-title"));

				// used for screen reader to read the message when user reached on record button
				$$invalidate(2, areaLabelForRecordButton = AH.select("#authoring_container #recordButton span").getAttribute("data-original-title"));

				// used for screen reader to read the message when user open the reset modalbox
				$$invalidate(1, areaLabelForModalContent = AH.select("#dialogBody").innerText);

				// clear the previously set timeout
				clearTimeout(state_timer);
			},
			100
		);
	}

	// updates the xml
	function updateData(xml) {
		getChildXml(xml);
	}

	// used for handle the states value
	function handleChange(event) {
		$$invalidate(3, state[event.target.name] = event.target.value, state);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();
	}

	// starts the recording
	function startRecording() {
		switch (state.status) {
			case "recording":
				// stops the recording when stop recording button clicked
				stopRecording();
				break;
			case "recordingStopped":
				// for show the reset modalbox when start recording button clicked and recording is done previously
				AH.getBS("#authoring_confirm_modal", "Modal").show();
				// focus on reset modalbox for screen reader purpose
				AH.select(".modal-body").focus();
				break;
			default:
				dictate();
				$$invalidate(3, state.status = "recording", state);
				$$invalidate(3, state.isReset = false, state);
				// used for count the second after recording start
				$$invalidate(3, state.counter = 0, state);
				// used for automatically end the recording after 15 sec
				timeForRecording = 15;
				// ends recording after 15 sec
				manageTime();
				// used for update the xml and disabled the element for language selection and to show the transcript checkbox
				checkState();
				// adds the stop recording icon to record button
				AH.selectAll("#recordButton span", "removeClass", ["icomoon-circle-2", "s2", "text-danger"]);
				AH.selectAll("#recordButton span", "addClass", "icomoon-24px-stop");
		}
	}

	//check that reset button is clicked or not
	function setData() {
		resetClicked = "yes";
	}

	// called for speak the recorded text
	function playRecording() {
		if (window.speechSynthesis) {
			synth = window.speechSynthesis;

			if (state.cdata != "") {
				// hides the initial state image of the audio container and recording gif
				AH.selectAll(".authRecordingOn, .authInitialState", "addClass", "h");

				// shows the play gif
				AH.selectAll(".authAudioPlaying", "removeClass", "h");

				$$invalidate(3, state.disabled = true, state);

				// used for update the xml and disabled the element for language selection and to show the transcript checkbox
				checkState();

				// removes all utterances from the utterance queue.
				//synth.cancel();
				// speak the recorded text after defining some properties value and adding event
				isSpeechSynthesisSupported();
			} else {
				// hides the play and recording gif
				AH.selectAll(".authRecordingOn, .authAudioPaused", "addClass", "h");

				// shows the initial state image of the audio container
				AH.selectAll(".authInitialState", "removeClass", "h");

				// message for no data recorded
				AH.alert(language.no_data_msg);
			}
		} else {
			// message for not supported speechSynthesis
			AH.alert(language.browser_support_msg);

			return;
		}
	}

	// speak the text after defining some properties value and adding event
	function isSpeechSynthesisSupported() {
		// Returns a new SpeechSynthesisUtterance object instance
		let utterThis = new SpeechSynthesisUtterance(state.cdata);

		// sets the voice name according to the value of language state
		let voice_name = state.language == "de-DE"
		? "Google Deutsch"
		: state.language == "fr-FR"
			? "Google français"
			: state.language == "es-ES"
				? "Google español"
				: state.language == "hi-IN"
					? "Google हिन्दी"
					: state.language == "ja-JP"
						? "Google 日本語"
						: state.language == "ko-KR"
							? "Google 한국의"
							: state.language == "it-IT"
								? "Google italiano"
								: "Google US English";

		// event listener fired when the utterance has finished being spoken.
		utterThis.addEventListener("end", function () {
			// hides the gif of recording and play
			AH.selectAll(".authAudioPlaying, .authRecordingOn", "addClass", "h");

			// shows the initial state image of the audio container
			AH.selectAll(".authInitialState", "removeClass", "h");

			// enables the play button
			$$invalidate(3, state.disabled = false, state);

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();

			// removes all utterances from the utterance queue.
			synth.cancel();
		});

		// array of available voices
		setTimeout(
			function () {
				voiceForSpeech = synth.getVoices();

				for (let index_no = 0; index_no < voiceForSpeech.length; index_no++) {
					if (voiceForSpeech[index_no].name == voice_name) {
						//  sets the voice that will be used to speak the utterance.
						utterThis.voice = voiceForSpeech[index_no];

						// sets the pitch at which the utterance will be spoken at.
						utterThis.pitch = 1;

						// sets the speed at which the utterance will be spoken at.
						utterThis.rate = 1;

						// sets the language of the utterance
						utterThis.lang = state.language;

						// adds an utterance to the utterance queue; it will be spoken when any other utterances queued before it have been spoken.
						synth.speak(utterThis);
					}
				}
			},
			10
		);
	}

	// stops capturing incoming audio
	function stopRecording() {
		// handles with gif of recording and play and icon of record button
		manageStopStatus();

		// clears the timeout which is started when recording stared
		clearTimeout(manageTimer);

		// change the value of status state
		$$invalidate(3, state.status = "recordingStopped", state);

		// change the value of disabled state to false that enables the play button
		$$invalidate(3, state.disabled = false, state);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();

		// shows the initial view of the audio container
		AH.select(".authInitialState", "removeClass", "h");

		/* stops the speech recognition service from listening to incoming audio, and attempts to return a SpeechRecognitionResult using the audio captured so far. */
		recognition.stop();
	}

	// handles with gif of recording and play and icon of record button
	function manageStopStatus() {
		// hides the gif of recording and playing
		AH.selectAll(".authAudioPlaying, .authRecordingOn", "addClass", "h");

		// shows the initial state image of the audio container
		AH.selectAll(".authInitialState", "removeClass", "h");

		// removes the stop icon from recording button and adds start recording icon
		AH.selectAll("#recordButton span", "removeClass", "icomoon-24px-stop");

		AH.selectAll("#recordButton span", "addClass", ["icomoon-circle-2", "s2", "text-danger"]);
	}

	// reset the previous recorded data
	function manageData() {
		// when reset modalbox open after click on reset button
		if (resetClicked == "yes") {
			// reset the previously recorded data
			resetAudioData();

			resetClicked = "no";
		} else {
			// when reset modalbox open after click on record button
			($$invalidate(3, state.cdata = "", state), $$invalidate(
				3,
				// disabled the play button
				state.disabled = true,
				state
			), $$invalidate(3, state.status = "", state));

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();

			let manage_data_timer = setTimeout(
				function () {
					// called for start the recording
					startRecording();

					// clear the timeout
					clearTimeout(manage_data_timer);
				},
				120
			);
		}
	}

	// checks if SpeechRecognition supported then defines some properties value of SpeechRecogniton and adds  some event listener as well
	function isSpeechRecognitionSupported() {
		if (window.webkitSpeechRecognition || window.SpeechRecognition) {
			window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;

			// creates new recognition object
			recognition = new SpeechRecognition();

			//Controls whether continuous results are returned for each recognition
			recognition.continuous = true;

			// returns interim results 
			recognition.interimResults = true;

			//  sets the language of the current SpeechRecognition
			recognition.lang = state.language;

			// used for globally access the recogniton 
			window.recognitionData = recognition;

			recognition.addEventListener("end", function () {
				if (!state.isReset) {
					// clears the timeout which is started when recording stared
					clearTimeout(manageTimer);

					// shows message that recording ended
					AH.alert(language.recording_ended);

					// handles with gif of recording and play and icon of record button
					manageStopStatus();

					// shows the initial state image of the audio container
					AH.selectAll(".authInitialState", "removeClass", "h");

					$$invalidate(3, state.status = "recordingStopped", state);

					// enables the play button
					$$invalidate(3, state.disabled = false, state);

					// used for update the xml and disabled the element for language selection and to show the transcript checkbox
					checkState();
				}
			});
		} else {
			// shows the message that SpeechRecognition not supported
			AH.alert(language.browser_support_msg);

			return;
		}
	}

	// ends recording after 15 sec
	function manageTime() {
		timeForRecording = timeForRecording - 1;
		$$invalidate(3, state.counter = state.counter + 1, state);

		manageTimer = setTimeout(
			function () {
				if (timeForRecording > 0) {
					// calls again the method manageTime for counting the second value
					manageTime();
				} else {
					// stops the recording
					stopRecording();
				}
			},
			1000
		);
	}

	// start the listening to incoming audio, enables reset button, stores the recognised data to cdata state and update the xml 
	function dictate() {
		// checks if SpeechRecognition supported then defines some properties value of SpeechRecogniton and adds  some event listener as well
		isSpeechRecognitionSupported();

		/* starts the speech recognition service listening to incoming audio with intent to recognize grammars associated with the current SpeechRecognition. */
		recognition.start();

		// enables reset button
		AH.select("#resetButton").disabled = "";

		// hides the initial state image of the audio container and play gif
		AH.selectAll(".authAudioPlaying, .authInitialState", "addClass", "h");

		// shows recording gif
		AH.selectAll(".authRecordingOn", "removeClass", "h");

		/* The onresult property of the SpeechRecognition interface represents an event handler that will run when the speech recognition service returns a result — a word or phrase has been positively recognized and this has been communicated back to the app */
		recognition.onresult = event => {
			let speechToText = "";

			for (let index_no = 0; index_no < event.results.length; index_no = index_no + 1) {
				speechToText += event.results[index_no][0].transcript;
			}

			// sets the value of textual data into cdata state that is recognised by SpeechRecognition
			$$invalidate(3, state.cdata = speechToText.trim(), state);

			// used for update the xml and disabled the element for language selection and to show the transcript checkbox
			checkState();
		};
	}

	// disabled the reset and play button and blanks the value of cdata and xml of state
	function resetAudioData() {
		// handles with gif of recording and play and icon of record button
		manageStopStatus();

		if (state.status == "recording") {
			/* stops the speech recognition service from listening to incoming audio, and attempts to return a SpeechRecognitionResult using the audio captured so far. */
			recognition.stop();
		}

		$$invalidate(3, state.language = "", state);
		$$invalidate(3, state.cdata = "", state);
		$$invalidate(3, state.disabled = true, state);
		$$invalidate(3, state.xml = "", state);
		$$invalidate(3, state.status = "", state);
		$$invalidate(3, state.isReset = true, state);

		// clears the timeout which is started when recording stared
		clearTimeout(manageTimer);

		// used for update the xml and disabled the element for language selection and to show the transcript checkbox
		checkState();
	}

	// reset the data of 'resetClicked' to 'no' when no button is clicked in modalbox
	function modalResponse() {
		resetClicked = "no";
	}

	// for ada checkbox
	function adaKeyupCheckbox(e) {
		if (e.keyCode == 13) {
			handleCheck(e);
		}
	}

	const writable_props = ["getChildXml", "xml"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<AudioRecorder> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("getChildXml" in $$props) $$invalidate(12, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(13, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		onMount,
		XMLToJSON,
		AH,
		l: language,
		getChildXml,
		xml,
		recognition,
		synth,
		resetClicked,
		areaLabelForStopButton,
		areaLabelForModalContent,
		areaLabelForRecordButton,
		timeForRecording,
		manageTimer,
		voiceForSpeech,
		state,
		loadModule,
		parseXMLAuthoring,
		handleCheck,
		checkState,
		updateData,
		handleChange,
		startRecording,
		setData,
		playRecording,
		isSpeechSynthesisSupported,
		stopRecording,
		manageStopStatus,
		manageData,
		isSpeechRecognitionSupported,
		manageTime,
		dictate,
		resetAudioData,
		modalResponse,
		adaKeyupCheckbox
	});

	$$self.$inject_state = $$props => {
		if ("getChildXml" in $$props) $$invalidate(12, getChildXml = $$props.getChildXml);
		if ("xml" in $$props) $$invalidate(13, xml = $$props.xml);
		if ("recognition" in $$props) recognition = $$props.recognition;
		if ("synth" in $$props) synth = $$props.synth;
		if ("resetClicked" in $$props) resetClicked = $$props.resetClicked;
		if ("areaLabelForStopButton" in $$props) $$invalidate(0, areaLabelForStopButton = $$props.areaLabelForStopButton);
		if ("areaLabelForModalContent" in $$props) $$invalidate(1, areaLabelForModalContent = $$props.areaLabelForModalContent);
		if ("areaLabelForRecordButton" in $$props) $$invalidate(2, areaLabelForRecordButton = $$props.areaLabelForRecordButton);
		if ("timeForRecording" in $$props) timeForRecording = $$props.timeForRecording;
		if ("manageTimer" in $$props) manageTimer = $$props.manageTimer;
		if ("voiceForSpeech" in $$props) voiceForSpeech = $$props.voiceForSpeech;
		if ("state" in $$props) $$invalidate(3, state = $$props.state);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*xml, state*/ 8200) {
			 {
				if (xml != state.xml) {
					// stores the xml value in xml state
					$$invalidate(3, state.xml = xml, state);

					loadModule(xml);
				}
			}
		}
	};

	return [
		areaLabelForStopButton,
		areaLabelForModalContent,
		areaLabelForRecordButton,
		state,
		handleCheck,
		handleChange,
		startRecording,
		setData,
		playRecording,
		manageData,
		modalResponse,
		adaKeyupCheckbox,
		getChildXml,
		xml
	];
}

class AudioRecorder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { getChildXml: 12, xml: 13 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AudioRecorder",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[12] === undefined && !("getChildXml" in props)) {
			console_1.warn("<AudioRecorder> was created without expected prop 'getChildXml'");
		}

		if (/*xml*/ ctx[13] === undefined && !("xml" in props)) {
			console_1.warn("<AudioRecorder> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<AudioRecorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<AudioRecorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<AudioRecorder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<AudioRecorder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default AudioRecorder;
//# sourceMappingURL=AudioRecorder-579c8f28.js.map
