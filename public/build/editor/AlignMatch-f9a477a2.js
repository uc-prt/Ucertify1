
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, a7 as createEventDispatcher, e as element, f as space, h as text, j as attr_dev, k as add_location, n as insert_dev, p as append_dev, q as listen_dev, F as set_data_dev, B as noop, x as detach_dev, g as globals, y as l, ad as afterUpdate, L as beforeUpdate, A as AH, o as onMount, X as XMLToJSON, w as writable, C as validate_each_argument, z as empty, K as destroy_each, c as create_component, m as mount_component, E as is_function, t as transition_in, a as transition_out, b as destroy_component, H as run_all, G as prop_dev } from './main-f61f6173.js';

/* clsSMAlignMatch\AlignMatchButton.svelte generated by Svelte v3.40.2 */
const file = "clsSMAlignMatch\\AlignMatchButton.svelte";

function create_fragment(ctx) {
	let button;
	let span0;
	let t0;
	let span1;
	let t1;
	let button_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = text(/*btnName*/ ctx[1]);
			attr_dev(span0, "class", "icomoon-new-24px-add-circle-1 s3");
			add_location(span0, file, 11, 4, 316);
			attr_dev(span1, "class", "position-relative top1");
			add_location(span1, file, 12, 4, 376);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", button_class_value = "btn btn-sm btn-outline-primary " + /*btnClass*/ ctx[0]);
			attr_dev(button, "id", /*id*/ ctx[2]);
			add_location(button, file, 5, 0, 165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span0);
			append_dev(button, t0);
			append_dev(button, span1);
			append_dev(span1, t1);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*btnName*/ 2) set_data_dev(t1, /*btnName*/ ctx[1]);

			if (dirty & /*btnClass*/ 1 && button_class_value !== (button_class_value = "btn btn-sm btn-outline-primary " + /*btnClass*/ ctx[0])) {
				attr_dev(button, "class", button_class_value);
			}

			if (dirty & /*id*/ 4) {
				attr_dev(button, "id", /*id*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlignMatchButton', slots, []);
	let { btnClass = '' } = $$props, { btnName } = $$props, { id } = $$props;
	const dispatch = createEventDispatcher();
	const writable_props = ['btnClass', 'btnName', 'id'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlignMatchButton> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch('btnClick');

	$$self.$$set = $$props => {
		if ('btnClass' in $$props) $$invalidate(0, btnClass = $$props.btnClass);
		if ('btnName' in $$props) $$invalidate(1, btnName = $$props.btnName);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		btnClass,
		btnName,
		id,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ('btnClass' in $$props) $$invalidate(0, btnClass = $$props.btnClass);
		if ('btnName' in $$props) $$invalidate(1, btnName = $$props.btnName);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [btnClass, btnName, id, dispatch, click_handler];
}

class AlignMatchButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { btnClass: 0, btnName: 1, id: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlignMatchButton",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*btnName*/ ctx[1] === undefined && !('btnName' in props)) {
			console.warn("<AlignMatchButton> was created without expected prop 'btnName'");
		}

		if (/*id*/ ctx[2] === undefined && !('id' in props)) {
			console.warn("<AlignMatchButton> was created without expected prop 'id'");
		}
	}

	get btnClass() {
		throw new Error("<AlignMatchButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set btnClass(value) {
		throw new Error("<AlignMatchButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get btnName() {
		throw new Error("<AlignMatchButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set btnName(value) {
		throw new Error("<AlignMatchButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<AlignMatchButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<AlignMatchButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* clsSMAlignMatch\AlignMatch.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file$1 = "clsSMAlignMatch\\AlignMatch.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[29] = list[i];
	child_ctx[31] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i];
	child_ctx[34] = i;
	return child_ctx;
}

// (554:4) {#if state.authordata}
function create_if_block(ctx) {
	let each_1_anchor;
	let each_value = /*state*/ ctx[1].authordata;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*removeItems, state, files, getChosenFile, removeCategory, icon_class, openEditDialog*/ 2455) {
				each_value = /*state*/ ctx[1].authordata;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(554:4) {#if state.authordata}",
		ctx
	});

	return block;
}

// (566:40) {#if data4.class == 'categories'}
function create_if_block_3(ctx) {
	let button;
	let span;
	let span_title_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			attr_dev(span, "title", span_title_value = l.delete_column);
			attr_dev(span, "data-bs-toggle", "tooltip");
			attr_dev(span, "class", /*icon_class*/ ctx[2]);
			add_location(span, file$1, 570, 48, 26125);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "btn_category btn mx-auto");
			add_location(button, file$1, 566, 44, 25829);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*removeCategory*/ ctx[8].bind(this, /*data4*/ ctx[32].id))) /*removeCategory*/ ctx[8].bind(this, /*data4*/ ctx[32].id).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(566:40) {#if data4.class == 'categories'}",
		ctx
	});

	return block;
}

// (575:36) {#if data4.class == 'items'}
function create_if_block_2(ctx) {
	let label;
	let span;
	let span_title_value;
	let t;
	let input;
	let input_id_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			span = element("span");
			t = space();
			input = element("input");
			attr_dev(span, "title", span_title_value = l.file_elem);
			attr_dev(span, "class", "icomoon-images position-relative");
			add_location(span, file$1, 576, 44, 26616);
			attr_dev(input, "type", "file");
			attr_dev(input, "id", input_id_value = 'imgUpload' + /*data4*/ ctx[32].id);
			attr_dev(input, "class", "imgUpload h");
			add_location(input, file$1, 577, 44, 26738);
			attr_dev(label, "class", "fileUpload btn btn-outline-primary bg-white rounded-0");
			attr_dev(label, "tabindex", "0");
			add_location(label, file$1, 575, 40, 26462);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, span);
			append_dev(label, t);
			append_dev(label, input);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[15]),
					listen_dev(input, "change", /*getChosenFile*/ ctx[11], false, false, false),
					listen_dev(label, "keydown", keydownAda, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state*/ 2 && input_id_value !== (input_id_value = 'imgUpload' + /*data4*/ ctx[32].id)) {
				attr_dev(input, "id", input_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(575:36) {#if data4.class == 'items'}",
		ctx
	});

	return block;
}

// (557:7) {#each data as data4, j}
function create_each_block_1(ctx) {
	let div1;
	let div0;
	let textarea;
	let textarea_aria_label_value;
	let textarea_class_value;
	let textarea_value_value;
	let textarea_placeholder_value;
	let t0;
	let t1;
	let div1_key_value;
	let div1_id_value;
	let mounted;
	let dispose;
	let if_block0 = /*data4*/ ctx[32].class == 'categories' && create_if_block_3(ctx);
	let if_block1 = /*data4*/ ctx[32].class == 'items' && create_if_block_2(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			textarea = element("textarea");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr_dev(textarea, "aria-label", textarea_aria_label_value = /*data4*/ ctx[32].text);

			attr_dev(textarea, "class", textarea_class_value = /*data4*/ ctx[32].class == 'categories'
			? 'categories pointer text_alignmatch'
			: 'items pointer text_alignmatch');

			textarea.value = textarea_value_value = /*data4*/ ctx[32].text;

			attr_dev(textarea, "placeholder", textarea_placeholder_value = /*data4*/ ctx[32].class == 'categories'
			? 'Category Name'
			: 'Item Information');

			textarea.readOnly = "readonly";
			add_location(textarea, file$1, 559, 10, 25045);
			attr_dev(div0, "class", "d-flex flex-column-reverse width180");
			add_location(div0, file$1, 558, 9, 24984);
			attr_dev(div1, "key", div1_key_value = /*j*/ ctx[34]);
			attr_dev(div1, "class", "columnContainer border-0");
			attr_dev(div1, "id", div1_id_value = /*data4*/ ctx[32].id);
			add_location(div1, file$1, 557, 8, 24913);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, textarea);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "keydown", keydownAda, false, false, false),
					listen_dev(
						textarea,
						"click",
						function () {
							if (is_function(/*data4*/ ctx[32].class == 'categories'
							? /*openEditDialog*/ ctx[4].bind(this, "categories", /*data4*/ ctx[32].id)
							: /*openEditDialog*/ ctx[4].bind(this, "items", /*data4*/ ctx[32].id))) (/*data4*/ ctx[32].class == 'categories'
							? /*openEditDialog*/ ctx[4].bind(this, "categories", /*data4*/ ctx[32].id)
							: /*openEditDialog*/ ctx[4].bind(this, "items", /*data4*/ ctx[32].id)).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*state*/ 2 && textarea_aria_label_value !== (textarea_aria_label_value = /*data4*/ ctx[32].text)) {
				attr_dev(textarea, "aria-label", textarea_aria_label_value);
			}

			if (dirty[0] & /*state*/ 2 && textarea_class_value !== (textarea_class_value = /*data4*/ ctx[32].class == 'categories'
			? 'categories pointer text_alignmatch'
			: 'items pointer text_alignmatch')) {
				attr_dev(textarea, "class", textarea_class_value);
			}

			if (dirty[0] & /*state*/ 2 && textarea_value_value !== (textarea_value_value = /*data4*/ ctx[32].text)) {
				prop_dev(textarea, "value", textarea_value_value);
			}

			if (dirty[0] & /*state*/ 2 && textarea_placeholder_value !== (textarea_placeholder_value = /*data4*/ ctx[32].class == 'categories'
			? 'Category Name'
			: 'Item Information')) {
				attr_dev(textarea, "placeholder", textarea_placeholder_value);
			}

			if (/*data4*/ ctx[32].class == 'categories') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*data4*/ ctx[32].class == 'items') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*state*/ 2 && div1_id_value !== (div1_id_value = /*data4*/ ctx[32].id)) {
				attr_dev(div1, "id", div1_id_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(557:7) {#each data as data4, j}",
		ctx
	});

	return block;
}

// (583:28) {#if i != 0}
function create_if_block_1(ctx) {
	let button;
	let span;
	let span_title_value;
	let button_id_value;
	let button_row_tags_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			attr_dev(span, "class", "icomoon-new-24px-delete-1 position-relative s3");
			attr_dev(span, "title", span_title_value = l.delete_row);
			attr_dev(span, "data-bs-toggle", "tooltip");
			add_location(span, file$1, 584, 36, 27213);
			attr_dev(button, "type", "button");
			attr_dev(button, "id", button_id_value = "tags_" + /*i*/ ctx[31]);
			attr_dev(button, "row_tags", button_row_tags_value = /*i*/ ctx[31]);
			attr_dev(button, "class", "btn_category btn me-2 pt-0");
			add_location(button, file$1, 583, 32, 27068);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*removeItems*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(583:28) {#if i != 0}",
		ctx
	});

	return block;
}

// (555:5) {#each state.authordata as data, i}
function create_each_block(ctx) {
	let div;
	let t0;
	let t1;
	let div_key_value;
	let each_value_1 = /*data*/ ctx[29];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let if_block = /*i*/ ctx[31] != 0 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			attr_dev(div, "key", div_key_value = /*i*/ ctx[31]);
			attr_dev(div, "class", "rowContainer pt-2 d-flex align-items-center pe-3");
			add_location(div, file$1, 555, 6, 24800);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t0);
			if (if_block) if_block.m(div, null);
			append_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*state, files, getChosenFile, removeCategory, icon_class, openEditDialog*/ 2327) {
				each_value_1 = /*data*/ ctx[29];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (/*i*/ ctx[31] != 0) if_block.p(ctx, dirty);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(555:5) {#each state.authordata as data, i}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div11;
	let div4;
	let div2;
	let div0;
	let t0;
	let div1;
	let alignmatchbutton0;
	let t1;
	let div3;
	let alignmatchbutton1;
	let t2;
	let div10;
	let div9;
	let div8;
	let div5;
	let h4;
	let t4;
	let button0;
	let t5;
	let div6;
	let textarea;
	let t6;
	let p;
	let t8;
	let div7;
	let button1;
	let current;
	let mounted;
	let dispose;
	let if_block = /*state*/ ctx[1].authordata && create_if_block(ctx);

	alignmatchbutton0 = new AlignMatchButton({
			props: {
				btnClass: "span16 add_cat_btn w-auto",
				id: "add_cat_btn",
				btnName: l.add_category
			},
			$$inline: true
		});

	alignmatchbutton0.$on("btnClick", /*addCategory*/ ctx[10]);

	alignmatchbutton1 = new AlignMatchButton({
			props: { id: "btn", btnName: l.add_item },
			$$inline: true
		});

	alignmatchbutton1.$on("btnClick", /*addItem*/ ctx[9]);

	const block = {
		c: function create() {
			div11 = element("div");
			div4 = element("div");
			div2 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div1 = element("div");
			create_component(alignmatchbutton0.$$.fragment);
			t1 = space();
			div3 = element("div");
			create_component(alignmatchbutton1.$$.fragment);
			t2 = space();
			div10 = element("div");
			div9 = element("div");
			div8 = element("div");
			div5 = element("div");
			h4 = element("h4");
			h4.textContent = `${l.edit_dialog}`;
			t4 = space();
			button0 = element("button");
			t5 = space();
			div6 = element("div");
			textarea = element("textarea");
			t6 = space();
			p = element("p");
			p.textContent = "Please enter some valid data.";
			t8 = space();
			div7 = element("div");
			button1 = element("button");
			button1.textContent = `${l.update}`;
			attr_dev(div0, "class", "tableContainer light-cyan-bg mx-auto");
			add_location(div0, file$1, 552, 3, 24672);
			attr_dev(div1, "class", "text-center position-relative");
			add_location(div1, file$1, 591, 3, 27462);
			attr_dev(div2, "class", "d-flex align-items-center mx-2 mt-2");
			add_location(div2, file$1, 551, 2, 24618);
			attr_dev(div3, "class", "text-center my-2");
			add_location(div3, file$1, 600, 2, 27776);
			attr_dev(div4, "class", "categoryAuthorcontainer");
			add_location(div4, file$1, 550, 1, 24577);
			attr_dev(h4, "class", "modal-title");
			add_location(h4, file$1, 612, 5, 28143);
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "btn-close");
			attr_dev(button0, "data-bs-dismiss", "modal");
			attr_dev(button0, "aria-hidden", "true");
			add_location(button0, file$1, 613, 5, 28194);
			attr_dev(div5, "class", "modal-header");
			add_location(div5, file$1, 611, 4, 28110);
			attr_dev(textarea, "class", "text-start w-100 h-100 form-control");
			attr_dev(textarea, "id", "editValue");
			add_location(textarea, file$1, 616, 5, 28347);
			attr_dev(p, "class", "error_msg text-left text-danger mb-0 h");
			add_location(p, file$1, 617, 20, 28572);
			attr_dev(div6, "class", "modal-body text-center");
			add_location(div6, file$1, 615, 4, 28304);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "id", "updateButton");
			attr_dev(button1, "class", "sure btn btn-primary");
			add_location(button1, file$1, 620, 5, 28723);
			attr_dev(div7, "class", "modal-footer mt-0");
			add_location(div7, file$1, 619, 4, 28685);
			attr_dev(div8, "class", "modal-content");
			add_location(div8, file$1, 610, 3, 28077);
			attr_dev(div9, "class", "modal-dialog modal-dialog-centered span4");
			add_location(div9, file$1, 609, 2, 28018);
			attr_dev(div10, "class", "modal");
			attr_dev(div10, "id", "editModal");
			add_location(div10, file$1, 608, 1, 27980);
			attr_dev(div11, "class", "border");
			add_location(div11, file$1, 549, 0, 24554);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div11, anchor);
			append_dev(div11, div4);
			append_dev(div4, div2);
			append_dev(div2, div0);
			if (if_block) if_block.m(div0, null);
			append_dev(div2, t0);
			append_dev(div2, div1);
			mount_component(alignmatchbutton0, div1, null);
			append_dev(div4, t1);
			append_dev(div4, div3);
			mount_component(alignmatchbutton1, div3, null);
			append_dev(div11, t2);
			append_dev(div11, div10);
			append_dev(div10, div9);
			append_dev(div9, div8);
			append_dev(div8, div5);
			append_dev(div5, h4);
			append_dev(div5, t4);
			append_dev(div5, button0);
			append_dev(div8, t5);
			append_dev(div8, div6);
			append_dev(div6, textarea);
			append_dev(div6, t6);
			append_dev(div6, p);
			append_dev(div8, t8);
			append_dev(div8, div7);
			append_dev(div7, button1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(
						textarea,
						"change",
						function () {
							if (is_function(/*state*/ ctx[1].editType == 'categories'
							? /*updateCategory*/ ctx[5].bind(this, /*state*/ ctx[1].editId)
							: /*updateItem*/ ctx[6].bind(this, /*state*/ ctx[1].editId))) (/*state*/ ctx[1].editType == 'categories'
							? /*updateCategory*/ ctx[5].bind(this, /*state*/ ctx[1].editId)
							: /*updateItem*/ ctx[6].bind(this, /*state*/ ctx[1].editId)).apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(button1, "click", /*closeDialog*/ ctx[3].bind(this), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*state*/ ctx[1].authordata) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(alignmatchbutton0.$$.fragment, local);
			transition_in(alignmatchbutton1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(alignmatchbutton0.$$.fragment, local);
			transition_out(alignmatchbutton1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div11);
			if (if_block) if_block.d();
			destroy_component(alignmatchbutton0);
			destroy_component(alignmatchbutton1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function splitArrayIntoChunksOfLen(arr, len) {
	let chunks = [], i = 0, n = arr.length;

	while (i < n) {
		chunks.push(arr.slice(i, i += len));
	}

	return chunks;
}

// For ADA
function keydownAda(event) {
	if (event.which === 13) {
		// click the textarea element or image upload icon on which keydown
		this.click();
	}
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlignMatch', slots, []);
	let { getChildXml } = $$props;
	let { editorState } = $$props;
	let { xml } = $$props;
	let files;

	let state = {},
		// used for delete icon
		icon_class = "icomoon-new-24px-delete-1 position-relative s3",
		// used to uniquily define the id of the cells
		con = 1,
		//used for update the value of state authordata
		myObj = [],
		// container for match data
		matchdata = {
			// container for category key of matchdata
			category: {
				// container for categories key of category key of matchdata
				categories: []
			},
			// container for item key of matchdata
			item: {
				// container for items key of item key of matchdata
				items: []
			},
			// not used any where
			settings: {}
		};

	// id of the cell on which clicked for change the text
	let blnUserChange = null;

	let authordata = writable({
		// contains the xml data
		xml: "",
		// not used
		csv: "",
		// not used
		json: "",
		// used to show the UI of the component
		authordata: "",
		// used to set the max with
		maxWidth: "",
		// contains the type of cell that have to update such as category cell or item cell when click on it
		editType: "",
		// contains the cell id that have to be update when click on it
		editId: ""
	});

	const unsubscribe = authordata.subscribe(items => {
		$$invalidate(1, state = items);
	});

	afterUpdate(() => {
		if (xml != state.xml) {
			$$invalidate(1, state.xml = xml, state);
			loadModule(xml);
		}
	});

	beforeUpdate(() => {
		if (editorState) {
			AH.set('alignMatchReset', true);
		}

		if (editorState.stopAuthoringUpdate == true) {
			return;
		}
	});

	onMount(() => {
		$$invalidate(1, state.xml = xml, state);
		loadModule(xml);
	});

	function loadModule(loadXml) {
		// convert the xml into json and pass it in the parseXMLAuthoring function to parse the xml
		loadXml = XMLToJSON(loadXml);

		parseXMLAuthoring(loadXml);
	}

	// update the value of state xml, maxWidth, and authordata
	function parseXMLAuthoring(MYXML) {
		// contains json data of cdata of xml
		let jsonData = JSON.parse(MYXML.smxml.__cdata);

		// sets the value of state authordata
		manipulate(jsonData);

		// sets the value of state 'xml' with the value of variable jsonData
		$$invalidate(1, state.xml = jsonData, state);

		// sets the value of state 'maxWidth'
		$$invalidate(
			1,
			state.maxWidth = MYXML.smxml._maxwidth
			? parseInt(MYXML.smxml._maxwidth)
			: 800,
			state
		);
	}

	// sets the value of state authordata
	function manipulate(qwerty) {
		// creates temporary object of cdata of xml
		let tempObj = JSON.parse(JSON.stringify(qwerty));

		// makes blank array myObj
		myObj = [];

		// creates an array
		let ele = [];

		tempObj.category.categories.forEach(function (index) {
			// creates a temporary object
			let deArr = {};

			// creates id key with value defined in 'id' key of object stored in varaible 'index'
			deArr.id = index.id;

			// creates class key with value 'categories'
			deArr.class = 'categories';

			// creates class key with value 'Tags 0'
			deArr.tags = 'Tags 0';

			// creates text key with value defined in 'text' key of object stored in varaible 'index'
			deArr.text = index.text;

			// pushes temporary object 'deArr' into array ele
			ele.push(deArr);
		});

		// pushes array ele into array myObj
		myObj.push(ele);

		// findes no of categories available
		let catLen = tempObj.category.categories.length;

		let itemsArray = splitArrayIntoChunksOfLen(tempObj.item.items, catLen);

		itemsArray.forEach(value => {
			let rowArr = [];

			value.forEach(item_val => {
				let deArr = {};
				deArr.id = item_val.id;
				deArr.class = 'items';
				deArr.tags = 'Tags ';

				if (blnUserChange == item_val.id) {
					// sets the value null of blnUserChange
					blnUserChange = null;

					// creates 'text' key with value of key 'label' of variable item_val
					deArr.text = item_val.label;
				} else {
					// creates 'text' key with value '*' + value of key 'imageurl' of variable item_val + '[' + value of key 'imagealt' of variable item_val + ']' if key 'imageurl' is not blank otherwise value will be the value of key 'label' of variable item_val
					deArr.text = item_val.imageurl != ''
					? '*' + item_val.imageurl + '[' + item_val.imagealt + ']'
					: item_val.label;
				}

				rowArr = [...rowArr, deArr];
			});

			myObj = [...myObj, rowArr];
		});

		// assign the value of array myObj to state authordata
		$$invalidate(1, state.authordata = myObj, state);
	}

	// close the edit dialog box and update the xml after click on update or close (x) button
	function closeDialog() {
		if (AH.select('#editValue').value.trim() != '') {
			AH.getBS('#editModal', 'Modal').hide();

			// change the xml and update the xml
			reverseXml();
		}
	}

	// change the xml and update the xml
	function reverseXml() {
		try {
			// contains the string data of xml json
			let reversedata = JSON.stringify(state.xml, null, 4);

			// creates new xml 
			let updatedXml = '<smxml type="35" name="AlignMatch" maxwidth="' + state.maxWidth + '"><!--[CDATA[' + reversedata + ']]--></smxml>';

			// updates xml
			getChildXml(updatedXml);
		} catch(event) {
			console.warn(event.message);
		}
	}

	// open the edit dialog box to update the text of that cell which is clicked
	function openEditDialog(type, id, event) {
		// updates the value of state 'editType'
		($$invalidate(1, state.editType = type, state), $$invalidate(
			1,
			// updates the value of state 'editId' 
			state.editId = id,
			state
		));

		// shows the edit dialog box when clicked on any cell for update the text of that cell
		AH.getBS('#editModal', 'Modal').show();

		// contains the value of cell, which is clicked and sets that value in the body of edit dialog box
		AH.select("#editValue").value = event.target.value;

		// focus the body of edit dialog box
		AH.select("#editValue").focus();
	}

	// updates the data of category
	function updateCategory(xelement, event) {
		state.xml.category.categories.map(function (data) {
			if (data.id == xelement) {
				// updates the data of category
				data.text = event.target.value != '' ? event.target.value : '';
			}

			if (data.text.trim() == '') {
				AH.selectAll('#editValue', 'addClass', 'border-danger');
				AH.selectAll('.error_msg', 'removeClass', 'h');
			} else {
				AH.selectAll('#editValue', 'removeClass', 'border-danger');
				AH.selectAll('.error_msg', 'addClass', 'h');
			}
		});
	}

	// used to update the cell value
	function updateItem(xelement, event) {
		try {
			state.xml.item.items.map(function (data) {
				if (data.id == xelement) {
					if (event.target.value != '') {
						if (event.target.value.charAt(0) == '*') {
							// contains the index of '[' in target element value
							let startIndex = event.target.value.indexOf('['),
								// contains the index of ']' in target element value
								endIndex = event.target.value.indexOf(']');

							if (startIndex > -1 && endIndex > -1) {
								// contains the image data
								let imageurl = event.target.value.substr(1, startIndex - 1);

								// sets the value of key 'imageurl' of array key 'items' of object key item of state object xml that is equals to the value of variable imageurl
								data.imageurl = imageurl;

								// sets the value blank of key 'label' of array key 'items' of object key item of state object xml
								data.label = '';

								// contains the alt message of image
								let imagealt = event.target.value.substring(event.target.value.lastIndexOf("[") + 1, event.target.value.lastIndexOf("]"));

								// sets the value of key 'imagealt' of array key 'items' of object key item of state object xml that is equals to the value of variable imagealt
								imagealt != ''
								? data.imagealt = imagealt
								: data.imagealt = "imagealt";
							} else {
								// sets the value of key 'label' of array key 'items' of object key item of state object xml that is equals to the value of target element
								data.label = event.target.value;

								// makes the image value blank
								data.imageurl = "";

								// makes the image alt message value blank
								data.imagealt = "";

								// shows the warning message
								AH.alert("Image format is not correct");
							}
						} else {
							// makes the image value blank
							data.imageurl = "";

							// makes the image alt message value blank
							data.imagealt = '';
						}

						if (AH.select('#editValue').value.trim() == '') {
							AH.selectAll('#editValue', 'addClass', 'border-danger');
							AH.selectAll('.error_msg', 'removeClass', 'h');
						} else {
							AH.selectAll('#editValue', 'removeClass', 'border-danger');
							AH.selectAll('.error_msg', 'addClass', 'h');
						}
					}

					data.label = event.target.value;

					// id of the cell on which clicked for change the text
					blnUserChange = xelement;
				}
			});
		} catch(event) {
			console.warn(event.message);
		}
	}

	// removes the row and updates the value of key 'tags' of each cell and update the xml
	function removeItems(event) {
		// find the number of categories exist
		let collen = state.xml.category.categories.length;

		// finds the number of items row exist
		let rowlen = state.xml.item.items.length / collen;

		if (rowlen > 2) {
			// contains numeric data from id of delete button used for delete the row with prefix 'Tags '
			let tag = 'Tags ' + this.getAttribute("row_tags");

			// creates temporary array
			let tempArr = [];

			state.xml.item.items.map(function (data, i) {
				if (data.tags != tag) {
					// pushes the cell data into array tempArr which not lies in the row which we want to delete
					tempArr.push(state.xml.item.items[i]);
				}
			});

			// used to uniquely define the 'tags' key value of array key 'items' of object key 'item' of state object 'xml'
			let _count = 1;

			// contains the categories used
			state.authordata.map(function (datai) {
				// contains the perticular category at specified index
				datai.map(function (dataj) {
					tempArr.map(function (datak) {
						if (dataj.id == datak.id) {
							// defines the value for key 'tags' of array object key 'items' where column id match with category id of key object 'item' of state object xml
							datak.tags = 'Tags ' + _count++;
						}
					});
				});
			});

			// finds the number of row exist after removing the desired row
			rowlen = tempArr.length / collen;

			for (let i = 0, k = 0; i < rowlen; i++) {
				for (let j = 0; j < collen; (j++, k++)) {
					// updates value of key 'tags' of array object key 'items' for row 'i' and column 'j' of key object 'item' of state object xml
					tempArr[k].tags = 'Tags ' + (i + 1);
				}
			}

			// updates the value of array key 'items' of object key 'item' of state object 'xml'
			$$invalidate(1, state.xml.item.items = tempArr, state);

			// change the xml and update the xml
			reverseXml();
		} else {
			// shows the warning message
			AH.alert("You can't have less than 2 rows.");
		}
	}

	// removes the category column have specified 'id' and update the xml
	function removeCategory(id) {
		if (state.xml.category.categories.length > 2) {
			state.xml.category.categories.map(function (data, i) {
				if (data.id == id) {
					// removes the data at index 'i' from array key 'categories' of key object 'category' of state object 'xml'
					state.xml.category.categories.splice(i, 1);

					state.xml.item.items.map(function (data1, j) {
						if (data.id == data1.category) {
							// removes the data at index 'j' from array key 'items' of object key 'item' of state object 'xml'
							state.xml.item.items.splice(j, 1);
						}
					});
				}
			});

			// change the xml and update the xml
			reverseXml();
		} else {
			// shows the warning message
			AH.alert("You can't have less than 2 categories.");
		}
	}

	// used to add the row
	function addItem() {
		// object containing numeric value from id of last category and item
		let ids = getIds();

		// contains category available
		let cat = state.xml.category.categories;

		// used to defined the unique id of the cells in added row
		let itemId = ids.itemId + 1;

		// contains no of column exist
		let noOfCols = state.xml.category.categories.length;

		// contains the value after adding 1 in no of avialable cells 
		let itemLen = state.xml.item.items.length + 1;

		// contains no of item row available
		let noOfRow = (itemLen - 1) / noOfCols;

		if (state.xml.category.categories.length >= 1) {
			if (noOfRow <= 3) {
				for (let i = 1; i <= noOfCols; i++) {
					state.xml.item.items.push({
						imageurl: "",
						imagealt: "",
						// defines the id of the added cell 
						id: 'item_' + itemId,
						label: "",
						// defines in which category it lies
						category: cat[i - 1].id,
						// used at the time of deletion
						tags: "Tags " + (noOfRow + 1)
					});

					// increases the value of item cell
					itemLen++;

					// increases the value for uniquley define the id of item cell
					itemId++;
				}

				// change the xml and update the xml
				reverseXml();
			} else {
				// shows the warning message
				AH.alert("You can't have more than 4 rows.");
			}
		} else {
			// shows the warning message
			AH.alert('First add category.');
		}
	}

	// used to add the category column and update that column with cell item also update the xml
	function addCategory() {
		if (state.xml.category.categories.length <= 3) {
			// defines category number
			let catLen = state.xml.category.categories.length + 1;

			// object containing numeric value from id of last category and item
			let ids = getIds();

			// used to set the id of the category
			let catId = ids.catId + 1;

			// used to set the id of the items added in last category which is currently added
			let itemId = ids.itemId + 1;

			// used for define the number of row exist
			let itemLen = state.xml.item.items.length + 1;

			// finds no of row exist for items
			let noOfRow = (itemLen - 1) / (catLen - 1);

			// used for define the id of new added category
			let newcat = 'category_' + catId;

			// sets the id and text of the category
			state.xml.category.categories.push({ id: newcat, text: "Default Category" });

			for (let i = 0; i < noOfRow; i++) {
				// used for define the id of new added cell/item
				let newitem = 'item_' + itemId;

				// used to add the default cells for added category column with same category id and unique cell id
				state.xml.item.items.splice((catLen - 1) * (i + 1) + i, 0, {
					imageurl: "",
					imagealt: "",
					// defines the id of the added cell 
					id: newitem,
					label: "",
					// defines in which category it lies
					category: newcat,
					// used at the time of deletion
					tags: "Tags " + (i + 1)
				});

				// increase by 1 for defined unique id of each cell item of added category column
				itemId++;
			}

			// enabled the button have class matchbutton
			AH.select('.matchbutton').disabled = false;

			// shows the element have class alignTestarea 
			AH.select('.alignTestarea').style.display = 'block';

			// change the xml and update the xml
			reverseXml();
		} else {
			// shows the warning message
			AH.alert("You can't have more than 4 categories.");
		}
	}

	// returns object containing numeric value from id of last category and item
	function getIds() {
		// contains category available
		let cat = state.xml.category.categories,
			// contains items available
			_item = state.xml.item.items;

		// used for contain the category id
		let catId,
			// used for contain the items id
			itemId;

		if (cat.length > 0) {
			// contains the last category
			let catLast = cat[cat.length - 1];

			// contains the numeric part from id of last category
			catId = parseInt(catLast.id.split('_')[1]);
		} else {
			catId = 0;
		}

		if (_item.length > 0) {
			// contains last item
			let itemLast = _item[_item.length - 1];

			// contains the numeric part from id of last item
			itemId = parseInt(itemLast.id.split('_')[1]);
		} else {
			itemId = 0;
		}

		// returns object containing numeric value from id of last category and item
		return { catId, itemId };
	}

	// upload the file and change the xml and update the xml also change the textarea value of that cell with image file name
	function uploadFile(container) {
		// creates an empty FormData object
		let fd = new FormData();

		Array.prototype.forEach.call(files, _f => {
			// append the new value onto the end of the existing set of values of secified key
			fd.append('image_file', _f);
		});

		AH.ajax({
			// path of the server from which you want to communicate
			url: baseUrl + "sim/smartsim/imageAudioUpload.php?func=upload_pic&ajax=1&user_guid=1&extension=jpg",
			formData: true,
			data: fd
		}).then(urlPath => {
			// contains only file name after removing the path
			let imagePath;

			if (urlPath == "0") {
				// shows the warning message
				AH.alert('Error In Uploading Image File!');

				AH.activate(0);
			} else {
				AH.activate(0);

				// contains null or as an Array object according to not match or match of http: in return data from server
				let matching = urlPath.match(/http:/g);

				if (matching) {
					// removes the path of the uploaded image
					imagePath = urlPath.replace("http://s3.amazonaws.com/jigyaasa_content_static//", "");
				} else {
					// removes the path of the uploaded image
					imagePath = urlPath.replace("//s3.amazonaws.com/jigyaasa_content_static//", "");
				}

				// sets the value of variable imagePath with prefix '*' and sufix '[]' in textarea of cell have id equals to the value of variable container
				AH.select('#' + container).querySelector('textarea').value = '*' + imagePath + '[]';

				// changes the image and alt text and update the xml
				updateImageUrl(container, imagePath);
			}
		}).catch(e => {
			console.warn("error in upload", e);
		});
	}

	// changes the image and alt text and update the xml
	function updateImageUrl(container, imagePath) {
		state.xml.item.items.map(function (data, index) {
			if (data.id == container) {
				// change the value of key 'imageurl' of items object at index retuned by the map method with the value equals to the value of variable imagePath of item key of state xml 
				data.imageurl = imagePath;

				// change the value of key 'imagealt' of items object at index retuned by the map method with the value of index retuned by the map method with prefix 'imagealt_text' of item key of state xml
				data.imagealt = 'imagealt_text' + index;

				// change the value of key 'label' of items object at index retuned by the map method with blank value of item key of state xml
				data.label = '';
			}

			// change the xml and update the xml
			reverseXml();
		});
	}

	// change and update the xml after upload the image
	function getChosenFile(event) {
		let container = event.target.closest('.columnContainer').id;
		AH.activate(2);

		// uploades the image and change the xml and update the xml
		uploadFile(container);
	}

	const writable_props = ['getChildXml', 'editorState', 'xml'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<AlignMatch> was created with unknown prop '${key}'`);
	});

	function input_change_handler() {
		files = this.files;
		$$invalidate(0, files);
	}

	$$self.$$set = $$props => {
		if ('getChildXml' in $$props) $$invalidate(12, getChildXml = $$props.getChildXml);
		if ('editorState' in $$props) $$invalidate(13, editorState = $$props.editorState);
		if ('xml' in $$props) $$invalidate(14, xml = $$props.xml);
	};

	$$self.$capture_state = () => ({
		onMount,
		beforeUpdate,
		afterUpdate,
		writable,
		XMLToJSON,
		AH,
		l,
		AlignMatchButton,
		getChildXml,
		editorState,
		xml,
		files,
		state,
		icon_class,
		con,
		myObj,
		matchdata,
		blnUserChange,
		authordata,
		unsubscribe,
		loadModule,
		parseXMLAuthoring,
		manipulate,
		splitArrayIntoChunksOfLen,
		closeDialog,
		reverseXml,
		openEditDialog,
		updateCategory,
		updateItem,
		removeItems,
		removeCategory,
		addItem,
		addCategory,
		getIds,
		uploadFile,
		updateImageUrl,
		getChosenFile,
		keydownAda
	});

	$$self.$inject_state = $$props => {
		if ('getChildXml' in $$props) $$invalidate(12, getChildXml = $$props.getChildXml);
		if ('editorState' in $$props) $$invalidate(13, editorState = $$props.editorState);
		if ('xml' in $$props) $$invalidate(14, xml = $$props.xml);
		if ('files' in $$props) $$invalidate(0, files = $$props.files);
		if ('state' in $$props) $$invalidate(1, state = $$props.state);
		if ('icon_class' in $$props) $$invalidate(2, icon_class = $$props.icon_class);
		if ('con' in $$props) con = $$props.con;
		if ('myObj' in $$props) myObj = $$props.myObj;
		if ('matchdata' in $$props) matchdata = $$props.matchdata;
		if ('blnUserChange' in $$props) blnUserChange = $$props.blnUserChange;
		if ('authordata' in $$props) authordata = $$props.authordata;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		files,
		state,
		icon_class,
		closeDialog,
		openEditDialog,
		updateCategory,
		updateItem,
		removeItems,
		removeCategory,
		addItem,
		addCategory,
		getChosenFile,
		getChildXml,
		editorState,
		xml,
		input_change_handler
	];
}

class AlignMatch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				getChildXml: 12,
				editorState: 13,
				xml: 14
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlignMatch",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*getChildXml*/ ctx[12] === undefined && !('getChildXml' in props)) {
			console_1.warn("<AlignMatch> was created without expected prop 'getChildXml'");
		}

		if (/*editorState*/ ctx[13] === undefined && !('editorState' in props)) {
			console_1.warn("<AlignMatch> was created without expected prop 'editorState'");
		}

		if (/*xml*/ ctx[14] === undefined && !('xml' in props)) {
			console_1.warn("<AlignMatch> was created without expected prop 'xml'");
		}
	}

	get getChildXml() {
		throw new Error("<AlignMatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getChildXml(value) {
		throw new Error("<AlignMatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editorState() {
		throw new Error("<AlignMatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editorState(value) {
		throw new Error("<AlignMatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xml() {
		throw new Error("<AlignMatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xml(value) {
		throw new Error("<AlignMatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default AlignMatch;
//# sourceMappingURL=AlignMatch-f9a477a2.js.map
