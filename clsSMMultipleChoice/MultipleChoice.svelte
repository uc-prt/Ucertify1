<script>
	/**
	 * File: MultipleChoice.svelte
	 * Author: Pradeep Yadav
	 * Description: Authoring file for multiple choice
	 */
	import { onMount } from "svelte";
	import { writable } from "svelte/store";
	import { AH } from "../helper/HelperAI.svelte";
	import OptionContainer from "./OptionContainer.svelte";
	export let ucEditor;
	export let getChildXml;
	export let editorState;
	export let xml;

	let state = {};
	let hdd = writable({
			correctAnswers:"",
			optionData:"",
			optionDataCopy:"",
			reviewMode:false,
			xml:"",
			optionCounter: 1,
		});
	const unsubscribe = hdd.subscribe((items)=> {
		state = items;
	});
	let letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');

	onMount(async()=> {
		didMount();
	})

	// Interate and load Options
	function didMount() {
		var init = setTimeout(function() {
			loadOldType();
			var loadTimer = setTimeout(function() {
				try {
					document.querySelectorAll("[id^='option']").forEach((_this, i)=> {
						if (_this.querySelectorAll(".pln").length > 0) {
							_this.querySelectorAll(".pln").forEach((_this2)=> {
								if (_this2.nextElementSibling.length > 0 && _this.previousElementSibling.length > 0) {
									if (_this2.nextElementSibling.nodeName == "BR" && _this2.previousElementSibling.nodeName == "BR") {
										_this.nextElementSibling.remove();
										_this2.remove();
									}
								}
							});
							xml ? editOption(i) : "";
						}
					});
				} catch(error) {
					console.log({err:"Removing PrettyPrint  BR from Authoring Error", func:'componentDidMount'});
				}
				ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
				clearTimeout(loadTimer);
			}, 3000);
			clearTimeout(init);
		}, 200);
		AH.listen(document, 'keydown', '.answer_container .delete_element', function(_this, event) {
			if ((event.keyCode == 13 || event.which == 13)) {
				// click the element which currently get the focus and enter key is down
				AH.trigger(_this, 'click');
			}
        });
        
        // this condition used for that guid which is generated by the help of List Item module
        if (editorState.ajaxData.parent_guid) {
            // used for only show the preview
            preview_edit = 1;
            AI && AI.set('get_parent_guid', editorState.ajaxData.parent_guid);
        }
	}

	// TO update modified options
	function updateProps(newData) {
		editorState.ajaxData.correct_answers = newData.correct_answers;
		editorState.ajaxData.answers = newData.answers;
		getChildXml(editorState, "mcqType");
	}

	// Check options and set state
	function loadOldType() {
		state.correctAnswers = editorState.ajaxData.correct_answers;
		state.optionData = editorState.ajaxData.answers;
		state.optionDataCopy = editorState.ajaxData.answers;
		state.optionCounter = editorState.ajaxData.answers.length;
	}

	// Handle Edit of options
	function editOption(index){
		let quesData = ucEditor.getContent("option"+index);
		state.optionDataCopy[index]['answer'] = AI.ignoreEnity(quesData);
		updateProps({
			correct_answers: state.correctAnswers,
			answers: state.optionDataCopy,
		});
	}

	//Handle Delete options
	function deleteOption(index) {
		let temp = [];
		state.optionDataCopy.map((data, i)=> {
			if (i != index) {
				temp.push(data);
			}
		});
		console.log(temp);
		state.optionDataCopy = temp;
		updateProps({
			correct_answers: state.correctAnswers,
			answers: temp,
		});
		updateOptionData(temp);
	}

	// Handle addition of new options
	function addOption(index) {
		let temp1 = state.optionDataCopy;
		state.optionCounter = state.optionCounter + 1;
		temp1.push({
			answer: "Option",
			id: "id" + (state.optionCounter),
			is_correct:"0",
			seq_str:"",
			seq_tag:""
		});
		state.optionDataCopy = temp1;
		updateProps({
			correct_answers: state.correctAnswers,
			answers: temp1,
		});
		updateOptionData(temp1);
		
		tinymce.EditorManager.editors = [];//@saquib:added this line
		ucEditor.initEditor();
		setTimeout(()=> {
			ucEditor.initEditor(false, "#authoringSection .ebook_item_text");
		},1000);
	}

	// Update option's data
	function updateOptionData(data) {
		data = JSON.stringify(data);
		data  = JSON.parse(data);
		state.optionData = data;
	}

	// Handle checked
	function toggleChecked(index,e) {
		let correctAnswers = 0;
		state.optionDataCopy[index]['is_correct'] = ((e.target.checked) ? "1" : "0");
		for (let i in state.optionDataCopy) {
			if (state.optionDataCopy[i]["is_correct"] == "1") {
				correctAnswers++;
			}
		}
		state.correctAnswers = correctAnswers;
		let temp = state.optionDataCopy;
		updateOptionData(temp);
		updateProps({
			correct_answers: correctAnswers,
			answers: state.optionDataCopy,
		});
	}
</script>

<div>
	{#if (state.optionData)}
		<OptionContainer 
			toggleChecked={toggleChecked} 
			deleteOption={deleteOption} 
			editOption={editOption} 
			letters={letters} 
			correctAnswers={state.correctAnswers} 
			reviewMode={state.reviewMode} 
			data={state.optionData} 
		/>
	{/if}
	<div class="mt-lg position-relative col-12 bottom20 pl-0" style="padding-top: 8px;">
		<button 
			variant="fab" 
			color="primary"
			aria-label="Add"
			on:click={addOption}
			class="rounded d-flex align-items-center btn btn-sm btn-outline-primary pr-md"
			style="text-transform: none;"
		>
			<span class="icomoon-plus pr-1"></span>Add option
		</button> 
	</div>
</div>